nce by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Shortcut`, `Component_`, `Name`, `Target`, `Arguments`, `Description`, `Hotkey`, `ShowCmd`, `WkDir` from Shortcut" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Shortcut`=\'", wcAction, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pShortcut, wcBuf);

						PutKeyProperty ( m_pObj, pActionID, wcBuf, &bActionID, m_pRequest, 1, wcProductCode );

                        //====================================================

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pName, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pTarget, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pArguments, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 6, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pCaption, wcBuf);
                            PutProperty(m_pObj, pDescription, wcBuf);

                            PutProperty(m_pObj, pHotKey, g_fpMsiRecordGetInteger(hRecord, 7));

                            PutProperty(m_pObj, pShowCmd, g_fpMsiRecordGetInteger(hRecord, 8));

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 9, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pWkDir, wcBuf);

                        //----------------------------------------------------

                            if(bActionID) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelement.cpp ===
// SoftwareElement.cpp: implementation of the CSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareElement.h"

#include <CRegCls.h>

#include <WBEMTime.h>

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareElement::CSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareElement::~CSoftwareElement()
{

}

HRESULT CSoftwareElement::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    int iState;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcID[BUFF_SIZE];
    WCHAR wcName[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bName, bSEID, bSES, bTOS, bVersion;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component`, `ComponentId`, `Attributes` from Component" );

    INSTALLSTATE piInstalled;

	bool bGotID = false;

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"Name" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				bGotID = true;
				wcQuery.Append ( 3, L" where `Component`=\'", m_pRequest->m_Value[iPos], L"\'" );
			}
			else
			{
				int iPos = -1;

				::SysFreeString ( bstrCompare );
				bstrCompare = SysAllocString ( L"SoftwareElementID" );

				if ( bstrCompare )
				{
					if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
					{
						bGotID = true;
						wcQuery.Append ( 3, L" where `ComponentId`=\'", m_pRequest->m_Value[iPos], L"\'" );
					}

					SysFreeString ( bstrCompare );
				}
				else
				{
					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
				}
			}
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if(m_pRequest->m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
			{
                m_pRequest->LoadHive();
            }
        
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Component", FALSE, TRUE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED))
				{
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj)))
					{
						throw hr;
					}

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pName, wcBuf, &bName, m_pRequest);

                    PutProperty(m_pObj, pCaption, wcBuf);
                    PutProperty(m_pObj, pDescription, wcBuf);

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                    wcscpy(wcName, wcBuf);

                    //Check that this component exists on this system
                    if(ValidateComponentID(wcBuf, wcProductCode))
					{
                        wcscpy(wcID, wcBuf);
                        PutKeyProperty(m_pObj, pSoftwareElementID, wcID, &bSEID, m_pRequest);
                        PutProperty(m_pObj, pIdentificationCode, wcID);

                        dwBufSize = BUFF_SIZE;
                        wcscpy(wcBuf, L"");
                        piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcID, wcBuf, &dwBufSize);
                        PutProperty(m_pObj, pPath, wcBuf);

                        SoftwareElementState(piInstalled, &iState);
                        PutKeyProperty(m_pObj, pSoftwareElementState, iState, &bSES, m_pRequest);

                        PutProperty(m_pObj, pInstallState, (int)piInstalled);

                        PutKeyProperty(m_pObj, pTargetOperatingSystem, GetOS(), &bTOS, m_pRequest);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"ProductVersion", wcBuf, &dwBufSize));
                        PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);

                        PutProperty(m_pObj, pAttributes, g_fpMsiRecordGetInteger(hRecord, 3));

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"Manufacturer", wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pManufacturer, wcBuf);

                        dwBufSize = BUFF_SIZE;
                        if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,INSTALLPROPERTY_INSTALLDATE, wcBuf, &dwBufSize))
						{
							if ( ( lstrlenW ( wcBuf ) + lstrlenW ( L"000000.000000+000" ) + 1 ) < BUFF_SIZE )
							{
								lstrcatW ( wcBuf, L"000000.000000+000" );

								BSTR	bstrWbemTime;
								if ( ( bstrWbemTime	= ::SysAllocString ( wcBuf ) ) != NULL )
								{
									WBEMTime	time ( bstrWbemTime );
									::SysFreeString ( bstrWbemTime );

									if ( time.IsOk () )
									{
										bstrWbemTime= time.GetDMTF ( );

										try
										{
											PutProperty( m_pObj, pInstallDate, bstrWbemTime );
										}
										catch ( ... )
										{
											::SysFreeString ( bstrWbemTime );
											throw;
										}

										::SysFreeString ( bstrWbemTime );
									}
									else
									{
										hr = E_INVALIDARG;
									}
								}
								else
								{
									throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}
							}
							else
							{
								hr = E_FAIL;
							}
						}

                        if(bName && bSEID && bSES && bTOS && bVersion)
						{
							bMatch = true;
						}

                        if((atAction != ACTIONTYPE_GET)  || bMatch)
						{
                            hr = pHandler->Indicate(1, &m_pObj);
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
            //remove the key if it wasn't there b4....
            if(m_pRequest->m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
			{
                m_pRequest->UnloadHive();
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseProduct ();

            if(m_pObj)
			{
                m_pObj->Release();
                m_pObj = NULL;
            }

            throw;
        }

        //remove the key if it wasn't there b4....
        if(m_pRequest->m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
		{
            m_pRequest->UnloadHive();
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseProduct ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelement.h ===
// SoftwareElement.h: interface for the CSoftwareElement class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREELEMENT_H__CFD828E4_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREELEMENT_H__CFD828E4_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareElement : public CGenericClass  
{
public:
	CSoftwareElement(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareElement();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREELEMENT_H__CFD828E4_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementaction.cpp ===
// SoftwareElementAction.cpp: implementation of the CSoftwareElementAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareElementAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareElementAction::CSoftwareElementAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareElementAction::~CSoftwareElementAction()
{

}

HRESULT CSoftwareElementAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_E_FAILED;
    CRequestObject *pActionRObj = NULL;
    CRequestObject *pElementRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

            for(int i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"ACTION") == 0){

                    pActionRObj = new CRequestObject();
                    if(!pActionRObj) throw he;

                    pActionRObj->Initialize(m_pNamespace);

                    pActionRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }

                if(_wcsicmp(m_pRequest->m_Property[i], L"Element") == 0){

                    pElementRObj = new CRequestObject();
                    if(!pElementRObj) throw he;

                    pElementRObj->Initialize(m_pNamespace);

                    pElementRObj->ParsePath(m_pRequest->m_Value[i]);
                }
            }
        }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ClassInfoAction") == 0)))
            if(FAILED(hr = SoftwareElementClass(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_CreateFolderAction") == 0)))
            if(FAILED(hr = SoftwareElementCreateFolder(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_DuplicateFileAction") == 0)))
            if(FAILED(hr = SoftwareElementDuplicateFile(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ExtensionInfoAction") == 0)))
            if(FAILED(hr = SoftwareElementExtension(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_MoveFileAction") == 0)))
            if(FAILED(hr = SoftwareElementMoveFile(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_RemoveFileAction") == 0)))
            if(FAILED(hr = SoftwareElementRemoveFile(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_RegistryAction") == 0)))
            if(FAILED(hr = SoftwareElementRegistry(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_PublishComponentAction") == 0)))
            if(FAILED(hr = SoftwareElementPublish(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_RemoveIniAction") == 0)))
            if(FAILED(hr = SoftwareElementRemoveIniValue(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ShortcutAction") == 0)))
            if(FAILED(hr = SoftwareElementShortcut(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_TypeLibraryAction") == 0)))
            if(FAILED(hr = SoftwareElementTypeLibrary(pHandler, atAction, pActionRObj, pElementRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }
        if(pElementRObj){

            pElementRObj->Cleanup();
            delete pElementRObj;
            pElementRObj = NULL;
        }

    }catch(...){
            
        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }
        if(pElementRObj){

            pElementRObj->Cleanup();
            delete pElementRObj;
            pElementRObj = NULL;
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementTypeLibrary(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                           , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcLibID[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcLibID);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData)
		{
            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `LibID`, `Language` from TypeLib" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `LibID`=\'", wcLibID, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"TypeLib", TRUE, FALSE ) ) 
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_TypeLibraryAction.ActionID=\"");
								wcProp.Append ( 1, wcBuf );

                                dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementShortcut(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                        , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcShortcut[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcShortcut);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Shortcut` from Shortcut" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Shortcut`=\'", wcShortcut, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_ShortcutAction.ActionID=\"");
								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementRemoveIniValue(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                              , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcIniFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcIniFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `RemoveIniFile` from RemoveIniFile" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `RemoveIniFile`=\'", wcIniFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"RemoveIniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_RemoveIniAction.ActionID=\"");
								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementPublish(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                       , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcCompID[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcCompID);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `ComponentId`, `Qualifier` from PublishComponent" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `ComponentId`=\'", wcCompID, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"PublishComponent", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_PublishComponentAction.ActionID=\"");
								wcProp.Append ( 1, wcBuf );

                                dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementRegistry(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                        , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcRegistry[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcRegistry);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Registry` from Registry" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Registry`=\'", wcRegistry, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Registry", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_RegistryAction.ActionID=\"");
								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }
                        
                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementRemoveFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                          , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
				}
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `FileKey` from RemoveFile" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `FileKey`=\'", wcFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"RemoveFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_RemoveFileAction.ActionID=\"");
								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementMoveFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                        , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){

				if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
                	if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `FileKey` from MoveFile" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `FileKey`=\'", wcFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"MoveFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_MoveFileAction.ActionID=\"");
								wcProp.Append ( 1, wcBuf );

                                dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementExtension(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                         , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcExtension[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcExtension);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Extension` from Extension" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Extension`=\'", wcExtension, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Extension", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_ExtensionInfoAction.ActionID=\"");
								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
            
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementDuplicateFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                             , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFile);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `FileKey` from DuplicateFile" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `FileKey`=\'", wcFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}
    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"DuplicateFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_DuplicateFileAction.ActionID=\"");
								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementCreateFolder(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                            , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcFolder[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcFolder);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Directory_` from CreateFolder" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `Directory_`=\'", wcFolder, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

            bMatch = false;
			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"CreateFolder", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_CreateFolderAction.ActionID=\"");
								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);

                            //====================================================

                            //----------------------------------------------------

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementAction::SoftwareElementClass(IWbemObjectSink *pHandler, ACTIONTYPE atAction
                                                     , CRequestObject *pActionData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcCLSID[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bGotAction = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcCLSID);

						bGotAction = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){

                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `CLSID`, `Context` from Class" );

    //optimize for GetObject
    if ( bGotElement || bGotAction )
	{
		if ( bGotAction )
		{
			wcQuery.Append ( 3, L" where `CLSID`=\'", wcCLSID, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bGotAction )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Class", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcElement,
																	&dwBufSize
															   );

						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(wcscmp(wcBuf, L"") != 0)
							{
								// safe operation
                                wcProp.Copy(L"Win32_ClassInfoAction.ActionID=\"");
								wcProp.Append ( 1, wcBuf );

                                dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

								wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
								PutKeyProperty(m_pObj, pAction, wcProp, &bEnvironment, m_pRequest);
 
                            //====================================================

                            //----------------------------------------------------

                                if(bEnvironment && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }
                        
                        m_pObj->Release();
                        m_pObj = NULL;
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
			}
			catch(...)
			{
				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

				throw;
			}

			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementaction.h ===
// SoftwareElementAction.h: interface for the CSoftwareElementAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREELEMENTACTION_H__52002680_D70A_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREELEMENTACTION_H__52002680_D70A_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CSoftwareElementAction : public CGenericClass  
{
public:
	CSoftwareElementAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareElementAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT SoftwareElementClass(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementCreateFolder(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementDuplicateFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementExtension(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementMoveFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementRemoveFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementRegistry(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementPublish(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementRemoveIniValue(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementShortcut(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
	HRESULT SoftwareElementTypeLibrary(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
		CRequestObject *pActionData, CRequestObject *pElementData);
};

#endif // !defined(AFX_SOFTWAREELEMENTACTION_H__52002680_D70A_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementcheck.h ===
// SoftwareElementCheck.h: interface for the CSoftwareElementCheck class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREELEMENTCHECK_H__067CD9F0_D70D_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREELEMENTCHECK_H__067CD9F0_D70D_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CSoftwareElementCheck : public CGenericClass  
{
public:
	CSoftwareElementCheck(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareElementCheck();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT SoftwareElementFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
	HRESULT SoftwareElementIniFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
	HRESULT SoftwareElementReserveCost(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
	HRESULT SoftwareElementEnvironment(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
	HRESULT ODBCTranslatorSoftwareElement(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
	HRESULT ODBCDataSourceSoftwareElement(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
								CRequestObject *pCheckData,CRequestObject *pElementData);
};

#endif // !defined(AFX_SOFTWAREELEMENTCHECK_H__067CD9F0_D70D_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementcheck.cpp ===
// SoftwareElementCheck.cpp: implementation of the CSoftwareElementCheck class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareElementCheck.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareElementCheck::CSoftwareElementCheck(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareElementCheck::~CSoftwareElementCheck()
{

}

HRESULT CSoftwareElementCheck::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_E_FAILED;
    CRequestObject *pCheckRObj = NULL;
    CRequestObject *pElementRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

            for(int i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"CHECK") == 0){

                    pCheckRObj = new CRequestObject();
                    if(!pCheckRObj) throw he;

                    pCheckRObj->Initialize(m_pNamespace);

                    pCheckRObj->ParsePath(m_pRequest->m_Value[i]);
                    break;
                }

                if(_wcsicmp(m_pRequest->m_Property[i], L"Element") == 0){

                    pElementRObj = new CRequestObject();
                    if(!pElementRObj) throw he;

                    pElementRObj->Initialize(m_pNamespace);

                    pElementRObj->ParsePath(m_pRequest->m_Value[i]);
                }
            }
        }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_FileSpecification") == 0)))
            if(FAILED(hr = SoftwareElementFile(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_IniFileSpecification") == 0)))
            if(FAILED(hr = SoftwareElementIniFile(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_ReserveCost") == 0)))
            if(FAILED(hr = SoftwareElementReserveCost(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_EnvironmentSpecification") == 0)))
            if(FAILED(hr = SoftwareElementEnvironment(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_ODBCTranslatorSpecification") == 0)))
            if(FAILED(hr = ODBCTranslatorSoftwareElement(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pElementRObj ||
            (pCheckRObj && pCheckRObj->m_bstrClass && (_wcsicmp(pCheckRObj->m_bstrClass, L"Win32_ODBCDataSourceSpecification") == 0)))
            if(FAILED(hr = ODBCDataSourceSoftwareElement(pHandler, atAction, pCheckRObj, pElementRObj))){

                if(pCheckRObj){

                    pCheckRObj->Cleanup();
                    delete pCheckRObj;
                    pCheckRObj = NULL;
                }
                if(pElementRObj){

                    pElementRObj->Cleanup();
                    delete pElementRObj;
                    pElementRObj = NULL;
                }
                return hr;
            }

        if(pCheckRObj){

            pCheckRObj->Cleanup();
            delete pCheckRObj;
            pCheckRObj = NULL;
        }
        if(pElementRObj){

            pElementRObj->Cleanup();
            delete pElementRObj;
            pElementRObj = NULL;
        }

    }catch(...){
            
        if(pCheckRObj){

            pCheckRObj->Cleanup();
            delete pCheckRObj;
            pCheckRObj = NULL;
        }
        if(pElementRObj){

            pElementRObj->Cleanup();
            delete pElementRObj;
            pElementRObj = NULL;
        }
    }

    return hr;
}

HRESULT CSoftwareElementCheck::ODBCDataSourceSoftwareElement(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData, CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcDataSource[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcDataSource);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `DataSource` from ODBCDataSource" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `DataSource`=\'", wcDataSource, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCDataSource", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

								if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
									wcProp.Copy(L"Win32_ODBCDataSourceSpecification.CheckID=\"");
									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bFeature, m_pRequest);

									if(bFeature && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

						uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementCheck::ODBCTranslatorSoftwareElement(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData,CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcTestCode[39];
    WCHAR wcProductCode[39];
    WCHAR wcTranslator[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcTranslator);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Translator` from ODBCTranslator" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `Translator`=\'", wcTranslator, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ODBCTranslator", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

								if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
									wcProp.Copy(L"Win32_ODBCTranslatorSpecification.CheckID=\"");
									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bFeature, m_pRequest);

									if(bFeature && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementCheck::SoftwareElementEnvironment(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData,CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcEnvironment[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcEnvironment);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Environment` from Environment" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `Environment`=\'", wcEnvironment, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Environment", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

								if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
									wcProp.Copy(L"Win32_EnvironmentSpecification.CheckID=\"");
									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bEnvironment, m_pRequest);

									//====================================================
									/*
									dwBufSize = BUFF_SIZE;
									CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
									PutProperty(m_pObj, pName, wcBuf);

									dwBufSize = BUFF_SIZE;
									CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
									PutProperty(m_pObj, pValue, wcBuf);
									*/
									//----------------------------------------------------

									if(bEnvironment && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementCheck::SoftwareElementReserveCost(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData,CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcReserve[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcReserve);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `ReserveKey` from ReserveCost" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `ReserveKey`=\'", wcReserve, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));
        
        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"ReserveCost", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

								if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
									wcProp.Copy(L"Win32_ReserveCost.CheckID=\"");
									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bEnvironment, m_pRequest);

									if(bEnvironment && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;
                    
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementCheck::SoftwareElementIniFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData,CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcIniFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcIniFile);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `IniFile` from IniFile" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `IniFile`=\'", wcIniFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"IniFile", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

								if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
									wcProp.Copy(L"Win32_IniFileSpecification.CheckID=\"");
									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bEnvironment, m_pRequest);

									if(bEnvironment && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}
                        
                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareElementCheck::SoftwareElementFile(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                             CRequestObject *pCheckData,CRequestObject *pElementData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcFile[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    UINT uiStatus;
    WCHAR wcElement[BUFF_SIZE];
    bool bCheck = false;
    bool bGotElement = false;

	CStringExt wcProp;

    if(atAction != ACTIONTYPE_ENUM){

        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pCheckData){

            for(int i = 0; i < pCheckData->m_iPropCount; i++){
                
                if(_wcsicmp(pCheckData->m_Property[i], L"CheckID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pCheckData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pCheckData->m_Value[i], wcFile);

						bCheck = true;
						bTestCode = true;
						break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pElementData){

            for(int j = 0; j < pElementData->m_iPropCount; j++){
                
                if(_wcsicmp(pElementData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pElementData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcElement, pElementData->m_Value[j]);
						bGotElement = true;
	                    break;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bEnvironment, bElement;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `File` from File" );

    //optimize for GetObject
    if ( bGotElement || bCheck )
	{
		if ( bCheck )
		{
			wcQuery.Append ( 3, L" where `File`=\'", wcFile, L"\'" );
		}

		if ( bGotElement )
		{
			if ( bCheck )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || bGotElement ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"File", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase(), wcProductCode, wcBuf ) )
						{
							dwBufSize = BUFF_SIZE;
							uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																		wcBuf,
																		wcProductCode,
																		wcElement,
																		&dwBufSize
																   );

							if( uiStatus == ERROR_SUCCESS )
							{
								PutKeyProperty(m_pObj, pElement, wcElement, &bElement, m_pRequest);

								dwBufSize = BUFF_SIZE;
								CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

								if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
									wcProp.Copy(L"Win32_FileSpecification.CheckID=\"");
									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pCheck, wcProp, &bEnvironment, m_pRequest);

									if(bEnvironment && bElement) bMatch = true;

									if((atAction != ACTIONTYPE_GET)  || bMatch){

										hr = pHandler->Indicate(1, &m_pObj);
									}
								}
							}
						}

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementcondition.cpp ===
// SoftwareElementCondition.cpp: implementation of the CSoftwareElementCondition class.

//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved 
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareElementCondition.h"

#include "ExtendString.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareElementCondition::CSoftwareElementCondition(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareElementCondition::~CSoftwareElementCondition()
{

}

HRESULT CSoftwareElementCondition::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcTmp[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    int iState;

	CStringExt wcProp;

    //These will change from class to class
    bool bCheck, bNull;
    INSTALLSTATE piInstalled;

    SetSinglePropertyPath(L"CheckID");

    WCHAR wcTestCode[39];

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"CheckID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Component`, `ComponentId`, `Condition` from Component");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (_wcsicmp(wcTestCode, wcProductCode) == 0))
		{
			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Component", FALSE, TRUE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pName, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);

                        wcProp.Copy ( wcBuf );      

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        dwBufSize = BUFF_SIZE;
                        piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcBuf, wcTmp, &dwBufSize);

                        SoftwareElementState(piInstalled, &iState);
                        PutProperty(m_pObj, pSoftwareElementState, iState);

                        if(ValidateComponentID(wcBuf, wcProductCode)){

                            PutProperty(m_pObj, pSoftwareElementID, wcBuf);

                            PutProperty(m_pObj, pTargetOperatingSystem, GetOS());

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"ProductVersion", wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pVersion, wcBuf);
                        //====================================================

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            if(0 == wcscmp(wcBuf, L"")) bNull = true;
                            else bNull = false;

                            PutProperty(m_pObj, pCondition, wcBuf);

							wcProp.Append ( 2, wcBuf, wcProductCode );
							PutKeyProperty(m_pObj, pCheckID, wcProp, &bCheck, m_pRequest);

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if(((atAction != ACTIONTYPE_GET) || bMatch) && !bNull){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseProduct ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseProduct ();
		}
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementservicecontrol.cpp ===
// SoftwareElementServiceControl.cpp: implementation of the CSoftwareElementServiceControl class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareElementServiceControl.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareElementServiceControl::CSoftwareElementServiceControl(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareElementServiceControl::~CSoftwareElementServiceControl()
{

}

HRESULT CSoftwareElementServiceControl::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bEnvironment, bElement;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Component_`, `ServiceControl` from ServiceControl");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"ServiceControl", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

					dwBufSize = BUFF_SIZE;
					uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																wcBuf,
																wcProductCode,
																wcProp,
																&dwBufSize
														   );

                    if( uiStatus == ERROR_SUCCESS )
					{
                        PutKeyProperty(m_pObj, pElement, wcProp, &bElement, m_pRequest);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if(wcscmp(wcBuf, L"") != 0)
						{
							DWORD dwConstant = 0L;
							DWORD dwBuf = 0L;
							DWORD dwProductCode = 0L;

							dwBuf = wcslen ( wcBuf );
							dwProductCode = wcslen ( wcProductCode );

							dwConstant = wcslen ( L"Win32_ServiceControl.ID=\"" ) + wcslen ( L"\",ProductCode=\"" ) + wcslen ( L"\"" );

							if ( dwConstant + dwBuf + dwProductCode + 1 < BUFF_SIZE )
							{
								wcscpy(wcProp, L"Win32_ServiceControl.ID=\"");
								wcscat(wcProp, wcBuf);
								wcscat(wcProp, L"\",ProductCode=\"");
								wcscat(wcProp, wcProductCode);
								wcscat(wcProp, L"\"");

								PutKeyProperty(m_pObj, pSetting, wcProp, &bEnvironment, m_pRequest);
							}
							else
							{
								LPWSTR wsz = NULL;

								try
								{
									if ( ( wsz = new WCHAR [ dwConstant + dwBuf + dwProductCode + 1 ] ) != NULL )
									{
										wcscpy ( wsz, L"Win32_ServiceControl.ID=\"" );
										wcscat ( wsz, wcBuf );
										wcscat ( wsz, L"\",ProductCode=\"" );
										wcscat ( wsz, wcProductCode );
										wcscat ( wsz, L"\"" );

										PutKeyProperty ( m_pObj, pSetting, wsz, &bEnvironment, m_pRequest );
									}
									else
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wsz )
									{
										delete [] wsz;
										wsz = NULL;
									}

									throw;
								}

								if ( wsz )
								{
									delete [] wsz;
									wsz = NULL;
								}
							}

                            if(bEnvironment && bElement) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
        }
		catch(...)
		{
            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

            throw;
        }

        g_fpMsiCloseHandle(hRecord);
        g_fpMsiViewClose(hView);
        g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementcondition.h ===
// SoftwareElementCondition.h: interface for the CSoftwareElementCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREELEMENTCONDITION_H__02FF6C8D_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREELEMENTCONDITION_H__02FF6C8D_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareElementCondition : public CGenericClass  
{
public:
	CSoftwareElementCondition(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareElementCondition();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREELEMENTCONDITION_H__02FF6C8D_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwareelementservicecontrol.h ===
// SoftwareElementServiceControl.h: interface for the CSoftwareElementServiceControl class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREELEMENTSERVICECONTROL_H__72CDD5DA_2313_11D2_BF95_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREELEMENTSERVICECONTROL_H__72CDD5DA_2313_11D2_BF95_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareElementServiceControl : public CGenericClass  
{
public:
	CSoftwareElementServiceControl(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareElementServiceControl();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREELEMENTSERVICECONTROL_H__72CDD5DA_2313_11D2_BF95_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeature.cpp ===
// SoftwareFeature.cpp: implementation of the CSoftwareFeature class.

//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareFeature.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareFeature::CSoftwareFeature(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareFeature::~CSoftwareFeature()
{

}

HRESULT CSoftwareFeature::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    int i = -1;
    int iEnum;
    long lDate;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcName[BUFF_SIZE];
    WCHAR wcParent[BUFF_SIZE];
    WCHAR wcDesc[BUFF_SIZE];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    WCHAR wcProductCode[39];
    DWORD dwBufSize;
    DWORD dwBufSize2;
    DWORD dwCount;
    DWORD dwAttrib;
    WORD wDate;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bFeature, bName, bVersion = false , bIDNum, bProductHandle;
    INSTALLSTATE piInstalled;

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED)){

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database
        
        try
		{
            if ( GetView ( NULL, wcProductCode, NULL, NULL, FALSE, TRUE ) )
			{
				bProductHandle = true;
			}
            else
			{
				bProductHandle = false;
			}

            iEnum = 0;

			// try to get available feature
			do
			{
				uiStatus = g_fpMsiEnumFeaturesW(wcProductCode, iEnum++, wcName, wcParent);
			}
			while ( uiStatus == ERROR_MORE_DATA );

            while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){

                CheckMSI(uiStatus);

                if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    
                dwBufSize = BUFF_SIZE;
                CheckMSI(g_fpMsiGetProductInfoW(wcProductCode,
#if defined(_UNICODE)
                    INSTALLPROPERTY_PRODUCTNAME
#else
                    TcharToWchar(INSTALLPROPERTY_PRODUCTNAME, wcTmp)
#endif
                    , wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pProductName, wcBuf, &bName, m_pRequest);

                dwBufSize = BUFF_SIZE;
                if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,
#if defined(_UNICODE)
                    INSTALLPROPERTY_VERSIONSTRING
#else
                    TcharToWchar(INSTALLPROPERTY_VERSIONSTRING, wcTmp)
#endif
                    , wcBuf, &dwBufSize))
                    PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
                else{
                    dwBufSize = BUFF_SIZE;
                    if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,
#if defined(_UNICODE)
                        INSTALLPROPERTY_VERSION
#else
                        TcharToWchar(INSTALLPROPERTY_VERSION, wcTmp)
#endif
                        , wcBuf, &dwBufSize))
                        PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
                }

                if ( bProductHandle )
				{
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"Manufacturer", wcBuf, &dwBufSize));
                    PutProperty(m_pObj, pVendor, wcBuf);

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct(), L"ProductVersion", wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pVersion, wcBuf, &bVersion, m_pRequest);
                }

                PutKeyProperty(m_pObj, pIdentifyingNumber, wcProductCode, &bIDNum, m_pRequest);

                dwBufSize = BUFF_SIZE;
                PutKeyProperty(m_pObj, pName, wcName, &bFeature, m_pRequest);

            //====================================================

                piInstalled = g_fpMsiQueryFeatureStateW(m_pRequest->Package(i), wcName);

                PutProperty(m_pObj, pInstallState, (int)piInstalled);

                if(ERROR_SUCCESS == g_fpMsiGetFeatureUsageW(wcProductCode, wcName, &dwCount, &wDate)){

                    PutProperty(m_pObj, pAccesses, (int)dwCount);

                    lDate = (1980 + ((wDate & 65024) >> 9)) * 10000;
                    lDate += ((wDate & 480) >> 5) * 100;
                    lDate += (wDate & 31 );

					//safe operation
                    _ltow(lDate, wcBuf, 10);
                    wcscat(wcBuf, L"******.000000+***");
                    PutProperty(m_pObj, pLastUse, wcBuf);
                }

				if ( bProductHandle )
				{
					dwBufSize = dwBufSize2 = BUFF_SIZE;
					if ( ERROR_SUCCESS == g_fpMsiGetFeatureInfoW (	msidata.GetProduct (),
																	wcName,
																	&dwAttrib,
																	wcBuf,
																	&dwBufSize,
																	wcDesc,
																	&dwBufSize2
																 )
					   )
					{
						PutProperty(m_pObj, pDescription, wcDesc);
						PutProperty(m_pObj, pCaption, wcBuf);
						PutProperty(m_pObj, pAttributes, (int)dwAttrib);
					}
					else
					{
						PutProperty(m_pObj, pDescription, wcName);
						PutProperty(m_pObj, pCaption, wcName);
					}
				}
				else
				{
					PutProperty(m_pObj, pDescription, wcName);
					PutProperty(m_pObj, pCaption, wcName);
				}

            //----------------------------------------------------

                if(bFeature && bName && bVersion && bIDNum) bMatch = true;

                if((atAction != ACTIONTYPE_GET)  || bMatch){

                    hr = pHandler->Indicate(1, &m_pObj);
                }

                m_pObj->Release();
                m_pObj = NULL;

				// try to get available feature
				do
				{
					uiStatus = g_fpMsiEnumFeaturesW(wcProductCode, iEnum++, wcName, wcParent);
				}
				while ( uiStatus == ERROR_MORE_DATA );
            }
        }
		catch(...)
		{
			msidata.CloseProduct ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}
            
            throw;
        }

		msidata.CloseProduct ();
    }

    return hr;
}

bool CSoftwareFeature::CheckUsage(UINT uiStatus)
{
    switch(uiStatus){

    case ERROR_BAD_CONFIGURATION:
        throw WBEM_E_FAILED;

    case ERROR_INSTALL_FAILURE:
        return false;

    case ERROR_SUCCESS:
        return true;

    default:
        return false;
    }

    return false;
}

HRESULT CSoftwareFeature::Configure(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                                    IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    int iState;
    UINT uiStatus = 1603;
    WCHAR wcCode[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrConfigure = SysAllocString(L"Configure");
    if(!bstrConfigure)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;
    INSTALLSTATE isState;
    int i = -1;
    bool bFoundCode = false;
    bool bFoundFeature = false;

    if(SUCCEEDED(hr = pReqObj->m_pNamespace->GetObject(pReqObj->m_bstrClass, 0, pCtx, &pClass, NULL)))
    {
        if(SUCCEEDED(hr = pClass->GetMethod(bstrConfigure, 0, NULL, &pOutClass)))
        {
            if(SUCCEEDED(hr = pOutClass->SpawnInstance(0, &pOutParams)))
            {
                //Get PackageLocation
                if(!SUCCEEDED(GetProperty(pInParams, "InstallState", &iState)))
                    hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                //Get the Product Code
                while(pReqObj->m_Property[++i])
				{
                    if(wcscmp(pReqObj->m_Property[i], L"IdentifyingNumber") == 0)
					{
						if ( wcslen (pReqObj->m_Value[i]) < BUFF_SIZE )
						{
							wcscpy(wcCode, pReqObj->m_Value[i]);
							bFoundCode = true;
							break;
						}
                    }   
                }

                //Get the Feature Name
                i = -1;
                while(pReqObj->m_Property[++i])
				{
                    if(wcscmp(pReqObj->m_Property[i], L"Name") == 0)
					{
						if ( wcslen (pReqObj->m_Value[i]) < BUFF_SIZE )
						{
							wcscpy(wcFeature, pReqObj->m_Value[i]);
							bFoundFeature = true;
							break;
						}
                    }   
                }

                if(bFoundCode && bFoundFeature){
                    //Get the appropriate State
                    switch(iState){
                    case 1:
                        isState = INSTALLSTATE_DEFAULT;
                        break;
                    case 2:
                        isState = INSTALLSTATE_ADVERTISED;
                        break;
                    case 3:
                        isState = INSTALLSTATE_LOCAL;
                        break;
                    case 4:
                        isState = INSTALLSTATE_ABSENT;
                        break;
                    case 5:
                        isState = INSTALLSTATE_SOURCE;
                        break;
                    default:
                        isState = INSTALLSTATE_NOTUSED;
                        break;
                    }

                    //If everything is valid, proceed
                    if((isState != INSTALLSTATE_NOTUSED) && (hrReturn == WBEM_S_NO_ERROR)){

                        if(!IsNT4()){

							if ( msidata.Lock () )
							{
								INSTALLUI_HANDLER ui = NULL;

								//Set UI Level w/ event callback
								ui = SetupExternalUI ( );

								try
								{
									//Call Installer
									uiStatus = g_fpMsiConfigureFeatureW(wcCode, wcFeature, isState);
								}
								catch(...)
								{
									uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
								}

								//Restore UI Level w/ event callback
								RestoreExternalUI ( ui );

								msidata. Unlock();
							}

                        }else{

                        /////////////////
                        // NT4 fix code....

                            try{

                                WCHAR wcAction[20];
                                wcscpy(wcAction, L"/sfconfigure");

                                WCHAR wcTmp[100];
								_itow((int)isState, wcTmp, 10);

								LPWSTR wcCommandLine = NULL;

								try
								{
									if ( ( wcCommandLine = new WCHAR [ wcslen ( wcCode ) + wcslen ( wcFeature ) + 3 + wcslen ( wcTmp ) ] ) != NULL )
									{
										wcscpy(wcCommandLine, wcCode);
										wcscat(wcCommandLine, L" ");
										wcscat(wcCommandLine, wcFeature);
										wcscat(wcCommandLine, L" ");
										wcscat(wcCommandLine, wcTmp);

										hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

										delete [] wcCommandLine;
									}
									else
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wcCommandLine )
									{
										delete [] wcCommandLine;
										wcCommandLine = NULL;
									}

									hrReturn = E_OUTOFMEMORY;
								}

                            }catch(...){

                                hrReturn = WBEM_E_FAILED;
                            }

                            ////////////////////

                        }

                        if(SUCCEEDED(hrReturn)){

                            //Set up ReturnValue
                            VariantInit(&v);
                            V_VT(&v) = VT_I4;
                            V_I4(&v) = uiStatus;

                            BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                            if(!bstrReturnValue)
                                throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

                            if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                &v, NULL)))
                                pHandler->Indicate(1, &pOutParams);

                            SysFreeString(bstrReturnValue);
                        }

                    }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                }else hr = WBEM_E_FAILED;

                pOutParams->Release();

            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

            pOutClass->Release();
        }

        pClass->Release();
    }

    SysFreeString(bstrReturnValue);
    SysFreeString(bstrConfigure);

    return hrReturn;
}

HRESULT CSoftwareFeature::Reinstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
                                    IWbemObjectSink *pHandler, IWbemContext *pCtx)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hrReturn = WBEM_S_NO_ERROR;
    int iMode;
    UINT uiStatus = 1603;
    WCHAR wcCode[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    BSTR bstrReturnValue = SysAllocString(L"ReturnValue");
    if(!bstrReturnValue) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

    BSTR bstrReinstall = SysAllocString(L"Reinstall");
    if(!bstrReinstall)
	{
		::SysFreeString (bstrReturnValue);
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    IWbemClassObject *pClass = NULL;
    IWbemClassObject *pOutClass = NULL;
    IWbemClassObject *pOutParams = NULL;
    VARIANT v;
    DWORD dwMode;
    int i = -1;
    bool bFoundCode = false;
    bool bFoundFeature = false;

    if(SUCCEEDED(hr = pReqObj->m_pNamespace->GetObject(pReqObj->m_bstrClass, 0, pCtx, &pClass, NULL))){
        if(SUCCEEDED(hr = pClass->GetMethod(bstrReinstall, 0, NULL, &pOutClass))){
            if(SUCCEEDED(hr = pOutClass->SpawnInstance(0, &pOutParams))){
                //Get Reinstall Mode
                if(!SUCCEEDED(GetProperty(pInParams, "ReinstallMode", &iMode)))
                    hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                //Get the Product Code
                while(pReqObj->m_Property[++i])
				{
                    if(wcscmp(pReqObj->m_Property[i], L"IdentifyingNumber") == 0)
					{
						if ( wcslen (pReqObj->m_Value[i]) < BUFF_SIZE )
						{
							wcscpy(wcCode, pReqObj->m_Value[i]);
							bFoundCode = true;
							break;
						}
                    }   
                }

                //Get the Feature Name
                i = -1;
                while(pReqObj->m_Property[++i])
				{
                    if(wcscmp(pReqObj->m_Property[i], L"Name") == 0)
					{
						if ( wcslen (pReqObj->m_Value[i]) < BUFF_SIZE )
						{
							wcscpy(wcFeature, pReqObj->m_Value[i]);
							bFoundFeature = true;
							break;
						}
                    }   
                }

                if(bFoundCode && bFoundFeature){
                    //Get the appropriate ReinstallMode
                    switch(iMode){
                    case 1:
                        dwMode = REINSTALLMODE_FILEMISSING;
                        break;
                    case 2:
                        dwMode = REINSTALLMODE_FILEOLDERVERSION;
                        break;
                    case 3:
                        dwMode = REINSTALLMODE_FILEEQUALVERSION;
                        break;
                    case 4:
                        dwMode = REINSTALLMODE_FILEEXACT;
                        break;
                    case 5:
                        dwMode = REINSTALLMODE_FILEVERIFY;
                        break;
                    case 6:
                        dwMode = REINSTALLMODE_FILEREPLACE;
                        break;
                    case 7:
                        dwMode = REINSTALLMODE_USERDATA;
                        break;
                    case 8:
                        dwMode = REINSTALLMODE_MACHINEDATA;
                        break;
                    case 9:
                        dwMode = REINSTALLMODE_SHORTCUT;
                        break;
                    case 10:
                        dwMode = REINSTALLMODE_PACKAGE;
                        break;
                    default:
                        dwMode = NULL;
                        break;
                    }

                    //If everything is valid, proceed
                    if ( dwMode && hrReturn == WBEM_S_NO_ERROR )
					{
                        if(!IsNT4()){

							if ( msidata.Lock () )
							{
								INSTALLUI_HANDLER ui = NULL;

								//Set UI Level w/ event callback
								ui = SetupExternalUI ( );

								try
								{
									//Call Installer
									uiStatus = g_fpMsiReinstallFeatureW(wcCode, wcFeature, dwMode);
								}
								catch(...)
								{
									uiStatus = static_cast < UINT > ( RPC_E_SERVERFAULT );
								}

								//Restore UI Level w/ event callback
								RestoreExternalUI ( ui );

								msidata. Unlock();
							}

                        }else{

                        /////////////////
                        // NT4 fix code....

                            try{

                                WCHAR wcAction[20];
                                wcscpy(wcAction, L"/sfreinstall");

                                WCHAR wcTmp[100];
								_itow((int)dwMode, wcTmp, 10);

								LPWSTR wcCommandLine = NULL;

								try
								{
									if ( ( wcCommandLine = new WCHAR [ wcslen ( wcCode ) + wcslen ( wcFeature ) + 3 + wcslen ( wcTmp ) ] ) != NULL )
									{
										wcscpy(wcCommandLine, wcCode);
										wcscat(wcCommandLine, L" ");
										wcscat(wcCommandLine, wcFeature);
										wcscat(wcCommandLine, L" ");
										wcscat(wcCommandLine, wcTmp);

										hrReturn = LaunchProcess(wcAction, wcCommandLine, &uiStatus);

										delete [] wcCommandLine;
									}
									else
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wcCommandLine )
									{
										delete [] wcCommandLine;
										wcCommandLine = NULL;
									}

									hrReturn = E_OUTOFMEMORY;
								}

                            }catch(...){

                                hrReturn = WBEM_E_FAILED;
                            }

                            ////////////////////

                        }

                        if(SUCCEEDED(hrReturn)){

                            //Set up ReturnValue
                            VariantInit(&v);
                            V_VT(&v) = VT_I4;
                            V_I4(&v) = uiStatus;

                            BSTR bstrReturnValue = SysAllocString(L"ReturnValue");

                            if(!bstrReturnValue)
                                throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

                            if(SUCCEEDED(hrReturn = pOutParams->Put(bstrReturnValue, 0,
                                &v, NULL)))
                                pHandler->Indicate(1, &pOutParams);

                            SysFreeString(bstrReturnValue);
                        }

                    }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

                }else hr = WBEM_E_FAILED;

                pOutParams->Release();

            }else hrReturn = WBEM_E_INVALID_METHOD_PARAMETERS;

            pOutClass->Release();
        }

        pClass->Release();
    }

    SysFreeString(bstrReturnValue);
    SysFreeString(bstrReinstall);

    return hrReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeatureaction.h ===
// SoftwareFeatureAction.h: interface for the CSoftwareFeatureAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREFEATUREACTION_H__01FCD010_D70E_11D2_B235_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREFEATUREACTION_H__01FCD010_D70E_11D2_B235_00A0C9954921__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "GenericClass.h"

class CSoftwareFeatureAction : public CGenericClass  
{
public:
	CSoftwareFeatureAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareFeatureAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	HRESULT SoftwareFeatureClassInfo(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pFeatureData);
	HRESULT SoftwareFeatureExtension(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pFeatureData);
	HRESULT SoftwareFeaturePublish(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pFeatureData);
	HRESULT SoftwareFeatureShortcut(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pFeatureData);
	HRESULT SoftwareFeatureTypeLibrary(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
									 CRequestObject *pActionData, CRequestObject *pFeatureData);
};

#endif // !defined(AFX_SOFTWAREFEATUREACTION_H__01FCD010_D70E_11D2_B235_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeature.h ===
// SoftwareFeature.h: interface for the CSoftwareFeature class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREFEATURE_H__CFD828E3_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREFEATURE_H__CFD828E3_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareFeature : public CGenericClass  
{
public:
	CSoftwareFeature(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareFeature();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	//WBEM Methods
	HRESULT Configure(CRequestObject *pReqObj, IWbemClassObject *pInParams,
					  IWbemObjectSink *pHandler, IWbemContext *pCtx);
	HRESULT Reinstall(CRequestObject *pReqObj, IWbemClassObject *pInParams,
					  IWbemObjectSink *pHandler, IWbemContext *pCtx);

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);

protected:
	bool CheckUsage(UINT uiStatus);
};

#endif // !defined(AFX_SOFTWAREFEATURE_H__CFD828E3_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeatureaction.cpp ===
// SoftwareFeatureAction.cpp: implementation of the CSoftwareFeatureAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareFeatureAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareFeatureAction::CSoftwareFeatureAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareFeatureAction::~CSoftwareFeatureAction()
{

}

HRESULT CSoftwareFeatureAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    CRequestObject *pActionRObj = NULL;
    CRequestObject *pFeatureRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

            for(int i = 0; i < m_pRequest->m_iPropCount; i++){
                
                if(_wcsicmp(m_pRequest->m_Property[i], L"ACTION") == 0){

                    pActionRObj = new CRequestObject();
                    if(!pActionRObj) throw he;

                    pActionRObj->Initialize(m_pNamespace);

                    pActionRObj->ParsePath(m_pRequest->m_Value[i]);
                }

                if(_wcsicmp(m_pRequest->m_Property[i], L"Element") == 0){

                    pFeatureRObj = new CRequestObject();
                    if(!pFeatureRObj) throw he;

                    pFeatureRObj->Initialize(m_pNamespace);

                    pFeatureRObj->ParsePath(m_pRequest->m_Value[i]);
                }
            }
        }

        if((atAction == ACTIONTYPE_ENUM) || pFeatureRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ClassInfoAction") == 0)))
            if(FAILED(hr = SoftwareFeatureClassInfo(pHandler, atAction, pActionRObj, pFeatureRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pFeatureRObj){

                    pFeatureRObj->Cleanup();
                    delete pFeatureRObj;
                    pFeatureRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pFeatureRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ExtensionInfoAction") == 0)))
            if(FAILED(hr = SoftwareFeatureExtension(pHandler, atAction, pActionRObj, pFeatureRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pFeatureRObj){

                    pFeatureRObj->Cleanup();
                    delete pFeatureRObj;
                    pFeatureRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pFeatureRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_PublishComponentAction") == 0)))
            if(FAILED(hr = SoftwareFeaturePublish(pHandler, atAction, pActionRObj, pFeatureRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pFeatureRObj){

                    pFeatureRObj->Cleanup();
                    delete pFeatureRObj;
                    pFeatureRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pFeatureRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_ShortcutAction") == 0)))
            if(FAILED(hr = SoftwareFeatureShortcut(pHandler, atAction, pActionRObj, pFeatureRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pFeatureRObj){

                    pFeatureRObj->Cleanup();
                    delete pFeatureRObj;
                    pFeatureRObj = NULL;
                }
                return hr;
            }

        if((atAction == ACTIONTYPE_ENUM) || pFeatureRObj ||
            (pActionRObj && pActionRObj->m_bstrClass && (_wcsicmp(pActionRObj->m_bstrClass, L"Win32_TypeLibraryAction") == 0)))
            if(FAILED(hr = SoftwareFeatureTypeLibrary(pHandler, atAction, pActionRObj, pFeatureRObj))){

                if(pActionRObj){

                    pActionRObj->Cleanup();
                    delete pActionRObj;
                    pActionRObj = NULL;
                }
                if(pFeatureRObj){

                    pFeatureRObj->Cleanup();
                    delete pFeatureRObj;
                    pFeatureRObj = NULL;
                }
                return hr;
            }

        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }
        if(pFeatureRObj){

            pFeatureRObj->Cleanup();
            delete pFeatureRObj;
            pFeatureRObj = NULL;
        }

    }catch(...){
            
        if(pActionRObj){

            pActionRObj->Cleanup();
            delete pActionRObj;
            pActionRObj = NULL;
        }
        if(pFeatureRObj){

            pFeatureRObj->Cleanup();
            delete pFeatureRObj;
            pFeatureRObj = NULL;
        }
    }

    return hr;
}

HRESULT CSoftwareFeatureAction::SoftwareFeatureTypeLibrary(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                           CRequestObject *pActionData, CRequestObject *pFeatureData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcLibID[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    bool bTypeLib = false;
    bool bGotFeature = false;
    UINT uiStatus;

    if(atAction != ACTIONTYPE_ENUM)
	{
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcLibID);

						bTypeLib = true;
						bTestCode = true;
	                    break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pFeatureData)
		{
            for(int j = 0; j < pFeatureData->m_iPropCount; j++){
                
                if(_wcsicmp(pFeatureData->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pFeatureData->m_Value[j]);
						bTestCode = true;
					}
                }

                if(_wcsicmp(pFeatureData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcFeature, pFeatureData->m_Value[j]);
						bGotFeature = true;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bAction;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Feature_`, `LibID`, `Language`, `Component_` from TypeLib" );

    if(atAction != ACTIONTYPE_ENUM)
	{
        //optimize for GetObject
        if(bTypeLib || bGotFeature)
		{
			if ( bTypeLib )
			{
				wcQuery.Append ( 3, L" where `LibID`=\'", wcLibID, L"\'" );
			}

			if ( bGotFeature )
			{
				if ( bTypeLib )
				{
					wcQuery.Append ( 3, L" or `Feature_`=\'", wcFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Feature_`=\'", wcFeature, L"\'" );
				}
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"TypeLib", TRUE, FALSE ) )
				{

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                            if ( CreateSoftwareFeatureString(wcBuf, wcProductCode, wcFeature, true) )
							{
                                PutKeyProperty(m_pObj, pElement, wcFeature, &bFeature, m_pRequest);

                                dwBufSize = BUFF_SIZE;
                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
                                    wcProp.Copy ( L"Win32_TypeLibraryAction.ActionID=\"" );
									wcProp.Append ( 1, wcBuf );

                                    dwBufSize = BUFF_SIZE;
                                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"");
									PutKeyProperty(m_pObj, pAction, wcProp, &bAction, m_pRequest);

                                //----------------------------------------------------

                                    if(bFeature && bAction) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareFeatureAction::SoftwareFeatureShortcut(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                           CRequestObject *pActionData, CRequestObject *pFeatureData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcShortcut[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    bool bShortcut = false;
    bool bGotFeature = false;
    UINT uiStatus;

    if(atAction != ACTIONTYPE_ENUM)
	{
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcShortcut);

						bShortcut = true;
						bTestCode = true;
	                    break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pFeatureData)
		{
            for(int j = 0; j < pFeatureData->m_iPropCount; j++){
                
                if(_wcsicmp(pFeatureData->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pFeatureData->m_Value[j]);
						bTestCode = true;
 					}
               }

                if(_wcsicmp(pFeatureData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcFeature, pFeatureData->m_Value[j]);
						bGotFeature = true;
 					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bAction;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Target`, `Shortcut`, `Component_` from Shortcut" );

    if(atAction != ACTIONTYPE_ENUM)
	{
        //optimize for GetObject
        if(bShortcut || bGotFeature)
		{
			if ( bShortcut )
			{
				wcQuery.Append ( 3, L" where `Shortcut`=\'", wcShortcut, L"\'" );
			}

			if ( bGotFeature )
			{
				if ( bShortcut )
				{
					wcQuery.Append ( 3, L" or `Target`=\'", wcFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Target`=\'", wcFeature, L"\'" );
				}
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Shortcut", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                            if ( CreateSoftwareFeatureString(wcBuf, wcProductCode, wcFeature, true) )
							{
                                PutKeyProperty(m_pObj, pElement, wcFeature, &bFeature, m_pRequest);

                                dwBufSize = BUFF_SIZE;
                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
                                    wcProp.Copy ( L"Win32_ShortcutAction.ActionID=\"" );
									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pAction, wcProp, &bAction, m_pRequest);

                                    if(bFeature && bAction) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareFeatureAction::SoftwareFeaturePublish(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                           CRequestObject *pActionData, CRequestObject *pFeatureData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcCompID[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    bool bPublish = false;
    bool bGotFeature = false;
    UINT uiStatus;

    if(atAction != ACTIONTYPE_ENUM)
	{
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[i], wcCompID);

						bPublish = true;
						bTestCode = true;
	                    break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pFeatureData)
		{
            for(int j = 0; j < pFeatureData->m_iPropCount; j++){
                
                if(_wcsicmp(pFeatureData->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pFeatureData->m_Value[j]);
						bTestCode = true;
					}
                }

                if(_wcsicmp(pFeatureData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcFeature, pFeatureData->m_Value[j]);
						bGotFeature = true;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bAction;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Feature_`, `ComponentId`, `Qualifier`, `Component_` from PublishComponent" );

    if(atAction != ACTIONTYPE_ENUM)
	{
        //optimize for GetObject
        if(bPublish || bGotFeature)
		{
			if ( bPublish )
			{
				wcQuery.Append ( 3, L" where `ComponentId`=\'", wcCompID, L"\'" );
			}

			if ( bGotFeature )
			{
				if ( bPublish )
				{
					wcQuery.Append ( 3, L" or `Feature_`=\'", wcFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Feature_`=\'", wcFeature, L"\'" );
				}
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"PublishComponent", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                            if ( CreateSoftwareFeatureString(wcBuf, wcProductCode, wcFeature, true) )
							{
                                PutKeyProperty(m_pObj, pElement, wcFeature, &bFeature, m_pRequest);

                                dwBufSize = BUFF_SIZE;
                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
                                    wcProp.Copy ( L"Win32_PublishComponentAction.ActionID=\"" );
									wcProp.Append ( 1, wcBuf );

                                    dwBufSize = BUFF_SIZE;
									CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pAction, wcProp, &bAction, m_pRequest);

                                    if(bFeature && bAction) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;
                        
                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareFeatureAction::SoftwareFeatureExtension(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                           CRequestObject *pActionData, CRequestObject *pFeatureData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcExtension[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    bool bExtension = false;
    bool bGotFeature = false;
    UINT uiStatus;

    if(atAction != ACTIONTYPE_ENUM)
	{
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

        if(pActionData){

            for(int i = 0; i < pActionData->m_iPropCount; i++){
                
                if(_wcsicmp(pActionData->m_Property[i], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[i] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[i]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						RemoveFinalGUID(pActionData->m_Value[i], wcExtension);

						bExtension = true;
						bTestCode = true;
	                    break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pFeatureData)
		{
            for(int j = 0; j < pFeatureData->m_iPropCount; j++){
                
                if(_wcsicmp(pFeatureData->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pFeatureData->m_Value[j]);
						bTestCode = true;
					}
                }

                if(_wcsicmp(pFeatureData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcFeature, pFeatureData->m_Value[j]);
						bGotFeature = true;
					}
                }
            }
        }
    }

    //These will change from class to class
    bool bFeature, bAction;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Feature_`, `Extension`, `Component_` from Extension" );

    if(atAction != ACTIONTYPE_ENUM)
	{
        //optimize for GetObject
        if(bExtension || bGotFeature)
		{
			if ( bExtension )
			{
				wcQuery.Append ( 3, L" where `Extension`=\'", wcExtension, L"\'" );
			}

			if ( bGotFeature )
			{
				if ( bExtension )
				{
					wcQuery.Append ( 3, L" or `Feature_`=\'", wcFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Feature_`=\'", wcFeature, L"\'" );
				}
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Extension", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj)))throw hr;

                        //----------------------------------------------------

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                            if ( CreateSoftwareFeatureString(wcBuf, wcProductCode, wcFeature, true) )
							{
                                PutKeyProperty(m_pObj, pElement, wcFeature, &bFeature, m_pRequest);

                                dwBufSize = BUFF_SIZE;
                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
                                    wcProp.Copy ( L"Win32_ExtensionInfoAction.ActionID=\"" );
									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pAction, wcProp, &bAction, m_pRequest);

                                //====================================================

                                //----------------------------------------------------

                                    if(bFeature && bAction) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}

HRESULT CSoftwareFeatureAction::SoftwareFeatureClassInfo(IWbemObjectSink *pHandler, ACTIONTYPE atAction,
                                                           CRequestObject *pActionData, CRequestObject *pFeatureData)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcCLSID[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    bool bTestCode = false;
    bool bCLSID = false;
    bool bGotFeature = false;
    UINT uiStatus;

    if(atAction != ACTIONTYPE_ENUM)
	{
        CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);
        int j;

        if(pActionData){

            for(j = 0; j < pActionData->m_iPropCount; j++){
                
                if(_wcsicmp(pActionData->m_Property[j], L"ActionID") == 0)
				{
					if ( ::SysStringLen ( m_pRequest->m_Value[j] ) < BUFF_SIZE )
					{
						//Get the action we're looking for
						wcscpy(wcBuf, pActionData->m_Value[j]);

						// safe operation if wcslen ( wcBuf ) > 38
						if ( wcslen ( wcBuf ) > 38 )
						{
							wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
						}
						else
						{
							// we are not good to go, they have sent us longer string
							throw hr;
						}

						// safe because lenght has been tested already in condition
						GetFirstGUID(pActionData->m_Value[j], wcCLSID);

						bCLSID = true;
						bTestCode = true;
	                    break;
					}
					else
					{
						// we are not good to go, they have sent us longer string
						throw hr;
					}
                }
            }
        }

        if(pFeatureData)
		{
            for(int j = 0; j < pFeatureData->m_iPropCount; j++){
                
                if(_wcsicmp(pFeatureData->m_Property[j], L"IdentifyingNumber") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcTestCode, pFeatureData->m_Value[j]);
						bTestCode = true;
					}
                }

                if(_wcsicmp(pFeatureData->m_Property[j], L"Name") == 0){

                    //Get the product code we're looking for
					if ( ::SysStringLen (pFeatureData->m_Value[j]) < BUFF_SIZE )
					{
						wcscpy(wcFeature, pFeatureData->m_Value[j]);
						bGotFeature = true;
					}
				}
            }
        }
    }

    //These will change from class to class
    bool bFeature, bAction;

	CStringExt wcProp;

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Feature_`, `CLSID`, `Context`, `Component_` from Class" );

    if(atAction != ACTIONTYPE_ENUM)
	{
        //optimize for GetObject
        if(bCLSID || bGotFeature)
		{
			if ( bCLSID )
			{
				wcQuery.Append ( 3, L" where `CLSID`=\'", wcCLSID, L"\'" );
			}

			if ( bGotFeature )
			{
				if ( bCLSID )
				{
					wcQuery.Append ( 3, L" or `Feature_`=\'", wcFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Feature_`=\'", wcFeature, L"\'" );
				}
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) ||
            (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Class", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));

                        if ( ValidateComponentName ( msidata.GetDatabase (), wcProductCode, wcBuf ) )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                            if ( CreateSoftwareFeatureString(wcBuf, wcProductCode, wcFeature, true) )
							{
                                PutKeyProperty(m_pObj, pElement, wcFeature, &bFeature, m_pRequest);

                                dwBufSize = BUFF_SIZE;
                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                if(wcscmp(wcBuf, L"") != 0)
								{
									// safe operation
                                    wcProp.Copy ( L"Win32_ClassInfoAction.ActionID=\"" );
                                    wcProp.Append ( 1, wcBuf );

                                    dwBufSize = BUFF_SIZE;
									CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));

									wcProp.Append ( 3, wcBuf, wcProductCode, L"\"" );
									PutKeyProperty(m_pObj, pAction, wcProp, &bAction, m_pRequest);

                                //====================================================

                                //----------------------------------------------------

                                    if(bFeature && bAction) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeaturecondition.cpp ===
// SoftwareFeatureCondition.cpp: implementation of the CSoftwareFeatureCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareFeatureCondition.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareFeatureCondition::CSoftwareFeatureCondition(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareFeatureCondition::~CSoftwareFeatureCondition()
{

}

HRESULT CSoftwareFeatureCondition::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcBuf2[BUFF_SIZE];
    WCHAR wcCondition[BUFF_SIZE];
    WCHAR wcQuery[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bFeature, bParent;

	// safe operation
	// lenght is smaller than BUFF_SIZE ( 512 )
    wcscpy(wcQuery, L"select distinct `Feature_`, `Level` from Condition");

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

		//Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Condition", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                    wcscpy(wcCondition, wcBuf);

                    if(CreateSoftwareFeatureString(wcBuf, wcProductCode, wcProp, true)){
                        PutKeyProperty(m_pObj, pElement, wcProp, &bFeature, m_pRequest);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf2, &dwBufSize));

                        if(wcscmp(wcBuf2, L"") != 0)
						{
							DWORD dwConstant = 0L;
							DWORD dwCondition = 0L;
							DWORD dwBuf = 0L;
							DWORD dwProductCode = 0L;

							dwCondition = wcslen ( wcCondition );
							dwBuf = wcslen ( wcBuf );
							dwProductCode = wcslen ( wcProductCode );

							dwConstant = wcslen ( L"Win32_Condition.CheckID=\"" ) + wcslen ( L"\"" );

							if ( dwConstant + dwCondition + dwBuf + dwProductCode + 1 < BUFF_SIZE )
							{
								wcscpy(wcProp, L"Win32_Condition.CheckID=\"");
								wcscat(wcProp, wcCondition);
								wcscat(wcProp, wcBuf2);
								wcscat(wcProp, wcProductCode);
								wcscat(wcProp, L"\"");

								PutKeyProperty(m_pObj, pCheck, wcProp, &bParent, m_pRequest);
							}
							else
							{
								LPWSTR wsz = NULL;

								try
								{
									if ( ( wsz = new WCHAR [ dwConstant + dwCondition + dwBuf + dwProductCode + 1 ] ) != NULL )
									{
										wcscpy ( wsz, L"Win32_Condition.CheckID=\"" );
										wcscat ( wsz, wcCondition );
										wcscat ( wsz, wcBuf2 );
										wcscat ( wsz, wcProductCode );
										wcscat ( wsz, L"\"" );

										PutKeyProperty ( m_pObj, pCheck, wsz, &bParent, m_pRequest );
									}
									else
									{
										throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
									}
								}
								catch ( ... )
								{
									if ( wsz )
									{
										delete [] wsz;
										wsz = NULL;
									}

									throw;
								}

								if ( wsz )
								{
									delete [] wsz;
									wsz = NULL;
								}
							}

						//====================================================

                        //----------------------------------------------------

                            if(bFeature && bParent) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }
                    }

                    m_pObj->Release();
                    m_pObj = NULL;

                    g_fpMsiCloseHandle(hRecord);

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		g_fpMsiCloseHandle(hRecord);
		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeatureparent.cpp ===
// SoftwareFeatureParent.cpp: implementation of the CSoftwareFeatureParent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareFeatureParent.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareFeatureParent::CSoftwareFeatureParent(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareFeatureParent::~CSoftwareFeatureParent()
{

}

HRESULT CSoftwareFeatureParent::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcTestCode[39];
    WCHAR wcProp[BUFF_SIZE];
    WCHAR wcAntFeature[BUFF_SIZE];
    WCHAR wcDepFeature[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;;
    bool bAnt = false;
    bool bDep = false;
    bool bTestCode = false;
    UINT uiStatus;
    CRequestObject *pDepRObj = NULL;
    CRequestObject *pAntRObj = NULL;

    try{

        if(atAction != ACTIONTYPE_ENUM)
		{
			// we are doing GetObject so we need to be reinitialized
			hr = WBEM_E_NOT_FOUND;

            int j;
            //GetObject optimizations
            CHeap_Exception he(CHeap_Exception::E_ALLOCATION_ERROR);

            for(j = 0; j < m_pRequest->m_iPropCount; j++){
                
                if(_wcsicmp(m_pRequest->m_Property[j], L"Dependent") == 0){

                    pDepRObj = new CRequestObject();
                    if(!pDepRObj) throw he;

                    pDepRObj->Initialize(m_pNamespace);

                    pDepRObj->ParsePath(m_pRequest->m_Value[j]);
                    break;
                }
            }

            if(pDepRObj){

                for(j = 0; j < pDepRObj->m_iPropCount; j++){
                
                    if(_wcsicmp(pDepRObj->m_Property[j], L"IdentifyingNumber") == 0){

						//Get the product code we're looking for
						if ( ::SysStringLen ( pDepRObj->m_Value[j] ) < BUFF_SIZE )
						{
							wcscpy(wcTestCode, pDepRObj->m_Value[j]);
							bTestCode = true;
						}
                    }

                    if(_wcsicmp(pDepRObj->m_Property[j], L"Name") == 0){

                        //Get the product code we're looking for
						if ( ::SysStringLen ( pDepRObj->m_Value[j] ) < BUFF_SIZE )
						{
							wcscpy(wcDepFeature, pDepRObj->m_Value[j]);
							bDep = true;
						}
                    }
                }

                pDepRObj->Cleanup();
                delete pDepRObj;
                pDepRObj = NULL;
            }

            for(j = 0; j < m_pRequest->m_iPropCount; j++){
                
                if(_wcsicmp(m_pRequest->m_Property[j], L"Antecedent") == 0){

                    pAntRObj = new CRequestObject();
                    if(!pAntRObj) throw he;

                    pAntRObj->Initialize(m_pNamespace);

                    pAntRObj->ParsePath(m_pRequest->m_Value[j]);
                    break;
                }
            }

            if(pAntRObj){

                for(j = 0; j < pAntRObj->m_iPropCount; j++){
                
                    if(_wcsicmp(pAntRObj->m_Property[j], L"IdentifyingNumber") == 0){

                        //Get the product code we're looking for
						if ( ::SysStringLen ( pAntRObj->m_Value[j] ) < BUFF_SIZE )
						{
							wcscpy(wcTestCode, pAntRObj->m_Value[j]);
						}
                    }

                    if(_wcsicmp(pAntRObj->m_Property[j], L"Name") == 0){

                        //Get the product code we're looking for
						if ( ::SysStringLen ( pAntRObj->m_Value[j] ) < BUFF_SIZE )
						{
							wcscpy(wcAntFeature, pAntRObj->m_Value[j]);
	                        bAnt = true;
						}
                    }
                }

                pAntRObj->Cleanup();
                delete pAntRObj;
                pAntRObj = NULL;
            }
        }

        //These will change from class to class
        bool bFeature, bParent;

		Query wcQuery;
		wcQuery.Append ( 1, L"select distinct `Feature_Parent`, `Feature` from Feature" );

		//optimize for GetObject
		if ( bAnt || bDep )
		{
			if ( bDep )
			{
				wcQuery.Append ( 3, L" where `Feature`=\'", wcDepFeature, L"\'" );
			}

			if ( bAnt )
			{
				if ( bDep )
				{
					wcQuery.Append ( 3, L" or `Feature_Parent`=\'", wcAntFeature, L"\'" );
				}
				else
				{
					wcQuery.Append ( 3, L" where `Feature_Parent`=\'", wcAntFeature, L"\'" );
				}
			}
		}

        while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
		{
			// safe operation:
			// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

            wcscpy(wcProductCode, m_pRequest->Package(i));

            if((atAction == ACTIONTYPE_ENUM) ||
                (bTestCode && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

				//Open our database

                try
				{
                    if ( GetView ( &hView, wcProductCode, wcQuery, L"Feature", TRUE, FALSE ) )
					{
                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                        while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                            CheckMSI(uiStatus);

                            if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                            //----------------------------------------------------
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));

                            if(CreateSoftwareFeatureString(wcBuf, wcProductCode, wcProp, true)){
                                PutKeyProperty(m_pObj, pAntecedent, wcProp, &bParent, m_pRequest);

                                dwBufSize = BUFF_SIZE;
                                CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                                if(CreateSoftwareFeatureString(wcBuf, wcProductCode, wcProp, true)){
                                    PutKeyProperty(m_pObj, pDependent, wcProp, &bFeature, m_pRequest);

                                    if(bFeature && bParent) bMatch = true;

                                    if((atAction != ACTIONTYPE_GET)  || bMatch){

                                        hr = pHandler->Indicate(1, &m_pObj);
                                    }
                                }
                            }

                            m_pObj->Release();
                            m_pObj = NULL;

                            g_fpMsiCloseHandle(hRecord);

                            uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                        }
                    }
				}
				catch(...)
				{
					g_fpMsiCloseHandle(hRecord);
					g_fpMsiViewClose(hView);
					g_fpMsiCloseHandle(hView);

					msidata.CloseDatabase ();

					if(m_pObj)
					{
						m_pObj->Release();
						m_pObj = NULL;
					}

					throw;
				}

				g_fpMsiCloseHandle(hRecord);
				g_fpMsiViewClose(hView);
				g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
            }
        }

    }catch(...){
            
        if(pDepRObj){

            pDepRObj->Cleanup();
            delete pDepRObj;
            pDepRObj = NULL;
        }

        if(pAntRObj){

            pAntRObj->Cleanup();
            delete pAntRObj;
            pAntRObj = NULL;
        }

		throw;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeaturesoftwareelements.cpp ===
// SoftwareFeatureSofwareElements.cpp: implementation of the CSoftwareFeatureSofwareElements class.

//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "SoftwareFeatureSoftwareElements.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSoftwareFeatureSofwareElements::CSoftwareFeatureSofwareElements(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CSoftwareFeatureSofwareElements::~CSoftwareFeatureSofwareElements()
{

}

HRESULT CSoftwareFeatureSofwareElements::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];

    WCHAR wcProductCode[39];
    WCHAR wcID[39];
    WCHAR wcProp[BUFF_SIZE];
    WCHAR wcFeature[BUFF_SIZE];
    WCHAR wcElement[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;

    //These will change from class to class
    bool bFeature, bElement;
    bool bFeatureRestrict = false;
    bool bElementRestrict = false;

    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

        int iPos = -1;
        BSTR bstrName = SysAllocString(L"GroupComponent");

		if ( bstrName )
		{
			if(FindIn(m_pRequest->m_Property, bstrName, &iPos))
			{
				CRequestObject *pFeature = new CRequestObject();
				if(!pFeature) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

				pFeature->Initialize(m_pNamespace);
            
				if(pFeature->ParsePath(m_pRequest->m_Value[iPos]))
				{
					iPos = -1;

					SysFreeString(bstrName);
					bstrName = SysAllocString(L"IdentifyingNumber");

					if ( bstrName )
					{
						if(FindIn(pFeature->m_Property, bstrName, &iPos))
						{
							if ( ::SysStringLen ( pFeature->m_Value[iPos] ) == 38 )
							{
								//Get the product code we're looking for
								wcscpy(wcID, pFeature->m_Value[iPos]);
							}
							else
							{
								// we are not good to go, they have sent us longer string
								SysFreeString ( bstrName );
								throw hr;
							}
                
							iPos = -1;

							SysFreeString(bstrName);
							bstrName = SysAllocString(L"Name");

							if ( bstrName )
							{
								if(FindIn(pFeature->m_Property, bstrName, &iPos))
								{
									if ( ::SysStringLen ( pFeature->m_Value[iPos] ) <= BUFF_SIZE )
									{
										//Get the product code we're looking for
										wcscpy(wcFeature, pFeature->m_Value[iPos]);
										bFeatureRestrict = true;
									}
									else
									{
										// we are not good to go, they have sent us longer string
										SysFreeString ( bstrName );
										throw hr;
									}
								}
							}
							else
							{
								throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
							}
						}
					}
					else
					{
						throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
					}
				}

				pFeature->Cleanup();
				delete pFeature;
				pFeature = NULL;
			}

			SysFreeString(bstrName);
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

        iPos = -1;
        bstrName = SysAllocString(L"PartComponent");

		if ( bstrName )
		{
			if(FindIn(m_pRequest->m_Property, bstrName, &iPos))
			{
				CRequestObject *pElement = new CRequestObject();
				if(!pElement) throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

				pElement->Initialize(m_pNamespace);
            
				if(pElement->ParsePath(m_pRequest->m_Value[iPos]))
				{
					iPos = -1;

					SysFreeString(bstrName);
					bstrName = SysAllocString(L"Name");

					if ( bstrName )
					{
						if(FindIn(pElement->m_Property, bstrName, &iPos))
						{
							if ( ::SysStringLen ( pElement->m_Value[iPos] ) <= BUFF_SIZE )
							{
								//Get the product code we're looking for
								wcscpy(wcElement, pElement->m_Value[iPos]);
								bElementRestrict = true;
							}
							else
							{
								// we are not good to go, they have sent us longer string
								SysFreeString ( bstrName );
								throw hr;
							}
						}
					}
					else
					{
						throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
					}
				}

				pElement->Cleanup();
				delete pElement;
				pElement = NULL;
			}

			SysFreeString(bstrName);
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

   
    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Component_`, `Feature_` from FeatureComponents" );

    //optimize for GetObject
    if ( bElementRestrict || bFeatureRestrict )
	{
		if ( bFeatureRestrict )
		{
			wcQuery.Append ( 3, L" where `Feature_`=\'", wcFeature, L"\'" );
		}

		if ( bElementRestrict )
		{
			if ( bFeatureRestrict )
			{
				wcQuery.Append ( 3, L" or `Component_`=\'", wcElement, L"\'" );
			}
			else
			{
				wcQuery.Append ( 3, L" where `Component_`=\'", wcElement, L"\'" );
			}
		}
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        //This trims the number of times we itterate on getobject calls
        if((atAction == ACTIONTYPE_ENUM) || !bFeatureRestrict ||
            (0 == _wcsicmp(m_pRequest->Package(i), wcID))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"FeatureComponents", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                        //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));                           

						dwBufSize = BUFF_SIZE;
						uiStatus = CreateSoftwareElementString (	msidata.GetDatabase(),
																	wcBuf,
																	wcProductCode,
																	wcProp,
																	&dwBufSize
															   );
						if( uiStatus == ERROR_SUCCESS )
						{
                            PutKeyProperty(m_pObj, pPartComponent, wcProp, &bElement, m_pRequest);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                            if(CreateSoftwareFeatureString(wcBuf, wcProductCode, wcProp, true)){

                                PutKeyProperty(m_pObj, pGroupComponent, wcProp, &bFeature, m_pRequest);
                        //----------------------------------------------------

                                if(bFeature && bElement) bMatch = true;

                                if((atAction != ACTIONTYPE_GET)  || bMatch){

                                    hr = pHandler->Indicate(1, &m_pObj);
                                }
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

						uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    }//while
                
                }//if
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

        }//if
    }//while

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeatureparent.h ===
// SoftwareFeatureParent.h: interface for the CSoftwareFeatureParent class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREFEATUREPARENT_H__02FF6C83_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREFEATUREPARENT_H__02FF6C83_DDDE_11D1_8B60_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareFeatureParent : public CGenericClass  
{
public:
	CSoftwareFeatureParent(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareFeatureParent();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREFEATUREPARENT_H__02FF6C83_DDDE_11D1_8B60_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeaturecondition.h ===
// SoftwareFeatureCondition.h: interface for the CSoftwareFeatureCondition class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREFEATURECONDITION_H__F4A87812_E037_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREFEATURECONDITION_H__F4A87812_E037_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareFeatureCondition : public CGenericClass  
{
public:
	CSoftwareFeatureCondition(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareFeatureCondition();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREFEATURECONDITION_H__F4A87812_E037_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\softwarefeaturesoftwareelements.h ===
// SoftwareFeatureSofwareElements.h: interface for the CSoftwareFeatureSofwareElements class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SOFTWAREFEATURESOFWAREELEMENTS_H__CFD828E5_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
#define AFX_SOFTWAREFEATURESOFWAREELEMENTS_H__CFD828E5_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CSoftwareFeatureSofwareElements : public CGenericClass  
{
public:
	CSoftwareFeatureSofwareElements(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CSoftwareFeatureSofwareElements();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_SOFTWAREFEATURESOFWAREELEMENTS_H__CFD828E5_DAC7_11D1_8B5D_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\typelibraryaction.cpp ===
// TypeLibraryAction.cpp: implementation of the CTypeLibraryAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "TypeLibraryAction.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTypeLibraryAction::CTypeLibraryAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CTypeLibraryAction::~CTypeLibraryAction()
{

}

HRESULT CTypeLibraryAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcProp[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bCheck;
    
    SetSinglePropertyPath(L"ActionID");

    //improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					GetFirstGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `LibID`, `Component_`, `Language`, `Version`, `Description`, `Cost` from TypeLib" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `LibID`=\'", wcAction, L"\'" );
	}

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"TypeLib", TRUE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcProp, &dwBufSize));
                        PutProperty(m_pObj, pLibID, wcProp);

                        dwBufSize = BUFF_SIZE;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));

                        if ( ValidateComponentName	(	msidata.GetDatabase (),
														wcProductCode,
														wcBuf
													)
						   )
						{
                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 3, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pLanguage, wcBuf);

							PutKeyProperty ( m_pObj, pActionID, wcProp, &bCheck, m_pRequest, 2, wcBuf, wcProductCode );

						//====================================================

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pVersion, wcBuf);

                            dwBufSize = BUFF_SIZE;
                            CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                            PutProperty(m_pObj, pCaption, wcBuf);
                            PutProperty(m_pObj, pDescription, wcBuf);
                            PutProperty(m_pObj, pName, wcBuf);

                            PutProperty(m_pObj, pCost, g_fpMsiRecordGetInteger(hRecord, 6));

                        //----------------------------------------------------

                            if(bCheck) bMatch = true;

                            if((atAction != ACTIONTYPE_GET)  || bMatch){

                                hr = pHandler->Indicate(1, &m_pObj);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }

            }catch(...){

                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\upgrade.cpp ===
// Upgrade.cpp: implementation of the CUpgrade class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Upgrade.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUpgrade::CUpgrade(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CUpgrade::~CUpgrade()
{

}

HRESULT CUpgrade::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE];
    WCHAR wcProductCode[39];
    WCHAR wcQuery[BUFF_SIZE];
    DWORD dwBufSize;
    bool bMatch;
    UINT uiStatus;

    //These will change from class to class
    bool bUpgradeCode, bProductVersion, bOperator, bProductCode;
    wcscpy(wcQuery, L"select distinct `UpgradeCode`, `ProductVersion`, `Operator`, `Features`, `Property` from Upgrade");

    while(m_pRequest->Package(++i)){
        wcscpy(wcProductCode, m_pRequest->Package(i));

        bMatch = false;
    //Open our database

        try
		{
            if ( GetView ( &hView, wcProductCode, wcQuery, L"Upgrade", TRUE, FALSE ) )
			{
                uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                while(uiStatus != ERROR_NO_MORE_ITEMS){
                    CheckMSI(uiStatus);

                    if(FAILED(hr = SpawnAnInstance(m_pNamespace, m_pCtx,
                        &m_pObj, m_pRequest->m_bstrClass))) throw hr;

                //----------------------------------------------------
                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pUpgradeCode, wcBuf, &bUpgradeCode, m_pRequest);

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                    PutKeyProperty(m_pObj, pProductVersion, wcBuf, &bProductVersion, m_pRequest);

                    PutKeyProperty(m_pObj, pOperator, g_fpMsiRecordGetInteger(hRecord, 3),
                        &bOperator, m_pRequest);

                    PutKeyProperty(m_pObj, pProductCode, wcProductCode, &bProductCode, m_pRequest);
                //====================================================

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                    PutProperty(m_pObj, pFeatures, wcBuf);

                    dwBufSize = BUFF_SIZE;
                    CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                    PutProperty(m_pObj, pProperty, wcBuf);
                //----------------------------------------------------

                    if(bUpgradeCode && bProductVersion && bOperator && bProductCode) bMatch = true;

                    if((atAction != ACTIONTYPE_GET)  || bMatch) hr = pHandler->Indicate(1, &m_pObj);

                    m_pObj->Release();
                    m_pObj = NULL;

                    if(bMatch){
                        g_fpMsiViewClose(hView);
                        g_fpMsiCloseHandle(hView);
                        g_fpMsiCloseHandle(hRecord);
                        return hr;
                    }

                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                }
            }
		}
		catch(...)
		{
			g_fpMsiCloseHandle(hRecord);
			g_fpMsiViewClose(hView);
			g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();

			if(m_pObj)
			{
				m_pObj->Release();
				m_pObj = NULL;
			}

			throw;
		}

		g_fpMsiCloseHandle(hRecord);
		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		msidata.CloseDatabase ();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\typelibraryaction.h ===
// TypeLibraryAction.h: interface for the CTypeLibraryAction class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TYPELIBRARYACTION_H__75F6BA27_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
#define AFX_TYPELIBRARYACTION_H__75F6BA27_DF6E_11D1_8B61_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CTypeLibraryAction : public CGenericClass  
{
public:
	CTypeLibraryAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CTypeLibraryAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_TYPELIBRARYACTION_H__75F6BA27_DF6E_11D1_8B61_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\upgrade.h ===
// Upgrade.h: interface for the CUpgrade class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UPGRADE_H__DB614F2D_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_UPGRADE_H__DB614F2D_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CUpgrade : public CGenericClass  
{
public:
	CUpgrade(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CUpgrade();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_UPGRADE_H__DB614F2D_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\writeregistry.h ===
// WriteRegistry.h: interface for the CWriteRegistry class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WRITEREGISTRY_H__DB614F31_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
#define AFX_WRITEREGISTRY_H__DB614F31_DB84_11D1_8B5F_00A0C9954921__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "GenericClass.h"

class CRegistryAction : public CGenericClass  
{
public:
	CRegistryAction(CRequestObject *pObj, IWbemServices *pNamespace, IWbemContext *pCtx = NULL);
	virtual ~CRegistryAction();

	virtual HRESULT PutInst(CRequestObject *pObj, IWbemClassObject *pInst, IWbemObjectSink *pHandler, IWbemContext *pCtx)
		{return WBEM_E_NOT_SUPPORTED;}

	virtual HRESULT CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction);
};

#endif // !defined(AFX_WRITEREGISTRY_H__DB614F31_DB84_11D1_8B5F_00A0C9954921__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\writeregistry.cpp ===
// WriteRegistry.cpp: implementation of the CWriteRegistry class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "WriteRegistry.h"

#include "ExtendString.h"
#include "ExtendQuery.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegistryAction::CRegistryAction(CRequestObject *pObj, IWbemServices *pNamespace,
                                   IWbemContext *pCtx):CGenericClass(pObj, pNamespace, pCtx)
{

}

CRegistryAction::~CRegistryAction()
{

}

HRESULT CRegistryAction::CreateObject(IWbemObjectSink *pHandler, ACTIONTYPE atAction)
{
    HRESULT hr = WBEM_S_NO_ERROR;

	MSIHANDLE hView		= NULL;
	MSIHANDLE hRecord	= NULL;
	MSIHANDLE hSEView	= NULL;
	MSIHANDLE hSERecord	= NULL;

    int i = -1;
    WCHAR wcBuf[BUFF_SIZE * 4];
    WCHAR wcProductCode[39];
    WCHAR wcID[39];
    DWORD dwBufSize;
    bool bMatch = false;
    UINT uiStatus;
    bool bGotID = false;
    WCHAR wcAction[BUFF_SIZE];
    WCHAR wcTestCode[39];

    //These will change from class to class
    bool bActionID;
    INSTALLSTATE piInstalled;
    int iState;

    SetSinglePropertyPath(L"ActionID");

	//improve getobject performance by optimizing the query
    if(atAction != ACTIONTYPE_ENUM)
	{
		// we are doing GetObject so we need to be reinitialized
		hr = WBEM_E_NOT_FOUND;

		BSTR bstrCompare;

        int iPos = -1;
        bstrCompare = SysAllocString ( L"ActionID" );

		if ( bstrCompare )
		{
			if(FindIn(m_pRequest->m_Property, bstrCompare, &iPos))
			{
				if ( ::SysStringLen ( m_pRequest->m_Value[iPos] ) < BUFF_SIZE )
				{
		            //Get the action we're looking for
					wcscpy(wcBuf, m_pRequest->m_Value[iPos]);

					// safe operation if wcslen ( wcBuf ) > 38
					if ( wcslen ( wcBuf ) > 38 )
					{
						wcscpy(wcTestCode, &(wcBuf[(wcslen(wcBuf) - 38)]));
					}
					else
					{
						// we are not good to go, they have sent us longer string
						SysFreeString ( bstrCompare );
						throw hr;
					}

					// safe because lenght has been tested already in condition
					RemoveFinalGUID(m_pRequest->m_Value[iPos], wcAction);

					bGotID = true;
				}
				else
				{
					// we are not good to go, they have sent us longer string
					SysFreeString ( bstrCompare );
					throw hr;
				}

			}

			SysFreeString ( bstrCompare );
		}
		else
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}
    }

    Query wcQuery;
    wcQuery.Append ( 1, L"select distinct `Registry`, `Component_`, `Root`, `Key`, `Name`, `Value` from Registry" );

    //optimize for GetObject
    if ( bGotID )
	{
		wcQuery.Append ( 3, L" where `Registry`=\'", wcAction, L"\'" );
	}

	QueryExt wcQuery1 ( L"select distinct `ComponentId` from Component where `Component`=\'" );

    while(!bMatch && m_pRequest->Package(++i) && (hr != WBEM_E_CALL_CANCELLED))
	{
		// safe operation:
		// Package ( i ) returns NULL ( tested above ) or valid WCHAR [39]

        wcscpy(wcProductCode, m_pRequest->Package(i));

        if((atAction == ACTIONTYPE_ENUM) || (bGotID && (_wcsicmp(wcTestCode, wcProductCode) == 0))){

			//Open our database

            try
			{
                if ( GetView ( &hView, wcProductCode, wcQuery, L"Registry", FALSE, FALSE ) )
				{
                    uiStatus = g_fpMsiViewFetch(hView, &hRecord);

                    while(!bMatch && (uiStatus != ERROR_NO_MORE_ITEMS) && (hr != WBEM_E_CALL_CANCELLED)){
                        CheckMSI(uiStatus);

                        if(FAILED(hr = SpawnAnInstance(&m_pObj))) throw hr;

                    //----------------------------------------------------
                        dwBufSize = BUFF_SIZE * 4;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 1, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pRegistry, wcBuf);
                        PutProperty(m_pObj, pDescription, wcBuf);
                        PutProperty(m_pObj, pCaption, wcBuf);

						PutKeyProperty ( m_pObj, pActionID, wcBuf, &bActionID, m_pRequest, 1, wcProductCode );

                    //====================================================

                        PutProperty(m_pObj, pRoot, g_fpMsiRecordGetInteger(hRecord, 3));

                        dwBufSize = BUFF_SIZE * 4;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 4, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pKey, wcBuf);

                        dwBufSize = BUFF_SIZE * 4;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 5, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pEntryName, wcBuf);

                        dwBufSize = BUFF_SIZE * 4;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 6, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pEntryValue, wcBuf);

                        dwBufSize = BUFF_SIZE * 4;
                        CheckMSI(g_fpMsiRecordGetStringW(hRecord, 2, wcBuf, &dwBufSize));
                        PutProperty(m_pObj, pName, wcBuf);

						// make query on fly
						wcQuery1.Append ( 2, wcBuf, L"\'" );

                        if(ERROR_SUCCESS == g_fpMsiDatabaseOpenViewW( msidata.GetDatabase (), wcQuery1, &hSEView ))
						{
                            if(ERROR_SUCCESS == g_fpMsiViewExecute(hSEView, 0)){

                                try{

                                    uiStatus = g_fpMsiViewFetch(hSEView, &hSERecord);

                                    dwBufSize = BUFF_SIZE * 4;
                                    CheckMSI(g_fpMsiRecordGetStringW(hSERecord, 1, wcID, &dwBufSize));

                                    if(ValidateComponentID(wcID, wcProductCode)){

                                        PutProperty(m_pObj, pSoftwareElementID, wcID);

                                        dwBufSize = BUFF_SIZE * 4;
                                        wcscpy(wcBuf, L"");
                                        piInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcID, wcBuf, &dwBufSize);
                                        SoftwareElementState(piInstalled, &iState);
                                        PutProperty(m_pObj, pSoftwareElementState, iState);

                                        PutProperty(m_pObj, pTargetOperatingSystem, GetOS());

                                        dwBufSize = BUFF_SIZE * 4;
                                        CheckMSI(g_fpMsiGetProductPropertyW(msidata.GetProduct (), L"ProductVersion", wcBuf,
                                            &dwBufSize));
                                        PutProperty(m_pObj, pVersion, wcBuf);
                                    //----------------------------------------------------

                                        if(bActionID) bMatch = true;

                                        if((atAction != ACTIONTYPE_GET)  || bMatch){

                                            hr = pHandler->Indicate(1, &m_pObj);
                                        }
                                    }
                                
                                }catch(...){

                                    g_fpMsiViewClose(hSEView);
                                    g_fpMsiCloseHandle(hSEView);
                                    g_fpMsiCloseHandle(hSERecord);
                                    throw;
                                }

                                g_fpMsiViewClose(hSEView);
                                g_fpMsiCloseHandle(hSEView);
                                g_fpMsiCloseHandle(hSERecord);
                            }
                        }

                        m_pObj->Release();
                        m_pObj = NULL;

                        g_fpMsiCloseHandle(hRecord);

                        uiStatus = g_fpMsiViewFetch(hView, &hRecord);
                    }
                }
            }
			catch(...)
			{
                g_fpMsiCloseHandle(hRecord);
                g_fpMsiViewClose(hView);
                g_fpMsiCloseHandle(hView);

				msidata.CloseDatabase ();
				msidata.CloseProduct ();

				if(m_pObj)
				{
					m_pObj->Release();
					m_pObj = NULL;
				}

                throw;
            }

            g_fpMsiCloseHandle(hRecord);
            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

			msidata.CloseDatabase ();
			msidata.CloseProduct ();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\dll\utils.cpp ===
// Utils.cpp: implementation of the CGenericClass class.

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"

char * WcharToTchar(WCHAR * wcPtr, char * tcTmp)
{
    WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, wcPtr, (-1), tcTmp, BUFF_SIZE, NULL, NULL);
    return tcTmp;
}

WCHAR * TcharToWchar(char * tcPtr, WCHAR * wcTmp)
{
    MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, tcPtr, (-1), wcTmp, BUFF_SIZE);
    return wcTmp;
}

WCHAR * TcharToWchar(const char * tcPtr, WCHAR * wcTmp)
{
    MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, tcPtr, (-1), wcTmp, BUFF_SIZE);
    return wcTmp;
}

HRESULT ConvertError(UINT uiStatus)
{
    switch(uiStatus){

    case ERROR_INSTALL_ALREADY_RUNNING:
        return WBEM_E_ACCESS_DENIED;

    case ERROR_ACCESS_DENIED:
        return WBEM_E_PRIVILEGE_NOT_HELD;

    case E_OUTOFMEMORY:
        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
        return WBEM_E_OUT_OF_MEMORY;

    default:
        return WBEM_E_FAILED;
    }
}

WCHAR * EscapeStringW(WCHAR * wcIn, WCHAR * wcOut)
{
	wcOut [ 0 ] = 0;

	DWORD dwLenghtIn = 0L;
	dwLenghtIn = lstrlenW ( wcIn );

    WCHAR wcTmp[BUFF_SIZE] = { L'\0' };
    wcscpy(wcTmp, wcIn);
    WCHAR * wcp = wcTmp;

	DWORD dwNumber = 0L;

	while ( *wcp )
	{
		if ( *wcp == L'\\' || *wcp == L'\"' )
		{
			dwNumber++;
		}

		wcp++;
	}

	if ( BUFF_SIZE > ( dwLenghtIn + dwNumber * 2 ) )
	{
		wcp = wcTmp;

		while ( *wcp )
		{
			switch ( *wcp )
			{
				case L'\\':
				*wcp = NULL;
				wcscpy(wcOut, wcTmp);
				wcscat(wcOut, L"\\\\");
				wcscat(wcOut, (wcp + 1));
				wcscpy(wcTmp, wcOut);
				wcp++;
				break;

				case L'\"':
				*wcp = NULL;
				wcscpy(wcOut, wcTmp);
				wcscat(wcOut, L"\\\"");
				wcscat(wcOut, (wcp + 1));
				wcscpy(wcTmp, wcOut);
				wcp++;
				break;

				default:
				break;
			}

			wcp++;
		}
	}

    return wcOut;
}

void SoftwareElementState(INSTALLSTATE piInstalled, int *iState)
{
    switch(piInstalled){

		case INSTALLSTATE_ABSENT:
		*iState = 0;
		break;
		case INSTALLSTATE_BADCONFIG:
		*iState = 0;
		break;
		case INSTALLSTATE_INVALIDARG:
		*iState = 0;
		break;
		case INSTALLSTATE_LOCAL:
		*iState = 2;
		break;
		case INSTALLSTATE_SOURCE:
		*iState = 1;
		break;
		case INSTALLSTATE_SOURCEABSENT:
		*iState = 0;
		break;
		case INSTALLSTATE_UNKNOWN:
		*iState = 0;
		break;
		default:
		*iState = 0;
	}
}

// string am getting is BUF_SIZE ( statically allocated )
bool CreateProductString(WCHAR *wcProductCode, WCHAR *wcProductPath)
{
    DWORD dwBufSize;
    WCHAR wcBuf[BUFF_SIZE];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif
    bool bResult = false;

	// safe operation
    wcscpy(wcProductPath, L"Win32_Product.IdentifyingNumber=\"");

	if (	wcslen ( wcProductPath ) + 
			wcslen ( L"\",Name=\"" )

			< BUFF_SIZE
	   )
	{
		wcscat(wcProductPath, wcProductCode);
		wcscat(wcProductPath, L"\",Name=\"");

		dwBufSize = BUFF_SIZE;
#if defined(_UNICODE)
		if(g_fpMsiGetProductInfoW(wcProductCode, INSTALLPROPERTY_PRODUCTNAME,
#else
		if(g_fpMsiGetProductInfoW(wcProductCode, TcharToWchar(INSTALLPROPERTY_PRODUCTNAME, wcTmp),
#endif
			wcBuf, &dwBufSize) == ERROR_SUCCESS)
		{

			if (	wcslen (wcProductPath) +
					wcslen (wcBuf) +
					wcslen (L"\",Version=\"") 

					< BUFF_SIZE
			   )
			{
				wcscat(wcProductPath, wcBuf);
				wcscat(wcProductPath, L"\",Version=\"");

				dwBufSize = BUFF_SIZE;
#if defined(_UNICODE)
				if(g_fpMsiGetProductInfoW(wcProductCode, INSTALLPROPERTY_VERSIONSTRING,
#else
				if(g_fpMsiGetProductInfoW(wcProductCode, TcharToWchar(INSTALLPROPERTY_VERSIONSTRING, wcTmp),
#endif
					wcBuf, &dwBufSize) == ERROR_SUCCESS)
				{
					if (	wcslen (wcProductPath) +
							wcslen (wcBuf) +
							1 

							< BUFF_SIZE
					   )
					{
						wcscat(wcProductPath, wcBuf);
						wcscat(wcProductPath, L"\"");
						bResult = true;
					}
				}
				else
				{
					dwBufSize = BUFF_SIZE;
					if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,
#if defined(_UNICODE)
						INSTALLPROPERTY_VERSION, wcBuf, &dwBufSize))
					{

#else
						TcharToWchar(INSTALLPROPERTY_VERSION, wcTmp), wcBuf, &dwBufSize))
					{
#endif
						if (	wcslen (wcProductPath) +
								wcslen (wcBuf) +
								1 

								< BUFF_SIZE
						   )
						{
							wcscat(wcProductPath, wcBuf);
							wcscat(wcProductPath, L"\"");
							bResult = true;
						}
					}
				}
			}
		}
	}

    return bResult;
    
}

DWORD CreateSoftwareElementString ( MSIHANDLE hDatabase, WCHAR *wcComponent, WCHAR *wcProductCode, WCHAR *wcPath, DWORD * dwPath )
{
    DWORD dwResult		= static_cast < DWORD > ( E_INVALIDARG );
    DWORD dwResultHelp	= static_cast < DWORD > ( S_FALSE );

	#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
	#endif

	if ( wcComponent != NULL && wcComponent [ 0 ] != 0 )
	{
		MSIHANDLE hView		= NULL;
		MSIHANDLE hRecord	= NULL;

		DWORD dwBufSize	= BUFF_SIZE;

		LPWSTR wcBuf	= NULL;
		LPWSTR wcID		= NULL;
		LPWSTR wcQuery	= NULL;

		int iState = 0L;

		DWORD dwPathSize = 0;
		dwPathSize = * dwPath;

		DWORD dwUsed = 1; // last null

		try
		{
			if ( ( wcBuf = new WCHAR [ dwBufSize ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
			if ( ( wcID = new WCHAR [ dwBufSize ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}

			LPCWSTR	wszQuery = L"select distinct `ComponentId` from Component where `Component`=\'";

			DWORD dwQuery = 0L;
			dwQuery = lstrlenW ( wszQuery ) + lstrlenW ( wcComponent ) + 1 + 1;

			if ( ( wcQuery = new WCHAR [ dwQuery ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}

			wcscpy ( wcQuery, wszQuery );
			wcscat ( wcQuery, wcComponent );
			wcscat ( wcQuery, L"\'" );

			if ( ( dwResult = g_fpMsiDatabaseOpenViewW ( hDatabase, wcQuery, &hView ) ) == ERROR_SUCCESS )
			{
				if ( g_fpMsiViewExecute ( hView, 0 ) == ERROR_SUCCESS )
				{
					if ( g_fpMsiViewFetch ( hView, &hRecord ) != ERROR_NO_MORE_ITEMS )
					{
						dwBufSize = BUFF_SIZE;

						BOOL	bContinue = TRUE;
						DWORD	dwContinue= 2;
						do
						{
							if ( ( dwResult = g_fpMsiRecordGetStringW ( hRecord, 1, wcID, &dwBufSize ) ) == ERROR_MORE_DATA )
							{
								delete [] wcID;
								wcID = NULL;

								if ( ( wcID = new WCHAR [ dwBufSize ] ) == NULL )
								{
									throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
								}
							}
							else
							{
								bContinue = FALSE;
							}
						}
						while ( bContinue && dwContinue-- );

						if ( dwResult == ERROR_MORE_DATA )
						{
							dwResult = static_cast < DWORD > ( E_FAIL );
						}

						if ( dwResult == ERROR_SUCCESS && wcProductCode != NULL && wcProductCode [ 0 ] != 0 )
						{
							//Check to make sure it's on the system
							if ( ValidateComponentID ( wcID, wcProductCode ) )
							{
								dwUsed =	dwUsed +
											lstrlenW ( L"Win32_SoftwareElement.Name=\"" ) +
											lstrlenW ( wcComponent ) + 
											lstrlenW ( L"\",SoftwareElementID=\"" ) +
											lstrlenW ( wcID ) +
											lstrlenW ( L"\",SoftwareElementState=" );

								if ( dwUsed > dwPathSize )
								{
									dwResultHelp = ERROR_MORE_DATA;
								}
								else
								{
									wcscpy(wcPath, L"Win32_SoftwareElement.Name=\"");
									wcscat(wcPath, wcComponent);
									wcscat(wcPath, L"\",SoftwareElementID=\"");
									wcscat(wcPath, wcID);
									wcscat(wcPath, L"\",SoftwareElementState=");
								}

								SoftwareElementState (	g_fpMsiGetComponentPathW ( 
																					wcProductCode,
																					wcID,
																					NULL,
																					NULL
																				 ),
														&iState
													 );

								_itow(iState, wcBuf, 10);

								dwUsed =	dwUsed +
											lstrlenW ( wcBuf ) +
											lstrlenW ( L"\",SoftwareElementState=\"" );

								if ( dwUsed > dwPathSize )
								{
									dwResultHelp = ERROR_MORE_DATA;
								}
								else
								{
									wcscat(wcPath, wcBuf);
									wcscat(wcPath, L",TargetOperatingSystem=");
								}

								_itow(GetOS(), wcBuf, 10);

								dwUsed =	dwUsed +
											lstrlenW ( wcBuf ) +
											lstrlenW ( L"\",SoftwareElementState=\"" );

								if ( dwUsed > dwPathSize )
								{
									dwResultHelp = ERROR_MORE_DATA;
								}
								else
								{
									wcscat(wcPath, wcBuf);
									wcscat(wcPath, L",Version=\"");
								}

								dwBufSize = BUFF_SIZE;
								wcBuf [0] = 0;

								bContinue	= TRUE;
								dwContinue	= 2;

								do 
								{
									if ( ( dwResult = g_fpMsiGetProductInfoW	(	wcProductCode,
																					#ifdef	_UNICODE
																					INSTALLPROPERTY_VERSIONSTRING,
																					#else	_UNICODE
																					TcharToWchar(INSTALLPROPERTY_VERSIONSTRING, wcTmp),
																					#endif	_UNICODE
																					wcBuf,
																					&dwBufSize
																				) 
										 ) == ERROR_MORE_DATA
									   )
									{
										delete [] wcBuf;
										wcBuf = NULL;

										if ( ( wcBuf = new WCHAR [ dwBufSize + 1 ] ) == NULL )
										{
											throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
										}

										dwBufSize = dwBufSize + 1;
									}
									else
									{
										bContinue = FALSE;
									}
								}
								while ( bContinue && dwContinue-- );

								if ( dwResult == ERROR_MORE_DATA )
								{
									dwResult = static_cast < DWORD > ( E_FAIL );
								}

								if ( dwResult == ERROR_SUCCESS )
								{
									dwUsed =	dwUsed +
												lstrlenW ( wcBuf ) +
												lstrlenW ( L"\"" );

									if ( dwUsed > dwPathSize )
									{
										dwResultHelp = ERROR_MORE_DATA;
									}
									else
									{
										wcscat(wcPath, wcBuf);
										wcscat(wcPath, L"\"");

										dwResult = ERROR_SUCCESS;
									}
								}
							}
						}
					}
				}
			}
			else
			{
				if ( dwResult == E_OUTOFMEMORY )
				{
					throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
				}
			}
		}
		catch ( ... )
		{
			if ( wcBuf )
			{
				delete [] wcBuf;
				wcBuf = NULL;
			}

			if ( wcID )
			{
				delete [] wcID;
				wcID = NULL;
			}

			if ( wcQuery )
			{
				delete [] wcQuery;
				wcQuery = NULL;
			}

			throw;
		}

		if ( wcBuf )
		{
			delete [] wcBuf;
			wcBuf = NULL;
		}

		if ( wcID )
		{
			delete [] wcID;
			wcID = NULL;
		}

		if ( wcQuery )
		{
			delete [] wcQuery;
			wcQuery = NULL;
		}

		g_fpMsiCloseHandle(hRecord);

		g_fpMsiViewClose(hView);
		g_fpMsiCloseHandle(hView);

		if ( dwResult == ERROR_SUCCESS && dwResultHelp == ERROR_MORE_DATA )
		{
			( * dwPath ) = ( * dwPath ) + ( dwUsed - dwPathSize );
			wcPath [ 0 ] = 0;

			dwResult = dwResultHelp;
		}
    }

    return dwResult;
}

// string am getting is BUF_SIZE ( statically allocated )
bool CreateSoftwareFeatureString(WCHAR *wcName, WCHAR *wcProductCode, WCHAR * wcString, bool bValidate)
{
    bool bResult = false;
    DWORD dwBufSize;
    WCHAR wcBuf[BUFF_SIZE];
#if !defined(_UNICODE)
    WCHAR wcTmp[BUFF_SIZE];
#endif

    if((bValidate) && (!ValidateFeatureName(wcName, wcProductCode))) return bResult;

	// safe operation
    wcscpy(wcString, L"Win32_SoftwareFeature.IdentifyingNumber=\"");

	if (	wcslen ( wcString ) + 
			wcslen ( L"\",Name=\"" ) +
			wcslen ( wcName ) +
			wcslen ( L"\",ProductName=\"" ) 

			< BUFF_SIZE
	   )
	{
		wcscat(wcString, wcProductCode);
		wcscat(wcString, L"\",Name=\"");
		wcscat(wcString, wcName);
		wcscat(wcString, L"\",ProductName=\"");

		dwBufSize = BUFF_SIZE;
		if(g_fpMsiGetProductInfoW(wcProductCode, 
#if defined(_UNICODE)
			INSTALLPROPERTY_PRODUCTNAME,
#else
			TcharToWchar(INSTALLPROPERTY_PRODUCTNAME, wcTmp),
#endif
			wcBuf, &dwBufSize) == ERROR_SUCCESS)
		{
			if (	wcslen (wcString) +
					wcslen (wcBuf) +
					wcslen (L"\",Version=\"") 

					< BUFF_SIZE
			   )
			{
				wcscat(wcString, wcBuf);
				wcscat(wcString, L"\",Version=\"");

				dwBufSize = BUFF_SIZE;
				if(g_fpMsiGetProductInfoW(wcProductCode, 
#if defined(_UNICODE)
					INSTALLPROPERTY_VERSIONSTRING,
#else
					TcharToWchar(INSTALLPROPERTY_VERSIONSTRING, wcTmp),
#endif
					wcBuf, &dwBufSize) == ERROR_SUCCESS)
				{
					if (	wcslen (wcString) +
							wcslen (wcBuf) +
							1 

							< BUFF_SIZE
					   )
					{
						wcscat(wcString, wcBuf);
						wcscat(wcString, L"\"");
						bResult = true;
					}
				}
				else
				{
					dwBufSize = BUFF_SIZE;
					if(ERROR_SUCCESS == g_fpMsiGetProductInfoW(wcProductCode,
#if defined(_UNICODE)
						INSTALLPROPERTY_VERSION
#else
						TcharToWchar(INSTALLPROPERTY_VERSION, wcTmp)
#endif
						, wcBuf, &dwBufSize))
					{
						if (	wcslen (wcString) +
								wcslen (wcBuf) +
								1 

								< BUFF_SIZE
						   )
						{
							wcscat(wcString, wcBuf);
							wcscat(wcString, L"\"");
							bResult = true;
						}
					}
				}
			}
		}
	}

    return bResult;
}
                        

// simple helper to ask the age old question
// of what OS are we running on, anyway?
bool AreWeOnNT()
{
    OSVERSIONINFO osversion;
    osversion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osversion);

    return (osversion.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

int GetOS()
{
    OSVERSIONINFO osversion;
    int iOS = 19;
    osversion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osversion);

    if(osversion.dwPlatformId == VER_PLATFORM_WIN32s) iOS = 16;
    else if(osversion.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS){

        if(osversion.dwMinorVersion == 0) iOS = 17;
        else iOS = 18;
    }

    return iOS;
}

bool IsNT4()
{
    OSVERSIONINFO osversion;
    int iOS = 19;
    osversion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osversion);

    return osversion.dwMajorVersion == 4;
}

bool IsNT5()
{
    OSVERSIONINFO osversion;
    int iOS = 19;
    osversion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osversion);

    return osversion.dwMajorVersion == 5;
}

// checks impersonation level
// impersonates client if allowed
HRESULT CheckImpersonationLevel()
{
    HRESULT hr = WBEM_E_ACCESS_DENIED;

    if(AreWeOnNT()){

        if(SUCCEEDED(CoImpersonateClient())){

            // Now, let's check the impersonation level.  First, get the thread token
            HANDLE hThreadTok;
            DWORD dwImp, dwBytesReturned;

            if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok )){

                DWORD dwLastError = GetLastError();

                if (dwLastError == ERROR_NO_TOKEN){

                    // If the CoImpersonate works, but the OpenThreadToken fails due to ERROR_NO_TOKEN, we
                    // are running under the process token (either local system, or if we are running
                    // with /exe, the rights of the logged in user).  In either case, impersonation rights
                    // don't apply.  We have the full rights of that user.

                    hr = WBEM_S_NO_ERROR;
                
				}else{
                
					// If we failed to get the thread token for any other reason, an error.
                    hr = WBEM_E_ACCESS_DENIED;
                }

            }else{

                if(GetTokenInformation(hThreadTok, TokenImpersonationLevel, &dwImp,
                    sizeof(DWORD), &dwBytesReturned)){

                    // Is the impersonation level Impersonate?
                    if (dwImp >= SecurityImpersonation) hr = WBEM_S_NO_ERROR;
                    else hr = WBEM_E_ACCESS_DENIED;

            }else hr = WBEM_E_FAILED;

                CloseHandle(hThreadTok);
            }

			if (FAILED(hr))
			{
				CoRevertToSelf();
			}
        }

    }else
        // let win9X in...
        hr = WBEM_S_NO_ERROR;

    return hr;
}

bool ValidateComponentID(WCHAR *wcID, WCHAR *wcProductCode)
{
    int i = 0;

    WCHAR * wcBuf = (WCHAR *)malloc(BUFF_SIZE * sizeof(WCHAR));
    if(!wcBuf)
	{
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    DWORD dwBufSize;
    UINT uiStatus;
    INSTALLSTATE isInstalled;
    bool bRetVal = false;

	dwBufSize = BUFF_SIZE;
	isInstalled = g_fpMsiGetComponentPathW(wcProductCode, wcID, wcBuf, &dwBufSize);

	// this lines are added for backward compatability ( ! INSTALLSTATE_NOTUSED )

	if( isInstalled == INSTALLSTATE_LOCAL ||
		isInstalled == INSTALLSTATE_SOURCE ||
		isInstalled == INSTALLSTATE_SOURCEABSENT ||
		isInstalled == INSTALLSTATE_UNKNOWN ||
		isInstalled == INSTALLSTATE_ABSENT 
	  )
	{
		bRetVal = true;
	}

    free((void *)wcBuf);

    return bRetVal;
}

bool ValidateComponentName ( MSIHANDLE hDatabase, WCHAR *wcProductCode, WCHAR *wcName )
{
    bool bResult = false;

	if ( wcName != NULL )
	{
		MSIHANDLE hView		= NULL;
		MSIHANDLE hRecord	= NULL;

		LPWSTR	wcQuery	= NULL;
		LPWSTR	wcBuf	= NULL;

		LPCWSTR wszQuery = L"select distinct `ComponentId` from Component where `Component`=\'";

		DWORD	dwBuf	= BUFF_SIZE;
		DWORD	dwQuery = 0L;
		dwQuery = wcslen ( wszQuery ) + wcslen ( wcName ) + 1 + 1;

		if ( ( wcQuery = new WCHAR [ dwQuery ] ) == NULL )
		{
			throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
		}

		try
		{
			wcscpy ( wcQuery, wszQuery );
			wcscat ( wcQuery, wcName );
			wcscat ( wcQuery, L"\'" );
		}
		catch ( ... )
		{
			delete [] wcQuery;
			wcQuery = NULL;

			throw;
		}

		try
		{
			if ( ( wcBuf = new WCHAR [ dwBuf ] ) == NULL )
			{
				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
		}
		catch ( ... )
		{
			delete [] wcQuery;
			wcQuery = NULL;

			throw;
		}

		HRESULT hRes = S_OK;

        if ( ERROR_SUCCESS == ( hRes = g_fpMsiDatabaseOpenViewW ( hDatabase, wcQuery, &hView ) ) )
		{
            if ( ERROR_SUCCESS == g_fpMsiViewExecute ( hView, 0 ) )
			{
                if ( ERROR_NO_MORE_ITEMS != ( hRes = g_fpMsiViewFetch ( hView, &hRecord ) ) )
				{
                    if ( E_OUTOFMEMORY == hRes )
					{
                        g_fpMsiCloseHandle(hRecord);

                        g_fpMsiViewClose(hView);
                        g_fpMsiCloseHandle(hView);

                        delete [] wcBuf;
                        delete [] wcQuery;

                        throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
                    }

                    if ( ERROR_SUCCESS == g_fpMsiRecordGetStringW ( hRecord, 1, wcBuf, &dwBuf ) )
					{
						//Check to make sure it's on the system
						bResult = ValidateComponentID ( wcBuf, wcProductCode );
					}

                    g_fpMsiCloseHandle(hRecord);
                }
            }

            g_fpMsiViewClose(hView);
            g_fpMsiCloseHandle(hView);

        }
		else
		{
			if ( E_OUTOFMEMORY == hRes )
			{
				delete [] wcBuf;
				delete [] wcQuery;

				throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
			}
        }

		delete [] wcBuf;
		delete [] wcQuery;
    }

    return bResult;
}

bool ValidateFeatureName(WCHAR *wcName, WCHAR *wcProduct)
{
    int i = 0;
    bool bRetVal = false;
    WCHAR * wcBuf = (WCHAR *)malloc(BUFF_SIZE * sizeof(WCHAR));
    if(!wcBuf)
	{
		wcBuf = NULL;
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    WCHAR * wcParent = (WCHAR *)malloc(BUFF_SIZE * sizeof(WCHAR));
    if(!wcParent)
	{
		free ( wcBuf );
		throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);
	}

    UINT uiStatus;

    while((uiStatus = g_fpMsiEnumFeaturesW(wcProduct, i++, wcBuf, wcParent)) != ERROR_NO_MORE_ITEMS){

        if(uiStatus != S_OK){
            bRetVal = false;
            break;
        }

        if(wcscmp(wcName, wcBuf) == 0){
            bRetVal = true;
            break;
        }
    }

    free((void *)wcBuf);
    free((void *)wcParent);

    return bRetVal;
}

bool SafeLeaveCriticalSection(CRITICAL_SECTION *pcs)
{
    void * vpOwner = pcs->OwningThread;
    DWORD dwOwner = PtrToUlong(vpOwner);

    if((pcs->LockCount > -1) && (dwOwner == GetCurrentThreadId()))
        LeaveCriticalSection(pcs);

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\msimeth\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <precomp.h>
#include "classfac.h"
#include "methods.h"

CMethodsFactory::CMethodsFactory()
{
    m_cRef=0L;
    return;
}

CMethodsFactory::~CMethodsFactory(void)
{
    return;
}

STDMETHODIMP CMethodsFactory::QueryInterface(REFIID riid
    , LPVOID * ppv)
{
    *ppv = NULL;

    if(IID_IUnknown==riid || IID_IClassFactory==riid) *ppv = this;

	if(NULL != *ppv){

		AddRef();
		return NOERROR;
	}

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CMethodsFactory::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CMethodsFactory::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long*)&m_cRef);
    if (0L == nNewCount) delete this;
    
    return nNewCount;
}

STDMETHODIMP CMethodsFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, LPVOID * ppvObj)
{
    CMethods *pObj;
    HRESULT hr = S_OK;

    *ppvObj = NULL;
    hr = E_OUTOFMEMORY;

    // This object doesnt support aggregation.
    if(NULL != pUnkOuter) return CLASS_E_NOAGGREGATION;

    // Create the object.
    pObj = new CMethods();

    if(NULL == pObj) return E_OUTOFMEMORY;

    hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if(FAILED(hr)) delete pObj;

    return hr;
}

STDMETHODIMP CMethodsFactory::LockServer(BOOL fLock)
{
    if(fLock) InterlockedIncrement(&g_cLock);
    else InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\msimeth\classfac.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef _ClassFactory_H_
#define _ClassFactory_H_

#define _WIN32_DCOM

// This class is the class factory for CMSIProv objects.

class CMethodsFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CMethodsFactory(void);
        ~CMethodsFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CMethodsFactory *PCMethodsFactory;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\msimeth\methods.cpp ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
#include <precomp.h>
#include "msimethod.h"
#include "methods.h"
#include "msimeth_i.c"

IMsiMethodStatusSink * CMethods::m_pStatusSink = NULL;
bool CMethods::m_bCSReady = false;
CRITICAL_SECTION CMethods::m_cs;
UINT CMethods::m_uiMaxIndex = 0;
UINT CMethods::m_cConnections = 0;
CONNECTDATA*   CMethods::m_paConnections = NULL;

bool g_bMsiPresent = true;
bool g_bMsiLoaded = false;

LPFNMSISETINTERNALUI				g_fpMsiSetInternalUI = NULL;
LPFNMSISETEXTERNALUIW				g_fpMsiSetExternalUIW = NULL;
LPFNMSIENABLELOGW					g_fpMsiEnableLogW = NULL;
LPFNMSIINSTALLPRODUCTW				g_fpMsiInstallProductW = NULL;
LPFNMSICONFIGUREPRODUCTW			g_fpMsiConfigureProductW = NULL;
LPFNMSIREINSTALLPRODUCTW			g_fpMsiReinstallProductW = NULL;
LPFNMSIAPPLYPATCHW					g_fpMsiApplyPatchW = NULL;
LPFNMSICONFIGUREFEATUREW			g_fpMsiConfigureFeatureW = NULL;
LPFNMSIREINSTALLFEATUREW			g_fpMsiReinstallFeatureW = NULL;

CMethods::CMethods()
{
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
	m_dwCheckKeyPresentStatus = ERROR_SUCCESS;
}

CMethods::~CMethods()
{
    InterlockedDecrement(&g_cObj);
}

STDMETHODIMP CMethods::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    // Since we have multiple inheritance, it is necessary to cast the return type
    if(riid == IID_IMsiProductMethods)
       *ppv = (IMsiProductMethods *)this;

	else if(riid == IID_IMsiSoftwareFeatureMethods)
       *ppv = (IMsiSoftwareFeatureMethods *)this;
/*
	else if(riid == IID_IConnectionPointContainer)
       *ppv = (IConnectionPointContainer *)this;

	else if(riid == IID_IConnectionPoint)
       *ppv = (IConnectionPoint *)this;
*/
    else if(riid == IID_IUnknown)
       *ppv = (IMsiProductMethods *)this;
    
    if(*ppv){

        AddRef();
        return NOERROR;

    }else return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CMethods::AddRef(void)
{
	SetEvent(g_hMethodAdd);

    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) CMethods::Release(void)
{
	SetEvent(g_hMethodRelease);

    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);

    if(0 == nNewCount) delete this;
    
    return nNewCount;
}

/*
HRESULT STDMETHODCALLTYPE CMethods::EnumConnectionPoints( 
        IEnumConnectionPoints __RPC_FAR *__RPC_FAR *ppEnum)
{ return E_NOTIMPL; }
        
HRESULT STDMETHODCALLTYPE CMethods::FindConnectionPoint( 
        REFIID riid,
        IConnectionPoint __RPC_FAR *__RPC_FAR *ppCP)
{
	*ppCP = NULL;

    if(riid == IID_IMsiMethodStatusSink)
       *ppCP = (IConnectionPoint *)this;
    
    if(NULL != *ppCP){

        this->AddRef();
        return NOERROR;

    }else return E_NOINTERFACE;
}


HRESULT STDMETHODCALLTYPE CMethods::GetConnectionInterface( 
            IID __RPC_FAR *pIID)
{
	*pIID = IID_IMsiMethodStatusSink;
	
	return S_OK;
}
   
HRESULT STDMETHODCALLTYPE CMethods::GetConnectionPointContainer( 
            IConnectionPointContainer __RPC_FAR *__RPC_FAR *ppCPC)
{
	*ppCPC = (IConnectionPointContainer *)this;

	return this->AddRef();
}
        
HRESULT STDMETHODCALLTYPE CMethods::Advise( 
            IUnknown __RPC_FAR *pUnkSink,
            DWORD __RPC_FAR *pdwCookie)
{
	HRESULT hr = S_OK;
	UINT uiFreeSlot = 0;
	IMsiMethodStatusSink* pISink = NULL;

	if(FAILED(hr = pUnkSink->QueryInterface(IID_IMsiMethodStatusSink, (void **)&pISink)))
		return hr;
	
	// Store the specific sink interface in this connection point's
    // array of live connections. First find a free slot (expand the
    // array if needed).
    hr = GetSlot(&uiFreeSlot);
    if (SUCCEEDED(hr))
    {
		// Assign the new slot with the connection entry.
		m_paConnections[uiFreeSlot].pUnk = pISink;
		m_paConnections[uiFreeSlot].dwCookie = m_dwNextCookie;

		// Assign the output Cookie value.
		*pdwCookie = m_dwNextCookie;

		// Increment the Cookie counter.
		m_dwNextCookie++;

		// Increment the number of live connections.
		m_cConnections++;
    }

	return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CMethods::Unadvise( 
            DWORD dwCookie)
{
	HRESULT hr = NOERROR;
    UINT uiSlot;

	if(0 != dwCookie){

        if(SUCCEEDED(hr = FindSlot(dwCookie, &uiSlot))){

			// Release the sink interface.
			m_paConnections[uiSlot].pUnk->Release();

			// Mark the array entry as empty.
			m_paConnections[uiSlot].dwCookie = 0;

			// Decrement the number of live connections.
			m_cConnections--;
        }

    }else hr = E_INVALIDARG;

	return hr;
}

HRESULT STDMETHODCALLTYPE CMethods::EnumConnections( 
            IEnumConnections __RPC_FAR *__RPC_FAR *ppEnum)
{ return E_NOTIMPL; }
*/

///////////////////////
//Product Mehtods

HRESULT STDMETHODCALLTYPE CMethods::Admin( 
    /* [string][in] */ LPCWSTR wszPackageLocation,
    /* [string][in] */ LPCWSTR wszOptions,
    /* [out] */ UINT __RPC_FAR *puiResult,
    /* [in] */ int iThreadID)
{
	HRESULT hr = S_OK;

	if(CheckForMsiDll()){

		InitStatic(&iThreadID);

		EnterCriticalSection(&m_cs);

		if(SUCCEEDED(hr = PrepareEnvironment())){

			try{

				*puiResult = g_fpMsiInstallProductW(wszPackageLocation, wszOptions);

			}catch(...){
				
				hr = RPC_E_SERVERFAULT;
			}

			ReleaseEnvironment();
		}

		LeaveCriticalSection(&m_cs);
	}

	return hr;
}


HRESULT STDMETHODCALLTYPE CMethods::Advertise( 
    /* [string][in] */ LPCWSTR wszPackageLocation,
    /* [string][in] */ LPCWSTR wszOptions,
    /* [out] */ UINT __RPC_FAR *puiResult,
    /* [in] */ int iThreadID)
{
	HRESULT hr = S_OK;

	if(CheckForMsiDll()){

		InitStatic(&iThreadID);

		EnterCriticalSection(&m_cs);

		if(SUCCEEDED(hr = PrepareEnvironment())){

			try{

				*puiResult = g_fpMsiInstallProductW(wszPackageLocation, wszOptions);

			}catch(...){
				
				hr = RPC_E_SERVERFAULT;
			}

			ReleaseEnvironment();
		}

		LeaveCriticalSection(&m_cs);
	}

	return hr;
}


HRESULT STDMETHODCALLTYPE CMethods::Configure( 
    /* [string][in] */ LPCWSTR wszProductCode,
    /* [in] */ int iInstallLevel,
    /* [in] */ int isInstallState,
    /* [out] */ UINT __RPC_FAR *puiResult,
    /* [in] */ int iThreadID)
{
	HRESULT hr = S_OK;

	if(CheckForMsiDll()){

		InitStatic(&iThreadID);

		EnterCriticalSection(&m_cs);

		if(SUCCEEDED(hr = PrepareEnvironment())){

			try{

				*puiResult = g_fpMsiConfigureProductW(wszProductCode, iInstallLevel,
					(INSTALLSTATE)isInstallState);

			}catch(...){
				
				hr = RPC_E_SERVERFAULT;
			}

			ReleaseEnvironment();
		}

		LeaveCriticalSection(&m_cs);
	
	}

	return hr;
}


HRESULT STDMETHODCALLTYPE CMethods::Install( 
    /* [string][in] */ LPCWSTR wszPackageLocation,
    /* [string][in] */ LPCWSTR wszOptions,
    /* [out] */ UINT __RPC_FAR *puiResult,
    /* [in] */ int iThreadID)
{
	HRESULT hr = S_OK;

	if(CheckForMsiDll()){

		InitStatic(&iThreadID);

		EnterCriticalSection(&m_cs);

		if(SUCCEEDED(hr = PrepareEnvironment())){

			try{

				*puiResult = g_fpMsiInstallProductW(wszPackageLocation, wszOptions);

			}catch(...){
				
				hr = RPC_E_SERVERFAULT;
			}

			ReleaseEnvironment();
		}

		LeaveCriticalSection(&m_cs);
	}

	return hr;
}


HRESULT STDMETHODCALLTYPE CMethods::Reinstall( 
    /* [string][in] */ LPCWSTR wszProductCode,
    /* [in] */ DWORD dwReinstallMode,
    /* [out] */ UINT __RPC_FAR *puiResult,
    /* [in] */ int iThreadID)
{
	HRESULT hr = S_OK;

	if(CheckForMsiDll()){

		InitStatic(&iThreadID);

		EnterCriticalSection(&m_cs);

		if(SUCCEEDED(hr = PrepareEnvironment())){

			try{

				*puiResult = g_fpMsiReinstallProductW(wszProductCode, dwReinstallMode);

			}catch(...){
				
				hr = RPC_E_SERVERFAULT;
			}

			ReleaseEnvironment();
		}

		LeaveCriticalSection(&m_cs);
	}

	return hr;
}


HRESULT STDMETHODCALLTYPE CMethods::Uninstall( 
    /* [string][in] */ LPCWSTR wszProductCode,
    /* [out] */ UINT __RPC_FAR *puiResult,
    /* [in] */ int iThreadID)
{
	HRESULT hr = S_OK;

	if(CheckForMsiDll()){

		InitStatic(&iThreadID);

		EnterCriticalSection(&m_cs);

		if(SUCCEEDED(hr = PrepareEnvironment())){

			try{

				*puiResult = g_fpMsiConfigureProductW(wszProductCode, INSTALLLEVEL_DEFAULT,
					INSTALLSTATE_ABSENT);

			}catch(...){
				
				hr = RPC_E_SERVERFAULT;
			}

			ReleaseEnvironment();
		}

		LeaveCriticalSection(&m_cs);
	}

	return hr;
}


HRESULT STDMETHODCALLTYPE CMethods::Upgrade( 
    /* [string][in] */ LPCWSTR wszPackageLocation,
    /* [string][in] */ LPCWSTR wszOptions,
    /* [out] */ UINT __RPC_FAR *puiResult,
    /* [in] */ int iThreadID)
{
	HRESULT hr = S_OK;

	if(CheckForMsiDll()){

		InitStatic(&iThreadID);

		EnterCriticalSection(&m_cs);

		if(SUCCEEDED(hr = PrepareEnvironment())){

			try{

				*puiResult = g_fpMsiApplyPatchW(wszPackageLocation, NULL, INSTALLTYPE_DEFAULT, wszOptions);

			}catch(...){
				
				hr = RPC_E_SERVERFAULT;
			}

			ReleaseEnvironment();
		}

		LeaveCriticalSection(&m_cs);
	}

	return hr;
}


///////////////////////
//SoftwareFeature Mehtods

HRESULT STDMETHODCALLTYPE CMethods::ConfigureSF( 
    /* [string][in] */ LPCWSTR wszProductCode,
    /* [string][in] */ LPCWSTR wszFeature,
    /* [in] */ int isInstallState,
    /* [out] */ UINT __RPC_FAR *puiResult,
    /* [in] */ int iThreadID)
{
	HRESULT hr = S_OK;

	if(CheckForMsiDll()){

		InitStatic(&iThreadID);

		EnterCriticalSection(&m_cs);

		if(SUCCEEDED(hr = PrepareEnvironment())){

			try{

				*puiResult = g_fpMsiConfigureFeatureW(wszProductCode, wszFeature,
					(INSTALLSTATE)isInstallState);

			}catch(...){
				
				hr = RPC_E_SERVERFAULT;
			}

			ReleaseEnvironment();
		}

		LeaveCriticalSection(&m_cs);
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE CMethods::ReinstallSF( 
        /* [string][in] */ LPCWSTR wszProductCode,
        /* [string][in] */ LPCWSTR wszFeature,
        /* [in] */ DWORD dwReinstallMode,
        /* [out] */ UINT __RPC_FAR *puiResult,
        /* [in] */ int iThreadID)
{
	HRESULT hr = S_OK;

	if(CheckForMsiDll()){

		InitStatic(&iThreadID);

		EnterCriticalSection(&m_cs);

		if(SUCCEEDED(hr = PrepareEnvironment())){

			try{

				*puiResult = g_fpMsiReinstallFeatureW(wszProductCode, wszFeature, dwReinstallMode);

			}catch(...){
				
				hr = RPC_E_SERVERFAULT;
			}

			ReleaseEnvironment();
		}

		LeaveCriticalSection(&m_cs);
	}

	return hr;
}

HRESULT CMethods::InitStatic(int *piThreadID)
{
	HRESULT hr = S_OK;

	//Initialize the critical section object
	if(!m_bCSReady){

		InitializeCriticalSection(&m_cs);
		m_bCSReady = true;
	
		CONNECTDATA* paConns;

		// Build the initial dynamic array for connections.
		paConns = new CONNECTDATA[10];
		if(NULL != paConns){

			// Zero the array.
			memset(paConns, 0, 10 * sizeof(CONNECTDATA));

			// Rig this connection point object so that it will use the
			// new internal array of connections.
			m_uiMaxIndex = 10;
			m_paConnections = paConns;

			m_dwNextCookie = 0;
			m_cConnections = 0;

		}else hr = E_OUTOFMEMORY;
	}

	g_fpMsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

	g_fpMsiSetExternalUIW(this->EventHandler, (INSTALLLOGMODE_PROGRESS | INSTALLLOGMODE_ACTIONDATA
		| INSTALLLOGMODE_INFO | INSTALLLOGMODE_WARNING | INSTALLLOGMODE_ACTIONSTART),
		(void *)piThreadID);

	g_fpMsiEnableLogW((INSTALLLOGMODE_ACTIONDATA | INSTALLLOGMODE_INFO | INSTALLLOGMODE_FATALEXIT |
		INSTALLLOGMODE_ERROR | INSTALLLOGMODE_WARNING | INSTALLLOGMODE_USER |
		INSTALLLOGMODE_RESOLVESOURCE | INSTALLLOGMODE_OUTOFDISKSPACE | INSTALLLOGMODE_COMMONDATA |
		INSTALLLOGMODE_ACTIONSTART), NULL, TRUE);

	return hr;
}

HRESULT CMethods::GetSlot(UINT* puiFreeSlot)
{
    HRESULT hr = NOERROR;
    BOOL bOpen = FALSE;
    UINT i;
    CONNECTDATA* paConns;

    // Zero the output variable.
    *puiFreeSlot = 0;

    // Loop to find an empty slot.
    for(i=0; i<m_uiMaxIndex; i++){

		if(m_paConnections[i].dwCookie == 0){

			// We found an open empty slot.
			*puiFreeSlot = i;
			bOpen = TRUE;
			break;
		}
    }

    if(!bOpen){

		// We didn't find an existing open slot in the array--it's full.
		// Expand the array by ALLOC_CONNECTIONS entries and assign the
		// appropriate output index.
		paConns = new CONNECTDATA[m_uiMaxIndex + 10];

		if(NULL != paConns){

			// Copy the content of the old full array to the new larger array.
			for(i=0; i<m_uiMaxIndex; i++){

				paConns[i].pUnk = m_paConnections[i].pUnk;
				paConns[i].dwCookie = m_paConnections[i].dwCookie;
			}

			// Zero (ie mark as empty) the expanded portion of the new array.
			for(i=m_uiMaxIndex; i<m_uiMaxIndex+10; i++){

				paConns[i].pUnk = NULL;
				paConns[i].dwCookie = 0;
			}

			// New larger array is ready--delete the old array.
			delete [] m_paConnections;

			// Rig the connection point to use the new larger array.
			m_paConnections = paConns;

			// Assign the output free slot as first entry in new expanded area.
			*puiFreeSlot = m_uiMaxIndex;

			// Calculate the new max index.
			m_uiMaxIndex += 10;

		}else hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CMethods::FindSlot(
            DWORD dwCookie,
            UINT* puiSlot)
{
	HRESULT hr = CONNECT_E_NOCONNECTION;
	UINT i;

	// Loop to find the Cookie.
	for(i=0; i<m_uiMaxIndex; i++){

		if(dwCookie == m_paConnections[i].dwCookie){

			// If a cookie match is found, assign the output slot index.
			*puiSlot = i;
			hr = NOERROR;
			break;
		}
	}

	return hr;
}
  
  

DWORD CMethods::GetAccount(HANDLE TokenHandle, WCHAR *wcDomain, WCHAR *wcUser)
{
	DWORD dwStatus = S_OK;

	TOKEN_USER *tTokenUser = NULL;
	DWORD dwReturnLength = 0;
	TOKEN_INFORMATION_CLASS tTokenInformationClass = TokenUser;

	if(!GetTokenInformation(TokenHandle, tTokenInformationClass, NULL, 0, &dwReturnLength) &&
		GetLastError () == ERROR_INSUFFICIENT_BUFFER){

		tTokenUser = (TOKEN_USER*) new UCHAR[dwReturnLength];

        if(TokenUser){

            try{

		        if(GetTokenInformation(TokenHandle, tTokenInformationClass,
					(void *)tTokenUser, dwReturnLength, &dwReturnLength)){

					DWORD dwUserSize = BUFF_SIZE;
					DWORD dwDomainSize = BUFF_SIZE;
					SID_NAME_USE Use;

					if(!LookupAccountSidW(NULL, tTokenUser->User.Sid, wcUser, &dwUserSize,
						wcDomain, &dwDomainSize, &Use)){

						dwStatus = GetLastError();
					}

		        }else dwStatus = GetLastError();


            }catch(...){

    			delete [] (UCHAR *)tTokenUser;
                throw;
            }

			delete [] (UCHAR *)tTokenUser;

        }else{

			throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }

	}else dwStatus = GetLastError();

	return dwStatus ;
}

DWORD CMethods::GetSid(HANDLE TokenHandle, WCHAR *wcSID)
{
	DWORD dwStatus = S_OK ;

	TOKEN_USER *tTokenUser = NULL ;
	DWORD dwReturnLength = 0 ;
	TOKEN_INFORMATION_CLASS tTokenInformationClass = TokenUser ;

	if(!GetTokenInformation(TokenHandle, tTokenInformationClass, NULL, 0, &dwReturnLength) &&
		GetLastError() == ERROR_INSUFFICIENT_BUFFER){

		tTokenUser = (TOKEN_USER *) new UCHAR[dwReturnLength] ;
		
		if(TokenUser){

			try{

				if(GetTokenInformation(TokenHandle, tTokenInformationClass, (void *)tTokenUser,
					dwReturnLength, &dwReturnLength)){

					// Initialize m_strSid - human readable form of our SID
					SID_IDENTIFIER_AUTHORITY *psia = ::GetSidIdentifierAuthority(tTokenUser->User.Sid);
					
					// We assume that only last byte is used (authorities between 0 and 15).
					// Correct this if needed.
//					ASSERT(psia->Value[0] == psia->Value[1] == psia->Value[2] == psia->Value[3]
//						== psia->Value[4] == 0);
					DWORD dwTopAuthority = psia->Value[5];

					WCHAR bstrtTempSid[BUFF_SIZE];
					wcscpy(bstrtTempSid, L"S-1-");

					WCHAR wstrAuth[32];
					ZeroMemory(wstrAuth, 32);
					_itow(dwTopAuthority, wstrAuth, 10);
					wcscat(bstrtTempSid, wstrAuth);
					int iSubAuthorityCount = *(GetSidSubAuthorityCount(tTokenUser->User.Sid));

					for(int i = 0; i < iSubAuthorityCount; i++){

						DWORD dwSubAuthority = *(GetSidSubAuthority( tTokenUser->User.Sid, i ));
						ZeroMemory(wstrAuth, wcslen(wstrAuth));
						_itow(dwSubAuthority, wstrAuth,10);
						wcscat(bstrtTempSid, L"-");
						wcscat(bstrtTempSid, wstrAuth);
					}
					// Now allocate the passed in wstr:
					WCHAR* wstrtemp = NULL;

					try{
						wstrtemp = (WCHAR*) new WCHAR[wcslen(bstrtTempSid) + 1];

						if(wstrtemp!=NULL){

							ZeroMemory(wstrtemp, wcslen(bstrtTempSid) + 1);
							wcscpy(wstrtemp, (WCHAR*)bstrtTempSid);
						}

						wcSID = wstrtemp;

					}catch(...){

						if(wstrtemp!=NULL){

							delete wstrtemp;
							wstrtemp = NULL;
						}

						throw;
					}  

				}else dwStatus = GetLastError();

			}catch(...){

				delete [] (UCHAR *)tTokenUser;

				throw ;			
			}

			delete [] (UCHAR *)tTokenUser;

		}else throw CHeap_Exception(CHeap_Exception::E_ALLOCATION_ERROR);

	}else dwStatus = GetLastError();

	return dwStatus ;
}


DWORD CMethods::LoadHive(LPWSTR pszUserName, LPWSTR pszKeyName)
{
    DWORD i, dwSIDSize, dwDomainNameSize, dwRetCode, dwSubAuthorities ;
	char SIDBuffer[_MAX_PATH];
    WCHAR szDomainName[_MAX_PATH], szSID[_MAX_PATH], szTemp[_MAX_PATH]  ;
    SID *pSID = (SID *) SIDBuffer ;
    PSID_IDENTIFIER_AUTHORITY pSIA ;
    SID_NAME_USE AccountType ;
    WCHAR wcTemp[BUFF_SIZE];
    CRegistry Reg ;

    // Set the necessary privs
    //========================

    dwRetCode = AcquirePrivilege();
    if(dwRetCode != ERROR_SUCCESS)
    {
        return dwRetCode;
    }

    // Look up the user's account info
    //================================
    dwSIDSize = strlen(SIDBuffer) ;
    dwDomainNameSize = wcslen(szDomainName) ;

	int iLookup;
	{
//		CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

		iLookup = LookupAccountNameW(NULL, pszUserName, pSID, &dwSIDSize, 
		                      szDomainName, &dwDomainNameSize, &AccountType);
    }

	if(!iLookup){

	    RestorePrivilege();
        CoImpersonateClient();
        return ERROR_BAD_USERNAME ;
    }



    // Translate the SID into text (a la PSS article Q131320)
    //=======================================================

    pSIA = GetSidIdentifierAuthority(pSID) ;
    dwSubAuthorities = *GetSidSubAuthorityCount(pSID) ;
    dwSIDSize = wprintf(szSID, TEXT("S-%lu-"), (DWORD) SID_REVISION) ;

    if((pSIA->Value[0] != 0) || (pSIA->Value[1] != 0)){

        dwSIDSize += swprintf(szSID + wcslen(szSID), L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                             (USHORT) pSIA->Value[0],
                             (USHORT) pSIA->Value[1],
                             (USHORT) pSIA->Value[2],
                             (USHORT) pSIA->Value[3],
                             (USHORT) pSIA->Value[4],
                             (USHORT) pSIA->Value[5]) ;
    }else{

        dwSIDSize += swprintf(szSID + wcslen(szSID), L"%lu",
                             (ULONG)(pSIA->Value[5]      ) +
                             (ULONG)(pSIA->Value[4] <<  8) +
                             (ULONG)(pSIA->Value[3] << 16) +
                             (ULONG)(pSIA->Value[2] << 24));
    }
 
    for(i = 0 ; i < dwSubAuthorities ; i++){

        dwSIDSize += swprintf(szSID + dwSIDSize, L"-%lu",
                             *GetSidSubAuthority(pSID, i)) ;
    }

    // See if the key already exists
    //==============================

    dwRetCode = Reg.Open(HKEY_USERS, szSID, KEY_READ) ;

    // We need to keep a handle open.  See m_hKey below, so we'll let the destructor close this.
//    Reg.Close();

    if(dwRetCode != ERROR_SUCCESS){
		
        // Try to locate user's registry hive
        //===================================

        swprintf(szTemp, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%s", szSID) ;
        dwRetCode = Reg.Open(HKEY_LOCAL_MACHINE, szTemp, KEY_READ);

        if(dwRetCode == ERROR_SUCCESS){

			CHString chsTemp(wcTemp);
        
            dwRetCode = Reg.GetCurrentKeyValue(L"ProfileImagePath", chsTemp);
            Reg.Close();

            if(dwRetCode == ERROR_SUCCESS){
                
                // NT 4 doesn't include the file name in the registry
                //===================================================

                if(!IsLessThan4()){
                    
                    wcscat(wcTemp, L"\\NTUSER.DAT");
                }

                ExpandEnvironmentStringsW(wcTemp, szTemp, sizeof(szTemp) / sizeof(TCHAR)) ;

				// Try it three times, another process may have the file open
				bool bTryTryAgain = false;
				int  nTries = 0;

				do{
					// need to serialize access, using "write" because RegLoadKey wants exclusive access
					// even though it is a read operation
					EnterCriticalSection(&m_cs);
	                dwRetCode = (DWORD) RegLoadKeyW(HKEY_USERS, szSID, szTemp) ;
					LeaveCriticalSection(&m_cs);
					
					if((dwRetCode == ERROR_SHARING_VIOLATION)
						&& (++nTries < 11)){
						
						Sleep(20 * nTries);	
						bTryTryAgain = true;

					}else{

						bTryTryAgain = false;
                    }
					
				}while (bTryTryAgain);
				
                // if we still can't get in, tell somebody.
//                if (dwRetCode == ERROR_SHARING_VIOLATION)
//    			    LogErrorMessage(_T("Sharing violation on NTUSER.DAT (Load)"));

			}
        }
    }

    if(dwRetCode == ERROR_SUCCESS){
		
        wcscpy(pszKeyName, szSID) ;

        LONG lRetVal;
        WCHAR wcKey[BUFF_SIZE];
		wcscpy(wcKey, szSID);

        wcscat(wcKey, L"\\Software");
        lRetVal = RegOpenKeyExW(HKEY_USERS, wcKey, 0, KEY_QUERY_VALUE, &m_hKey);

//        ASSERT_BREAK(lRetVal == ERROR_SUCCESS);
    }

    // Restore original privilege level & end self-impersonation
    //==========================================================

    RestorePrivilege() ;
    return dwRetCode ;    
}

DWORD CMethods::UnloadHive(LPCWSTR pszKeyName) 
{
    DWORD dwRetCode = ERROR_SUCCESS;
    
    if(m_hKey != NULL){

        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

	dwRetCode = AcquirePrivilege();
    
	if(dwRetCode == ERROR_SUCCESS){
        
        EnterCriticalSection(&m_cs);
		dwRetCode = RegUnLoadKeyW(HKEY_USERS, pszKeyName) ;
		LeaveCriticalSection(&m_cs);
        
		RestorePrivilege() ;
    }

    return dwRetCode ;
}

DWORD CMethods::AcquirePrivilege() 
{
	// are you calling in twice?  Shouldn't.
    // at worst, it would cause a leak, so I'm going with it anyway.
//    ASSERT_BREAK(m_pOriginalPriv == NULL);
    
    BOOL bRetCode = FALSE;
    HANDLE hToken = INVALID_HANDLE_VALUE ;
    TOKEN_PRIVILEGES TPriv ;
    LUID LUID ;

    // Validate the platform
    //======================

    // Try getting the thread token.  If it fails the first time it's 
    // because we're a system thread and we don't yet have a thread 
    // token, so just impersonate self and try again.
    if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | 
        TOKEN_QUERY, FALSE, &hToken))
	{

        try{

            GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &m_dwSize);

            if (m_dwSize > 0){

                // This is cleaned in the destructor, so no try/catch required
                m_pOriginalPriv = (TOKEN_PRIVILEGES*) new BYTE[m_dwSize];

                if (m_pOriginalPriv == NULL){

                    throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
                }

            }

            if(m_pOriginalPriv && GetTokenInformation(hToken, TokenPrivileges, m_pOriginalPriv, m_dwSize, &m_dwSize)){ 

			    // DEADLOCK ON NT! it's actually an NT bug, but we have to protect ourselves
//			    CreateMutexAsProcess createMutexAsProcess(SECURITYAPIMUTEXNAME);

			    bRetCode = LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &LUID);

			    if(bRetCode){

				    TPriv.PrivilegeCount = 1 ;
				    TPriv.Privileges[0].Luid = LUID ;
				    TPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

				    bRetCode = AdjustTokenPrivileges(hToken, FALSE, &TPriv,
						sizeof(TOKEN_PRIVILEGES), NULL, NULL);
		        }
			    bRetCode = LookupPrivilegeValue(NULL, SE_BACKUP_NAME, &LUID);

			    if(bRetCode){

				    TPriv.PrivilegeCount = 1 ;
				    TPriv.Privileges[0].Luid = LUID ;
				    TPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

				    bRetCode = AdjustTokenPrivileges(hToken, FALSE, &TPriv,
						sizeof(TOKEN_PRIVILEGES), NULL, NULL) ;
		        }
		    }

        }catch(...){

            CloseHandle(hToken);
            throw ;
        }

        CloseHandle(hToken);
    }

    if(!bRetCode){
		
        return GetLastError();
    }

    return ERROR_SUCCESS ;    
}

void CMethods::RestorePrivilege() 
{    
//    ASSERT_BREAK(m_pOriginalPriv != NULL);
    
    if (m_pOriginalPriv != NULL){

        HANDLE hToken;

        try{
            if (OpenThreadToken(GetCurrentThread(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, TRUE, &hToken)){

                AdjustTokenPrivileges(hToken, FALSE, m_pOriginalPriv, m_dwSize, NULL, NULL);
                CloseHandle(hToken) ;
            }

        }catch(...){

            delete m_pOriginalPriv;
            m_pOriginalPriv = NULL;
            m_dwSize = 0;

            throw;
        }

        delete m_pOriginalPriv;
        m_pOriginalPriv = NULL;
        m_dwSize = 0;
    }
}

HRESULT CMethods::PrepareEnvironment()
{
//	PROCESS_INFORMATION piMethods;
	STARTUPINFO siMethods;

	ZeroMemory(&siMethods, sizeof(siMethods));
	siMethods.cb = sizeof(siMethods);

	try{

		HANDLE hClientToken = INVALID_HANDLE_VALUE;

		//Get thread token
		if(!OpenThreadToken(GetCurrentThread(), (TOKEN_DUPLICATE |TOKEN_QUERY |
							TOKEN_ASSIGN_PRIMARY), TRUE, &hClientToken)){

			return GetLastError();
		}

		//Prepare registry

		DWORD dwStatus = ERROR_SUCCESS;
		WCHAR wcDomain[BUFF_SIZE];
		WCHAR wcUser[BUFF_SIZE];

		if((dwStatus = GetAccount(hClientToken, wcDomain, wcUser)) != 0)
			return GetLastError();

		WCHAR wcAccount[BUFF_SIZE];
		wcscpy(wcAccount, wcDomain);
		wcscat(wcAccount, L"\\");
		wcscat(wcAccount, wcUser);

		WCHAR wcSID[BUFF_SIZE];

		if((dwStatus = GetSid(hClientToken, wcSID)) == ERROR_SUCCESS){

			CRegistry Reg ;
			//check if SID already present under HKEY_USER ...
			m_dwCheckKeyPresentStatus = Reg.Open(HKEY_USERS, wcSID, KEY_READ);
			Reg.Close() ;

			if(m_dwCheckKeyPresentStatus != ERROR_SUCCESS)
				dwStatus = LoadHive(wcAccount, m_wcKeyName);
		}

		if(dwStatus != ERROR_SUCCESS){

			dwStatus = GetLastError();
		}

		///////////////

	}catch(...){

		throw;
	}

	return S_OK;
}

HRESULT CMethods::ReleaseEnvironment()
{
	//remove the key if it wasn't there b4....
	if(m_dwCheckKeyPresentStatus != ERROR_SUCCESS){

		UnloadHive(m_wcKeyName);
	}

	return S_OK;
}

int WINAPI CMethods::EventHandler(LPVOID pvContext, UINT iMessageType, LPCWSTR szMessage)
{
	// Loop to find the Cookie.
/*	for(UINT i = 0; i < m_cConnections; i++){

		IMsiMethodStatusSink * pStatus = (IMsiMethodStatusSink *)m_paConnections[i].pUnk;

		if(pStatus) pStatus->Indicate((int *)pvContext,iMessageType, szMessage);
	}
*/
	if(g_bPipe){
		
		int *piContext = (int*)(pvContext);

		WCHAR wcMessage[1000];
		WCHAR wcTmp[100];
		
		wcscpy(wcMessage, _itow(*piContext, wcTmp, 10));
		wcscat(wcMessage, L"~");
		wcscat(wcMessage, _itow(iMessageType, wcTmp, 10));
		wcscat(wcMessage, L"~");
		wcscat(wcMessage, szMessage);
		wcscat(wcMessage, L"\n");

		DWORD dwWritten = 0;

		//synchronized pipe access
//		WaitForSingleObject(g_hMutex, INFINITE);

		WriteFile(g_hPipe, wcMessage, (wcslen(wcMessage) * 2), &dwWritten, NULL);

//		ReleaseMutex(g_hMutex);
	}

	return 0;
}

//Ensure msi.dll and functions are loaded if present on system
bool CMethods::CheckForMsiDll()
{
	if(!g_bMsiLoaded){
		
		//synchronize us with the perf counters
		HANDLE hMutex = OpenMutex(SYNCHRONIZE, FALSE, WBEMPERFORMANCEDATAMUTEX);
		if(hMutex) WaitForSingleObject(hMutex, INFINITE);

		HINSTANCE hiMsiDll = LoadLibraryW(L"msi.dll");

		if(!hiMsiDll){

			hiMsiDll = LoadLibraryA("msi.dll");

			if(!hiMsiDll){

				char cBuf[MAX_PATH] = { '\0' };

				if ( GetSystemDirectoryA(cBuf, MAX_PATH) != 0 )
				{
					if ( ( strlen ( cBuf ) + strlen ( "\\msi.dll" ) + 1 ) < MAX_PATH )
					{
						strcat(cBuf, "\\msi.dll");
						hiMsiDll = LoadLibraryA(cBuf);
					}
				}
			}
		}

		if(hiMsiDll){

			//Load the function pointers
			g_fpMsiSetInternalUI = (LPFNMSISETINTERNALUI)GetProcAddress(hiMsiDll, "MsiSetInternalUI");
			g_fpMsiSetExternalUIW = (LPFNMSISETEXTERNALUIW)GetProcAddress(hiMsiDll, "MsiSetExternalUIW");
			g_fpMsiEnableLogW = (LPFNMSIENABLELOGW)GetProcAddress(hiMsiDll, "MsiEnableLogW");
			g_fpMsiInstallProductW = (LPFNMSIINSTALLPRODUCTW)GetProcAddress(hiMsiDll, "MsiInstallProductW");
			g_fpMsiConfigureProductW = (LPFNMSICONFIGUREPRODUCTW)GetProcAddress(hiMsiDll, "MsiConfigureProductW");
			g_fpMsiReinstallProductW = (LPFNMSIREINSTALLPRODUCTW)GetProcAddress(hiMsiDll, "MsiReinstallProductW");
			g_fpMsiApplyPatchW = (LPFNMSIAPPLYPATCHW)GetProcAddress(hiMsiDll, "MsiApplyPatchW");
			g_fpMsiConfigureFeatureW = (LPFNMSICONFIGUREFEATUREW)GetProcAddress(hiMsiDll, "MsiConfigureFeatureW");
			g_fpMsiReinstallFeatureW = (LPFNMSIREINSTALLFEATUREW)GetProcAddress(hiMsiDll, "MsiReinstallFeatureW");
			
			// Did we get all the pointers we need?
			if(g_fpMsiSetInternalUI && g_fpMsiSetExternalUIW && g_fpMsiEnableLogW &&
				g_fpMsiInstallProductW && g_fpMsiConfigureProductW && g_fpMsiReinstallProductW &&
				g_fpMsiApplyPatchW && g_fpMsiConfigureFeatureW && g_fpMsiReinstallFeatureW){

				g_bMsiLoaded = true;
			
			}
		
		}else{

			g_bMsiPresent = false;
		}

		if(hMutex){

			ReleaseMutex(hMutex);
			CloseHandle(hMutex);
		}
	}

	return g_bMsiLoaded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\msimeth\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WBEM MSI Instance provider method execution

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <initguid.h>
#include <precomp.h>
#include "classfac.h"
#include "msimeth_i.c"

HMODULE ghModule;

//Count number of objects and number of locks.
long       g_cObj=0;
long       g_cLock=0;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason
    , LPVOID pvReserved)
{
    if(DLL_PROCESS_ATTACH == ulReason)
	{
		DisableThreadLibraryCalls(hInstance);			// 158024 
	}

    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv)
{
    HRESULT hr = S_OK;
    CMethodsFactory *pObj = NULL;

    if((CLSID_MsiProductMethods != rclsid) &&
		(CLSID_MsiSoftwareFeatureMethods != rclsid))
		return E_FAIL;

    pObj = new CMethodsFactory();

    if(NULL == pObj) return E_OUTOFMEMORY;

    hr = pObj->QueryInterface(riid, ppv);

    if(FAILED(hr)) delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc = (0L == g_cObj && 0L == g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL IsLessThan4()
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

	return os.dwMajorVersion < 4;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{
    char       szID[265];
	WCHAR       wcID[265];
    char       szCLSID[265];
    char       szModule[MAX_PATH];
    char * pName = "IMsiProductMethods";
    char * pModel;
    HKEY hKey, hKey1, hKey2;

	ghModule = GetModuleHandleA("MSIMETH");

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

	if(IsLessThan4()) pModel = "Apartment";
	else pModel = "Both";

	//////////////////////////////////////
	// Product Methods Implementation

	// Create the path.
    StringFromGUID2(CLSID_MsiProductMethods, wcID, 128);
	WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, wcID, (-1), szID, 256, NULL, NULL);

    strcpy(szCLSID, "Software\\classes\\CLSID\\");
    strcat(szCLSID, szID);

	char szProviderCLSIDAppID[128];
	strcpy(szProviderCLSIDAppID, "SOFTWARE\\CLASSES\\APPID\\");
	strcat(szProviderCLSIDAppID, szID);

	RegCreateKeyA(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID, &hKey);
    RegSetValueExA(hKey, NULL, 0, REG_SZ, (BYTE *)pName, (strlen(pName) * 2)+1);

	CloseHandle(hKey);

	RegCreateKeyA(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueExA(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, (strlen(pName) * 2)+1);

	// Create entries under CLSID
	RegCreateKeyA(hKey1, "LocalServer32", &hKey2);

	GetModuleFileNameA(ghModule, szModule,  MAX_PATH);

    RegSetValueExA(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, (strlen(szModule) * 2)+1);
    RegSetValueExA(hKey2, "ThreadingModel", 0, REG_SZ, (BYTE *)pModel, (strlen(pModel) * 2)+1);

    CloseHandle(hKey1);
    CloseHandle(hKey2);

	//////////////////////////////////////
	// Software Feature Methods Implementation

	pName = "IMsiSoftwareFeatureMethods";

	// Create the path.
    StringFromGUID2(CLSID_MsiSoftwareFeatureMethods, wcID, 128);
	WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, wcID, (-1), szID, 256, NULL, NULL);

    strcpy(szCLSID, "Software\\classes\\CLSID\\");
    strcat(szCLSID, szID);

	strcpy(szProviderCLSIDAppID, "SOFTWARE\\CLASSES\\APPID\\");
	strcat(szProviderCLSIDAppID, szID);

	RegCreateKeyA(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID, &hKey);
    RegSetValueExA(hKey, NULL, 0, REG_SZ, (BYTE *)pName, (strlen(pName) * 2)+1);

	CloseHandle(hKey);

	RegCreateKeyA(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);
    RegSetValueExA(hKey1, NULL, 0, REG_SZ, (BYTE *)pName, (strlen(pName) * 2)+1);

	// Create entries under CLSID
	RegCreateKeyA(hKey1, "LocalServer32", &hKey2);

	GetModuleFileNameA(ghModule, szModule,  MAX_PATH);

    RegSetValueExA(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, (strlen(szModule) * 2)+1);
    RegSetValueExA(hKey2, "ThreadingModel", 0, REG_SZ, (BYTE *)pModel, (strlen(pModel) * 2)+1);

    CloseHandle(hKey1);
    CloseHandle(hKey2);

    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    WCHAR wcID[256];
	char szID[256];
    char wcCLSID[256];
    HKEY hKey;

    //////////////////////////////////////
	// Product Methods Implementation

	// Create the path.
    StringFromGUID2(CLSID_MsiProductMethods, wcID, 128);
	WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, wcID, (-1), szID, 256, NULL, NULL);

    strcpy(wcCLSID, "Software\\classes\\CLSID\\");
    strcat(wcCLSID, szID);

	char szProviderCLSIDAppID[128];
	strcpy(szProviderCLSIDAppID, "SOFTWARE\\CLASSES\\APPID\\");
	strcat(szProviderCLSIDAppID,wcCLSID);

	//Delete entries under APPID

	RegDeleteKeyA(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID);

	char szTemp[128];
	strcpy(szTemp, wcCLSID);
	strcat(szTemp,"\\");
	strcat(szTemp,"LocalServer32");
	RegDeleteKeyA(HKEY_CLASSES_ROOT, szTemp);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKeyA(HKEY_LOCAL_MACHINE, wcCLSID, &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKeyA(hKey, "InprocServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKeyA(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKeyA(hKey,szID);
        CloseHandle(hKey);
    }

	//////////////////////////////////////
	// Software Feature Methods Implementation

	// Create the path.
    StringFromGUID2(CLSID_MsiSoftwareFeatureMethods, wcID, 128);
	WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, wcID, (-1), szID, 256, NULL, NULL);

    strcpy(wcCLSID, "Software\\classes\\CLSID\\");
    strcat(wcCLSID, szID);

	strcpy(szProviderCLSIDAppID, "SOFTWARE\\CLASSES\\APPID\\");
	strcat(szProviderCLSIDAppID,wcCLSID);

	//Delete entries under APPID

	RegDeleteKeyA(HKEY_LOCAL_MACHINE, szProviderCLSIDAppID);

	strcpy(szTemp, wcCLSID);
	strcat(szTemp,"\\");
	strcat(szTemp,"LocalServer32");
	RegDeleteKeyA(HKEY_CLASSES_ROOT, szTemp);

    // First delete the InProcServer subkey.

    dwRet = RegOpenKeyA(HKEY_LOCAL_MACHINE, wcCLSID, &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKeyA(hKey, "InprocServer32");
        CloseHandle(hKey);
    }

    dwRet = RegOpenKeyA(HKEY_LOCAL_MACHINE, "Software\\classes\\CLSID", &hKey);
    if(dwRet == NO_ERROR){
        RegDeleteKeyA(hKey,szID);
        CloseHandle(hKey);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\msimeth\msimethod.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//

#define _WIN32_DCOM

#define   READ_HANDLE 0
#define   WRITE_HANDLE 1

extern BOOL APIENTRY DllMain (					  
	HINSTANCE hinstDLL,
	DWORD fdwReason, 
	LPVOID lpReserved
);

STDAPI DllRegisterServer();
STDAPI DllUnregisterServer();

BOOL IsLessThan4();
BOOL IsNT();
//LRESULT CALLBACK WndProc(IN HWND hWnd, IN UINT message,
//                        IN WPARAM wParam, IN LPARAM lParam);
//HWND CreateMsiMethWindow(IN HINSTANCE hInstance);
//HRESULT UninitComServer ();
//HRESULT InitInstanceProvider();
//HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel );
//void WindowsDispatch ();
//HRESULT Process ();
void TerminateRunning();
BOOL ParseCommandLine ();
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow);

extern HANDLE g_hTerminateEvent;
extern HANDLE g_hMethodAdd;
extern HANDLE g_hMethodRelease;
extern HANDLE g_hPipe;
extern HANDLE g_hMutex;
extern bool g_bPipe;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\msimeth\methods.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//

#include "msi.h"
#include "msimeth.h"
#include "msimethod.h"

#define BUFF_SIZE 512
  
class CMethods : public IMsiProductMethods, public IMsiSoftwareFeatureMethods
//				, public IConnectionPointContainer, public IConnectionPoint
{
protected:
	ULONG m_cRef;         //Object reference count

public:
	CMethods();
	~CMethods();

	//Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, void**);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
/*
	HRESULT STDMETHODCALLTYPE EnumConnectionPoints( 
            IEnumConnectionPoints __RPC_FAR *__RPC_FAR *ppEnum);
        
    HRESULT STDMETHODCALLTYPE FindConnectionPoint( 
            REFIID riid,
            IConnectionPoint __RPC_FAR *__RPC_FAR *ppCP);

	HRESULT STDMETHODCALLTYPE GetConnectionInterface( 
            IID __RPC_FAR *pIID);
        
    HRESULT STDMETHODCALLTYPE GetConnectionPointContainer( 
            IConnectionPointContainer __RPC_FAR *__RPC_FAR *ppCPC);
        
    HRESULT STDMETHODCALLTYPE Advise( 
            IUnknown __RPC_FAR *pUnkSink,
            DWORD __RPC_FAR *pdwCookie);
        
    HRESULT STDMETHODCALLTYPE Unadvise( 
            DWORD dwCookie);
        
    HRESULT STDMETHODCALLTYPE EnumConnections( 
            IEnumConnections __RPC_FAR *__RPC_FAR *ppEnum);
*/
	///////////////////////
	//Product Methods

	HRESULT STDMETHODCALLTYPE Admin( 
        /* [string][in] */ LPCWSTR wszPackageLocation,
        /* [string][in] */ LPCWSTR wszOptions,
        /* [out] */ UINT __RPC_FAR *puiResult,
        /* [in] */ int iThreadID);
    
    HRESULT STDMETHODCALLTYPE Advertise( 
        /* [string][in] */ LPCWSTR wszPackageLocation,
        /* [string][in] */ LPCWSTR wszOptions,
        /* [out] */ UINT __RPC_FAR *puiResult,
        /* [in] */ int iThreadID);
    
    HRESULT STDMETHODCALLTYPE Configure( 
        /* [string][in] */ LPCWSTR wszProductCode,
        /* [in] */ int iInstallLevel,
        /* [in] */ int isInstallState,
        /* [out] */ UINT __RPC_FAR *puiResult,
        /* [in] */ int iThreadID);
    
    HRESULT STDMETHODCALLTYPE Install( 
        /* [string][in] */ LPCWSTR wszPackageLocation,
        /* [string][in] */ LPCWSTR wszOptions,
        /* [out] */ UINT __RPC_FAR *puiResult,
        /* [in] */ int iThreadID);
    
    HRESULT STDMETHODCALLTYPE Reinstall( 
        /* [string][in] */ LPCWSTR wszProductCode,
        /* [in] */ DWORD dwReinstallMode,
        /* [out] */ UINT __RPC_FAR *puiResult,
        /* [in] */ int iThreadID);
    
    HRESULT STDMETHODCALLTYPE Uninstall( 
        /* [string][in] */ LPCWSTR wszProductCode,
        /* [out] */ UINT __RPC_FAR *puiResult,
        /* [in] */ int iThreadID);
    
    HRESULT STDMETHODCALLTYPE Upgrade( 
        /* [string][in] */ LPCWSTR wszPackageLocation,
        /* [string][in] */ LPCWSTR wszOptions,
        /* [out] */ UINT __RPC_FAR *puiResult,
        /* [in] */ int iThreadID);

	///////////////////////
	//SoftwareFeature Methods

	HRESULT STDMETHODCALLTYPE ConfigureSF( 
        /* [string][in] */ LPCWSTR wszProductCode,
        /* [string][in] */ LPCWSTR wszFeature,
        /* [in] */ int isInstallState,
        /* [out] */ UINT __RPC_FAR *puiResult,
        /* [in] */ int iThreadID);
    
    HRESULT STDMETHODCALLTYPE ReinstallSF( 
        /* [string][in] */ LPCWSTR wszProductCode,
        /* [string][in] */ LPCWSTR wszFeature,
        /* [in] */ DWORD dwReinstallMode,
        /* [out] */ UINT __RPC_FAR *puiResult,
        /* [in] */ int iThreadID);

	//UI Handler
	static int WINAPI EventHandler(LPVOID pvContext, UINT iMessageType, LPCWSTR szMessage);

private:
	// Private utility methods of CMethods.
	HRESULT GetSlot(UINT* puiFreeSlot);
	HRESULT FindSlot(DWORD dwCookie, UINT* puiSlot);

	IID            m_iidSink;
	DWORD          m_dwNextCookie;
	static UINT           m_cConnections;
	static UINT           m_uiMaxIndex;
	static CONNECTDATA*   m_paConnections;

	bool CheckForMsiDll();

	HRESULT InitStatic(int *piThreadID);
	DWORD GetAccount(HANDLE TokenHandle, WCHAR *wcDomain, WCHAR *wcUser);
	DWORD GetSid(HANDLE TokenHandle, WCHAR *wcSID);
	DWORD LoadHive(LPWSTR pszUserName, LPWSTR pszKeyName);
	DWORD UnloadHive(LPCWSTR pszKeyName);
	DWORD AcquirePrivilege();
	void RestorePrivilege();
	HRESULT PrepareEnvironment();
	HRESULT ReleaseEnvironment();

	static IMsiMethodStatusSink *m_pStatusSink;
	DWORD m_dwCheckKeyPresentStatus;
	WCHAR m_wcKeyName[1024];
	TOKEN_PRIVILEGES* m_pOriginalPriv;
	HKEY m_hKey;
    DWORD m_dwSize;

		//Critical section for event handling
	static CRITICAL_SECTION m_cs;
	static bool m_bCSReady;
};

// These variables keep track of when the module can be unloaded
extern long       g_cObj;
extern long       g_cLock;

//These are the valiables used to track MSI.dll and it's exported functions
typedef INSTALLUILEVEL (CALLBACK* LPFNMSISETINTERNALUI)(INSTALLUILEVEL, HWND);
typedef INSTALLUI_HANDLER (CALLBACK* LPFNMSISETEXTERNALUIW)(INSTALLUI_HANDLER, DWORD, LPVOID);
typedef UINT (CALLBACK* LPFNMSIENABLELOGW)(DWORD, LPCWSTR, DWORD);
typedef UINT (CALLBACK* LPFNMSIINSTALLPRODUCTW)(LPCWSTR, LPCWSTR);
typedef UINT (CALLBACK* LPFNMSICONFIGUREPRODUCTW)(LPCWSTR, int, INSTALLSTATE);
typedef UINT (CALLBACK* LPFNMSIREINSTALLPRODUCTW)(LPCWSTR, DWORD);
typedef UINT (CALLBACK* LPFNMSIAPPLYPATCHW)(LPCWSTR, LPCWSTR, INSTALLTYPE, LPCWSTR);
typedef UINT (CALLBACK* LPFNMSICONFIGUREFEATUREW)(LPCWSTR, LPCWSTR, INSTALLSTATE);
typedef UINT (CALLBACK* LPFNMSIREINSTALLFEATUREW)(LPCWSTR, LPCWSTR, DWORD);

extern bool g_bMsiPresent;
extern bool g_bMsiLoaded;

extern LPFNMSISETINTERNALUI				g_fpMsiSetInternalUI;
extern LPFNMSISETEXTERNALUIW			g_fpMsiSetExternalUIW;
extern LPFNMSIENABLELOGW				g_fpMsiEnableLogW;
extern LPFNMSIINSTALLPRODUCTW			g_fpMsiInstallProductW;
extern LPFNMSICONFIGUREPRODUCTW			g_fpMsiConfigureProductW;
extern LPFNMSIREINSTALLPRODUCTW			g_fpMsiReinstallProductW;
extern LPFNMSIAPPLYPATCHW				g_fpMsiApplyPatchW;
extern LPFNMSICONFIGUREFEATUREW			g_fpMsiConfigureFeatureW;
extern LPFNMSIREINSTALLFEATUREW			g_fpMsiReinstallFeatureW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\msimeth\msimeth.cpp ===
// msimeth.cpp : Defines the entry point for the application.

//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//

#include <precomp.h>
#include "classfac.h"
#include "methods.h"
#include "msimethod.h"

DWORD g_ProductRegister = 0;
DWORD g_SoftwareFeatureRegister = 0;

long g_lRunning = 0;
BOOL s_Exiting = FALSE ;
BOOL gbShowIcon = FALSE;
HANDLE g_hMutex = NULL;
HANDLE g_hTerminateEvent = NULL;
HANDLE g_hMethodAdd = NULL;
HANDLE g_hMethodRelease = NULL;
UINT g_uiResult = 0;
HANDLE g_hPipe = NULL;
bool g_bPipe = true;

DEFINE_GUID(CLSID_MsiProductMethods,0x3E6A93E0, 0xFDAD, 0x11D2, 0xa9, 0x7B, 0x0, 0xA0, 0xC9, 0x95, 0x49, 0x21);
// {3E6A93E0-FDAD-11D2-A97B-00A0C9954921}

DEFINE_GUID(CLSID_MsiSoftwareFeatureMethods,0xE293BA80, 0xFDAD, 0x11D2, 0xa9, 0x7B, 0x0, 0xA0, 0xC9, 0x95, 0x49, 0x21);
// {E293BA80-FDAD-11D2-A97B-00A0C9954921}


BOOL IsNT()
{
    OSVERSIONINFO OSInfo;

    OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(GetVersionEx(&OSInfo) && OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        return TRUE ;

    return FALSE ;
}
/*
LRESULT CALLBACK WndProc(IN HWND hWnd, IN UINT message,
                        IN WPARAM wParam, IN LPARAM lParam)
{
    switch (message) {

        case WM_QUERYOPEN:    //todo, queryend session
            return 0;

        case WM_QUERYENDSESSION:
            return TRUE;

        case WM_ENDSESSION:
            if(wParam == TRUE){

                SetEvent(g_hTerminateEvent);
            }
            return 0;
            
        case WM_DESTROY:
            PostQuitMessage(0);
            SetEvent(g_hTerminateEvent);
            break;

        default:
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }

    return (0);
}
*//*
HWND CreateMsiMethWindow(IN HINSTANCE hInstance)
{
    WNDCLASS wndclass;
    wndclass.style = 0;
    wndclass.lpfnWndProc = WndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(hInstance, TEXT("MsiMeth"));
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1) ;
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = TEXT("MSIMETHCLASS");

    if(!RegisterClass(&wndclass)) return NULL;

    HWND hWnd = CreateWindow(TEXT("MSIMETHCLASS"),
                    TEXT("MSIMETH"),
                    WS_OVERLAPPED | WS_SYSMENU,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    NULL, NULL, hInstance, NULL);

    if(hWnd == NULL)return NULL;

    // This program is visible only for debug builds.

    if(gbShowIcon){
        ShowWindow(hWnd,SW_MINIMIZE);
        UpdateWindow(hWnd);
        HMENU hMenu = GetSystemMenu(hWnd, FALSE);

        if(hMenu) DeleteMenu(hMenu, SC_RESTORE, MF_BYCOMMAND);
    }

    return hWnd;
}
*//*
HRESULT UninitComServer ()
{
	if(g_ProductRegister) CoRevokeClassObject(g_ProductRegister);

	if(g_SoftwareFeatureRegister) CoRevokeClassObject(g_SoftwareFeatureRegister);

	CoUninitialize();

	return S_OK ;
}
*//*
HRESULT InitInstanceProvider()
{
	CMethodsFactory *pClassFactory = new CMethodsFactory();

	HRESULT hrResult = S_OK;

	if(SUCCEEDED(hrResult = CoRegisterClassObject(CLSID_MsiProductMethods,
												  (IUnknown *)pClassFactory,
												  CLSCTX_LOCAL_SERVER,
												  REGCLS_MULTIPLEUSE,
												  &g_ProductRegister))){

		hrResult = CoRegisterClassObject(CLSID_MsiSoftwareFeatureMethods,
										 (IUnknown *)pClassFactory,
										 CLSCTX_LOCAL_SERVER,
										 REGCLS_MULTIPLEUSE,
										 &g_SoftwareFeatureRegister);
	}

	return hrResult ;
}
*//*
HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
	HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx(0, COINIT_MULTITHREADED);

	if(SUCCEEDED(t_Result)){

		t_Result = CoInitializeSecurity(NULL, -1, NULL, NULL,
			a_AuthenticationLevel, a_ImpersonationLevel, 
			NULL, EOAC_NONE, 0);

		if(FAILED(t_Result)){

			CoUninitialize();
			return t_Result;
		}

	}

	if(SUCCEEDED(t_Result)) t_Result = InitInstanceProvider();

	if(FAILED(t_Result)){

		UninitComServer () ;
	}

	return t_Result  ;
}
*//*
void WindowsDispatch()
{
	BOOL bWaitAll = FALSE;
	HANDLE hEvents[] = {g_hTerminateEvent, g_hMethodAdd, g_hMethodRelease};
    int iNumEvents = sizeof(hEvents) / sizeof(HANDLE);
	DWORD dwWait = 60000;	//60 seconds

	while(1){

		// listen for server events...exit if dwTime elapses without any requests
		DWORD dwObj = WaitForMultipleObjects(iNumEvents, hEvents, bWaitAll, dwWait);

		switch(dwObj){

        case WAIT_TIMEOUT:			// time expired
			//we timed out so if there are no active threads it's safe to exit.
			if(g_cObj < 1) return;
			break;

		case WAIT_OBJECT_0:			//terminate
			if(g_cObj < 1) return;

			dwWait = 2000;
			break;

		case WAIT_OBJECT_0 + 1:		//method started
			g_lRunning++;
			break;

		case WAIT_OBJECT_0 + 2:		//method ended
			g_lRunning--;
			break;

		}

        if(s_Exiting) return ;
	}
}
*//*
HRESULT Process ()
{
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT ;

	HRESULT hr = S_OK;

	if(SUCCEEDED(hr = InitComServer(t_ImpersonationLevel, t_AuthenticationLevel))){

		WindowsDispatch();
		UninitComServer();
	}

	return hr;
}
*/
void TerminateRunning()
{
	DWORD dwFlag = EVENT_MODIFY_STATE;

	if(IsNT()) dwFlag |= SYNCHRONIZE;

    HANDLE hTerm = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("MSIPROV_METHODS_SERVER_TERMINATE"));

    if(hTerm){

        SetEvent(hTerm);
        CloseHandle(hTerm);
    }

    return;
}
/*
BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE;

	LPTSTR t_CommandLine = GetCommandLine();

	if(t_CommandLine)
	{
		TCHAR *t_Arg = NULL;
		TCHAR *t_ApplicationArg = NULL;
		t_ApplicationArg = _tcstok(t_CommandLine, _TEXT(" \t"));
		t_Arg = _tcstok(NULL, _TEXT(" \t"));
		
		if(t_Arg){
			if(_tcsicmp(t_Arg, _TEXT ("/RegServer")) == 0){

				t_Exit = TRUE;
				DllRegisterServer();

			}else if(_tcsicmp(t_Arg, _TEXT("/UnRegServer")) == 0){

				t_Exit = TRUE;
				DllUnregisterServer();

			}else if(_tcsicmp(t_Arg, _TEXT("/kill")) == 0){

				t_Exit = TRUE;
				TerminateRunning();

			}else if(_tcsicmp(t_Arg, _TEXT("/admin")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" ")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" "));
				TCHAR ptcOptions[1000];
				_tcscpy(ptcOptions, _T(""));

				TCHAR *token = _tcstok(NULL, _TEXT(" "));
				while(token != NULL){

					_tcscat(ptcOptions, _T(" "));
					_tcscat(ptcOptions, token);

					token = _tcstok(NULL, _TEXT(" "));
				}

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Admin((LPWSTR)ptcPackage, (LPWSTR)ptcOptions, &g_uiResult, iThread);
				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;

			}else if(_tcsicmp(t_Arg, _TEXT("/advertise")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" ")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" "));
				TCHAR ptcOptions[1000];
				_tcscpy(ptcOptions, _T(""));

				TCHAR *token = _tcstok(NULL, _TEXT(" "));
				while(token != NULL){

					_tcscat(ptcOptions, _T(" "));
					_tcscat(ptcOptions, token);

					token = _tcstok(NULL, _TEXT(" "));
				}

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Advertise((LPWSTR)ptcPackage, (LPWSTR)ptcOptions, &g_uiResult, iThread);
				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;

			}else if(_tcsicmp(t_Arg, _TEXT("/configure")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" \t"));
				int iInstallLevel = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				int iInstallState = _ttoi(_tcstok(NULL, _TEXT(" \t")));

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Configure((LPWSTR)ptcPackage, iInstallLevel, iInstallState, &g_uiResult, iThread);
				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;

			}else if(_tcsicmp(t_Arg, _TEXT("/install")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" ")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" "));
				TCHAR ptcOptions[1000];
				_tcscpy(ptcOptions, _T(""));

				TCHAR *token = _tcstok(NULL, _TEXT(" "));
				while(token != NULL){

					_tcscat(ptcOptions, _T(" "));
					_tcscat(ptcOptions, token);

					token = _tcstok(NULL, _TEXT(" "));
				}

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Install((LPWSTR)ptcPackage, (LPWSTR)ptcOptions, &g_uiResult, iThread);
				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			
			}else if(_tcsicmp(t_Arg, _TEXT("/reinstall")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" \t"));
				DWORD dwReinstallMode = _ttoi(_tcstok(NULL, _TEXT(" \t")));

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Reinstall((LPWSTR)ptcPackage, dwReinstallMode, &g_uiResult, iThread);
				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			
			}else if(_tcsicmp(t_Arg, _TEXT("/uninstall")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" \t"));

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Uninstall((LPWSTR)ptcPackage, &g_uiResult, iThread);
				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			
			}else if(_tcsicmp(t_Arg, _TEXT("/upgrade")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" ")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" "));
				TCHAR ptcOptions[1000];
				_tcscpy(ptcOptions, _T(""));

				TCHAR *token = _tcstok(NULL, _TEXT(" "));
				while(token != NULL){

					_tcscat(ptcOptions, _T(" "));
					_tcscat(ptcOptions, token);

					token = _tcstok(NULL, _TEXT(" "));
				}

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Upgrade((LPWSTR)ptcPackage, (LPWSTR)ptcOptions, &g_uiResult, iThread);
				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			
			}else if(_tcsicmp(t_Arg, _TEXT("/sfconfigure")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" \t"));
				TCHAR *ptcFeature = _tcstok(NULL, _TEXT(" \t"));
				int iInstallState = _ttoi(_tcstok(NULL, _TEXT(" \t")));

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->ConfigureSF((LPWSTR)ptcPackage, (LPWSTR)ptcFeature, iInstallState,
					&g_uiResult, iThread);
				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			
			}else if(_tcsicmp(t_Arg, _TEXT("/sfreinstall")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" \t"));
				TCHAR *ptcFeature = _tcstok(NULL, _TEXT(" \t"));
				DWORD dwReinstallMode = _ttoi(_tcstok(NULL, _TEXT(" \t")));

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->ReinstallSF((LPWSTR)ptcPackage, (LPWSTR)ptcFeature, dwReinstallMode,
					&g_uiResult, iThread);
				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			}
		}
	}

	return t_Exit ;
}
*/

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
//	BOOL t_Exit = FALSE;
	g_uiResult = 0;

	LPTSTR t_CommandLine = GetCommandLine();

	if(t_CommandLine)
	{
		TCHAR *t_Arg = NULL;
		TCHAR *t_ApplicationArg = NULL;
		t_ApplicationArg = _tcstok(t_CommandLine, _TEXT(" \t"));
		t_Arg = _tcstok(NULL, _TEXT(" \t"));
		
		if(t_Arg){
			if(_tcsicmp(t_Arg, _TEXT ("/RegServer")) == 0){

//				t_Exit = TRUE;
				DllRegisterServer();

			}else if(_tcsicmp(t_Arg, _TEXT("/UnRegServer")) == 0){

//				t_Exit = TRUE;
				DllUnregisterServer();

			}else if(_tcsicmp(t_Arg, _TEXT("/kill")) == 0){

//				t_Exit = TRUE;
				TerminateRunning();

			}else if(_tcsicmp(t_Arg, _TEXT("/admin")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" ")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" "));
				TCHAR ptcOptions[1000];
				_tcscpy(ptcOptions, _T(""));

				TCHAR *token = _tcstok(NULL, _TEXT(" "));
				while(token != NULL){

					_tcscat(ptcOptions, _T(" "));
					_tcscat(ptcOptions, token);

					token = _tcstok(NULL, _TEXT(" "));
				}

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Admin((LPWSTR)ptcPackage, (LPWSTR)ptcOptions, &g_uiResult, iThread);
//				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;

			}else if(_tcsicmp(t_Arg, _TEXT("/advertise")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" ")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" "));
				TCHAR ptcOptions[1000];
				_tcscpy(ptcOptions, _T(""));

				TCHAR *token = _tcstok(NULL, _TEXT(" "));
				while(token != NULL){

					_tcscat(ptcOptions, _T(" "));
					_tcscat(ptcOptions, token);

					token = _tcstok(NULL, _TEXT(" "));
				}

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Advertise((LPWSTR)ptcPackage, (LPWSTR)ptcOptions, &g_uiResult, iThread);
//				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;

			}else if(_tcsicmp(t_Arg, _TEXT("/configure")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" \t"));
				int iInstallLevel = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				int iInstallState = _ttoi(_tcstok(NULL, _TEXT(" \t")));

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Configure((LPWSTR)ptcPackage, iInstallLevel, iInstallState, &g_uiResult, iThread);
//				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;

			}else if(_tcsicmp(t_Arg, _TEXT("/install")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" ")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" "));
				TCHAR ptcOptions[1000];
				_tcscpy(ptcOptions, _T(""));

				TCHAR *token = _tcstok(NULL, _TEXT(" "));
				while(token != NULL){

					_tcscat(ptcOptions, _T(" "));
					_tcscat(ptcOptions, token);

					token = _tcstok(NULL, _TEXT(" "));
				}

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Install((LPWSTR)ptcPackage, (LPWSTR)ptcOptions, &g_uiResult, iThread);
//				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			
			}else if(_tcsicmp(t_Arg, _TEXT("/reinstall")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" \t"));
				DWORD dwReinstallMode = _ttoi(_tcstok(NULL, _TEXT(" \t")));

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Reinstall((LPWSTR)ptcPackage, dwReinstallMode, &g_uiResult, iThread);
//				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			
			}else if(_tcsicmp(t_Arg, _TEXT("/uninstall")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" \t"));

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Uninstall((LPWSTR)ptcPackage, &g_uiResult, iThread);
//				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			
			}else if(_tcsicmp(t_Arg, _TEXT("/upgrade")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" ")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" "));
				TCHAR ptcOptions[1000];
				_tcscpy(ptcOptions, _T(""));

				TCHAR *token = _tcstok(NULL, _TEXT(" "));
				while(token != NULL){

					_tcscat(ptcOptions, _T(" "));
					_tcscat(ptcOptions, token);

					token = _tcstok(NULL, _TEXT(" "));
				}

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->Upgrade((LPWSTR)ptcPackage, (LPWSTR)ptcOptions, &g_uiResult, iThread);
//				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			
			}else if(_tcsicmp(t_Arg, _TEXT("/sfconfigure")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" \t"));
				TCHAR *ptcFeature = _tcstok(NULL, _TEXT(" \t"));
				int iInstallState = _ttoi(_tcstok(NULL, _TEXT(" \t")));

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->ConfigureSF((LPWSTR)ptcPackage, (LPWSTR)ptcFeature, iInstallState,
					&g_uiResult, iThread);
//				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			
			}else if(_tcsicmp(t_Arg, _TEXT("/sfreinstall")) == 0){

				int iThread = _ttoi(_tcstok(NULL, _TEXT(" \t")));
				TCHAR *ptcPackage = _tcstok(NULL, _TEXT(" \t"));
				TCHAR *ptcFeature = _tcstok(NULL, _TEXT(" \t"));
				DWORD dwReinstallMode = _ttoi(_tcstok(NULL, _TEXT(" \t")));

				SetFileApisToOEM();

				g_hPipe = CreateFileW(L"\\\\.\\pipe\\msimeth_pipe", GENERIC_WRITE, 0, NULL,
					OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				//synchronize us with the parent process
				g_hMutex = CreateMutex(NULL, FALSE, TEXT("MSIPROV_METHODS_SERVER"));

				if(g_hMutex)
					WaitForSingleObject(g_hMutex, INFINITE);

				ReleaseMutex(g_hMutex);

				// call the server with a pipe set up to deal with
				//status messages
				CMethods *pMeth = new CMethods();

				pMeth->ReinstallSF((LPWSTR)ptcPackage, (LPWSTR)ptcFeature, dwReinstallMode,
					&g_uiResult, iThread);
//				t_Exit = TRUE;

				CloseHandle(g_hPipe);

				delete pMeth;
			}
		}
	}

	return g_uiResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\core\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\msiprovider\msimeth\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#include <objbase.h>
#include <locale.h>
#include <stdio.h>
#include <tchar.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <ocidl.h>
#include <ProvExce.h>
#include <CRegCls.h>
#include <objbase.h>
#include <OLECTL.H>
#include <createmutexasprocess.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\core\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\core\analyser.h ===
//******************************************************************************

//

//  ANALYSER.H

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//******************************************************************************
#ifndef __WBEM_ANALYSER__H_
#define __WBEM_ANALYSER__H_

#include <stdio.h>
#include <wbemidl.h>
#include <ql.h>

#include <provtempl.h>


typedef CArray<CString, LPCWSTR> CStringArray;

class CQueryAnalyser
{
public:
    static HRESULT GetNecessaryQueryForProperty(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CPropertyName& PropName,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr);
	static HRESULT GetValuesForProp(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            CPropertyName& PropName, CStringArray& awsVals);

protected:
    static BOOL IsTokenAboutProperty(
                                       IN QL_LEVEL_1_TOKEN& Token,
                                       IN CPropertyName& PropName);
    static void AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource);
    static HRESULT AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew);
    static HRESULT OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew);
    static HRESULT NegateQueryExpression(
                            IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            OUT QL_LEVEL_1_RPN_EXPRESSION* pNewExpr);
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\core\qllex.h ===
/*++



Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    QLLEX.CH

Abstract:

	QL Level 1 DFA Table & Tokens

History:

	raymcc    24-Jun-95       Created.

--*/

#ifndef _QLLEX_H_

#include <genlex.h>
#define QL_1_TOK_EOF       0
#define QL_1_TOK_ERROR     1
#define QL_1_TOK_IDENT     100
#define QL_1_TOK_QSTRING   101
#define QL_1_TOK_INT       102
#define QL_1_TOK_REAL      103
#define QL_1_TOK_CHAR      104

#define QL_1_TOK_LE        105
#define QL_1_TOK_LT        106
#define QL_1_TOK_GE        107
#define QL_1_TOK_GT        108
#define QL_1_TOK_EQ        109
#define QL_1_TOK_NE        110

#define QL_1_TOK_DOT           111
#define QL_1_TOK_OPEN_PAREN    112
#define QL_1_TOK_CLOSE_PAREN   113
#define QL_1_TOK_ASTERISK      114
#define QL_1_TOK_COMMA         115

#define QL_1_TOK_SELECT        120
#define QL_1_TOK_WHERE         121
#define QL_1_TOK_FROM          122
#define QL_1_TOK_LIKE          123
#define QL_1_TOK_OR            124
#define QL_1_TOK_AND           125
#define QL_1_TOK_NOT           126
#define QL_1_TOK_IS            127
#define QL_1_TOK_NULL          128
#define QL_1_TOK_WITHIN        129
#define QL_1_TOK_ISA           130
#define QL_1_TOK_GROUP         131
#define QL_1_TOK_BY            132
#define QL_1_TOK_HAVING        133

#define QL_1_TOK_TRUE        140
#define QL_1_TOK_FALSE        141

extern LexEl Ql_1_LexTable[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\core\analyser.cpp ===
//******************************************************************************

//

//  ANALYSER.CPP

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//******************************************************************************

#include "precomp.h"
#include "analyser.h"
#include <stack>





HRESULT CQueryAnalyser::GetNecessaryQueryForProperty(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CPropertyName& PropName,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr)
{
    pNewExpr = NULL;

    // Class name and selected properties are ignored; we look at tokens only
    // ======================================================================

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*> ExprStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        pNewExpr = new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNewExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        QL_LEVEL_1_RPN_EXPRESSION* pFirst;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            if(IsTokenAboutProperty(Token, PropName))
            {
                pNew->AddToken(Token);
            }
            ExprStack.push(pNew);
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();

            // No information

            ExprStack.push(pNew);
            delete pFirst;
            break;
        
        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;            
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && ExprStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }
        
    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    pNewExpr = ExprStack.top();
    return S_OK;
}

BOOL CQueryAnalyser::IsTokenAboutProperty(
                                       IN QL_LEVEL_1_TOKEN& Token,
                                       IN CPropertyName& PropName)
{
    CPropertyName& TokenPropName = Token.PropertyName;

    if(PropName.GetNumElements() != TokenPropName.GetNumElements())
        return FALSE;

    for(int i = 0; i < PropName.GetNumElements(); i++)
    {
        LPCWSTR wszPropElement = PropName.GetStringAt(i);
        LPCWSTR wszTokenElement = TokenPropName.GetStringAt(i);

        if(wszPropElement == NULL || wszTokenElement == NULL)
            return FALSE;

        if(_wcsicmp(wszPropElement, wszTokenElement))
            return FALSE;
    }

    return TRUE;
}

void CQueryAnalyser::AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource)
{
    for(int i = 0; i < pSource->nNumTokens; i++)
    {
        pDest->AddToken(pSource->pArrayOfTokens[i]);
    }
}

HRESULT CQueryAnalyser::AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew)
{
    // If either one is NULL (false), the result is NULL
    // =================================================

    if(pFirst == NULL || pSecond == NULL)
        return WBEM_S_FALSE;
        
    // If either one is empty, take the other
    // ======================================

    if(pFirst->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- and together
    // ===============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_AND;
    pNew->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew)
{
    // If both are NULL (false) so is the result
    // =========================================

    if(pFirst == NULL && pSecond == NULL)
        return WBEM_S_FALSE;

    // If one is NULL (false) return the other
    // =======================================

    if(pFirst == NULL)
    { 
        AppendQueryExpression(pNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond == NULL)
    { 
        AppendQueryExpression(pNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // If either one is empty, so is the result
    // ========================================

    if(pFirst->nNumTokens == 0 || pSecond->nNumTokens == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- or together
    // ==============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_OR;
    pNew->AddToken(Token);

    return WBEM_S_NO_ERROR;
}
    
HRESULT CQueryAnalyser::GetValuesForProp(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            CPropertyName& PropName, CStringArray& awsVals)
{
    awsVals.RemoveAll();

    // Get the necessary query
    // =======================

    QL_LEVEL_1_RPN_EXPRESSION* pPropExpr;
    HRESULT hres = CQueryAnalyser::GetNecessaryQueryForProperty(pExpr, 
                            PropName, pPropExpr);
    if(FAILED(hres))
    {
        return hres;
    }

    // See if there are any tokens
    // ===========================

    if(pPropExpr->nNumTokens == 0)
    {
        delete pPropExpr;
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }

    // Combine them all
    // ================

    for(int i = 0; i < pPropExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pPropExpr->pArrayOfTokens[i];
        if(Token.nTokenType == QL1_NOT)
        {
            delete pPropExpr;
            return WBEMESS_E_REGISTRATION_TOO_BROAD;
        }
        else if(Token.nTokenType == QL1_AND || Token.nTokenType == QL1_OR)
        {
            // We treat them all as ORs
            // ========================
        }
        else    
        {
            // This is a token
            // ===============

            if(Token.nOperator != QL1_OPERATOR_EQUALS)
            {
                delete pPropExpr;
                return WBEMESS_E_REGISTRATION_TOO_BROAD;
            }

            if(V_VT(&Token.vConstValue) != VT_BSTR)
            {
                delete pPropExpr;
                return WBEM_E_INVALID_QUERY;
            }

            // This token is a string equality. Add the string to the list
            // ===========================================================

            awsVals.Add(V_BSTR(&Token.vConstValue));
        }
    }

    delete pPropExpr;
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\core\ql.h ===
/*++



Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    QL.H

Abstract:

	Level 1 Syntax QL Parser

	Implements the syntax described in QL.BNF.  This translates the input
	into an RPN stream of tokens.

History:

	a-raymcc, a-tomasp    21-Jun-96       Created.

--*/

#ifndef _QL__H_
#define _QL__H_
#include <wbemidl.h>
#include <wbemint.h>
#include <qllex.h>

#define DELETE_ME

class CPropertyName : public WBEM_PROPERTY_NAME
{
protected:
    long m_lAllocated;

    void EnsureAllocated(long lElements);
public:
    void Init();
    CPropertyName() {Init();}
    CPropertyName(const CPropertyName& Other);
    void operator=(const CPropertyName& Other);
    void operator=(const WBEM_PROPERTY_NAME& Other);
    BOOL operator==(const WBEM_PROPERTY_NAME& Other);

    void Empty();
    ~CPropertyName() {Empty();}

    long GetNumElements() const {return m_lNumElements;}
    LPCWSTR GetStringAt(long lIndex) const;
    void AddElement(LPCWSTR wszElement);
    DELETE_ME LPWSTR GetText();
};

class  CQl1ParseSink
{
public:
    virtual void SetClassName(LPCWSTR wszClass) = 0;
    virtual void SetTolerance(const WBEM_QL1_TOLERANCE& Tolerance) = 0;
    virtual void AddToken(const WBEM_QL1_TOKEN& Token) = 0;
    virtual void AddProperty(const CPropertyName& Property) = 0;
    virtual void AddAllProperties() = 0;

    virtual void SetAggregated() = 0;
    virtual void SetAggregationTolerance(const WBEM_QL1_TOLERANCE& Tolerance)= 0;
    virtual void AddAggregationProperty(const CPropertyName& Property) = 0;
    virtual void AddAllAggregationProperties() = 0;
    virtual void AddHavingToken(const WBEM_QL1_TOKEN& Token) = 0;

    virtual void InOrder(long lOp){}
};

class CAbstractQl1Parser
{
protected:
    // Controls keyword parsing in Next().
    // ===================================
    enum { 
        NO_KEYWORDS = 0,
        ALL_KEYWORDS,
        EXCLUDE_GROUP_KEYWORD,
        EXCLUDE_EXPRESSION_KEYWORDS
        };

    CQl1ParseSink* m_pSink;
    CGenLexer *m_pLexer;
    int        m_nLine;
    wchar_t*   m_pTokenText;
    int        m_nCurrentToken;

    // Semantic transfer variables.
    // ============================
    VARIANT    m_vTypedConst;
    BOOL       m_bQuoted;
    int        m_nRelOp;
    DWORD      m_dwConstFunction;
    DWORD      m_dwPropFunction;
    CPropertyName m_PropertyName;
    BOOL       m_bInAggregation;
    CPropertyName m_PropertyName2;
    BOOL       m_bPropComp;
        
    // Parsing functions.
    // ==================
    virtual BOOL Next(int nFlags = ALL_KEYWORDS);
    LPCWSTR GetSinglePropertyName();
    void DeletePropertyName();
    int FlipOperator(int nOp);
    void AddAppropriateToken(const WBEM_QL1_TOKEN& Token);

    int parse_property_name(CPropertyName& Prop);
    
    int parse(int nFlags);

    int prop_list();
    int class_name();
    int tolerance();
    int opt_where();
    int expr();
    int property_name();
    int prop_list_2();
    int term();
    int expr2();
    int simple_expr();
    int term2();
    int leading_ident_expr();
    int finalize();
    int rel_operator();
    int equiv_operator();
    int comp_operator();
    int is_operator();
    int trailing_prop_expr();
    int trailing_prop_expr2();
    int trailing_or_null();
    int trailing_const_expr();
    int trailing_ident_expr();
    int unknown_func_expr();
    int typed_constant();
    int opt_aggregation();
    int aggregation_params();
    int aggregate_by();
    int aggregate_within();
    int opt_having();

    static DWORD TranslateIntrinsic(LPCWSTR pFuncName);
    static void InitToken(WBEM_QL1_TOKEN* pToken);
public:
    enum { 
        SUCCESS = 0,
        SYNTAX_ERROR,
        LEXICAL_ERROR,
        FAILED,
        BUFFER_TOO_SMALL
        };

    enum {
        FULL_PARSE = 0,
        NO_WHERE,
        JUST_WHERE
    };

    CAbstractQl1Parser(CGenLexSource *pSrc);
    virtual ~CAbstractQl1Parser();

    int Parse(CQl1ParseSink* pSink, int nFlags);
            
    int CurrentLine() { return m_nLine; }
    LPWSTR CurrentToken() { return m_pTokenText; }
};



struct QL_LEVEL_1_TOKEN
{
    enum 
    { 
        OP_EXPRESSION = QL1_OP_EXPRESSION, 
        TOKEN_AND = QL1_AND, 
        TOKEN_OR = QL1_OR, 
        TOKEN_NOT = QL1_NOT
    };
    enum 
    { 
        IFUNC_NONE = QL1_FUNCTION_NONE, 
        IFUNC_UPPER = QL1_FUNCTION_UPPER, 
        IFUNC_LOWER = QL1_FUNCTION_LOWER 
    };    

    // If the field is a OP_EXPRESSION, then the following are used.
    enum 
    { 
        OP_EQUAL = QL1_OPERATOR_EQUALS, 
        OP_NOT_EQUAL = QL1_OPERATOR_NOTEQUALS, 
        OP_EQUALorGREATERTHAN = QL1_OPERATOR_GREATEROREQUALS,
		OP_EQUALorLESSTHAN = QL1_OPERATOR_LESSOREQUALS, 
        OP_LESSTHAN = QL1_OPERATOR_LESS, 
        OP_GREATERTHAN = QL1_OPERATOR_GREATER, 
        OP_LIKE  = QL1_OPERATOR_LIKE
    };

    int nTokenType; //  OP_EXPRESSION,TOKEN_AND, TOKEN_OR, TOKEN_NOT
    CPropertyName PropertyName;  
                   // Name of the property on which the operator is applied
    int     nOperator;      // Operator that is applied on property
    VARIANT vConstValue;    // Value applied by operator
    BOOL bQuoted; // FALSE if the string should not have quotes around it.

    CPropertyName PropertyName2; // Property to compare, if applicable.
    BOOL m_bPropComp;        // TRUE if this is a property-to-property compare.

    DWORD   dwPropertyFunction; // 0=no instrinsic function applied
    DWORD   dwConstFunction;    // "

    QL_LEVEL_1_TOKEN();
    QL_LEVEL_1_TOKEN(const QL_LEVEL_1_TOKEN&);
   ~QL_LEVEL_1_TOKEN(); 
    QL_LEVEL_1_TOKEN& operator=(const QL_LEVEL_1_TOKEN &Src);
    QL_LEVEL_1_TOKEN& operator=(const WBEM_QL1_TOKEN &Src);
    
    void Dump(FILE *);
    DELETE_ME LPWSTR GetText();
};


// Contains RPN version of expression.
// ===================================

struct QL_LEVEL_1_RPN_EXPRESSION : public CQl1ParseSink
{
    int nNumTokens;
    int nCurSize;
    QL_LEVEL_1_TOKEN *pArrayOfTokens;
    BSTR bsClassName;
    WBEM_QL1_TOLERANCE Tolerance;

	int nNumberOfProperties;          // Zero means all properties selected
    int nCurPropSize;
    BOOL bStar;
	CPropertyName *pRequestedPropertyNames;  
                // Array of property names which values are to be returned if
    
    BOOL bAggregated;
    WBEM_QL1_TOLERANCE AggregationTolerance;
    BOOL bAggregateAll;
    int nNumAggregatedProperties;   
    int nCurAggPropSize;
	CPropertyName *pAggregatedPropertyNames;  

    int nNumHavingTokens;
    int nCurHavingSize;
    QL_LEVEL_1_TOKEN *pArrayOfHavingTokens;
    
    long lRefCount;

    QL_LEVEL_1_RPN_EXPRESSION();
    QL_LEVEL_1_RPN_EXPRESSION(const QL_LEVEL_1_RPN_EXPRESSION& Other);
   ~QL_LEVEL_1_RPN_EXPRESSION();    
    void AddRef();
    void Release();

    void SetClassName(LPCWSTR wszName);
    void SetTolerance(const WBEM_QL1_TOLERANCE& Tolerance);
    void AddToken(const WBEM_QL1_TOKEN& Tok);
    void AddToken(const QL_LEVEL_1_TOKEN& Tok);
    void AddProperty(const CPropertyName& Prop);
    void AddAllProperties();

    void SetAggregated();
    void SetAggregationTolerance(const WBEM_QL1_TOLERANCE& Tolerance);
    void AddAggregationProperty(const CPropertyName& Property);
    void AddAllAggregationProperties();
    void AddHavingToken(const WBEM_QL1_TOKEN& Tok);

    void Dump(const char *pszTextFile);
    DELETE_ME LPWSTR GetText();
};


class QL1_Parser : public CAbstractQl1Parser
{
    QL_LEVEL_1_RPN_EXPRESSION* m_pExpression;
    BOOL m_bPartiallyParsed;

public:
    QL1_Parser(CGenLexSource *pSrc);
   ~QL1_Parser();

    int GetQueryClass(LPWSTR pBuf, int nBufSize);
       
    int Parse(QL_LEVEL_1_RPN_EXPRESSION **pOutput);
    static LPWSTR ReplaceClassName(QL_LEVEL_1_RPN_EXPRESSION* pExpr, 
        LPCWSTR wszClassName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the gloabal dll functions

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************



#include "precomp.h"

#include <olectl.h>

//OK we need these globals
HINSTANCE   g_hInst = NULL;
CEventProviderManager* g_pMgr = NULL;
CCriticalSection g_ProvLock;
ProvDebugLog* CNTEventProvider::g_NTEvtDebugLog = NULL;
CDllMap CEventlogRecord::sm_dllMap;
CSIDMap CEventlogRecord::sm_usersMap;
CMutex* CNTEventProvider::g_secMutex = NULL;
CMutex* CNTEventProvider::g_perfMutex = NULL;
PSID CNTEventProvider::s_NetworkServiceSid = NULL;
PSID CNTEventProvider::s_LocalServiceSid = NULL;
PSID CNTEventProvider::s_AliasBackupOpsSid = NULL;
PSID CNTEventProvider::s_AliasSystemOpsSid = NULL;
PSID CNTEventProvider::s_AliasGuestsSid = NULL;
PSID CNTEventProvider::s_LocalSystemSid = NULL;
PSID CNTEventProvider::s_AliasAdminsSid = NULL;
PSID CNTEventProvider::s_AnonymousLogonSid = NULL;
PSID CNTEventProvider::s_WorldSid = NULL;
IWbemClassObject *WbemTaskObject::g_ClassArray[] = { NULL, NULL, NULL, NULL, NULL };

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

    HINSTANCE hInstance, 
    ULONG ulReason , 
    LPVOID pvReserved
)
{
    SetStructuredExceptionHandler seh;
    BOOL status = TRUE ;

    try
    {

        if ( DLL_PROCESS_DETACH == ulReason )
        {
        }
        else if ( DLL_PROCESS_ATTACH == ulReason )
        {
            g_hInst=hInstance;
            DisableThreadLibraryCalls(hInstance);
        }
        else if ( DLL_THREAD_DETACH == ulReason )
        {
        }
        else if ( DLL_THREAD_ATTACH == ulReason )
        {
        }

    }
    catch(Structured_Exception e_SE)
    {
        status = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        status = FALSE;
    }
    catch(...)
    {
        status = FALSE;
    }

    return status;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

    REFCLSID rclsid , 
    REFIID riid, 
    void **ppv 
)
{
    HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
        if (g_ProvLock.Lock())
        {
            if ( rclsid == CLSID_CNTEventProviderClassFactory ) 
            {
                CNTEventlogEventProviderClassFactory *lpunk = new CNTEventlogEventProviderClassFactory;

                if ( lpunk == NULL )
                {
                    status = E_OUTOFMEMORY ;
                }
                else
                {
                    status = lpunk->QueryInterface ( riid , ppv ) ;

                    if ( FAILED ( status ) )
                    {
                        delete lpunk ;              
                    }
                }
            }
            else if ( rclsid == CLSID_CNTEventInstanceProviderClassFactory ) 
            {
                CNTEventlogInstanceProviderClassFactory *lpunk = new CNTEventlogInstanceProviderClassFactory;

                if ( lpunk == NULL )
                {
                    status = E_OUTOFMEMORY ;
                }
                else
                {
                    status = lpunk->QueryInterface ( riid , ppv ) ;

                    if ( FAILED ( status ) )
                    {
                        delete lpunk ;              
                    }
                }
            }
            else
            {
                status = CLASS_E_CLASSNOTAVAILABLE ;
            }

            g_ProvLock.Unlock();
        }
        else
        {
            status = E_UNEXPECTED ;
        }
    }
    catch(Structured_Exception e_SE)
    {
        status = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        status = E_OUTOFMEMORY;
    }
    catch(...)
    {
        status = E_UNEXPECTED;
    }

    return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */
    BOOL unload = FALSE;
    HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
        if (g_ProvLock.Lock())
        {
            unload = (0 == CNTEventProviderClassFactory :: locksInProgress)
                            && (0 == CNTEventProviderClassFactory :: objectsInProgress);

            if (unload)
            {
				for (DWORD i = 0; i < NT_EVTLOG_MAX_CLASSES; i++)
				{
					if (WbemTaskObject::g_ClassArray[i])
					{
						WbemTaskObject::g_ClassArray[i]->Release();
						WbemTaskObject::g_ClassArray[i] = NULL;
					}
				}

                CEventlogRecord::EmptyDllMap();
                CEventlogRecord::EmptyUsersMap();
                delete g_pMgr;
                g_pMgr = NULL;
				CNTEventProvider::FreeGlobalSIDs();


                if (CNTEventProvider::g_NTEvtDebugLog != NULL)
                {
                    if (CNTEventProvider::g_secMutex != NULL)
                    {
                        delete CNTEventProvider::g_secMutex;
                        CNTEventProvider::g_secMutex = NULL;
                    }

                    if (CNTEventProvider::g_perfMutex != NULL)
                    {
                        delete CNTEventProvider::g_perfMutex;
                        CNTEventProvider::g_perfMutex = NULL;
                    }

                    delete CNTEventProvider::g_NTEvtDebugLog;
                    CNTEventProvider::g_NTEvtDebugLog = NULL;
                    ProvDebugLog::Closedown();
                }
            }

            g_ProvLock.Unlock();
        }
    }
    catch(Structured_Exception e_SE)
    {
        unload = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        unload = FALSE;
    }
    catch(...)
    {
        unload = FALSE;
    }

    return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}

//Strings used during self registeration

#define REG_FORMAT2_STR         L"%s%s"
#define REG_FORMAT3_STR         L"%s%s\\%s"
#define VER_IND_STR             L"VersionIndependentProgID"
#define NOT_INTERT_STR          L"NotInsertable"
#define INPROC32_STR            L"InprocServer32"
#define PROGID_STR              L"ProgID"
#define THREADING_MODULE_STR    L"ThreadingModel"
#define APARTMENT_STR           L"Both"

#define CLSID_STR               L"CLSID\\"

#define PROVIDER_NAME_STR       L"Microsoft WBEM NT Eventlog Event Provider"
#define PROVIDER_STR            L"WBEM.NT.EVENTLOG.EVENT.PROVIDER"
#define PROVIDER_CVER_STR       L"WBEM.NT.EVENTLOG.EVENT.PROVIDER\\CurVer"
#define PROVIDER_CLSID_STR      L"WBEM.NT.EVENTLOG.EVENT.PROVIDER\\CLSID"
#define PROVIDER_VER_CLSID_STR  L"WBEM.NT.EVENTLOG.EVENT.PROVIDER.0\\CLSID"
#define PROVIDER_VER_STR        L"WBEM.NT.EVENTLOG.EVENT.PROVIDER.0"

#define INST_PROVIDER_NAME_STR      L"Microsoft WBEM NT Eventlog Instance Provider"
#define INST_PROVIDER_STR           L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER"
#define INST_PROVIDER_CVER_STR      L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER\\CurVer"
#define INST_PROVIDER_CLSID_STR     L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER\\CLSID"
#define INST_PROVIDER_VER_CLSID_STR L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER.0\\CLSID"
#define INST_PROVIDER_VER_STR       L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER.0"


/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey, wchar_t* pszValueName, wchar_t* pszValue)
{
    HKEY        hKey;
    wchar_t       szKey[256];

    wcscpy(szKey, HKEYCLASSES);
    wcscat(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
        wcscat(szKey, L"\\");
        wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (lstrlen(pszValue)+1)*sizeof(wchar_t)))
            return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/
STDAPI DllRegisterServer()
{
    HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
        wchar_t szModule[MAX_PATH + 1];
        GetModuleFileName(g_hInst,(wchar_t*)szModule, MAX_PATH + 1);
        wchar_t szProviderClassID[128];
        wchar_t szProviderCLSIDClassID[128];
        StringFromGUID2(CLSID_CNTEventProviderClassFactory,szProviderClassID, 128);

        wcscpy(szProviderCLSIDClassID,CLSID_STR);
        wcscat(szProviderCLSIDClassID,szProviderClassID);

            //Create entries under CLSID
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, PROVIDER_NAME_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, PROGID_STR, NULL, PROVIDER_VER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, VER_IND_STR, NULL, PROVIDER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
            return SELFREG_E_CLASS;

        wchar_t szInstProviderClassID[128];
        wchar_t szInstProviderCLSIDClassID[128];
        StringFromGUID2(CLSID_CNTEventInstanceProviderClassFactory,szInstProviderClassID, 128);

        wcscpy(szInstProviderCLSIDClassID,CLSID_STR);
        wcscat(szInstProviderCLSIDClassID,szInstProviderClassID);

            //Create entries under CLSID
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, NULL, NULL, INST_PROVIDER_NAME_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, PROGID_STR, NULL, INST_PROVIDER_VER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, VER_IND_STR, NULL, INST_PROVIDER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
            return SELFREG_E_CLASS;
    }
    catch(Structured_Exception e_SE)
    {
        status = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        status = E_OUTOFMEMORY;
    }
    catch(...)
    {
        status = E_UNEXPECTED;
    }

    return status ;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI DllUnregisterServer(void)
{
    HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
        wchar_t szTemp[128];
        wchar_t szProviderClassID[128];
        wchar_t szProviderCLSIDClassID[128];

        //event provider
        StringFromGUID2(CLSID_CNTEventProviderClassFactory,szProviderClassID, 128);


        wcscpy(szProviderCLSIDClassID,CLSID_STR);
        wcscat(szProviderCLSIDClassID,szProviderClassID);

        //Delete ProgID keys
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_CVER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);
        
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        //Delete VersionIndependentProgID keys
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_VER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_VER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        //Delete entries under CLSID

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, PROGID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, VER_IND_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, NOT_INTERT_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, INPROC32_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, szProviderCLSIDClassID);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wchar_t szInstProviderClassID[128];
        wchar_t szInstProviderCLSIDClassID[128];

        //instance provider
        StringFromGUID2(CLSID_CNTEventInstanceProviderClassFactory, szInstProviderClassID, 128);

        wcscpy(szInstProviderCLSIDClassID,CLSID_STR);
        wcscat(szInstProviderCLSIDClassID,szInstProviderClassID);

        //Delete ProgID keys

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, INST_PROVIDER_CVER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, INST_PROVIDER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, INST_PROVIDER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        //Delete VersionIndependentProgID keys

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, INST_PROVIDER_VER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, INST_PROVIDER_VER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        //Delete entries under CLSID

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, PROGID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, VER_IND_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, NOT_INTERT_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, INPROC32_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, szInstProviderCLSIDClassID);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);
    }
    catch(Structured_Exception e_SE)
    {
        status = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        status = E_OUTOFMEMORY;
    }
    catch(...)
    {
        status = E_UNEXPECTED;
    }

    return status ;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\core\qllex.cpp ===
/*++



Copyright (c) 1995-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    QLLEX.CPP

Abstract:

    QL Level 1 DFA Table

History:

    raymcc    24-Jun-95       Created.

--*/

#include "precomp.h"
#include <stdio.h>

#include <genlex.h>
#include <qllex.h>             

#define ST_STRING       24
#define ST_IDENT        29
#define ST_GE           35
#define ST_LE           37
#define ST_NE           40
#define ST_NUMERIC      42
#define ST_REAL         47
#define ST_STRING2      53
#define ST_STRING_ESC   58
#define ST_STRING2_ESC  61   
#define ST_DOT          64
#define ST_NEGATIVE_NUM 66
#define ST_POSITIVE_NUM 69

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl Ql_1_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          QL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,  QL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,  0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,  QL_1_TOK_ASTERISK,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,  QL_1_TOK_EQ,          GLEX_ACCEPT,

/* 9 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 10 */  L'<',   GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 11 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 12 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 13 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 14 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 15 */ L'-',   GLEX_EMPTY, ST_NEGATIVE_NUM, 0,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 16 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 17 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 18 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 19 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 20 */ 0,      GLEX_EMPTY, 0,  QL_1_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 21 */ L',',   GLEX_EMPTY, 0,  QL_1_TOK_COMMA, GLEX_ACCEPT,
/* 22 */ L'+',   GLEX_EMPTY, ST_POSITIVE_NUM, 0,               GLEX_CONSUME,

    // Unknown characters

/* 23 */ GLEX_ANY, GLEX_EMPTY, 0,        QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 24 */   L'\n', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 25 */   L'\r', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 26 */   L'"',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 27 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 28 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 29 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 30 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 31 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 35 */  L'=',   GLEX_EMPTY,  0,  QL_1_TOK_GE,  GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 37 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_LE,  GLEX_ACCEPT,
/* 38 */  L'>',   GLEX_EMPTY,      0,  QL_1_TOK_NE,  GLEX_ACCEPT,
/* 39 */  GLEX_ANY, GLEX_EMPTY,    0,  QL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 40 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_NE,     GLEX_ACCEPT,
/* 41 */  GLEX_ANY,  GLEX_EMPTY,   0,  QL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 42 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 43 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 44 */  L'E',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 45 */  L'e',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 46 */  GLEX_ANY, GLEX_EMPTY, 0,          QL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 47 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 48 */  L'E',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 49 */  L'e',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 50 */  L'+',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 51 */  L'-',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 52 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 53 */   L'\n',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 54 */   L'\r',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 55 */   L'\'',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 56 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 57 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 58 */   L'"', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 59 */   L'\\', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 60 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING2_ESC
/* 61 */   L'\'', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 62 */   L'\\', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 63 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_DOT
/* 64 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 65 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,


// ST_NEGATIVE_NUM - Strips whitespace after '-'
/* 66 */ L' ', GLEX_EMPTY, ST_NEGATIVE_NUM, 0, GLEX_CONSUME,
/* 67 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 68 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_POSITIVE_NUM - Strips whitespace after '+'
/* 69 */ L' ', GLEX_EMPTY, ST_POSITIVE_NUM, 0, GLEX_CONSUME,
/* 70 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 71 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\main.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the gloabal dll functions

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************



#include "precomp.h"

#include <olectl.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <ntevtdefs.h>
#include <tchar.h>


//OK we need these globals
CEventProviderManager* g_pMgr = NULL;
CCriticalSection g_ProvLock;
ProvDebugLog* CNTEventProvider::g_NTEvtDebugLog = NULL;
CDllMap CEventlogRecord::sm_dllMap;
CSIDMap CEventlogRecord::sm_usersMap;
CMutex* CNTEventProvider::g_secMutex = NULL;
CMutex* CNTEventProvider::g_perfMutex = NULL;

HMODULE ghOle32 = NULL;

BOOL s_Exiting = FALSE ;


typedef HRESULT (WINAPI* PFNCOINITIALIZEEX)(void* pvReserved,  //Reserved  
                                            DWORD dwCoInit      //COINIT value
                                            );

typedef HRESULT (WINAPI* PFNCOINITIALIZESECURITY)(
                                PSECURITY_DESCRIPTOR         pSecDesc,
                                LONG                         cAuthSvc,
                                SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
                                void                        *pReserved1,
                                DWORD                        dwAuthnLevel,
                                DWORD                        dwImpLevel,
                                void                        *pReserved2,
                                DWORD                        dwCapabilities,
                                void                        *pReserved3 );

HRESULT COMInit();
STDAPI ExeRegisterServer(void);
STDAPI ExeUnregisterServer(void);

BOOL StartupProvider (DWORD *pdwClassFac)
{
    CNTEventlogInstanceProviderClassFactory *lpunki = new CNTEventlogInstanceProviderClassFactory;
    lpunki->AddRef();

    HRESULT hr = CoRegisterClassObject(
                          CLSID_CNTEventInstanceProviderClassFactory,   //Class identifier (CLSID) to be registered
                          (IUnknown *) lpunki,                      //Pointer to the class object
                          CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER, //Context for running executable code
                          REGCLS_MULTIPLEUSE,                       //How to connect to the class object
                          &(pdwClassFac[0])                         //Pointer to the value returned
                          );

    if (SUCCEEDED(hr))
    {
        CNTEventlogEventProviderClassFactory *lpunke = new CNTEventlogEventProviderClassFactory;
        lpunke->AddRef();
        HRESULT hr = CoRegisterClassObject(
                          CLSID_CNTEventProviderClassFactory,       //Class identifier (CLSID) to be registered
                          (IUnknown *) lpunke,                      //Pointer to the class object
                          CLSCTX_LOCAL_SERVER|CLSCTX_INPROC_SERVER, //Context for running executable code
                          REGCLS_MULTIPLEUSE,                       //How to connect to the class object
                          &(pdwClassFac[1])                         //Pointer to the value returned
                          );

    }

    return (SUCCEEDED(hr));
}

void ShutdownProvider(DWORD *pdwClassFac)
{
    CEventlogRecord::EmptyDllMap();
    CEventlogRecord::EmptyUsersMap();
    delete g_pMgr;
    g_pMgr = NULL;

    if (CNTEventProvider::g_NTEvtDebugLog != NULL)
    {
        if (CNTEventProvider::g_secMutex != NULL)
        {
            delete CNTEventProvider::g_secMutex;
            CNTEventProvider::g_secMutex = NULL;
        }

        if (CNTEventProvider::g_perfMutex != NULL)
        {
            delete CNTEventProvider::g_perfMutex;
            CNTEventProvider::g_perfMutex = NULL;
        }

        delete CNTEventProvider::g_NTEvtDebugLog;
        CNTEventProvider::g_NTEvtDebugLog = NULL;
        ProvDebugLog::Closedown();
    }

    CoRevokeClassObject(pdwClassFac[0]);
    CoRevokeClassObject(pdwClassFac[1]);
}


BOOL ParseCommandLine () 
{
    BOOL t_Exit = FALSE ;

    LPTSTR t_CommandLine = GetCommandLine () ;
    if ( t_CommandLine )
    {
        TCHAR *t_Arg = NULL ;
        TCHAR *t_ApplicationArg = NULL ;
        t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
        t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;

        if ( t_Arg ) 
        {
            if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
            {
                t_Exit = TRUE ;
                ExeRegisterServer();
            }
            else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
            {
                t_Exit = TRUE ;
                ExeUnregisterServer();
            }
            else if(_tcsicmp(t_Arg, _TEXT ( "/EMBEDDING" ) ) == 0)
            {
                // COM called us, so this is the real thing...
                t_Exit = FALSE;
            }
        }
    }

    return t_Exit ;
}

LONG CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
    long t_rc = 0 ;

    switch ( a_message )
    {
        case WM_CLOSE:
        {
            s_Exiting = TRUE ;
        }
        break ;

        case WM_DESTROY:
        {
            PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
        }
        break ;

        default:
        {       
            t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
        }
        break ;
    }

    return ( t_rc ) ;
}

HWND WindowsInit ( HINSTANCE a_HInstance )
{
    static wchar_t *t_TemplateCode = L"TemplateCode - NT Eventlog Provider" ;

    WNDCLASS  t_wc ;
 
    t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
    t_wc.lpfnWndProc      = WindowsMainProc ;
    t_wc.cbClsExtra       = 0 ;
    t_wc.cbWndExtra       = 0 ;
    t_wc.hInstance        = a_HInstance ;
    t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
    t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
    t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
    t_wc.lpszMenuName     = NULL ;
    t_wc.lpszClassName    = t_TemplateCode ;
 
    ATOM t_winClass = RegisterClass ( &t_wc ) ;

    HWND t_HWnd = CreateWindow (

        t_TemplateCode ,              // see RegisterClass() call
        t_TemplateCode ,                      // text for window title bar
        WS_OVERLAPPEDWINDOW ,               // window style
        CW_USEDEFAULT ,                     // default horizontal position
        CW_USEDEFAULT ,                     // default vertical position
        CW_USEDEFAULT ,                     // default width
        CW_USEDEFAULT ,                     // default height
        NULL ,                              // overlapped windows have no parent
        NULL ,                              // use the window class menu
        a_HInstance ,
        NULL                                // pointer not needed
    ) ;

    if (t_HWnd)
    {
        ShowWindow ( t_HWnd, SW_SHOW ) ;
    }

    return t_HWnd ;
}

void WindowsStop ( HWND a_HWnd )
{
    DestroyWindow ( a_HWnd ) ;
}

HWND WindowsStart ( HINSTANCE a_Handle )
{
    HWND t_HWnd = WindowsInit(a_Handle);

    return t_HWnd;
}

void WindowsDispatch ()
{
    BOOL t_GetMessage ;
    MSG t_lpMsg ;

    while ( ( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
    {
        TranslateMessage ( & t_lpMsg ) ;
        DispatchMessage ( & t_lpMsg ) ;

        if ( s_Exiting ) 
            return ;
    }
}


int WINAPI WinMain (
  
    HINSTANCE hInstance,        // handle to current instance
    HINSTANCE hPrevInstance,    // handle to previous instance
    LPSTR lpCmdLine,            // pointer to command line
    int nShowCmd                // show state of window
)
{
    // Initialize the COM Library.
    HRESULT hr = COMInit();

    BOOL t_Exit = ParseCommandLine();

    if (!t_Exit) 
    {
        HWND hWnd = WindowsStart(hInstance);

        if (hWnd)
        {
            DWORD dwArray[] = {0, 0};

            if (StartupProvider(dwArray))
            {
                WindowsDispatch();
                ShutdownProvider(dwArray);
            }

            WindowsStop(hWnd);
        }
    }

    // Uninitialize the COM Library.
    ::CoUninitialize() ;

    return 0 ;
}



//Strings used during self registeration

#define REG_FORMAT2_STR         L"%s%s"
#define REG_FORMAT3_STR         L"%s%s\\%s"
#define VER_IND_STR             L"VersionIndependentProgID"
#define NOT_INTERT_STR          L"NotInsertable"
#define LOCALSRV32_STR          _T("LocalServer32")
#define PROGID_STR              L"ProgID"
#define THREADING_MODULE_STR    L"ThreadingModel"
#define APARTMENT_STR           L"Both"

#define CLSID_STR               L"CLSID\\"

#define PROVIDER_NAME_STR       L"Microsoft WBEM NT Eventlog Event Provider"
#define PROVIDER_STR            L"WBEM.NT.EVENTLOG.EVENT.PROVIDER"
#define PROVIDER_CVER_STR       L"WBEM.NT.EVENTLOG.EVENT.PROVIDER\\CurVer"
#define PROVIDER_CLSID_STR      L"WBEM.NT.EVENTLOG.EVENT.PROVIDER\\CLSID"
#define PROVIDER_VER_CLSID_STR  L"WBEM.NT.EVENTLOG.EVENT.PROVIDER.0\\CLSID"
#define PROVIDER_VER_STR        L"WBEM.NT.EVENTLOG.EVENT.PROVIDER.0"

#define INST_PROVIDER_NAME_STR      L"Microsoft WBEM NT Eventlog Instance Provider"
#define INST_PROVIDER_STR           L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER"
#define INST_PROVIDER_CVER_STR      L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER\\CurVer"
#define INST_PROVIDER_CLSID_STR     L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER\\CLSID"
#define INST_PROVIDER_VER_CLSID_STR L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER.0\\CLSID"
#define INST_PROVIDER_VER_STR       L"WBEM.NT.EVENTLOG.INSTANCE.PROVIDER.0"


/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey, wchar_t* pszValueName, wchar_t* pszValue)
{
    HKEY        hKey;
    wchar_t       szKey[256];

    wcscpy(szKey, HKEYCLASSES);
    wcscat(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
        wcscat(szKey, L"\\");
        wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (lstrlen(pszValue)+1)*sizeof(wchar_t)))
            return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/
STDAPI ExeRegisterServer()
{
    HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
        wchar_t szModule[MAX_PATH + 1];
        HINSTANCE hInst = GetModuleHandle(_T("NTEVT"));
        GetModuleFileName(hInst,(wchar_t*)szModule, MAX_PATH + 1);
        wchar_t szProviderClassID[128];
        wchar_t szProviderCLSIDClassID[128];
        StringFromGUID2(CLSID_CNTEventProviderClassFactory,szProviderClassID, 128);

        wcscpy(szProviderCLSIDClassID,CLSID_STR);
        wcscat(szProviderCLSIDClassID,szProviderClassID);

            //Create entries under CLSID
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, PROVIDER_NAME_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, PROGID_STR, NULL, PROVIDER_VER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, VER_IND_STR, NULL, PROVIDER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSRV32_STR, NULL,szModule))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSRV32_STR,THREADING_MODULE_STR, APARTMENT_STR))
            return SELFREG_E_CLASS;

        wchar_t szInstProviderClassID[128];
        wchar_t szInstProviderCLSIDClassID[128];
        StringFromGUID2(CLSID_CNTEventInstanceProviderClassFactory,szInstProviderClassID, 128);

        wcscpy(szInstProviderCLSIDClassID,CLSID_STR);
        wcscat(szInstProviderCLSIDClassID,szInstProviderClassID);

            //Create entries under CLSID
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, NULL, NULL, INST_PROVIDER_NAME_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, PROGID_STR, NULL, INST_PROVIDER_VER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, VER_IND_STR, NULL, INST_PROVIDER_STR))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, LOCALSRV32_STR, NULL,szModule))
            return SELFREG_E_CLASS;
        if (FALSE ==SetKeyAndValue(szInstProviderCLSIDClassID, LOCALSRV32_STR,THREADING_MODULE_STR, APARTMENT_STR))
            return SELFREG_E_CLASS;
    }
    catch(Structured_Exception e_SE)
    {
        status = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        status = E_OUTOFMEMORY;
    }

    return status ;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI ExeUnregisterServer(void)
{
    HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
        wchar_t szTemp[128];
        wchar_t szProviderClassID[128];
        wchar_t szProviderCLSIDClassID[128];

        //event provider
        StringFromGUID2(CLSID_CNTEventProviderClassFactory,szProviderClassID, 128);


        wcscpy(szProviderCLSIDClassID,CLSID_STR);
        wcscat(szProviderCLSIDClassID,szProviderClassID);

        //Delete ProgID keys
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_CVER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);
        
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        //Delete VersionIndependentProgID keys
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_VER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, PROVIDER_VER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        //Delete entries under CLSID

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, PROGID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, VER_IND_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, NOT_INTERT_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szProviderCLSIDClassID, LOCALSRV32_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, szProviderCLSIDClassID);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wchar_t szInstProviderClassID[128];
        wchar_t szInstProviderCLSIDClassID[128];

        //instance provider
        StringFromGUID2(CLSID_CNTEventInstanceProviderClassFactory, szInstProviderClassID, 128);

        wcscpy(szInstProviderCLSIDClassID,CLSID_STR);
        wcscat(szInstProviderCLSIDClassID,szInstProviderClassID);

        //Delete ProgID keys

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, INST_PROVIDER_CVER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, INST_PROVIDER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, INST_PROVIDER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        //Delete VersionIndependentProgID keys

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, INST_PROVIDER_VER_CLSID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);
        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, INST_PROVIDER_VER_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        //Delete entries under CLSID

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, PROGID_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, VER_IND_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, NOT_INTERT_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT3_STR, HKEYCLASSES, szInstProviderCLSIDClassID, LOCALSRV32_STR);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

        wsprintf(szTemp, REG_FORMAT2_STR, HKEYCLASSES, szInstProviderCLSIDClassID);
        RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);
    }
    catch(Structured_Exception e_SE)
    {
        status = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        status = E_OUTOFMEMORY;
    }

    return status ;
 }

/////////////////////////////////////////////////////////////////////////////
HRESULT COMInit()
{
    HRESULT hr;
    PFNCOINITIALIZESECURITY pfnCoInitializeSecurity = NULL;
    PFNCOINITIALIZEEX pfnCoInitializeEx = NULL;

    
    //Get handle to COM library 
    ghOle32 = LoadLibraryEx(_T("ole32.dll"), NULL, 0);

    if(ghOle32 != NULL) 
    {                                            
        //Get ptr to functions CoInitialize and CoInitializeSecurity.
        pfnCoInitializeEx = (PFNCOINITIALIZEEX) GetProcAddress(ghOle32, 
                                                   "CoInitializeEx");
        pfnCoInitializeSecurity = (PFNCOINITIALIZESECURITY) GetProcAddress(ghOle32, 
                                             "CoInitializeSecurity");

        //Initialize COM
        if (pfnCoInitializeEx) 
        {
            hr = pfnCoInitializeEx(NULL, COINIT_MULTITHREADED);
        }
        else 
        {
            hr = CoInitialize(NULL);
        }

        if(FAILED(hr))
        {
            FreeLibrary(ghOle32);
            ghOle32 = NULL;
            return E_FAIL;
        }
      
        //Initialize Security
        if (pfnCoInitializeSecurity)
        {
            hr = pfnCoInitializeSecurity(NULL, -1, NULL, NULL, 
                                           RPC_C_AUTHN_LEVEL_CONNECT, 
                                           RPC_C_IMP_LEVEL_IMPERSONATE, 
                                           NULL, EOAC_NONE, 0);
        }
    
        if(FAILED(hr))
        {
            CoUninitialize();
            ghOle32 = NULL;
            return E_FAIL;
        }

        FreeLibrary(ghOle32);
    }
    else
    {
        return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\core\ql.cpp ===
/*++



Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    QL.CPP

Abstract:

    Level 1 Syntax QL Parser

    Implements the syntax described in QL_1.BNF.  This translates the input
    into an RPN stream of tokens.

History:

    a-raymcc    21-Jun-96       Created.
    mdavis      23-Apr-99       Changed to allow 'group' as a property name
                              for Raid 47767.  Also fixed GetText() for
                              property comparisons and improved Dump().

--*/

#include "precomp.h"
#include <stdio.h>
#include <errno.h>

#include <math.h>

#include <genlex.h>
#include <qllex.h>
#include <ql.h>
#include <ASSERT.H >

LPWSTR WbemStringCopy(LPCWSTR wsz)
{
    if(wsz == NULL)
        return NULL;

    LPWSTR wszNew = new WCHAR[wcslen(wsz)+1];
    if(wszNew == NULL)
        return NULL;

    wcscpy(wszNew, wsz);
    return wszNew;
}

void WbemStringFree(LPWSTR wsz)
{
    delete [] wsz;
}

int wbem_wcsicmp(LPCWSTR wsz1, LPCWSTR wsz2)
{
    return _wcsicmp(wsz1, wsz2);
}

#define trace(x)

//***************************************************************************
//
//  BOOL ReadI64
//
//  DESCRIPTION:
//
//  Reads a signed 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz     String to read from
//      __int64& i64    Destination for the value
//
//***************************************************************************
POLARITY BOOL ReadI64(LPCWSTR wsz, __int64& ri64)
{
    __int64 i64 = 0;
    const WCHAR* pwc = wsz;

    int nSign = 1;
    if(*pwc == L'-')
    {
        nSign = -1;
        pwc++;
    }
        
    while(i64 >= 0 && i64 < 0x7FFFFFFFFFFFFFFF / 8 && 
            *pwc >= L'0' && *pwc <= L'9')
    {
        i64 = i64 * 10 + (*pwc - L'0');
        pwc++;
    }

    if(*pwc)
        return FALSE;

    if(i64 < 0)
    {
        // Special case --- largest negative number
        // ========================================

        if(nSign == -1 && i64 == (__int64)0x8000000000000000)
        {
            ri64 = i64;
            return TRUE;
        }
        
        return FALSE;
    }

    ri64 = i64 * nSign;
    return TRUE;
}

//***************************************************************************
//
//  BOOL ReadUI64
//
//  DESCRIPTION:
//
//  Reads an unsigned 64-bit value from a string
//
//  PARAMETERS:
//
//      LPCWSTR wsz              String to read from
//      unsigned __int64& i64    Destination for the value
//
//***************************************************************************
POLARITY BOOL ReadUI64(LPCWSTR wsz, unsigned __int64& rui64)
{
    unsigned __int64 ui64 = 0;
    const WCHAR* pwc = wsz;

    while(ui64 < 0xFFFFFFFFFFFFFFFF / 8 && *pwc >= L'0' && *pwc <= L'9')
    {
        unsigned __int64 ui64old = ui64;
        ui64 = ui64 * 10 + (*pwc - L'0');
        if(ui64 < ui64old)
            return FALSE;

        pwc++;
    }

    if(*pwc)
    {
        return FALSE;
    }

    rui64 = ui64;
    return TRUE;
}


//***************************************************************************
//
//  WCHARToDOUBLE
//
//  Converts a wchar to a double, but does it using the english locale rather
//  than whatever local the process is running in.  This allows us to support
//  all english queries even on German machines.
//
//***************************************************************************

DOUBLE WCHARToDOUBLE(WCHAR * pConv, bool & bSuccess)
{
    bSuccess = false;
    if(pConv == NULL)
        return 0.0;

    VARIANT varTo, varFrom;
    VariantInit(&varTo);
    varFrom.vt = VT_BSTR;
    varFrom.bstrVal = SysAllocString(pConv);
    if(varFrom.bstrVal == NULL)
        return 0.0;
    SCODE sc = VariantChangeTypeEx(&varTo, &varFrom, 0x409, 0, VT_R8);
    VariantClear(&varFrom);
    if(sc == S_OK)
        bSuccess = true;
    return varTo.dblVal;
}

CPropertyName::CPropertyName(const CPropertyName& Other)
{
    Init();
    *this = Other;
}

void CPropertyName::Init()
{
    m_lNumElements = 0;
    m_lAllocated = 0;
    m_aElements = NULL;
}

void CPropertyName::operator=(const CPropertyName& Other)
{
    *this = (const WBEM_PROPERTY_NAME&)Other;
}

void CPropertyName::operator=(const WBEM_PROPERTY_NAME& Other)
{
    Empty();
//    delete [] m_aElements;
    if(Other.m_lNumElements > 0)
        m_aElements = new WBEM_NAME_ELEMENT[Other.m_lNumElements];

    m_lNumElements = Other.m_lNumElements;
    m_lAllocated = m_lNumElements;

    for(long l = 0; l < m_lNumElements; l++)
    {
        m_aElements[l].m_nType = Other.m_aElements[l].m_nType;
        if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            m_aElements[l].Element.m_wszPropertyName =
                WbemStringCopy(Other.m_aElements[l].Element.m_wszPropertyName);
        }
        else
        {
            m_aElements[l].Element.m_lArrayIndex =
                Other.m_aElements[l].Element.m_lArrayIndex;
        }
    }
}

BOOL CPropertyName::operator==(const WBEM_PROPERTY_NAME& Other)
{
    if(m_lNumElements != Other.m_lNumElements)
        return FALSE;

    for(long l = 0; l < m_lNumElements; l++)
    {
        if(m_aElements[l].m_nType != Other.m_aElements[l].m_nType)
            return FALSE;
        if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            if(wbem_wcsicmp(m_aElements[l].Element.m_wszPropertyName,
                        Other.m_aElements[l].Element.m_wszPropertyName))
            {
                return FALSE;
            }
        }
        else
        {
            if(m_aElements[l].Element.m_lArrayIndex !=
                Other.m_aElements[l].Element.m_lArrayIndex)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

void CPropertyName::Empty()
{
    for(long l = 0; l < m_lNumElements; l++)
    {
        if(m_aElements[l].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            WbemStringFree(m_aElements[l].Element.m_wszPropertyName);
        }
    }
    delete [] m_aElements;
    m_aElements = NULL;
    m_lNumElements = 0;
    m_lAllocated = 0;
}

LPCWSTR CPropertyName::GetStringAt(long lIndex) const
{
    if(m_aElements[lIndex].m_nType == WBEM_NAME_ELEMENT_TYPE_PROPERTY)
    {
        return m_aElements[lIndex].Element.m_wszPropertyName;
    }
    else return NULL;
}

void CPropertyName::AddElement(LPCWSTR wszElement)
{
    EnsureAllocated(m_lNumElements+1);
    m_aElements[m_lNumElements].m_nType = WBEM_NAME_ELEMENT_TYPE_PROPERTY;
    m_aElements[m_lNumElements].Element.m_wszPropertyName =
        WbemStringCopy(wszElement);
    m_lNumElements++;
}

void CPropertyName::EnsureAllocated(long lElements)
{
    if(m_lAllocated < lElements)
    {
        WBEM_NAME_ELEMENT* pTemp = new WBEM_NAME_ELEMENT[ lElements + 5 ];
        memcpy(pTemp, m_aElements, sizeof(WBEM_NAME_ELEMENT) * m_lNumElements);
        delete [] m_aElements;
        m_aElements = pTemp;
        m_lAllocated = lElements + 5;
    }
}

DELETE_ME LPWSTR CPropertyName::GetText()
{
    /*
    WString wsText;
    for(int i = 0; i < m_lNumElements; i++)
    {
        if(m_aElements[i].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
            return NULL;
        if(i > 0)
            wsText += L".";
        wsText += m_aElements[i].Element.m_wszPropertyName;
    }
    return wsText.UnbindPtr();
    */

    assert(FALSE);
    return NULL;
}




//***************************************************************************
//***************************************************************************


DWORD CAbstractQl1Parser::TranslateIntrinsic(LPCWSTR pFuncName)
{
    if (wbem_wcsicmp(pFuncName, L"UPPER") == 0)
        return QL1_FUNCTION_UPPER;
    if (wbem_wcsicmp(pFuncName, L"LOWER") == 0)
        return QL1_FUNCTION_LOWER;
    return QL1_FUNCTION_NONE;
}

void CAbstractQl1Parser::InitToken(WBEM_QL1_TOKEN* pToken)
{
    pToken->m_lTokenType = QL1_NONE;
    pToken->m_PropertyName.m_lNumElements = 0;
    pToken->m_PropertyName.m_aElements = NULL;

    pToken->m_PropertyName2.m_lNumElements = 0;
    pToken->m_PropertyName2.m_aElements = NULL;

    VariantInit(&pToken->m_vConstValue);
}


CAbstractQl1Parser::CAbstractQl1Parser(CGenLexSource *pSrc)
{
    m_nLine = 0;
    m_pTokenText = 0;
    m_nCurrentToken = 0;

    // Semantic transfer variables.
    // ============================
    m_nRelOp = 0;
    VariantInit(&m_vTypedConst);
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_PropertyName.m_lNumElements = 0;
    m_PropertyName.m_aElements = NULL;
    m_PropertyName2.m_lNumElements = 0;
    m_PropertyName2.m_aElements = NULL;
    m_bPropComp = FALSE;

    m_pLexer = new CGenLexer(Ql_1_LexTable, pSrc);
}

CAbstractQl1Parser::~CAbstractQl1Parser()
{
    VariantClear(&m_vTypedConst);
    DeletePropertyName();
    delete m_pLexer;
}


int CAbstractQl1Parser::Parse(CQl1ParseSink* pSink, int nFlags)
{
    m_pSink = pSink;
    int nRes = parse(nFlags);
    m_pSink = NULL;
    return nRes;
}

//***************************************************************************
//
//  Next()
//
//  Advances to the next token and recognizes keywords, etc.
//
//***************************************************************************

BOOL CAbstractQl1Parser::Next(int nFlags)
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == QL_1_TOK_ERROR)
        return FALSE;

    m_nLine = m_pLexer->GetLineNum();
    m_pTokenText = m_pLexer->GetTokenText();
    if (m_nCurrentToken == QL_1_TOK_EOF)
        m_pTokenText = L"<end of file>";

    // Keyword check.
    // ==============

    if (m_nCurrentToken == QL_1_TOK_IDENT && nFlags != NO_KEYWORDS)
    {
        if (wbem_wcsicmp(m_pTokenText, L"select") == 0)
            m_nCurrentToken = QL_1_TOK_SELECT;
        else if (wbem_wcsicmp(m_pTokenText, L"from") == 0)
            m_nCurrentToken = QL_1_TOK_FROM;
        else if (wbem_wcsicmp(m_pTokenText, L"where") == 0)
            m_nCurrentToken = QL_1_TOK_WHERE;
/*
        else if (wbem_wcsicmp(m_pTokenText, L"like") == 0)
            m_nCurrentToken = QL_1_TOK_LIKE;
*/
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"or") == 0)
            m_nCurrentToken = QL_1_TOK_OR;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"and") == 0)
            m_nCurrentToken = QL_1_TOK_AND;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"not") == 0)
            m_nCurrentToken = QL_1_TOK_NOT;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"IS") == 0)
            m_nCurrentToken = QL_1_TOK_IS;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"NULL") == 0)
            m_nCurrentToken = QL_1_TOK_NULL;
        else if (wbem_wcsicmp(m_pTokenText, L"WITHIN") == 0)
            m_nCurrentToken = QL_1_TOK_WITHIN;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"ISA") == 0)
            m_nCurrentToken = QL_1_TOK_ISA;
        else if (nFlags != EXCLUDE_GROUP_KEYWORD && wbem_wcsicmp(m_pTokenText, L"GROUP") == 0)
            m_nCurrentToken = QL_1_TOK_GROUP;
        else if (wbem_wcsicmp(m_pTokenText, L"BY") == 0)
            m_nCurrentToken = QL_1_TOK_BY;
        else if (wbem_wcsicmp(m_pTokenText, L"HAVING") == 0)
            m_nCurrentToken = QL_1_TOK_HAVING;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"TRUE") == 0)
            m_nCurrentToken = QL_1_TOK_TRUE;
        else if (nFlags != EXCLUDE_EXPRESSION_KEYWORDS && wbem_wcsicmp(m_pTokenText, L"FALSE") == 0)
            m_nCurrentToken = QL_1_TOK_FALSE;
    }

    return TRUE;
}

LPCWSTR CAbstractQl1Parser::GetSinglePropertyName()
{
    if(m_PropertyName.m_lNumElements < 1)
        return NULL;

    if(m_PropertyName.m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        return NULL;

    return m_PropertyName.m_aElements[0].Element.m_wszPropertyName;
}

void CAbstractQl1Parser::DeletePropertyName()
{
    for(long l = 0; l < m_PropertyName.m_lNumElements; l++)
    {
        if(m_PropertyName.m_aElements[l].m_nType ==
                                             WBEM_NAME_ELEMENT_TYPE_PROPERTY)
        {
            WbemStringFree(m_PropertyName.m_aElements[l].
                                Element.m_wszPropertyName);
        }
    }
    delete [] m_PropertyName.m_aElements;
    m_PropertyName.m_lNumElements = 0;
    m_PropertyName.m_aElements = NULL;
}

int CAbstractQl1Parser::FlipOperator(int nOp)
{
    switch(nOp)
    {
    case QL1_OPERATOR_EQUALS:
        return QL1_OPERATOR_EQUALS;

    case QL1_OPERATOR_NOTEQUALS:
        return QL1_OPERATOR_NOTEQUALS;

    case QL1_OPERATOR_GREATER:
        return QL1_OPERATOR_LESS;

    case QL1_OPERATOR_LESS:
        return QL1_OPERATOR_GREATER;

    case QL1_OPERATOR_LESSOREQUALS:
        return QL1_OPERATOR_GREATEROREQUALS;

    case QL1_OPERATOR_GREATEROREQUALS:
        return QL1_OPERATOR_LESSOREQUALS;

    case QL1_OPERATOR_LIKE:
        return QL1_OPERATOR_LIKE;

    case QL1_OPERATOR_UNLIKE:
        return QL1_OPERATOR_UNLIKE;

    case QL1_OPERATOR_ISA:
        return QL1_OPERATOR_INV_ISA;

    case QL1_OPERATOR_ISNOTA:
        return QL1_OPERATOR_INV_ISNOTA;

    case QL1_OPERATOR_INV_ISA:
        return QL1_OPERATOR_ISA;

    case QL1_OPERATOR_INV_ISNOTA:
        return QL1_OPERATOR_ISNOTA;

    default:
        return nOp;
    }
}

void CAbstractQl1Parser::AddAppropriateToken(const WBEM_QL1_TOKEN& Token)
{
    if(m_bInAggregation)
        m_pSink->AddHavingToken(Token);
    else
        m_pSink->AddToken(Token);
}

//***************************************************************************
//
// <parse> ::= SELECT <prop_list> FROM <classname> WHERE <expr>;
//
//***************************************************************************
// ok

int CAbstractQl1Parser::parse(int nFlags)
{
    int nRes;

    m_bInAggregation = FALSE;
    if(nFlags != JUST_WHERE)
    {
        m_pLexer->Reset();

        // SELECT
        // ======
        if (!Next())
            return LEXICAL_ERROR;
        if (m_nCurrentToken != QL_1_TOK_SELECT)
            return SYNTAX_ERROR;
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        // <prop_list>
        // ===========
        if (nRes = prop_list())
            return nRes;

        // FROM
        // ====
        if (m_nCurrentToken != QL_1_TOK_FROM)
            return SYNTAX_ERROR;
        if (!Next())
            return LEXICAL_ERROR;

        // <classname>
        // ===========
        if (nRes = class_name())
            return nRes;

        // <tolerance>
        // ===========

        if(nRes = tolerance())
            return nRes;
    }

    if(nFlags != NO_WHERE)
    {
        // WHERE clause.
        // =============
        if(nRes = opt_where())
            return nRes;

        // GROUP BY clause
        // ===============
        if(nRes = opt_aggregation())
            return nRes;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <opt_where> ::= WHERE <expr>;
//  <opt_where> ::= <>;
//
//***************************************************************************
int CAbstractQl1Parser::opt_where()
{
    int nRes;

    if (m_nCurrentToken == QL_1_TOK_EOF || m_nCurrentToken == QL_1_TOK_GROUP)
    {
        trace(("No WHERE clause\n"));
        return SUCCESS;
    }

    if (m_nCurrentToken != QL_1_TOK_WHERE)
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    // <expr>
    // ======
    if (nRes = expr())
        return nRes;

    // Verify that the current token is QL_1_TOK_EOF.
    // ===============================================
    if (m_nCurrentToken != QL_1_TOK_EOF && m_nCurrentToken != QL_1_TOK_GROUP)
        return SYNTAX_ERROR;

    return SUCCESS;
}



//***************************************************************************
//
//  <prop_list> ::= <property_name> <prop_list_2>;
//
//***************************************************************************

int CAbstractQl1Parser::prop_list()
{
    int nRes;

    if (m_nCurrentToken != QL_1_TOK_ASTERISK &&
        m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    if (nRes = property_name())
        return nRes;

    return prop_list_2();
}

//***************************************************************************
//
//  <prop_list_2> ::= COMMA <prop_list>;
//  <prop_list_2> ::= <>;
//
//***************************************************************************

int CAbstractQl1Parser::prop_list_2()
{
    if (m_nCurrentToken == QL_1_TOK_COMMA)
    {
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        return prop_list();
    }

    return SUCCESS;
}


int CAbstractQl1Parser::parse_property_name(CPropertyName& Prop)
{
    Prop.Empty();

    int nCount = 0;
    while(m_nCurrentToken == QL_1_TOK_IDENT)
    {
        Prop.AddElement(m_pTokenText);
        nCount++;

        if(!Next())
            return LEXICAL_ERROR;

        if(m_nCurrentToken != QL_1_TOK_DOT)
            break;

        if(!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
    }
    if (nCount)
        return SUCCESS;
    else
        return SYNTAX_ERROR;
}

//***************************************************************************
//
//  <property_name> ::= PROPERTY_NAME_STRING;
//  <property_name> ::= ASTERISK;
//
//***************************************************************************

int CAbstractQl1Parser::property_name()
{
    if (m_nCurrentToken == QL_1_TOK_ASTERISK)
    {
        trace(("Asterisk\n"));

        if(m_bInAggregation)
            m_pSink->AddAllAggregationProperties();
        else
            m_pSink->AddAllProperties();

        if(!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // Else a list of property names
    // =============================

    CPropertyName Prop;
    int nRes = parse_property_name(Prop);
    if(nRes != SUCCESS)
        return nRes;

    if(m_bInAggregation)
        m_pSink->AddAggregationProperty(Prop);
    else
        m_pSink->AddProperty(Prop);

    return SUCCESS;
}


//***************************************************************************
//
//  <classname> ::= CLASS_NAME_STRING;
//
//***************************************************************************

int CAbstractQl1Parser::class_name()
{
    if (m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    trace(("Class name is %S\n", m_pTokenText));
    m_pSink->SetClassName(m_pTokenText);

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <tolerance> ::= <>;
//  <tolerance> ::= WITHIN duration;
//
//***************************************************************************

int CAbstractQl1Parser::tolerance()
{
    LPWSTR wszGarbage;
    WBEM_QL1_TOLERANCE Tolerance;
    if(m_nCurrentToken != QL_1_TOK_WITHIN)
    {
        Tolerance.m_bExact = TRUE;
        m_pSink->SetTolerance(Tolerance);
        return SUCCESS;
    }

    if(!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        Tolerance.m_bExact = FALSE;
        bool bSuccess;
        Tolerance.m_fTolerance = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(Tolerance.m_fTolerance <= 0 || bSuccess == false)
        {
            return SYNTAX_ERROR;
        }
        m_pSink->SetTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else if (m_nCurrentToken == QL_1_TOK_INT)
    {
        Tolerance.m_bExact = FALSE;
        Tolerance.m_fTolerance = wcstol(m_pTokenText, &wszGarbage, 10);
        if(Tolerance.m_fTolerance < 0)
        {
            return SYNTAX_ERROR;
        }
        m_pSink->SetTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else
    {
        return SYNTAX_ERROR;
    }
}

//***************************************************************************
//
//  <expr> ::= <term> <expr2>;
//
//***************************************************************************

int CAbstractQl1Parser::expr()
{
    int nRes;

    if (nRes = term())
        return nRes;

    if (nRes = expr2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <expr2> ::= OR <term> <expr2>;
//  <expr2> ::= <>;
//
//  Entry: Assumes token OR already current.
//  Exit:  Advances a token
//
//***************************************************************************

int CAbstractQl1Parser::expr2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == QL_1_TOK_OR)
        {
            trace(("Token OR\n"));
            m_pSink->InOrder(QL1_OR);

            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if (nRes = term())
                return nRes;

            WBEM_QL1_TOKEN NewTok;
            InitToken(&NewTok);
            NewTok.m_lTokenType = QL1_OR;
            AddAppropriateToken(NewTok);
        }
        else break;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <term> ::= <simple_expr> <term2>;
//
//***************************************************************************

int CAbstractQl1Parser::term()
{
    int nRes;
    if (nRes = simple_expr())
        return nRes;

    if (nRes = term2())
        return nRes;

    return SUCCESS;
}

//***************************************************************************
//
//  <term2> ::= AND <simple_expr> <term2>;
//  <term2> ::= <>;
//
//***************************************************************************

int CAbstractQl1Parser::term2()
{
    int nRes;

    while (1)
    {
        if (m_nCurrentToken == QL_1_TOK_AND)
        {
            trace(("Token AND\n"));
            m_pSink->InOrder(QL1_AND);

            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if (nRes = simple_expr())
                return nRes;

            // Add the AND token.
            // ==================
            WBEM_QL1_TOKEN NewTok;
            InitToken(&NewTok);
            NewTok.m_lTokenType = QL1_AND;
            AddAppropriateToken(NewTok);
        }
        else break;
    }

    return SUCCESS;
}


//***************************************************************************
//
//  <simple_expr> ::= NOT <expr>;
//  <simple_expr> ::= OPEN_PAREN <expr> CLOSE_PAREN;
//  <simple_expr> ::= IDENTIFIER <leading_ident_expr> <finalize>;
//  <simple_expr> ::= VARIANT <rel_operator> <trailing_prop_expr> <finalize>;
//
//***************************************************************************
// ok
int CAbstractQl1Parser::simple_expr()
{
    int nRes;

    // NOT <expr>
    // ==========
    if (m_nCurrentToken == QL_1_TOK_NOT)
    {
        trace(("Operator NOT\n"));
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        if (nRes = simple_expr())
            return nRes;

        WBEM_QL1_TOKEN NewTok;
        InitToken(&NewTok);
        NewTok.m_lTokenType = QL1_NOT;
        AddAppropriateToken(NewTok);

        return SUCCESS;
    }

    // OPEN_PAREN <expr> CLOSE_PAREN
    // =============================
    else if (m_nCurrentToken == QL_1_TOK_OPEN_PAREN)
    {
        trace(("Open Paren: Entering subexpression\n"));
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;
        if (expr())
            return SYNTAX_ERROR;
        if (m_nCurrentToken != QL_1_TOK_CLOSE_PAREN)
            return SYNTAX_ERROR;
        trace(("Close paren: Exiting subexpression\n"));
        if (!Next())
            return LEXICAL_ERROR;

        return SUCCESS;
    }

    // IDENTIFIER <leading_ident_expr> <finalize>
    // ==========================================
    else if (m_nCurrentToken == QL_1_TOK_IDENT)
    {
        trace(("    Identifier <%S>\n", m_pTokenText));

        if(nRes = parse_property_name(m_PropertyName))
            return nRes;

        if (nRes = leading_ident_expr())
            return SYNTAX_ERROR;

        return finalize();
    }

    // <typed_constant> <rel_operator> <trailing_prop_expr> <finalize>
    // ======================================================
    else if (m_nCurrentToken == QL_1_TOK_INT ||
             m_nCurrentToken == QL_1_TOK_REAL ||
             m_nCurrentToken == QL_1_TOK_TRUE ||
             m_nCurrentToken == QL_1_TOK_FALSE ||
             m_nCurrentToken == QL_1_TOK_NULL ||
             m_nCurrentToken == QL_1_TOK_QSTRING
            )
    {
        if (nRes = typed_constant())
            return nRes;

        if (nRes = rel_operator())
            return nRes;

        // dont allow const followed by isa!

        if(m_nRelOp == QL1_OPERATOR_ISA)
            return SYNTAX_ERROR;

        // Since we always view the token as IDENT <rel> constant, we need
        // to invert this operator, e.g. replace > with <
        // ================================================================

        m_nRelOp = FlipOperator(m_nRelOp);

        if (nRes = trailing_prop_expr())
            return nRes;

        return finalize();
    }

    return SYNTAX_ERROR;
}


//***************************************************************************
//
//  <trailing_prop_expr> ::=  IDENTIFIER
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_prop_expr()
{
    if (m_nCurrentToken != QL_1_TOK_IDENT)
        return SYNTAX_ERROR;

    int nRes = parse_property_name(m_PropertyName);
    return nRes;
}

//***************************************************************************
//
//  <leading_ident_expr> ::= <comp_operator> <trailing_const_expr>;
//  <leading_ident_expr> ::= <equiv_operator> <trailing_or_null>;
//  <leading_ident_expr> ::= <is_operator> NULL;
//
//***************************************************************************
// ok
int CAbstractQl1Parser::leading_ident_expr()
{
    int nRes;
    if (SUCCESS ==  comp_operator())
    {
        return trailing_const_expr();
    }
    else if(SUCCESS == equiv_operator())
        return trailing_or_null();
    nRes = is_operator();
    if(nRes != SUCCESS)
        return nRes;
    if (m_nCurrentToken != QL_1_TOK_NULL)
        return LEXICAL_ERROR;
    if (Next())
    {
        V_VT(&m_vTypedConst) = VT_NULL;
        return SUCCESS;
    }
    else
        return LEXICAL_ERROR;
}


//***************************************************************************
//
//  <trailing_or_null> ::= NULL;
//  <trailing_or_null> ::= <trailing_const_expr>;
//
//***************************************************************************

int CAbstractQl1Parser::trailing_or_null()
{
    if (m_nCurrentToken == QL_1_TOK_NULL)
    {
        if (!Next())
            return LEXICAL_ERROR;
        else
        {
            V_VT(&m_vTypedConst) = VT_NULL;
            return SUCCESS;
        }
    }
    return trailing_const_expr();
}

//***************************************************************************
//
//  <trailing_const_expr> ::= IDENTIFIER OPEN_PAREN
//                            <typed_constant> CLOSE_PAREN;
//  <trailing_const_expr> ::= <typed_constant>;
//  <trailing_const_expr> ::= <trailing_ident_expr>
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_const_expr()
{
    int nRes;
    nRes = typed_constant();
    if (nRes != SUCCESS)
        nRes = trailing_ident_expr();
    return nRes;
}

//***************************************************************************
//
//  <trailing_ident_expr> ::= <property_name>
//
//***************************************************************************
// ok
int CAbstractQl1Parser::trailing_ident_expr()
{
    int nRes = parse_property_name(m_PropertyName2) ;
    if (nRes == SUCCESS)
        m_bPropComp = TRUE;
    return nRes;
}

//***************************************************************************
//
//  <finalize> ::= <>;
//
//  This composes the QL_LEVEL_1_TOKEN for a simple relational expression,
//  complete with any associated intrinsic functions.  All of the other
//  parse functions help isolate the terms of the expression, but only
//  this function builds the token.
//
//  To build the token, the following member variables are used:
//      m_pPropName
//      m_vTypedConst
//      m_dwPropFunction
//      m_dwConstFunction
//      m_nRelOp;
//
//  After the token is built, these are cleared/deallocated as appropriate.
//  No tokens are consumed and the input is not advanced.
//
//***************************************************************************
int CAbstractQl1Parser::finalize()
{
    // At this point, we have all the info needed for a token.
    // =======================================================
    int retval = SUCCESS;
    WBEM_QL1_TOKEN NewTok;
    InitToken(&NewTok);

    NewTok.m_lTokenType = QL1_OP_EXPRESSION;
    VariantInit(&NewTok.m_vConstValue);

	//can do a memcpy since NewTok.m_PropertyName isa WBEM_PROPERTY_NAME
	//and m_PropertyName is derived from WBEM_PROPERTY_NAME so copying
	//the contents up to the sizeof(WBEM_PROPERTY_NAME) is OK...
    memcpy((void*)&NewTok.m_PropertyName,
           (void*)&m_PropertyName,
           sizeof (WBEM_PROPERTY_NAME));

    if (m_bPropComp)
    {
        NewTok.m_bPropComp = true;

		//can do a memcpy since NewTok.m_PropertyName2 isa WBEM_PROPERTY_NAME
		//and m_PropertyName2 is derived from WBEM_PROPERTY_NAME so copying
		//the contents up to the sizeof(WBEM_PROPERTY_NAME) is OK...
        memcpy((void*)&NewTok.m_PropertyName2,
               (void*)&m_PropertyName2,
               sizeof (WBEM_PROPERTY_NAME));
    }
    else
    {
        NewTok.m_bPropComp = false;

        if (FAILED(VariantCopy(&NewTok.m_vConstValue, &m_vTypedConst)))
        {
            VariantInit(&NewTok.m_vConstValue);
            retval = FAILED;
        }
    }

    if (retval == SUCCESS)
    {
        NewTok.m_lOperator = m_nRelOp;
        NewTok.m_lPropertyFunction = m_dwPropFunction;
        NewTok.m_lConstFunction = m_dwConstFunction;
        NewTok.m_bQuoted = m_bQuoted;

        AddAppropriateToken(NewTok);

    //    m_PropertyName.m_lNumElements = 0;
    //    m_PropertyName.m_aElements = NULL;
        m_PropertyName.Empty();
        m_PropertyName2.Empty();
    }

    // Cleanup.
    // ========
    VariantClear(&m_vTypedConst);
    VariantClear(&NewTok.m_vConstValue);
    m_nRelOp = 0;
    m_dwPropFunction = 0;
    m_dwConstFunction = 0;
    m_bPropComp = FALSE;

    return retval;
}

//***************************************************************************
//
//  <typed_constant> ::= VARIANT;
//
//  Ouput: m_vTypedConst is set to the value of the constant. The only
//         supported types are VT_I4, VT_R8 and VT_BSTR.
//
//***************************************************************************

int CAbstractQl1Parser::typed_constant()
{
    trace(("    Typed constant <%S> ", m_pTokenText));
    VariantClear(&m_vTypedConst);
    m_bQuoted = FALSE;

    if (m_nCurrentToken == QL_1_TOK_INT)
    {
        trace((" Integer\n"));

        // Read it in as a 64-bit one
        // ==========================

        __int64 i64;
        unsigned __int64 ui64;
        BOOL b32bits = FALSE;
        if(ReadI64(m_pTokenText, i64))
        {
            // Check if it is within range of I4
            // =================================

            if(i64 >= - (__int64)0x80000000 && i64 <= 0x7FFFFFFF)
            {
                V_VT(&m_vTypedConst) = VT_I4;
                V_I4(&m_vTypedConst) = (long)i64;
                b32bits = TRUE;
            }
        }
        else if(!ReadUI64(m_pTokenText, ui64))
        {
            // Not a valid number
            // ==================

            return LEXICAL_ERROR;
        }

        if(!b32bits)
        {
            // Valid 64-bit number but not 32-bit
            // ==================================

            V_VT(&m_vTypedConst) = VT_BSTR;
            V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
            m_bQuoted = FALSE;
        }
    }
    else if (m_nCurrentToken == QL_1_TOK_QSTRING)
    {
        trace((" String\n"));
        V_VT(&m_vTypedConst) = VT_BSTR;
        V_BSTR(&m_vTypedConst) = SysAllocString(m_pTokenText);
        m_bQuoted = TRUE;
    }
    else if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        trace((" Real\n"));
        V_VT(&m_vTypedConst) = VT_R8;
        bool bSuccess;
        V_R8(&m_vTypedConst) = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(bSuccess == false)
            return LEXICAL_ERROR;
    }
    else if(m_nCurrentToken == QL_1_TOK_TRUE)
    {
        V_VT(&m_vTypedConst) = VT_BOOL;
        V_BOOL(&m_vTypedConst) = VARIANT_TRUE;
    }
    else if(m_nCurrentToken == QL_1_TOK_FALSE)
    {
        V_VT(&m_vTypedConst) = VT_BOOL;
        V_BOOL(&m_vTypedConst) = VARIANT_FALSE;
    }
    else if (m_nCurrentToken == QL_1_TOK_NULL)
        V_VT(&m_vTypedConst) = VT_NULL;

    // Else, not a typed constant.
    else
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <rel_operator> ::= <equiv_operator>;
//  <rel_operator> ::= <comp_operator>;
//
//***************************************************************************

int CAbstractQl1Parser::rel_operator()
{
    if(SUCCESS == equiv_operator())
        return SUCCESS;
    else if (SUCCESS == comp_operator())
        return SUCCESS;
    else return LEXICAL_ERROR;
}

//***************************************************************************
//
//  <equiv_operator> ::= EQUIV_OPERATOR; // =, !=
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::equiv_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == QL_1_TOK_EQ)
    {
        trace(("    REL OP =\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUAL;
    }
    else if (m_nCurrentToken == QL_1_TOK_NE)
    {
        trace(("    REL OP <> (!=) \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
    }
    else
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    return SUCCESS;
}

//***************************************************************************
//
//  <is_operator> ::= IS_OPERATOR; // is, isnot
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::is_operator()
{
    m_nRelOp = 0;
    if (m_nCurrentToken != QL_1_TOK_IS)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    if (m_nCurrentToken == QL_1_TOK_NOT)
    {
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        if (!Next())
            return LEXICAL_ERROR;

        trace(("    REL OP IS NOT \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_NOT_EQUAL;
        return SUCCESS;
    }
    else
    {
        trace(("    REL OP IS \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUAL;
        return SUCCESS;
    }

    return SUCCESS;
}

//***************************************************************************
//
//  <comp_operator> ::= COMP_OPERATOR; // <=, >=, <, >, like
//
//  Output: m_nRelOp is set to the correct operator for a QL_LEVEL_1_TOKEN.
//
//***************************************************************************

int CAbstractQl1Parser::comp_operator()
{
    m_nRelOp = 0;

    if (m_nCurrentToken == QL_1_TOK_LE)
    {
        trace(("    REL OP <=\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_LT)
    {
        trace(("    REL OP <\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_LESSTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_GE)
    {
        trace(("    REL OP >=\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_GT)
    {
        trace(("    REL OP >\n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_GREATERTHAN;
    }
    else if (m_nCurrentToken == QL_1_TOK_LIKE)
    {
        trace(("    REL OP 'like' \n"));
        m_nRelOp = QL_LEVEL_1_TOKEN::OP_LIKE;
    }
    else if (m_nCurrentToken == QL_1_TOK_ISA)
    {
        trace(("    REL OP 'isa' \n"));
        m_nRelOp = QL1_OPERATOR_ISA;
    }
    else
        return SYNTAX_ERROR;

    if (!Next(EXCLUDE_GROUP_KEYWORD))
        return LEXICAL_ERROR;

    return SUCCESS;
}

int CAbstractQl1Parser::opt_aggregation()
{
    if(m_nCurrentToken == QL_1_TOK_EOF)
        return SUCCESS;

    if(m_nCurrentToken != QL_1_TOK_GROUP)
        return SYNTAX_ERROR;

    if (!Next())
        return LEXICAL_ERROR;

    m_pSink->SetAggregated();

    int nRes = aggregation_params();
    if(nRes)
        return nRes;

    if(nRes = opt_having())
        return nRes;

    // Make sure we've reached the end
    // ===============================

    if(m_nCurrentToken != QL_1_TOK_EOF)
        return SYNTAX_ERROR;

    return SUCCESS;
}

int CAbstractQl1Parser::aggregation_params()
{
    int nRes;
    WBEM_QL1_TOLERANCE Exact;
    Exact.m_bExact = TRUE;

    if(m_nCurrentToken == QL_1_TOK_BY)
    {
        if (!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        if(nRes = aggregate_by())
            return nRes;

        if(m_nCurrentToken == QL_1_TOK_WITHIN)
        {
            if (!Next())
                return LEXICAL_ERROR;

            if(nRes = aggregate_within())
                return nRes;
        }
        else
        {
            m_pSink->SetAggregationTolerance(Exact);
        }
    }
    else if(m_nCurrentToken == QL_1_TOK_WITHIN)
    {
        if (!Next())
            return LEXICAL_ERROR;

        if(nRes = aggregate_within())
            return nRes;

        if(m_nCurrentToken == QL_1_TOK_BY)
        {
            if (!Next(EXCLUDE_GROUP_KEYWORD))
                return LEXICAL_ERROR;

            if(nRes = aggregate_by())
                return nRes;
        }
    }
    else
    {
        return SYNTAX_ERROR;
    }

    return SUCCESS;
}

int CAbstractQl1Parser::aggregate_within()
{
    WBEM_QL1_TOLERANCE Tolerance;
    Tolerance.m_bExact = FALSE;
    LPWSTR wszGarbage;

    if (m_nCurrentToken == QL_1_TOK_REAL)
    {
        bool bSuccess;
        Tolerance.m_fTolerance = WCHARToDOUBLE(m_pTokenText, bSuccess);
        if(!bSuccess)
            return SYNTAX_ERROR;
        m_pSink->SetAggregationTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else if (m_nCurrentToken == QL_1_TOK_INT)
    {
        Tolerance.m_fTolerance = (double)wcstol(m_pTokenText, &wszGarbage, 10);
        m_pSink->SetAggregationTolerance(Tolerance);
        Next();
        return SUCCESS;
    }
    else
    {
        return SYNTAX_ERROR;
    }
}

int CAbstractQl1Parser::aggregate_by()
{
    m_bInAggregation = TRUE;
    int nRes = prop_list();
    m_bInAggregation = FALSE;
    return nRes;
}

int CAbstractQl1Parser::opt_having()
{
    if(m_nCurrentToken == QL_1_TOK_HAVING)
    {
        if(!Next(EXCLUDE_GROUP_KEYWORD))
            return LEXICAL_ERROR;

        m_bInAggregation = TRUE;
        int nRes = expr();
        m_bInAggregation = FALSE;
        return nRes;
    }
    else return SUCCESS;
}


//***************************************************************************
//***************************************************************************
//
//  class QL1_Parser
//
//  A derivative of CAbstractQlParser for backward compatibility
//
//***************************************************************************
//
//

QL1_Parser::QL1_Parser(CGenLexSource *pSrc)
    : m_pExpression(NULL), CAbstractQl1Parser(pSrc), m_bPartiallyParsed(FALSE)
{
    m_pExpression = new QL_LEVEL_1_RPN_EXPRESSION;
}

QL1_Parser::~QL1_Parser()
{
    delete m_pExpression;
}

int QL1_Parser::GetQueryClass(
    LPWSTR pDestBuf,
    int nBufLen
    )
{
    // Get the underlying parser to parse the first part of the query
    // ==============================================================

    if(!m_bPartiallyParsed)
    {
        int nRes = CAbstractQl1Parser::Parse(m_pExpression, NO_WHERE);
        if(nRes != SUCCESS) return nRes;
    }

    if (!m_pExpression->bsClassName)
        return SYNTAX_ERROR;

    m_bPartiallyParsed = TRUE;
    if(wcslen(m_pExpression->bsClassName) >= (unsigned int)nBufLen)
        return BUFFER_TOO_SMALL;

    wcscpy(pDestBuf, m_pExpression->bsClassName);
    return WBEM_S_NO_ERROR;
}

int QL1_Parser::Parse(QL_LEVEL_1_RPN_EXPRESSION **pOutput)
{
    // Get the underying parser to completely parse the query. If
    // GetQueryClass was called in the past, no sense in duplcating
    // the work
    // ============================================================

    int nRes = CAbstractQl1Parser::Parse(m_pExpression,
        m_bPartiallyParsed?JUST_WHERE:FULL_PARSE);
    *pOutput = m_pExpression;
    m_pExpression = new QL_LEVEL_1_RPN_EXPRESSION;
    m_bPartiallyParsed = FALSE;

    return nRes;
}

DELETE_ME LPWSTR QL1_Parser::ReplaceClassName(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                                LPCWSTR wszClassName)
{
    QL_LEVEL_1_RPN_EXPRESSION NewExpr(*pExpr);

    if (NewExpr.bsClassName)
        SysFreeString(NewExpr.bsClassName);
    NewExpr.bsClassName = SysAllocString(wszClassName);

    LPWSTR wszNewQuery = NewExpr.GetText();
    return wszNewQuery;
}


//***************************************************************************
//
//  Expression and token structure methods.
//
//***************************************************************************

QL_LEVEL_1_RPN_EXPRESSION::QL_LEVEL_1_RPN_EXPRESSION()
{
    nNumTokens = 0;
    bsClassName = 0;
    nNumberOfProperties = 0;
    bStar = FALSE;
    pRequestedPropertyNames = 0;
    nCurSize = 1;
    nCurPropSize = 1;

    bAggregated = FALSE;
    bAggregateAll = FALSE;
    nNumAggregatedProperties = 0;
    nCurAggPropSize = 1;

    nNumHavingTokens = 0;
    nCurHavingSize = 1;

    lRefCount = 0;

    pAggregatedPropertyNames = NULL;
    pArrayOfHavingTokens = NULL;
    pArrayOfTokens = NULL;
    pRequestedPropertyNames = NULL;

    pAggregatedPropertyNames = new CPropertyName[nCurAggPropSize];
    pArrayOfHavingTokens = new QL_LEVEL_1_TOKEN[nCurHavingSize];
    pArrayOfTokens = new QL_LEVEL_1_TOKEN[nCurSize];
    pRequestedPropertyNames = new CPropertyName[nCurPropSize];
}

QL_LEVEL_1_RPN_EXPRESSION::QL_LEVEL_1_RPN_EXPRESSION(
                                const QL_LEVEL_1_RPN_EXPRESSION& Other)
{
    nNumTokens = Other.nNumTokens;
    bsClassName = SysAllocString(Other.bsClassName);
    nNumberOfProperties = Other.nNumberOfProperties;
    bStar = Other.bStar;
    pRequestedPropertyNames = 0;
    nCurSize = Other.nCurSize;
    nCurPropSize = Other.nCurPropSize;

    pAggregatedPropertyNames = NULL;
    pArrayOfHavingTokens = NULL;
    pArrayOfTokens = NULL;
    pRequestedPropertyNames = NULL;

    pArrayOfTokens = new QL_LEVEL_1_TOKEN[nCurSize];
    int i;
    for(i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i] = Other.pArrayOfTokens[i];

    pRequestedPropertyNames = new CPropertyName[nCurPropSize];
    for(i = 0; i < nNumberOfProperties; i++)
        pRequestedPropertyNames[i] = Other.pRequestedPropertyNames[i];

    bAggregated = Other.bAggregated;
    bAggregateAll = Other.bAggregateAll;
    nNumAggregatedProperties = Other.nNumAggregatedProperties;
    nCurAggPropSize = Other.nCurAggPropSize;

    pAggregatedPropertyNames = new CPropertyName[nCurAggPropSize];
    for(i = 0; i < nNumAggregatedProperties; i++)
        pAggregatedPropertyNames[i] = Other.pAggregatedPropertyNames[i];

    nNumHavingTokens = Other.nNumHavingTokens;
    nCurHavingSize = Other.nCurHavingSize;

    pArrayOfHavingTokens = new QL_LEVEL_1_TOKEN[nCurHavingSize];
    for(i = 0; i < nNumHavingTokens; i++)
        pArrayOfHavingTokens[i] = Other.pArrayOfHavingTokens[i];

    lRefCount = 0;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddRef()
{
    InterlockedIncrement(&lRefCount);
}

void QL_LEVEL_1_RPN_EXPRESSION::Release()
{
    if(InterlockedDecrement(&lRefCount) == 0)
        delete this;
}


QL_LEVEL_1_RPN_EXPRESSION::~QL_LEVEL_1_RPN_EXPRESSION()
{
    delete [] pArrayOfTokens;
    if (bsClassName)
        SysFreeString(bsClassName);
    delete [] pAggregatedPropertyNames;
    delete [] pArrayOfHavingTokens;
    delete [] pRequestedPropertyNames;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetClassName(LPCWSTR wszClassName)
{
    bsClassName = SysAllocString(wszClassName);
}

void QL_LEVEL_1_RPN_EXPRESSION::SetTolerance(
                                const WBEM_QL1_TOLERANCE& _Tolerance)
{
    Tolerance = _Tolerance;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetAggregationTolerance(
                                const WBEM_QL1_TOLERANCE& _Tolerance)
{
    AggregationTolerance = _Tolerance;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddToken(
                                  const WBEM_QL1_TOKEN& Tok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 1;
        nCurSize *= 2;
        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurSize];
        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddToken(
                                  const QL_LEVEL_1_TOKEN& Tok)
{
    if (nCurSize == nNumTokens)
    {
        nCurSize += 1;
        nCurSize *= 2;
        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurSize];
        for (int i = 0; i < nNumTokens; i++)
            pTemp[i] = pArrayOfTokens[i];
        delete [] pArrayOfTokens;
        pArrayOfTokens = pTemp;
    }

    pArrayOfTokens[nNumTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddHavingToken(
                                  const WBEM_QL1_TOKEN& Tok)
{
    if (nCurHavingSize == nNumHavingTokens)
    {
        nCurHavingSize += 1;
        nCurHavingSize *= 2;
        QL_LEVEL_1_TOKEN *pTemp = new QL_LEVEL_1_TOKEN[nCurHavingSize];
        for (int i = 0; i < nNumHavingTokens; i++)
            pTemp[i] = pArrayOfHavingTokens[i];
        delete [] pArrayOfHavingTokens;
        pArrayOfHavingTokens = pTemp;
    }

    pArrayOfHavingTokens[nNumHavingTokens++] = Tok;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddProperty(const CPropertyName& Prop)
{
    if (nCurPropSize == nNumberOfProperties)
    {
        nCurPropSize += 1;
        nCurPropSize *= 2;
        CPropertyName *pTemp = new CPropertyName[nCurPropSize];
        for(int i = 0; i < nNumberOfProperties; i++)
            pTemp[i] = pRequestedPropertyNames[i];
        delete [] pRequestedPropertyNames;
        pRequestedPropertyNames = pTemp;
    }

    pRequestedPropertyNames[nNumberOfProperties++] = Prop;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAllProperties()
{
    bStar = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::SetAggregated()
{
    bAggregated = TRUE;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAggregationProperty(
                                    const CPropertyName& Property)
{
    if(pAggregatedPropertyNames == NULL)
    {
        // '*' requested
        return;
    }
    if (nCurAggPropSize == nNumAggregatedProperties)
    {
        nCurAggPropSize += 1;
        nCurAggPropSize *= 2;
        CPropertyName *pTemp = new CPropertyName[nCurAggPropSize];
        for(int i = 0; i < nNumAggregatedProperties; i++)
            pTemp[i] = pAggregatedPropertyNames[i];
        delete [] pAggregatedPropertyNames;
        pAggregatedPropertyNames = pTemp;
    }

    pAggregatedPropertyNames[nNumAggregatedProperties++] = Property;
}

void QL_LEVEL_1_RPN_EXPRESSION::AddAllAggregationProperties()
{
    bAggregateAll = TRUE;
}

DELETE_ME LPWSTR QL_LEVEL_1_RPN_EXPRESSION::GetText()
{
    assert(FALSE);
    return NULL;
    /*
    WString wsText;

    wsText += L"select ";
    for(int i = 0; i < nNumberOfProperties; i++)
    {
        if(i != 0) wsText += L", ";
        wsText += (LPWSTR)pRequestedPropertyNames[i].GetStringAt(0);
    }
    if(bStar)
    {
        if(nNumberOfProperties > 0)
            wsText += L", ";
        wsText += L"*";
    }

    wsText += L" from ";
    if (bsClassName)
        wsText += bsClassName;

    if(nNumTokens > 0)
    {
        wsText += L" where ";

        CWStringArray awsStack;
        for(int i = 0; i < nNumTokens; i++)
        {
            QL_LEVEL_1_TOKEN& Token = pArrayOfTokens[i];
            LPWSTR wszTokenText = Token.GetText();
            if(Token.nTokenType == QL1_OP_EXPRESSION)
            {
                awsStack.Add(wszTokenText);
                delete [] wszTokenText;
            }
            else if(Token.nTokenType == QL1_NOT)
            {
                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                WString wsNew;
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" (";
                wsNew += wszLast;
                wsNew += L")";
                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.Add(wsNew);
            }
            else
            {
                if(awsStack.Size() < 2) return NULL;

                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                LPWSTR wszPrev = awsStack[awsStack.Size()-2];

                WString wsNew;
                wsNew += L"(";
                wsNew += wszPrev;
                wsNew += L" ";
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" ";
                wsNew += wszLast;
                wsNew += L")";

                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.RemoveAt(awsStack.Size()-1); //pop

                awsStack.Add(wsNew);
            }
        }

        if(awsStack.Size() != 1) return NULL;
        wsText += awsStack[0];
    }

    return wsText.UnbindPtr();
    */
}

void QL_LEVEL_1_RPN_EXPRESSION::Dump(const char *pszTextFile)
{
    FILE *f = fopen(pszTextFile, "wt");
    if (!f)
        return;

    fprintf(f, "----RPN Expression----\n");
    fprintf(f, "Class name = %S\n", bsClassName);
    fprintf(f, "Properties selected: ");

    if (!nNumberOfProperties)
    {
        fprintf(f, "* = all properties selected\n");
    }
    else for (int i = 0; i < nNumberOfProperties; i++)
    {
        fprintf(f, "%S ", pRequestedPropertyNames[i].GetStringAt(0));
    }
    fprintf(f, "\n------------------\n");
    fprintf(f, "Tokens:\n");

    for (int i = 0; i < nNumTokens; i++)
        pArrayOfTokens[i].Dump(f);

    fprintf(f, "---end of expression---\n");
    fclose(f);
}

QL_LEVEL_1_TOKEN::QL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bQuoted = TRUE;
    m_bPropComp = FALSE;
}

QL_LEVEL_1_TOKEN::QL_LEVEL_1_TOKEN(const QL_LEVEL_1_TOKEN &Src)
{
    nTokenType = 0;
    nOperator = 0;
    VariantInit(&vConstValue);
    dwPropertyFunction = 0;
    dwConstFunction = 0;
    bQuoted = TRUE;
    m_bPropComp = FALSE;

    *this = Src;
}

QL_LEVEL_1_TOKEN& QL_LEVEL_1_TOKEN::operator =(const QL_LEVEL_1_TOKEN &Src)
{
    nTokenType = Src.nTokenType;
    PropertyName = Src.PropertyName;
    
    if (Src.m_bPropComp)
        PropertyName2 = Src.PropertyName2;

    nOperator = Src.nOperator;
    
    if (FAILED(VariantCopy(&vConstValue, (VARIANT*)&Src.vConstValue)))
        VariantInit(&vConstValue);

    dwPropertyFunction = Src.dwPropertyFunction;
    dwConstFunction = Src.dwConstFunction;
    bQuoted = Src.bQuoted;
    m_bPropComp = Src.m_bPropComp;
    return *this;
}

QL_LEVEL_1_TOKEN& QL_LEVEL_1_TOKEN::operator =(const WBEM_QL1_TOKEN &Src)
{
    nTokenType = Src.m_lTokenType;
    PropertyName = Src.m_PropertyName;
    
    if (Src.m_bPropComp)
        PropertyName2 = Src.m_PropertyName2;

    nOperator = Src.m_lOperator;
    
    if (FAILED(VariantCopy(&vConstValue, (VARIANT*)&Src.m_vConstValue)))
        VariantInit(&vConstValue);
    
    dwPropertyFunction = Src.m_lPropertyFunction;
    dwConstFunction = Src.m_lConstFunction;
    bQuoted = Src.m_bQuoted;
    m_bPropComp = Src.m_bPropComp;
    return *this;
}

QL_LEVEL_1_TOKEN::~QL_LEVEL_1_TOKEN()
{
    nTokenType = 0;
    nOperator = 0;
    VariantClear(&vConstValue);
}

DELETE_ME LPWSTR QL_LEVEL_1_TOKEN::GetText()
{
    assert(FALSE);
    return NULL;
    /*
    WString wsText;
    LPWSTR wszPropName;
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            wszPropName = PropertyName.GetText();
            wsText += wszPropName;
            delete [] wszPropName;
            wsText += L" ";

            WCHAR* wszOp;
            switch (nOperator)
            {
            case OP_EQUAL: wszOp = L"="; break;
            case OP_NOT_EQUAL: wszOp = L"<>"; break;
            case OP_EQUALorGREATERTHAN: wszOp = L">="; break;
            case OP_EQUALorLESSTHAN: wszOp = L"<="; break;
            case OP_LESSTHAN: wszOp = L"<"; break;
            case OP_GREATERTHAN: wszOp = L">"; break;
            case OP_LIKE: wszOp = L"LIKE"; break;
            case QL1_OPERATOR_ISA: wszOp = L"ISA"; break;
            default: wszOp = NULL;
            }
            if(wszOp)
                wsText += wszOp;
            wsText += L" ";

            if (m_bPropComp)
            {
                // property comparison (e.g., prop1 > prop2)
                wszPropName = PropertyName2.GetText();
                wsText += wszPropName;
                delete [] wszPropName;
            }
            else
            {
                // expression with constant (e.g., prop1 > 5)
                WCHAR wszConst[100];
                switch (V_VT(&vConstValue))
                {
                case VT_NULL:
                    wsText += L"NULL";
                    break;
                case VT_I4:
                    swprintf(wszConst, L"%d", V_I4(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_I2:
                    swprintf(wszConst, L"%d", (int)V_I2(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_UI1:
                    swprintf(wszConst, L"%d", (int)V_UI1(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_BSTR:
                {
                    if(bQuoted)
                        wsText += L"\"";
                    //If we need to parse the string we do it the hard way
                    WCHAR* pwc = V_BSTR(&vConstValue);
                    BOOL bLongMethod = FALSE;
                    for (int tmp = 0; pwc[tmp]; tmp++)
                        if ((pwc[tmp] == L'\\') || (pwc[tmp] == L'"'))
                            bLongMethod = TRUE;
                    if (bLongMethod)
                    {
                        for(pwc; *pwc; pwc++)
                        {
                            if(*pwc == L'\\' || *pwc == L'"')
                                wsText += L'\\';
                            wsText += *pwc;
                        }
                    }
                    else
                    {
                        //otherwise we do it the fast way...
                        wsText += pwc;
                    }
                    if(bQuoted)
                        wsText += L"\"";
                }
                    break;
                case VT_R4:
                    swprintf(wszConst, L"%G", V_R4(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_R8:
                    swprintf(wszConst, L"%lG", V_R8(&vConstValue));
                    wsText += wszConst;
                    break;
                case VT_BOOL:
                    wsText += (V_BOOL(&vConstValue)?L"TRUE":L"FALSE");
                    break;
                }
            }

            break;
        case TOKEN_AND:
            wsText = "AND";
            break;
        case TOKEN_OR:
            wsText = "OR";
            break;
        case TOKEN_NOT:
            wsText = "NOT";
            break;
    }

    return wsText.UnbindPtr();
    */
}

void QL_LEVEL_1_TOKEN::Dump(FILE *f)
{
    switch (nTokenType)
    {
        case OP_EXPRESSION:
            fprintf(f, "OP_EXPRESSION ");
            break;
        case TOKEN_AND:
            fprintf(f, "TOKEN_AND ");
            break;
        case TOKEN_OR:
            fprintf(f, "TOKEN_OR ");
            break;
        case TOKEN_NOT:
            fprintf(f, "TOKEN_NOT ");
            break;
        default:
            fprintf(f, "Error: no token type specified\n");
    }

    if (nTokenType == OP_EXPRESSION)
    {
        char *pOp = "<no op>";
        switch (nOperator)
        {
            case OP_EQUAL: pOp = "OP_EQUAL"; break;
            case OP_NOT_EQUAL: pOp = "OP_NOT_EQUAL"; break;
            case OP_EQUALorGREATERTHAN: pOp = "OP_EQUALorGREATERTHAN"; break;
            case OP_EQUALorLESSTHAN: pOp = "OP_EQUALorLESSTHAN"; break;
            case OP_LESSTHAN: pOp = "OP_LESSTHAN"; break;
            case OP_GREATERTHAN: pOp = "OP_GREATERTHAN"; break;
            case OP_LIKE: pOp = "OP_LIKE"; break;
        }

        LPWSTR wszPropName = PropertyName.GetText();
        fprintf(f, "    Property = %S\n", wszPropName);
        delete [] wszPropName;
        fprintf(f, "    Operator = %s\n", pOp);
        fprintf(f, "    Value =    ");

        if (m_bPropComp)
        {
            wszPropName = PropertyName2.GetText();
            fprintf(f, "   <Property:%S>\n", wszPropName);
            delete [] wszPropName;
        }
        else
        {
            switch (V_VT(&vConstValue))
            {
                case VT_I4:
                    fprintf(f, "VT_I4 = %d\n", V_I4(&vConstValue));
                    break;
                case VT_I2:
                    fprintf(f, "VT_I2 = %d\n", (int)V_I2(&vConstValue));
                    break;
                case VT_UI1:
                    fprintf(f, "VT_UI1 = %d\n", (int)V_UI1(&vConstValue));
                    break;
                case VT_BSTR:
                    fprintf(f, "VT_BSTR = %S\n", V_BSTR(&vConstValue));
                    break;
                case VT_R4:
                    fprintf(f, "VT_R4 = %f\n", V_R4(&vConstValue));
                    break;
                case VT_R8:
                    fprintf(f, "VT_R8 = %f\n", V_R8(&vConstValue));
                    break;
                case VT_BOOL:
                    fprintf(f, "%S\n", V_BOOL(&vConstValue)?L"TRUE":L"FALSE");
                    break;
                case VT_NULL:
                    fprintf(f, "%S\n", L"NULL");
                    break;
                default:
                    fprintf(f, "<unknown>\n");
            }

            switch (dwPropertyFunction)
            {
                case IFUNC_NONE:
                    break;
                case IFUNC_LOWER:
                    fprintf(f, "Intrinsic function LOWER() applied to property\n");
                    break;
                case IFUNC_UPPER:
                    fprintf(f, "Intrinsic function UPPER() applied to property\n");
                    break;
            }
            switch (dwConstFunction)
            {
                case IFUNC_NONE:
                    break;
                case IFUNC_LOWER:
                    fprintf(f, "Intrinsic function LOWER() applied to const value\n");
                    break;
                case IFUNC_UPPER:
                    fprintf(f, "Intrinsic function UPPER() applied to const value\n");
                    break;
            }
        }
    }

    fprintf(f, " <end of token>\n");
}

/////////////////////////////////////////////////////////////////////////////
//
// Algorithm for evaluating the expression, assuming that it has been
// tokenized and translated to Reverse Polish.
//
// Starting point:  (a) An array of QL tokens.
//                  (b) An empty boolean token stack.
//
// 1.  Read Next Token
//
// 2.  If a SIMPLE EXPRESSION, evaluate it to TRUE or FALSE, and
//     place this boolean result on the stack.  Go to 1.
//
// 3.  If an OR operator, then pop a boolean token into A,
//     pop another boolean token into B. If either A or B are TRUE,
//     stack TRUE.  Else stack FALSE.
//     Go to 1.
//
// 4.  If an AND operator, then pop a boolean token into A,
//     and pop another into B.  If both are TRUE, stack TRUE.
//     Else stack FALSE.
//     Go to 1.
//
// 5.  If a NOT operator, reverse the value of the top-of-stack boolean.
//     Go to 1.
//
// At end-of-input, the result is at top-of-stack.
//
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtcfac.cpp ===
//***************************************************************************

//

//  NTEVTCFAC.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"


LONG CNTEventProviderClassFactory :: objectsInProgress = 0 ;
LONG CNTEventProviderClassFactory :: locksInProgress = 0 ;
BOOL CEventLogFile :: ms_bSetPrivilege = FALSE ;
extern CEventProviderManager* g_pMgr;
extern CCriticalSection g_ProvLock;


//***************************************************************************
//
// CNTEventProviderClassFactory::CNTEventProviderClassFactory
// CNTEventProviderClassFactory::~CNTEventProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CNTEventProviderClassFactory::CNTEventProviderClassFactory ()
{
    m_referenceCount = 0 ;
}

CNTEventProviderClassFactory::~CNTEventProviderClassFactory ()
{
}

//***************************************************************************
//
// CNTEventProviderClassFactory::QueryInterface
// CNTEventProviderClassFactory::AddRef
// CNTEventProviderClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CNTEventProviderClassFactory::QueryInterface (

    REFIID iid , 
    LPVOID FAR *iplpv 
) 
{
    *iplpv = NULL ;

    if ( iid == IID_IUnknown )
    {
        *iplpv = ( LPVOID ) this ;
    }
    else if ( iid == IID_IClassFactory )
    {
        *iplpv = ( LPVOID ) this ;      
    }   

    if ( *iplpv )
    {
        ( ( LPUNKNOWN ) *iplpv )->AddRef () ;

        return ResultFromScode ( S_OK ) ;
    }
    else
    {
        return ResultFromScode ( E_NOINTERFACE ) ;
    }
}


STDMETHODIMP_( ULONG ) CNTEventProviderClassFactory :: AddRef ()
{
    InterlockedIncrement(&objectsInProgress);
    return InterlockedIncrement ( &m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CNTEventProviderClassFactory :: Release ()
{   
    LONG ref ;

    if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
    {
        delete this ;
    }

    InterlockedDecrement(&objectsInProgress);
    return ref ;
}

//***************************************************************************
//
// CNTEventProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CNTEventProviderClassFactory :: LockServer ( BOOL fLock )
{
    if ( fLock )
    {
        InterlockedIncrement ( & locksInProgress ) ;
    }
    else
    {
        InterlockedDecrement ( & locksInProgress ) ;
    }

    return S_OK ;
}

//***************************************************************************
//
// CNTEventlogEventProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CNTEventlogEventProviderClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
                                                                REFIID riid,
                                                                LPVOID FAR * ppvObject
)
{
    HRESULT status = E_FAIL;

    if ( pUnkOuter )
    {
        status = CLASS_E_NOAGGREGATION;
    }
    else 
    {
        if (g_ProvLock.Lock())
        {
            if (NULL == CNTEventProvider::g_NTEvtDebugLog)
            {
                ProvDebugLog::Startup();
                CNTEventProvider::g_NTEvtDebugLog = new ProvDebugLog(_T("NTEVT"));
                
                //only need the security mutex if not NT5
                DWORD dwVersion = GetVersion();

                if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
                {
                    CNTEventProvider::g_secMutex = new CMutex(FALSE, SECURITY_MUTEX_NAME, NULL);
                }

                CNTEventProvider::g_perfMutex = new CMutex(FALSE, PERFORMANCE_MUTEX_NAME, NULL);
            }

            if (!CEventLogFile::ms_bSetPrivilege)
            {
                if (!CEventLogFile::SetSecurityLogPrivilege(TRUE))
                {
DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
            L"CNTEventlogEventProviderClassFactory :: CreateInstance, CEventLogFile::SetSecurityLogPrivilege failed \r\n");
)
                }
                else
                {
                    CEventLogFile::ms_bSetPrivilege = TRUE;
                }
            }

            if (NULL == g_pMgr)
            {
                g_pMgr = new CEventProviderManager;
				CNTEventProvider::AllocateGlobalSIDs();
            }

            g_ProvLock.Unlock();
            CNTEventProvider* prov =  new CNTEventProvider(g_pMgr);
            status = prov->QueryInterface (riid, ppvObject);

            if (NOERROR != status)
            {
                delete prov;
            }
        }
    }

    return status ;
}


//***************************************************************************
//
// CNTEventlogInstanceProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CNTEventlogInstanceProviderClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
                                                                REFIID riid,
                                                                LPVOID FAR * ppvObject
)
{
    HRESULT status = E_FAIL;

    if ( pUnkOuter )
    {
        status = CLASS_E_NOAGGREGATION;
    }
    else 
    {
        if (g_ProvLock.Lock())
        {
            if (NULL == CNTEventProvider::g_NTEvtDebugLog)
            {
                ProvDebugLog::Startup();
                CNTEventProvider::g_NTEvtDebugLog = new ProvDebugLog(_T("NTEVT"));

                //only need the security mutex if not NT5
                DWORD dwVersion = GetVersion();

                if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
                {
                    CNTEventProvider::g_secMutex = new CMutex(FALSE, SECURITY_MUTEX_NAME, NULL);
                }
            }

            g_ProvLock.Unlock();

            IWbemServices *lpunk = ( IWbemServices * ) new CImpNTEvtProv ;
            if ( lpunk == NULL )
            {
                status = E_OUTOFMEMORY ;
            }
            else
            {
                status = lpunk->QueryInterface ( riid , ppvObject ) ;
                if ( FAILED ( status ) )
                {
                    delete lpunk ;
                }
                else
                {
                }
            }
        }
    }

    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtlogr.cpp ===
//***************************************************************************

//

//  NTEVTLOGR.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the Eventlog record classes

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

#include <time.h>
#include <wbemtime.h>
#include <Ntdsapi.h>
#include <Sddl.h>

CEventlogRecord::CEventlogRecord(const wchar_t* logfile, const EVENTLOGRECORD* pEvt, IWbemServices* ns,
								 IWbemClassObject* pClass, IWbemClassObject* pAClass)
 :  m_nspace(NULL), m_pClass(NULL), m_pAClass(NULL)
{
    m_EvtType = 0;
	m_Data = NULL;
    m_Obj = NULL;
    m_NumStrs = 0;
    m_DataLen = 0;
    m_nspace = ns;

    if (m_nspace != NULL)
    {
        m_nspace->AddRef();
    }
	else
	{
		m_pClass = pClass;

		if (m_pClass != NULL)
		{
			m_pClass->AddRef();
		}

		m_pAClass = pAClass;

		if (m_pAClass != NULL)
		{
			m_pAClass->AddRef();
		}
	}
    if ((NULL == logfile) || ((m_pClass == NULL) && (m_nspace == NULL)))
    {
        m_Valid = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::CEventlogRecord:Created INVALID Record\r\n"
        ) ;
)
    }
    else
    {
        m_Logfile = logfile;
        m_Valid = Init(pEvt);
    }


}

CEventlogRecord::~CEventlogRecord()
{
    if (m_pClass != NULL)
    {
        m_pClass->Release();
    }

    if (m_pAClass != NULL)
    {
        m_pAClass->Release();
    }
    
    if (m_nspace != NULL)
    {
        m_nspace->Release();
    }

    for (LONG x = 0; x < m_NumStrs; x++)
    {
        delete [] m_InsStrs[x];
    }

    if (m_Data != NULL)
    {
        delete [] m_Data;
    }

    if (m_Obj != NULL)
    {
        m_Obj->Release();
    }
}

BOOL CEventlogRecord::Init(const EVENTLOGRECORD* pEvt)
{
    if (NULL == pEvt)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::Init:No DATA return FALSE\r\n"
        ) ;
)
        return FALSE;
    }

    if (!GetInstance())
    {
        return FALSE;
    }

    m_Record = pEvt->RecordNumber;
    m_EvtID = pEvt->EventID;
    m_SourceName = (const wchar_t*)((UCHAR*)pEvt + sizeof(EVENTLOGRECORD));
    m_CompName = (const wchar_t*)((UCHAR*)pEvt + sizeof(EVENTLOGRECORD)) + wcslen(m_SourceName) + 1;
    SetType(pEvt->EventType);
    m_Category = pEvt->EventCategory;
    SetTimeStr(m_TimeGen, pEvt->TimeGenerated);
    SetTimeStr(m_TimeWritten, pEvt->TimeWritten);

    if (pEvt->UserSidLength > 0)
    {
        SetUser((PSID)((UCHAR*)pEvt + pEvt->UserSidOffset));
    }
    
    if (pEvt->NumStrings)
    {
        //Must have an element for every expected insertion string
        //don't know how many that is so create max size array and
        //intitialize all to NULL
        memset(m_InsStrs, 0, MAX_NUM_OF_INS_STRS * sizeof(wchar_t*));

        const wchar_t* pstr = (const wchar_t*)((UCHAR*)pEvt + pEvt->StringOffset);

        for (WORD x = 0; x < pEvt->NumStrings; x++)
        {
            LONG len = wcslen(pstr) + 1;
            m_InsStrs[x] = new wchar_t[len];
            m_NumStrs++;
            wcscpy(m_InsStrs[x], pstr);
            pstr += len;
        }
    }

    SetMessage();

    if (pEvt->DataLength)
    {
        m_Data = new UCHAR[pEvt->DataLength];
        m_DataLen = pEvt->DataLength;
        memcpy((void*)m_Data, (void*)((UCHAR*)pEvt + pEvt->DataOffset), pEvt->DataLength);
    }

    return TRUE;
}


BOOL CEventlogRecord::GenerateInstance(IWbemClassObject** ppInst)
{
    if (ppInst == NULL)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Invalid parameter\r\n"
        ) ;
)
        return FALSE;
    }

    *ppInst = NULL;

    if (!m_Valid)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Invalid record\r\n"
        ) ;
)
        return FALSE;
    }

    if (!SetProperty(LOGFILE_PROP, m_Logfile))
    {
        m_Valid = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Failed to set key\r\n"
        ) ;
)
        return FALSE;
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Log: %s\r\n", m_Logfile
        ) ;
)
    }

    if (!SetProperty(RECORD_PROP, m_Record))
    {
        m_Valid = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Failed to set key\r\n"
        ) ;
)
        return FALSE;
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Record: %d\r\n", m_Record
        ) ;
)
    }

    SetProperty(TYPE_PROP, m_Type);
    SetProperty(EVTTYPE_PROP, (DWORD)m_EvtType);

    if (!m_SourceName.IsEmpty())
    {
        SetProperty(SOURCE_PROP, m_SourceName);
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:Source: %s\r\n", m_SourceName
        ) ;
)
    }

    SetProperty(EVTID_PROP, m_EvtID);
    SetProperty(EVTID2_PROP, (m_EvtID & 0xFFFF));

    if (!m_TimeGen.IsEmpty())
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GenerateInstance:TimeGenerated: %s\r\n", m_TimeGen
        ) ;
)
        SetProperty(GENERATED_PROP, m_TimeGen);
    }

    if (!m_TimeWritten.IsEmpty())
    {
        SetProperty(WRITTEN_PROP, m_TimeWritten);
    }

    if (!m_CompName.IsEmpty())
    {
        SetProperty(COMPUTER_PROP, m_CompName);
    }

    if (!m_User.IsEmpty())
    {
        SetProperty(USER_PROP, m_User);
    }

    if (!m_Message.IsEmpty())
    {
        SetProperty(MESSAGE_PROP, m_Message);
    }

    if (!m_CategoryString.IsEmpty())
    {
        SetProperty(CATSTR_PROP, m_CategoryString);
    }

    SetProperty(CATEGORY_PROP, (DWORD)m_Category);

    VARIANT v;

    if (m_Data != NULL)
    {
        SAFEARRAYBOUND rgsabound[1];
        SAFEARRAY* psa = NULL;
        UCHAR* pdata = NULL;
        rgsabound[0].lLbound = 0;
        VariantInit(&v);
        rgsabound[0].cElements = m_DataLen;
        psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

        if (NULL != psa)
        {
            if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pdata)))
            {
                memcpy((void *)pdata, (void *)m_Data, m_DataLen);
                SafeArrayUnaccessData(psa);
                v.vt = VT_ARRAY|VT_UI1;
                v.parray = psa;
                m_Obj->Put(DATA_PROP, 0, &v, 0);
            }
        }

        VariantClear(&v);
    }

    if (0 != m_NumStrs)
    {
        SAFEARRAYBOUND rgsabound[1];
        SAFEARRAY* psa = NULL;
        BSTR* pBstr = NULL;
        rgsabound[0].lLbound = 0;
        VariantInit(&v);
        rgsabound[0].cElements = m_NumStrs;
        psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);

        if (NULL != psa)
        {
            if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pBstr)))
            {
                for (LONG x = 0; x < m_NumStrs; x++)
                {
                    pBstr[x] = SysAllocString(m_InsStrs[x]);
                }

                SafeArrayUnaccessData(psa);
                v.vt = VT_ARRAY|VT_BSTR;
                v.parray = psa;
                m_Obj->Put(INSSTRS_PROP, 0, &v, 0);
            }
        }

        VariantClear(&v);
    }

    *ppInst = m_Obj;
    m_Obj->AddRef();
    return TRUE;
}

BOOL CEventlogRecord::SetProperty(wchar_t* prop, CStringW val)
{
    VARIANT v;
    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = val.AllocSysString();

    HRESULT hr = m_Obj->Put(prop, 0, &v, 0);
    VariantClear(&v);

    if (FAILED(hr))
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetProperty:Failed to set %s with %s\r\n",
        prop, val
        ) ;
)

        return FALSE;
    }
    
    return TRUE;
}

BOOL CEventlogRecord::SetProperty(wchar_t* prop, DWORD val)
{
    VARIANT v;
    VariantInit(&v);
    v.vt = VT_I4;
    v.lVal = val;

    HRESULT hr = m_Obj->Put(prop, 0, &v, 0);
    VariantClear(&v);

    if (FAILED(hr))
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetProperty:Failed to set %s with %lx\r\n",
        prop, val
        ) ;
)
        return FALSE;
    }
    
    return TRUE;
}

void CEventlogRecord::SetUser(PSID psidUserSid)
{
    m_User = GetUser(psidUserSid);
}

ULONG CEventlogRecord::CheckInsertionStrings(HINSTANCE hPrimModule, HKEY hk)
{
    HINSTANCE hParamModule;
    CStringW paramModule = CEventLogFile::GetFileName(hk, PARAM_MODULE);

    if (paramModule.IsEmpty())
    {
        hParamModule = NULL;
    }
    else
    {
        hParamModule = GetDll(paramModule);
    }

    ULONG size = 0;

    for (UINT i = 0; i < m_NumStrs; i++)
    {
        UINT nStrSize = wcslen(m_InsStrs[i]);   // get size of insertion string
        wchar_t* lpszString = m_InsStrs[i];     // set initial pointer

        while (nStrSize > 2)
        {
            wchar_t* lpStartDigit = wcschr(lpszString, L'%');
			DWORD nChars = 0;
			UINT nParmSize = 0;
			UINT nOffset = 0;
			wchar_t* lpParmBuffer = NULL;
            BOOL bMove = FALSE;

            if ((lpStartDigit == NULL) || (wcslen(lpStartDigit) < 3))
            {
                break;
            }

			if (lpStartDigit[1] == '%')
			{
				nOffset = lpStartDigit - m_InsStrs[i]; // calculate offset in buffer of %
				lpStartDigit += 2;                  // point to start of potential digit
				lpszString = lpStartDigit;          // set new string pointer
				nStrSize = wcslen(lpszString);      // calculate new string length

				if (nStrSize == 0)
				{
					//done with this string
					break;
				}

				LONG nSubNo = _wtol(lpStartDigit);      // convert to integer

				if (nSubNo == 0 && *lpStartDigit != L'0')
				{
					lpszString--;                   // back up 1 char
					nStrSize = wcslen(lpszString);  // recalculate length
					continue;                       // continue parsing the string
				}

				if (hParamModule !=  NULL)
				{
					nChars = FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
						FORMAT_MESSAGE_IGNORE_INSERTS |     // ignore inserted strings
						FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
						(LPVOID) hParamModule,              // use parameter file
						nSubNo,                             // parameter number to get
						(ULONG) NULL,                       // specify no language
						(LPWSTR) &lpParmBuffer,             // address for buffer pointer
						80,                                 // minimum space to allocate
						NULL);                              // no inserted strings
				}

				if (nChars == 0)
				{
					if (hParamModule !=  NULL)
					{
						LONG lastError = GetLastError();
						LocalFree(lpParmBuffer);
						lpParmBuffer = NULL;
					}

					if (hPrimModule != NULL)
					{
						nChars = FormatMessage(
							FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
							FORMAT_MESSAGE_IGNORE_INSERTS |     // ignore inserted strings
							FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
							(LPVOID) hPrimModule,               // use parameter file
							nSubNo,                             // parameter number to get
							(ULONG) NULL,                       // specify no language
							(LPWSTR) &lpParmBuffer,             // address for buffer pointer
							80,                                 // minimum space to allocate
							NULL);                              // no inserted strings

						if (nChars == 0)
						{
							LONG lastError = GetLastError(); // get error code
							LocalFree(lpParmBuffer);    // free storage
						}
					}
				}

				nParmSize = 2;                 // set initialize parameter size (%%)

				while (wcslen(lpszString))
				{
					if (!iswdigit(*lpszString))
					{
						break;                  // exit if no more digits
					}

					nParmSize++;                // increment parameter size
					lpszString++;               // point to next byte
				}

				lpStartDigit -= 2; //set back to the start of the %% for the copy...
			}
			else if ((lpStartDigit[1] == L'{') && (lpStartDigit[2] == L'G'))
			{
				wchar_t *strEnd = wcschr(lpStartDigit + 2, L'}');

				if (!strEnd)
				{
					//ignore this %{?
					lpszString++;
				}
				else
				{
					//guid string braces but no percent sign...
					CStringW strGUID((LPWSTR)(lpStartDigit+1), (int)(strEnd - lpStartDigit));
					strEnd++;   // now points past '}'

					wchar_t t_csbuf[MAX_COMPUTERNAME_LENGTH + 1];
					DWORD t_csbuflen = MAX_COMPUTERNAME_LENGTH + 1;

					if (GetComputerName(t_csbuf, &t_csbuflen))
					{
						CStringW temp = GetMappedGUID(t_csbuf, strGUID);

						if (temp.GetLength())
						{
							lpParmBuffer = (wchar_t*) LocalAlloc(LMEM_FIXED,(temp.GetLength()+1) * sizeof(wchar_t));

							if (lpParmBuffer)
							{
								wcscpy(lpParmBuffer, temp);
								nChars = wcslen(lpParmBuffer);
								nOffset = lpStartDigit - m_InsStrs[i];
								nParmSize = strEnd - lpStartDigit;
							}
							else
							{
								throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
							}
						}
						else
						{
							// couldn't get a replacement, so skip it.
							lpszString = strEnd;
						}
					}
					else
					{
						// couldn't get a replacement, so skip it.
						lpszString = strEnd;
					}
				}
			}
			else if ((lpStartDigit[1] == L'{') && (lpStartDigit[2] == L'S'))
			{
				wchar_t *strEnd = wcschr(lpStartDigit + 2, L'}');

				if (!strEnd)
				{
					//ignore this %{?
					lpszString++;
				}
				else
				{
					//sid string no braces or percent sign...
					CStringW strSID((LPWSTR)(lpStartDigit+2), (int)(strEnd - lpStartDigit - 2));
					strEnd++;   // now points past '}'
					PSID t_pSid = NULL;

					if (ConvertStringSidToSid((LPCWSTR) strSID, &t_pSid))
					{
						CStringW temp = GetUser(t_pSid);
						LocalFree(t_pSid);

						if (temp.GetLength())
						{
							lpParmBuffer = (wchar_t*) LocalAlloc(LMEM_FIXED,(temp.GetLength()+1) * sizeof(wchar_t));

							if (lpParmBuffer)
							{
								wcscpy(lpParmBuffer, temp);
								nChars = wcslen(lpParmBuffer);
								nOffset = lpStartDigit - m_InsStrs[i];
								nParmSize = strEnd - lpStartDigit;
							}
							else
							{
								throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
							}
						}
						else
						{
							// couldn't get a replacement, so skip it.
							lpszString = strEnd;
						}
					}
					else
					{
						// couldn't get a replacement, so skip it.
						lpszString = strEnd;
					}
				}
			}
			else
			{
				lpszString++;
			}

			if (nChars)
			{
				//perform the move...
				UINT nNewSize = wcslen(m_InsStrs[i])+nChars-nParmSize+1;	// calculate new length
				nStrSize = wcslen(m_InsStrs[i])+1;							// get original length

				if (nNewSize > nStrSize)
				{
					wchar_t* tmp = new wchar_t[nNewSize];		// set new pointer
					wcscpy(tmp, m_InsStrs[i]);
					delete [] m_InsStrs[i];
					m_InsStrs[i] = tmp;
					lpStartDigit = m_InsStrs[i] + nOffset;		// point to new start of current %
					lpszString = lpStartDigit+nChars;			// set new start of scan spot
				}

				nStrSize = wcslen(lpStartDigit)-nParmSize+1;	// calculate length of remainder of string

				memmove((void *)(lpStartDigit+nChars),		// destination address
					(void *)(lpStartDigit+nParmSize),			// source address
					nStrSize*sizeof(wchar_t));		// amount of data to move

				memmove((void *)lpStartDigit,				// destination address
					(void *)lpParmBuffer,					// source address
					nChars*sizeof(wchar_t));		        // amount of data to move
            
				LocalFree(lpParmBuffer);
			}
            
            nStrSize = wcslen(lpszString);				// get length of remainder of string
        }

        size += wcslen(m_InsStrs[i]) + 1;
    }

    return size;
}

CStringW CEventlogRecord::GetUser(PSID userSid)
{
    CStringW retVal;
    BOOL bFound = FALSE;

    if (sm_usersMap.Lock())
    {
        MyPSID usrSID(userSid);

        if (!sm_usersMap.IsEmpty() && sm_usersMap.Lookup(usrSID, retVal))
        {
            bFound = TRUE;
        }

        sm_usersMap.Unlock();
    }

    if (!bFound)
    {
        DWORD dwVersion = GetVersion();

        if ( (4 < (DWORD)(LOBYTE(LOWORD(dwVersion))))
            || ObtainedSerialAccess(CNTEventProvider::g_secMutex) )
        {
            wchar_t szDomBuff[MAX_PATH];
            wchar_t szUsrBuff[MAX_PATH];
            DWORD domBuffLen = MAX_PATH;
            DWORD usrBuffLen = MAX_PATH;
            SID_NAME_USE snu;

            if (LookupAccountSid(           // lookup account name
                            NULL,           // system to lookup account on
                            userSid,        // pointer to SID for this account
                            szUsrBuff,      // return account name in this buffer
                            &usrBuffLen,    // pointer to size of account name returned
                            szDomBuff,      // domain where account was found
                            &domBuffLen,    //pointer to size of domain name
                            &snu))          // sid name use field pointer
            {
                retVal = szDomBuff;
                retVal += L'\\';
                retVal += szUsrBuff;
            }
            else
            {
                LONG lasterr = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GetUser:API (LookupAccountSid) failed with %lx\r\n",
        lasterr
        ) ;
)       
            }

            if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
            {
                ReleaseSerialAccess(CNTEventProvider::g_secMutex);
            }
        }
        else
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GetUser:Failed to get serial access to security APIs\r\n"
        ) ;
)       
        }

        //regardless of error enter this into map so we
        //don't look up this PSID again
        if (sm_usersMap.Lock())
        {
            DWORD sidlen = GetLengthSid(userSid);
            MyPSID key;
            key.m_SID = (PSID) new UCHAR[sidlen];
            CopySid(sidlen, key.m_SID, userSid);
            sm_usersMap[key] = retVal;
            sm_usersMap.Unlock();
        }
    }

    return retVal;

}

void CEventlogRecord::EmptyUsersMap()
{
    if (sm_usersMap.Lock())
    {
        sm_usersMap.RemoveAll();
        sm_usersMap.Unlock();
    }
}


HINSTANCE CEventlogRecord::GetDll(CStringW path)
{
    HINSTANCE retVal = NULL;
    CStringW key(path);
    key.MakeUpper();
    BOOL bFound = FALSE;

    if (sm_dllMap.Lock())
    {
        if (!sm_dllMap.IsEmpty() && sm_dllMap.Lookup(key, retVal))
        {
            bFound = TRUE;
        }

        sm_dllMap.Unlock();
    }

    if (!bFound)
    {
        retVal = LoadLibraryEx(path, NULL, DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_AS_DATAFILE);
        
        if (retVal == NULL)
        {
DebugOut( 
    DWORD lasterr = GetLastError();
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GetDll:API (LoadLibraryEx) failed with %lx for %s\r\n",
        lasterr, path
        ) ;
)
        }

        if (sm_dllMap.Lock())
        {
            sm_dllMap[key] = retVal;
            sm_dllMap.Unlock();
        }
    }

    return retVal;
}

void CEventlogRecord::EmptyDllMap()
{
    if (sm_dllMap.Lock())
    {
        sm_dllMap.RemoveAll();
        sm_dllMap.Unlock();
    }
}

void CEventlogRecord::SetMessage()
{
    HINSTANCE hMsgModule;
    wchar_t* lpBuffer = NULL;

    CStringW log(EVENTLOG_BASE);
    log += L"\\";
    log += m_Logfile;
    HKEY hkResult;
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, log, 0, KEY_READ, &hkResult);

    if (status != ERROR_SUCCESS)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetMessage:API (RegOpenKeyEx) failed with %lx for %s\r\n",
        status, log
        ) ;
)

        return;
    }

    DWORD dwType;
    wchar_t* prim = new wchar_t[MAX_PATH];
    DWORD datalen = MAX_PATH * sizeof(wchar_t);

    status = RegQueryValueEx(hkResult, PRIM_MODULE,
                        0, &dwType, (LPBYTE)prim, &datalen);

    if (status != ERROR_SUCCESS)
    {
        if (status == ERROR_MORE_DATA)
        {
            delete [] prim;
            prim = new wchar_t[datalen];
            status = RegQueryValueEx(hkResult, PRIM_MODULE,
                        0, &dwType, (LPBYTE)prim, &datalen);
        }
    }

    RegCloseKey(hkResult);
    
    HINSTANCE prim_mod =  NULL;

    if ((status == ERROR_SUCCESS) && (_wcsicmp(m_SourceName, prim) != 0))
    {
        CStringW primLog = log + L"\\";
        primLog += prim;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, log, 0,
                KEY_READ, &hkResult) == ERROR_SUCCESS)
        {
            CStringW prim_modname = CEventLogFile::GetFileName(hkResult, MSG_MODULE);

            if (!prim_modname.IsEmpty())
            {
                prim_mod = GetDll(prim_modname);
            }
        }

        RegCloseKey(hkResult);
    }

    delete [] prim;

    log += L'\\';
    log += m_SourceName;
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, log, 0, KEY_READ, &hkResult);

    if (status != ERROR_SUCCESS)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetMessage:API (RegOpenKeyEx) failed with %lx for %s\r\n",
        status, log
        ) ;
)
        return;
    }

    CStringW cat_modname = CEventLogFile::GetFileName(hkResult, CAT_MODULE);

    if (!cat_modname.IsEmpty())
    {
        hMsgModule = GetDll(cat_modname);
        
        if (hMsgModule != NULL)
        {
            if (0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
                    FORMAT_MESSAGE_IGNORE_INSERTS |     // indicate no string inserts
                    FORMAT_MESSAGE_FROM_HMODULE |        // look thru message DLL
					FORMAT_MESSAGE_MAX_WIDTH_MASK ,
                    (LPVOID) hMsgModule,                // handle to message module
                    m_Category,                         // message number to get
                    (ULONG) NULL,                       // specify no language
                    (LPWSTR) &lpBuffer,                 // address for buffer pointer
                    80,                                 // minimum space to allocate
                    NULL))
            {
                m_CategoryString = lpBuffer;
				m_CategoryString.TrimRight();
                LocalFree(lpBuffer);
            }
            else
            {
                DWORD lasterr = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetMessage:API (FormatMessage) failed with %lx\r\n",
        lasterr
        ) ;
)
            }
        }
    }


    if (m_NumStrs != 0)
    {
        CheckInsertionStrings(prim_mod, hkResult);
    }

    CStringW* names;
    DWORD count = CEventLogFile::GetFileNames(hkResult, &names);

    if (count != 0)
    {
        for (int x = 0; x < count; x++)
        {
            hMsgModule = GetDll(names[x]);
            
            if (hMsgModule != NULL)
            {
                if (0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
                        FORMAT_MESSAGE_ARGUMENT_ARRAY |     // indicate an array of string inserts
                        FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
                        (LPVOID) hMsgModule,                // handle to message module
                        m_EvtID,                            // message number to get
                        (ULONG) NULL,                       // specify no language
                        (LPWSTR) &lpBuffer,                 // address for buffer pointer
                        80,                                 // minimum space to allocate
                        (m_NumStrs != 0)?(va_list *)m_InsStrs:NULL))
                {
                    m_Message = lpBuffer;
                    LocalFree(lpBuffer);
                    break;
                }
                else
                {
                    DWORD lasterr = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetMessage:API (FormatMessage) failed with %lx\r\n",
        lasterr
        ) ;
)
                }
            }
        }

        delete [] names;
    }

    RegCloseKey(hkResult);

    //if still no message try primary module...
    if (m_Message.IsEmpty() && (prim_mod != NULL))
    {
        if (0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |    // let api build buffer
                FORMAT_MESSAGE_ARGUMENT_ARRAY |     // indicate an array of string inserts
                FORMAT_MESSAGE_FROM_HMODULE,        // look thru message DLL
                (LPVOID) prim_mod,                  // handle to message module
                m_EvtID,                            // message number to get
                (ULONG) NULL,                       // specify no language
                (LPWSTR) &lpBuffer,                 // address for buffer pointer
                80,                                 // minimum space to allocate
                (m_NumStrs != 0)?(va_list *)m_InsStrs:NULL))
        {
            m_Message = lpBuffer;
            LocalFree(lpBuffer);
        }
        else
        {
            DWORD lasterr = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetMessage:API (FormatMessage) failed with %lx\r\n",
        lasterr
        ) ;
)
        }
    }
}

void CEventlogRecord::SetTimeStr(CStringW& str, DWORD timeVal)
{
    WBEMTime tmpTime((time_t)timeVal);
    BSTR tStr = tmpTime.GetDMTF(TRUE);
    str = tStr;
    SysFreeString(tStr);
}

void CEventlogRecord::SetType(WORD type)
{
    switch (type)
    {
        case 1:
        {
            m_Type = m_TypeArray[0];
			m_EvtType = 1;
            break;
        }
        case 2:
        {
            m_Type = m_TypeArray[1];
			m_EvtType = 2;
            break;
        }
        case 4:
        {
            m_Type = m_TypeArray[2];
            m_EvtType = 3;
			break;
        }
        case 8:
        {
            m_Type = m_TypeArray[3];
			m_EvtType = 4;
            break;
        }
        case 16:
        {
            m_Type = m_TypeArray[4];
			m_EvtType = 5;
            break;
        }
        default:
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetType:Unknown type %lx\r\n",
        (long)type
        ) ;
)
            break;
        }
    }

#if 0
    if (m_Type.IsEmpty())
    {
        wchar_t* buff = m_Type.GetBuffer(20);
        _ultow((ULONG)type, buff, 10);
        m_Type.ReleaseBuffer();
    }
#endif
}

ULONG CEventlogRecord::GetIndex(wchar_t* indexStr, BOOL* bError)
{
    int val = _wtoi(indexStr);
    *bError = FALSE;
    ULONG index = 0;

    switch (val)
    {
        case EVENTLOG_ERROR_TYPE:       //1
        {
            index = 0;
            break;
        }
        case EVENTLOG_WARNING_TYPE:     //2
        {
            index = 1;
            break;
        }
        case EVENTLOG_INFORMATION_TYPE: //4
        {
            index = 2;
            break;
        }
        case EVENTLOG_AUDIT_SUCCESS:    //8
        {
            index = 3;
            break;
        }
        case EVENTLOG_AUDIT_FAILURE:    //16
        {
            index = 4;
            break;
        }
        default:
        {
            *bError = TRUE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::Index:Unknown index %lx\r\n",
        val
        ) ;
)

        }
    }

    return index;
}

BOOL CEventlogRecord::SetEnumArray(IWbemClassObject* pClass, wchar_t* propname, CStringW* strArray, ULONG strArrayLen, GetIndexFunc IndexFunc)
{
    BOOL retVal = FALSE;
    IWbemQualifierSet* pQuals = NULL;

    if (SUCCEEDED(pClass->GetPropertyQualifierSet(propname, &pQuals)))
    {
        VARIANT vVals;

        if (SUCCEEDED(pQuals->Get(EVT_ENUM_QUAL, 0, &vVals, NULL)))
        {
            VARIANT vInds;

            if (SUCCEEDED(pQuals->Get(EVT_MAP_QUAL, 0, &vInds, NULL)))
            {
                if ((vInds.vt == vVals.vt) && (vInds.vt == (VT_BSTR | VT_ARRAY)) && 
                    (SafeArrayGetDim(vInds.parray) == SafeArrayGetDim(vVals.parray)) &&
                    (SafeArrayGetDim(vVals.parray) == 1) && (vInds.parray->rgsabound[0].cElements == strArrayLen) &&
                    (vInds.parray->rgsabound[0].cElements == vVals.parray->rgsabound[0].cElements) )
                {
                    BSTR *strInds = NULL;

                    if (SUCCEEDED(SafeArrayAccessData(vInds.parray, (void **)&strInds)) )
                    {
                        BSTR *strVals = NULL;

                        if (SUCCEEDED(SafeArrayAccessData(vVals.parray, (void **)&strVals)) )
                        {
                            BOOL bErr = FALSE;
                            retVal = TRUE;

                            for (ULONG x = 0; x < strArrayLen; x++)
                            {
                                ULONG index = IndexFunc(strInds[x], &bErr);

                                if (!bErr)
                                {
                                    if (strArray[index].IsEmpty())
                                    {
                                        strArray[index] = strVals[x];
                                    }
                                }
                                else
                                {
                                    retVal = FALSE;
                                    break;
                                }
                            }
                        
                            SafeArrayUnaccessData(vVals.parray);
                        }

                        SafeArrayUnaccessData(vInds.parray);
                    }
                }

                VariantClear(&vInds);
            }

            VariantClear(&vVals);
        }
        else
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetEnumArray:Failed to get enumeration qualifier.\r\n"
        ) ;
)

        }

        pQuals->Release();
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::SetEnumArray:Failed to get qualifier set for enumeration.\r\n"
        ) ;
)

    }
    
    return retVal;
}

BOOL CEventlogRecord::GetInstance()
{
    BSTR path = SysAllocString(NTEVT_CLASS);

    if (m_nspace != NULL)
    {
        if (!WbemTaskObject::GetClassObject(path, FALSE, m_nspace, NULL, &m_pClass ))
        {
            m_pClass = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GetInstance:Failed to get Class object\r\n"
        ) ;
)

        }

        if (!WbemTaskObject::GetClassObject(path, TRUE, m_nspace, NULL, &m_pAClass ))
        {
            m_pAClass = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GetInstance:Failed to get Amended Class object\r\n"
        ) ;
)

        }

        m_nspace->Release();
        m_nspace = NULL;
    }

    
    if (m_pClass != NULL)
    {
        m_pClass->SpawnInstance(0, &m_Obj);

		if (m_pAClass)
		{
			SetEnumArray(m_pAClass, TYPE_PROP,(CStringW*)m_TypeArray, TYPE_ARRAY_LEN, (GetIndexFunc)GetIndex);
	        m_pAClass->Release();
			m_pAClass = NULL;
		}

        m_pClass->Release();
        m_pClass = NULL;
    }

    SysFreeString(path);

    if (m_Obj != NULL)
    {
        return TRUE;
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogRecord::GetInstance:Failed to spawn instance\r\n"
        ) ;
)

    return FALSE;
}

class CDsBindingHandle
{
   public:

   // initally unbound

   CDsBindingHandle()
      :
      m_hDS(0)
   {
   }

   ~CDsBindingHandle()
   {
      DsUnBind(&m_hDS);
   }

   // only re-binds if the dc name differs...

   DWORD Bind(LPCWSTR strDcName);

   // don't call DsUnBind on an instance of this class: you'll only regret
   // it later.  Let the dtor do the unbind.

   operator HANDLE()
   {
      return m_hDS;
   }

   private:

   HANDLE   m_hDS;
   CStringW  m_strDcName;
};

DWORD CDsBindingHandle::Bind(LPCWSTR strDcName)
{
	DWORD err = NO_ERROR;

    if (m_strDcName.CompareNoCase(strDcName) != 0 || !m_hDS)
    {
        if (m_hDS)
        {
            DsUnBind(&m_hDS);
            m_hDS = NULL;
        }

        DWORD err = DsBind(strDcName, 0, &m_hDS);

        if (err == NO_ERROR)
        {
            m_strDcName = strDcName;
        }
        else
        {
            m_hDS = NULL;
        }
    }

    return err;
}

DWORD CEventlogRecord::CrackGuid(HANDLE   handle, LPCWSTR pwzGuid, CStringW  &strResult)
{
    strResult.Empty();

    DS_NAME_RESULT* name_result = 0;
    DWORD err = DsCrackNames(
                      handle,
                      DS_NAME_NO_FLAGS,
                      DS_UNIQUE_ID_NAME,
                      DS_FQDN_1779_NAME,
                      1,                   // only 1 name to crack
                      &pwzGuid,
                      &name_result);

    if (err == NO_ERROR && name_result)
    {
        DS_NAME_RESULT_ITEM* item = name_result->rItems;

        if (item)
        {
            // the API may return success, but each cracked name also carries
            // an error code, which we effectively check by checking the name
            // field for a value.

            if (item->pName)
            {
                strResult = item->pName;
            }
        }

        DsFreeNameResult(name_result);
    }

    return err;
}

CStringW CEventlogRecord::GetMappedGUID(LPCWSTR strDcName, LPCWSTR strGuid)
{
	GUID guid;

    if (RPC_S_OK == UuidFromString((LPWSTR)strGuid, &guid))
    {
        return CStringW();
    }

    CStringW strResult;
    static CDsBindingHandle s_hDS;
    ULONG ulError = NO_ERROR;

    do
    {
        ulError = s_hDS.Bind(strDcName);

        if (ulError != NO_ERROR)
        {
            break;
        }

        DS_SCHEMA_GUID_MAP* guidmap = 0;
        ulError = DsMapSchemaGuids(s_hDS, 1, &guid, &guidmap);
        if (ulError != NO_ERROR)
        {
            break;
        }

        if (guidmap->pName)
        {
            strResult = guidmap->pName;
        }

        DsFreeSchemaGuidMap(guidmap);

        if (strResult.GetLength())
        {
            // the guid mapped as a schema guid: we're done
            break;
        }

        // the guid is not a schema guid.  Proabably an object guid.
        ulError = CrackGuid(s_hDS, strGuid, strResult);
    }
    while (0);

    do
    {
        //
        // If we've got a string from the guid already, we're done.
        //

        if (strResult.GetLength() == 0)
        {
            break;
        }

        //
        // one last try.  in this case, we bind to a GC to try to crack the
        // name.

        static CDsBindingHandle s_hGC;

        // empty string implies GC
        if (s_hGC.Bind(L"") != NO_ERROR)
        {
            break;
        }

        ulError = CrackGuid(s_hGC, strGuid, strResult);
    }
    while (0);

    return strResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtmthd.cpp ===
//***************************************************************************

//

//  NTEVTMTHD.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the ExecMethod implementation

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"


BOOL ExecMethodAsyncEventObject :: ExecMethod ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod\r\n"
        ) ;
)
    if (FAILED(m_ErrorObject.GetWbemStatus()))
    {
        return FALSE;
    }

    BOOL t_Status = ! m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

    if ( t_Status )
    {
        if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , NTEVTLOG_CLASS ) == 0 )
        {
            t_Status = GetClassObject ( m_ParsedObjectPath->m_pClass ) ;

            if ( t_Status )
            {
                IWbemClassObject * tmp = NULL;
                IWbemClassObject * outclass = NULL;
                t_Status = SUCCEEDED(m_ClassObject->GetMethod(m_Method, 0, &tmp, &outclass));

                if (tmp != NULL)
                {
                    tmp->Release();
                }

                if ((t_Status) && (outclass != NULL))
                {
                    t_Status = SUCCEEDED(outclass->SpawnInstance(0, &m_pOutClass));
                    
                    if (!t_Status)
                    {
                        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                        a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                        a_ErrorObject.SetMessage ( L"Unable to spawn result object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:Unable to spawn result object\r\n"
        ) ;
)
                    }
                    else
                    {
                        t_Status =  Dispatch_EventLog ( a_ErrorObject ) ;
                        
                        if ( t_Status )
                        {
                            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                        }
                    }
                    
                    outclass->Release();
                }
                else
                {
                    t_Status = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                    a_ErrorObject.SetMessage ( L"Unable to get result class object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:Unable to get result class object\r\n"
        ) ;
)
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                a_ErrorObject.SetMessage ( L"Class definition not found" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:Class definition not found\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_CLASS ) ;
            a_ErrorObject.SetMessage ( L"Dynamic NT Eventlog Provider does not methods support on this class" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:Dynamic NT Eventlog Provider does not methods support on this class\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Unable to parse object path" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:Unable to parse object path %s\r\n",
        m_ObjectPath
        ) ;
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod:returning with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}


BOOL ExecMethodAsyncEventObject :: Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: Dispatch_EventLog\r\n"
        ) ;
)
    if (m_ParsedObjectPath->m_dwNumKeys != 1)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }

    BOOL t_Status ;
    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;

    if ( t_Key1 )
    {
        if ((t_Key1->m_pName == NULL) || _wcsicmp ( t_Key1->m_pName , PROP_NAME ) == 0 )
        {
            if ( t_Key1->m_vValue.vt == VT_BSTR )
            {
                t_Status = ExecMethod_EventLog ( a_ErrorObject , t_Key1 ) ;
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: Dispatch_EventLog: Key value has incorrect type\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value has incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: Dispatch_EventLog: Key value has incorrect name\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key value" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: Dispatch_EventLog:Failed to get key value\r\n"
        ) ;
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: Dispatch_EventLog:returning with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

BOOL ExecMethodAsyncEventObject :: ExecMethod_EventLog ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey) 
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog\r\n"
        ) ;
)
    BOOL retVal = TRUE;
    
    VARIANT v;
    VariantInit(&v);
    CIMTYPE cT = VT_NULL;

    if (m_InParamObject != NULL)
    {
        HRESULT hr =  m_InParamObject->Get(METHOD_PARAM, 0, &v, &cT, NULL);

        if (SUCCEEDED(hr))
        {
            if (cT != CIM_STRING)
            {
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"ArchiveFileName parameter should be a string" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:ArchiveFileName parameter should be a string\r\n"
        ) ;
)
            }
        }
        else
        {
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"ArchiveFileName parameter not found in supplied InParam object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:ArchiveFileName parameter not found in supplied InParam object\r\n"
        ) ;
)
        }
    }

    DWORD x = ERROR_SUCCESS;

    if (retVal)
    {
        if (_wcsicmp(m_Method, L"ClearEventlog") == 0)
        {
            wchar_t* param = NULL;

            if ((v.vt != VT_BSTR) && (v.vt != VT_NULL))
            {
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"ArchiveFileName parameter not found in supplied InParam object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:ArchiveFileName parameter not found in supplied InParam object\r\n"
        ) ;
)
            }
            else if (v.vt == VT_BSTR)
            {
                param =  v.bstrVal;
            }

            if (retVal)
            {
                CStringW log = CEventLogFile::GetLogName((const wchar_t*)a_FileKey->m_vValue.bstrVal);

                if (log.IsEmpty())
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                    a_ErrorObject.SetMessage ( L"Could not find specified Eventlog" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:Could not find specified Eventlog\r\n"
        ) ;
)
                }
                else
                {
                    CEventlogFileAttributes evtLog(log);
                    x = evtLog.EventLogOperation(param, TRUE, a_ErrorObject, retVal);
                }
            }
        }
        else if (_wcsicmp(m_Method, L"BackupEventlog") == 0)
        {
            if (v.vt != VT_BSTR)
            {
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"ArchiveFileName parameter not found in supplied InParam object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:ArchiveFileName parameter not found in supplied InParam object\r\n"
        ) ;
)
            }
            else
            {
                CStringW log = CEventLogFile::GetLogName((const wchar_t*)a_FileKey->m_vValue.bstrVal);

                if (log.IsEmpty())
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                    a_ErrorObject.SetMessage ( L"Could not find specified Eventlog" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:Could not find specified Eventlog\r\n"
        ) ;
)
                }
                else
                {
                    CEventlogFileAttributes evtLog(log);
                    x = evtLog.EventLogOperation(v.bstrVal, FALSE, a_ErrorObject, retVal);
                }
            }
        }
        else
        {
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Unknown method name supplied." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:Unknown method name supplied.\r\n"
        ) ;
)
        }
    }

    if (x != ERROR_SUCCESS)
    {
        wchar_t* buff = NULL;

        if (0 == FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL, x, 0, (LPWSTR) &buff, 80, NULL))
        {
            DWORD dwErr = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:Calling underlying Eventlog API failed.\r\n"
        ) ;
)
        }
        else
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:%s\r\n",
        buff
        ) ;
)
            LocalFree(buff);
        }
    }

    VariantClear(&v);

    if (retVal)
    {
        // set out-param
        VariantInit(&v);
        v.vt = VT_I4;
        v.lVal = x;
        HRESULT hr = m_pOutClass->Put(METHOD_RESULT_PARAM, 0, &v, 0);

        if (FAILED(hr))
        {
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
            a_ErrorObject.SetMessage ( L"Unable to put OutParam value." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:Unable to put OutParam value.\r\n"
        ) ;
)
            m_pOutClass->Release();
            m_pOutClass = NULL;
        }
        else
        {
            m_bIndicateOutParam = TRUE;
        }

        VariantClear(&v);
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecMethodAsyncEventObject :: ExecMethod_EventLog:returning with %lx\r\n",
        retVal
        ) ;
)

    return retVal;
}

ExecMethodAsyncEventObject :: ExecMethodAsyncEventObject (

        CImpNTEvtProv *a_Provider , 
        wchar_t *a_ObjectPath ,
        wchar_t *a_MethodName,
        ULONG a_Flag ,
        IWbemClassObject *a_InParams ,      
        IWbemObjectSink *a_NotificationHandler ,
        IWbemContext *pCtx

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_Flag , pCtx ) ,
    m_Class ( NULL ), m_InParamObject( NULL ), m_bIndicateOutParam ( FALSE ),
    m_pOutClass ( NULL ), m_ParsedObjectPath ( NULL )
{
    m_InParamObject = a_InParams ;

    if (m_InParamObject != NULL)
    {
        m_InParamObject->AddRef();
    }

    m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
    m_Method = UnicodeStringDuplicate ( a_MethodName ) ;
}

ExecMethodAsyncEventObject :: ~ExecMethodAsyncEventObject () 
{
    if (m_pOutClass != NULL)
    {
        if ( m_bIndicateOutParam && (SUCCEEDED(m_ErrorObject.GetWbemStatus ())) )
        {
            HRESULT t_Result = m_NotificationHandler->Indicate(1, &m_pOutClass);
        }

        m_pOutClass->Release();
    }

    if (m_InParamObject != NULL)
    {
        m_InParamObject->Release();
    }

    delete [] m_ObjectPath ;
    delete [] m_Method ;
    delete m_ParsedObjectPath;

    // Get Status object
    IWbemClassObject *t_NotifyStatus = NULL ;
    BOOL t_Status = TRUE;
    
    if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
    {
        t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
    }

    if ( t_Status )
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
        
        if (t_NotifyStatus)
        {
            t_NotifyStatus->Release () ;
        }
    }
    else
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
    }

}


void ExecMethodAsyncEventObject :: Process () 
{
    ExecMethod ( m_ErrorObject ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtlogf.cpp ===
//***************************************************************************

//

//  NTEVTLOGF.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the Eventlog classes

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

#include <time.h>
#include <io.h>
#include <wbemtime.h>

CEventlogFileAttributes::CEventlogFileAttributes(const wchar_t* log)
: m_logname(log)
{
    m_retention = 0;
    m_fileSz = 0;
    m_sources.SetSize(0, 10);
}


CEventlogFileAttributes::~CEventlogFileAttributes()
{
    LONG count = m_sources.GetSize();

    if (count > 0)
    {
        for (LONG x = 0; x < count; x++)
        {
            delete m_sources[x];
        }
        
        m_sources.RemoveAll();
    }
}

DWORD CEventlogFileAttributes::EventLogOperation (const wchar_t* archive, BOOL bClear,
                                                  WbemProvErrorObject &a_ErrorObject, BOOL &bSuccess)
{
    DWORD retVal = ERROR_SUCCESS;
    HANDLE hEventLog = OpenEventLog(NULL, m_logname);

    if (hEventLog == NULL)
    {
        if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
        {
            CEventLogFile::SetSecurityLogPrivilege();
            hEventLog = OpenEventLog(NULL, m_logname);
        }
    }

    if (hEventLog == NULL)
    {
        retVal = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::EventLogOperation:Failed to OpenEventLog %s with error %lx.\r\n",
        m_logname, retVal
        ) ;
)
        if (retVal == ERROR_PRIVILEGE_NOT_HELD)
        {
            retVal = 0;
            bSuccess = FALSE;
            a_ErrorObject.SetWbemStatus ( WBEM_E_ACCESS_DENIED ) ;
            a_ErrorObject.SetMessage ( L"Failed to open the logfile" ) ;
            a_ErrorObject.SetPrivilegeFailed();
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();

            if (!bClear)
            {
                a_ErrorObject.SetBackupPrivRequired();
            }
        }
    }
    else
    {
        if (bClear)
        {
            if (!ClearEventLog(hEventLog, archive))
            {
                retVal = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::EventLogOperation:Failed to ClearEventLog %s with error %lx.\r\n",
        m_logname, retVal
        ) ;
)
            }
        }
        else
        {
            if (archive == NULL)
            {
                retVal = ERROR_INVALID_PARAMETER;
            }
            else if (!BackupEventLog(hEventLog, archive))
            {
                retVal = GetLastError();

                if (retVal == ERROR_PRIVILEGE_NOT_HELD)
                {
                    retVal = 0;
                    CEventLogFile::SetSecurityLogPrivilege(FALSE, SE_BACKUP_NAME);

                    if (!BackupEventLog(hEventLog, archive))
                    {
                        retVal = GetLastError();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::EventLogOperation:Failed even after privilege set to BackupEventLog %s with error %lx.\r\n",
        m_logname, retVal
        ) ;
)
                        if (retVal == ERROR_PRIVILEGE_NOT_HELD)
                        {
                            retVal = 0;
                            bSuccess = FALSE;
                            a_ErrorObject.SetWbemStatus ( WBEM_E_ACCESS_DENIED ) ;
                            a_ErrorObject.SetMessage ( L"Opened the logfile but failed to back it up, privilege error" ) ;
                            a_ErrorObject.SetPrivilegeFailed();
                            a_ErrorObject.SetBackupPrivRequired();
                            a_ErrorObject.SetBackupPrivFailed();
                        }

                    }
                    else
                    {
                    DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::EventLogOperation:After privilege set, BackupEventLog %s succeeded.\r\n",
        m_logname
        ) ;
)
                    }
                }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::EventLogOperation:Failed to BackupEventLog %s with error %lx.\r\n",
        m_logname, retVal
        ) ;
)
            }
        }

        CloseEventLog(hEventLog);
    }

    return retVal;
}

BOOL CEventlogFileAttributes::GenerateInstance(IWbemClassObject* pClassObj, IWbemClassObject* pAClassObj, IWbemClassObject** ppInst)
{
    if (pClassObj == NULL)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::GenerateInstance:Invalid parameter - Return FALSE\r\n"
        ) ;
)
        return FALSE;
    }

    if (ReadRegistry() != ERROR_SUCCESS)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::GenerateInstance:Failed to read registry values - Return FALSE\r\n"
        ) ;
)
        return FALSE;
    }

    HRESULT hr = pClassObj->SpawnInstance(0, ppInst);

    if (FAILED(hr))
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::GenerateInstance:Failed to spawn instance - Return FALSE\r\n"
        ) ;
)
        return FALSE;
    }

    //set the key properties, they are all in the super class
    if (!SetSuperClassProperties(*ppInst))
    {
        //can't set the key, just return
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::GenerateInstance:Failed to set key values - Return FALSE\r\n"
        ) ;
)
        
        (*ppInst)->Release();
        return FALSE;
    }

    //set the evtlog properties...
    VARIANT v;
    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = m_logname.AllocSysString();
    hr = (*ppInst)->Put(PROP_LOGNAME, 0, &v, 0);
    VariantClear(&v); // will call free v.bstrVal

    VariantInit(&v);
    v.vt = VT_I4;
    v.lVal = m_fileSz;
    hr = (*ppInst)->Put(PROP_MAXSZ, 0, &v, 0);
    VariantClear(&v);

    VariantInit(&v);
    v.vt = VT_I4;

    if ((m_retention > 0) && (m_retention < EVT_NEVER_AGE))
    {
        //turn into days
        v.lVal = m_retention/EVT_UNITS_FROM_DAYS;

        if (v.lVal > MAX_EVT_AGE)
        {
            v.lVal = MAX_EVT_AGE;
        }
    }
    else
    {
        v.lVal = m_retention;
    }

    hr = (*ppInst)->Put(PROP_RETENTION, 0, &v, 0);

	if (pAClassObj)
	{
		SetRetentionStr(pAClassObj, *ppInst, (DWORD)v.lVal);
	}

    VariantClear(&v);

    HANDLE hEventLog = OpenEventLog(NULL, m_logname);

    if (hEventLog == NULL)
    {
        if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
        {
            CEventLogFile::SetSecurityLogPrivilege();
            hEventLog = OpenEventLog(NULL, m_logname);
        }
    }

    if (hEventLog != NULL)
    {
        DWORD num_recs = 0;
        
        if (GetNumberOfEventLogRecords(hEventLog, &num_recs))
        {
            VariantInit(&v);
            v.vt = VT_I4;
            v.lVal = num_recs;
            hr = (*ppInst)->Put(PROP_NUMRECS, 0, &v, 0);
            VariantClear(&v);
        }
        
        CloseEventLog(hEventLog);
    }

    LONG count = m_sources.GetSize();

    if (count > 0)
    {
        SAFEARRAYBOUND rgsabound[1];
        SAFEARRAY* psa = NULL;
        BSTR* pBstr = NULL;
        rgsabound[0].lLbound = 0;
        VariantInit(&v);
        rgsabound[0].cElements = count;
        psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);

        if (NULL != psa)
        {
            if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pBstr)))
            {
                for (LONG x = 0; x < count; x++)
                {
                    pBstr[x] = m_sources[x]->AllocSysString();
                    delete m_sources[x];
					m_sources[x] = NULL;
                }
                
                m_sources.RemoveAll();
                SafeArrayUnaccessData(psa);
                v.vt = VT_ARRAY|VT_BSTR;
                v.parray = psa;
                hr = (*ppInst)->Put(PROP_SOURCES, 0, &v, 0);
            }
        }

        VariantClear(&v);
    }

    return TRUE;
}

ULONG CEventlogFileAttributes::GetIndex(wchar_t* indexStr, BOOL* bError)
{
#if 0
    __int64 val = _wtoi64(indexStr);
#else
    int val = _wtoi(indexStr);
#endif
    *bError = FALSE;
    ULONG index = 0;

    switch (val)
    {
        case 0:     //Always overwrite
        {
            index = 0;
            break;
        }
        case 1:     //1-365
        {
            index = 1;
            break;
        }
        case EVT_NEVER_AGE: //0xffffffff
        {
            index = 2;
            break;
        }
        default:
        {
            *bError = TRUE;
        }
    }

    return index;
}

void CEventlogFileAttributes::SetRetentionStr(IWbemClassObject* pClassObj, IWbemClassObject* pInstObj, DWORD dwVal)
{
    CStringW strRetentionArray[RETENTION_ARRAY_LEN];

    if (CEventlogRecord::SetEnumArray(pClassObj, PROP_RETENTION_STR,(CStringW*) strRetentionArray,
                                    RETENTION_ARRAY_LEN, (GetIndexFunc)GetIndex))
    {
        BSTR retStr = NULL;

        if (dwVal == 0)
        {
            retStr = strRetentionArray[0].AllocSysString();
        }
        else if (dwVal == EVT_NEVER_AGE)
        {
            retStr = strRetentionArray[2].AllocSysString();
        }
        else
        {
            retStr = strRetentionArray[1].AllocSysString();
        }

        if (retStr != NULL)
        {
            VARIANT v;
            VariantInit (&v);
            v.vt = VT_BSTR;
            v.bstrVal = retStr;
            HRESULT hr = pInstObj->Put(PROP_RETENTION_STR, 0, &v, 0);
            VariantClear(&v);
        }
    }
}

BOOL CEventlogFileAttributes::SetSuperClassProperties(IWbemClassObject* pInst)
{
    //failure to set any key property
    //is an error, return FALSE!!

    VARIANT v;

    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = m_logpath.AllocSysString();
    HRESULT hr = pInst->Put(PROP_NAME, 0, &v, 0);
    VariantClear(&v);

    if (FAILED(hr))
    {
        return FALSE;
    }

    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(VAL_FS_CRE_CLASS);
    hr = pInst->Put(PROP_FS_CRE_CLASS, 0, &v, 0);
    VariantClear(&v);

    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(NTEVTLOG_CLASS);
    hr = pInst->Put(PROP_CRE_CLASS, 0, &v, 0);
    VariantClear(&v);

    VariantInit(&v);
    v.vt = VT_BSTR;
    v.bstrVal = SysAllocString(COMP_CLASS);
    hr = pInst->Put(PROP_CS_CRE_CLASS, 0, &v, 0);
    VariantClear(&v);

    return TRUE;
}

DWORD CEventlogFileAttributes::UpdateRegistry(IWbemClassObject* pInst)
{
    if (NULL == pInst)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //get the data to be written
    VARIANT v;
    HRESULT hr = pInst->Get(PROP_RETENTION, 0, &v,NULL, NULL);

    if (SUCCEEDED(hr))
    {
        m_retention = (DWORD)v.lVal;
        VariantClear(&v);

        if ((m_retention > MAX_EVT_AGE) && (m_retention < EVT_NEVER_AGE))
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Retention Data not in range\r\n"
        ) ;
)
            return ERROR_INVALID_DATA;
        }

        if ((m_retention > 0) && (m_retention < EVT_NEVER_AGE))
        {
            m_retention = m_retention * EVT_UNITS_FROM_DAYS;
        }
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Failed to get retention value from instance\r\n"
        ) ;
)

        return (DWORD)hr;
    }

    hr = pInst->Get(PROP_MAXSZ, 0, &v,NULL, NULL);

    if (SUCCEEDED(hr))
    {
        m_fileSz = (DWORD)v.lVal;
        VariantClear(&v);

        if (m_fileSz < FILE_CHUNK_SZ)
        {
            m_fileSz = FILE_CHUNK_SZ;
        }
        else if (m_fileSz > MAX_EVT_LOG_SZ)
        {
            m_fileSz = MAX_EVT_LOG_SZ;
        }
        else
        {
            DWORD rem = m_fileSz % FILE_CHUNK_SZ;

            if (rem != 0)
            {
                //need to round up to nearest file chunk size
                DWORD x = m_fileSz / FILE_CHUNK_SZ;
                m_fileSz = (++x) * FILE_CHUNK_SZ;
            }
        }
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Failed to get MaxFileSize value from instance\r\n"
        ) ;
)
        return (DWORD)hr;
    }

    DWORD retVal;
    CStringW strKey(EVENTLOG_BASE);
    strKey += CStringW(L'\\');
    strKey += m_logname;

    HKEY hkResult;
    //open the logfile's key for setting values
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            strKey, 0,
                            KEY_SET_VALUE,
                            &hkResult);
    
    if (status != ERROR_SUCCESS)
    {
        // indicate error
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Open registry to set new values. Error %lx\r\n",
        status
        ) ;
)
        return status;
    }

    //set the values we read in...
    status = RegSetValueEx(hkResult,
                            EVTLOG_REG_MAXSZ_VALUE, 0, REG_DWORD,
                            (CONST BYTE *) &m_fileSz, sizeof(DWORD));

    if (status != ERROR_SUCCESS)
    {
        // indicate error
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Failed to set new size. Error %lx\r\n",
        status
        ) ;
)
        retVal = status;
    }
    else
    {
        retVal =(DWORD) RegSetValueEx(hkResult,
                                EVTLOG_REG_RETENTION_VALUE, 0, REG_DWORD,
                                (CONST BYTE *) &m_retention, sizeof(DWORD));
        
        if (retVal != ERROR_SUCCESS)
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::UpdateRegistry:Failed to set new retention policy. Error %lx\r\n",
        retVal
        ) ;
)
        }
    }

    RegCloseKey(hkResult);
    return retVal;
}


DWORD CEventlogFileAttributes::ReadRegistry()
{
    DWORD retVal;
    CStringW strKey(EVENTLOG_BASE);
    strKey += CStringW(L'\\');
    strKey += m_logname;
    HKEY hkResult;

    //open the logfile's key for read
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            strKey, 0,
                            KEY_QUERY_VALUE,
                            &hkResult);
    
    if (status != ERROR_SUCCESS)
    {
        // indicate error
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to open registry. Error %lx\r\n",
        status
        ) ;
)

        retVal = status;
    }
    else
    {
        //first get the file value
        m_logpath = CEventLogFile::GetFileName(hkResult);
        DWORD datalen;
        DWORD dwType;
        wchar_t* data;

        if (m_logpath.IsEmpty())
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to resolve log file name\r\n"
        ) ;
)
            retVal = ERROR_INVALID_DATA;
        }
        else
        {
            datalen = sizeof(m_fileSz);
            status = RegQueryValueEx(hkResult, EVTLOG_REG_MAXSZ_VALUE,
                        0, &dwType, (LPBYTE) &m_fileSz, &datalen);

            if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD))
            {
                if(dwType != REG_DWORD)
                {
                    retVal = ERROR_INVALID_DATA;
                }
                else
                {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to read size. Error %lx\r\n",
        status
        ) ;
)
                    retVal = status;
                }
            }
            else
            {
                datalen = sizeof(m_retention);
                status = RegQueryValueEx(hkResult, EVTLOG_REG_RETENTION_VALUE,
                            0, &dwType, (LPBYTE) &m_retention, &datalen);

                if ((status != ERROR_SUCCESS) || (dwType != REG_DWORD))
                {
                    if(dwType != REG_DWORD)
                    {
                        retVal = ERROR_INVALID_DATA;
                    }
                    else
                    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to read retention. Error %lx\r\n",
        status
        ) ;
)
                        retVal = status;
                    }
                }
                else
                {
                    retVal = 0;
                }
            }
        }

        if (retVal == 0)
        {
            data = new wchar_t[MAX_PATH + 1];
            datalen = (MAX_PATH + 1) * sizeof(wchar_t);
            status = RegQueryValueEx(hkResult, EVTLOG_REG_SOURCES_VALUE,
                        0, &dwType, (LPBYTE) data, &datalen);
            
            if (((status == ERROR_SUCCESS) || (status == ERROR_MORE_DATA)) &&
                (dwType == REG_MULTI_SZ))
            {
                if (status == ERROR_MORE_DATA)
                {
                    delete [] data;
                    data = new wchar_t[datalen];
                    status = RegQueryValueEx(hkResult, EVTLOG_REG_SOURCES_VALUE,
                                0, &dwType, (LPBYTE) data, &datalen);
                }

                if (status == ERROR_SUCCESS)
                {
                    wchar_t* tmp = data;
                    int x = 0;

                    while (*tmp != L'\0')
                    {
                        CStringW* tmpstr = new CStringW(tmp);
                        m_sources.SetAtGrow(x++, tmpstr);
                        tmp += wcslen(tmp) + 1;
                    }
                }
                else
                {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to read sources. Error %lx\r\n",
        status
        ) ;
)
                }
            }
            else
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventlogFileAttributes::ReadRegistry:Failed to read sources. Error %lx\r\n",
        status
        ) ;
)

            }

            delete [] data;
        }
        
        RegCloseKey(hkResult);
    }

    return retVal;
}

CEventLogFile::CEventLogFile(const WCHAR* logname, BOOL bVerify) : m_hEvtLog(NULL), m_BuffLen (0)
{
    m_Reason = ERROR_SUCCESS;
    m_EvtLogName = logname;
    m_bValid = FALSE;
    m_bBuffer = FALSE;
    m_hEvtLog = NULL;
    m_Buffer = NULL;

	if (bVerify)
	{
		if (logname != NULL)
		{
			wchar_t* buff = new wchar_t[wcslen(EVENTLOG_BASE) + wcslen(logname) + 2];
			wcscpy(buff, EVENTLOG_BASE);
			wcscat(buff, L"\\");
			wcscat(buff, logname);

			HKEY hkResult = NULL;
			m_Reason = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
									buff, 0,
									KEY_READ,
									&hkResult);

			if (m_Reason == ERROR_SUCCESS)
			{
				if (hkResult != NULL)
				{
					RegCloseKey(hkResult);
					hkResult = NULL;
				}
				else
				{
					m_Reason = ERROR_FILE_NOT_FOUND;
				}
			}

			delete [] buff;
			buff = NULL;
		}
		else
		{
			m_Reason = ERROR_FILE_NOT_FOUND;
		}
	}

	if (m_Reason == ERROR_SUCCESS)
	{
		m_hEvtLog = OpenEventLog(NULL, m_EvtLogName);

		if (m_hEvtLog == NULL)
		{
			if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
			{
				SetSecurityLogPrivilege();
				m_hEvtLog = OpenEventLog(NULL, m_EvtLogName);
			}
		}

		m_bValid = (NULL != m_hEvtLog);

		if (!m_bValid)
		{
			m_Reason = GetLastError();
		}
	}
}

CEventLogFile::~CEventLogFile()
{
    if (0 != m_BuffLen)
    {
        delete [] m_Buffer;
    }

    if (NULL != m_hEvtLog)
    {
        CloseEventLog(m_hEvtLog);
    }
}

BOOL CEventLogFile::QueryRegForFileName(HKEY hk_Log, const wchar_t* valname, wchar_t** res, DWORD* dwType)
{
    BOOL retVal = FALSE;
    *res = new wchar_t[MAX_PATH + 1];
    DWORD datalen = (MAX_PATH + 1) * sizeof(wchar_t);
    LONG status = RegQueryValueEx(hk_Log, valname,
                        0, dwType, (LPBYTE)(*res), &datalen);

    if (status != ERROR_SUCCESS)
    {
        if (status == ERROR_MORE_DATA)
        {
            delete [] *res;
            *res = new wchar_t[datalen];
            status = RegQueryValueEx(hk_Log, valname,
                        0, dwType, (LPBYTE)(*res), &datalen);
        }
        else
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::QueryRegForFileName:Failed to get %s value\r\n",
        valname
        ) ;
)
        }
    }

    if ((status == ERROR_SUCCESS) && ((*dwType == REG_EXPAND_SZ) || (*dwType == REG_SZ)))
    {
        retVal = TRUE;
    }
    else
    {
        delete [] *res;
        *res = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::QueryRegForFileName:Failed\r\n"
        ) ;
)

    }

    return retVal;
}

CStringW CEventLogFile::ExpandFileName(const wchar_t* filepath)
{
    CStringW retVal;
    DWORD datalen =  wcslen(filepath) * 2;
    wchar_t* fullpath = new wchar_t[datalen];
    DWORD cbExpand = ExpandEnvironmentStrings(filepath, fullpath, datalen);

    if (cbExpand > datalen)
    {
        cbExpand++; //just in case they don't include terminating null.
        delete [] fullpath;
        fullpath = new wchar_t[cbExpand];
        cbExpand = ExpandEnvironmentStrings(filepath, fullpath, cbExpand);
    }

    if (cbExpand == 0)
    {
        delete [] fullpath;
    }
    else
    {
        retVal = fullpath;
        delete [] fullpath;
    }
    
    return retVal;
}

DWORD CEventLogFile::GetFileNames(HKEY hk_Log, CStringW** names, const wchar_t* valname)
{
    DWORD retVal = 0;
    wchar_t* path = NULL;
    DWORD dwType;

    if (QueryRegForFileName(hk_Log, valname, &path, &dwType) && (path != NULL))
    {
        //got the comma or semi-colon separated list
        //need to separate it into
        retVal = 1;
        wchar_t* tmp = wcspbrk(path, L",;");

        while (tmp != NULL)
        {
            //don't count chars at start of string!
            if (tmp != path)
            {
                retVal++;
            }

            while ((*tmp == L',') || (*tmp == L';'))
            {
                *tmp = L'\0';
                tmp++;
            }

            tmp = wcspbrk(tmp, L",;");
        }

        *names = new CStringW[retVal];
        tmp = path;

        for (int x = 0; x < retVal; x++)
        {
            while (*tmp == L'\0')
            {
                tmp++;
            }

            (*names)[x] = ExpandFileName(tmp);
            tmp += wcslen(tmp);
        }

        delete [] path;
    }

    return retVal;
}

CStringW CEventLogFile::GetFileName(HKEY hk_Log, const wchar_t* valname)
{
    CStringW retVal;
    wchar_t* path = NULL;
    DWORD dwType;

    if (QueryRegForFileName(hk_Log, valname, &path, &dwType) && (path != NULL))
    {
        if (dwType == REG_EXPAND_SZ)
        {
            retVal = ExpandFileName(path);
        }
        else
        {
            retVal =  path;
        }

        delete [] path;
    }

    return retVal;
}

BOOL CEventLogFile::SetSecurityLogPrivilege(BOOL bProcess, LPCWSTR privName)
{
    BOOL bResult = TRUE;

    //only need the security mutex if not NT5
    DWORD dwVersion = GetVersion();

    if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
    {
        bResult = ObtainedSerialAccess(CNTEventProvider::g_secMutex);
    }

    if (bResult)
    {
        HANDLE hToken = NULL;

        if (bProcess)
        {
            bResult = OpenProcessToken(GetCurrentProcess(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                &hToken);

            if ( ! bResult )
            {
                DWORD t_LastError = GetLastError () ;

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::SetSecurityLogPrivilege:Failed to open process token: Error %lx\r\n",
        t_LastError 
        ) ;
)
            }

            HANDLE hThreadToken = 0 ;
            bResult = OpenThreadToken(GetCurrentThread(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_IMPERSONATE |TOKEN_QUERY,
                                TRUE, &hToken);


            if ( bResult)
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::SetSecurityLogPrivilege:Thread Token Present\r\n"
        ) ;
)

            }
            else
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::SetSecurityLogPrivilege:Thread Token Missing\r\n"
        ) ;
)

            }
            
            CloseHandle ( hThreadToken ) ;
        }
        else
        {
            bResult = OpenThreadToken(GetCurrentThread(),
                                TOKEN_ADJUST_PRIVILEGES | TOKEN_IMPERSONATE |TOKEN_QUERY,
                                TRUE, &hToken);
        }

        if (bResult)
        {
            // Enable Security Privilege...
            LUID Luid;
            bResult = LookupPrivilegeValue(NULL, privName, &Luid);
         
            if (bResult)
            {   
                TOKEN_PRIVILEGES newPriv;
                newPriv.PrivilegeCount = 1;
                newPriv.Privileges[0].Luid = Luid;
                newPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                bResult = AdjustTokenPrivileges(hToken,     // TokenHandle
                                                FALSE,      // DisableAllPrivileges
                                                &newPriv,   // NewState (OPTIONAL)
                                                NULL,   // BufferLength
                                                NULL,       // PreviousState
                                                NULL);  // ReturnLength

                DWORD dwErr = GetLastError();

                if (dwErr != ERROR_SUCCESS)
                {
                    bResult = FALSE;
                }
            }       
                    
            if (hToken != NULL)
            {
                CloseHandle( hToken );
            }
        }
    
        if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
        {
            ReleaseSerialAccess(CNTEventProvider::g_secMutex);
        }
    }

    return bResult;
}

CStringW CEventLogFile::GetLogName(const WCHAR* file_name)
{
    // open registry for log names
    CStringW retVal;

    if (file_name == NULL)
    {
        return retVal;
    }

    HKEY hkResult;
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            EVENTLOG_BASE, 0,
                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                            &hkResult);

    if (status != ERROR_SUCCESS)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::GetLogName:Failed to open registry: Error %lx\r\n",
        status
        ) ;
)
        return retVal;
    }

    DWORD iValue = 0;
    WCHAR t_logname[MAX_PATH+1];
    DWORD t_lognameSize = MAX_PATH;

    // read all entries under this key to find all logfiles...
    while ((status = RegEnumKey(hkResult, iValue, t_logname, t_lognameSize)) != ERROR_NO_MORE_ITEMS)
    {
        // if error during read
        if (status != ERROR_SUCCESS)
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::GetLogName:Failed while enumerating registry: Error %lx\r\n",
        status
        ) ;
)
            // indicate error
            break;
        }

        //open logfile key
        HKEY hkLog;

        if (ERROR_SUCCESS == RegOpenKeyEx(hkResult, t_logname, 0, KEY_QUERY_VALUE, &hkLog))
        {
            CStringW fname = GetFileName(hkLog);
            RegCloseKey(hkLog);

            if (!fname.IsEmpty() && (0 == _wcsicmp(fname, file_name)))
            {
                retVal = t_logname;
                break;
            }
        }

        // read next parameter
        iValue++;

    } // end while

    RegCloseKey(hkResult);
    return retVal;
}

void CEventLogFile::RefreshHandle()
{
    m_LogLock.Lock();

    if (NULL != m_hEvtLog)
    {
        CloseEventLog(m_hEvtLog);
    }
    
    m_hEvtLog = OpenEventLog(NULL, m_EvtLogName);

    if (m_hEvtLog == NULL)
    {
        if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
        {
            SetSecurityLogPrivilege();
            m_hEvtLog = OpenEventLog(NULL, m_EvtLogName);
        }
    }

    m_LogLock.Unlock();
     
    if (NULL != m_hEvtLog)
    {
        m_bValid = TRUE;
        m_Reason = 0;
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::RefreshHandle:Invalid log\r\n"
        ) ;
)
        m_bValid = FALSE;
        m_Reason = GetLastError();
    }
}

DWORD CEventLogFile::FindOldEvent(DWORD evtID, const wchar_t* source, DWORD* recID, time_t offset)
{
    DWORD dwRet = 0;
    time_t timeVal;

    if (offset > 0)
    {
        time(&timeVal);
        timeVal -= offset;
    }

    DWORD dwEventSize = 0;
    DWORD lastErr = ReadRecord(0, &dwEventSize, TRUE);

    if (0 != lastErr)
    {
        if (lastErr != ERROR_HANDLE_EOF)
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::FindOldEvent:Log no longer valid\r\n"
        ) ;
)

            m_bValid = FALSE;
        }
    }
    else
    {
        while (TRUE)
        {
            if (lastErr != 0)
            {
                if (lastErr != ERROR_HANDLE_EOF)
                {
                    m_bValid = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::FindOldEvent:Log no longer valid\r\n"
        ) ;
)
                }

                break;
            }
            else
            {
                PEVENTLOGRECORD EventBuffer = (PEVENTLOGRECORD)m_Buffer;
                BOOL bDone = FALSE;

                while (dwEventSize != 0)
                {
                    //eventid and sourcename identify event
                    if ((source != NULL) && (evtID == EventBuffer->EventID) && 
                        (0 == _wcsicmp(source,
                                (const wchar_t*)((UCHAR*)EventBuffer + sizeof(EVENTLOGRECORD))
                                )
                        )
                    )
                    {
                        if (offset > 0)
                        {
                            if (EventBuffer->TimeWritten < timeVal)
                            {
                                bDone = TRUE;
                                break;
                            }
                            
                        }

                        dwRet = EventBuffer->TimeWritten;

                        if (recID != NULL)
                        {
                            *recID = EventBuffer->RecordNumber;
                        }

                        bDone = TRUE;
                        break;
                    }
                    else
                    {
                        if (offset > 0)
                        {
                            if (EventBuffer->TimeWritten < timeVal)
                            {
                                bDone = TRUE;
                                break;
                            }
                            else
                            {
                                if (recID != NULL)
                                {
                                    *recID = EventBuffer->RecordNumber;
                                }
                            }
                        }
                    }
                    
                    // drop by length of this record and point to next record
                    dwEventSize -= EventBuffer->Length;
                    EventBuffer = (PEVENTLOGRECORD) ((UCHAR*) EventBuffer + EventBuffer->Length);
                }

                if (bDone)
                {
                    break;
                }
                else
                {
                    lastErr = ReadRecord(0, &dwEventSize, TRUE);
                }
            }
        }
    }
    
    return dwRet;
}

BOOL CEventLogFile::GetLastRecordID(DWORD& rec, DWORD& numrecs)
{
    rec = 0;
    numrecs = 0;
    m_LogLock.Lock();

    if (!GetNumberOfEventLogRecords(m_hEvtLog, &numrecs))
    {
        m_LogLock.Unlock();
        return FALSE;
    }

    if (numrecs != 0)
    {
        DWORD last_rec = 0;

        if (!GetOldestEventLogRecord(m_hEvtLog, &last_rec))
        {
            m_LogLock.Unlock();
            return FALSE;
        }
		
		if (0xFFFFFFFF - last_rec >= numrecs)
		{
			rec = numrecs + last_rec - 1;
		}
		else
		{
			//we have to guard the overflow...
			rec = numrecs - (0xFFFFFFFF - last_rec) - 1;
		}
    }
    
    m_LogLock.Unlock();
    return TRUE;
}

DWORD CEventLogFile::ReadRecord(DWORD recID, DWORD* dwBytesRead, BOOL b_Back)
{
    if (NULL != dwBytesRead)
    {
        *dwBytesRead = 0;
    }

    DWORD dwFlags;

    if (recID == 0)
    {
        dwFlags = EVENTLOG_SEQUENTIAL_READ;
    }
    else
    {
        dwFlags = EVENTLOG_SEEK_READ;
    }

    if (b_Back)
    {
        dwFlags = dwFlags | EVENTLOG_BACKWARDS_READ;
    }
    else
    {
        dwFlags = dwFlags | EVENTLOG_FORWARDS_READ;
    }

    m_bBuffer = TRUE;

    if (0 == m_BuffLen)
    {
        m_BuffLen = 2048;
        m_Buffer = new BYTE[m_BuffLen];
    }

    DWORD dwRead = 0;
    DWORD dwNext = 0;
    m_LogLock.Lock();

    if ( !ReadEventLog(m_hEvtLog,
                dwFlags,
                recID,
                m_Buffer,
                m_BuffLen,
                &dwRead,
                &dwNext))
    {
        DWORD err = GetLastError();

        if (ERROR_INSUFFICIENT_BUFFER == err)
        {
            delete [] m_Buffer;
            m_Buffer = NULL;
            m_BuffLen = 5*dwNext;
            m_Buffer = new BYTE[m_BuffLen];

            if ( !ReadEventLog(m_hEvtLog,
                dwFlags,
                recID,
                m_Buffer,
                m_BuffLen,
                &dwRead,
                &dwNext))
            {
                m_LogLock.Unlock();
                return GetLastError();
            }
        }
        else
        {
            m_LogLock.Unlock();
            return err;
        }
    }

    if (NULL != dwBytesRead)
    {
        *dwBytesRead = dwRead;
    }

    m_bBuffer = TRUE;
    m_LogLock.Unlock();
    return 0;
}

DWORD CEventLogFile::ReadFirstRecord()
{
    DWORD last_rec = 0;
    DWORD dwRead = 0;
    m_bValid = FALSE;
    m_LogLock.Lock();
    BOOL bTest = GetOldestEventLogRecord(m_hEvtLog, &last_rec);
    m_LogLock.Unlock();

    if (bTest)
    {
        DWORD lastErr = ReadRecord(last_rec, &dwRead);

        if (0 != lastErr)
        {
            if (lastErr == ERROR_HANDLE_EOF)
            {
                m_bValid = TRUE;
            }
        }
        else
        {
            m_bValid = TRUE;
        }
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::ReadFirstRecord:Failed to get oldest record\r\n"
        ) ;
)

    }

    return dwRead;
}

void CEventLogFile::ReadLastRecord()
{
    DWORD recID = 0;
    DWORD numRecs = 0;
    m_bValid = FALSE;


    if (GetLastRecordID(recID, numRecs))
    {
        DWORD lastErr = ReadRecord(recID);

        if (0 != lastErr)
        {
            if (lastErr == ERROR_HANDLE_EOF)
            {
                m_bValid = TRUE;
            }
            else
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::ReadLastRecord:Failed to read last record\r\n"
        ) ;
)

            }
        }
        else
        {
            while (0 == (lastErr = ReadRecord(0)));

            if (lastErr == ERROR_HANDLE_EOF)
            {
                m_bValid = TRUE;
            }
            else
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::ReadLastRecord:Failed to read last record\r\n"
        ) ;
)

            }
        }
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogFile::ReadLastRecord:Failed to read last record\r\n"
        ) ;
)

    }
}


HANDLE CEventLogFile::OpenLocalEventLog(LPCWSTR a_log, DWORD *a_Reason)
{
    HANDLE retVal = NULL;

    if (a_Reason)
    {
        *a_Reason = 0;
    }

    HKEY hkLog;
    CStringW log(EVENTLOG_BASE);
    log += L"\\";
    log += a_log;

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, log, 0, KEY_READ, &hkLog))
    {
        *a_Reason  = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        RegCloseKey(hkLog);
        retVal = OpenEventLog(NULL, a_log);
        DWORD t_dwErr = GetLastError();

        if (retVal == NULL)
        {
            if (t_dwErr == ERROR_PRIVILEGE_NOT_HELD)
            {
                SetSecurityLogPrivilege();
                retVal = OpenEventLog(NULL, a_log);
                t_dwErr = GetLastError();
            }
            else if (a_Reason)
            {
                *a_Reason = t_dwErr;
            }
        }

        if ((NULL == retVal) && a_Reason && (*a_Reason == 0))
        {
            *a_Reason = t_dwErr;
        }
    }

    return retVal;
}


CMonitoredEventLogFile::CMonitoredEventLogFile(CEventProviderManager* parent, const WCHAR* logname)
: ProvTaskObject(), CEventLogFile(logname, FALSE), m_Class (NULL)
{
    InterlockedIncrement(&(CNTEventProviderClassFactory::objectsInProgress));
	VariantInit(&m_VpsdSelfRel);
    m_RecID = 0;

    if (parent != NULL)
    {
        m_parent = parent;
    }
    else
    {
        m_bValid = FALSE;
    }

    if (IsValid())
    {
        ReadLastRecord();

        if (IsValid())
        {
            m_LogLock.Lock();
            m_bValid = NotifyChangeEventLog(m_hEvtLog, GetHandle());
			m_bValid = m_bValid && SetEventDescriptor();
            m_LogLock.Unlock();
        }
    }

    if (!m_bValid)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::CMonitoredEventLogFile:Invalid log created\r\n"
        ) ;
)

    }
}

CMonitoredEventLogFile::~CMonitoredEventLogFile()
{
    if (m_Class != NULL)
    {
        m_Class->Release();
    }

	VariantClear(&m_VpsdSelfRel);

    InterlockedDecrement(&(CNTEventProviderClassFactory::objectsInProgress));
}

void CMonitoredEventLogFile::RefreshHandle()
{
    CEventLogFile::RefreshHandle();

    if (IsValid())
    {
        m_LogLock.Lock();
        m_bValid = NotifyChangeEventLog(m_hEvtLog, GetHandle());
        m_LogLock.Unlock();
    }

    if (!m_bValid)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::RefreshHandle:Invalid log\r\n"
        ) ;
)

    }

}

BOOL CMonitoredEventLogFile::GenerateInstance(IWbemClassObject** ppEvtInst,
                                              IWbemClassObject* pEmbedObj)
{
    HRESULT hr;

    if ((ppEvtInst == NULL) || (pEmbedObj == NULL))
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::GenerateInstance:Invalid parameter\r\n"
        ) ;
)
        return FALSE;
    }
    else
    {
        *ppEvtInst = NULL;
    }

    if (m_Class == NULL)
    {
        BSTR path = SysAllocString(EVENT_CLASS);
        IWbemServices* ns = m_parent->GetNamespacePtr();

        if (ns == NULL)
        {
            hr = WBEM_E_FAILED;
        }
        else
        {
            hr = ns->GetObject(path, 0, NULL, &m_Class, NULL);
            SysFreeString(path);
            ns->Release();
        }

        if (FAILED(hr))
        {
            m_Class = NULL;         
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::GenerateInstance:Failed to get class object\r\n"
        ) ;
)
            
            return FALSE;
        }
    }

    hr = m_Class->SpawnInstance(0, ppEvtInst);

    if (FAILED(hr))
    {
        m_Class->Release();
        m_Class = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::GenerateInstance:Failed to spawn instance\r\n"
        ) ;
)
        
        return FALSE;
    }

    hr = (*ppEvtInst)->Put(SD_PROP, 0, &m_VpsdSelfRel, 0);

    if (FAILED(hr))
    {
        (*ppEvtInst)->Release();
        *ppEvtInst = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::GenerateInstance:Failed to set security descriptor into event\r\n"
        ) ;
)
        return FALSE;
    }

    VARIANT v;
    VariantInit(&v);
#ifdef STILL_DISPATCH
    v.vt = VT_DISPATCH;
    v.pdispVal = pEmbedObj;
#else
    v.vt = VT_UNKNOWN;
    v.punkVal = pEmbedObj;
#endif
    pEmbedObj->AddRef();
    hr = (*ppEvtInst)->Put(TARGET_PROP, 0, &v, 0);
    VariantClear(&v); // will call release on value stored in variant

    if (FAILED(hr))
    {
        (*ppEvtInst)->Release();
        *ppEvtInst = NULL;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::GenerateInstance:Failed to embed target instance into event\r\n"
        ) ;
)
        return FALSE;
    }

    return TRUE;
}


void CMonitoredEventLogFile::Process()
{
    SetStructuredExceptionHandler seh;

    try
    {
        //Read and process the eventlog
        DWORD dwEventSize = 0;
        DWORD err = ReadRecord(m_RecID, &dwEventSize);
        m_RecID = 0;

        while (TRUE)
        {
            if (err != 0)
            {
                if (err == ERROR_HANDLE_EOF)
                {
                    break;
                }
                else
                {
                    RefreshHandle();

                    if (!m_bValid)
                    {
                        //log cannot be monitored
                        Complete();
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::Process:log cannot be read\r\n"
        ) ;
)

                        break;
                    }

                    if (err == ERROR_EVENTLOG_FILE_CHANGED)
                    {
                        err = 0;
                        continue;
                    }
                    else
                    {
                        ReadLastRecord();

                        if (!m_bValid)
                        {
                            //log cannot be monitored
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CMonitoredEventLogFile::Process:log cannot be read\r\n"
        ) ;
)
                            Complete();
                            break;
                        }
                    }
                }

                break;

            }
            else
            {
                PEVENTLOGRECORD EventBuffer = (PEVENTLOGRECORD)m_Buffer;
            
                while (dwEventSize != 0)
                {
                    //generate records...
                    IWbemServices* ns = m_parent->GetNamespacePtr();
                    
                    if (ns == NULL)
                    {
                        //no control objects!
                        return;
                    }

                    CEventlogRecord evtrec(m_EvtLogName, EventBuffer, ns);
                    ns->Release();
                    IWbemClassObject* pEmbedInst = NULL;
                    
                    if (evtrec.GenerateInstance(&pEmbedInst))
                    {
                        IWbemClassObject* pEvtInst;

                        if (GenerateInstance(&pEvtInst, pEmbedInst))
                        {
                            m_parent->SendEvent(pEvtInst);
                            pEvtInst->Release();
                        }

                        pEmbedInst->Release();
                    }

                    // drop by length of this record and point to next record
                    dwEventSize -= EventBuffer->Length;
                    EventBuffer = (PEVENTLOGRECORD) ((UCHAR*) EventBuffer + EventBuffer->Length);
                }
            }

            dwEventSize = 0;
            err = ReadRecord(0, &dwEventSize);
        }
    }
    catch(Structured_Exception e_SE)
    {
        try
        {
            Complete();
        }
		catch(...)
		{
			return;
		}
    }
    catch(Heap_Exception e_HE)
    {
        try
        {
            Complete();
        }
		catch(...)
		{
			return;
		}
    }
    catch(...)
    {
        try
        {
            Complete();
        }
		catch(...)
		{
			return;
		}
    }

}

static GENERIC_MAPPING LogFileObjectMapping = {

    STANDARD_RIGHTS_READ           |       // Generic read
        ELF_LOGFILE_READ           |
		WBEM_RIGHT_SUBSCRIBE,

    STANDARD_RIGHTS_WRITE          |       // Generic write
        ELF_LOGFILE_WRITE          |
		WBEM_RIGHT_SUBSCRIBE,

    STANDARD_RIGHTS_EXECUTE        |       // Generic execute
        ELF_LOGFILE_START          |
        ELF_LOGFILE_STOP           |
        ELF_LOGFILE_CONFIGURE      |
		WBEM_RIGHT_SUBSCRIBE,

    ELF_LOGFILE_ALL_ACCESS         |       // Generic all
		WBEM_RIGHT_SUBSCRIBE
    };

BOOL CMonitoredEventLogFile::SetEventDescriptor()
{
	BOOL retVal = FALSE;
    DWORD NumberOfAcesToUse = 0;
//
// Logfile object specific access type
//
    RTL_ACE_DATA AceData[ELF_LOGFILE_OBJECT_ACES] = {

        {ACCESS_DENIED_ACE_TYPE, 0, 0,
			ELF_LOGFILE_ALL_ACCESS | WBEM_RIGHT_SUBSCRIBE,               &CNTEventProvider::s_AnonymousLogonSid},

        {ACCESS_DENIED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_ALL_ACCESS | WBEM_RIGHT_SUBSCRIBE,               &CNTEventProvider::s_AliasGuestsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_ALL_ACCESS | WBEM_RIGHT_SUBSCRIBE,               &CNTEventProvider::s_LocalSystemSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_READ | ELF_LOGFILE_CLEAR | WBEM_RIGHT_SUBSCRIBE, &CNTEventProvider::s_AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_BACKUP,                   &CNTEventProvider::s_AliasBackupOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_READ | ELF_LOGFILE_CLEAR | WBEM_RIGHT_SUBSCRIBE, &CNTEventProvider::s_AliasSystemOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_READ | WBEM_RIGHT_SUBSCRIBE,                     &CNTEventProvider::s_WorldSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE | WBEM_RIGHT_SUBSCRIBE,                    &CNTEventProvider::s_AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE | WBEM_RIGHT_SUBSCRIBE,                    &CNTEventProvider::s_LocalServiceSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE | WBEM_RIGHT_SUBSCRIBE,                    &CNTEventProvider::s_NetworkServiceSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE | WBEM_RIGHT_SUBSCRIBE,                    &CNTEventProvider::s_AliasSystemOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE | WBEM_RIGHT_SUBSCRIBE,                    &CNTEventProvider::s_WorldSid}
        };

    PRTL_ACE_DATA pAceData = NULL;

    //
    // NON_SECURE logfiles let anyone read/write to them, secure ones
    // only let admins/local system do this.  so for secure files we just
    // don't use the last ACE
    //
    // Adjust the ACL start based on the passed GuestAccessRestriction flag.
    // The first two aces deny all log access to guests and/or anonymous
    // logons. The flag, GuestAccessRestriction, indicates that these two
    // deny access aces should be applied. Note that the deny aces and the
    // GuestAccessRestriction flag are not applicable to the security log,
    // since users and anonymous logons, by default, do not have access.
    //

	wchar_t* buff = new wchar_t[wcslen(EVENTLOG_BASE) + m_EvtLogName.GetLength() + 2];
	wcscpy(buff, EVENTLOG_BASE);
	wcscat(buff, L"\\");
	wcscat(buff, m_EvtLogName);

	HKEY hkResult = NULL;
	BOOL GuestAccessRestriction = TRUE;

	DWORD dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
							buff, 0,
							KEY_READ,
							&hkResult);

	if (dwErr == ERROR_SUCCESS)
	{
		DWORD datalen = sizeof(DWORD);
		DWORD dwType = 0;
		DWORD dwVal = 0;

		dwErr = RegQueryValueEx(hkResult, GUEST_ACCESS,
					0, &dwType, (LPBYTE) &dwVal, &datalen);

		if ((dwErr == ERROR_SUCCESS) && (dwType == REG_DWORD))
		{
			if (dwVal == 0)
			{
				GuestAccessRestriction = FALSE;
			}
		}

		RegCloseKey(hkResult);
	}

	DWORD Type = 0;

    if (m_EvtLogName.CompareNoCase(SYSTEM_LOG) == 0)
    {
        Type = 1;
    }
    else if (m_EvtLogName.CompareNoCase(SECURITY_LOG) == 0)
    {
        Type = 2;
    }

    switch (Type)
    {
        case 2:
		{
            pAceData = AceData + 2;         // Deny ACEs *not* applicable
            NumberOfAcesToUse = 3;
		}
        break;

        case 1:
		{
            if (GuestAccessRestriction)
            {
                pAceData = AceData;         // Deny ACEs *applicable*
                NumberOfAcesToUse = 10;
            }
            else
            {
                pAceData = AceData + 2;     // Deny ACEs *not* applicable
                NumberOfAcesToUse = 8;
            }
		}
        break;

        case 0:
		default:
		{
            if (GuestAccessRestriction)
            {
                pAceData = AceData;         // Deny ACEs *applicable*
                NumberOfAcesToUse = 12;
            }
            else
            {
                pAceData = AceData + 2;     // Deny ACEs *not* applicable
                NumberOfAcesToUse = 10;
            }
		}
        break;
    }
	
	PSECURITY_DESCRIPTOR psdSelfRel = NULL;
	NTSTATUS Status = RtlCreateUserSecurityObject(
					   pAceData,
					   NumberOfAcesToUse,
					   CNTEventProvider::s_LocalSystemSid,	// Owner
					   CNTEventProvider::s_LocalSystemSid,	// Group
					   TRUE,								// IsDirectoryObject
					   &LogFileObjectMapping,
					   &psdSelfRel);

	if (NT_SUCCESS(Status) && psdSelfRel)	
	{
		try
		{
			DWORD sdlen = GetSecurityDescriptorLength(psdSelfRel);

			if (sdlen > 0)
			{
				SAFEARRAYBOUND rgsabound[1];
				SAFEARRAY* psa = NULL;
				UCHAR* pdata = NULL;
				rgsabound[0].lLbound = 0;
				rgsabound[0].cElements = sdlen;
				psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

				if (NULL != psa)
				{
					try
					{
						if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pdata)))
						{
							memcpy((void *)pdata, (void *)psdSelfRel, sdlen);
							SafeArrayUnaccessData(psa);
							m_VpsdSelfRel.vt = VT_ARRAY|VT_UI1;
							m_VpsdSelfRel.parray = psa;
							retVal = TRUE;
						}
						else
						{
							SafeArrayDestroy(psa);
							psa = NULL;
						}
					}
					catch(...)
					{
						SafeArrayDestroy(psa);
						psa = NULL;
						throw;
					}
				}
			}
		}
		catch(...)
		{
			RtlDeleteSecurityObject(&psdSelfRel);
			psdSelfRel = NULL;
		}

		RtlDeleteSecurityObject(&psdSelfRel);
		psdSelfRel = NULL;
	}

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtget.cpp ===
//***************************************************************************

//

//  NTEVTGET.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the GetObject implementation

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

extern BOOL GenerateAssocInstance (WbemProvErrorObject &a_ErrorObject,
                                     const wchar_t* objPath1,
                                     const wchar_t* objPath2,
                                     wchar_t* prop1,
                                     wchar_t* prop2,
                                     IWbemClassObject* pClassObject,
                                     IWbemObjectSink* pNtfcnHandler,
									 BOOL *pbIndicated);

BOOL GetObjectAsyncEventObject :: GetObject ( WbemProvErrorObject &a_ErrorObject )
{

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: GetObject\r\n"
        ) ;
)
    if (FAILED(m_ErrorObject.GetWbemStatus()))
    {
        return FALSE;
    }

    BOOL t_Status = ! m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

    if ( t_Status )
    {
        BOOL bClass = TRUE;

        if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , NTEVT_CLASS) == 0 )
        {
			BSTR bstCls = SysAllocString( m_ParsedObjectPath->m_pClass ) ;
            t_Status = GetClassObject ( bstCls ) ;
			SysFreeString ( bstCls ) ;

            if ( t_Status )
            {
                t_Status =  Dispatch_Record ( a_ErrorObject ) ;
                
                if ( t_Status )
                {
                    m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                }
            }
            else
            {
                bClass = FALSE ;
            }
        }
        else if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , NTEVTLOG_CLASS ) == 0 )
        {
			BSTR bstCls = SysAllocString( m_ParsedObjectPath->m_pClass ) ;
            t_Status = GetClassObject ( bstCls ) ;
			SysFreeString ( bstCls ) ;

            if ( t_Status )
            {
                t_Status =  Dispatch_EventLog ( a_ErrorObject ) ;
                
                if ( t_Status )
                {
                    m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                }
            }
            else
            {
                bClass = FALSE ;
            }
        }
        else if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , ASSOC_LOGRECORD ) == 0 )
        {
			BSTR bstCls = SysAllocString( m_ParsedObjectPath->m_pClass ) ;
            t_Status = GetClassObject ( bstCls ) ;
			SysFreeString ( bstCls ) ;

            if ( t_Status )
            {
                t_Status =  Dispatch_LogRecord ( a_ErrorObject ) ;
                
                if ( t_Status )
                {
                    m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                }
            }
            else
            {
                bClass = FALSE ;
            }
        }
        else if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , ASSOC_USERRECORD ) == 0 )
        {
			BSTR bstCls = SysAllocString( m_ParsedObjectPath->m_pClass ) ;
            t_Status = GetClassObject ( bstCls ) ;
			SysFreeString ( bstCls ) ;

            if ( t_Status )
            {
                t_Status =  Dispatch_UserRecord ( a_ErrorObject ) ;
                
                if ( t_Status )
                {
                    m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                }
            }
            else
            {
                bClass = FALSE ;
            }
        }
        else if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , ASSOC_COMPRECORD ) == 0 )
        {
            t_Status = GetClassObject ( m_ParsedObjectPath->m_pClass ) ;

            if ( t_Status )
            {
                t_Status =  Dispatch_ComputerRecord ( a_ErrorObject ) ;
                
                if ( t_Status )
                {
                    m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                }
            }
            else
            {
                bClass = FALSE ;
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
            a_ErrorObject.SetMessage ( L"Dynamic NT Eventlog Provider does not support this class" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: GetObject:Dynamic NT Eventlog Provider does not support this class %s\r\n",
        m_ParsedObjectPath->m_pClass
        ) ;
)

        }

        if (!bClass)
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
            a_ErrorObject.SetMessage ( L"Class definition not found" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: GetObject:Class definition not found\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Unable to parse object path" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: GetObject:Dynamic NT Eventlog Provider does not support this class %s\r\n",
        m_ObjectPath
        ) ;
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"leaving GetObjectAsyncEventObject :: GetObject with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_Record ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record\r\n"
        ) ;
)
    if (m_ParsedObjectPath->m_dwNumKeys != 2)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }

    BOOL t_Status ;

    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
    KeyRef *t_Key2 = m_ParsedObjectPath->m_paKeys [ 1 ] ;
    if ( t_Key1 && t_Key2 )
    {
        if ( _wcsicmp ( t_Key1->m_pName , LOGFILE_PROP ) == 0 )
        {
            if ( _wcsicmp ( t_Key2->m_pName , RECORD_PROP ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_I4 ) )
                {
                    t_Status = Get_Record ( a_ErrorObject , t_Key1 , t_Key2 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Key value(s) have incorrect type\r\n"
        ) ;
)

                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else if ( _wcsicmp ( t_Key2->m_pName , LOGFILE_PROP ) == 0 )
        {
            if ( _wcsicmp ( t_Key1->m_pName , RECORD_PROP ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_I4 ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_Record ( a_ErrorObject , t_Key2 , t_Key1 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Key value(s) have incorrect type\r\n"
        ) ;
)
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Key value(s) have incorrect name\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key values" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_Record: Failed to get key values\r\n"
        ) ;
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"leaving GetObjectAsyncEventObject :: Dispatch_Record with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog\r\n"
        ) ;
)
    if (m_ParsedObjectPath->m_dwNumKeys != 1)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }

    BOOL t_Status ;

    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
    if ( t_Key1 )
    {
        if ((t_Key1->m_pName == NULL) || _wcsicmp ( t_Key1->m_pName , PROP_NAME ) == 0 )
        {
            if ( t_Key1->m_vValue.vt == VT_BSTR )
            {
                t_Status = Get_EventLog ( a_ErrorObject , t_Key1 ) ;
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value has incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog:Key value has incorrect type\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value has incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog:Key value has incorrect name\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key value" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog:Failed to get key value\r\n"
        ) ;
)
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_EventLog:return %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_LogRecord ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord\r\n"
        ) ;
)
    if (m_ParsedObjectPath->m_dwNumKeys != 2)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }


    BOOL t_Status ;

    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
    KeyRef *t_Key2 = m_ParsedObjectPath->m_paKeys [ 1 ] ;
    if ( t_Key1 && t_Key2 )
    {
        if ( _wcsicmp ( t_Key1->m_pName , REF_LOG ) == 0 )
        {
            if ( _wcsicmp ( t_Key2->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_LogRecord ( a_ErrorObject , t_Key1 , t_Key2 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Key value(s) have incorrect type\r\n"
        ) ;
)

                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else if ( _wcsicmp ( t_Key2->m_pName , REF_LOG ) == 0 )
        {
            if ( _wcsicmp ( t_Key1->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_LogRecord ( a_ErrorObject , t_Key2 , t_Key1 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Key value(s) have incorrect type\r\n"
        ) ;
)
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key values" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:Failed to get key values\r\n"
        ) ;
)
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:returning with %lx\r\n",
        t_Status
        ) ;
)
    return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_UserRecord ( WbemProvErrorObject &a_ErrorObject )
{
    if (m_ParsedObjectPath->m_dwNumKeys != 2)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_UserRecord: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }

    BOOL t_Status ;

    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
    KeyRef *t_Key2 = m_ParsedObjectPath->m_paKeys [ 1 ] ;
    if ( t_Key1 && t_Key2 )
    {
        if ( _wcsicmp ( t_Key1->m_pName , REF_USER ) == 0 )
        {
            if ( _wcsicmp ( t_Key2->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_UserRecord ( a_ErrorObject , t_Key1 , t_Key2 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
            }
        }
        else if ( _wcsicmp ( t_Key2->m_pName , REF_USER ) == 0 )
        {
            if ( _wcsicmp ( t_Key1->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_UserRecord ( a_ErrorObject , t_Key2 , t_Key1 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key values" ) ;
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:returning with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

BOOL GetObjectAsyncEventObject :: Dispatch_ComputerRecord ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord\r\n"
        ) ;
)

    if (m_ParsedObjectPath->m_dwNumKeys != 2)
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Object path has incorrect number of keys." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord: Wrong number of key values\r\n"
        ) ;
)
        return FALSE;
    }

    BOOL t_Status ;

    KeyRef *t_Key1 = m_ParsedObjectPath->m_paKeys [ 0 ] ;
    KeyRef *t_Key2 = m_ParsedObjectPath->m_paKeys [ 1 ] ;
    if ( t_Key1 && t_Key2 )
    {
        if ( _wcsicmp ( t_Key1->m_pName , REF_COMP ) == 0 )
        {
            if ( _wcsicmp ( t_Key2->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_ComputerRecord ( a_ErrorObject , t_Key1 , t_Key2 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Key value(s) have incorrect type\r\n"
        ) ;
)

                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else if ( _wcsicmp ( t_Key2->m_pName , REF_COMP ) == 0 )
        {
            if ( _wcsicmp ( t_Key1->m_pName , REF_REC ) == 0 )
            {
                if ( ( t_Key1->m_vValue.vt == VT_BSTR ) && ( t_Key2->m_vValue.vt == VT_BSTR ) )
                {
                    t_Status = Get_ComputerRecord ( a_ErrorObject , t_Key2 , t_Key1 ) ;
                }
                else
                {
                    t_Status = FALSE ;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                    a_ErrorObject.SetMessage ( L"Key value(s) have incorrect type" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Key value(s) have incorrect type\r\n"
        ) ;
)
                }
            }
            else
            {
                t_Status = FALSE ;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
                a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
            }
        }
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetMessage ( L"Key value(s) have incorrect name" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Key value(s) have incorrect name\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetMessage ( L"Failed to get key values" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:Failed to get key values\r\n"
        ) ;
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_ComputerRecord:returning with %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}


BOOL GetObjectAsyncEventObject :: Get_LogRecord ( WbemProvErrorObject &a_ErrorObject ,
                                                 KeyRef *a_LogKey , KeyRef *a_RecordKey )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord\r\n"
        ) ;
)

    BOOL retVal = TRUE;
    GetObjectAsyncEventObject *t_getRec = new GetObjectAsyncEventObject (
                                                m_Provider , a_RecordKey->m_vValue.bstrVal ,
                                                0 , m_NotificationHandler , m_Ctx, FALSE ) ;

	try
	{
		if (!t_getRec->GetObject(t_getRec->m_ErrorObject))
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_ErrorObject.SetMessage ( L"Failed to verify given eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord:Failed to verify given eventlog record object\r\n"
        ) ;
)

		}
		else
		{
			GetObjectAsyncEventObject *t_getLog = new GetObjectAsyncEventObject (
													m_Provider , a_LogKey->m_vValue.bstrVal ,
													0 , m_NotificationHandler , m_Ctx, FALSE ) ;
			try
			{
				if (!t_getLog->GetObject(t_getLog->m_ErrorObject))
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
					a_ErrorObject.SetMessage ( L"Failed to verify given eventlog file object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord:Failed to verify given eventlog file object\r\n"
        ) ;
)
				}
				else 
				{
					//check the association
					VARIANT vLog;
					VariantInit(&vLog);
					HRESULT result = t_getLog->m_Out->Get(PROP_LOGNAME, 0, &vLog, NULL, NULL);

					if ((FAILED(result)) || (vLog.vt != VT_BSTR))
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to get logfile property from eventlog file object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord:Failed to get logfile property from eventlog file object\r\n"
        ) ;
)
					}
					else
					{
						VARIANT vRec;
						VariantInit(&vRec);
						result = t_getRec->m_Out->Get(LOGFILE_PROP, 0, &vRec, NULL, NULL);

						if ((FAILED(result)) || (vRec.vt != VT_BSTR))
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Failed to get logfile property from eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord:Failed to get logfile property from eventlog record object\r\n"
        ) ;
)
						}
						else if (_wcsicmp(vRec.bstrVal, vLog.bstrVal) == 0)
						{
							retVal = GenerateAssocInstance(a_ErrorObject, a_RecordKey->m_vValue.bstrVal,
											a_LogKey->m_vValue.bstrVal, REF_REC, REF_LOG,
											m_ClassObject, m_NotificationHandler, NULL);
						}
						else
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
							a_ErrorObject.SetMessage ( L"Both objects exist but are not associated" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_LogRecord:Both objects exist but are not associated\r\n"
        ) ;
)
						}

						VariantClear(&vRec);
					}

					VariantClear(&vLog);
				}
			}
			catch(...)
			{
				delete t_getLog;
				throw;
			}

			delete t_getLog;
		}
	}
	catch (...)
	{
		delete t_getRec;
		throw;
	}

    delete t_getRec;

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Dispatch_LogRecord:returning with %lx\r\n",
        retVal
        ) ;
)

    return retVal;
}

BOOL GetObjectAsyncEventObject :: Get_UserRecord ( WbemProvErrorObject &a_ErrorObject ,
                                                  KeyRef *a_UserKey , KeyRef *a_RecordKey )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord\r\n"
        ) ;
)

    BOOL retVal = TRUE;
    GetObjectAsyncEventObject *t_getRec = new GetObjectAsyncEventObject (
                                                m_Provider , a_RecordKey->m_vValue.bstrVal ,
                                                0 , m_NotificationHandler , m_Ctx, FALSE) ;

	try
	{
		if (!t_getRec->GetObject(t_getRec->m_ErrorObject))
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_ErrorObject.SetMessage ( L"Failed to verify given eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Failed to verify given eventlog record object\r\n"
        ) ;
)
		}
		else
		{
			IWbemClassObject* userObj = NULL;
			IWbemServices *t_Server = m_Provider->GetServer() ;
			HRESULT result = t_Server->GetObject(a_UserKey->m_vValue.bstrVal, 0, m_Ctx, &userObj, NULL);
			t_Server->Release();

			if (FAILED(result))
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				a_ErrorObject.SetMessage ( L"Failed to verify given user object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Failed to verify given user object\r\n"
        ) ;
)
			}
			else 
			{
				//check the association
				VARIANT vUserN;
				VariantInit(&vUserN);
				result = userObj->Get(PROP_NAME, 0, &vUserN, NULL, NULL);

				if ((FAILED(result)) || (vUserN.vt != VT_BSTR))
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Failed to get name property from eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Failed to get name property from eventlog record object\r\n"
        ) ;
)
				}
				else
				{
					VARIANT vUserD;
					VariantInit(&vUserD);
					result = userObj->Get(PROP_DOMAIN, 0, &vUserD, NULL, NULL);

					if ((FAILED(result)) || (vUserD.vt != VT_BSTR))
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to get name property from user object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Failed to get name property from user object\r\n"
        ) ;
)
					}
					else
					{
						wchar_t userStr[1024];
						wcscpy(userStr, vUserD.bstrVal);
						wcscat(userStr, L"\\"); 
						wcscat(userStr, vUserN.bstrVal);
						VARIANT vRec;
						VariantInit(&vRec);
						result = t_getRec->m_Out->Get(USER_PROP, 0, &vRec, NULL, NULL);

						if ((FAILED(result)) || (vRec.vt != VT_BSTR))
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_ErrorObject.SetMessage ( L"Failed to get user property from eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Failed to get user property from eventlog record object\r\n"
        ) ;
)
						}
						else if (_wcsicmp(vRec.bstrVal, userStr) == 0)
						{
							retVal = GenerateAssocInstance(a_ErrorObject, a_RecordKey->m_vValue.bstrVal,
											a_UserKey->m_vValue.bstrVal, REF_REC, REF_USER,
											m_ClassObject, m_NotificationHandler, NULL);
						}
						else
						{
							retVal = FALSE;
							a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
							a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
							a_ErrorObject.SetMessage ( L"Both objects exist but are not associated" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:Both objects exist but are not associated\r\n"
        ) ;
)
						}

						VariantClear(&vRec);
					}

					VariantClear(&vUserD);
				}

				VariantClear(&vUserN);
				userObj->Release();
			}
		}
	}
	catch(...)
	{
		delete t_getRec;
		throw;
	}

    delete t_getRec;

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_UserRecord:returning with %lx\r\n",
        retVal
        ) ;
)

    return retVal;
}

BOOL GetObjectAsyncEventObject :: Get_ComputerRecord ( WbemProvErrorObject &a_ErrorObject ,
                                                      KeyRef *a_CompKey , KeyRef *a_RecordKey )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord\r\n"
        ) ;
)
    
    BOOL retVal = TRUE;
    GetObjectAsyncEventObject *t_getRec = new GetObjectAsyncEventObject (
                                                m_Provider , a_RecordKey->m_vValue.bstrVal ,
                                                0 , m_NotificationHandler , m_Ctx, FALSE ) ;

	try
	{
		if (!t_getRec->GetObject(t_getRec->m_ErrorObject))
		{
			retVal = FALSE;
			a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_ErrorObject.SetMessage ( L"Failed to verify given eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:Failed to verify given eventlog record object\r\n"
        ) ;
)
		}
		else
		{
			IWbemClassObject* compObj = NULL;
			IWbemServices *t_Server = m_Provider->GetServer() ;
			HRESULT result = t_Server->GetObject(a_CompKey->m_vValue.bstrVal, 0, m_Ctx, &compObj, NULL);
			t_Server->Release();

			if (FAILED(result))
			{
				retVal = FALSE;
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				a_ErrorObject.SetMessage ( L"Failed to verify given computer object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:Failed to verify given computer object\r\n"
        ) ;
)
			}
			else 
			{
				//check the association
				VARIANT vComp;
				VariantInit(&vComp);
				result = compObj->Get(PROP_NAME, 0, &vComp, NULL, NULL);

				if ((FAILED(result)) || (vComp.vt != VT_BSTR))
				{
					retVal = FALSE;
					a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_ErrorObject.SetMessage ( L"Failed to get Name property from computer object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:Failed to get Name property from computer object\r\n"
        ) ;
)
				}
				else
				{
					VARIANT vRec;
					VariantInit(&vRec);
					result = t_getRec->m_Out->Get(COMPUTER_PROP, 0, &vRec, NULL, NULL);

					if ((FAILED(result)) || (vRec.vt != VT_BSTR))
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to get computer property from eventlog record object" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:Failed to get computer property from eventlog record object\r\n"
        ) ;
)
					}
					else if (_wcsicmp(vRec.bstrVal, vComp.bstrVal) == 0)
					{
						retVal = GenerateAssocInstance(a_ErrorObject, a_RecordKey->m_vValue.bstrVal,
										a_CompKey->m_vValue.bstrVal, REF_REC, REF_COMP,
										m_ClassObject, m_NotificationHandler, NULL);
					}
					else
					{
						retVal = FALSE;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
						a_ErrorObject.SetMessage ( L"Both objects exist but are not associated" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:Both objects exist but are not associated\r\n"
        ) ;
)
					}

					VariantClear(&vRec);
				}

				VariantClear(&vComp);
				compObj->Release();
			}
		}
	}
	catch (...)
	{
		delete t_getRec;
		throw;
	}

	delete t_getRec;

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_ComputerRecord:returning with %lx\r\n",
        retVal
        ) ;
)
    return retVal;
}

BOOL GetObjectAsyncEventObject :: Get_EventLog ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey) 
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_EventLog\r\n"
        ) ;
)

    BOOL retVal = FALSE;
    CStringW log = CEventLogFile::GetLogName((const wchar_t*)a_FileKey->m_vValue.bstrVal);

    if (log.IsEmpty())
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
        a_ErrorObject.SetMessage ( L"Failed to translate key to instance of logfile." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_EventLog: Failed to get instance of logfile named %s\r\n",
        (const wchar_t*)a_FileKey->m_vValue.bstrVal
        ) ;
)
    }
    else
    {
        CEventlogFileAttributes evtlog(log);

        IWbemClassObject* pInst = NULL;
            
        if (evtlog.GenerateInstance(m_ClassObject, m_AClassObject, &pInst))
        {
            if (m_bIndicate)
            {
                m_NotificationHandler->Indicate ( 1 , & pInst ) ;
                pInst->Release();
            }
            else
            {
                m_Out = pInst;
            }

            retVal = TRUE;
        }
        else
        {
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_PARAMETER ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
            a_ErrorObject.SetMessage ( L"Failed while generating instance of logfile." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_EventLog: Failed to generate instance of logfile named %s\r\n",
        log
        ) ;
)
        }
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_EventLog:returning with %lx\r\n",
        retVal
        ) ;
)
    return retVal;
}


BOOL GetObjectAsyncEventObject :: Get_Record ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey , KeyRef *a_RecordKey ) 
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_Record\r\n"
        ) ;
)

    BOOL retVal = TRUE;
    CEventLogFile evtlog(a_FileKey->m_vValue.bstrVal, TRUE);

    if (!evtlog.IsValid())
    {
        //failed to find log i.e. no such record??
        retVal = FALSE;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;

        if ((evtlog.GetReason() == ERROR_ACCESS_DENIED) || (evtlog.GetReason() == ERROR_PRIVILEGE_NOT_HELD))
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_ACCESS_DENIED ) ;
            a_ErrorObject.SetPrivilegeFailed();
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();
        }
        else
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
        }

        a_ErrorObject.SetMessage ( L"Failed to find the logfile" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_Record:Failed to find the logfile %s\r\n",
        a_FileKey->m_vValue.bstrVal
        ) ;
)
    }
    else
    {
        if (0 == evtlog.ReadRecord(a_RecordKey->m_vValue.lVal))
        {
            EVENTLOGRECORD* pEvt = (EVENTLOGRECORD*) evtlog.GetBuffer();
            CEventlogRecord evtRec(a_FileKey->m_vValue.bstrVal, pEvt, NULL, m_ClassObject, m_AClassObject);
            IWbemClassObject* pInst = NULL;
                
            if (evtRec.GenerateInstance(&pInst))
            {
                if (m_bIndicate)
                {
                    m_NotificationHandler->Indicate ( 1 , & pInst ) ;
                    pInst->Release();
                }
                else
                {
                    m_Out = pInst;
                }
            }
            else
            {
                //failed to create record
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                a_ErrorObject.SetMessage ( L"Failed to create instance from Eventlog data" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_Record:Failed to create instance from Eventlog data\r\n"
        ) ;
)

            }

        }
        else
        {
            //record not found i.e. no such record??
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
            a_ErrorObject.SetMessage ( L"Failed to find the record in the logfile" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_Record:Failed to find the record in the logfile\r\n"
        ) ;
)
        }
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: Get_Record:returning with %lx\r\n",
        retVal
        ) ;
)
    return retVal;
}

GetObjectAsyncEventObject :: GetObjectAsyncEventObject (

    CImpNTEvtProv *a_Provider , 
    wchar_t* a_ObjectPath ,
    ULONG a_OperationFlag ,
    IWbemObjectSink *a_NotificationHandler ,
    IWbemContext *a_Ctx ,
    BOOL a_bIndicate

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
    m_Class ( NULL ) , m_bIndicate ( a_bIndicate ) , m_Out ( NULL ) ,
    m_ParsedObjectPath ( NULL )
{
    m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
}

GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject () 
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject: Object path (%s) SetStatus with %lx\r\n",
        m_ObjectPath, m_ErrorObject.GetWbemStatus ()
        ) ;
)

    delete [] m_ObjectPath ;
    delete m_ParsedObjectPath ;

    // Get Status object
    if (m_bIndicate)
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject: Indicating Object path (%s) SetStatus with %lx\r\n",
        m_ObjectPath, m_ErrorObject.GetWbemStatus ()
        ) ;
)
        IWbemClassObject *t_NotifyStatus = NULL ;
        BOOL t_Status = TRUE;
        
        if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
        {
            t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
        }

        if ( t_Status )
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject: Really Indicating Object path (%s) SetStatus with %lx\r\n",
        m_ObjectPath, m_ErrorObject.GetWbemStatus ()
        ) ;
)
            HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;
            
            if (t_NotifyStatus)
            {
                t_NotifyStatus->Release () ;
            }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject:Indicated status, released objectsink\r\n"
        ) ;
)

        }
        else
        {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject: Failed to get Status object Object path (%s)\r\n",
        m_ObjectPath
        ) ;
)
            HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
        }
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject:Released object without indicating it\r\n"
        ) ;
)

        if (m_Out != NULL)
        {
            m_Out->Release();
        }
    }
}


void GetObjectAsyncEventObject :: Process () 
{
    GetObject ( m_ErrorObject ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtprov.cpp ===
//***************************************************************************

//

//  NTEVTPROV.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the WBEM interface for event provider classes

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

#include "ql.h"
#include "analyser.h"

BOOL ObtainedSerialAccess(CMutex* pLock)
{
    BOOL bResult = FALSE;

    if (pLock != NULL)
    {
        if (pLock->Lock())
        {
            bResult = TRUE;
        }
    }

    return bResult;
}

void ReleaseSerialAccess(CMutex* pLock)
{
    if (pLock != NULL)
    {
        pLock->Unlock();
    }
}

void CNTEventProvider::AllocateGlobalSIDs()
{
	SID_IDENTIFIER_AUTHORITY t_WorldAuthoritySid = SECURITY_WORLD_SID_AUTHORITY;

    if (!AllocateAndInitializeSid(
							&t_WorldAuthoritySid,
							1,
							SECURITY_WORLD_RID,
							0,
							0, 0, 0, 0, 0, 0,
							&s_WorldSid))
	{
		s_WorldSid = NULL;
	}

	SID_IDENTIFIER_AUTHORITY t_NTAuthoritySid = SECURITY_NT_AUTHORITY;

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							1,
							SECURITY_ANONYMOUS_LOGON_RID,
							0, 0, 0, 0, 0, 0, 0,
							&s_AnonymousLogonSid))
	{
		s_AnonymousLogonSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							 2,
							 SECURITY_BUILTIN_DOMAIN_RID,
							 DOMAIN_ALIAS_RID_ADMINS,
							 0, 0, 0, 0, 0, 0,
							 &s_AliasAdminsSid))
	{
		s_AliasAdminsSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							 &t_NTAuthoritySid,
							 1,
							 SECURITY_LOCAL_SYSTEM_RID,
							 0, 0, 0, 0, 0, 0, 0,
							 &s_LocalSystemSid
							 ))
	{
		s_LocalSystemSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							2,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_GUESTS,
							0,0,0,0,0,0,
							&s_AliasGuestsSid
							))
	{
		s_AliasGuestsSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							2,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_SYSTEM_OPS,
							0,0,0,0,0,0,
							&s_AliasSystemOpsSid
							))
	{
		s_AliasSystemOpsSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							2,
							SECURITY_BUILTIN_DOMAIN_RID,
							DOMAIN_ALIAS_RID_BACKUP_OPS,
							0,0,0,0,0,0,
							&s_AliasBackupOpsSid
							))
	{
		s_AliasBackupOpsSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							1,
							SECURITY_LOCAL_SERVICE_RID,
							0,
							0, 0, 0, 0, 0, 0,
							&s_LocalServiceSid
							))
	{
		s_LocalServiceSid = NULL;
	}

    if (!AllocateAndInitializeSid(
							&t_NTAuthoritySid,
							1,
							SECURITY_NETWORK_SERVICE_RID,
							0,
							0, 0, 0, 0, 0, 0,
							&s_NetworkServiceSid
							))
	{
		s_NetworkServiceSid = NULL;
	}
}

void CNTEventProvider::FreeGlobalSIDs()
{
	if (s_NetworkServiceSid)
	{
		FreeSid(s_NetworkServiceSid);
		s_NetworkServiceSid = NULL;
	}

	if (s_LocalServiceSid)
	{
		FreeSid(s_LocalServiceSid);
		s_LocalServiceSid = NULL;
	}

	if (s_AliasBackupOpsSid)
	{
		FreeSid(s_AliasBackupOpsSid);
		s_AliasBackupOpsSid = NULL;
	}

	if (s_AliasSystemOpsSid)
	{
		FreeSid(s_AliasSystemOpsSid);
		s_AliasSystemOpsSid = NULL;
	}

	if (s_AliasGuestsSid)
	{
		FreeSid(s_AliasGuestsSid);
		s_AliasGuestsSid = NULL;
	}

	if (s_LocalSystemSid)
	{
		FreeSid(s_LocalSystemSid);
		s_LocalSystemSid = NULL;
	}

	if (s_AliasAdminsSid)
	{
		FreeSid(s_AliasAdminsSid);
		s_AliasAdminsSid = NULL;
	}

	if (s_AnonymousLogonSid)
	{
		FreeSid(s_AnonymousLogonSid);
		s_AnonymousLogonSid = NULL;
	}

	if (s_WorldSid)
	{
		FreeSid(s_WorldSid);
		s_WorldSid = NULL;
	}
}

BOOL CNTEventProvider::GlobalSIDsOK()
{
	return (s_NetworkServiceSid 
		&& s_LocalServiceSid
		&& s_AliasBackupOpsSid
		&& s_AliasSystemOpsSid
		&& s_AliasGuestsSid
		&& s_LocalSystemSid
		&& s_AliasAdminsSid
		&& s_AnonymousLogonSid
		&& s_WorldSid);
}


STDMETHODIMP CNTEventProvider::AccessCheck (
                LPCWSTR wszQueryLanguage,
                LPCWSTR wszQuery,
                LONG lSidLength,
                const BYTE __RPC_FAR *pSid
                )
{
    HRESULT t_Status = WBEM_E_ACCESS_DENIED;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::AccessCheck\r\n");
)


        if (lSidLength  > 0)
        {
            if (pSid != NULL)
            {
                // permanent consumer: hope core did its job
                return WBEM_S_SUBJECT_TO_SDS;
            }
            else
            {
                return WBEM_E_ACCESS_DENIED;
            }
        }

        if (FAILED(CImpNTEvtProv::GetImpersonation()))
        {
            return WBEM_E_ACCESS_DENIED;
        }

        QL_LEVEL_1_RPN_EXPRESSION* pExpr;
        CTextLexSource Source(wszQuery);
        QL1_Parser Parser(&Source);

        if(Parser.Parse(&pExpr) == 0)
        {
            // Analyze this

            QL_LEVEL_1_RPN_EXPRESSION* pNewExpr;
            CPropertyName MyProp;
            MyProp.AddElement(TARGET_PROP);
            MyProp.AddElement(LOGFILE_PROP);

            if(SUCCEEDED(CQueryAnalyser::GetNecessaryQueryForProperty(pExpr, MyProp, pNewExpr)))
            {
                CStringArray t_wsVals;
                HRESULT t_hres = CQueryAnalyser::GetValuesForProp(pNewExpr, MyProp, t_wsVals);

                if(SUCCEEDED(t_hres))
                {
                    //grant access and set false if a failure occurs...
                    t_Status = S_OK;

                    // awsVals contains the list of files
                    for (int x = 0; x < t_wsVals.GetSize(); x++)
                    {
                        DWORD t_dwReason = 0;
                        HANDLE t_hEvtlog = CEventLogFile::OpenLocalEventLog(t_wsVals[x], &t_dwReason);

                        if (t_hEvtlog == NULL)
                        {
                            if (t_dwReason != ERROR_FILE_NOT_FOUND)
                            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::AccessCheck - Failed to verify logfile access\r\n");
)
                                t_Status = WBEM_E_ACCESS_DENIED;
                                break;
                            }
                            else
                            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::AccessCheck - Logfile not found assuming access allowed for log\r\n");
)
                            }
                        }
                        else
                        {
                            CloseEventLog(t_hEvtlog);
                        }
                    }
                }
                else if(t_hres == WBEMESS_E_REGISTRATION_TOO_BROAD)
                {
                    // user asked for all, check all logs....
                    HKEY hkResult = NULL;
                    LONG t_lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                            EVENTLOG_BASE, 0,
                                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                            &hkResult);

                    if (t_lErr == ERROR_SUCCESS)
                    {
                        DWORD iValue = 0;
                        WCHAR t_logname[MAX_PATH+1];
                        DWORD t_lognameSize = MAX_PATH;
                        //grant access and set false if a failure occurs...
                        t_Status = S_OK;

                        // read all entries under this key to find all logfiles...
                        while ((t_lErr = RegEnumKey(hkResult, iValue, t_logname, t_lognameSize)) != ERROR_NO_MORE_ITEMS)
                        {
                            // if error during read
                            if (t_lErr != ERROR_SUCCESS)
                            {
                                // indicate error
                                t_Status = WBEM_E_ACCESS_DENIED;
                                break;
                            }

                            //open logfile
                            DWORD t_dwReason = 0;
                            HANDLE t_hEvtlog = CEventLogFile::OpenLocalEventLog(t_logname, &t_dwReason);

                            if (t_hEvtlog == NULL)
                            {
                                if (t_dwReason != ERROR_FILE_NOT_FOUND)
                                {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::AccessCheck - Failed to verify logfile access\r\n");
)
                                    t_Status = WBEM_E_ACCESS_DENIED;
                                    break;
                                }
                                else
                                {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::AccessCheck - Logfile not found assuming access allowed for log\r\n");
)
                                }
                            }
                            else
                            {
                                CloseEventLog(t_hEvtlog);
                            }

                            // read next parameter
                            iValue++;

                        } // end while

                        RegCloseKey(hkResult);
                    }
                }

                t_wsVals.RemoveAll();
                delete pNewExpr;
            }

            delete pExpr;
        }

        WbemCoRevertToSelf();

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Leaving CNTEventProvider::AccessCheck\r\n");
)
    }
    catch(Structured_Exception e_SE)
    {
        WbemCoRevertToSelf();
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        WbemCoRevertToSelf();
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        WbemCoRevertToSelf();
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

STDMETHODIMP CNTEventProvider::Initialize (
                LPWSTR pszUser,
                LONG lFlags,
                LPWSTR pszNamespace,
                LPWSTR pszLocale,
                IWbemServices *pCIMOM,         // For anybody
                IWbemContext *pCtx,
                IWbemProviderInitSink *pInitSink     // For init signals
                )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::Initialize\r\n");
)
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
		if (GlobalSIDsOK())
		{
			m_pNamespace = pCIMOM;
			m_pNamespace->AddRef();
			m_Mgr->SetFirstSinceLogon(pCIMOM, pCtx);
			pInitSink->SetStatus ( WBEM_S_INITIALIZED , 0 );
		}
		else
		{
			pInitSink->SetStatus ( WBEM_E_UNEXPECTED , 0 );
		}
    

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
            L"Leaving CNTEventProvider::Initialize with SUCCEEDED\r\n");
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

STDMETHODIMP CNTEventProvider::ProvideEvents(IWbemObjectSink* pSink, LONG lFlags)
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"Entering CNTEventProvider::ProvideEvents\r\n");
)

        m_pEventSink = pSink;
        m_pEventSink->AddRef();
        
        if (!m_Mgr->Register(this))
        {

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
            L"Leaving CNTEventProvider::ProvideEvents with FAILED\r\n");
)

            return WBEM_E_FAILED;
        }

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
            L"Leaving CNTEventProvider::ProvideEvents with SUCCEEDED\r\n");
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}


CNTEventProvider::~CNTEventProvider()
{
    if (m_pNamespace != NULL)
    {
        m_pNamespace->Release();
    }

    if (m_pEventSink != NULL)
    {
        m_pEventSink->Release();    
    }
}


CNTEventProvider::CNTEventProvider(CEventProviderManager* mgr) : m_pNamespace(NULL), m_pEventSink(NULL)
{
    m_Mgr = mgr;
    m_ref = 0;
}


IWbemServices* CNTEventProvider::GetNamespace()
{
    m_pNamespace->AddRef();
    return m_pNamespace;
}

IWbemObjectSink* CNTEventProvider::GetEventSink()
{
    m_pEventSink->AddRef();
    return m_pEventSink;
}
void CNTEventProvider::ReleaseAll()
{
    //release dependencies
    m_pNamespace->Release();
    m_pEventSink->Release();
    Release();
}

void  CNTEventProvider::AddRefAll()
{
    //addref dependencies
    m_pNamespace->AddRef();
    m_pEventSink->AddRef();
    AddRef();
}

STDMETHODIMP_( ULONG ) CNTEventProvider::AddRef()
{
    SetStructuredExceptionHandler seh;

    try
    {
        InterlockedIncrement(&(CNTEventProviderClassFactory::objectsInProgress));
        return InterlockedIncrement ( &m_ref ) ;
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }

}

STDMETHODIMP_(ULONG) CNTEventProvider::Release()
{
    SetStructuredExceptionHandler seh;

    try
    {
        long ret;

        if ( 0 == (ret = InterlockedDecrement(&m_ref)) )
        {
            delete this;
        }
        else if ( 1 == ret )
        {
            m_Mgr->UnRegister(this);
        }

        InterlockedDecrement(&(CNTEventProviderClassFactory::objectsInProgress));
        return ret;
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

STDMETHODIMP CNTEventProvider::QueryInterface(REFIID riid, PVOID* ppv)
{
    SetStructuredExceptionHandler seh;

    try
    {
        *ppv = NULL;

        if (IID_IUnknown == riid)
        {
            *ppv=(IWbemEventProvider*)this;
        }
        else if (IID_IWbemEventProvider == riid)
        {
            *ppv=(IWbemEventProvider*)this;
        }
        else if (IID_IWbemProviderInit == riid)
        {
            *ppv= (IWbemProviderInit*)this;
        }
        else if (IID_IWbemEventProviderSecurity == riid)
        {
            *ppv= (IWbemEventProviderSecurity*)this;
        }

        if (NULL==*ppv)
        {
            return E_NOINTERFACE;
        }

        //AddRef any interface we'll return.
        ((LPUNKNOWN)*ppv)->AddRef();    
        return NOERROR;
    }
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtput.cpp ===
//***************************************************************************

//

//  NTEVTPUT.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the PutObject implementation

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"


BOOL PutInstanceAsyncEventObject :: PutInstance ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance\r\n"
        ) ;
)
    if (FAILED(m_ErrorObject.GetWbemStatus()))
    {
        return FALSE;
    }

    VARIANT v;
    VariantInit (&v);
    BOOL t_Status = SUCCEEDED(m_InstObject->Get(CLASS_PROP, 0, &v, NULL, NULL));

    if (( t_Status ) && (VT_BSTR == v.vt))
    {
        if ( _wcsicmp ( v.bstrVal , NTEVTLOG_CLASS) == 0 )
        {
            if ( t_Status )
            {
                t_Status =  Dispatch_EventLog ( a_ErrorObject ) ;
                
                if ( t_Status )
                {
                    m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                }
            }
            else
            {
            }
        }
        /*
        else if ( _wcsicmp ( v.bstrVal , some_other_class) == 0 )
        {
            if ( t_Status )
            {
                t_Status =  Dispatch_some_other_class ( a_ErrorObject ) ;
                
                if ( t_Status )
                {
                    m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE ;
                }
            }
            else
            {
            }
        }
        */
        else
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
            a_ErrorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE ) ;
            a_ErrorObject.SetMessage ( L"Dynamic NT Eventlog Provider does not support WRITE for this class" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Dynamic NT Eventlog Provider does not support WRITE for this class\r\n"
        ) ;
)
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_OBJECT ) ;
        a_ErrorObject.SetMessage ( L"Unable to obtain class name from object." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Unable to obtain class name from object.\r\n"
        ) ;
)
    }

    VariantClear(&v);
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:returning %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}


BOOL PutInstanceAsyncEventObject :: Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject )
{
    if (WBEM_FLAG_CREATE_ONLY == (m_OperationFlag & WBEM_FLAG_CREATE_ONLY))
    {
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_OPERATION ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE ) ;
        a_ErrorObject.SetMessage ( L"WBEM_FLAG_CREATE_ONLY is unsupported, modify only!" ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:WBEM_FLAG_CREATE_ONLY is unsupported, modify only!\r\n"
        ) ;
)

        return FALSE ;
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance\r\n"
        ) ;
)

    VARIANT v;
    VariantInit(&v);
    BOOL t_Status = SUCCEEDED(m_InstObject->Get(PROP_NAME, 0, &v, NULL, NULL));
    
    if (( t_Status ) && (VT_BSTR == v.vt))
    {
        CStringW log = CEventLogFile::GetLogName(v.bstrVal);

        if (log.IsEmpty())
        {
            t_Status = FALSE ;
            a_ErrorObject.SetStatus (WBEM_PROV_E_INVALID_CLASS ) ;
            a_ErrorObject.SetWbemStatus (WBEM_E_INVALID_OBJECT ) ;
            a_ErrorObject.SetMessage (L"Unable to find log file specified.");
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Unable to find log file specified.\r\n"
        ) ;
)
        }
        else
        {
            VariantClear(&v);
            VariantInit(&v);
            t_Status = SUCCEEDED(m_InstObject->Get(PROP_LOGNAME, 0, &v, NULL, NULL));
                
            if (( t_Status ) && (VT_BSTR == v.vt) && (0 == _wcsicmp(log, v.bstrVal)))
            {
                CEventlogFileAttributes evtLog(log);
                DWORD dwR = evtLog.UpdateRegistry(m_InstObject);

                if (ERROR_SUCCESS != dwR)
                {
                    t_Status = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                    wchar_t* buff = NULL;

                    if (0 == FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                            NULL, dwR, 0, (LPWSTR) &buff, 80, NULL))
                    {
                        DWORD x = GetLastError();
                        a_ErrorObject.SetMessage (L"Failed to write some (maybe all) data.");
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Failed to write some (maybe all) data.\r\n"
        ) ;
)
                    }
                    else
                    {
                        a_ErrorObject.SetMessage (buff) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:%s.\r\n",
        buff
        ) ;
)
                        LocalFree(buff);
                    }
                }
            }
            else
            {
                t_Status = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
                a_ErrorObject.SetMessage (L"Logfilename doesn't match name property (key)") ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Logfilename doesn't match name property (key)\r\n"
        ) ;
)
            }
        }
    }
    else
    {
        t_Status = FALSE ;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS ) ;
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_OBJECT ) ;
        a_ErrorObject.SetMessage ( L"Unable to obtain key property from object." ) ;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:Unable to obtain key property from object.\r\n"
        ) ;
)
    }

    VariantClear(&v);
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->Write (  

        _T(__FILE__),__LINE__,
        L"PutInstanceAsyncEventObject :: PutInstance:returning %lx\r\n",
        t_Status
        ) ;
)

    return t_Status ;
}

PutInstanceAsyncEventObject :: PutInstanceAsyncEventObject (

    CImpNTEvtProv *a_Provider , 
    IWbemClassObject* a_Inst ,
    ULONG a_OperationFlag ,
    IWbemObjectSink *a_NotificationHandler ,
    IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
    m_InstObject ( NULL ) 
{
    m_InstObject = a_Inst ;

    if (m_InstObject != NULL)
    {
        m_InstObject->AddRef();
    }
}

PutInstanceAsyncEventObject :: ~PutInstanceAsyncEventObject () 
{
// Get Status object
    IWbemClassObject *t_NotifyStatus = NULL ;
    BOOL t_Status = TRUE;
    
    if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
    {
        t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
    }

    if ( t_Status )
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , t_NotifyStatus ) ;

        if (t_NotifyStatus)
        {
            t_NotifyStatus->Release () ;
        }
    }
    else
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , 0 , NULL ) ;
    }

    if (m_InstObject != NULL)
    {
        m_InstObject->Release();
    }

}


void PutInstanceAsyncEventObject :: Process () 
{
    PutInstance ( m_ErrorObject ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ole2.h>
#include <windows.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <cominit.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>

#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif
#include <ntevtdefs.h>

#include <ntevtserv.h>
#include <ntevtprov.h>
#include <ntevtthrd.h>
#include <ntevtinst.h>
#include <ntevtcfac.h>
#include <ntevtlogf.h>
#include <ntevtlogr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtcfac.h ===
//***************************************************************************

//

//  NTEVTCFAC.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTCFAC_H
#define _NT_EVT_PROV_NTEVTCFAC_H

/////////////////////////////////////////////////////////////////////////
// This class is the class factory for the event provider.

class CNTEventProviderClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CNTEventProviderClassFactory () ;
    ~CNTEventProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) = 0;
    STDMETHODIMP LockServer ( BOOL ) ;
};

class CNTEventlogEventProviderClassFactory : public CNTEventProviderClassFactory
{
public:
	//IClassFactory members
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * );
};

class CNTEventlogInstanceProviderClassFactory : public CNTEventProviderClassFactory
{
public:
	//IClassFactory members
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * );
};

#endif //_NT_EVT_PROV_NTEVTCFAC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevttask.cpp ===
//***************************************************************************

//

//  NTEVTQUERY.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the taskobject implementation

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"


WbemTaskObject :: WbemTaskObject (

    CImpNTEvtProv *a_Provider ,
    IWbemObjectSink *a_NotificationHandler ,
    ULONG a_OperationFlag ,
    IWbemContext *a_Ctx

) : m_State ( WBEM_TASKSTATE_START ) ,
    m_OperationFlag ( a_OperationFlag ) ,
    m_Provider ( a_Provider ) ,
    m_NotificationHandler ( a_NotificationHandler ) ,
    m_Ctx ( a_Ctx ) ,
    m_RequestHandle ( 0 ) ,
    m_ClassObject ( NULL ) ,
	m_AClassObject ( NULL )
{
//No need to AddRef these 'cos our lifetime is less than the the function creating us!!
//  m_Provider->AddRef () ;
//  m_NotificationHandler->AddRef () ;
//  m_Ctx->AddRef () ;

    HRESULT hr = CImpNTEvtProv::GetImpersonation();

    if (FAILED(hr))
    {
        //either FAILED or ACCESS_DENIED
        if (hr == WBEM_E_FAILED)
        {
            m_ErrorObject.SetStatus (WBEM_PROV_E_FAILED);
            m_ErrorObject.SetWbemStatus (WBEM_E_FAILED);
            m_ErrorObject.SetMessage (L"Failed to impersonate client");
        }
        else
        {
            m_ErrorObject.SetStatus (WBEM_PROV_E_ACCESS_DENIED);
            m_ErrorObject.SetWbemStatus (WBEM_E_ACCESS_DENIED);
            m_ErrorObject.SetMessage (L"Access denied, impersonation level too low");
        }
    }

}

WbemTaskObject :: ~WbemTaskObject ()
{
//Didn't AddRef so don't Release
//  m_Provider->Release () ;
//  m_NotificationHandler->Release () ;
//  m_Ctx->Release () ;

    if ( m_ClassObject )
        m_ClassObject->Release () ;

	if ( m_AClassObject )
		m_AClassObject->Release () ;

    WbemCoRevertToSelf();
}

WbemProvErrorObject &WbemTaskObject :: GetErrorObject ()
{
    return m_ErrorObject ; 
}   

BOOL WbemTaskObject :: GetClassObject ( BSTR a_Class )
{
	BOOL retVal = FALSE;

	IWbemServices *t_Server = m_Provider->GetServer() ;

	if (t_Server)
	{
		retVal = GetClassObject(a_Class, FALSE, t_Server, m_Ctx, &m_ClassObject);

		if (retVal)
		{
			GetClassObject(a_Class, TRUE, t_Server, m_Ctx, &m_AClassObject);
		}

		t_Server->Release () ;
	}

	return retVal;
}

BOOL WbemTaskObject :: GetClassObject ( BSTR a_Class, BOOL a_bAmended, IWbemServices *a_Server, IWbemContext *a_Ctx, IWbemClassObject **a_ppClass )
{
	DWORD dwIndex = NT_EVTLOG_MAX_CLASSES;
	BOOL retVal = FALSE;

	if (a_Class && a_ppClass)
	{
		if (_wcsicmp(a_Class, NTEVT_CLASS) == 0)
		{
			dwIndex = a_bAmended ? 0 : 1;
		}
		else if (_wcsicmp(a_Class, NTEVTLOG_CLASS) == 0)
		{
			dwIndex = a_bAmended ? 2 : 3;
		}
		else if (_wcsicmp(a_Class, ASSOC_LOGRECORD) == 0)
		{
			dwIndex = 4;
		}
		else if (_wcsicmp(a_Class, ASSOC_USERRECORD) == 0)
		{
			dwIndex = 5;
		}
		else if (_wcsicmp(a_Class, ASSOC_COMPRECORD) == 0)
		{
			dwIndex = 6;
		}

		if (dwIndex < NT_EVTLOG_MAX_CLASSES)
		{
			if (g_ClassArray[dwIndex] == NULL)
			{
				if (SUCCEEDED(a_Server->GetObject (

					a_Class ,
					a_bAmended ? WBEM_FLAG_USE_AMENDED_QUALIFIERS : 0 ,
					a_Ctx,
					a_ppClass,
					NULL 
				) ))
				{
					g_ClassArray[dwIndex] = *a_ppClass ;
					g_ClassArray[dwIndex]->AddRef() ;
					retVal = TRUE;
				}
			}
			else
			{
				*a_ppClass = g_ClassArray[dwIndex];
				(*a_ppClass)->AddRef();
				retVal = TRUE;
			}
		}
	}

    return retVal;
}


BOOL WbemTaskObject :: GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
    IWbemClassObject *t_NotificationClassObject = NULL ;
    IWbemClassObject *t_ErrorObject = NULL ;

    BOOL t_Status = TRUE ;

    WbemProvErrorObject t_ErrorStatusObject ;
    if ( t_NotificationClassObject = m_Provider->GetExtendedNotificationObject ( t_ErrorStatusObject, m_Ctx ) )
    {
        HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
        if ( SUCCEEDED ( t_Result ) )
        {
            VARIANT t_Variant ;
            VariantInit ( &t_Variant ) ;

            t_Variant.vt = VT_I4 ;
            t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

            t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;
            VariantClear ( &t_Variant ) ;
#if 0
            if ( SUCCEEDED ( t_Result ) )
            {
                t_Variant.vt = VT_I4 ;
                t_Variant.lVal = m_ErrorObject.GetStatus () ;

                t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSCODE , 0 , & t_Variant , 0 ) ;
                VariantClear ( &t_Variant ) ;
#endif
                if ( SUCCEEDED ( t_Result ) )
                {
                    if ( m_ErrorObject.GetMessage () ) 
                    {
                        t_Variant.vt = VT_BSTR ;
                        t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;

                        t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;
                        VariantClear ( &t_Variant ) ;

                        if ( m_ErrorObject.GetPrivilegeFailed() )
                        {
                            if (m_ErrorObject.SetPrivRequiredVariant(t_Variant))
                            {
                                t_Result = (*a_NotifyObject)->Put(WBEM_PROPERTY_PRIVREQUIRED, 0, &t_Variant, 0);
                                VariantClear ( &t_Variant ) ;

                                if (SUCCEEDED(t_Result))
                                {
                                    if (m_ErrorObject.SetPrivFailedVariant(t_Variant))
                                    {
                                        t_Result = (*a_NotifyObject)->Put(WBEM_PROPERTY_PRIVNOTHELD, 0, &t_Variant, 0);
                                        VariantClear ( &t_Variant ) ;
                                    }
                                    else
                                    {
                                        t_Result = WBEM_E_FAILED;
                                    }
                                }
                            }
                            else
                            {
                                t_Result = WBEM_E_FAILED;
                            }
                        }

                        if ( ! SUCCEEDED ( t_Result ) )
                        {
                            (*a_NotifyObject)->Release () ;
                            *a_NotifyObject = NULL;
                            t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
                        }
                    }
                }
                else
                {
                    (*a_NotifyObject)->Release () ;
                    t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
                }
#if 0
            }
            else
            {
                (*a_NotifyObject)->Release () ;
                t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
            }
#endif
            t_NotificationClassObject->Release () ;
        }
        else
        {
            t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
        }
    }
    else
    {
        t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
    }

    return t_Status ;
}

BOOL WbemTaskObject :: GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
    IWbemClassObject *t_NotificationClassObject = NULL ;

    BOOL t_Status = TRUE ;

    WbemProvErrorObject t_ErrorStatusObject ;
    if ( t_NotificationClassObject = m_Provider->GetNotificationObject ( t_ErrorStatusObject, m_Ctx ) )
    {
        HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
        if ( SUCCEEDED ( t_Result ) )
        {
            VARIANT t_Variant ;
            VariantInit ( &t_Variant ) ;

            t_Variant.vt = VT_I4 ;
            t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

            t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;
            if ( SUCCEEDED ( t_Result ) )
            {
                if ( m_ErrorObject.GetMessage () ) 
                {
                    t_Variant.vt = VT_BSTR ;
                    t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;

                    t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;
                    VariantClear ( &t_Variant ) ;

                    if ( ! SUCCEEDED ( t_Result ) )
                    {
                        t_Status = FALSE ;
                        (*a_NotifyObject)->Release () ;
                        (*a_NotifyObject)=NULL ;
                    }
                }
            }
            else
            {
                (*a_NotifyObject)->Release () ;
                (*a_NotifyObject)=NULL ;
                t_Status = FALSE ;
            }

            VariantClear ( &t_Variant ) ;

            t_NotificationClassObject->Release () ;
        }
        else
        {
            t_Status = FALSE ;
        }
    }
    else
    {
        t_Status = FALSE ;
    }

    return t_Status ;
}

BOOL WbemProvErrorObject::SetPrivVariant ( VARIANT &a_V, DWORD dwVal )
{
    BOOL retVal = FALSE;
    SAFEARRAYBOUND rgsabound[1];
    SAFEARRAY* psa = NULL;
    rgsabound[0].lLbound = 0;
    VariantInit(&a_V);
    rgsabound[0].cElements = 0;

    if (dwVal & PROV_PRIV_BACKUP)
    {
        rgsabound[0].cElements++;
    }

    if (dwVal & PROV_PRIV_SECURITY)
    {
        rgsabound[0].cElements++;
    }

    if (rgsabound[0].cElements != 0)
    {
        psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
        BSTR* pBstr = NULL;

        if (NULL != psa)
        {
            if (SUCCEEDED(SafeArrayAccessData(psa, (void **)&pBstr)))
            {
                DWORD indx = 0;

                if (dwVal & PROV_PRIV_SECURITY)
                {
                    pBstr[indx++] = SysAllocString(SE_SECURITY_NAME);
                }

                if (dwVal & PROV_PRIV_BACKUP)
                {
                    pBstr[indx] = SysAllocString(SE_BACKUP_NAME);
                }

                SafeArrayUnaccessData(psa);
                a_V.vt = VT_ARRAY|VT_BSTR;
                a_V.parray = psa;
                retVal = TRUE;
            }
        }
    }

    if (!retVal)
    {
        VariantClear(&a_V);
    }

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtserv.cpp ===
//***************************************************************************

//

//  NTEVTSERV.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the WBEM locator and services interfaces

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpNTEvtProv ::CImpNTEvtProv
// CImpNTEvtProv ::~CImpNTEvtProv
//
//***************************************************************************

CImpNTEvtProv ::CImpNTEvtProv () 
 :  m_localeId ( NULL ) ,
    m_Namespace ( NULL ) ,
    m_Server ( NULL ) ,
    m_NotificationClassObject ( NULL ) ,
    m_ExtendedNotificationClassObject ( NULL )
{
    m_ReferenceCount = 0 ;
     
    InterlockedIncrement ( & CNTEventProviderClassFactory :: objectsInProgress ) ;

/*
 * Implementation
 */

    m_Initialised = FALSE ;
    m_GetNotifyCalled = FALSE ;
    m_GetExtendedNotifyCalled = FALSE ;

}

CImpNTEvtProv ::~CImpNTEvtProv(void)
{
    delete [] m_localeId ;
    delete [] m_Namespace ;

    if ( m_Server ) 
        m_Server->Release () ;

    if ( m_NotificationClassObject )
        m_NotificationClassObject->Release () ;

    if ( m_ExtendedNotificationClassObject )
        m_ExtendedNotificationClassObject->Release () ;

    InterlockedDecrement ( & CNTEventProviderClassFactory :: objectsInProgress ) ;
}

//***************************************************************************
//
// CImpNTEvtProv ::QueryInterface
// CImpNTEvtProv ::AddRef
// CImpNTEvtProv ::Release
//
// Purpose: IUnknown members for CImpNTEvtProv object.
//***************************************************************************

STDMETHODIMP CImpNTEvtProv ::QueryInterface (

    REFIID iid , 
    LPVOID FAR *iplpv 
) 
{
    SetStructuredExceptionHandler seh;

    try
    {
        *iplpv = NULL ;

        if ( iid == IID_IUnknown )
        {
            *iplpv = ( IWbemServices* ) this ;
        }
        else if ( iid == IID_IWbemServices )
        {
            *iplpv = ( IWbemServices* ) this ;      
        }
        else if ( iid == IID_IWbemProviderInit )
        {
            *iplpv = ( IWbemProviderInit* ) this ;      
        }
        

        if ( *iplpv )
        {
            ( ( LPUNKNOWN ) *iplpv )->AddRef () ;

            return S_OK ;
        }
        else
        {
            return E_NOINTERFACE ;
        }
    }
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP_(ULONG) CImpNTEvtProv ::AddRef(void)
{
    SetStructuredExceptionHandler seh;

    try
    {
        return InterlockedIncrement ( & m_ReferenceCount ) ;
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

STDMETHODIMP_(ULONG) CImpNTEvtProv ::Release(void)
{
    SetStructuredExceptionHandler seh;

    try
    {
        LONG t_Ref ;
        if ( ( t_Ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
        {
            delete this ;
            return 0 ;
        }
        else
        {
            return t_Ref ;
        }
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

IWbemServices *CImpNTEvtProv :: GetServer () 
{ 
    if ( m_Server )
        m_Server->AddRef () ; 

    return m_Server ; 
}

void CImpNTEvtProv :: SetLocaleId ( wchar_t *localeId )
{
    m_localeId = UnicodeStringDuplicate ( localeId ) ;
}

wchar_t *CImpNTEvtProv :: GetNamespace () 
{
    return m_Namespace ; 
}

void CImpNTEvtProv :: SetNamespace ( wchar_t *a_Namespace ) 
{
    m_Namespace = UnicodeStringDuplicate ( a_Namespace ) ; 
}

IWbemClassObject *CImpNTEvtProv :: GetNotificationObject (
                                        WbemProvErrorObject &a_errorObject,
                                        IWbemContext *pCtx
                                    ) 
{
    if ( m_NotificationClassObject )
    {
        m_NotificationClassObject->AddRef () ;
    }
    else
    {
        BOOL t_Status = CreateNotificationObject ( a_errorObject, pCtx ) ;
        if ( t_Status )
        {
/* 
 * Keep around until we close
 */
            m_NotificationClassObject->AddRef () ;
        }

    }

    return m_NotificationClassObject ; 
}

IWbemClassObject *CImpNTEvtProv :: GetExtendedNotificationObject (
                                        WbemProvErrorObject &a_errorObject,
                                        IWbemContext *pCtx
                                    ) 
{
    if ( m_ExtendedNotificationClassObject )
    {
        m_ExtendedNotificationClassObject->AddRef () ;
    }
    else
    {
        BOOL t_Status = CreateExtendedNotificationObject ( a_errorObject, pCtx ) ;
        if ( t_Status )
        {
/* 
 * Keep around until we close
 */
            m_ExtendedNotificationClassObject->AddRef () ;
        }
    }

    return m_ExtendedNotificationClassObject ; 
}

BOOL CImpNTEvtProv :: CreateExtendedNotificationObject ( 

    WbemProvErrorObject &a_errorObject,
    IWbemContext *pCtx
)
{
    m_ExtendedNotifyLock.Lock();
    BOOL t_Status = TRUE ;

    if ( m_GetExtendedNotifyCalled )
    {
        if ( !m_ExtendedNotificationClassObject )
            t_Status = FALSE ;
    }
    else
    {
        m_GetExtendedNotifyCalled = TRUE ;
		BSTR t_clsStr = SysAllocString(WBEM_CLASS_EXTENDEDSTATUS);

        HRESULT t_Result = m_Server->GetObject (

            t_clsStr ,
            0 ,
            pCtx,
            & m_ExtendedNotificationClassObject ,
            NULL 
    ) ;

		SysFreeString(t_clsStr);

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CreateExtendedNotificationObject :: ~CreateExtendedNotificationObject:  GetObject for %s returned %lx\r\n",
        WBEM_CLASS_EXTENDEDSTATUS, t_Result
        ) ;
)

        if ( ! SUCCEEDED ( t_Result ) )
        {
            t_Status = FALSE ;
            a_errorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
            a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
            a_errorObject.SetMessage ( L"Failed to get Win32_PrivilegesStatus" ) ;

            m_ExtendedNotificationClassObject = NULL ;
        }
    }

    m_ExtendedNotifyLock.Unlock();

    return t_Status ;
}

BOOL CImpNTEvtProv :: CreateNotificationObject ( 

    WbemProvErrorObject &a_errorObject,
    IWbemContext *pCtx
)
{
    m_NotifyLock.Lock();
    BOOL t_Status = TRUE ;

    if ( m_GetNotifyCalled )
    {
        if ( !m_NotificationClassObject )
            t_Status = FALSE ;
    }
    else
    {
        m_GetNotifyCalled = TRUE ;
		BSTR t_clsStr = SysAllocString(WBEM_CLASS_EXTENDEDSTATUS);

        HRESULT t_Result = m_Server->GetObject (

            t_clsStr ,
            0 ,
            pCtx,
            & m_NotificationClassObject ,
            NULL
        ) ;

		SysFreeString(t_clsStr);

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CreateNotificationObject :: ~CreateNotificationObject:  GetObject for %s returned %lx\r\n",
        WBEM_CLASS_EXTENDEDSTATUS, t_Result
        ) ;
)

        if ( ! SUCCEEDED ( t_Result ) )
        {
            t_Status = FALSE ;
            a_errorObject.SetStatus ( WBEM_PROV_E_INVALID_OBJECT ) ;
            a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
            a_errorObject.SetMessage ( L"Failed to get Win32_PrivilegesStatus" ) ;
			m_NotificationClassObject = NULL;
        }
    }
    m_NotifyLock.Unlock();

    return t_Status ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CImpNTEvtProv :: CancelAsyncCall ( 
        
    IWbemObjectSink __RPC_FAR *pSink
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: QueryObjectSink ( 

    long lFlags,        
    IWbemObjectSink __RPC_FAR* __RPC_FAR* ppHandler
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: GetObject ( 
        
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR* __RPC_FAR *ppObject,
    IWbemCallResult __RPC_FAR* __RPC_FAR *ppCallResult
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: GetObjectAsync ( 
        
    const BSTR ObjectPath, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;

        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::GetObjectAsync ()" 
        ) ;
) 

/*
 * Create Asynchronous GetObjectByPath object
 */

        GetObjectAsyncEventObject t_AsyncEvent ( this , ObjectPath , lFlags , pHandler , pCtx ) ;
        t_AsyncEvent.Process () ;

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning from CImpNTEvtProv::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
            ObjectPath ,
            t_Status 
        ) ;
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

HRESULT CImpNTEvtProv :: PutClass ( 
        
    IWbemClassObject __RPC_FAR* pClass , 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemCallResult __RPC_FAR* __RPC_FAR* ppCallResult
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: PutClassAsync ( 
        
    IWbemClassObject __RPC_FAR* pClass, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

 HRESULT CImpNTEvtProv :: DeleteClass ( 
        
    const BSTR Class, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemCallResult __RPC_FAR* __RPC_FAR* ppCallResult
) 
{
     return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: DeleteClassAsync ( 
        
    const BSTR Class, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: CreateClassEnum ( 

    const BSTR Superclass, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

SCODE CImpNTEvtProv :: CreateClassEnumAsync (

    const BSTR Superclass, 
    long lFlags, 
    IWbemContext __RPC_FAR* pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: PutInstance (

    IWbemClassObject __RPC_FAR *pInstance,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
) 
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: PutInstanceAsync ( 
        
    IWbemClassObject __RPC_FAR* pInstance, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;

        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::PutInstanceAsync ()" 
        ) ;
) 

/*
 * Create Asynchronous GetObjectByPath object
 */

        PutInstanceAsyncEventObject t_AsyncEvent ( this , pInstance , lFlags , pHandler , pCtx ) ;
        t_AsyncEvent.Process();

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning from CImpNTEvtProv::PutInstanceAsync with Result = (%lx)" ,
            t_Status 
        ) ;
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

HRESULT CImpNTEvtProv :: DeleteInstance ( 

    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
)
{
    return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpNTEvtProv :: DeleteInstanceAsync (
 
    const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: CreateInstanceEnum ( 

    const BSTR Class, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx, 
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: CreateInstanceEnumAsync (

    const BSTR Class, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR* pHandler 

) 
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;


        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::CreateInstanceEnumAsync ( (%s) )" ,
            Class
        ) ;
)

/*
 * Create Synchronous Enum Instance object
 */
        CStringW QueryStr(ENUM_INST_QUERY_START);
        QueryStr += CStringW(Class);
        QueryStr += ENUM_INST_QUERY_MID;
        QueryStr += CStringW(Class);
        QueryStr += PROP_END_QUOTE;
        BSTR Query = QueryStr.AllocSysString();

        ExecQueryAsyncEventObject t_AsyncEvent ( this , WBEM_QUERY_LANGUAGE_SQL1 , Query , lFlags , pHandler , pCtx ) ;
        t_AsyncEvent.Process() ;

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning from CImpNTEvtProv::CreateInstanceEnumAsync ( (%s),(%s) ) with Result = (%lx)" ,
            Class,
            Query,
            t_Status 
        ) ;
)
        SysFreeString(Query);
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

HRESULT CImpNTEvtProv :: ExecQuery ( 

    const BSTR QueryLanguage, 
    const BSTR Query, 
    long lFlags, 
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpNTEvtProv :: ExecQueryAsync ( 
        
    const BSTR QueryFormat, 
    const BSTR Query, 
    long lFlags, 
    IWbemContext __RPC_FAR* pCtx,
    IWbemObjectSink __RPC_FAR* pHandler
) 
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;


        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::ExecQueryAsync ( (%s),(%s) )" ,
            QueryFormat ,
            Query 
        ) ;
)

/*
 * Create Synchronous Enum Instance object
 */
        pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, S_OK, NULL, NULL);

        ExecQueryAsyncEventObject t_AsyncEvent ( this , QueryFormat , Query , lFlags , pHandler , pCtx ) ;
        t_AsyncEvent.Process() ;

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning from CImpNTEvtProv::ExecqQueryAsync ( (%s),(%s) ) with Result = (%lx)" ,
            QueryFormat,
            Query,
            t_Status 
        ) ;
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

HRESULT CImpNTEvtProv :: ExecNotificationQuery ( 

    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
    return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpNTEvtProv :: ExecNotificationQueryAsync ( 
            
    const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
    return WBEM_E_NOT_AVAILABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpNTEvtProv :: ExecMethod( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR *pInParams,
    IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
)
{
    return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpNTEvtProv :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemClassObject __RPC_FAR *pInParams,
    IWbemObjectSink __RPC_FAR *pResponseHandler
) 
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;

        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::ExecMethodAsync ()" 
        ) ;
) 

/*
 * Create Asynchronous GetObjectByPath object
 */
        ExecMethodAsyncEventObject t_AsyncEvent ( this , ObjectPath , MethodName ,
                                                                lFlags , pInParams , pResponseHandler , pCtx ) ;
        t_AsyncEvent.Process() ;

DebugOut( 
        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning from CImpNTEvtProv::ExecMethodAsync ( (%s) ) with Result = (%lx)" ,
            ObjectPath ,
            t_Status 
        ) ;
)
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

        
HRESULT CImpNTEvtProv :: Initialize(

    LPWSTR pszUser,
    LONG lFlags,
    LPWSTR pszNamespace,
    LPWSTR pszLocale,
    IWbemServices *pCIMOM,         // For anybody
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink     // For init signals
)
{
    HRESULT t_Status = WBEM_NO_ERROR;
    SetStructuredExceptionHandler seh;

    try
    {
DebugOut( 

        CNTEventProvider::g_NTEvtDebugLog->Write (  

            L"\r\n"
        ) ;

        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"CImpNTEvtProv::Initialize "
        ) ;
)

        m_Server = pCIMOM ;
        m_Server->AddRef () ;

        m_NamespacePath.SetNamespacePath ( pszNamespace ) ;
    
DebugOut( 

        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

            _T(__FILE__),__LINE__,
            L"Returning From CImpPropProv::Initialize () "
        ) ;
)

        pInitSink->SetStatus ( WBEM_S_INITIALIZED , 0 ) ;   
    }
    catch(Structured_Exception e_SE)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Status = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Status = WBEM_E_UNEXPECTED;
    }

    return t_Status;
}

HRESULT STDMETHODCALLTYPE CImpNTEvtProv::OpenNamespace ( 

    const BSTR ObjectPath, 
    long lFlags, 
    IWbemContext FAR* pCtx,
    IWbemServices FAR* FAR* pNewContext, 
    IWbemCallResult FAR* FAR* ppErrorObject
)
{
    return WBEM_E_NOT_AVAILABLE ;
}


HRESULT CImpNTEvtProv::GetImpersonation()
{
    HRESULT hr = WBEM_E_FAILED;
    DWORD dwVersion = GetVersion();

    if ( (4 < (DWORD)(LOBYTE(LOWORD(dwVersion))))
        || ObtainedSerialAccess(CNTEventProvider::g_secMutex) )
    {
        if (SUCCEEDED(WbemCoImpersonateClient())) 
        {
            HANDLE hThreadTok;

            if ( !OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadTok) )
            {
                DWORD dwLastError = GetLastError();

                if (dwLastError == ERROR_NO_TOKEN)
                {
                    // If the CoImpersonate works, but the OpenThreadToken fails due to ERROR_NO_TOKEN, we
                    // are running under the process token (either local system, or if we are running
                    // with /exe, the rights of the logged in user).  In either case, impersonation rights
                    // don't apply.  We have the full rights of that user.

                    hr = WBEM_S_NO_ERROR;
                }
                else
                {
                    // If we failed to get the thread token for any other reason, an error.
                    hr = WBEM_E_ACCESS_DENIED;
                }
            } 
            else 
            {         
                DWORD dwImp;
                DWORD dwBytesReturned;

                // We really do have a thread token, so let's retrieve its level
                if (GetTokenInformation(hThreadTok, TokenImpersonationLevel, &dwImp,
                                            sizeof(DWORD), &dwBytesReturned)) 
                {
                      
                    // Is the impersonation level Impersonate?
                    if ((dwImp == SecurityImpersonation) || (dwImp == SecurityDelegation)) 
                    {
                        hr = WBEM_S_NO_ERROR;
                    } 
                    else 
                    {
                        hr = WBEM_E_ACCESS_DENIED;
                    }     
                } 
                  
                CloseHandle(hThreadTok);
            }

			if (FAILED(hr))
			{
				WbemCoRevertToSelf();
			}
        }

        if ( 5 > (DWORD)(LOBYTE(LOWORD(dwVersion))) )
        {
            ReleaseSerialAccess(CNTEventProvider::g_secMutex);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtthrd.cpp ===
//***************************************************************************

//

//  NTEVTTHRD.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the thread which listens for events and processes

//              them.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"

#include <winperf.h>
#include <time.h>
#include <wbemtime.h>

#define NUM_THREADS 1
const DWORD CEventLogMonitor::m_PollTimeOut = 60000;    // 10 minute poll period
extern CCriticalSection g_ProvLock;


CEventProviderManager::CEventProviderManager() : m_IsFirstSinceLogon (FALSE), m_monitorArray (NULL)
{
    ProvThreadObject::Startup();
}

CEventProviderManager::~CEventProviderManager()
{
    ProvThreadObject::Closedown();
}

BOOL CEventProviderManager::Register(CNTEventProvider* prov)
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::Register\r\n");
)

    BOOL retVal = FALSE;
    BOOL bUnReg = FALSE;

    if (m_MonitorLock.Lock())
    {
        if (m_ControlObjects.Lock())
        {
            prov->AddRefAll();
            m_ControlObjects.SetAt((UINT_PTR)prov, prov);
            m_ControlObjects.Unlock();
            bUnReg = TRUE;

            if (NULL == m_monitorArray)
            {
                InitialiseMonitorArray();
            }
        
            if (NULL != m_monitorArray)
            {
                for (int x=0; x < NUM_THREADS; x++)
                {
                    if ( m_monitorArray[x]->IsMonitoring() )
                    {
                        //at least one monitor is working
                        retVal = TRUE;

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventProviderManager::Register:Successfully monitoring monitor %lx : \r\n" ,
        x
    ) ;
)

                        break;
                    }
                    else
                    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventProviderManager::Register:Not monitoring monitor %lx : \r\n" ,
        x
    ) ;
)

                    }
                }
            }
        }

        m_MonitorLock.Unlock();
    }
    else
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventProviderManager::Register:Failed to lock monitor: \r\n"
    ) ;
)

        return FALSE;
    }

    if ((!retVal) && (bUnReg))
    {
        UnRegister(prov);
    }
    
    return retVal;
}

void CEventProviderManager::UnRegister(CNTEventProvider* prov)
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::UnRegister\r\n");
)

    BOOL bDestroyMonitorArray = FALSE;

    if (m_MonitorLock.Lock())
    {
        if (m_ControlObjects.Lock())
        {
            if (m_ControlObjects.RemoveKey((UINT_PTR)prov))
            {
                prov->ReleaseAll();
                
                if (m_ControlObjects.IsEmpty() && (NULL != m_monitorArray))
                {
                    bDestroyMonitorArray = TRUE;
                }
            }

            m_ControlObjects.Unlock();

            if (bDestroyMonitorArray)
            {
                DestroyMonitorArray();
                m_monitorArray = NULL;
            }   
        }

        m_MonitorLock.Unlock();
    }
}

IWbemServices* CEventProviderManager::GetNamespacePtr()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::GetNamespacePtr\r\n");
)

    IWbemServices* retVal = NULL;

    if (m_ControlObjects.Lock())
    {
        POSITION pos = m_ControlObjects.GetStartPosition();

        if (pos)
        {
            CNTEventProvider* pCntrl;
            UINT_PTR key;
            m_ControlObjects.GetNextAssoc(pos, key, pCntrl);
            retVal = pCntrl->GetNamespace();
        }

        m_ControlObjects.Unlock();
    }

    return retVal;
}

void CEventProviderManager::SendEvent(IWbemClassObject* evtObj)
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::SendEvent\r\n");
)

    if (evtObj == NULL) 
    {
        return;
    }

    //copy the list of control objects to minimize amount of work
    //done in locked section of code. also cannot call into webm
    //in blocked code may cause deadlock if webnm calls back.
    CList<CNTEventProvider*, CNTEventProvider*> controlObjects;

    if (m_ControlObjects.Lock())
    {
        POSITION pos = m_ControlObjects.GetStartPosition();

        while (NULL != pos)
        {
            CNTEventProvider* pCntrl;
            UINT_PTR key;
            m_ControlObjects.GetNextAssoc(pos, key, pCntrl);
            pCntrl->AddRefAll();
            controlObjects.AddTail(pCntrl);
        }

        m_ControlObjects.Unlock();
    }
    else
    {
        return;
    }

    //loop through the different control objects and send the event to each
    while (!controlObjects.IsEmpty())
    {
        CNTEventProvider* pCntrl = controlObjects.RemoveTail();
        IWbemServices* ns = pCntrl->GetNamespace();
        IWbemObjectSink* es = pCntrl->GetEventSink();
        es->Indicate(1, &evtObj);
        es->Release();
        ns->Release();
        pCntrl->ReleaseAll();
    }
}

BOOL CEventProviderManager::InitialiseMonitorArray()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::InitialiseMonitorArray\r\n");
)

    // open registry for log names
    HKEY hkResult;
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            EVENTLOG_BASE, 0,
                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                            &hkResult);

    if (status != ERROR_SUCCESS)
    {
        DWORD t_LastError = GetLastError () ;

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventProviderManager::InitialiseMonitorArray:Failed to open registry key %s , %lx: \r\n" ,
        EVENTLOG_BASE ,
        status
    ) ;
)

        // indicate error
        return FALSE;
    }

    DWORD iValue = 0;
    WCHAR logname[MAX_PATH+1];
    DWORD lognameSize = MAX_PATH;
    CArray<CStringW*, CStringW*> logfiles;

    //usually three logfiles, grow in 10s!
    logfiles.SetSize(3, 10); 

    // read all entries under this key to find all logfiles...
    while ((status = RegEnumKey(hkResult, iValue, logname, lognameSize)) != ERROR_NO_MORE_ITEMS)
    {
        // if error during read
        if (status != ERROR_SUCCESS)
        {
            RegCloseKey(hkResult);

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventProviderManager::InitialiseMonitorArray:Failed to enumerate registry subkeys %s : \r\n" ,
        EVENTLOG_BASE
    ) ;
)
            // indicate error
            return FALSE;
        }

        //store the logfilename
        CStringW* logfile = new CStringW(logname);
        logfiles.SetAtGrow(iValue, logfile);
        
        // read next parameter
        iValue++;

    } // end while

    RegCloseKey(hkResult);
    m_monitorArray = new CEventLogMonitor*[NUM_THREADS];
	memset(m_monitorArray, 0, NUM_THREADS * sizeof(CEventLogMonitor*));

    //use the array
#if NUM_THREADS > 1
//multi-threaded monitor
    
    //TO DO: Partition the eventlogs to the monitors
    //and start each monitor

#else
//single threaded monitor
	try
	{
		m_monitorArray[0] = new CEventLogMonitor(this, logfiles);
		m_monitorArray[0]->AddRef();
		(*m_monitorArray)->BeginThread();
		(*m_monitorArray)->WaitForStartup();
		(*m_monitorArray)->StartMonitoring();
	}
	catch (...)
	{
		if (m_monitorArray[0])
		{
			m_monitorArray[0]->Release();
		}

		delete [] m_monitorArray;
		m_monitorArray = NULL;
		throw;
	}
#endif

    //delete array contents AFTER threads startup!
    LONG count = logfiles.GetSize();

    if (count > 0)
    {
        for (LONG x = 0; x < count; x++)
        {
            delete logfiles[x];
        }
        
        logfiles.RemoveAll();
    }

    return TRUE;
}

void CEventProviderManager::DestroyMonitorArray()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::DestroyMonitorArray\r\n");
)

    if (NULL != m_monitorArray)
    {
        for (int x=0; x < NUM_THREADS; x++)
        {
			m_monitorArray[x]->PostSignalThreadShutdown();
			m_monitorArray[x]->Release();
			m_monitorArray[x] = NULL;
        }
        
        delete [] m_monitorArray;
        m_monitorArray = NULL;
    }
}

BSTR CEventProviderManager::GetLastBootTime()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::GetLastBootTime\r\n");
)
    if (!m_BootTimeString.IsEmpty())
    {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventProviderManager::GetLastBootTime returning %s\r\n",
        m_BootTimeString
        );
)

        return m_BootTimeString.AllocSysString();
    }

    HKEY hKeyPerflib009;
    BSTR retStr = NULL;
	
	SYSTEM_TIMEOFDAY_INFORMATION t_TODInformation;

	if ( NT_SUCCESS(NtQuerySystemInformation(SystemTimeOfDayInformation,
								&t_TODInformation,
								sizeof(t_TODInformation),
								NULL)) )
	{
		FILETIME t_ft;
		memcpy(&t_ft, &t_TODInformation.BootTime, sizeof(t_TODInformation.BootTime));
		WBEMTime wbemboottime(t_ft);
		retStr = wbemboottime.GetDMTF(TRUE);
		m_BootTimeString = (LPCWSTR)(retStr);
	}

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"Returning from CEventProviderManager::GetLastBootTime with %s",
        (retStr == NULL ? L"NULL": retStr)
        ) ;
)

    return retStr;
}

void CEventProviderManager :: SetFirstSinceLogon(IWbemServices* ns, IWbemContext *pCtx)
{
    BSTR boottmStr = GetLastBootTime();

    if (boottmStr == NULL)
    {
        return;
    }

    IWbemClassObject* pObj = NULL; 
	BSTR bstrPath = SysAllocString (CONFIG_INSTANCE);
    HRESULT hr = ns->GetObject(bstrPath, 0, pCtx, &pObj, NULL);
	SysFreeString(bstrPath);

    if (FAILED(hr))
    {
		bstrPath = SysAllocString (CONFIG_CLASS);
        hr = ns->GetObject(bstrPath, 0, pCtx, &pObj, NULL);
		SysFreeString(bstrPath);

        if (FAILED(hr))
        {
DebugOut( 
            CNTEventProvider::g_NTEvtDebugLog->Write (  

                L"\r\n"
            ) ;

            CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                _T(__FILE__),__LINE__,
                L"CEventProviderManager :: IsFirstSinceLogon: Failed to get config class" 
            ) ;
) 
        }
        else
        {
            IWbemClassObject* pInst = NULL;
            hr = pObj->SpawnInstance(0, &pInst);
            pObj->Release();

            if (FAILED(hr))
            {
DebugOut( 
            CNTEventProvider::g_NTEvtDebugLog->Write (  

                L"\r\n"
            ) ;

            CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                _T(__FILE__),__LINE__,
                L"CEventProviderManager :: IsFirstSinceLogon: Failed to spawn config instance" 
            ) ;
) 
            }
            else
            {
                VARIANT v;
                VariantInit(&v);
                v.vt = VT_BSTR;
                v.bstrVal = SysAllocString(boottmStr);;
                hr = pInst->Put(LAST_BOOT_PROP, 0, &v, 0);
                VariantClear(&v);

                if (FAILED(hr))
                {
DebugOut( 
                    CNTEventProvider::g_NTEvtDebugLog->Write (  

                        L"\r\n"
                    ) ;

                    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                        _T(__FILE__),__LINE__,
                        L"CEventProviderManager :: IsFirstSinceLogon: Failed to put config property" 
                    ) ;
) 

                }
                else
                {
                    hr = ns->PutInstance(pInst, WBEM_FLAG_CREATE_ONLY, pCtx, NULL);

                    if (FAILED(hr))
                    {
DebugOut( 
                        CNTEventProvider::g_NTEvtDebugLog->Write (  

                            L"\r\n"
                        ) ;

                        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                            _T(__FILE__),__LINE__,
                            L"CEventProviderManager :: IsFirstSinceLogon: Failed to put new config instance" 
                        ) ;
) 
                    }
                    else
                    {
                        m_IsFirstSinceLogon = TRUE;
                    }

                }

                pInst->Release();
            }
        }
    }
    else
    {
        VARIANT v;
        hr = pObj->Get(LAST_BOOT_PROP, 0, &v, NULL, NULL);

        if (FAILED(hr))
        {
DebugOut( 
            CNTEventProvider::g_NTEvtDebugLog->Write (  

                L"\r\n"
            ) ;

            CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                _T(__FILE__),__LINE__,
                L"CEventProviderManager :: IsFirstSinceLogon: Failed to get config's last boot time from instance" 
            ) ;
) 
        }
        else
        {
            if (v.vt == VT_BSTR)
            {
                if (wcscmp(v.bstrVal, boottmStr) == 0)
                {
                }
                else
                {
                    VariantClear(&v);
                    VariantInit(&v);
                    v.vt = VT_BSTR;
                    v.bstrVal = SysAllocString(boottmStr);
                    hr = pObj->Put(LAST_BOOT_PROP, 0, &v, 0);

                    if (FAILED(hr))
                    {
DebugOut( 
                        CNTEventProvider::g_NTEvtDebugLog->Write (  

                            L"\r\n"
                        ) ;

                        CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                            _T(__FILE__),__LINE__,
                            L"CEventProviderManager :: IsFirstSinceLogon: Failed to put config property in instance" 
                        ) ;
) 

                    }
                    else
                    {
                        hr = ns->PutInstance(pObj, WBEM_FLAG_UPDATE_ONLY, pCtx, NULL);

                        if (FAILED(hr))
                        {
DebugOut( 
                            CNTEventProvider::g_NTEvtDebugLog->Write (  

                                L"\r\n"
                            ) ;

                            CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                                _T(__FILE__),__LINE__,
                                L"CEventProviderManager :: IsFirstSinceLogon: Failed to put config instance" 
                            ) ;
) 
                        }
                        else
                        {
                            m_IsFirstSinceLogon = TRUE;
                        }
                    }
                }
            }
            else
            {
DebugOut( 
                CNTEventProvider::g_NTEvtDebugLog->Write (  

                    L"\r\n"
                ) ;

                CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                    _T(__FILE__),__LINE__,
                    L"CEventProviderManager :: IsFirstSinceLogon: one (maybe both) boot times are of wrong type" 
                ) ;
) 
            }
            
            VariantClear(&v);
        }
        
        pObj->Release();
    }

    SysFreeString(boottmStr);
}


CEventLogMonitor::CEventLogMonitor(CEventProviderManager* parentptr, CArray<CStringW*, CStringW*>& logs)
: ProvThreadObject(EVENTTHREADNAME, m_PollTimeOut), m_LogCount(logs.GetSize()), m_Logs(NULL),
m_bMonitoring(FALSE), m_pParent(parentptr), m_Ref(0)
{
    if (g_ProvLock.Lock())
    {
        InterlockedIncrement(&(CNTEventProviderClassFactory::objectsInProgress));
        g_ProvLock.Unlock();
    }

	// create array from argument
    if (m_LogCount > 0)
    {
		//usually three logfiles, grow in 10s!
		m_LogNames.SetSize(3, 10); 

        for (LONG x = 0; x < m_LogCount; x++)
        {
			CStringW* logfile = new CStringW( * logs.GetAt ( x ) );
            m_LogNames.SetAtGrow(x, logfile);
		}
	}
}

CEventLogMonitor::~CEventLogMonitor()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventLogMonitor::~CEventLogMonitor\r\n");
)

    if (g_ProvLock.Lock())
    {
        InterlockedDecrement(&(CNTEventProviderClassFactory::objectsInProgress));
        g_ProvLock.Unlock();
    }

    //delete array contents
	LONG count = m_LogNames.GetSize();

    if (count > 0)
    {
        for (LONG x = 0; x < count; x++)
        {
            delete m_LogNames[x];
        }
        
        m_LogNames.RemoveAll();
    }
}

void CEventLogMonitor::Poll()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventLogMonitor::Poll\r\n");
)

    if (m_Logs != NULL)
    {
        for (ULONG x = 0; x < m_LogCount; x++)
        {
            if (m_Logs[x]->IsValid())
            {
                m_Logs[x]->Process();
            }
        }
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"leaving CEventLogMonitor::Poll\r\n");
)

}

void CEventLogMonitor::TimedOut()
{
    if (m_bMonitoring)
    {
        Poll();
    }
}

void CEventLogMonitor::StartMonitoring()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::StartMonitoring()"
        ) ;
)

    //single threaded monitor
    //cheat, check for logon event
    //if we go multi-threaded this will
    //have to be done by the manager

    if (m_Logs)
    {
        DWORD logtime = 0;
        
        if (m_pParent->IsFirstSinceLogon())
        {
            //find the System log
            for (ULONG x = 0; x < m_LogCount; x++)
            {
                if ((m_Logs[x]->IsValid()) && (0 == _wcsicmp(L"System", m_Logs[x]->GetLogName())))
                {
                    DWORD dwRecID;
                    logtime = m_Logs[x]->FindOldEvent(LOGON_EVTID, LOGON_SOURCE, &dwRecID, LOGON_TIME);
                    
                    if (0 != logtime)
                    {
                        m_Logs[x]->SetProcessRecord(dwRecID);
                        m_Logs[x]->Process();
                    }
                    else
                    {
                        if (!m_Logs[x]->IsValid())
                        {
                            m_Logs[x]->RefreshHandle();

                            if (m_Logs[x]->IsValid())
                            {
                                m_Logs[x]->ReadLastRecord();
                            }

                        }
                        else
                        {
                            m_Logs[x]->ReadLastRecord();
                        }
                    }

                    break;
                }
            }

            if (0 != logtime)
            {
                time_t tm;
                time(&tm);

                for (x = 0; x < m_LogCount; x++)
                {
                    if ((m_Logs[x]->IsValid()) && (0 != _wcsicmp(L"System", m_Logs[x]->GetLogName())))
                    {
                        DWORD dwRecID;
                        m_Logs[x]->FindOldEvent(0, NULL, &dwRecID, tm - logtime);

                        if (m_Logs[x]->IsValid())
                        {
                            m_Logs[x]->SetProcessRecord(dwRecID);
                            m_Logs[x]->Process();
                        }
                    }
                }
            }
        }
        
        //now start the monitors monitoring!
        for (ULONG x = 0; x < m_LogCount; x++)
        {
            if (m_Logs[x]->IsValid())
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::StartMonitoring() monitoring log %d of %d logs\r\n",
        x, m_LogCount
        ) ;
)

                ScheduleTask(*(m_Logs[x]));
            }
        }
    }
    
    m_bMonitoring = TRUE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"leaving CEventLogMonitor::StartMonitoring()\r\n"
        ) ;
)

}

void CEventLogMonitor::Initialise()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::Initialise\r\n"
        ) ;
)
	AddRef();
    InitializeCom();

    //for each logfilename create a logfile
    if (m_LogCount != 0)
    {
        m_Logs = new CMonitoredEventLogFile*[m_LogCount];
        BOOL bValid = FALSE;

        for (ULONG x = 0; x < m_LogCount; x++)
        {
            CStringW* tmp = m_LogNames.GetAt(x);
            m_Logs[x] = new CMonitoredEventLogFile(m_pParent, *tmp);

            if ( !( (m_Logs[x])->IsValid() ) )
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::Initialise logfile %d named %s is invalid\r\n",
        x, *tmp
        ) ;
)
            }
            else
            {
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::Initialise logfile %d named %s is valid\r\n",
        x, *tmp
        ) ;
)

                bValid = TRUE;
            }
        }

        if (!bValid)
        {
            delete [] m_Logs;
            m_Logs = NULL;
        }
    }
    else
    {
        //should never happen
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"CEventLogMonitor::Initialise() !!!NO LOGFILES TO MONITOR!!!\r\n"
        ) ;
)

    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"leaving CEventLogMonitor::Initialise()\r\n"
        ) ;
)

}


void CEventLogMonitor::Uninitialise()
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventLogMonitor::Uninitialise\r\n");
)
    if (m_Logs != NULL)
    {
        for (ULONG x = 0; x < m_LogCount; x++)
        {
            delete m_Logs[x];
        }

        delete [] m_Logs;
    }

    CoUninitialize();
    Release();

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine(_T(__FILE__),__LINE__,
        L"CEventLogMonitor::Uninitialise: Leaving method\r\n");
)
}

LONG CEventLogMonitor ::AddRef(void)
{
	return InterlockedIncrement ( & m_Ref ) ;
}

LONG CEventLogMonitor ::Release(void)
{
    LONG t_Ref ;

    if ( ( t_Ref = InterlockedDecrement ( & m_Ref ) ) == 0 )
    {
        delete this ;
        return 0 ;
    }
    else
    {
        return t_Ref ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtdefs.h ===
//***************************************************************************

//

//  NTEVTDEFS.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTDEFS_H
#define _NT_EVT_PROV_NTEVTDEFS_H

#define ELF_LOGFILE_READ             0x0001
#define ELF_LOGFILE_WRITE            0x0002
#define ELF_LOGFILE_CLEAR            0x0004
#define ELF_LOGFILE_START            0x0008
#define ELF_LOGFILE_STOP             0x000C
#define ELF_LOGFILE_CONFIGURE        0x0010
#define ELF_LOGFILE_BACKUP           0x0020

#define ELF_LOGFILE_ALL_ACCESS       (STANDARD_RIGHTS_REQUIRED       | \
                                         ELF_LOGFILE_READ            | \
                                         ELF_LOGFILE_WRITE           | \
                                         ELF_LOGFILE_CLEAR           | \
                                         ELF_LOGFILE_START           | \
                                         ELF_LOGFILE_STOP            | \
                                         ELF_LOGFILE_CONFIGURE)

#define ELF_LOGFILE_OBJECT_ACES		12            // Number of ACEs in this DACL
#define NT_EVTLOG_MAX_CLASSES		7	

#define SECURITY_MUTEX_NAME		L"Cimom NT Security API protector"
#define PERFORMANCE_MUTEX_NAME	L"WbemPerformanceDataMutex"

#define EVENTTHREADNAME			L"Eventlog Monitor"

BOOL ObtainedSerialAccess(CMutex* pLock);
void ReleaseSerialAccess(CMutex* pLock);

#define HKEYCLASSES		L"SOFTWARE\\Classes\\"

#define TYPE_ARRAY_LEN		5
#define RETENTION_ARRAY_LEN	3
typedef ULONG (*GetIndexFunc)(const wchar_t*, BOOL*);

#define WBEM_QUERY_LANGUAGE_SQL1 L"WQL"

#define LOGON_EVTID		2147489653
#define LOGON_SOURCE	L"eventlog"
#define LOGON_TIME		1800 //30 MINS

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define EVENT_CLASS		L"__InstanceCreationEvent"
#define SD_PROP			L"SECURITY_DESCRIPTOR"
#define TARGET_PROP		L"TargetInstance"
#define NTEVT_CLASS		L"Win32_NTLogEvent"
#define RECORD_PROP		L"RecordNumber"
#define	LOGFILE_PROP	L"Logfile"
#define EVTID_PROP		L"EventIdentifier"
#define EVTID2_PROP		L"EventCode"
#define SOURCE_PROP		L"SourceName"
#define TYPE_PROP		L"Type"
#define EVTTYPE_PROP	L"EventType"
#define CATEGORY_PROP	L"Category"
#define CATSTR_PROP		L"CategoryString"
#define GENERATED_PROP	L"TimeGenerated"
#define WRITTEN_PROP	L"TimeWritten"
#define COMPUTER_PROP	L"ComputerName"
#define USER_PROP		L"User"
#define MESSAGE_PROP	L"Message"
#define INSSTRS_PROP	L"InsertionStrings"
#define DATA_PROP		L"Data"
#define EVT_ENUM_QUAL	L"Values"
#define EVT_MAP_QUAL	L"ValueMap"

#define EVENTLOG_BASE	L"SYSTEM\\CurrentControlSet\\Services\\Eventlog"
#define	MSG_MODULE		L"EventMessageFile"
#define PARAM_MODULE	L"ParameterMessageFile"
#define PRIM_MODULE		L"PrimaryModule"
#define CAT_MODULE		L"CategoryMessageFile"
#define GUEST_ACCESS	L"RestrictGuestAccess"
#define SYSTEM_LOG		L"System"
#define SECURITY_LOG	L"Security"

// {F55C5B4C-517D-11d1-AB57-00C04FD9159E}
DEFINE_GUID(CLSID_CNTEventProviderClassFactory, 
0xf55c5b4c, 0x517d, 0x11d1, 0xab, 0x57, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);


#define WBEM_PROPERTY_STATUSCODE   L"StatusCode"
#define WBEM_PROPERTY_PROVSTATUSCODE   L"ProvStatusCode"
#define WBEM_PROPERTY_PROVSTATUSMESSAGE   L"Description"
#define WBEM_PROPERTY_PRIVNOTHELD   L"PrivilegesNotHeld"
#define WBEM_PROPERTY_PRIVREQUIRED   L"PrivilegesRequired"

#define CLASS_PROP		L"__CLASS"

#define EVTLOG_REG_FILE_VALUE		L"File"
#define EVTLOG_REG_RETENTION_VALUE	L"Retention"
#define EVTLOG_REG_MAXSZ_VALUE		L"MaxSize"
#define EVTLOG_REG_SOURCES_VALUE	L"Sources"

#define NTEVTLOG_CLASS				L"Win32_NTEventlogFile"
#define PROP_MAXSZ					L"MaxFileSize"
#define PROP_RETENTION				L"OverWriteOutDated"
#define PROP_LOGNAME				L"LogfileName"
#define PROP_NUMRECS				L"NumberOfRecords"
#define PROP_RETENTION_STR			L"OverWritePolicy"
#define PROP_SOURCES				L"Sources"

#define PROP_NAME					L"Name"

#define PROP_CS_CRE_CLASS			L"CSCreationClassName"
#define PROP_CRE_CLASS				L"CreationClassName"
#define PROP_FS_CRE_CLASS			L"FSCreationClassName"
#define PROP_FS_NAME				L"FSName"
#define VAL_FS_CRE_CLASS			L"Win32_FileSystem"

#ifdef VERSION_ISA_PROPERTY
#define PROP_VERSION				L"Version"
#endif

#define METHOD_RESOBJ				L"__Parameters"
#define METHOD_CLEAR				L"ClearEventlog"
#define METHOD_BACKUP				L"BackupEventlog"
#define METHOD_PARAM				L"ArchiveFileName"
#define METHOD_RESULT_PARAM			L"ReturnValue"

#define FILE_CHUNK_SZ				0x00010000
#define MAX_EVT_LOG_SZ				0xffff0000
#define MAX_EVT_AGE					365
#define EVT_NEVER_AGE				0xffffffff
#define EVT_UNITS_FROM_DAYS			(60*60*24)	//from days to seconds

#define CONFIG_CLASS		L"NTEventlogProviderConfig"
#define CONFIG_INSTANCE		L"NTEventlogProviderConfig=@"
#define COMP_CLASS			L"Win32_ComputerSystem"
#define LAST_BOOT_PROP		L"LastBootUpTime"
#define USER_CLASS			L"Win32_UserAccount"
#define ASSOC_LOGRECORD		L"Win32_NTLogEventLog"
#define ASSOC_USERRECORD	L"Win32_NTLogEventUser"
#define ASSOC_COMPRECORD	L"Win32_NTLogEventComputer"
#define REF_LOG				L"Log"
#define REF_REC				L"Record"
#define REF_USER			L"User"
#define REF_COMP			L"Computer"

#define PROP_DOMAIN			L"Domain"

#define PROP_START_LOG		CStringW(CStringW(NTEVTLOG_CLASS) + CStringW(L'.') + CStringW(PROP_NAME) + CStringW(L"=\""))
#define PROP_START_REC		CStringW(CStringW(NTEVT_CLASS) + CStringW(L'.') + CStringW(LOGFILE_PROP) + CStringW(L"=\""))
#define PROP_MID_REC		CStringW(CStringW(L"\",") + CStringW(RECORD_PROP) + CStringW(L'='))
#define PROP_START_COMP		CStringW(CStringW(COMP_CLASS) + CStringW(L".Name=\""))
#define PROP_START_USER		CStringW(CStringW(USER_CLASS) + CStringW(L".Domain=\""))
#define PROP_MID_USER		CStringW(L"\",Name=\"")

#define ENUM_INST_QUERY_START	CStringW(L"select * from ")
#define ENUM_INST_QUERY_MID		CStringW(L" where __CLASS = \"")

#define PROP_END_QUOTE		CStringW(L"\"")

// {D2E4F828-65E4-11d1-AB64-00C04FD9159E}
DEFINE_GUID(CLSID_CNTEventLocatorClassFactory, 
0xd2e4f828, 0x65e4, 0x11d1, 0xab, 0x64, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);

// {FD4F53E0-65DC-11d1-AB64-00C04FD9159E}
DEFINE_GUID(CLSID_CNTEventInstanceProviderClassFactory, 
0xfd4f53e0, 0x65dc, 0x11d1, 0xab, 0x64, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);

#endif //_NT_EVT_PROV_NTEVTDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\dll\ntevtquery.cpp ===
//***************************************************************************

//

//  NTEVTQUERY.CPP

//

//  Module: WBEM NT EVENT PROVIDER

//

//  Purpose: Contains the ExecQuery implementation

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <comdef.h>
#include <wbemtime.h>

#define NTEVT_DECPOS	14
#define NTEVT_SGNPOS	21
#define NTEVT_DMTFLEN	25

wchar_t* CheckForSpecialCharacters(const wchar_t* wstr)
{
    if (wstr == NULL)
    {
        return NULL;
    }

    int wstrlen = wcslen(wstr) * 2;
    wchar_t* ret = new wchar_t[wstrlen + 1];
    const wchar_t* tmp = wstr;
    int x = 0;

    while ((*tmp != L'\0') && (x < wstrlen))
    {
        if (*tmp == L'\\')
        {
            ret[x++] = L'\\';
        }
        
        ret[x++] = *tmp;
        tmp++;
    }

    ret[x] = L'\0';
    return ret;
}


BOOL GenerateAssocInstance ( WbemProvErrorObject &a_ErrorObject,
                                                         const wchar_t* objPath1,
                                                         const wchar_t* objPath2,
                                                         wchar_t* prop1,
                                                         wchar_t* prop2,
                                                         IWbemClassObject* pClassObject,
                                                         IWbemObjectSink* pNtfcnHandler,
														 BOOL *pbIndicated)
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GenerateAssocInstance\r\n"
        );
)

    IWbemClassObject* pInst = NULL;
    HRESULT result = pClassObject->SpawnInstance(0, &pInst);
    BOOL retVal = TRUE;

	if (pbIndicated)
	{
		*pbIndicated = FALSE;
	}

    if (FAILED(result))
    {
        retVal = FALSE;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
        a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
        a_ErrorObject.SetMessage ( L"Failed to spawn association instance." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GenerateAssocInstance:Failed to spawn association instance.\r\n"
        );
)
    }
    else
    {
        VARIANT v;
        VariantInit (&v);
        v.vt = VT_BSTR;
        v.bstrVal = SysAllocString(objPath1);
        HRESULT result = pInst->Put(prop1, 0, &v, 0);
        VariantClear(&v);

        if (FAILED(result))
        {
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            a_ErrorObject.SetMessage ( L"Failed to set association key property." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GenerateAssocInstance:Failed to set association key property\r\n"
        );
)
        }
        else
        {
            VariantInit (&v);
            v.vt = VT_BSTR;
            v.bstrVal = SysAllocString(objPath2);
            HRESULT result = pInst->Put(prop2, 0, &v, 0);
            VariantClear(&v);

            if (FAILED(result))
            {
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                a_ErrorObject.SetMessage ( L"Failed to set association key property." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GenerateAssocInstance:Failed to set association key property\r\n"
        );
)
            }
            else
            {
                result = pNtfcnHandler->Indicate ( 1, & pInst );
				
				if (FAILED(result))
				{
					retVal = FALSE;
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
					a_ErrorObject.SetMessage ( L"Failed to indicate association instance." );
				}
				else
				{
					if (pbIndicated)
					{
						*pbIndicated = TRUE;
					}
				}
            }
        }

        pInst->Release();
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"GenerateAssocInstance:returning %lx\r\n",
        retVal
        );
)
    return retVal;
}




BOOL ExecQueryAsyncEventObject :: OptimizeAssocQuery ( 
                                                      
    WbemProvErrorObject &a_ErrorObject, 
    BSTR *a_ObjectPath 
)
{
    *a_ObjectPath = NULL;

    BOOL t_Status = FALSE;
    
    SQL_LEVEL_1_TOKEN *pArrayOfTokens = m_RPNExpression->pArrayOfTokens;
    int nNumTokens = m_RPNExpression->nNumTokens;

    if ( ! pArrayOfTokens )
    {
        return t_Status;
    }

    if (( nNumTokens != 3 ) && ( nNumTokens != 1 ))
    {
        return t_Status;
    }

    if ( pArrayOfTokens [ 0 ].dwPropertyFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
    {
        return t_Status;
    }

    if ( pArrayOfTokens [ 0 ].dwConstFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
    {
        return t_Status;
    }

    if ( pArrayOfTokens [ 0 ].nTokenType != SQL_LEVEL_1_TOKEN :: OP_EXPRESSION )
    {
        return t_Status;
    }

    if ( pArrayOfTokens [ 0 ].vConstValue.vt != VT_BSTR )
    {
        return t_Status;
    }

    if ( pArrayOfTokens [ 0 ].vConstValue.bstrVal == NULL )
    {
        return t_Status;
    }

    if ( nNumTokens == 3 )
    {
        if ( pArrayOfTokens [ 1 ].dwPropertyFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
        {
            return t_Status;
        }

        if ( pArrayOfTokens [ 1 ].dwConstFunction != SQL_LEVEL_1_TOKEN :: IFUNC_NONE )
        {
            return t_Status;
        }

        if ( pArrayOfTokens [ 1 ].nTokenType != SQL_LEVEL_1_TOKEN :: OP_EXPRESSION )
        {
            return t_Status;
        }

        if ( pArrayOfTokens [ 1 ].vConstValue.vt != VT_BSTR )
        {
            return t_Status;
        }

        if ( pArrayOfTokens [ 1 ].vConstValue.bstrVal == NULL )
        {
            return t_Status;
        }

        if ( pArrayOfTokens [ 2 ].nTokenType != SQL_LEVEL_1_TOKEN :: TOKEN_OR )
        {
            return t_Status;
        }

        if (_wcsicmp(pArrayOfTokens[0].vConstValue.bstrVal, pArrayOfTokens[1].vConstValue.bstrVal) != 0)
        {
            return t_Status;
        }
    
        *a_ObjectPath = SysAllocString ( pArrayOfTokens [ 0 ].vConstValue.bstrVal );
        t_Status = TRUE;
    }
    else
    {
        *a_ObjectPath = SysAllocString ( pArrayOfTokens [ 0 ].vConstValue.bstrVal );
        t_Status = TRUE;
    }

    return t_Status;
}

wchar_t* ExecQueryAsyncEventObject :: GetClassFromPath(wchar_t* path)
{
    wchar_t* retVal = NULL;
    CObjectPathParser pathParser;
    ParsedObjectPath *parsedObjectPath = NULL;

    if (!pathParser.Parse(path, &parsedObjectPath))
    {
        retVal = UnicodeStringDuplicate(parsedObjectPath->m_pClass);
    }
    
    delete parsedObjectPath;
    return retVal;
}

BOOL ExecQueryAsyncEventObject :: Query_LogRecord ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord\r\n"
        );
)

    BSTR t_ObjectPath = NULL;
    BOOL retVal = TRUE;
    BOOL bGenAll = FALSE;

    if (OptimizeAssocQuery (a_ErrorObject, &t_ObjectPath))
    {
        GetObjectAsyncEventObject *t_getObj = new GetObjectAsyncEventObject (
                                                    m_Provider, t_ObjectPath,
                                                    0, m_NotificationHandler, m_Ctx, FALSE);

        if (!t_getObj->GetObject(t_getObj->m_ErrorObject))
        {
            bGenAll = TRUE;
            //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
            //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to verify object given in query\r\n"
        );
)
        }
        else
        {
            VARIANT v;
            VariantInit(&v);
            HRESULT result = t_getObj->m_Out->Get(CLASS_PROP, 0, &v, NULL, NULL);

            if ((FAILED(result)) || (v.vt != VT_BSTR))
            {
                retVal = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                a_ErrorObject.SetMessage ( L"Failed to get class name of object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to get class name of object given in query\r\n"
        );
)
            }
            else
            {
                if (_wcsicmp(v.bstrVal, NTEVTLOG_CLASS) == 0)
                {
                    VARIANT vLog;
                    VariantInit(&vLog);
                    result = t_getObj->m_Out->Get(PROP_LOGNAME, 0, &vLog, NULL, NULL);

                    if ((FAILED(result)) || (vLog.vt != VT_BSTR))
                    {
                        retVal = FALSE;
                        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                        a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                        a_ErrorObject.SetMessage ( L"Failed to get log file name of object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to get log file name of object given in query\r\n"
        );
)
                    }
                    else
                    {
                        //get all records for this log
                        retVal = GenerateLogAssocs(a_ErrorObject, t_ObjectPath, vLog.bstrVal, TRUE, NULL);
                    }

                    VariantClear(&vLog);
                }
                else if (_wcsicmp(v.bstrVal, NTEVT_CLASS) == 0)
                {
                    VARIANT vLog;
                    VariantInit(&vLog);
                    result = t_getObj->m_Out->Get(LOGFILE_PROP, 0, &vLog, NULL, NULL);

                    if ((FAILED(result)) || (vLog.vt != VT_BSTR))
                    {
                        retVal = FALSE;
                        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                        a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                        a_ErrorObject.SetMessage ( L"Failed to get log file name of object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to get log file name of object given in query\r\n"
        );
)
                    }
                    else
                    {
                        //get log for this record
                        CStringW logNameVal(EVENTLOG_BASE);
                        logNameVal += L"\\";
                        logNameVal += CStringW(vLog.bstrVal);
                        HKEY hkResult;
                        LONG res = RegOpenKeyEx(HKEY_LOCAL_MACHINE, logNameVal, 0,
                                KEY_READ, &hkResult);

                        if (res != ERROR_SUCCESS)
                        {
                            retVal = FALSE;
                            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

                            if ((res == ERROR_ACCESS_DENIED) || (res == ERROR_PRIVILEGE_NOT_HELD))
                            {
                                a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                                a_ErrorObject.SetPrivilegeFailed();
                                a_ErrorObject.SetSecurityPrivRequired();
                                a_ErrorObject.SetSecurityPrivFailed();
                            }
                            else
                            {
                                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                            }

                            a_ErrorObject.SetMessage ( L"Failed to get log file associated to object given in query");
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to get log file associated to object given in query\r\n"
        );
)
                        }
                        else
                        {
                            CStringW logPath(PROP_START_LOG);
                            wchar_t* spchrs = CheckForSpecialCharacters(CEventLogFile::GetFileName(hkResult));
                            RegCloseKey(hkResult);
                            logPath += CStringW(spchrs);
                            delete [] spchrs;
                            logPath += PROP_END_QUOTE;
                            retVal = GenerateAssocInstance(a_ErrorObject, t_ObjectPath, logPath, REF_REC, REF_LOG,
                                                            m_ClassObject, m_NotificationHandler, NULL);
                        }
                    }

                    VariantClear(&vLog);
                }
                else
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                    a_ErrorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE );
                    a_ErrorObject.SetMessage ( L"Class name of object given in query is not a property of Association class" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Class name of object given in query is not a property of Association class\r\n"
        );
)
                }
            }

            VariantClear(&v);
        }

        SysFreeString (t_ObjectPath);
        delete t_getObj;
    }
    else
    {
        bGenAll = TRUE;
    }

    if (bGenAll)
    {
        //get all instances...
        // open registry for log names
        HKEY hkResult;
        LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                EVENTLOG_BASE, 0,
                                KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                &hkResult);

        if (status != ERROR_SUCCESS)
        {
            // indicate error
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

            if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
            {
                a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                a_ErrorObject.SetPrivilegeFailed();
                a_ErrorObject.SetSecurityPrivRequired();
                a_ErrorObject.SetSecurityPrivFailed();
            }
            else
            {
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            }

            a_ErrorObject.SetMessage ( L"Failed to open the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to open the Eventlog registry for logfiles - Returning FALSE.\r\n"
        );
)

            retVal = FALSE;
            return retVal;
        }

        DWORD iValue = 0;
        WCHAR t_logname[MAX_PATH+1];
        DWORD t_lognameSize = MAX_PATH;
		BOOL bContinue = TRUE;

        // read all entries under this key to find all logfiles...
        while (bContinue && ((status = RegEnumKey(hkResult, iValue, t_logname, t_lognameSize)) != ERROR_NO_MORE_ITEMS))
        {
            // if error during read
            if (status != ERROR_SUCCESS)
            {
                // indicate error
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

                if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
                {
                    a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                    a_ErrorObject.SetPrivilegeFailed();
                    a_ErrorObject.SetSecurityPrivRequired();
                    a_ErrorObject.SetSecurityPrivFailed();
                }
                else
                {
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                }

                a_ErrorObject.SetMessage ( L"Failed while enumerating the Eventlog registry for logfiles." );
                retVal = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed while enumerating the Eventlog registry for logfiles.\r\n"
        );
)
                break;
            }

            //create the associations for this logfile...
            HKEY hkLog;

            if (ERROR_SUCCESS == RegOpenKeyEx(hkResult, t_logname, 0, KEY_QUERY_VALUE, &hkLog))
            {
                CStringW t_logPath(PROP_START_LOG);
                CStringW t_evtlognamestr = CEventLogFile::GetFileName(hkLog);

                if (!t_evtlognamestr.IsEmpty())
                {
                    wchar_t* spchrs = CheckForSpecialCharacters(t_evtlognamestr);
                    t_logPath += CStringW(spchrs);
                    delete [] spchrs;
                    t_logPath += PROP_END_QUOTE;

                    if (!GenerateLogAssocs(a_ErrorObject, t_logPath, t_logname, FALSE, &bContinue))
                    {
                        retVal = FALSE;
                    }
                }
                else
                {
                    retVal = FALSE;
DebugOut( 
            CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

                _T(__FILE__),__LINE__,
                L"ExecQueryAsyncEventObject :: Query_LogRecord:Failed to get file for the %s logfile.\r\n",
                t_logname
                );
)

                }

                RegCloseKey(hkLog);
            }

            // read next parameter
            iValue++;

        } // end while

        RegCloseKey(hkResult);
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_LogRecord:returning %lx\r\n",
        retVal
        );
)
    
    return retVal;
}

BOOL ExecQueryAsyncEventObject :: GenerateLogAssocs( WbemProvErrorObject &a_ErrorObject,
                                                    const wchar_t* logPath,
                                                    const wchar_t* logName,
													BOOL bVerifyLogname,
													BOOL *pbContinue)
{
    BOOL retVal = TRUE;

	if (pbContinue)
	{
		*pbContinue = TRUE;
	}

    CEventLogFile evtLog(logName, bVerifyLogname);

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateLogAssocs\r\n"
        );
)

    if (!evtLog.IsValid())
    {
        retVal = FALSE;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

        if ((evtLog.GetReason() == ERROR_ACCESS_DENIED) || (evtLog.GetReason() == ERROR_PRIVILEGE_NOT_HELD))
        {
            a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();
            a_ErrorObject.SetPrivilegeFailed();
        }
        else
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
        }

        a_ErrorObject.SetMessage ( L"Failed to open eventlog to enumerate records for Log Association." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateLogAssocs:Failed to open eventlog to enumerate records for Log Association\r\n"
        );
)
    }
    else
    {
        DWORD recId;
        DWORD numRecs;
        
        if (evtLog.GetLastRecordID(recId, numRecs))
        {
            for (DWORD x = recId; (x > (recId - numRecs)); x--)
            {
                CStringW recPath(PROP_START_REC);
                recPath += CStringW(logName);
                recPath += PROP_MID_REC;
                wchar_t buff[40];
                recPath += CStringW(_ultow((ULONG)x, buff, 10));
                
				if (!GenerateAssocInstance(a_ErrorObject, recPath,
                                        logPath, REF_REC, REF_LOG,
                                        m_ClassObject, m_NotificationHandler, pbContinue))
                {
                    retVal = FALSE;
                }
				
				if (pbContinue && !(*pbContinue))
				{
					break;
				}
            }
        }
        else
        {
            retVal = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            a_ErrorObject.SetMessage ( L"Failed to determine number of records in eventlog for log associations" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateLogAssocs:Failed to determine number of records in eventlog for log associations\r\n"
        );
)
        }
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateLogAssocs:Returning %lx\r\n",
        retVal
        );
)

    return retVal;
}


BOOL ExecQueryAsyncEventObject :: Query_UserRecord ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord\r\n"
        );
)

    BSTR t_ObjectPath = NULL;
    BOOL retVal = TRUE;
    BOOL bGenAll = FALSE;

    if (OptimizeAssocQuery (a_ErrorObject, &t_ObjectPath))
    {
        wchar_t* str_classname = GetClassFromPath(t_ObjectPath);


        if (str_classname == NULL)
        {
            bGenAll = TRUE;
            //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
            //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord:Failed to verify object given in query\r\n"
        );
)

        }
        else if (_wcsicmp(str_classname, USER_CLASS) == 0)
        {
            IWbemClassObject* pObj = NULL;
            IWbemServices *t_Server = m_Provider->GetServer();
            HRESULT result = t_Server->GetObject(t_ObjectPath, 0, m_Ctx, &pObj, NULL);

            t_Server->Release();

            if (FAILED(result))
            {
                retVal = FALSE;
                //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord:Failed to verify object given in query\r\n"
        );
)
            }
            else
            {
                pObj->Release ();

                //get all records...
                retVal = GenerateCompUserAssocs(a_ErrorObject, FALSE);
            }
            
            delete [] str_classname;
        }
        else if (_wcsicmp(str_classname, NTEVT_CLASS) == 0)
        {
            GetObjectAsyncEventObject *t_getRec = new GetObjectAsyncEventObject (
                                                        m_Provider, t_ObjectPath,
                                                        0, m_NotificationHandler,
                                                        m_Ctx, FALSE );

            if (t_getRec->GetObject(t_getRec->m_ErrorObject))
            {
                VARIANT vUser;
                CIMTYPE cT;
                VariantInit(&vUser);
                HRESULT result = t_getRec->m_Out->Get(USER_PROP, 0, &vUser, &cT, NULL);

                if ((FAILED(result)) || (cT != CIM_STRING))
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                    a_ErrorObject.SetMessage ( L"Failed to get user name of object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord:Failed to get user name of object given in query\r\n"
        );
)
                }
                else
                {
                    if ((vUser.vt == VT_BSTR) && (vUser.bstrVal != NULL))
                    {
                        //get user for this record
                        CStringW userVal(vUser.bstrVal);
                        int pos = userVal.Find(L'\\');

                        if (pos != -1)
                        {
                            CStringW dom = userVal.Left(pos);
                            CStringW nm = userVal.Right(userVal.GetLength() - 1 - pos);

                            if (!nm.IsEmpty() && !dom.IsEmpty())
                            {
                                wchar_t userPath[1024];
                                wcscpy(userPath, PROP_START_USER);
                                wcscat(userPath, dom);
                                wcscat(userPath, PROP_MID_USER);
                                wcscat(userPath, nm);
                                wcscat(userPath, PROP_END_QUOTE);
                                IWbemClassObject* pUObj = NULL;
                                IWbemServices *t_Server = m_Provider->GetServer();
								BSTR userStr = SysAllocString(userPath);
                                HRESULT result = t_Server->GetObject(userStr, 0, m_Ctx, &pUObj, NULL);
                                t_Server->Release();
								SysFreeString(userStr);

                                if (SUCCEEDED(result))
                                {
                                    retVal = GenerateAssocInstance(a_ErrorObject, t_ObjectPath,
                                                        userPath, REF_REC, REF_USER,
                                                        m_ClassObject, m_NotificationHandler, NULL);
                                    pUObj->Release();
                                }
                            }
                        }
                    }
                }

                VariantClear(&vUser);
            }
            else
            {
                retVal = FALSE;
                //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord:Failed to verify object given in query\r\n"
        );
)
            }

            delete t_getRec;
            delete [] str_classname;
        }
        else
        {
            bGenAll = TRUE;
        }

        SysFreeString (t_ObjectPath);
    }
    else
    {
        bGenAll = TRUE;
    }

    if (bGenAll)
    {
        //get all instances...
        retVal = GenerateCompUserAssocs(a_ErrorObject, FALSE);
    }
    
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_UserRecord:Returning %lx\r\n",
        retVal
        );
)

    return retVal;
}

BOOL ExecQueryAsyncEventObject :: Query_ComputerRecord ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord\r\n"
        );
)

    BSTR t_ObjectPath = NULL;
    BOOL retVal = TRUE;
    BOOL bGenAll = FALSE;

    if (OptimizeAssocQuery (a_ErrorObject, &t_ObjectPath))
    {
        wchar_t* str_classname = GetClassFromPath(t_ObjectPath);

        if (str_classname == NULL)
        {
            bGenAll = TRUE;
            //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
            //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord:Failed to verify object given in query\r\n"
        );
)
        }
        else if (_wcsicmp(str_classname, COMP_CLASS) == 0)
        {
            IWbemClassObject* pObj = NULL;
            IWbemServices *t_Server = m_Provider->GetServer();
            HRESULT result = t_Server->GetObject(t_ObjectPath, 0, m_Ctx, &pObj, NULL);
            t_Server->Release();

            if (FAILED(result))
            {
                retVal = FALSE;
                //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord:Failed to verify object given in query\r\n"
        );
)
            }
            else
            {
                pObj->Release ();

                //get all records...
                retVal = GenerateCompUserAssocs(a_ErrorObject, TRUE);
            }

            delete [] str_classname;
        }
        else if (_wcsicmp(str_classname, NTEVT_CLASS) == 0)
        {
            GetObjectAsyncEventObject *t_getRec = new GetObjectAsyncEventObject (
                                                        m_Provider, t_ObjectPath,
                                                        0, m_NotificationHandler,
                                                        m_Ctx, FALSE);

            if (t_getRec->GetObject(t_getRec->m_ErrorObject))
            {
                VARIANT vComp;
                CIMTYPE cT;
                VariantInit(&vComp);
                HRESULT result = t_getRec->m_Out->Get(COMPUTER_PROP, 0, &vComp, &cT, NULL);

                if ((FAILED(result)) || (cT != CIM_STRING))
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                    a_ErrorObject.SetMessage ( L"Failed to get computer name of object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord:Failed to get computer name of object given in query\r\n"
        );
)
                }
                else
                {
                    if ((vComp.vt == VT_BSTR) && (vComp.bstrVal != NULL))
                    {
                        //get computer for this record
                        wchar_t compPath[1024];
                        wcscpy(compPath, PROP_START_COMP);
                        wcscat(compPath, vComp.bstrVal);
                        wcscat(compPath, PROP_END_QUOTE);
                        IWbemClassObject* pCObj = NULL;
                        IWbemServices *t_Server = m_Provider->GetServer();
						BSTR compStr = SysAllocString(compPath);
                        HRESULT result = t_Server->GetObject(compStr, 0, m_Ctx, &pCObj, NULL);
						SysFreeString(compStr);
                        t_Server->Release();

                        if (SUCCEEDED(result))
                        {
                            retVal = GenerateAssocInstance(a_ErrorObject, t_ObjectPath,
                                                compPath, REF_REC, REF_COMP,
                                                m_ClassObject, m_NotificationHandler, NULL);
                            pCObj->Release();
                        }
                    }
                }

                VariantClear(&vComp);
            }
            else
            {
                retVal = FALSE;
                //a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
                //a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                //a_ErrorObject.SetMessage ( L"Failed to verify object given in query" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord:Failed to verify object given in query\r\n"
        );
)
            }

            delete t_getRec;
            delete [] str_classname;
        }
        else
        {
            bGenAll = TRUE;
        }

        SysFreeString (t_ObjectPath);
    }
    else
    {
        bGenAll = TRUE;
    }

    if (bGenAll)
    {
        //get all instances...
        retVal = GenerateCompUserAssocs(a_ErrorObject, TRUE);
    }
    
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_ComputerRecord:Returning %lx\r\n",
        retVal
        );
)

    return retVal;
}


BOOL ExecQueryAsyncEventObject :: GenerateCompUserAssocs ( WbemProvErrorObject &a_ErrorObject, BOOL bComp )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateCompUserAssocs\r\n"
        );
)

    BOOL retVal = TRUE;
    //just enumerate all logs and let cimom post filter...
    // open registry for log names
    HKEY hkResult;
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            EVENTLOG_BASE, 0,
                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                            &hkResult);

    if (status != ERROR_SUCCESS)
    {
        // indicate error
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

        if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
        {
            a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();
            a_ErrorObject.SetPrivilegeFailed();
        }
        else
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
        }

        a_ErrorObject.SetMessage ( L"Failed to enumerate the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateCompUserAssocs:Failed to enumerate the Eventlog registry for logfiles- Returning FALSE\r\n"
        );
)

        return FALSE;
    }

    DWORD iValue = 0;
    WCHAR logname[MAX_PATH+1];
    DWORD lognameSize = MAX_PATH;
    CMap<CStringW, LPCWSTR, HRESULT, HRESULT> pathMap;
	BOOL bContinue = TRUE;

    // read all entries under this key to find all logfiles...
    while (bContinue && ((status = RegEnumKey(hkResult, iValue, logname, lognameSize)) != ERROR_NO_MORE_ITEMS))
    {
        // if error during read
        if (status != ERROR_SUCCESS)
        {
            RegCloseKey(hkResult);

            // indicate error
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

            if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
            {
                a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                a_ErrorObject.SetSecurityPrivRequired();
                a_ErrorObject.SetSecurityPrivFailed();
                a_ErrorObject.SetPrivilegeFailed();
            }
            else
            {
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            }

            a_ErrorObject.SetMessage ( L"Failed while enumerating the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateCompUserAssocs:Failed while enumerating the Eventlog registry for logfiles - Returning FALSE\r\n"
        );
)
            return FALSE;
        }

        //process this logfile
        CEventLogFile evtLog(logname, FALSE);

        if (evtLog.IsValid())
        {
            evtLog.ReadLastRecord();
        }

        while (bContinue && evtLog.IsValid())
        {
            DWORD dwEventSize = 0;
            DWORD err = evtLog.ReadRecord(0, &dwEventSize, TRUE);

            if (0 != err)
            {
                if (retVal && (err != ERROR_HANDLE_EOF))
                {
                    retVal = FALSE;
                    a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

                    if ((err == ERROR_ACCESS_DENIED) || (err == ERROR_PRIVILEGE_NOT_HELD))
                    {
                        a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                        a_ErrorObject.SetSecurityPrivRequired();
                        a_ErrorObject.SetSecurityPrivFailed();
                        a_ErrorObject.SetPrivilegeFailed();
                    }
                    else
                    {
                        a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                    }

                    a_ErrorObject.SetMessage ( L"Failed while enumerating one of the logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateCompUserAssocs:Failed while enumerating one of the logfiles.\r\n"
        );
)
                }

                break;
            }

            PEVENTLOGRECORD EventBuffer = (PEVENTLOGRECORD)evtLog.GetBuffer();

            while (bContinue && (dwEventSize != 0))
            {
                CStringW compPath;
                BOOL bGenAssoc = FALSE;

                if (bComp)
                {
                    const wchar_t* src = (const wchar_t*)((UCHAR*)EventBuffer + sizeof(EVENTLOGRECORD));
                    const wchar_t* compName = (const wchar_t*)((UCHAR*)EventBuffer + sizeof(EVENTLOGRECORD))
                                                                        + wcslen(src) + 1;

                    if (compName != NULL)
                    {
                        //get computer for this record
                        compPath = PROP_START_COMP;
                        compPath += compName;
                        compPath += PROP_END_QUOTE;
                        bGenAssoc = TRUE;
                    }
                }
                else
                {
                    if (EventBuffer->UserSidLength > 0)
                    {
                        CStringW user = CEventlogRecord::GetUser(
                            (PSID)((UCHAR*)EventBuffer + EventBuffer->UserSidOffset));

                        if (!user.IsEmpty())
                        {
                            int index = user.Find(L'\\');

                            if (index > 0)
                            {
                                compPath = PROP_START_USER;
                                compPath += user.Left(index++);
                                compPath += PROP_MID_USER;
                                compPath += user.Right(user.GetLength() - index);
                                compPath += PROP_END_QUOTE;
                                bGenAssoc = TRUE;
                            }
                        }
                    }

                }

                if (bGenAssoc)
                {
                    HRESULT result;

                    if (pathMap.IsEmpty() || !pathMap.Lookup(compPath, result))
                    {
                        IWbemClassObject* pCObj = NULL;
                        IWbemServices *t_Server = m_Provider->GetServer();
						BSTR compPathStr = compPath.AllocSysString();
                        result = t_Server->GetObject(compPathStr, 0, m_Ctx, &pCObj, NULL);
                        SysFreeString(compPathStr);
                        t_Server->Release();
                        pathMap[compPath] = result;

                        if (SUCCEEDED(result))
                        {
                            pCObj->Release();
                        }
                    }

                    if (SUCCEEDED(result))
                    {
                        CStringW recPath(PROP_START_REC);
                        recPath += CStringW(logname);
                        recPath += PROP_MID_REC;
                        wchar_t buff[40];
                        recPath += CStringW(_ultow((ULONG)EventBuffer->RecordNumber, buff, 10));
                        
                        if (!GenerateAssocInstance(a_ErrorObject, recPath, compPath, REF_REC,
                            bComp ? REF_COMP : REF_USER,
                            m_ClassObject, m_NotificationHandler, &bContinue))
                        {
                            retVal = FALSE;
                        }
                    }
                }

                // drop by length of this record and point to next record
                dwEventSize -= EventBuffer->Length;
                EventBuffer = (PEVENTLOGRECORD) ((UCHAR*) EventBuffer + EventBuffer->Length);
            }
        }

        // read next parameter
        iValue++;

    } // end while

    pathMap.RemoveAll();
    RegCloseKey(hkResult);
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: GenerateCompUserAssocs:Returning %lx\r\n",
        retVal
        );
)
    
    return retVal;
}

BOOL ExecQueryAsyncEventObject :: ExecQuery ( WbemProvErrorObject &a_ErrorObject )
{
    BOOL t_Status;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: ExecQuery\r\n"
        );
)
    if (FAILED(m_ErrorObject.GetWbemStatus()))
    {
        return FALSE;
    }

    if ( _wcsicmp ( m_QueryFormat, WBEM_QUERY_LANGUAGE_SQL1 ) == 0 )
    {
        CTextLexSource querySource ( m_Query );
        SQL1_Parser sqlParser ( &querySource );

        t_Status = ! sqlParser.Parse ( & m_RPNExpression );

        if ( t_Status )
        {
            t_Status = GetClassObject ( m_RPNExpression->bsClassName );
            
            if ( t_Status )
            {
                t_Status = DispatchQuery ( a_ErrorObject );            
            }
            else
            {
                t_Status = FALSE;
                a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS );
                a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_CLASS );
                a_ErrorObject.SetMessage ( L"Unknown Class" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: ExecQuery:Unknown Class\r\n"
        );
)
            }
        }
        else
        {
            t_Status = FALSE;
            a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_QUERY );
            a_ErrorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE );
            a_ErrorObject.SetMessage ( L"WQL query was invalid for this provider" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: ExecQuery:WQL query was invalid for this provider\r\n"
        );
)
        }
    }
    else
    {
        t_Status = FALSE;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_QUERY_TYPE );
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY_TYPE );
        a_ErrorObject.SetMessage ( L"Query Language not supported" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: ExecQuery:Query Language not supported\r\n"
        );
)
    }

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: ExecQuery:Returning %lx\r\n",
        t_Status
        );
)

    return t_Status;
}

ExecQueryAsyncEventObject :: ExecQueryAsyncEventObject (

    CImpNTEvtProv *a_Provider, 
    BSTR a_QueryFormat, 
    BSTR a_Query, 
    ULONG a_OperationFlag,
    IWbemObjectSink *a_NotificationHandler,
    IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider, a_NotificationHandler, a_OperationFlag, a_Ctx ),
    m_Query ( NULL ),
    m_QueryFormat ( NULL ),
    m_RPNExpression ( NULL ) 
{
    m_Query = UnicodeStringDuplicate ( a_Query );
    m_QueryFormat = UnicodeStringDuplicate ( a_QueryFormat );
}

ExecQueryAsyncEventObject :: ~ExecQueryAsyncEventObject () 
{
// Get Status object

    delete [] m_Query;
    delete [] m_QueryFormat;
    delete m_RPNExpression;

    IWbemClassObject *t_NotifyStatus = NULL;
    BOOL t_Status = TRUE;
    
    if (WBEM_NO_ERROR != m_ErrorObject.GetWbemStatus ())
    {
        t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus );
    }

    if ( t_Status )
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0, m_ErrorObject.GetWbemStatus (), 0, t_NotifyStatus );
        
        if (t_NotifyStatus)
        {
            t_NotifyStatus->Release ();
        }
    }
    else
    {
        HRESULT t_Result = m_NotificationHandler->SetStatus ( 0, m_ErrorObject.GetWbemStatus (), 0, NULL );
    }
}


void ExecQueryAsyncEventObject :: Process () 
{
    ExecQuery ( m_ErrorObject );
}

BOOL ExecQueryAsyncEventObject :: DispatchQuery ( WbemProvErrorObject &a_ErrorObject )
{
    BOOL t_Status;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: DispatchQuery\r\n"
        );
)

    if ( _wcsicmp ( m_RPNExpression->bsClassName, NTEVT_CLASS ) == 0 )
    {
        t_Status = Query_Record ( a_ErrorObject );

        if ( t_Status )
        {
            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE;
        }
    }
    else if ( _wcsicmp ( m_RPNExpression->bsClassName, NTEVTLOG_CLASS ) == 0 )
    {
        t_Status = Query_EventLog ( a_ErrorObject );

        if ( t_Status )
        {
            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE;
        }
    }
    else if ( _wcsicmp ( m_RPNExpression->bsClassName, ASSOC_LOGRECORD) == 0 )
    {
        t_Status = Query_LogRecord ( a_ErrorObject );

        if ( t_Status )
        {
            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE;
        }
    }
    else if ( _wcsicmp ( m_RPNExpression->bsClassName, ASSOC_USERRECORD) == 0 )
    {
        t_Status = Query_UserRecord ( a_ErrorObject );

        if ( t_Status )
        {
            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE;
        }
    }
    else if ( _wcsicmp ( m_RPNExpression->bsClassName, ASSOC_COMPRECORD) == 0 )
    {
        t_Status = Query_ComputerRecord ( a_ErrorObject );

        if ( t_Status )
        {
            m_State = WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE;
        }
    }
    else
    {
        //just complete!
        t_Status = FALSE;
        a_ErrorObject.SetStatus ( WBEM_PROV_E_INVALID_CLASS );
        a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_CLASS );
        a_ErrorObject.SetMessage ( L"Dynamic NT Eventlog Provider does not support this class" );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: DispatchQuery:Dynamic NT Eventlog Provider does not support this class:%s\r\n",
        m_RPNExpression->bsClassName
        );
)
    }
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: DispatchQuery:Returning %lx\r\n",
        t_Status
        );
)

    return t_Status;
}

BOOL ExecQueryAsyncEventObject :: Query_EventLog ( WbemProvErrorObject &a_ErrorObject )
{
    // open registry for log names
    HKEY hkResult;
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            EVENTLOG_BASE, 0,
                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                            &hkResult);

    if (status != ERROR_SUCCESS)
    {
        // indicate error
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

        if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
        {
            a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();
            a_ErrorObject.SetPrivilegeFailed();
        }
        else
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
        }

        a_ErrorObject.SetMessage ( L"Failed to open the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_EventLog:Failed to open the Eventlog registry for logfiles - Returning FALSE.\r\n"
        );
)

        return FALSE;
    }

    BOOL retVal = TRUE;
    DWORD iValue = 0;
    WCHAR logname[MAX_PATH+1];
    DWORD lognameSize = MAX_PATH;

    // read all entries under this key to find all logfiles...
    while ((status = RegEnumKey(hkResult, iValue, logname, lognameSize)) != ERROR_NO_MORE_ITEMS)
    {
        // if error during read
        if (status != ERROR_SUCCESS)
        {
            // indicate error
            a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

            if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
            {
                a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                a_ErrorObject.SetPrivilegeFailed();
                a_ErrorObject.SetSecurityPrivRequired();
                a_ErrorObject.SetSecurityPrivFailed();
            }
            else
            {
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
            }

            a_ErrorObject.SetMessage ( L"Failed while enumerating the Eventlog registry for logfiles." );
            retVal = FALSE;
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_EventLog:Failed while enumerating the Eventlog registry for logfiles.\r\n"
        );
)
            break;
        }

        //create the instance logfilename
        CEventlogFileAttributes evtlog(logname);
        IWbemClassObject* pInst = NULL;
            
        if (evtlog.GenerateInstance(m_ClassObject, m_AClassObject, &pInst))
        {
            HRESULT t_hr = m_NotificationHandler->Indicate ( 1, & pInst );                               
            pInst->Release();

			if (FAILED(t_hr))
			{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_EventLog:Failed while indicating instance(s) of %s Eventlog file\r\n",
        logname
        );
)
                a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
				a_ErrorObject.SetMessage ( L"Failed while indicating instance of logfile." );
				retVal = FALSE;
				break;
			}
        }
        else if (retVal) //only do this once!
        {
            //an error, just log an error, don't report it via the interface
            //it is a bad registry entry which the eventlog service allows
            //so we should let it pass...
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_EventLog:Failed to create instance(s) of %s Eventlog file\r\n",
        logname
        );
)

        }

        // read next parameter
        iValue++;

    } // end while

    RegCloseKey(hkResult);

DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_EventLog:Returning %lx\r\n",
        retVal
        );
)

    return retVal;
}

BOOL ExecQueryAsyncEventObject :: Query_Record ( WbemProvErrorObject &a_ErrorObject )
{
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_Record\r\n"
        );
)

    BOOL retVal = TRUE;
    //just enumerate all logs and let cimom post filter...
    // open registry for log names
    HKEY hkResult = NULL;
    LONG status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            EVENTLOG_BASE, 0,
                            KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                            &hkResult);

    if (status != ERROR_SUCCESS)
    {
        // indicate error
        a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

        if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
        {
            a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
            a_ErrorObject.SetPrivilegeFailed();
            a_ErrorObject.SetSecurityPrivRequired();
            a_ErrorObject.SetSecurityPrivFailed();
        }
        else
        {
            a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
        }

        a_ErrorObject.SetMessage ( L"Failed to enumerate the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_Record:Failed to enumerate the Eventlog registry for logfiles - Return FALSE\r\n"
        );
)
        retVal = FALSE;
    }

	if (retVal)
	{
		//Analyze the query...
		SQL_LEVEL_1_RPN_EXPRESSION *t_RpnExpression = NULL;
		PartitionSet *t_PartitionSet = NULL;
		QueryPreprocessor :: QuadState t_State =  Query (m_Query, t_RpnExpression);

		if ( t_State == QueryPreprocessor :: QuadState :: State_True )
		{
			WmiTreeNode *t_Root = NULL;

			t_State = PreProcess (NULL, t_RpnExpression, t_Root);

			try
			{
				switch ( t_State )
				{
					case QueryPreprocessor :: QuadState :: State_True:
					{

						BSTR t_PropertyContainer [ 4 ];
						memset ( t_PropertyContainer, 0, sizeof ( BSTR ) * 4 );

						try
						{
							t_PropertyContainer [ 0 ] = SysAllocString ( LOGFILE_PROP );
							t_PropertyContainer [ 1 ] = SysAllocString ( RECORD_PROP ); 
							t_PropertyContainer [ 2 ] = SysAllocString ( GENERATED_PROP ); 
							t_PropertyContainer [ 3 ] = SysAllocString ( WRITTEN_PROP );

						
							if ((t_PropertyContainer [ 0 ] == NULL) ||
								(t_PropertyContainer [ 1 ] == NULL) ||
								(t_PropertyContainer [ 2 ] == NULL) ||
								(t_PropertyContainer [ 3 ] == NULL) )
							{
								throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR );
							}

							t_State = PreProcess (	

								NULL,
								t_RpnExpression,
								t_Root,
								4, 
								t_PropertyContainer,
								t_PartitionSet
							);
						}
						catch ( ... )
						{
							for (DWORD x = 0; x < 4; x++)
							{
								if ( t_PropertyContainer [ x ] )
								{
									SysFreeString ( t_PropertyContainer [ x ] );
									t_PropertyContainer [ x ] = NULL;
								}
							}

							throw;
						}

						for (DWORD x = 0; x < 4; x++)
						{
							if ( t_PropertyContainer [ x ] )
							{
								SysFreeString ( t_PropertyContainer [ x ] );
								t_PropertyContainer [ x ] = NULL;
							}
						}

						switch ( t_State )
						{
							case QueryPreprocessor :: QuadState :: State_True :	
							{
								/*
								* Full set, enumerate
								*/
								t_PartitionSet = NULL;
							}
							break;

							case QueryPreprocessor :: QuadState :: State_False :
							{
								/*
								* Empty set, no work to do
								*/
								RegCloseKey(hkResult);
								hkResult = NULL;

								return TRUE;
							}
							break;

							case QueryPreprocessor :: QuadState :: State_Undefined :
							{
								//we have should now have a non-null partition set
							}
							break;

							default:
							{
								/*
								* Didn't understand the query send back everything
								*/
								t_PartitionSet = NULL;
							}
							break;
						}

						delete t_Root;
						t_Root = NULL;
					}
					break;
				
					default:
					{
						/*
						* Didn't understand the query send back everything
						*/
						t_PartitionSet = NULL;
					}
					break;
				}

				delete t_RpnExpression;
				t_RpnExpression = NULL;
			}
			catch (...)
			{
				if (t_PartitionSet)
				{
					delete t_PartitionSet;
					t_PartitionSet = NULL;
				}

				if ( t_Root )
				{
					delete t_Root;
					t_Root = NULL;
				}

				if ( t_RpnExpression )
				{
					delete t_RpnExpression;
					t_RpnExpression = NULL;
				}

				if ( hkResult )
				{
					RegCloseKey(hkResult);
					hkResult = NULL;
				}

				throw;
			}
		}
		else
		{
			/*
			* Didn't understand the query send back everything
			*/
			t_PartitionSet = NULL;
		}

		DWORD iValue = 0;
		WCHAR logname[MAX_PATH+1];
		DWORD lognameSize = MAX_PATH;
		retVal = FALSE;

		// read all entries under this key to find all logfiles...
		while ((status = RegEnumKey(hkResult, iValue, logname, lognameSize)) != ERROR_NO_MORE_ITEMS)
		{
			// if error during read
			if (status != ERROR_SUCCESS)
			{
				// indicate error
				a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

				if ((status == ERROR_ACCESS_DENIED) || (status == ERROR_PRIVILEGE_NOT_HELD))
				{
					a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
					a_ErrorObject.SetSecurityPrivRequired();
					a_ErrorObject.SetSecurityPrivFailed();
					a_ErrorObject.SetPrivilegeFailed();
				}
				else
				{
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
				}

				a_ErrorObject.SetMessage ( L"Failed while enumerating the Eventlog registry for logfiles." );
DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_Record:Failed while enumerating the Eventlog registry for logfiles - Return FALSE\r\n"
        );
)
				break;
			}

			if (t_PartitionSet)
			{
				//process this logfile for query
				if (SUCCEEDED (RecurseLogFile (a_ErrorObject, t_PartitionSet, logname)))
				{
					retVal = TRUE;
				}
			}
			else
			{
				//process this logfile
				if ( SUCCEEDED( DoAllInLogfile(a_ErrorObject, logname, 0, 0) ) )
				{
					retVal = TRUE;
				}
				else
				{
					break;
				}
			}

			// read next parameter
			iValue++;

		} // end while

		if (t_PartitionSet)
		{
			delete t_PartitionSet;
		}

		RegCloseKey(hkResult);
	}


DebugOut( 
    CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

        _T(__FILE__),__LINE__,
        L"ExecQueryAsyncEventObject :: Query_Record:Returning %lx\r\n",
        retVal
        );
)

    return retVal;
}

HRESULT ExecQueryAsyncEventObject :: RecurseLogFile (
	WbemProvErrorObject &a_ErrorObject, 
	PartitionSet *a_PartitionSet,
	LPCWSTR a_logname
)
{
	HRESULT t_Result = WBEM_E_FAILED;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount ();

	if (t_PartitionCount == 0)
	{
		t_Result = S_OK;
	}

	for ( DWORD t_Partition = 0; t_Partition < t_PartitionCount; t_Partition++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition );

		WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_PropertyPartition->GetRange ();

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( _wcsicmp ( t_Node->LowerBound (), t_Node->UpperBound () ) == 0 );

		if (!t_Unique)
		{
			//not naming logfiles therefore do this logfile only if it meets bounds...
			//if even one call succeeds return success
			BOOL t_bProcess = TRUE;

			if (!t_Node->InfiniteLowerBound())
			{
				int t_iCmp = _wcsicmp(a_logname, t_Node->LowerBound());

				if (t_Node->ClosedLowerBound())
				{
					if (t_iCmp < 0)
					{
						t_bProcess = FALSE;				
					}
				}
				else
				{
					if (t_iCmp <= 0)
					{
						t_bProcess = FALSE;				
					}
				}
			}

			if (!t_Node->InfiniteUpperBound())
			{
				int t_iCmp = _wcsicmp(a_logname, t_Node->UpperBound());

				if (t_Node->ClosedUpperBound())
				{
					if (t_iCmp > 0)
					{
						t_bProcess = FALSE;				
					}
				}
				else
				{
					if (t_iCmp >= 0)
					{
						t_bProcess = FALSE;				
					}
				}
			}

			if (t_bProcess)
			{
				if ( SUCCEEDED(RecurseRecord(a_ErrorObject, t_PropertyPartition, a_logname)) && FAILED(t_Result) )
				{
					t_Result = S_OK;
				}

				//we've processed this logfile no need to do anymore...
				break;
			}
		}
		else 
		{
			//are naming logfiles
			if (_wcsicmp(t_Node->LowerBound(), a_logname) == 0)
			{
				//logfile matched let's do records
				if (SUCCEEDED(RecurseRecord(a_ErrorObject, t_PropertyPartition, a_logname)) && FAILED(t_Result) )
				{
					t_Result = S_OK;
				}

				break;
			}
			else
			{
				//not this logfile let's try some other...
				continue;
			}
		}
	}

	return t_Result;
}

HRESULT ExecQueryAsyncEventObject :: RecurseRecord (
	WbemProvErrorObject &a_ErrorObject, 
	PartitionSet *a_PartitionSet,
	LPCWSTR a_logname
)
{
	HRESULT t_Result = S_OK;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount ();

	for ( DWORD t_Partition = 0; t_Partition < t_PartitionCount; t_Partition++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition );
		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = !t_Node->InfiniteLowerBound () && 
						!t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						(t_Node->LowerBound() == t_Node->UpperBound());

		if (!t_Unique)
		{
			if (t_Node->InfiniteLowerBound() && t_Node->InfiniteUpperBound())
			{
				//no limits on record therefore check time generated...
				t_Result = RecurseTime(a_ErrorObject, t_PropertyPartition, a_logname, TRUE);
				
				//there should be only one partition entry for this case but we'll break anyway...
				break;
			}
			else
			{
				DWORD t_dwLower = 0;
				DWORD t_dwUpper = 0xFFFFFFFF;
				BOOL t_bProcess = TRUE;

				if (!t_Node->InfiniteLowerBound())
				{
					if (t_Node->ClosedLowerBound())
					{
						t_dwLower = t_Node->LowerBound();
					}
					else
					{
						if (t_Node->LowerBound() != 0xFFFFFFFF)
						{
							t_dwLower = t_Node->LowerBound() + 1;
						}
						else
						{
							t_bProcess = FALSE; 
						}
					}
				}

				if (!t_Node->InfiniteUpperBound())
				{
					if (t_Node->ClosedUpperBound())
					{
						t_dwUpper = t_Node->UpperBound();
					}
					else
					{
						if (t_Node->UpperBound() != 0)
						{
							t_dwUpper = t_Node->UpperBound() - 1;
						}
						else
						{
							t_bProcess = FALSE; 
						}
					}
				}

				if (t_dwUpper < t_dwLower)
				{
					t_bProcess = FALSE;
				}

				//now return all records including the bounds
				if (t_bProcess)
				{
					CEventLogFile evtLog(a_logname, FALSE);
					
					if (evtLog.IsValid())
					{
						DWORD t_dwEventSize = 0;
						DWORD t_dwErr = evtLog.ReadRecord(t_dwUpper, &t_dwEventSize, TRUE);

						if (0 == t_dwErr)
						{
							DWORD t_dwState = 0;

							while (0 == t_dwState)
							{
								PEVENTLOGRECORD EventBuffer = (PEVENTLOGRECORD)evtLog.GetBuffer();

								while (t_dwEventSize != 0)
								{
									if (EventBuffer->RecordNumber >= t_dwLower)
									{
										CEventlogRecord evtrec(a_logname, EventBuffer, NULL, m_ClassObject, m_AClassObject);
										IWbemClassObject* pInst = NULL;
            
										if (evtrec.GenerateInstance(&pInst))
										{
											t_Result = m_NotificationHandler->Indicate ( 1, & pInst );
											
											//upper limit is decreased with this indicate!
											t_dwUpper--; 
											pInst->Release();

											if (FAILED(t_Result))
											{
												a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
												a_ErrorObject.SetMessage ( L"Failed while indicating record instance." );
												t_dwState = 2;
												break;
											}
										}

										// drop by length of this record and point to next record
										t_dwEventSize -= EventBuffer->Length;
										EventBuffer = (PEVENTLOGRECORD) ((UCHAR*) EventBuffer + EventBuffer->Length);
									}
									else
									{
										t_dwState = 2;
										break;
									}
								}

								if (t_dwState == 0)
								{
									t_dwErr = evtLog.ReadRecord(0, &t_dwEventSize, TRUE);

									if (0 != t_dwErr)
									{
										if (SUCCEEDED(t_Result) && (t_dwErr != ERROR_HANDLE_EOF))
										{
											a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );
											t_Result = WBEM_E_FAILED;

											if ((t_dwErr == ERROR_ACCESS_DENIED) || (t_dwErr == ERROR_PRIVILEGE_NOT_HELD))
											{
												a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
												a_ErrorObject.SetSecurityPrivRequired();
												a_ErrorObject.SetSecurityPrivFailed();
												a_ErrorObject.SetPrivilegeFailed();
											}
											else
											{
												a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
											}

											a_ErrorObject.SetMessage ( L"Failed while enumerating one of the logfiles." );
										}

										t_dwState = 1;
									}
								}
							}

							if ((t_dwState == 1) && (t_dwErr == ERROR_HANDLE_EOF) && (t_dwUpper > t_dwLower))
							{
								//got all the records til the start of the log see if there are any at the top
								t_Result = DoAllInLogfile(a_ErrorObject, a_logname, t_dwUpper, t_dwLower);

								if (FAILED(t_Result))
								{
									break;
								}
							}
						}
						else
						{
							if (t_dwLower != t_dwUpper)
							{
								//the upper bound does not exist, try from the top down...
								t_Result = DoAllInLogfile(a_ErrorObject, a_logname, t_dwUpper, t_dwLower);

								if (FAILED(t_Result))
								{
									break;
								}

							}
						}
					}
				}
			}
		}
		else 
		{
			//are naming records
			CEventLogFile evtLog(a_logname, FALSE);
        
			if (evtLog.IsValid())
			{
				DWORD err = evtLog.ReadRecord(t_Node->LowerBound());

				if (0 == err)
				{
					EVENTLOGRECORD* EventBuffer = (EVENTLOGRECORD*) evtLog.GetBuffer();
					CEventlogRecord evtRec(a_logname, EventBuffer, NULL, m_ClassObject, m_AClassObject);
					IWbemClassObject* pInst = NULL;
    
					if (evtRec.GenerateInstance(&pInst))
					{
						t_Result = m_NotificationHandler->Indicate ( 1 , & pInst ) ;
						pInst->Release();

						if (FAILED(t_Result))
						{
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
							a_ErrorObject.SetMessage ( L"Failed while indicating record instance." );
							break;
						}
					}
					else
					{
						//failed to create record
						t_Result = WBEM_E_FAILED;
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED ) ;
						a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_ErrorObject.SetMessage ( L"Failed to create instance from Eventlog data" ) ;
					}
				}
			}
		}
	}

	return t_Result;
}

HRESULT ExecQueryAsyncEventObject::RecurseTime(WbemProvErrorObject &a_ErrorObject, PartitionSet *a_PartitionSet,
													LPCWSTR a_logname, BOOL a_Generated)
{
	HRESULT t_Result = S_OK;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount ();

	for ( DWORD t_Partition = 0; t_Partition < t_PartitionCount; t_Partition++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition );

		WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_PropertyPartition->GetRange ();

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( _wcsicmp ( t_Node->LowerBound (), t_Node->UpperBound () ) == 0 );

		if (!t_Unique)
		{
			if (t_Node->InfiniteLowerBound() && t_Node->InfiniteUpperBound())
			{
				//no limits on record therefore check time written...
				if (a_Generated)
				{
					t_Result = RecurseTime(a_ErrorObject, t_PropertyPartition, a_logname, FALSE);
				}
				else
				{
					//do all in the logfile...
					t_Result = DoAllInLogfile(a_ErrorObject, a_logname, 0, 0);
				}
				
				//there should be only one partition entry for this case but we'll break anyway...
				break;
			}
			else
			{
				//we have bounds (at least one anyway!)
				DWORD t_tmLower = 0;
				DWORD t_tmUpper = 0xFFFFFFFF;
				BOOL t_bProcess = TRUE;

				if (!t_Node->InfiniteLowerBound())
				{
					WBEMTime t_Time(t_Node->LowerBound());
					time_t t_temp = 0;
					
					if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
					{
						t_tmLower = (DWORD)t_temp;

						if (!t_Node->ClosedLowerBound())
						{
							if (t_tmLower != 0xFFFFFFFF)
							{
								t_tmLower++;
							}
							else
							{
								t_bProcess = FALSE; 
							}
						}

					}
					else
					{
						DWORD t_len =  wcslen(t_Node->LowerBound());

						if (t_len == NTEVT_DMTFLEN)
						{
							BOOL t_bIsLo = FALSE;
							BOOL t_bIsHi = TRUE;

							if (CheckTime(t_Node->LowerBound(), t_bIsLo, t_bIsHi))
							{
								if (t_bIsHi)
								{
									t_bProcess = FALSE;
								}
							}
							else
							{
								t_bProcess = FALSE;
							}
						}
						else
						{
							t_bProcess = FALSE;
						}
					}
				}

				if (!t_Node->InfiniteUpperBound())
				{
					WBEMTime t_Time(t_Node->UpperBound());
					time_t t_temp = 0;
					
					if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
					{
						t_tmUpper = (DWORD)t_temp;

						if (!t_Node->ClosedUpperBound())
						{
							if (t_tmUpper != 0)
							{
								t_tmUpper--;
							}
							else
							{
								t_bProcess = FALSE; 
							}
						}

					}
					else
					{
						DWORD t_len =  wcslen(t_Node->UpperBound());

						if (t_len == NTEVT_DMTFLEN)
						{
							BOOL t_bIsLo = FALSE;
							BOOL t_bIsHi = TRUE;

							if (CheckTime(t_Node->LowerBound(), t_bIsLo, t_bIsHi))
							{
								if (t_bIsLo)
								{
									t_bProcess = FALSE;
								}
							}
							else
							{
								t_bProcess = FALSE;
							}
						}
						else
						{
							t_bProcess = FALSE;
						}
					}
				}

				if (t_tmUpper < t_tmLower)
				{
					t_bProcess = FALSE;
				}

				//now return all records including the bounds
				if (t_bProcess)
				{
					t_Result = GetRecordsBetweenTimes(a_ErrorObject, a_logname, a_Generated, t_tmUpper, t_tmLower);

					if (FAILED(t_Result))
					{
						break;
					}
				}
			}
		}
		else 
		{
			//want records with exactly the right time...
			WBEMTime t_Time(t_Node->LowerBound());
			time_t t_temp = 0;
			
			if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
			{
				t_Result = GetRecordsBetweenTimes(a_ErrorObject, a_logname, a_Generated, (DWORD)t_temp, (DWORD)t_temp);

				if (FAILED(t_Result))
				{
					break;
				}
			}
		}
	}

	return t_Result;
}

HRESULT ExecQueryAsyncEventObject::GetRecordsBetweenTimes(WbemProvErrorObject &a_ErrorObject, LPCWSTR a_logname,
														  BOOL a_Generated, DWORD a_dwUpper, DWORD a_dwLower)
{
	HRESULT retVal = WBEM_E_FAILED;
	CEventLogFile evtLog(a_logname, FALSE);

	if (evtLog.IsValid())
	{
		DWORD t_NewRec = 0;
		DWORD t_NumRecs = 0;

		if (evtLog.GetLastRecordID(t_NewRec, t_NumRecs))
		{
			retVal = WBEM_S_NO_ERROR;

			while (t_NumRecs > 0)
			{
				DWORD t_RecId = t_NumRecs/2;
				
				if (t_NumRecs%2)
				{
					t_RecId++;
				}

				//adjust for the record number offset
				if (t_RecId > t_NewRec)
				{
					//recordnumber has wrapped around...
					t_RecId = 0xFFFFFFFF - t_RecId + t_NewRec + 1;
				}
				else
				{
					t_RecId = t_NewRec - t_RecId + 1;
				}

				DWORD t_dwEventSize = 0;
				DWORD t_dwErr = evtLog.ReadRecord(t_RecId, &t_dwEventSize, TRUE);

				if (0 == t_dwErr)
				{
					EVENTLOGRECORD* t_pEventBuffer = (EVENTLOGRECORD*) evtLog.GetBuffer();
					DWORD t_Time = a_Generated ? t_pEventBuffer->TimeGenerated : t_pEventBuffer->TimeWritten;

					if (a_dwUpper >= t_Time)
					{
						if (a_dwLower <= t_Time)
						{
							//generate all above and below this that match...
							t_NumRecs = 0;
							
							//below...
							while((a_dwUpper >= t_Time) && (a_dwLower <= t_Time) && (t_dwEventSize != 0))
							{
								CEventlogRecord evtrec(a_logname, t_pEventBuffer, NULL, m_ClassObject, m_AClassObject);
								IWbemClassObject* pInst = NULL;
            
								if (evtrec.GenerateInstance(&pInst))
								{
									retVal = m_NotificationHandler->Indicate ( 1, & pInst );
									pInst->Release();

									if (FAILED(retVal))
									{
										a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
										a_ErrorObject.SetMessage ( L"Failed while indicating record instance." );
										break;
									}
								}

								// drop by length of this record and point to next record
								t_dwEventSize -= t_pEventBuffer->Length;

								if (t_dwEventSize == 0)
								{
									t_dwErr = evtLog.ReadRecord(0, &t_dwEventSize, TRUE);

									if (t_dwErr == ERROR_SUCCESS)
									{
										t_pEventBuffer = (EVENTLOGRECORD*) evtLog.GetBuffer();
									}
								}
								else
								{
									t_pEventBuffer = (PEVENTLOGRECORD) ((UCHAR*) t_pEventBuffer + t_pEventBuffer->Length);
								}

								t_Time = a_Generated ? t_pEventBuffer->TimeGenerated : t_pEventBuffer->TimeWritten;
							}

							if (SUCCEEDED(retVal))
							{
								//above...
								evtLog.ReadRecord(t_RecId, &t_dwEventSize, FALSE);
								
								//skip the record we've done already...
								t_pEventBuffer = (EVENTLOGRECORD*) evtLog.GetBuffer();
								t_dwEventSize -= t_pEventBuffer->Length;

								if (t_dwEventSize != 0)
								{
									t_pEventBuffer = (PEVENTLOGRECORD) ((UCHAR*) t_pEventBuffer + t_pEventBuffer->Length);
									t_Time = a_Generated ? t_pEventBuffer->TimeGenerated : t_pEventBuffer->TimeWritten;

									while((a_dwUpper >= t_Time) && (a_dwLower <= t_Time) && (t_dwEventSize != 0))
									{
										CEventlogRecord evtrec(a_logname, t_pEventBuffer, NULL, m_ClassObject, m_AClassObject);
										IWbemClassObject* pInst = NULL;
            
										if (evtrec.GenerateInstance(&pInst))
										{
											retVal = m_NotificationHandler->Indicate ( 1, & pInst );
											pInst->Release();

											if (FAILED(retVal))
											{
												a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
												a_ErrorObject.SetMessage ( L"Failed while indicating record instance." );
												break;
											}

										}

										// drop by length of this record and point to next record
										t_dwEventSize -= t_pEventBuffer->Length;

										if (t_dwEventSize == 0)
										{
											t_dwErr = evtLog.ReadRecord(0, &t_dwEventSize, FALSE);

											if (t_dwErr == ERROR_SUCCESS)
											{
												t_pEventBuffer = (EVENTLOGRECORD*) evtLog.GetBuffer();
											}
										}
										else
										{
											t_pEventBuffer = (PEVENTLOGRECORD) ((UCHAR*) t_pEventBuffer + t_pEventBuffer->Length);
										}

										t_Time = a_Generated ? t_pEventBuffer->TimeGenerated : t_pEventBuffer->TimeWritten;
									}
								}
							}
						}
						else
						{
							//too old, go higher done automatically by halving t_NumRecs
							if (t_NumRecs > 1)
							{
								if ((t_NumRecs%2) || (t_NumRecs == 2))
								{
									t_NumRecs = t_NumRecs/2;
								}
								else
								{
									t_NumRecs = t_NumRecs/2 - 1;
								}
							}
							else
							{
								t_NumRecs = 0;
							}
						}
					}
					else
					{
						//too recent, setup the number of records left and go lower by 
						//setting the upper limit to one less than we've checked... 
						if (t_NumRecs > 1)
						{
							t_NumRecs = t_NumRecs/2;

							if (t_RecId == 1)
							{
								//we've wrapped...
								t_NewRec = 0xFFFFFFFF;
							}
							else
							{
								t_NewRec = t_RecId - 1;
							}
						}
						else
						{
							t_NumRecs = 0;
						}
					}

				}
				else
				{
					t_NumRecs = 0;

					if (t_dwErr != ERROR_HANDLE_EOF)
					{
						a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

						if ((t_dwErr == ERROR_ACCESS_DENIED) || (t_dwErr == ERROR_PRIVILEGE_NOT_HELD))
						{
							a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
							a_ErrorObject.SetSecurityPrivRequired();
							a_ErrorObject.SetSecurityPrivFailed();
							a_ErrorObject.SetPrivilegeFailed();
						}
						else
						{
							a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
						}

						a_ErrorObject.SetMessage ( L"Failed while searching one of the logfiles." );
					}

					break;
				}
			}
		}
	}

	return retVal;
}

HRESULT ExecQueryAsyncEventObject::DoAllInLogfile(WbemProvErrorObject &a_ErrorObject, LPCWSTR a_logname, DWORD a_dwUpper, DWORD a_dwLower)
{
    //process this logfile
	HRESULT retVal = S_OK;
    CEventLogFile evtLog(a_logname, FALSE);
	BOOL bContinue = TRUE;
    
    if (evtLog.IsValid())
    {
        evtLog.ReadLastRecord();
    }

    while (evtLog.IsValid() && SUCCEEDED(retVal) && bContinue)
    {
        DWORD dwEventSize = 0;
        DWORD err = evtLog.ReadRecord(0, &dwEventSize, TRUE);

        if (0 != err)
        {
            if (err != ERROR_HANDLE_EOF)
            {
                a_ErrorObject.SetStatus ( WBEM_PROV_E_UNEXPECTED );

                if ((err == ERROR_ACCESS_DENIED) || (err == ERROR_PRIVILEGE_NOT_HELD))
                {
                    a_ErrorObject.SetWbemStatus ( WBEM_S_ACCESS_DENIED );
                    a_ErrorObject.SetSecurityPrivRequired();
                    a_ErrorObject.SetSecurityPrivFailed();
                    a_ErrorObject.SetPrivilegeFailed();
                }
                else
                {
                    a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
                }

                a_ErrorObject.SetMessage ( L"Failed while enumerating one of the logfiles." );
DebugOut( 
CNTEventProvider::g_NTEvtDebugLog->WriteFileAndLine (  

    _T(__FILE__),__LINE__,
    L"ExecQueryAsyncEventObject :: Query_Record:Failed while enumerating one of the logfiles.\r\n"
    );
)
            }

            break;
        }

        PEVENTLOGRECORD EventBuffer = (PEVENTLOGRECORD)evtLog.GetBuffer();

		if (a_dwUpper != a_dwLower)
		{
			if ((EventBuffer->RecordNumber > a_dwUpper) || (EventBuffer->RecordNumber < a_dwLower))
			{
				break;
			}
		}

        while (dwEventSize != 0)
        {
			if (a_dwUpper != a_dwLower)
			{
				if ((EventBuffer->RecordNumber > a_dwUpper) || (EventBuffer->RecordNumber < a_dwLower))
				{
					bContinue = FALSE;
					break;
				}
			}

            CEventlogRecord evtrec(a_logname, EventBuffer, NULL, m_ClassObject, m_AClassObject);
            IWbemClassObject* pInst = NULL;
            
            if (evtrec.GenerateInstance(&pInst))
            {
                retVal = m_NotificationHandler->Indicate ( 1, & pInst );
                pInst->Release();

				if (FAILED(retVal))
				{
					a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED );
					a_ErrorObject.SetMessage ( L"Failed while indicating record instance." );
				}
            }

            // drop by length of this record and point to next record
            dwEventSize -= EventBuffer->Length;
            EventBuffer = (PEVENTLOGRECORD) ((UCHAR*) EventBuffer + EventBuffer->Length);
        }
    }

	return retVal;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: Compare ( 

	LONG a_Operand1, 
	LONG a_Operand2, 
	ULONG a_Operand1Func,
	ULONG a_Operand2Func,
	WmiTreeNode &a_OperatorType 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True;

	switch ( a_Operand1Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break;

		default:
		{
		}
		break;
	}

	switch ( a_Operand2Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break;

		default:
		{
		}
		break;
	}

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		t_Status = a_Operand1 == a_Operand2 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		t_Status = a_Operand1 != a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		t_Status = a_Operand1 >= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		t_Status = a_Operand1 <= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		t_Status = a_Operand1 < a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		t_Status = a_Operand1 > a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False;

	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	return t_Status;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: Compare ( 

	wchar_t *a_Operand1, 
	wchar_t *a_Operand2, 
	ULONG a_Operand1Func,
	ULONG a_Operand2Func,
	WmiTreeNode &a_OperatorType 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True;

	wchar_t *a_Operand1AfterFunc = NULL;
	wchar_t *a_Operand2AfterFunc = NULL; 

	switch ( a_Operand1Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			ULONG length = wcslen ( a_Operand1 );
			wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ];
			for ( ULONG index = 0; index < length; index ++ )
			{
				a_Operand1AfterFunc [ index ] = towupper ( a_Operand1 [ index ] );
			}
		}
		break;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			ULONG length = wcslen ( a_Operand1 );
			wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ];
			for ( ULONG index = 0; index < length; index ++ )
			{
				a_Operand1AfterFunc [ index ] = towlower ( a_Operand1 [ index ] );
			}
		}
		break;

		default:
		{
		}
		break;
	}

	switch ( a_Operand2Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			ULONG length = wcslen ( a_Operand2 );
			wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ];
			for ( ULONG index = 0; index < length; index ++ )
			{
				a_Operand2AfterFunc [ index ] = towupper ( a_Operand2 [ index ] );
			}
		}
		break;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			ULONG length = wcslen ( a_Operand2 );
			wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ];
			for ( ULONG index = 0; index < length; index ++ )
			{
				a_Operand2AfterFunc [ index ] = towlower ( a_Operand2 [ index ] );
			}
		}
		break;

		default:
		{
		}
		break;
	}

	const wchar_t *t_Arg1 = a_Operand1AfterFunc ? a_Operand1AfterFunc : a_Operand1;
	const wchar_t *t_Arg2 = a_Operand2AfterFunc ? a_Operand2AfterFunc : a_Operand2;

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) == 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) != 0 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) >= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_False ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) <= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) < 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) > 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	delete [] a_Operand1AfterFunc;
	delete [] a_Operand2AfterFunc;

	return t_Status;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: CompareDateTime ( 

	IWbemClassObject *a_ClassObject,
	BSTR a_PropertyName, 
	WmiTreeNode *a_Operator,
	WmiTreeNode *a_Operand 
)
{
/*
 *	If property and value can never occur then return State_False to imply empty set
 *	If property and value do not infer anything then return State_Undefined.
 */
	WmiStringNode *t_StringNode = ( WmiStringNode * ) a_Operand;

	if ( t_StringNode == NULL || t_StringNode->GetValue() == NULL)
	{
		return QueryPreprocessor :: QuadState :: State_False;
	}

	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True;
	WBEMTime t_Time((const BSTR)t_StringNode->GetValue());

	if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualNode ) )
	{
		time_t t_temp = 0;
		t_Status = (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
					? QueryPreprocessor :: QuadState :: State_Undefined
					: QueryPreprocessor :: QuadState :: State_False;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		time_t t_temp = 0;
		t_Status = (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
					? QueryPreprocessor :: QuadState :: State_Undefined
					: QueryPreprocessor :: QuadState :: State_True;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		//to do: check t_time >= val this will always be true if t_time >= max time_t
		//will always be false if t_time is < 1970.
		time_t t_temp = 0;
		
		if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
		{
			t_Status = QueryPreprocessor :: QuadState :: State_Undefined;
		}
		else
		{
			DWORD t_len =  wcslen(t_StringNode->GetValue());

			if (t_len == NTEVT_DMTFLEN)
			{
				BOOL t_bIsLo = FALSE;
				BOOL t_bIsHi = TRUE;

				if (CheckTime(t_StringNode->GetValue(), t_bIsLo, t_bIsHi))
				{
					if (t_bIsHi)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_True;
					}
					else if (t_bIsLo)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_False;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True;
			}
		}
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		//to do: check t_time <= val this will always be true if t_time <= 1970
		//will always be false if t_time is > max time_t.
		time_t t_temp = 0;
		
		if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
		{
			t_Status = QueryPreprocessor :: QuadState :: State_Undefined;
		}
		else
		{
			DWORD t_len =  wcslen(t_StringNode->GetValue());

			if (t_len == NTEVT_DMTFLEN)
			{
				BOOL t_bIsLo = FALSE;
				BOOL t_bIsHi = TRUE;

				if (CheckTime(t_StringNode->GetValue(), t_bIsLo, t_bIsHi))
				{
					if (t_bIsHi)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_False;
					}
					else if (t_bIsLo)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_True;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True;
			}
		}
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLessNode ) )
	{
		//to do: check t_time < val this will always be true if t_time < 1970
		//will always be false if t_time is > max time_t.
		time_t t_temp = 0;
		
		if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
		{
			t_Status = QueryPreprocessor :: QuadState :: State_Undefined;
		}
		else
		{
			DWORD t_len =  wcslen(t_StringNode->GetValue());

			if (t_len == NTEVT_DMTFLEN)
			{
				BOOL t_bIsLo = FALSE;
				BOOL t_bIsHi = TRUE;

				if (CheckTime(t_StringNode->GetValue(), t_bIsLo, t_bIsHi))
				{
					if (t_bIsHi)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_False;
					}
					else if (t_bIsLo)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_True;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True;
			}
		}
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorGreaterNode ) )
	{
		//to do: check t_time > val this will always be true if t_time > max time_t
		//will always be false if t_time is < 1970.
		time_t t_temp = 0;
		
		if (t_Time.IsOk() && t_Time.Gettime_t(&t_temp)) 
		{
			t_Status = QueryPreprocessor :: QuadState :: State_Undefined;
		}
		else
		{
			DWORD t_len =  wcslen(t_StringNode->GetValue());

			if (t_len == NTEVT_DMTFLEN)
			{
				BOOL t_bIsLo = FALSE;
				BOOL t_bIsHi = TRUE;

				if (CheckTime(t_StringNode->GetValue(), t_bIsLo, t_bIsHi))
				{
					if (t_bIsHi)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_True;
					}
					else if (t_bIsLo)
					{
						t_Status = QueryPreprocessor :: QuadState :: State_False;
					}
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True;
				}
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True;
			}
		}
	}

	return t_Status;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: CompareString ( 

	IWbemClassObject *a_ClassObject,
	BSTR a_PropertyName, 
	WmiTreeNode *a_Operator,
	WmiTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True;

	WmiStringNode *t_StringNode = ( WmiStringNode * ) a_Operand; 

	VARIANT t_Variant;
	VariantInit ( & t_Variant );

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName, 0, &t_Variant, NULL, NULL );
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_StringNode->GetValue (),
			t_Variant.bstrVal,
			t_StringNode->GetPropertyFunction (),
			t_StringNode->GetConstantFunction (),
			*a_Operator 
		);
	}

	VariantClear ( & t_Variant );

	return t_Status;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: CompareInteger ( 

	IWbemClassObject *a_ClassObject,
	BSTR a_PropertyName, 
	WmiTreeNode *a_Operator,
	WmiTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True;

	WmiSignedIntegerNode *t_IntegerNode = ( WmiSignedIntegerNode * ) a_Operand; 

	VARIANT t_Variant;
	VariantInit ( & t_Variant );

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName, 0, &t_Variant, NULL, NULL );
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_IntegerNode->GetValue (),
			t_Variant.lVal,
			t_IntegerNode->GetPropertyFunction (),
			t_IntegerNode->GetConstantFunction (),
			*a_Operator 
		);
	}

	VariantClear ( & t_Variant );

	return t_Status;
}

WmiTreeNode *ExecQueryAsyncEventObject :: AllocTypeNode ( 

	void *a_Context,
	BSTR a_PropertyName, 
	VARIANT &a_Variant, 
	WmiValueNode :: WmiValueFunction a_PropertyFunction,
	WmiValueNode :: WmiValueFunction a_ConstantFunction,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL;

	VARTYPE t_VarType = VT_NULL;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_CLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_SUPERCLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_GENUS ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode ( 

				a_PropertyName, 
				a_Variant.lVal, 
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_SERVER ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_NAMESPACE ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode ( 

				a_PropertyName, 
				a_Variant.lVal, 
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_DYNASTY ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_RELPATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_PATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName, 
				a_Variant.bstrVal, 
				a_PropertyFunction,
				a_ConstantFunction,
				0xFFFFFFFF,
				a_Parent 
			);
		}
		else if ( _wcsicmp ( a_PropertyName, SYSTEM_PROPERTY_DERIVATION ) == 0 )
		{
		}
	}
	else
	{
		CIMTYPE t_VarType;
		long t_Flavour;
		VARIANT t_Variant;
		VariantInit ( & t_Variant );

		HRESULT t_Result = m_ClassObject->Get (

			a_PropertyName,
			0,
			& t_Variant,
			& t_VarType,
			& t_Flavour
		);

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_VarType & CIM_FLAG_ARRAY )
			{
			}
			else
			{
				switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
				{
					case CIM_BOOLEAN:
					{
						if(V_VT(&a_Variant) == VT_I4)
                        {
                            t_Node = new WmiSignedIntegerNode ( 

								a_PropertyName, 
								a_Variant.lVal, 
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
                        }
						else if (V_VT(&a_Variant) == VT_BOOL)
						{
                            t_Node = new WmiSignedIntegerNode ( 

								a_PropertyName, 
								(a_Variant.lVal == VARIANT_FALSE) ? 0 : 1, 
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
						}
					}
					break;

					case CIM_SINT8:
					case CIM_SINT16:
					case CIM_CHAR16:
					case CIM_SINT32:
					{
						if(V_VT(&a_Variant) == VT_I4)
                        {
                            t_Node = new WmiSignedIntegerNode ( 

								a_PropertyName, 
								a_Variant.lVal, 
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
                        }
					}
					break;

					case CIM_UINT8:
					case CIM_UINT16:
					case CIM_UINT32:
					{
						if(V_VT(&a_Variant) == VT_I4)
                        {
                            t_Node = new WmiUnsignedIntegerNode ( 

								a_PropertyName, 
								a_Variant.lVal, 
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
                        }
					}
					break;

					case CIM_SINT64:
					case CIM_UINT64:
					{
						if(V_VT(&a_Variant) == VT_BSTR)
                        {
                            t_Node = new WmiStringNode ( 

								a_PropertyName, 
								a_Variant.bstrVal, 
								a_PropertyFunction,
								a_ConstantFunction,
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
                        }
						else if(V_VT(&a_Variant) == VT_I4)
						{
							_variant_t t_uintBuff (&a_Variant);

                            t_Node = new WmiStringNode ( 

								a_PropertyName, 
								(BSTR)((_bstr_t) t_uintBuff), 
								a_PropertyFunction,
								a_ConstantFunction,
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
						}
					}
					break;

					case CIM_STRING:
					case CIM_DATETIME:
					case CIM_REFERENCE:
					{
						if(V_VT(&a_Variant) == VT_BSTR)
                        {
                            t_Node = new WmiStringNode ( 

								a_PropertyName, 
								a_Variant.bstrVal, 
								a_PropertyFunction,
								a_ConstantFunction,
								GetPriority ( a_PropertyName ),
								a_Parent 
							);
                        }
					}
					break;

					case CIM_REAL32:
					case CIM_REAL64:
					{
					}
					break;

					case CIM_OBJECT:
					case CIM_EMPTY:
					{
					}
					break;

					default:
					{
					}
					break;
				}
			}
		}

		VariantClear ( & t_Variant );
	}

	return t_Node;
}

QueryPreprocessor :: QuadState ExecQueryAsyncEventObject :: InvariantEvaluate ( 

	void *a_Context,
	WmiTreeNode *a_Operator,
	WmiTreeNode *a_Operand 
)
{
/*
 *  If property and value are invariant i.e. will never change for all instances then return State_True.
 *	If property is not indexable or keyed then return State_True to define an unknown number of possible values which we cannot optimise against.
 *	If property and value can never occur then return State_False to imply empty set
 *	If property and value do not infer anything then return State_Undefined.
 *	If property and value are in error then return State_Error
 *	Never return State_ReEvaluate.
 */

	QueryPreprocessor :: QuadState t_State = QueryPreprocessor :: QuadState :: State_Error;

	WmiValueNode *t_Node = ( WmiValueNode * ) a_Operand;
	BSTR t_PropertyName = t_Node->GetPropertyName ();

	if ( t_PropertyName != NULL )
	{
		if ( *t_PropertyName == L'_' )
		{
			// System property, must check values

			if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_CLASS ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_CLASS,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_SUPERCLASS,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_GENUS ) == 0 )
			{
				t_State = CompareInteger ( 

					m_ClassObject,
					SYSTEM_PROPERTY_GENUS,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_SERVER ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_SERVER,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_NAMESPACE ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_NAMESPACE,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 )
			{
				t_State = CompareInteger ( 

					m_ClassObject,
					SYSTEM_PROPERTY_PROPERTY_COUNT,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_DYNASTY ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_DYNASTY,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_RELPATH ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_RELPATH,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_PATH ) == 0 )
			{
				t_State = CompareString ( 

					m_ClassObject,
					SYSTEM_PROPERTY_PATH,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, SYSTEM_PROPERTY_DERIVATION ) == 0 )
			{
				t_State = QueryPreprocessor :: QuadState :: State_Undefined;
			}
			else
			{
				t_State = QueryPreprocessor :: QuadState :: State_Undefined;
			}
		}
		else
		{
			//if it is time generated or time written check the max and min are ok
			if ( _wcsicmp ( t_PropertyName, GENERATED_PROP ) == 0 )
			{
				t_State = CompareDateTime ( 

					m_ClassObject,
					SYSTEM_PROPERTY_PATH,
					a_Operator,
					a_Operand
				);
			}
			else if ( _wcsicmp ( t_PropertyName, WRITTEN_PROP ) == 0 )
			{
				t_State = CompareDateTime ( 

					m_ClassObject,
					SYSTEM_PROPERTY_PATH,
					a_Operator,
					a_Operand
				);
			}
			else
			{
				t_State = QueryPreprocessor :: QuadState :: State_Undefined;
			}
		}
	}
	else
	{
		t_State = QueryPreprocessor :: QuadState :: State_Undefined;
	}

	return t_State;
}

WmiRangeNode *ExecQueryAsyncEventObject :: AllocInfiniteRangeNode (

	void *a_Context,
	BSTR a_PropertyName 
)
{
	WmiRangeNode *t_RangeNode = NULL;

	CIMTYPE t_VarType;
	long t_Flavour;
	VARIANT t_Variant;
	VariantInit ( & t_Variant );

	HRESULT t_Result = m_ClassObject->Get (

		a_PropertyName,
		0,
		& t_Variant,
		& t_VarType,
		& t_Flavour
	);

	if ( SUCCEEDED ( t_Result ) )
	{
		if ( t_VarType & CIM_FLAG_ARRAY )
		{
		}
		else
		{
			switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
			{
				case CIM_BOOLEAN:
				case CIM_SINT8:
				case CIM_SINT16:
				case CIM_CHAR16:
				case CIM_SINT32:
				{
					t_RangeNode = new WmiSignedIntegerRangeNode ( 

						a_PropertyName, 
						0xFFFFFFFF, 
						TRUE,
						TRUE,
						FALSE,
						FALSE,
						0,
						0,
						NULL, 
						NULL 
					);
				}
				break;

				case CIM_UINT8:
				case CIM_UINT16:
				case CIM_UINT32:
				{
					t_RangeNode = new WmiUnsignedIntegerRangeNode ( 

						a_PropertyName, 
						0xFFFFFFFF, 
						TRUE,
						TRUE,
						FALSE,
						FALSE,
						0,
						0,
						NULL, 
						NULL 
					);
				}
				break;

				case CIM_SINT64:
				case CIM_UINT64:
				case CIM_STRING:
				case CIM_DATETIME:
				case CIM_REFERENCE:
				{
					t_RangeNode = new WmiStringRangeNode ( 

						a_PropertyName, 
						0x0, 
						TRUE,
						TRUE,
						FALSE,
						FALSE,
						NULL,
						NULL,
						NULL, 
						NULL 
					);
				}
				break;

				case CIM_REAL32:
				case CIM_REAL64:
				{
				}
				break;

				case CIM_OBJECT:
				case CIM_EMPTY:
				{
				}
				break;

				default:
				{
				}
				break;
			}
		}

	}

	VariantClear ( & t_Variant );

	return t_RangeNode;
}

ULONG ExecQueryAsyncEventObject :: GetPriority ( BSTR a_PropertyName )
{
	if ( _wcsicmp ( a_PropertyName, LOGFILE_PROP ) == 0 )
	{
		return 0;
	}

	if ( _wcsicmp ( a_PropertyName, RECORD_PROP ) == 0 )
	{
		return 1;
	}

	if ( _wcsicmp ( a_PropertyName, GENERATED_PROP ) == 0 )
	{
		return 2;
	}

	if ( _wcsicmp ( a_PropertyName, WRITTEN_PROP ) == 0 )
	{
		return 3;
	}

	return 0xFFFFFFFF;
}

BOOL ExecQueryAsyncEventObject::CheckTime( const BSTR a_wszText, BOOL &a_IsLow, BOOL &a_IsHigh )
{
	a_IsLow = FALSE;
	a_IsHigh = FALSE;

	if (a_wszText == NULL)
	{
		return FALSE;
	}

    wchar_t t_DefaultBuffer[] = {L"16010101000000.000000+000"} ;
    wchar_t t_DateBuffer[ NTEVT_DMTFLEN + 1 ] ;
            t_DateBuffer[ NTEVT_DMTFLEN ] = NULL ;

    // wildcard cleanup and validation
    // ===============================

    if( NTEVT_DMTFLEN != wcslen(a_wszText) )
    {
        return FALSE ;  
    }
    
    const wchar_t *t_pwBuffer = (const wchar_t*)a_wszText ;
    
    for( int t_i = 0; t_i < NTEVT_DMTFLEN; t_i++ )
    {
        switch( a_wszText[ t_i ] )
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                // stepping on separator or sign
                if( NTEVT_DECPOS == t_i || NTEVT_SGNPOS == t_i )
                {
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = a_wszText[ t_i ] ;
                
                break ;
            }           
            case '*':
            {               
                // stepping on separator or sign
                if( NTEVT_DECPOS == t_i || NTEVT_SGNPOS == t_i )
                {
                    return FALSE ;  
                }
                else
                {
                    // replace with default stamp
                    t_DateBuffer[ t_i ] = t_DefaultBuffer[ t_i ] ; 
                }   
                break ;
            }           
            case '.':
            {
                if( NTEVT_DECPOS != t_i )
                {
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = a_wszText[ t_i ] ;

                break ;
            }           
            case '+':
            case '-':
            {
                if( NTEVT_SGNPOS != t_i )
                {
                    return FALSE ;  
                }
                t_DateBuffer[ t_i ] = a_wszText[ t_i ] ;
                break ;
            }           
            default:
            {
                return FALSE ;
            }           
        }
    }

    // Parse it
    // ========

    int nYear, nMonth, nDay, nHour, nMinute, nSecond, nMicro, nOffset;
    WCHAR wchSep;

    int nRes = swscanf (

        (LPCWSTR)&t_DateBuffer, 
        L"%4d%2d%2d%2d%2d%2d.%6d%c%3d", 
        &nYear, 
        &nMonth, 
        &nDay, 
        &nHour, 
        &nMinute, 
        &nSecond, 
        &nMicro, 
        &wchSep, 
        &nOffset
    );

    if ( ( 9 != nRes ) )    
    {
        return FALSE;
    }

	if (nYear < 1970)
	{
		a_IsLow = TRUE;
		return TRUE;
	}

	BOOL retVal = FALSE;
	WBEMTime t_max ((time_t)0xFFFFFFFF);
	BSTR t_temp = t_max.GetBSTR();

	if (t_temp)
	{
		if (_wcsicmp(a_wszText, t_temp) >= 0)
		{
			a_IsHigh = TRUE;
			retVal = TRUE;
		}

		SysFreeString(t_temp);
	}

	// if we got here, the earlier WBEMTIME should have been OK so return FALSE.
    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtinst.h ===
//***************************************************************************

//

//  NTEVTINST.H

//

//  Module: 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTINST_H
#define _NT_EVT_PROV_NTEVTINST_H


#define WBEM_CLASS_EXTENDEDSTATUS	L"Win32_PrivilegesStatus" 

#define WBEM_TASKSTATE_START					0x0
#define WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE	0x100000
#define WBEM_TASKSTATE_ASYNCHRONOUSABORT		0x100001

class WbemTaskObject
{
private:
protected:

	ULONG m_State ;
	WbemProvErrorObject m_ErrorObject ;

	ULONG m_RequestHandle ;
	ULONG m_OperationFlag ;
	IWbemClassObject *m_ClassObject ;
	IWbemClassObject *m_AClassObject ;
	IWbemObjectSink *m_NotificationHandler ;
	IWbemContext *m_Ctx ;
	CImpNTEvtProv *m_Provider ;

protected:

	void SetRequestHandle ( ULONG a_RequestHandle ) ;
	BOOL GetRequestHandle () ;
	BOOL GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;
	BOOL GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;
	BOOL GetClassObject ( BSTR a_Class ) ;

public:

	static IWbemClassObject *g_ClassArray[NT_EVTLOG_MAX_CLASSES];
	static BOOL GetClassObject ( BSTR a_Class, BOOL a_bAmended, IWbemServices *a_Server,  IWbemContext *a_Ctx, IWbemClassObject **a_pClass ) ;

	WbemTaskObject ( 

		CImpNTEvtProv *a_Provider ,
		IWbemObjectSink *a_NotificationHandler ,
		ULONG a_OperationFlag ,
		IWbemContext *a_Ctx
	) ;

	virtual void Process() {}

	~WbemTaskObject () ;

	WbemProvErrorObject &GetErrorObject () ;

} ;

class ExecQueryAsyncEventObject;

class GetObjectAsyncEventObject : public WbemTaskObject
{
friend ExecQueryAsyncEventObject;
private:

	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;
	IWbemClassObject *m_Out;
	BOOL m_bIndicate;

	BOOL Dispatch_Record ( WbemProvErrorObject &a_ErrorObject );
	BOOL Get_Record ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey , KeyRef *a_RecordKey );
	BOOL Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject );
	BOOL Get_EventLog ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey);
	BOOL Dispatch_LogRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Dispatch_UserRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Dispatch_ComputerRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Get_LogRecord ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_LogKey , KeyRef *a_RecordKey ) ;
	BOOL Get_UserRecord ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_UserKey , KeyRef *a_RecordKey ) ;
	BOOL Get_ComputerRecord ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_CompKey , KeyRef *a_RecordKey ) ;

protected:

	BOOL GetObject ( WbemProvErrorObject &a_ErrorObject ) ;


public:

	GetObjectAsyncEventObject ( 

		CImpNTEvtProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx ,
		BOOL a_bIndicate = TRUE
	) ;

	~GetObjectAsyncEventObject () ;

	void Process () ;
} ;


class ExecMethodAsyncEventObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	wchar_t *m_Method ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;
	IWbemClassObject* m_InParamObject;
	BOOL m_bIndicateOutParam;
	IWbemClassObject* m_pOutClass;

	BOOL Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject );
	BOOL ExecMethod_EventLog ( WbemProvErrorObject &a_ErrorObject , KeyRef *a_FileKey);

protected:

	BOOL ExecMethod ( WbemProvErrorObject &a_ErrorObject ) ;

public:

	ExecMethodAsyncEventObject ( 

		CImpNTEvtProv *a_Provider , 
		wchar_t *a_ObjectPath ,
		wchar_t *a_MethodName,
		ULONG a_Flag ,
		IWbemClassObject *a_InParams ,		
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~ExecMethodAsyncEventObject () ;

	void Process () ;
} ;


class PutInstanceAsyncEventObject : public WbemTaskObject
{
private:

	IWbemClassObject *m_InstObject ;

	BOOL Dispatch_EventLog ( WbemProvErrorObject &a_ErrorObject );

protected:

	BOOL PutInstance ( WbemProvErrorObject &a_ErrorObject ) ;


public:

	PutInstanceAsyncEventObject ( 

		CImpNTEvtProv *a_Provider , 
		IWbemClassObject *a_Inst , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~PutInstanceAsyncEventObject () ;

	void Process () ;
} ;

class ExecQueryAsyncEventObject : public WbemTaskObject, public QueryPreprocessor
{
private:

	wchar_t *m_QueryFormat ; 
	wchar_t *m_Query ;
	wchar_t *m_Class ;

	SQL_LEVEL_1_RPN_EXPRESSION *m_RPNExpression ;

	QueryPreprocessor::QuadState Compare(wchar_t *a_Operand1, wchar_t *a_Operand2, 
											DWORD a_Operand1Func, DWORD a_Operand2Func,
											WmiTreeNode &a_OperatorType);

	QueryPreprocessor::QuadState Compare(LONG a_Operand1, LONG a_Operand2 , 
											DWORD a_Operand1Func, DWORD a_Operand2Func,
											WmiTreeNode &a_OperatorType);

	QueryPreprocessor::QuadState CompareString(IWbemClassObject *a_ClassObject, BSTR a_PropertyName , 
												WmiTreeNode *a_Operator, WmiTreeNode *a_Operand);

	QueryPreprocessor::QuadState CompareInteger(IWbemClassObject *a_ClassObject, BSTR a_PropertyName, 
												WmiTreeNode *a_Operator, WmiTreeNode *a_Operand);

	QueryPreprocessor :: QuadState CompareDateTime (IWbemClassObject *a_ClassObject, BSTR a_PropertyName, 
												WmiTreeNode *a_Operator, WmiTreeNode *a_Operand);

	HRESULT GetRecordsBetweenTimes(WbemProvErrorObject &a_ErrorObject, LPCWSTR a_logname,
														  BOOL a_Generated, DWORD a_dwUpper, DWORD a_dwLower);

	HRESULT RecurseLogFile (WbemProvErrorObject &a_ErrorObject, PartitionSet *a_PartitionSet, LPCWSTR a_logname);
	HRESULT RecurseRecord (WbemProvErrorObject &a_ErrorObject, PartitionSet *a_PartitionSet, LPCWSTR a_logname);
	HRESULT DoAllInLogfile(WbemProvErrorObject &a_ErrorObject, LPCWSTR a_logname, DWORD a_dwUpper, DWORD a_dwLower);
	HRESULT RecurseTime(WbemProvErrorObject &a_ErrorObject, PartitionSet *a_PartitionSet, LPCWSTR a_logname, BOOL a_Generated);
	BOOL CheckTime( const BSTR a_wszText, BOOL &a_IsLow, BOOL &a_IsHigh );

protected:

	BOOL ExecQuery ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL DispatchQuery ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Query_Record ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Query_EventLog ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Query_LogRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Query_UserRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL Query_ComputerRecord ( WbemProvErrorObject &a_ErrorObject ) ;
	BOOL OptimizeAssocQuery ( WbemProvErrorObject &a_ErrorObject , BSTR *a_ObjectPath);
	BOOL GenerateLogAssocs( WbemProvErrorObject &a_ErrorObject, const wchar_t* logPath,
								const wchar_t* logName, BOOL bVerifyLogname, BOOL *pbContinue = NULL);
	BOOL GenerateCompUserAssocs ( WbemProvErrorObject &a_ErrorObject, BOOL bComp );
	wchar_t* GetClassFromPath(wchar_t* path);

    // Query Processing Functions
    //============================
	QuadState InvariantEvaluate(void *a_Context, WmiTreeNode *a_Operator, WmiTreeNode *a_Operand);
	WmiRangeNode *AllocInfiniteRangeNode(void *a_Context, BSTR a_PropertyName);
	virtual DWORD GetPriority ( BSTR a_PropertyName ) ;
	WmiTreeNode *AllocTypeNode (void *a_Context, BSTR a_PropertyName, 
								VARIANT &a_Variant,	WmiValueNode::WmiValueFunction a_PropertyFunction,
								WmiValueNode :: WmiValueFunction a_ConstantFunction, WmiTreeNode *a_Parent);

public:

	ExecQueryAsyncEventObject ( 

		CImpNTEvtProv *a_Provider , 
		BSTR a_QueryFormat , 
		BSTR a_Query , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~ExecQueryAsyncEventObject () ;

	void Process () ;
} ;

#endif //_NT_EVT_PROV_NTEVTINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtserv.h ===
//***************************************************************************

//

//  NTEVTSERV.H

//

//  Module: 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTSERV_H
#define _NT_EVT_PROV_NTEVTSERV_H

typedef 
enum tag_WBEMPROVSTATUS
{

	WBEM_PROV_NO_ERROR							= 0,
	WBEM_PROV_S_NO_ERROR							= 0,
	WBEM_PROV_S_NO_MORE_DATA						= 0x40001,
	WBEM_PROV_S_ALREADY_EXISTS					= WBEM_PROV_S_NO_MORE_DATA + 1,
	WBEM_PROV_S_NOT_FOUND						= WBEM_PROV_S_ALREADY_EXISTS + 1,
	WBEM_PROV_S_RESET_TO_DEFAULT					= WBEM_PROV_S_NOT_FOUND + 1,
	WBEM_PROV_E_FAILED							= 0x80041001,
	WBEM_PROV_E_NOT_FOUND						= WBEM_PROV_E_FAILED + 1,
	WBEM_PROV_E_ACCESS_DENIED					= WBEM_PROV_E_NOT_FOUND + 1,
	WBEM_PROV_E_PROVIDER_FAILURE					= WBEM_PROV_E_ACCESS_DENIED + 1,
	WBEM_PROV_E_TYPE_MISMATCH					= WBEM_PROV_E_PROVIDER_FAILURE + 1,
	WBEM_PROV_E_OUT_OF_MEMORY					= WBEM_PROV_E_TYPE_MISMATCH + 1,
	WBEM_PROV_E_INVALID_CONTEXT					= WBEM_PROV_E_OUT_OF_MEMORY + 1,
	WBEM_PROV_E_INVALID_PARAMETER				= WBEM_PROV_E_INVALID_CONTEXT + 1,
	WBEM_PROV_E_NOT_AVAILABLE					= WBEM_PROV_E_INVALID_PARAMETER + 1,
	WBEM_PROV_E_CRITICAL_ERROR					= WBEM_PROV_E_NOT_AVAILABLE + 1,
	WBEM_PROV_E_INVALID_STREAM					= WBEM_PROV_E_CRITICAL_ERROR + 1,
	WBEM_PROV_E_NOT_SUPPORTED					= WBEM_PROV_E_INVALID_STREAM + 1,
	WBEM_PROV_E_INVALID_SUPERCLASS				= WBEM_PROV_E_NOT_SUPPORTED + 1,
	WBEM_PROV_E_INVALID_NAMESPACE				= WBEM_PROV_E_INVALID_SUPERCLASS + 1,
	WBEM_PROV_E_INVALID_OBJECT					= WBEM_PROV_E_INVALID_NAMESPACE + 1,
	WBEM_PROV_E_INVALID_CLASS					= WBEM_PROV_E_INVALID_OBJECT + 1,
	WBEM_PROV_E_PROVIDER_NOT_FOUND				= WBEM_PROV_E_INVALID_CLASS + 1,
	WBEM_PROV_E_INVALID_PROVIDER_REGISTRATION	= WBEM_PROV_E_PROVIDER_NOT_FOUND + 1,
	WBEM_PROV_E_PROVIDER_LOAD_FAILURE			= WBEM_PROV_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_PROV_E_INITIALIZATION_FAILURE			= WBEM_PROV_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_PROV_E_TRANSPORT_FAILURE				= WBEM_PROV_E_INITIALIZATION_FAILURE + 1,
	WBEM_PROV_E_INVALID_OPERATION				= WBEM_PROV_E_TRANSPORT_FAILURE + 1,
	WBEM_PROV_E_INVALID_QUERY					= WBEM_PROV_E_INVALID_OPERATION + 1,
	WBEM_PROV_E_INVALID_QUERY_TYPE				= WBEM_PROV_E_INVALID_QUERY + 1,
	WBEM_PROV_E_ALREADY_EXISTS					= WBEM_PROV_E_INVALID_QUERY_TYPE + 1,
	WBEM_PROV_E_OVERRIDE_NOT_ALLOWED				= WBEM_PROV_E_ALREADY_EXISTS + 1,
	WBEM_PROV_E_PROPAGATED_QUALIFIER				= WBEM_PROV_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_PROV_E_UNEXPECTED						= WBEM_PROV_E_PROPAGATED_QUALIFIER + 1,
	WBEM_PROV_E_ILLEGAL_OPERATION				= WBEM_PROV_E_UNEXPECTED + 1,
	WBEM_PROV_E_CANNOT_BE_KEY					= WBEM_PROV_E_ILLEGAL_OPERATION + 1,
	WBEM_PROV_E_INCOMPLETE_CLASS					= WBEM_PROV_E_CANNOT_BE_KEY + 1,
	WBEM_PROV_E_INVALID_SYNTAX					= WBEM_PROV_E_INCOMPLETE_CLASS + 1,
	WBEM_PROV_E_NONDECORATED_OBJECT				= WBEM_PROV_E_INVALID_SYNTAX + 1,
	WBEM_PROV_E_READ_ONLY						= WBEM_PROV_E_NONDECORATED_OBJECT + 1,
	WBEM_PROV_E_PROVIDER_NOT_CAPABLE				= WBEM_PROV_E_READ_ONLY + 1,
	WBEM_PROV_E_CLASS_HAS_CHILDREN				= WBEM_PROV_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_PROV_E_CLASS_HAS_INSTANCES				= WBEM_PROV_E_CLASS_HAS_CHILDREN + 1 ,

	// Added

	WBEM_PROV_E_INVALID_PROPERTY					= WBEM_PROV_E_CLASS_HAS_INSTANCES + 1 ,
	WBEM_PROV_E_INVALID_QUALIFIER				= WBEM_PROV_E_INVALID_PROPERTY + 1 ,
	WBEM_PROV_E_INVALID_PATH						= WBEM_PROV_E_INVALID_QUALIFIER + 1 ,
	WBEM_PROV_E_INVALID_PATHKEYPARAMETER			= WBEM_PROV_E_INVALID_PATH + 1 ,
	WBEM_PROV_E_MISSINGPATHKEYPARAMETER 			= WBEM_PROV_E_INVALID_PATHKEYPARAMETER + 1 ,	
	WBEM_PROV_E_INVALID_KEYORDERING				= WBEM_PROV_E_MISSINGPATHKEYPARAMETER + 1 ,	
	WBEM_PROV_E_DUPLICATEPATHKEYPARAMETER		= WBEM_PROV_E_INVALID_KEYORDERING + 1 ,
	WBEM_PROV_E_MISSINGKEY						= WBEM_PROV_E_DUPLICATEPATHKEYPARAMETER + 1 ,
	WBEM_PROV_E_INVALID_TRANSPORT				= WBEM_PROV_E_MISSINGKEY + 1 ,
	WBEM_PROV_E_INVALID_TRANSPORTCONTEXT			= WBEM_PROV_E_INVALID_TRANSPORT + 1 ,
	WBEM_PROV_E_TRANSPORT_ERROR					= WBEM_PROV_E_INVALID_TRANSPORTCONTEXT + 1 ,
	WBEM_PROV_E_TRANSPORT_NO_RESPONSE			= WBEM_PROV_E_TRANSPORT_ERROR + 1 ,
	WBEM_PROV_E_NOWRITABLEPROPERTIES				= WBEM_PROV_E_TRANSPORT_NO_RESPONSE + 1 ,
	WBEM_PROV_E_NOREADABLEPROPERTIES				= WBEM_PROV_E_NOWRITABLEPROPERTIES + 1 

} WBEMPROVSTATUS;


class WbemProvErrorObject 
{
private:

	enum tag_ProvPrivileges
	{
		PROV_PRIV_SECURITY = 1,
		PROV_PRIV_BACKUP = 2
	} PROVPRIVILEGES;

	wchar_t *m_provErrorMessage ;
	WBEMPROVSTATUS m_provErrorStatus ;
	WBEMSTATUS m_wbemErrorStatus ;
	BOOL m_privilegeFailed;
	DWORD m_PrivsReqd;
	DWORD m_PrivsFailed;

	BOOL SetPrivVariant ( VARIANT &a_V, DWORD dwVal );

protected:
public:


	WbemProvErrorObject () : m_privilegeFailed ( FALSE ) ,
							m_provErrorMessage ( NULL ) ,
							m_wbemErrorStatus ( WBEM_NO_ERROR ) ,
							m_provErrorStatus ( WBEM_PROV_NO_ERROR ),
							m_PrivsReqd (0),
							m_PrivsFailed (0) {}
	virtual ~WbemProvErrorObject () { delete [] m_provErrorMessage ; }

	void SetStatus ( WBEMPROVSTATUS a_provErrorStatus )
	{
		m_provErrorStatus = a_provErrorStatus ;
	} 

	void SetWbemStatus ( WBEMSTATUS a_wbemErrorStatus ) 
	{
		m_wbemErrorStatus = a_wbemErrorStatus ;
	}

	void SetMessage ( wchar_t *a_provErrorMessage )
	{
		delete [] m_provErrorMessage ;
		m_provErrorMessage = UnicodeStringDuplicate ( a_provErrorMessage ) ;
	}

	void SetPrivilegeFailed ( BOOL a_PrivilegeFailed = TRUE )
	{
		m_privilegeFailed = a_PrivilegeFailed;
	}

	void SetBackupPrivRequired () { m_PrivsReqd = m_PrivsReqd | PROV_PRIV_BACKUP; }
	void SetSecurityPrivRequired () { m_PrivsReqd = m_PrivsReqd | PROV_PRIV_SECURITY; }
	void SetBackupPrivFailed () { m_PrivsFailed = m_PrivsFailed | PROV_PRIV_BACKUP; }
	void SetSecurityPrivFailed () { m_PrivsFailed = m_PrivsFailed | PROV_PRIV_SECURITY; }

	BOOL SetPrivRequiredVariant ( VARIANT &a_V ) { return SetPrivVariant(a_V, m_PrivsReqd); }
	BOOL SetPrivFailedVariant ( VARIANT &a_V ) { return SetPrivVariant(a_V, m_PrivsFailed); }

	wchar_t *GetMessage () { return m_provErrorMessage ; } ;
	WBEMPROVSTATUS GetStatus () { return m_provErrorStatus ; } ;
	WBEMSTATUS GetWbemStatus () { return m_wbemErrorStatus ; } ;
	BOOL GetPrivilegeFailed () { return m_privilegeFailed ; }
} ;

class CImpNTEvtProv : public IWbemServices, public IWbemProviderInit
{
private:

	BOOL m_Initialised ;
	LONG m_ReferenceCount ;         //Object reference count

	CCriticalSection m_NotifyLock ;
	CCriticalSection m_ExtendedNotifyLock ;

	WbemNamespacePath m_NamespacePath ;
	wchar_t *m_Namespace ;

	IWbemServices *m_Server ;

	wchar_t *m_localeId ;

	BOOL m_GetNotifyCalled ;
	BOOL m_GetExtendedNotifyCalled ;
	IWbemClassObject *m_NotificationClassObject ;
	IWbemClassObject *m_ExtendedNotificationClassObject ;

protected:
public:

	CImpNTEvtProv () ;
    ~CImpNTEvtProv () ;

	// Implementation

	IWbemServices *GetServer () ;

	WbemNamespacePath *GetNamespacePath () { return & m_NamespacePath ; }

	wchar_t *GetNamespace () ;
	void SetNamespace ( wchar_t *a_Namespace ) ;

	void SetLocaleId ( wchar_t *a_localeId ) ;
	wchar_t *GetLocaleId () { return m_localeId ; }

	BOOL CreateExtendedNotificationObject ( 

		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	BOOL CreateNotificationObject ( 

		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	IWbemClassObject *GetNotificationObject (
		
		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	IWbemClassObject *GetExtendedNotificationObject (
		
		WbemProvErrorObject &a_errorObject,
		IWbemContext *pCtx
	) ;

	static HRESULT GetImpersonation();

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
			);
        
} ;

#endif //_NT_EVT_PROV_NTEVTSERV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtlogr.h ===
//***************************************************************************

//

//  NTEVTLOGR.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_EVTLOGR_H
#define _NT_EVT_PROV_EVTLOGR_H

class MyPSID
{
public:

	PSID m_SID;
	MyPSID(PSID psid = NULL) { m_SID = psid; }
};

template <> inline void AFXAPI  DestructElements<HINSTANCE> (HINSTANCE* ptr_e, int x)
{
	//x is always one for a CMap!
	if (*ptr_e != NULL)
	{
		FreeLibrary(*ptr_e);
	}
}

template <> inline void AFXAPI  DestructElements<MyPSID> (MyPSID* ptr_e, int x)
{
	//x is always one for a CMap!
	if ((ptr_e != NULL) && (ptr_e->m_SID != NULL))
	{
		delete ptr_e->m_SID;
	}
}

template <> inline UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key)
{
	return HashKeyLPCWSTR(key);
}

template <> inline UINT AFXAPI HashKey<MyPSID> (MyPSID key)
{
	UINT ret = 0;
	UCHAR* tmp = (UCHAR*) key.m_SID;
	DWORD sidlen = GetLengthSid(key.m_SID);
	
	for (DWORD x = 0; x < sidlen; x++)
	{
		ret = (ret<<5) + ret + *tmp++;
	}

	return ret;
}

template <> inline BOOL AFXAPI CompareElements<MyPSID, MyPSID> (const MyPSID* p1, const MyPSID* p2)
{
	return EqualSid(p1->m_SID, p2->m_SID);
}

class CSIDMap : public CMap<MyPSID, MyPSID, CStringW, LPCWSTR>
{
private:

	CCriticalSection m_Lock;


public:

	BOOL Lock() { return m_Lock.Lock(); }
	BOOL Unlock() { return m_Lock.Unlock(); }

};

class CDllMap : public CMap<CStringW, LPCWSTR, HINSTANCE, HINSTANCE>
{
private:

	CCriticalSection m_Lock;


public:

	BOOL Lock() { return m_Lock.Lock(); }
	BOOL Unlock() { return m_Lock.Unlock(); }
};

//taken from the NT eventlog private include (MAXLIST)
#define MAX_NUM_OF_INS_STRS 256

class CEventlogRecord
{
private:

	CStringW	m_Logfile;
	DWORD		m_Record;
	DWORD		m_EvtID;
	CStringW	m_SourceName;
	CStringW	m_Type;
	WORD		m_Category;
	CStringW	m_CategoryString;
	CStringW	m_TimeGen;
	CStringW	m_TimeWritten;
	CStringW	m_CompName;
	CStringW	m_User;
	CStringW	m_Message;
	wchar_t*	m_InsStrs[MAX_NUM_OF_INS_STRS];
	LONG		m_NumStrs;
	CStringW	m_TypeArray[TYPE_ARRAY_LEN];
	UCHAR*		m_Data;
	LONG		m_DataLen;
	BYTE		m_EvtType;
	
	IWbemClassObject* m_Obj;
	IWbemClassObject* m_pClass;
	IWbemClassObject *m_pAClass;
	IWbemServices* m_nspace;
	
	BOOL		m_Valid;

	static CDllMap sm_dllMap;
	static CSIDMap sm_usersMap;

	BOOL		Init(const EVENTLOGRECORD* pEvt);
	BOOL		SetProperty(wchar_t* prop, CStringW val);
	BOOL		SetProperty(wchar_t* prop, DWORD val);
	void		SetUser(PSID psidUserSid);
	void		SetMessage();
	void		SetTimeStr(CStringW& str, DWORD timeVal);
	void		SetType(WORD type);
	BOOL		GetInstance();
	ULONG		CheckInsertionStrings(HINSTANCE hPrimModule, HKEY hk);
	CStringW	GetMappedGUID(LPCWSTR strDcName, LPCWSTR strGuid);
	DWORD		CrackGuid(HANDLE   handle, LPCWSTR pwzGuid, CStringW  &strResult);
	
	static HINSTANCE	GetDll(CStringW path);
	static ULONG		GetIndex(wchar_t* indexStr, BOOL* bError);


public:

	static BOOL		SetEnumArray(IWbemClassObject* pClass, wchar_t* propname, CStringW* strArray, ULONG strArrayLen, GetIndexFunc IndexFunc);
	static void		EmptyDllMap();
	static void		EmptyUsersMap();
	static CStringW	GetUser(PSID userSid);

		CEventlogRecord(const wchar_t* logfile, const EVENTLOGRECORD* pEvt, IWbemServices* ns,
						IWbemClassObject* pClass = NULL, IWbemClassObject* pAClass = NULL);

	BOOL	GenerateInstance(IWbemClassObject** ppInst);
	BOOL	IsValid() { return m_Valid; }

		~CEventlogRecord();
};


#endif //_NT_EVT_PROV_EVTLOGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtlogf.h ===
//***************************************************************************

//

//  NTEVTLOGF.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_EVTLOGF_H
#define _NT_EVT_PROV_EVTLOGF_H

class CEventlogFileAttributes
{
protected:

	CStringW						m_logname;
	CStringW						m_logpath;
	DWORD						m_retention;
	DWORD						m_fileSz;
	CArray<CStringW*, CStringW*>	m_sources;

	DWORD	ReadRegistry();
	void	SetRetentionStr(IWbemClassObject *pClassObj, IWbemClassObject *pInstObj, DWORD dwVal);
	BOOL	SetSuperClassProperties(IWbemClassObject *pInst);

static	ULONG	GetIndex(wchar_t *indexStr, BOOL *bError);

public:

		CEventlogFileAttributes(const wchar_t *log);
	
	DWORD	UpdateRegistry(IWbemClassObject *pInst);
	DWORD	EventLogOperation(const wchar_t *archive, BOOL bClear,
								WbemProvErrorObject &a_ErrorObject, BOOL &bSuccess);
	BOOL	GenerateInstance(IWbemClassObject *pClassObj, IWbemClassObject* pAClassObj, IWbemClassObject **ppInst);

		~CEventlogFileAttributes();
	
};

class CEventLogFile
{
private:

	static CStringW	ExpandFileName(const wchar_t *filepath);
	static BOOL		QueryRegForFileName(HKEY hk_Log, const wchar_t *valname, wchar_t **res, DWORD *dwType);


protected:

	HANDLE	m_hEvtLog;
	CStringW	m_EvtLogName;
	BOOL	m_bValid;
	BOOL	m_bBuffer;
	DWORD	m_BuffLen;
	DWORD	m_Reason;
	BYTE	*m_Buffer;
	CCriticalSection m_LogLock;


public:


		CEventLogFile(const WCHAR *logname, BOOL bVerify);

	void	ReadLastRecord();
	BOOL	GetLastRecordID(DWORD &rec, DWORD &numrecs);
	DWORD	ReadRecord(DWORD recID, DWORD *dwBytesRead = NULL, BOOL b_Back = FALSE);
	BOOL	IsValid() {return m_bValid;}
	BOOL	IsValidBuffer() {return m_bBuffer;}
	DWORD	ReadFirstRecord();
	CStringW GetLogName() { return m_EvtLogName; }
	DWORD	FindOldEvent(DWORD evtID, const wchar_t *source, DWORD *recID,time_t offset = 0);
	BYTE*	GetBuffer() { return m_Buffer; }
	DWORD	GetBufferLen() { return m_BuffLen; }
	DWORD	GetReason() { return m_Reason; }

	virtual void	RefreshHandle();

	static CStringW	GetLogName(const wchar_t *file_name);
	static CStringW	GetFileName(HKEY hk_Log, const wchar_t *valname = EVTLOG_REG_FILE_VALUE);
	static DWORD	GetFileNames(HKEY hk_Log, CStringW **names, const wchar_t *valname = MSG_MODULE);
	static BOOL		ms_bSetPrivilege;
	static BOOL		SetSecurityLogPrivilege(BOOL bProcess = FALSE, LPCWSTR privName = SE_SECURITY_NAME);
	static HANDLE	OpenLocalEventLog(LPCWSTR a_log, DWORD *a_Reason);

	virtual ~CEventLogFile();

};


class CMonitoredEventLogFile : public CEventLogFile, public ProvTaskObject
{
private:
	
	CEventProviderManager	*m_parent; 
	IWbemClassObject		*m_Class;
	DWORD					m_RecID;
	VARIANT					m_VpsdSelfRel;


	BOOL SetEventDescriptor();

public:

		CMonitoredEventLogFile(CEventProviderManager *parent, const wchar_t *logname);

	void	SetProcessRecord(DWORD recID) { m_RecID = recID; }
	void	Process();
	void	RefreshHandle();
	BOOL	GenerateInstance(IWbemClassObject **ppEvtInst, IWbemClassObject *pEmbedObj);

		~CMonitoredEventLogFile();

};


#endif //_NT_EVT_PROV_EVTLOGF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtthrd.h ===
//***************************************************************************

//

//  NTEVTTHRD.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTTHRD_H
#define _NT_EVT_PROV_NTEVTTHRD_H

class CNTEventProvider;
class CEventLogMonitor;
class CEventProviderManager;
class CMonitoredEventLogFile;

class CControlObjectMap : public CMap< UINT_PTR, UINT_PTR, CNTEventProvider*, CNTEventProvider* >
{
private:

	UINT HashKey(UINT_PTR key) { return key; }
	CCriticalSection m_Lock;

public:

	BOOL Lock() { return m_Lock.Lock(); }
	BOOL Unlock() { return m_Lock.Unlock(); }
};

					
class CEventLogMonitor : public ProvThreadObject
{
private:

	void					Initialise();
	void					Uninitialise();
	void					TimedOut();

	CEventProviderManager*	m_pParent;
	BOOL					m_bMonitoring;
	static const DWORD		m_PollTimeOut;
	CMonitoredEventLogFile** m_Logs;
	ULONG					m_LogCount;
	CArray<CStringW*, CStringW*> m_LogNames;
	LONG					m_Ref;

public:

		CEventLogMonitor(CEventProviderManager* parentptr, CArray<CStringW*, CStringW*>& logs);

	void	Poll();
	void	StartMonitoring();
	BOOL	IsMonitoring() { return m_bMonitoring; }
	LONG	AddRef();
	LONG	Release();

		~CEventLogMonitor();
};

class CEventProviderManager
{
private:

	CControlObjectMap	m_ControlObjects;
	CEventLogMonitor**	m_monitorArray;
	CCriticalSection	m_MonitorLock;
	CStringW			m_BootTimeString;
	BOOL				m_IsFirstSinceLogon;
	BOOL InitialiseMonitorArray();
	void DestroyMonitorArray();
	BSTR GetLastBootTime();

public:


		CEventProviderManager();

	void	SendEvent(IWbemClassObject* evtObj);
	BOOL	Register(CNTEventProvider* prov);
	void	UnRegister(CNTEventProvider* prov);
	BOOL	IsFirstSinceLogon() { return m_IsFirstSinceLogon; }
	void	SetFirstSinceLogon(IWbemServices *ns, IWbemContext *pCtx);

	IWbemServices* GetNamespacePtr();
		
		~CEventProviderManager();

};

#endif //_NT_EVT_PROV_NTEVTTHRD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\dll\globals.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <precomp.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>

#include <Allocator.h>
#include <Array.h>
#include <Stack.h>
#include <Queue.h>
#include <Algorithms.h>
#include <PQueue.h>
#include <RedBlackTree.h>
#include <HashTable.h>

#include <Allocator.cpp>
#include <HelperFuncs.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\nteventprovider\include\ntevtprov.h ===
//***************************************************************************

//

//  NTEVTPROV.H

//

//  Module: WBEM NT EVENT PROVIDER

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _NT_EVT_PROV_NTEVTPROV_H
#define _NT_EVT_PROV_NTEVTPROV_H

class CEventProviderManager;

class CNTEventProvider : public IWbemEventProvider, public IWbemProviderInit, public IWbemEventProviderSecurity
{

private:

	IWbemServices*			m_pNamespace;
	IWbemObjectSink*		m_pEventSink;
	CEventProviderManager*	m_Mgr;
	LONG					m_ref;
	
	//copy constuctor not defined so not allowed!
	CNTEventProvider(CNTEventProvider&);
	void operator=(const CNTEventProvider&);


public:

		CNTEventProvider(CEventProviderManager* mgr);

	IWbemServices*		GetNamespace();
	IWbemObjectSink*	GetEventSink();
    void				AddRefAll();
    void				ReleaseAll();

		~CNTEventProvider();

	//globals
	//=======
	static ProvDebugLog* g_NTEvtDebugLog;
	static CMutex*		 g_secMutex;
	static CMutex*		 g_perfMutex;
	static PSID			 s_NetworkServiceSid;
	static PSID			 s_LocalServiceSid;
	static PSID			 s_AliasBackupOpsSid;
	static PSID			 s_AliasSystemOpsSid;
	static PSID			 s_AliasGuestsSid;
	static PSID			 s_LocalSystemSid;
	static PSID			 s_AliasAdminsSid;
	static PSID			 s_AnonymousLogonSid;
	static PSID			 s_WorldSid;

	static void AllocateGlobalSIDs();
	static void FreeGlobalSIDs();
	static BOOL GlobalSIDsOK();

	//interface methods
	//==================
    STDMETHODIMP ProvideEvents(
                IWbemObjectSink* pSink,
                LONG lFlags
            );

    STDMETHODIMP         QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


	/* IWbemProviderInit methods */

	STDMETHODIMP Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
			);

	/* IWbemEventProviderSecurity methods */

	STDMETHODIMP AccessCheck( 
				LPCWSTR wszQueryLanguage,
				LPCWSTR wszQuery,
				LONG lSidLength,
				const BYTE __RPC_FAR *pSid);
};


#define DebugOut(a) { \
\
	if ( (NULL != CNTEventProvider::g_NTEvtDebugLog) && CNTEventProvider::g_NTEvtDebugLog->GetLogging () && ( CNTEventProvider::g_NTEvtDebugLog->GetLevel () > 0 ) ) \
	{ \
		{a ; } \
	} \
} 


#endif //_NT_EVT_PROV_NTEVTPROV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\dll\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Module: WMI Framework Instance provider 

//

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks as well as routines that support

//           self registration.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <stdafx.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <PingProv.h>
#include <Pingfac.h>
#include <dllunreg.h>
 
HMODULE ghModule ;

//============

// {734AC5AE-68E1-4fb5-B8DA-1D92F7FC6661}
DEFINE_GUID(CLSID_CPINGPROVIDER, 
0x734ac5ae, 0x68e1, 0x4fb5, 0xb8, 0xda, 0x1d, 0x92, 0xf7, 0xfc, 0x66, 0x61);


//Count number of objects and number of locks.
long g_cLock = 0 ;

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

	REFCLSID rclsid, 
	REFIID riid, 
	PPVOID ppv
)
{
	HRESULT hr = E_FAIL;
    SetStructuredExceptionHandler seh;

    try
    {
		CPingProviderClassFactory *pObj = NULL;

		if ( CLSID_CPINGPROVIDER == rclsid )
		{
			pObj = new CPingProviderClassFactory () ;
			hr = pObj->QueryInterface(riid, ppv);

			if (FAILED(hr))
			{
				delete pObj;
			}
		}
    }
    catch(Structured_Exception e_SE)
    {
        hr = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        hr = E_OUTOFMEMORY;
    }
    catch(...)
    {
        hr = E_UNEXPECTED;
    }

    return hr ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
    // It is OK to unload if there are no objects or locks on the 
    // class factory.
    SCODE sc = S_FALSE;
    SetStructuredExceptionHandler seh;

    try
    {
		CCritSecAutoUnlock t_lock( & CPingProvider::s_CS ) ;

		if ( ( 0 == CPingProviderClassFactory::s_LocksInProgress ) &&
			( 0 == CPingProviderClassFactory::s_ObjectsInProgress ) 
		)
		{
			CPingProvider::Global_Shutdown();
			sc = S_OK;
		}
    }
    catch(Structured_Exception e_SE)
    {
        sc = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        sc = E_OUTOFMEMORY;
    }
    catch(...)
    {
        sc = E_UNEXPECTED;
    }

    return sc;
}

STDAPI DllRegisterServer(void)
{   
    SetStructuredExceptionHandler seh;

    try
    {
		HRESULT t_status;

		t_status = RegisterServer( _T("WBEM Ping Provider"), CLSID_CPINGPROVIDER ) ;
		if( NOERROR != t_status )
		{
			return t_status ;  
		}
		
		return NOERROR;
	}
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    SetStructuredExceptionHandler seh;

    try
    {
 		HRESULT t_status;

		t_status = UnregisterServer( CLSID_CPINGPROVIDER ) ;
		if( NOERROR != t_status )
		{
			return t_status ;  
		}
		
		return NOERROR;
	}
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are 
//          initialized and terminated, or upon calls to the LoadLibrary 
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstDLL,		// handle to dll module
    DWORD fdwReason,		// reason for calling function
    LPVOID lpReserved		// reserved
)
{
    BOOL bRet = TRUE;
    SetStructuredExceptionHandler seh;

    try
    {
		// Perform actions based on the reason for calling.
		switch( fdwReason ) 
		{ 
			case DLL_PROCESS_ATTACH:
			{
		// TO DO: Consider adding DisableThreadLibraryCalls().

			 // Initialize once for each new process.
			 // Return FALSE to fail DLL load.
				DisableThreadLibraryCalls(hInstDLL);
				ghModule = hInstDLL ;
				InitializeCriticalSection(& CPingProvider::s_CS);
	/*
	 *	Use the global process heap for this particular boot operation
	 */

				WmiAllocator t_Allocator ;
				WmiStatusCode t_StatusCode = t_Allocator.New (

					( void ** ) & CPingProvider::s_Allocator ,
					sizeof ( WmiAllocator ) 
				) ;

				if ( t_StatusCode == e_StatusCode_Success )
				{
					:: new ( ( void * ) CPingProvider::s_Allocator ) WmiAllocator ;

					t_StatusCode = CPingProvider::s_Allocator->Initialize () ;

					if ( t_StatusCode != e_StatusCode_Success )
					{
						t_Allocator.Delete ( ( void * ) CPingProvider::s_Allocator	) ;
						CPingProvider::s_Allocator = NULL;
						bRet = FALSE ;
					}
				}
				else
				{
					bRet = FALSE ;
					CPingProvider::s_Allocator = NULL;
				}

			}
			break;

			case DLL_THREAD_ATTACH:
			{
			 // Do thread-specific initialization.
			}
			break;

			case DLL_THREAD_DETACH:
			{
			 // Do thread-specific cleanup.
		/*
		 *	Use the global process heap for this particular boot operation
		 */
			}
			break;

			case DLL_PROCESS_DETACH:
			{
			 // Perform any necessary cleanup.
				if (CPingProvider::s_Allocator)
				{
					WmiAllocator t_Allocator ;
					t_Allocator.Delete ( ( void * ) CPingProvider::s_Allocator	) ;
				}

				DeleteCriticalSection(& CPingProvider::s_CS);
			}
			break;
		}
	}
    catch(Structured_Exception e_SE)
    {
        bRet = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        bRet = FALSE;
    }
    catch(...)
    {
        bRet = FALSE;
    }

    return bRet ;  // Sstatus of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\dll\pingget.cpp ===
/******************************************************************

   pingget.CPP



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  

   Description: 
   
******************************************************************/

#include <stdafx.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include ".\res_str.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <PingProv.h>
#include <Pingtask.h>
#include <Pingfac.h>


CPingGetAsync::CPingGetAsync (

	CPingProvider *a_Provider , 
	wchar_t *a_ObjectPath , 
	ULONG a_Flag , 
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx
): 	m_ObjectPath(NULL),
	m_ParsedObjectPath (NULL),
	CPingTaskObject (a_Provider, a_NotificationHandler, a_Ctx)
{
	if (a_ObjectPath != NULL)
	{
		int t_len = wcslen(a_ObjectPath);

		if (t_len > 0)
		{
			m_ObjectPath = new WCHAR[t_len+1];
			m_ObjectPath[t_len] = L'\0';
			wcsncpy(m_ObjectPath, a_ObjectPath, t_len);
		}
	}
}

CPingGetAsync::~CPingGetAsync ()
{
	if (m_ObjectPath)
	{
		delete [] m_ObjectPath ;
	}

	if (m_ParsedObjectPath)
	{
		delete m_ParsedObjectPath ;
	}
}

BOOL CPingGetAsync::GetObject ()
{
	InterlockedIncrement(&m_PingCount);
	BOOL t_Status = ! m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;

	if ( t_Status )
	{
		BOOL bClass = TRUE;

		if ( _wcsicmp ( m_ParsedObjectPath->m_pClass , PROVIDER_NAME_CPINGPROVIDER) == 0 )
		{
			IWbemClassObject *t_Cls = NULL;
			t_Status = GetClassObject ( &t_Cls ) ;

			if ( t_Status )
			{
				t_Status = 	PerformGet() ;
				t_Cls->Release();
			}
			else
			{
				t_Status = FALSE ;
				SetErrorInfo(IDS_CLASS_DEFN,
								WBEM_E_FAILED ) ;
			}
		}
		else
		{
			t_Status = FALSE ;
			SetErrorInfo(IDS_INVALID_CLASS ,
								WBEM_E_FAILED ) ;
		}
	}
	else
	{
		t_Status = FALSE ;
		SetErrorInfo(IDS_OBJ_PATH ,
								WBEM_E_FAILED ) ;
	}

	DecrementPingCount();
	return t_Status ;
}

BOOL CPingGetAsync::PerformGet ()
{
	if (m_ParsedObjectPath->m_dwNumKeys != PING_KEY_PROPERTY_COUNT)
	{
		SetErrorInfo(IDS_OBJ_PATH_KEYS  ,
								 WBEM_E_FAILED ) ;
		return FALSE;
	}

	BOOL t_Status = TRUE;
	UCHAR t_bits[PING_KEY_PROPERTY_COUNT] = {0};
	ULONG t_Address = 0 ;
	ULONG t_TimeToLive = 0 ;
	ULONG t_Timeout = 0 ;
	ULONG t_SendSize = 0 ;
	BOOL t_NoFragmentation = FALSE ;
	ULONG t_TypeofService = 0 ;
	ULONG t_RecordRoute = 0 ;
	ULONG t_TimestampRoute = 0 ;
	ULONG t_SourceRouteType = 0 ;
	LPCWSTR t_SourceRoute = NULL ;
	BOOL t_ResolveAddress = FALSE;
	ULONG t_AddressKey = 0;
	ULONG t_ResolveErr = 0;

	for (int x = 0; ((x < PING_KEY_PROPERTY_COUNT) && t_Status); x++)
	{
		if (m_ParsedObjectPath->m_paKeys [ x ])
		{
			CKeyEntry t_key(m_ParsedObjectPath->m_paKeys [ x ]->m_pName) ;
			ULONG t_PropertyIndex = 0xFF; //out of scope

			if ( (CPingProvider::s_HashTable->Find(t_key, t_PropertyIndex) == e_StatusCode_Success)
				&& (t_PropertyIndex < PING_KEY_PROPERTY_COUNT) )
			{
				if (t_bits[t_PropertyIndex] == 1)
				{
					t_Status = FALSE;
					SetErrorInfo(IDS_OBJ_PATH_DUP_KEYS  ,
									WBEM_E_FAILED ) ;

				}
				else
				{
					t_bits[t_PropertyIndex] = 1;
					
					switch (t_PropertyIndex)
					{
						case PING_ADDRESS_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_BSTR )
							{
								if (FAILED (Icmp_ResolveAddress ( m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.bstrVal , t_Address, &t_ResolveErr ))
									&& (t_ResolveErr == 0) )
								{
									t_ResolveErr = WSAHOST_NOT_FOUND;
								}

								t_AddressKey = x;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_ADDR_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_TIMEOUT_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								t_Timeout = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_TO_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_TIMETOLIVE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_TimeToLive = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_TTL_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_BUFFERSIZE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_SendSize = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_BUFF_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_NOFRAGMENTATION_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_NoFragmentation = (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal != 0);
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_NOFRAG_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_TYPEOFSERVICE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_TypeofService = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_TOS_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_RECORDROUTE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_RecordRoute = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_RR_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_TIMESTAMPROUTE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_TimestampRoute = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_TS_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_SOURCEROUTETYPE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								 t_SourceRouteType = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_SRT_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_SOURCEROUTE_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_BSTR )
							{
								t_SourceRoute = m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.bstrVal;
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_SR_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						case PING_RESOLVEADDRESSNAMES_INDEX:
						{
							if (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.vt == VT_I4 )
							{
								t_ResolveAddress = (m_ParsedObjectPath->m_paKeys [ x ]->m_vValue.lVal != 0);
							}
							else
							{
								t_Status = FALSE;
								SetErrorInfo(IDS_RA_TYPE,
									WBEM_E_FAILED ) ;
							}
						}
						break;

						default :
						{
								t_Status = FALSE;
								SetErrorInfo(IDS_UNK_PROP,
									WBEM_E_FAILED ) ;
						}
					}
				}
			}
			else
			{
				t_Status = FALSE;
				SetErrorInfo(IDS_UNK_KEY,
								 WBEM_E_FAILED ) ;
			}
		}
		else
		{
			t_Status = FALSE;
			SetErrorInfo(IDS_NO_KEYS,
								 WBEM_E_FAILED ) ;
		}
	}

	if (t_Status)
	{
		InterlockedIncrement(&m_PingCount);
		HRESULT t_Result = Icmp_RequestResponse ( 

								m_ParsedObjectPath->m_paKeys [ t_AddressKey ]->m_vValue.bstrVal ,
								t_Address ,
								t_TimeToLive ,
								t_Timeout ,
								t_SendSize ,
								t_NoFragmentation ,
								t_TypeofService ,
								t_RecordRoute ,
								t_TimestampRoute ,
								t_SourceRouteType ,
								t_SourceRoute,
								t_ResolveAddress,
								t_ResolveErr
							) ;

		if ( SUCCEEDED ( t_Result ) ) 
		{
			SetErrorInfo(0, WBEM_E_NOT_FOUND ) ;
		}
		else
		{
			DecrementPingCount();
			t_Status = FALSE;
		}
	}

	return t_Status ;
}

HRESULT CPingGetAsync::GetDefaultTTL ( DWORD &a_TimeToLive )
{
	HRESULT t_Result = S_OK ;

    a_TimeToLive = DEFAULT_TTL ;

    HKEY t_Registry ;

    ULONG t_Status = RegOpenKeyEx (

		HKEY_LOCAL_MACHINE,
        L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters",
        0,
        KEY_QUERY_VALUE,
        &t_Registry
	) ;

	if ( t_Status == ERROR_SUCCESS )
	{
		ULONG t_Type = 0 ;
		ULONG t_Size = sizeof ( ULONG ) ;

        t_Status = RegQueryValueEx (

			t_Registry,
            L"DefaultTTL",
            0,
            & t_Type,
            ( unsigned char * ) & a_TimeToLive ,
            & t_Size
		);

        RegCloseKey ( t_Registry ) ;
    } 

    return t_Result ;
}

void CPingGetAsync::HandleResponse (CPingCallBackObject *a_reply)
{
	try
	{
		if (FAILED(Icmp_DecodeAndIndicate (a_reply)) )	
		{
			SetErrorInfo(IDS_DECODE_GET,
								 WBEM_E_FAILED, TRUE ) ;
		}
		else
		{
			SetErrorInfo(NULL, S_OK, TRUE);
		}
	}
	catch (...)
	{
		DecrementPingCount();
	}

	DecrementPingCount();
}

void CPingGetAsync::HandleErrorResponse (DWORD a_ErrMsgID, HRESULT a_HRes)
{
	try
	{
		SetErrorInfo(a_ErrMsgID , a_HRes, TRUE) ;
	}
	catch (...)
	{
		DecrementPingCount();
	}

	DecrementPingCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\dll\pingprov.cpp ===
//***************************************************************************

//

//  PINGPROV.CPP

//

//  Module: WMI PING PROVIDER 

//

//  Purpose: Implementation for the CPingProvider class. 

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************


#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <stdafx.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <pingprov.h>
#include <pingfac.h>
#include <pingtask.h>

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CPingProvider ::CPingProvider
// CPingProvider ::~CPingProvider
//
//***************************************************************************

CRITICAL_SECTION CPingProvider::s_CS;
CPingThread *CPingProvider::s_PingThread = NULL;
WmiAllocator *CPingProvider::s_Allocator = NULL;
WmiHashTable <CKeyEntry, ULONG, 12> *CPingProvider::s_HashTable = NULL;

LPCWSTR CPingProvider::s_KeyTable[PING_KEY_PROPERTY_COUNT] = {
										Ping_Address,
										Ping_Timeout,
										Ping_TimeToLive,
										Ping_BufferSize,
										Ping_NoFragmentation,
										Ping_TypeofService,
										Ping_RecordRoute,
										Ping_TimestampRoute,
										Ping_SourceRouteType,
										Ping_SourceRoute,
										Ping_ResolveAddressNames
										};

LONG CompareElement ( const CKeyEntry &a_Arg1 , const CKeyEntry & a_Arg2 )
{
	LPCWSTR t_a1 = a_Arg1.Get();
	LPCWSTR t_a2 = a_Arg2.Get();

	if (t_a1 == t_a2)
	{
		return 0;
	}
	else if ((t_a1 == NULL) && (t_a1 != NULL))
	{
		return 1;
	}
	else if ((t_a1 == NULL) && (t_a1 != NULL))
	{
		return -1;
	}
	else
	{
		return (_wcsicmp(t_a1, t_a2));
	}
}

BOOL operator== ( const CKeyEntry &a_Arg1 , const CKeyEntry &a_Arg2 )
{
	return (CompareElement(a_Arg1, a_Arg2) == 0);
}

BOOL operator< ( const CKeyEntry &a_Arg1 , const CKeyEntry &a_Arg2 )
{
	return (CompareElement(a_Arg1, a_Arg2) == -1);
}

ULONG Hash ( const CKeyEntry & a_Arg )
{
	LPCWSTR t_a = a_Arg.Get();
	ULONG t_RetVal = 0;

	if (t_a != NULL)
	{
		switch (*t_a)
		{
			case L'A':
			case L'a':
			{
				t_RetVal = 1;
			}
			break;

			case L'B':
			case L'b':
			{
				t_RetVal = 2;
			}
			break;

			case L'N':
			case L'n':
			{
				t_RetVal = 3;
			}
			break;

			case L'R':
			case L'r':
			{
				switch (wcslen(t_a))
				{
					case 11 : //wcslen(RecordRoute)
					{
						t_RetVal = 4;
					}
					break;

					case 19 : //wcslen(ResolveAddressNames)
					{
						t_RetVal = 5;
					}
					break;

					default:
					{
					}
				}
			}
			break;

			case L'S':
			case L's':
			{
				switch (wcslen(t_a))
				{
					case 11 : //wcslen(SourceRoute)
					{
						t_RetVal = 6;
					}
					break;

					case 15 : //wcslen(SourceRouteType)
					{
						t_RetVal = 7;
					}
					break;

					default:
					{
					}
				}
			}
			break;

			case L'T':
			case L't':
			{
				switch (wcslen(t_a))
				{
					case 7 : //wcslen(TimeOut)
					{
						t_RetVal = 8;
					}
					break;

					case 10 : //wcslen(TimeToLive)
					{
						t_RetVal = 9;
					}
					break;

					case 13 : //wcslen(TypeOfService)
					{
						t_RetVal = 10;
					}
					break;

					case 14 : //wcslen(TimeStampRoute)
					{
						t_RetVal = 11;
					}
					break;

					default:
					{
					}
				}
			}
			break;

			default:
			{
			}
		}
	}

	return t_RetVal ;
}


CPingThread::CPingThread (WmiAllocator & a_Allocator)
:	WmiThread < ULONG > ( a_Allocator , L"PingProviderThread") ,
	m_Allocator ( a_Allocator ), m_Init(FALSE)
{
}

CPingThread::~CPingThread ()
{
}

WmiStatusCode CPingThread :: Initialize_Callback ()
{
	WmiStatusCode t_RetVal = e_StatusCode_NotInitialized;

	if (SUCCEEDED( CoInitializeEx ( NULL , COINIT_MULTITHREADED )) )
	{
		WSADATA t_WsaData ;
		
		if (0 == WSAStartup (0x0101, & t_WsaData))
		{
			t_RetVal = e_StatusCode_Success ;
			m_Init = TRUE;
		}
		else
		{
			CoUninitialize () ;
		}
	}

	return t_RetVal ;
}


WmiStatusCode CPingThread :: UnInitialize_Callback () 
{
	if (m_Init)
	{
		WSACleanup () ;
		CoUninitialize () ;
	}

	return e_StatusCode_Success ;
}

CPingProvider ::CPingProvider () : m_referenceCount(0),
									m_server(NULL),
									m_notificationClassObject(NULL),
									m_ClassObject(NULL),
									m_bInitial(FALSE)
{	 
    InterlockedIncrement ( & CPingProviderClassFactory :: s_ObjectsInProgress ) ;
}

CPingProvider ::~CPingProvider()
{
	if ( m_server != NULL )
	{
		m_server->Release () ;
	}

	if ( m_ClassObject != NULL )
	{
		m_ClassObject->Release () ;
	}

	if ( m_notificationClassObject != NULL )
	{
		m_notificationClassObject->Release () ;
	}

	InterlockedDecrement ( & CPingProviderClassFactory :: s_ObjectsInProgress ) ;
}

HRESULT CPingProvider :: Global_Startup ()
{
	HRESULT t_Result = S_OK ;

	if ( s_Allocator)
	{
		if (  !s_PingThread )
		{
			WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( *s_Allocator ) ;

			if ( t_StatusCode != e_StatusCode_Success )
			{
				t_Result = WBEM_E_FAILED;
			}
			else
			{
				try
				{
					s_HashTable = ::new WmiHashTable <CKeyEntry, ULONG, 12> ( *s_Allocator ) ;
					t_StatusCode = s_HashTable->Initialize () ;
					
					if ( t_StatusCode != e_StatusCode_Success )
					{
						Global_Shutdown();
						t_Result = WBEM_E_FAILED;
					}
					else
					{
						for (int x = 0; x < PING_KEY_PROPERTY_COUNT; x++)
						{
							CKeyEntry t_KeyEntry(s_KeyTable[x]);
							t_StatusCode = s_HashTable->Insert ( t_KeyEntry , x ) ;

							if ( t_StatusCode != e_StatusCode_Success )
							{
								Global_Shutdown();
								t_Result = WBEM_E_FAILED;
								break;
							}

						}

						if (SUCCEEDED(t_Result))
						{
							s_PingThread = ::new CPingThread( *s_Allocator ) ;
							s_PingThread->AddRef();
							t_StatusCode = s_PingThread->Initialize () ;

							if ( t_StatusCode != e_StatusCode_Success )
							{
								Global_Shutdown();
								t_Result = WBEM_E_FAILED;
							}
						}
					}
				}
				catch(...)
				{
					Global_Shutdown();
					throw;
				}
			}
		}
	}
	else
	{
		t_Result = WBEM_E_FAILED;
	}

	return t_Result ;
}

HRESULT CPingProvider :: Global_Shutdown ()
{
	HRESULT t_Result = S_OK ;

	if (s_Allocator && s_PingThread )
	{
		try
		{
			if (s_PingThread != NULL)
			{
				if (s_PingThread->GetHandle ())
				{
					HANDLE t_ThreadHandle = NULL ;

					BOOL t_Status = DuplicateHandle ( 

						GetCurrentProcess () ,
						s_PingThread->GetHandle () ,
						GetCurrentProcess () ,
						& t_ThreadHandle, 
						0 , 
						FALSE , 
						DUPLICATE_SAME_ACCESS
					) ;

					s_PingThread->Release();
					WaitForSingleObject ( t_ThreadHandle , INFINITE ) ;

					CloseHandle ( t_ThreadHandle ) ;
				}
				else
				{
					s_PingThread->Release();
				}
			}

			WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( *s_Allocator ) ;
		}
		catch(...)
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		s_PingThread = NULL;

		try
		{
			if (s_HashTable)
			{
				for (int x = 0; x < PING_KEY_PROPERTY_COUNT; x++)
				{
					CKeyEntry t_KeyEntry(s_KeyTable[x]);
					s_HashTable->Delete ( t_KeyEntry ) ;
				}

				s_HashTable->UnInitialize () ;
				::delete s_HashTable;
			}
		}
		catch(...)
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}

		s_HashTable = NULL;
	}

	return t_Result ;
}

//***************************************************************************
//
// CPingProvider ::QueryInterface
// CPingProvider ::AddRef
// CPingProvider ::Release
//
// Purpose: IUnknown members for CPingProvider object.
//***************************************************************************

STDMETHODIMP CPingProvider ::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	HRESULT t_hr = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;
		}
		else
		{
			t_hr = E_NOINTERFACE ;
		}
    }
    catch(Structured_Exception e_SE)
    {
        t_hr = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_hr = E_OUTOFMEMORY;
    }
    catch(...)
    {
        t_hr = E_UNEXPECTED;
    }

	return t_hr;
}

STDMETHODIMP_(ULONG) CPingProvider ::AddRef(void)
{
    SetStructuredExceptionHandler seh;

    try
    {
		return InterlockedIncrement ( & m_referenceCount ) ;
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

STDMETHODIMP_(ULONG) CPingProvider ::Release(void)
{
	LONG t_Ref  = 0;
    SetStructuredExceptionHandler seh;

    try
    {
		if ( ( t_Ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return t_Ref ;
		}
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

BOOL CPingProvider :: GetNotificationObject ( IWbemContext *a_Ctx , IWbemClassObject **a_ppObj ) 
{
	*a_ppObj = NULL;

	if ( m_notificationClassObject == NULL )
	{
		CreateNotificationObject ( a_Ctx ) ;
	}

	if ( m_notificationClassObject != NULL )
	{
		if ( FAILED (m_notificationClassObject->SpawnInstance(0, a_ppObj)) )
		{
			*a_ppObj = NULL;
		}
	}

	return (*a_ppObj != NULL)  ; 
}

BOOL CPingProvider :: ImpersonateClient ( )
{
	return SUCCEEDED(WbemCoImpersonateClient());
}

BOOL CPingProvider::GetClassObject (IWbemClassObject **a_ppClass )
{
	BOOL t_RetVal = TRUE;

	if ((a_ppClass == NULL) || (m_ClassObject == NULL))
	{
		t_RetVal = FALSE;
	}
	else
	{
		*a_ppClass = m_ClassObject;
		(*a_ppClass)->AddRef();
	}

	return t_RetVal;
}

BOOL CPingProvider :: CreateNotificationObject ( 

	IWbemContext *a_Ctx 
)
{
	BOOL t_Status = TRUE ;

	HRESULT t_Result = m_server->GetObject (

		WBEM_CLASS_EXTENDEDSTATUS ,
		0 ,
		a_Ctx,
		& m_notificationClassObject ,
		NULL
	) ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
	}

	return t_Status ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CPingProvider ::OpenNamespace ( 

	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* ppNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppHandler
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: GetObject ( 
		
	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: GetObjectAsync ( 
		
	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	HRESULT t_Result = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {	
		if (ImpersonateClient())
		{
/*
 * Create Asynchronous GetObjectByPath object
 */
			WSADATA t_WsaData ;
			
			if (0 == WSAStartup (0x0101, & t_WsaData))
			{
				CPingGetAsync *t_AsyncEvent = new CPingGetAsync ( this , ObjectPath , lFlags , pHandler , pCtx ) ;

				if (t_AsyncEvent->GetThreadToken())
                {
                    t_AsyncEvent->GetObject();
                }
                else
				{
                    // Note that ExecQuery will delete this for us.
					delete t_AsyncEvent;
				}

				WSACleanup();
			}
			else
			{
				t_Result = WBEM_E_FAILED;
			}

			CoRevertToSelf();
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED;
		}
    }
    catch(Structured_Exception e_SE)
    {
        t_Result = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Result = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Result = E_UNEXPECTED;
    }

	return t_Result ;
}

HRESULT CPingProvider :: PutClass ( 
		
	IWbemClassObject FAR* pClass , 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: PutClassAsync ( 
		
	IWbemClassObject FAR* pClass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
 	 return WBEM_E_NOT_SUPPORTED ;
}

 HRESULT CPingProvider :: DeleteClass ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: DeleteClassAsync ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{

	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: CreateClassEnum ( 

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

SCODE CPingProvider :: CreateClassEnumAsync (

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: PutInstance (

    IWbemClassObject FAR *pInstance,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInstance, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: DeleteInstance ( 

	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_SUPPORTED ;
}
        
HRESULT CPingProvider :: DeleteInstanceAsync (
 
	BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: CreateInstanceEnum ( 

	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: CreateInstanceEnumAsync (

 	BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: ExecQuery ( 

	BSTR QueryLanguage, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: ExecQueryAsync ( 
		
	BSTR QueryFormat, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	HRESULT t_Result = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
		if (ImpersonateClient())
		{
	/*
	 * Create Synchronous Query Instance object
	 */
			WSADATA t_WsaData ;
			
			if (0 == WSAStartup (0x0101, & t_WsaData))
			{
				CPingQueryAsync *t_AsyncEvent = new CPingQueryAsync ( this , QueryFormat , Query , lFlags , pHandler , pCtx ) ;
				
				if (t_AsyncEvent->GetThreadToken())
                {
                    t_AsyncEvent->ExecQuery();
                }
                else
				{
                    // Note that ExecQuery will delete this for us.
					delete t_AsyncEvent;
				}

				WSACleanup();
			}
			else
			{
				t_Result = WBEM_E_FAILED;
			}

			CoRevertToSelf();
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED;
		}
    }
    catch(Structured_Exception e_SE)
    {
        t_Result = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_Result = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_Result = WBEM_E_UNEXPECTED;
    }

	return t_Result ;
}

HRESULT CPingProvider :: ExecNotificationQuery ( 

	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_SUPPORTED ;
}
        
HRESULT CPingProvider :: ExecNotificationQueryAsync ( 
            
	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_SUPPORTED ;
}       

HRESULT STDMETHODCALLTYPE CPingProvider :: ExecMethod ( 

	BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT STDMETHODCALLTYPE CPingProvider :: ExecMethodAsync ( 

    BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{

	return WBEM_E_NOT_SUPPORTED ;
}

HRESULT CPingProvider :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
	HRESULT t_result = S_OK;
    SetStructuredExceptionHandler seh;

    try
    {
		if ((pCIMOM == NULL) || (pCtx == NULL) || (pInitSink == NULL))
		{
			t_result = WBEM_E_FAILED;
		}

		if (SUCCEEDED(t_result))
		{
			CCritSecAutoUnlock t_lock( &s_CS ) ;

			try
			{
				t_result = Global_Startup ();

				if (SUCCEEDED(t_result))
				{
					if (!m_bInitial)
					{
						m_bInitial = TRUE;
						m_server = pCIMOM ;
						m_server->AddRef();
						IWbemClassObject *t_Object = NULL;
						
						if ( GetNotificationObject ( pCtx, &t_Object ) ) 
						{
							t_Object->Release () ;

							t_result = m_server->GetObject (

								PROVIDER_NAME_CPINGPROVIDER ,
								0 ,
								pCtx,
								& m_ClassObject ,
								NULL 
							) ;

							if ( FAILED(t_result))
							{
								m_ClassObject = NULL ;
								t_result = WBEM_E_FAILED ;
							}

						}
						else
						{
							t_result = WBEM_E_FAILED ;
						}
					}
				}
			}
			catch (...)
			{
				t_result = WBEM_E_FAILED;
			}

			try
			{
				pInitSink->SetStatus ( SUCCEEDED(t_result) ? (LONG)WBEM_S_INITIALIZED : (LONG)WBEM_E_FAILED , 0 ) ;
				t_result = S_OK;
			}
			catch(...)
			{
				t_result = WBEM_E_FAILED;
			}
		}
    }
    catch(Structured_Exception e_SE)
    {
        t_result = WBEM_E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        t_result = WBEM_E_OUT_OF_MEMORY;
    }
    catch(...)
    {
        t_result = WBEM_E_UNEXPECTED;
    }

	return t_result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\dll\pingcallback.cpp ===
/******************************************************************

   pingcallback.cpp



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  

   Description: 
   
******************************************************************/



#include <stdafx.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include ".\res_str.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <PingProv.h>
#include <Pingtask.h>
#include <Pingfac.h>

VOID static NTAPI ApcRoutine(                                    // This is called when ping completes
    IN PVOID            Context,               // The above structure
    IN PIO_STATUS_BLOCK Ignored1,              // Unused param
    IN ULONG            Ignored2               // Unused param
)
{
    CPingCallBackObject *t_request = (CPingCallBackObject *)Context;
	t_request->HandleResponse();
	t_request->Release();
}

CPingCallBackObject::CPingCallBackObject(CPingTaskObject *a_ParentTask,
						LPCWSTR a_AddressString,
						ULONG a_Address,
						ULONG a_TimeToLive,
						ULONG a_Timeout,
						ULONG a_SendSize,
						BOOL a_NoFragmentation,
						ULONG a_TypeofService,
						ULONG a_RecordRoute,
						ULONG a_TimestampRoute,
						ULONG a_SourceRouteType,
						LPCWSTR a_SourceRoute,
						BOOL a_ResolveAddress,
						ULONG a_ResolveError)
						:
						WmiTask < ULONG > ( *CPingProvider :: s_Allocator ) ,
						m_ParentTask(NULL),
						m_ReplyBuffer(NULL),
						m_SendBuffer(NULL),
						m_ReplySize(0),
						m_SourceRouteCount(0),
						m_IcmpHandle(INVALID_HANDLE_VALUE),
						m_ResolveError(a_ResolveError)
{
	InterlockedIncrement ( & CPingProviderClassFactory :: s_ObjectsInProgress ) ;

	m_ParentTask = a_ParentTask;
	m_Address = a_Address;
	m_TimeToLive = a_TimeToLive;
	m_Timeout = a_Timeout;
	m_SendSize = a_SendSize;
	m_NoFragmentation = a_NoFragmentation;
	m_TypeofService = a_TypeofService;
	m_RecordRoute = a_RecordRoute;
	m_TimestampRoute = a_TimestampRoute;
	m_SourceRouteType = a_SourceRouteType;
	m_ResolveAddress = a_ResolveAddress;
	
	if (a_SourceRoute != NULL)
	{
		m_SourceRoute = a_SourceRoute;
	}

	if (a_AddressString != NULL)
	{
		m_AddressString = a_AddressString;
	}
}

CPingCallBackObject::~CPingCallBackObject()
{
	if (m_ParentTask != NULL)
	{
		SendError(IDS_CALLBACK_PREMATURE, WBEM_E_FAILED);
	}

	if (m_ReplyBuffer != NULL)
	{
		delete [] m_ReplyBuffer;
		m_ReplyBuffer = NULL;
	}

	if (m_SendBuffer != NULL)
	{
		delete [] m_SendBuffer;
		m_SendBuffer = NULL;
	}

	if (INVALID_HANDLE_VALUE != m_IcmpHandle)
	{
		IcmpCloseHandle ( m_IcmpHandle );
	}

	InterlockedDecrement ( & CPingProviderClassFactory :: s_ObjectsInProgress ) ;
}

BOOL CPingCallBackObject::GetIcmpHandle()
{
	if (m_IcmpHandle == INVALID_HANDLE_VALUE)
	{
		m_IcmpHandle = IcmpCreateFile () ;
	}

	return (m_IcmpHandle != INVALID_HANDLE_VALUE); 
}

void CPingCallBackObject :: SendError(DWORD a_ErrMsgID, HRESULT a_HRes)
{
	if (m_ParentTask != NULL)
	{
		m_ParentTask->HandleErrorResponse(a_ErrMsgID, a_HRes);
		Disconnect();
	}
}

void CPingCallBackObject :: HandleResponse()
{
	if (m_ParentTask != NULL)
	{
		if (m_ParentTask->SetThreadToken(FALSE))
		{
			m_ParentTask->HandleResponse(this);
			m_ParentTask->SetThreadToken(TRUE);
		}
		else
		{
			SendError(IDS_IMPERSONATE_RECEIVE, WBEM_E_ACCESS_DENIED);
		}

		Disconnect();
	}
}


WmiStatusCode CPingCallBackObject :: Process ( WmiThread <ULONG> &a_Thread )
{
	SendEcho () ;

	return e_StatusCode_Success ;
}

BOOL CPingCallBackObject::ParseSourceRoute()
{
	BOOL t_RetVal = TRUE;
	CStringW t_Src(m_SourceRoute);
	t_Src.TrimLeft();
	t_Src.TrimRight();
	
	if (!t_Src.IsEmpty())
	{
		int t_Index = 0;

		while (t_Index != -1)
		{
			t_Index = t_Src.Find(L',');

			if (t_Index == 0)
			{
				t_RetVal = FALSE;
				break;
			}

			CStringW t_AddrStr;

			if (t_Index == -1)
			{
				t_AddrStr = t_Src;
			}
			else
			{
				t_AddrStr = t_Src.Left(t_Index);
				int t_len = t_Src.GetLength() - t_Index - 1;

				if (t_len == 0)
				{
					t_RetVal = FALSE;
					break;
				}
				else
				{
					t_Src = t_Src.Right(t_len);
				}
			}

			t_AddrStr.TrimLeft();
			t_AddrStr.TrimRight();

			if (!t_AddrStr.IsEmpty())
			{
				if ( SUCCEEDED ( CPingTaskObject::Icmp_ResolveAddress ( t_AddrStr , m_SourceRouteArray[m_SourceRouteCount] ) ) )
				{
					m_SourceRouteCount++;

					if ((m_SourceRouteCount == PING_MAX_IPS) && (t_Index != -1))
					{
						t_RetVal = FALSE;
						break;
					}
				}
				else
				{
					t_RetVal = FALSE;
					break;
				}
			}
			else
			{
				t_RetVal = FALSE;
				break;
			}
		}
	}

	return t_RetVal;
}

void CPingCallBackObject::SendEcho()
{
	if (m_ParentTask != NULL)
	{
		if (m_ParentTask->SetThreadToken(FALSE))
		{
			HRESULT t_Result = GetIcmpHandle() ? S_OK : WBEM_E_FAILED;
			BOOL t_SourceRouting = FALSE ;

			uchar t_SendOptions [ MAX_OPT_SIZE ] ;
			uint t_OptionLength = 0;
			int t_OptionIndex = 0 ;
			int t_SourceRouteIndex = -1 ;

			uchar t_Flags = m_NoFragmentation ? IP_FLAG_DF : 0 ;

			if (FAILED(t_Result))
			{
				SendError (IDS_ICMPCREATEFILE_FAIL, WBEM_E_FAILED);
			}
			else
			{
				if ( m_RecordRoute )
				{
					if ( ( t_OptionIndex + 3 ) <= MAX_OPT_SIZE )
					{
						ULONG t_RouteRecordCount = ( m_RecordRoute * sizeof ( ULONG ) ) + 3 ;

						if ( ( t_RouteRecordCount + t_OptionIndex ) <= MAX_OPT_SIZE) 
						{
							uchar *t_Options = t_SendOptions ;

							t_Options [ t_OptionIndex ] = IP_OPT_RR ;
							t_Options [ t_OptionIndex + 1 ] = t_RouteRecordCount ;
							t_Options [ t_OptionIndex + 2 ] = 4;  // Set initial pointer value

							t_OptionLength += t_RouteRecordCount;
							t_OptionIndex += t_RouteRecordCount ;

							t_SourceRouting = TRUE;
						}
						else
						{	
							t_Result = WBEM_E_FAILED ;
							SendError (IDS_RR_MAX, WBEM_E_FAILED);
						}
					}
					else
					{
						t_Result = WBEM_E_FAILED ;
						SendError (IDS_RR_MAX_INDEX, WBEM_E_FAILED);
					}
				}
			}

			if (SUCCEEDED (t_Result))
			{
				if ( m_TimestampRoute )
				{
					if ( ( t_OptionIndex + 4 ) <= MAX_OPT_SIZE )
					{
						ULONG t_TimestampRecordCount = ( m_TimestampRoute * sizeof ( ULONG ) * 2 ) + 4 ;

						if ( ( t_TimestampRecordCount + t_OptionIndex ) <= MAX_OPT_SIZE) 
						{
							uchar *t_Options = t_SendOptions ;

							t_Options [ t_OptionIndex ] = IP_OPT_TS ;
							t_Options [ t_OptionIndex + 1 ] = t_TimestampRecordCount ;
							t_Options [ t_OptionIndex + 2 ] = 5;  // Set initial pointer value
							t_Options [ t_OptionIndex + 3 ] = 1 ;

							t_OptionLength += t_TimestampRecordCount ;
							t_OptionIndex += t_TimestampRecordCount ;

							t_SourceRouting = TRUE;
						}
						else
						{	
							t_Result = WBEM_E_FAILED ;
							SendError (IDS_TS_MAX, WBEM_E_FAILED);
						}
					}
					else
					{
						t_Result = WBEM_E_FAILED ;
						SendError (IDS_TS_MAX_INDEX, WBEM_E_FAILED);
					}
				}
			}

			if (SUCCEEDED (t_Result))
			{
				switch ( m_SourceRouteType )
				{
					case 1:
					{
						if ( ParseSourceRoute() )
						{
							if ( ( t_OptionIndex + 3 ) <= MAX_OPT_SIZE )
							{
								if ( t_OptionIndex + m_SourceRouteCount <= MAX_OPT_SIZE - 4 )
								{
									uchar *t_Options = t_SendOptions ;

									t_Options [ t_OptionIndex ] = IP_OPT_LSRR ;
									t_Options [ t_OptionIndex + 1 ] = 3;  
									t_Options [ t_OptionIndex + 2 ] = 4;  

									t_OptionLength += 3 ;

									for ( ULONG t_SourceIndex = 0 ; t_SourceIndex < m_SourceRouteCount ; t_SourceIndex ++ )
									{
										ULONG t_RouteIndex = t_Options [ t_OptionIndex + 1 ] ;

										//* ( ULONG * ) &t_Options [ t_RouteIndex + t_OptionIndex ] = m_SourceRouteArray [ t_SourceIndex ] ;
										memcpy ( &t_Options [ t_RouteIndex + t_OptionIndex ], &m_SourceRouteArray [ t_SourceIndex ], sizeof ( ULONG ) );

										t_Options [ t_OptionIndex + 1 ] += 4 ;
										t_OptionLength += 4 ;
									}

									t_SourceRouteIndex = t_Options [ t_OptionIndex + 1 ] + t_OptionIndex ;

									t_Options [ t_OptionIndex + 1 ] += 4 ;   // Save space for dest. addr
									t_OptionIndex += t_Options [ t_OptionIndex + 1 ] ;
									t_OptionLength += 4 ;

									t_SourceRouting = TRUE;
								}
								else
								{	
									t_Result = WBEM_E_FAILED ;
									SendError (IDS_SR_MAX, WBEM_E_FAILED);
								}
							}
							else
							{
								t_Result = WBEM_E_FAILED ;
								SendError (IDS_SR_MAX_INDEX, WBEM_E_FAILED);
							}
						}
						else
						{
							t_Result = WBEM_E_FAILED ;
							SendError (IDS_SR_PARSE, WBEM_E_FAILED);
						}
					}
					break ;

					case 2:
					{
						if ( ParseSourceRoute() )
						{
							if ( ( t_OptionIndex + 3 ) <= MAX_OPT_SIZE )
							{
								if ( t_OptionIndex + m_SourceRouteCount <= MAX_OPT_SIZE - 4 )
								{
									uchar *t_Options = t_SendOptions ;

									t_Options [ t_OptionIndex ] = IP_OPT_SSRR ;
									t_Options [ t_OptionIndex + 1 ] = 3;  
									t_Options [ t_OptionIndex + 2 ] = 4;  

									t_OptionLength += 3 ;

									for ( ULONG t_SourceIndex = 0 ; t_SourceIndex < m_SourceRouteCount ; t_SourceIndex ++ )
									{
										ULONG t_RouteIndex = t_Options [ t_OptionIndex + 1 ] ;

										//* ( ULONG * ) &t_Options [ t_RouteIndex + t_OptionIndex ] = m_SourceRouteArray [ t_SourceIndex ] ;
										memcpy ( &t_Options [ t_RouteIndex + t_OptionIndex ], &m_SourceRouteArray [ t_SourceIndex ], sizeof ( ULONG ) );

										t_Options [ t_OptionIndex + 1 ] += 4 ;
										t_OptionLength += 4 ;
									}

									t_SourceRouteIndex = t_Options [ t_OptionIndex + 1 ] + t_OptionIndex ;

									t_Options [ t_OptionIndex + 1 ] += 4 ;   // Save space for dest. addr
									t_OptionIndex += t_Options [ t_OptionIndex + 1 ] ;
									t_OptionLength += 4 ;

									t_SourceRouting = TRUE;
								}
								else
								{	
									t_Result = WBEM_E_FAILED ;
									SendError (IDS_SR_MAX, WBEM_E_FAILED);
								}
							}
							else
							{
								t_Result = WBEM_E_FAILED ;
								SendError (IDS_SR_MAX_INDEX, WBEM_E_FAILED);
							}
						}
						else
						{
							t_Result = WBEM_E_FAILED ;
							SendError (IDS_SR_PARSE, WBEM_E_FAILED);
						}
      				}
					break ;

					case 0:
					default:
					{
					}
					break ;
				}
			}

			if (SUCCEEDED (t_Result))
			{
				if ( t_SourceRouteIndex != -1 )
				{
					//* ( ULONG *) & t_SendOptions [ t_SourceRouteIndex ] = m_Address ;
					memcpy ( & t_SendOptions [ t_SourceRouteIndex ], &m_Address, sizeof ( ULONG ) );
				}

				m_SendBuffer = new UCHAR[m_SendSize] ;

				//
				// Calculate receive buffer size and try to allocate it.
				//

				if ( m_SendSize <= DEFAULT_SEND_SIZE )
				{
					m_ReplySize = DEFAULT_BUFFER_SIZE ;
				}
				else 
				{
					m_ReplySize = MAX_BUFFER_SIZE ;
				}

				m_ReplyBuffer = new UCHAR[m_ReplySize] ;

				//
				// Initialize the send buffer pattern.
				//
				for ( ULONG t_Index = 0; t_Index < m_SendSize; t_Index ++)
				{
					m_SendBuffer [ t_Index ] = 'a' + ( t_Index % 23 ) ;
				}

				//
				// Initialize the send options
				//

				IP_OPTION_INFORMATION t_SendOptionInformation ;

				t_SendOptionInformation.OptionsData = t_SendOptions ;
				t_SendOptionInformation.OptionsSize = (uchar) t_OptionLength ;

				t_SendOptionInformation.Ttl = m_TimeToLive ;
				t_SendOptionInformation.Tos = m_TypeofService ;
				t_SendOptionInformation.Flags = t_Flags ;
			
				//will always return 0 in async case!
				ULONG t_ReplyStatus = IcmpSendEcho2 (

						m_IcmpHandle,
						0,
						ApcRoutine,
						(PVOID)this ,
						m_Address,
						m_SendBuffer ,
						(unsigned short) m_SendSize ,
						& t_SendOptionInformation ,
						m_ReplyBuffer,
						m_ReplySize,
						m_Timeout
				);

				//we're async get the return val elsewhere
				t_ReplyStatus = GetLastError();

				if( (ERROR_SUCCESS != t_ReplyStatus) && (ERROR_IO_PENDING != t_ReplyStatus) )
				{
					SendError (IDS_ICMPSENDECHO2, WBEM_E_FAILED);
				}
			}

			m_ParentTask->SetThreadToken(TRUE);

			if (FAILED(t_Result))
			{
				Release();
			}
		}
		else
		{
			SendError(IDS_IMPERSONATE_SEND, WBEM_E_ACCESS_DENIED);
			Release();
		}
	}
	else
	{
		Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\dll\pingquery.cpp ===
/******************************************************************

   pingquery.CPP



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  

   Description: 
   
******************************************************************/

#include <stdafx.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include ".\res_str.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <PingProv.h>
#include <Pingtask.h>
#include <Pingfac.h>

CPingQueryAsync::CPingQueryAsync (CPingProvider *a_Provider , 
								  BSTR a_QueryFormat , 
								  BSTR a_Query , 
								  ULONG a_Flag , 
								  IWbemObjectSink *a_NotificationHandler ,
								  IWbemContext *a_Ctx
								  ) : m_QueryFormat(NULL),
									  m_Query(NULL),
									  CPingTaskObject (a_Provider, a_NotificationHandler, a_Ctx)
{
	if (a_QueryFormat != NULL)
	{
		int t_len = wcslen(a_QueryFormat);

		if (t_len > 0)
		{
			m_QueryFormat = new WCHAR[t_len+1];
			m_QueryFormat[t_len] = L'\0';
			wcsncpy(m_QueryFormat, a_QueryFormat, t_len);
		}
	}

	if (a_Query != NULL)
	{
		int t_len = wcslen(a_Query);

		if (t_len > 0)
		{
			m_Query = new WCHAR[t_len+1];
			m_Query[t_len] = L'\0';
			wcsncpy(m_Query, a_Query, t_len);
		}
	}
}

CPingQueryAsync::~CPingQueryAsync ()
{
	if (m_Query != NULL)
	{
		delete [] m_Query ;
	}

	if (m_QueryFormat != NULL)
	{
		delete [] m_QueryFormat ;
	}
}

QueryPreprocessor :: QuadState CPingQueryAsync :: Compare ( 

	LONG a_Operand1 , 
	LONG a_Operand2 , 
	ULONG a_Operand1Func ,
	ULONG a_Operand2Func ,
	WmiTreeNode &a_OperatorType 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	switch ( a_Operand1Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		t_Status = a_Operand1 == a_Operand2 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		t_Status = a_Operand1 != a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		t_Status = a_Operand1 >= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		t_Status = a_Operand1 <= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		t_Status = a_Operand1 < a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		t_Status = a_Operand1 > a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;

	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	return t_Status ;
}

QueryPreprocessor :: QuadState CPingQueryAsync :: Compare ( 

	wchar_t *a_Operand1 , 
	wchar_t *a_Operand2 , 
	ULONG a_Operand1Func ,
	ULONG a_Operand2Func ,
	WmiTreeNode &a_OperatorType 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	wchar_t *a_Operand1AfterFunc = NULL ;
	wchar_t *a_Operand2AfterFunc = NULL ; 

	switch ( a_Operand1Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			ULONG length = wcslen ( a_Operand1 ) ;
			wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand1AfterFunc [ index ] = towupper ( a_Operand1 [ index ] ) ;
			}
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			ULONG length = wcslen ( a_Operand1 ) ;
			wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand1AfterFunc [ index ] = towlower ( a_Operand1 [ index ] ) ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Upper:
		{
			ULONG length = wcslen ( a_Operand2 ) ;
			wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand2AfterFunc [ index ] = towupper ( a_Operand2 [ index ] ) ;
			}
		}
		break ;

		case WmiValueNode :: WmiValueFunction :: Function_Lower:
		{
			ULONG length = wcslen ( a_Operand2 ) ;
			wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				a_Operand2AfterFunc [ index ] = towlower ( a_Operand2 [ index ] ) ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	const wchar_t *t_Arg1 = a_Operand1AfterFunc ? a_Operand1AfterFunc : a_Operand1 ;
	const wchar_t *t_Arg2 = a_Operand2AfterFunc ? a_Operand2AfterFunc : a_Operand2 ;

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) == 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) != 0 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) >= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_False ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) <= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) < 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) > 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	delete [] a_Operand1AfterFunc ;
	delete [] a_Operand2AfterFunc ;

	return t_Status ;
}

QueryPreprocessor :: QuadState CPingQueryAsync :: CompareString ( 

	IWbemClassObject *a_ClassObject ,
	BSTR a_PropertyName , 
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	WmiStringNode *t_StringNode = ( WmiStringNode * ) a_Operand ; 

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_StringNode->GetValue () ,
			t_Variant.bstrVal ,
			t_StringNode->GetPropertyFunction () ,
			t_StringNode->GetConstantFunction () ,
			*a_Operator 
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

QueryPreprocessor :: QuadState CPingQueryAsync :: CompareInteger ( 

	IWbemClassObject *a_ClassObject ,
	BSTR a_PropertyName , 
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	WmiSignedIntegerNode *t_IntegerNode = ( WmiSignedIntegerNode * ) a_Operand ; 

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = a_ClassObject->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_IntegerNode->GetValue () ,
			t_Variant.lVal ,
			t_IntegerNode->GetPropertyFunction () ,
			t_IntegerNode->GetConstantFunction () ,
			*a_Operator 
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

WmiTreeNode *CPingQueryAsync :: AllocTypeNode ( 

	void *a_Context ,
	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode ( 

				a_PropertyName , 
				a_Variant.lVal , 
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 &&
            (V_VT(&a_Variant) == VT_I4))
		{
			t_Node = new WmiSignedIntegerNode ( 

				a_PropertyName , 
				a_Variant.lVal , 
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 &&
            (V_VT(&a_Variant) == VT_BSTR))
		{
			t_Node = new WmiStringNode ( 

				a_PropertyName , 
				a_Variant.bstrVal , 
				a_PropertyFunction ,
				a_ConstantFunction ,
				0xFFFFFFFF ,
				a_Parent 
			) ;
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
		{
		}
	}
	else
	{
		IWbemClassObject *t_Object = NULL ;
		HRESULT t_Result = GetClassObject ( &t_Object ) ? WBEM_S_NO_ERROR : WBEM_E_FAILED ;

		if ( SUCCEEDED ( t_Result ) )
		{
			CIMTYPE t_VarType ;
			long t_Flavour ;
			VARIANT t_Variant ;
			VariantInit ( & t_Variant ) ;

			t_Result = t_Object->Get (

				a_PropertyName ,
				0 ,
				& t_Variant ,
				& t_VarType ,
				& t_Flavour
			);

			if ( SUCCEEDED ( t_Result ) )
			{
				if ( t_VarType & CIM_FLAG_ARRAY )
				{
				}
				else
				{
					switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
					{
						case CIM_BOOLEAN:
						{
							if(V_VT(&a_Variant) == VT_I4)
                            {
                                t_Node = new WmiSignedIntegerNode ( 

								    a_PropertyName , 
								    a_Variant.lVal , 
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
                            }
							else if (V_VT(&a_Variant) == VT_BOOL)
							{
                                t_Node = new WmiSignedIntegerNode ( 

								    a_PropertyName , 
									(a_Variant.lVal == VARIANT_FALSE) ? 0 : 1, 
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
							}
							else if (V_VT(&a_Variant) == VT_NULL)
							{
								t_Node = new WmiNullNode (

									a_PropertyName , 
									GetPriority ( a_PropertyName ) ,
									a_Parent 
								);
							}
						}
						break ;

						case CIM_SINT8:
						case CIM_SINT16:
						case CIM_CHAR16:
						case CIM_SINT32:
						{
							if(V_VT(&a_Variant) == VT_I4)
                            {
                                t_Node = new WmiSignedIntegerNode ( 

								    a_PropertyName , 
								    a_Variant.lVal , 
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
                            }
							else if (V_VT(&a_Variant) == VT_NULL)
							{
								t_Node = new WmiNullNode (

									a_PropertyName , 
									GetPriority ( a_PropertyName ) ,
									a_Parent 
								);
							}
						}
						break ;

						case CIM_UINT8:
						case CIM_UINT16:
						case CIM_UINT32:
						{
							if(V_VT(&a_Variant) == VT_I4)
                            {
                                t_Node = new WmiUnsignedIntegerNode ( 

								    a_PropertyName , 
								    a_Variant.lVal , 
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
                            }
							else if (V_VT(&a_Variant) == VT_NULL)
							{
								t_Node = new WmiNullNode (

									a_PropertyName , 
									GetPriority ( a_PropertyName ) ,
									a_Parent 
								);
							}
						}
						break ;

						case CIM_SINT64:
						case CIM_UINT64:
						{
							if(V_VT(&a_Variant) == VT_BSTR)
                            {
                                t_Node = new WmiStringNode ( 

								    a_PropertyName , 
								    a_Variant.bstrVal , 
								    a_PropertyFunction ,
								    a_ConstantFunction ,
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
                            }
							else if(V_VT(&a_Variant) == VT_I4)
							{
								_variant_t t_uintBuff (&a_Variant);

                                t_Node = new WmiStringNode ( 

								    a_PropertyName , 
								    (BSTR)((_bstr_t) t_uintBuff), 
								    a_PropertyFunction ,
								    a_ConstantFunction ,
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
							}
							else if (V_VT(&a_Variant) == VT_NULL)
							{
								t_Node = new WmiNullNode (

									a_PropertyName , 
									GetPriority ( a_PropertyName ) ,
									a_Parent 
								);
							}
						}
						break ;

						case CIM_STRING:
						case CIM_DATETIME:
						case CIM_REFERENCE:
						{
							if(V_VT(&a_Variant) == VT_BSTR)
                            {
                                t_Node = new WmiStringNode ( 

								    a_PropertyName , 
								    a_Variant.bstrVal , 
								    a_PropertyFunction ,
								    a_ConstantFunction ,
								    GetPriority ( a_PropertyName ) ,
								    a_Parent 
							    ) ;
                            }
							else if (V_VT(&a_Variant) == VT_NULL)
							{
								t_Node = new WmiNullNode (

									a_PropertyName , 
									GetPriority ( a_PropertyName ) ,
									a_Parent 
								);
							}
						}
						break ;

						case CIM_REAL32:
						case CIM_REAL64:
						{
						}
						break ;

						case CIM_OBJECT:
						case CIM_EMPTY:
						{
						}
						break ;

						default:
						{
						}
						break ;
					}
				}
			}

			t_Object->Release () ;

			VariantClear ( & t_Variant ) ;
		}

	}

	return t_Node ;
}

QueryPreprocessor :: QuadState CPingQueryAsync :: InvariantEvaluate ( 

	void *a_Context ,
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand 
)
{
/*
 *  If property and value are invariant i.e. will never change for all instances then return State_True.
 *	If property is not indexable or keyed then return State_True to define an unknown number of possible values which we cannot optimise against.
 *	If property and value can never occur then return State_False to imply empty set
 *	If property and value do not infer anything then return State_Undefined.
 *	If property and value are in error then return State_Error
 *	Never return State_ReEvaluate.
 */

	QueryPreprocessor :: QuadState t_State = QueryPreprocessor :: QuadState :: State_Error ;

	IWbemClassObject *t_Object = NULL ;
	HRESULT t_Result = GetClassObject ( &t_Object ) ? WBEM_S_NO_ERROR : WBEM_E_FAILED ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WmiValueNode *t_Node = ( WmiValueNode * ) a_Operand ;
		BSTR t_PropertyName = t_Node->GetPropertyName () ;

		if ( t_PropertyName != NULL )
		{
			if ( *t_PropertyName == L'_' )
			{
				// System property, must check values

				if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_CLASS ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_SUPERCLASS ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 )
				{
					t_State = CompareInteger ( 

						t_Object ,
						SYSTEM_PROPERTY_GENUS ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_SERVER ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_NAMESPACE ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 )
				{
					t_State = CompareInteger ( 

						t_Object ,
						SYSTEM_PROPERTY_PROPERTY_COUNT ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_DYNASTY ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_RELPATH ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 )
				{
					t_State = CompareString ( 

						t_Object ,
						SYSTEM_PROPERTY_PATH ,
						a_Operator ,
						a_Operand
					) ;
				}
				else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}

			}
			else
			{
				if ( typeid ( *a_Operand ) == typeid ( WmiNullNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
	#if 0
				else if ( typeid ( *a_Operand ) == typeid ( WmiStringNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operand ) == typeid ( WmiUnsignedIntegerNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operand ) == typeid ( WmiSignedIntegerNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}

				if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotEqualNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrLessNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLessNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorGreaterNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLikeNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
				else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotLikeNode ) )
				{
					t_State = QueryPreprocessor :: QuadState :: State_Undefined ;
				}
	#endif
			}
		}
		else
		{
			t_State = QueryPreprocessor :: QuadState :: State_Undefined;
		}

		t_Object->Release () ;
	}

	return t_State ;
}

WmiRangeNode *CPingQueryAsync :: AllocInfiniteRangeNode (

	void *a_Context ,
	BSTR a_PropertyName 
)
{
	WmiRangeNode *t_RangeNode = NULL ;

	IWbemClassObject *t_Object = NULL ;
	HRESULT t_Result = GetClassObject ( &t_Object ) ? WBEM_S_NO_ERROR : WBEM_E_FAILED ;
	if ( SUCCEEDED ( t_Result ) )
	{
		CIMTYPE t_VarType ;
		long t_Flavour ;
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		HRESULT t_Result = t_Object->Get (

			a_PropertyName ,
			0 ,
			& t_Variant ,
			& t_VarType ,
			& t_Flavour
		);

		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_VarType & CIM_FLAG_ARRAY )
			{
			}
			else
			{
				switch ( t_VarType & ( ~ CIM_FLAG_ARRAY ) )
				{
					case CIM_BOOLEAN:
					case CIM_SINT8:
					case CIM_SINT16:
					case CIM_CHAR16:
					case CIM_SINT32:
					{
						t_RangeNode = new WmiSignedIntegerRangeNode ( 

							a_PropertyName , 
							0xFFFFFFFF , 
							TRUE ,
							TRUE ,
							FALSE ,
							FALSE ,
							0 ,
							0 ,
							NULL , 
							NULL 
						) ;
					}
					break ;

					case CIM_UINT8:
					case CIM_UINT16:
					case CIM_UINT32:
					{
						t_RangeNode = new WmiUnsignedIntegerRangeNode ( 

							a_PropertyName , 
							0xFFFFFFFF , 
							TRUE ,
							TRUE ,
							FALSE ,
							FALSE ,
							0 ,
							0 ,
							NULL , 
							NULL 
						) ;
					}
					break ;

					case CIM_SINT64:
					case CIM_UINT64:
					case CIM_STRING:
					case CIM_DATETIME:
					case CIM_REFERENCE:
					{
						t_RangeNode = new WmiStringRangeNode ( 

							a_PropertyName , 
							0x0 , 
							TRUE ,
							TRUE ,
							FALSE ,
							FALSE ,
							NULL ,
							NULL ,
							NULL , 
							NULL 
						) ;
					}
					break ;

					case CIM_REAL32:
					case CIM_REAL64:
					{
					}
					break ;

					case CIM_OBJECT:
					case CIM_EMPTY:
					{
					}
					break ;

					default:
					{
					}
					break ;
				}
			}

		}

		t_Object->Release () ;
		VariantClear ( & t_Variant ) ;
	}

	return t_RangeNode ;
}

ULONG CPingQueryAsync :: GetPriority ( BSTR a_PropertyName )
{
	if ( _wcsicmp ( a_PropertyName , Ping_Address ) == 0 )
	{
		return 0 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_Timeout ) == 0 )
	{
		return 1 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_TimeToLive ) == 0 )
	{
		return 2 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_BufferSize ) == 0 )
	{
		return 3 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_NoFragmentation ) == 0 )
	{
		return 4 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_TypeofService ) == 0 )
	{
		return 5 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_RecordRoute ) == 0 )
	{
		return 6 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_TimestampRoute ) == 0 )
	{
		return 7 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_SourceRouteType ) == 0 )
	{
		return 8 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_SourceRoute ) == 0 )
	{
		return 9 ;
	}

	if ( _wcsicmp ( a_PropertyName , Ping_ResolveAddressNames  ) == 0 )
	{
		return 10 ;
	}

	return 0xFFFFFFFF ;
}

HRESULT CPingQueryAsync :: RecurseAddress (

	void *pMethodContext, 
	PartitionSet *a_PartitionSet
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	if (t_PartitionCount == 0)
	{
		t_Result = S_OK ;
	}

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( wcscmp ( t_Node->LowerBound () , t_Node->UpperBound () ) == 0 ) ;

		if ( ! t_Unique )
		{
			SetErrorInfo(IDS_QUERY_ADDR,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			ULONG t_Address = 0 ;
			ULONG t_ResolveErr = 0 ;
			
			if ( FAILED ( Icmp_ResolveAddress ( t_Node->LowerBound () , t_Address , &t_ResolveErr ) ) && (t_ResolveErr == 0))
			{
				t_ResolveErr = WSAHOST_NOT_FOUND;
			}

			//if even one call succeeds return success
			if (SUCCEEDED( RecurseTimeOut (pMethodContext , 
							t_Node->LowerBound () ,
							t_Address, 
							t_PropertyPartition,
							t_ResolveErr)
				&& FAILED (t_Result) ) )
			{
				t_Result = S_OK;
			}
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseTimeOut (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	PartitionSet *a_PartitionSet ,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_TO,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseTimeToLive (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				t_UnSpecified ? DEFAULT_TIMEOUT : t_Node->LowerBound () , 
				t_PropertyPartition  ,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseTimeToLive (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_TTL,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseBufferSize (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				t_UnSpecified ? DEFAULT_TTL : t_Node->LowerBound () , 
				t_PropertyPartition ,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseBufferSize (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive ,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_BUF,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseNoFragmentation (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				t_UnSpecified ? DEFAULT_SEND_SIZE : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseNoFragmentation (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_NOFRAG,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseTypeOfService (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				t_UnSpecified ? FALSE : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseTypeOfService (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_TOS,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseRecordRoute (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				a_NoFragmentation ,
				t_UnSpecified ? 0 : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseRecordRoute (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	ULONG a_TypeOfService,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_RR,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseTimestampRoute (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				a_NoFragmentation ,
				a_TypeOfService ,
				t_UnSpecified ? 0 : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseTimestampRoute (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	ULONG a_TypeOfService,
	ULONG a_RecordRoute,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_TS,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseSourceRouteType (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				a_NoFragmentation ,
				a_TypeOfService,
				a_RecordRoute,
				t_UnSpecified ? 0 : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}


HRESULT CPingQueryAsync :: RecurseSourceRouteType (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	ULONG a_TypeOfService,
	ULONG a_RecordRoute,
	ULONG a_TimestampRoute,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_SRT,
							WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseSourceRoute (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				a_NoFragmentation ,
				a_TypeOfService,
				a_RecordRoute,
				a_TimestampRoute,
				t_UnSpecified ? 0 : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseSourceRoute (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	ULONG a_TypeOfService,
	ULONG a_RecordRoute,
	ULONG a_TimestampRoute,
	ULONG a_SourceRouteType,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( wcscmp ( t_Node->LowerBound () , t_Node->UpperBound () ) == 0 )  ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_SR,
							WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			t_Result = RecurseResolveAddressNames (

				pMethodContext, 
				a_AddressString ,
				a_Address ,
				a_TimeOut ,
				a_TimeToLive,
				a_SendSize,
				a_NoFragmentation ,
				a_TypeOfService,
				a_RecordRoute,
				a_TimestampRoute,
				a_SourceRouteType,
				t_UnSpecified ? NULL : t_Node->LowerBound () , 
				t_PropertyPartition,
				a_ResolveError
			) ;
		}
	}

	return t_Result ;
}

HRESULT CPingQueryAsync :: RecurseResolveAddressNames (

	void *pMethodContext, 
	wchar_t *a_AddressString ,
	ULONG a_Address ,
	ULONG a_TimeOut ,
	ULONG a_TimeToLive,
	ULONG a_SendSize,
	BOOL a_NoFragmentation ,
	ULONG a_TypeOfService,
	ULONG a_RecordRoute,
	ULONG a_TimestampRoute,
	ULONG a_SourceRouteType,
	LPCWSTR a_SourceRoute,
	PartitionSet *a_PartitionSet,
	ULONG a_ResolveError
)
{
	HRESULT t_Result = WBEM_E_FAILED ;

	ULONG t_PartitionCount = a_PartitionSet->GetPartitionCount () ;

	for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
	{
		PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;

		WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

		BOOL t_Unique = ! t_Node->InfiniteLowerBound () && 
						! t_Node->InfiniteUpperBound () &&
						t_Node->ClosedLowerBound () &&
						t_Node->ClosedUpperBound () &&
						( t_Node->LowerBound () == t_Node->UpperBound () ) ;

		BOOL t_UnSpecified = t_Node->InfiniteLowerBound () && t_Node->InfiniteUpperBound () ;

		if ( ! t_Unique && ! t_UnSpecified )
		{
			SetErrorInfo(IDS_QUERY_RA,
							WBEM_E_PROVIDER_NOT_CAPABLE ) ;
			break ;
		}
		else
		{
			for ( ulong t_Partition = 0 ; t_Partition < t_PartitionCount ; t_Partition ++ )
			{
				PartitionSet *t_PropertyPartition = a_PartitionSet->GetPartition ( t_Partition ) ;
				WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) t_PropertyPartition->GetRange () ;

				InterlockedIncrement(&m_PingCount);
				t_Result = Icmp_RequestResponse ( 

					a_AddressString ,
					a_Address ,
					a_TimeToLive,
					a_TimeOut ,
					a_SendSize,
					a_NoFragmentation ,
					a_TypeOfService,
					a_RecordRoute,
					a_TimestampRoute,
					a_SourceRouteType,
					a_SourceRoute ,
					t_UnSpecified ? FALSE : t_Node->LowerBound (),
					a_ResolveError
				) ;

				if ( FAILED ( t_Result ) )
				{
					DecrementPingCount();
				}
			}
		}
	}

	return t_Result ;
}

BOOL CPingQueryAsync::ExecQuery ()
{
	BOOL t_Result = FALSE ;
	InterlockedIncrement(&m_PingCount);
	SQL_LEVEL_1_RPN_EXPRESSION *t_RpnExpression = NULL ;
	QueryPreprocessor :: QuadState t_State =  Query ( 
		
		m_Query , 
		t_RpnExpression
	) ;

	if ( t_State == QueryPreprocessor :: QuadState :: State_True )
	{
		WmiTreeNode *t_Root = NULL ;

		t_State = PreProcess (

			NULL ,
			t_RpnExpression ,
			t_Root
		) ;

		PartitionSet *t_PartitionSet = NULL ;

		try
		{
			switch ( t_State )
			{
				case QueryPreprocessor :: QuadState :: State_True:
				{
					BSTR t_PropertyContainer [ PING_KEY_PROPERTY_COUNT ] ;
					memset (t_PropertyContainer , 0 , sizeof(BSTR) * PING_KEY_PROPERTY_COUNT );

					try
					{
						t_PropertyContainer [ 0 ] = SysAllocString ( Ping_Address ) ;
						t_PropertyContainer [ 1 ] = SysAllocString ( Ping_Timeout ) ; 
						t_PropertyContainer [ 2 ] = SysAllocString ( Ping_TimeToLive ) ; 
						t_PropertyContainer [ 3 ] = SysAllocString ( Ping_BufferSize ) ; 
						t_PropertyContainer [ 4 ] = SysAllocString ( Ping_NoFragmentation ) ; 
						t_PropertyContainer [ 5 ] = SysAllocString ( Ping_TypeofService ) ; 
						t_PropertyContainer [ 6 ] = SysAllocString ( Ping_RecordRoute ) ; 
						t_PropertyContainer [ 7 ] = SysAllocString ( Ping_TimestampRoute ) ; 
						t_PropertyContainer [ 8 ] = SysAllocString ( Ping_SourceRouteType ) ; 
						t_PropertyContainer [ 9 ] = SysAllocString ( Ping_SourceRoute ) ; 
						t_PropertyContainer [ 10 ] = SysAllocString ( Ping_ResolveAddressNames ) ; 

						if (	!t_PropertyContainer [ 0 ] ||
								!t_PropertyContainer [ 1 ] ||
								!t_PropertyContainer [ 2 ] ||
								!t_PropertyContainer [ 3 ] ||
								!t_PropertyContainer [ 4 ] ||
								!t_PropertyContainer [ 5 ] ||
								!t_PropertyContainer [ 6 ] ||
								!t_PropertyContainer [ 7 ] ||
								!t_PropertyContainer [ 8 ] ||
								!t_PropertyContainer [ 9 ] ||
								!t_PropertyContainer [ 10 ]
						   )
						{
							throw CHeap_Exception (  CHeap_Exception :: E_ALLOCATION_ERROR );
						}

						t_State = PreProcess (	

							NULL ,
							t_RpnExpression ,
							t_Root ,
							PING_KEY_PROPERTY_COUNT , 
							t_PropertyContainer ,
							t_PartitionSet
						) ;

						for ( ULONG index = 0; index < PING_KEY_PROPERTY_COUNT; index++ )
						{
							if ( t_PropertyContainer [ index ] )
							{
								SysFreeString ( t_PropertyContainer [ index ] ) ;
								t_PropertyContainer [ index ] = NULL;
							}
						}

					}
					catch ( ... )
					{
						for ( ULONG index = 0; index < PING_KEY_PROPERTY_COUNT; index++ )
						{
							if ( t_PropertyContainer [ index ] )
							{
								SysFreeString ( t_PropertyContainer [ index ] ) ;
								t_PropertyContainer [ index ] = NULL;
							}
						}

						throw;
					}

					switch ( t_State )
					{
						case QueryPreprocessor :: QuadState :: State_True :	
						{
							SetErrorInfo(IDS_QUERY_BROAD,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
						}
						break ;

						case QueryPreprocessor :: QuadState :: State_False :
						{
		/*
		* Empty set
		*/
							SetErrorInfo(IDS_QUERY_NARROW,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;

						}
						break ;

						case QueryPreprocessor :: QuadState :: State_Undefined :
						{
							t_Result = SUCCEEDED(RecurseAddress ( NULL , t_PartitionSet ) );
							delete t_PartitionSet ;
							t_PartitionSet = NULL;
						}
						break ;

						default:
						{
							SetErrorInfo(IDS_QUERY_UNUSABLE,
									 WBEM_E_PROVIDER_NOT_CAPABLE ) ;
						}
						break ;
					}

					delete t_Root ;
					t_Root = NULL ;
				}
				break ;
			
				default:
				{
					SetErrorInfo(IDS_QUERY_ANALYZE,
									 WBEM_E_FAILED ) ;
				}
				break ;
			}

			delete t_RpnExpression ;
			t_RpnExpression = NULL ;
		}
		catch (...)
		{
			if ( t_PartitionSet )
			{
				delete t_PartitionSet;
				t_PartitionSet = NULL;
			}

			if ( t_Root )
			{
				delete t_Root;
				t_Root = NULL;
			}

			if ( t_RpnExpression )
			{
				delete t_RpnExpression ;
				t_RpnExpression = NULL ;
			}

			DecrementPingCount();
			throw;
		}
	}
	else
	{
		SetErrorInfo(IDS_QUERY_PARSE,
						WBEM_E_FAILED ) ;
	}

	DecrementPingCount();
	return t_Result ;
}

void CPingQueryAsync::HandleResponse (CPingCallBackObject *a_reply)
{
	try
	{
		if (FAILED(Icmp_DecodeAndIndicate (a_reply)) )	
		{
			SetErrorInfo(IDS_DECODE_QUERY,
								 WBEM_E_FAILED ) ;
		}
	}
	catch (...)
	{
		DecrementPingCount();
	}

	DecrementPingCount();
}

void CPingQueryAsync::HandleErrorResponse (DWORD a_ErrMsgID, HRESULT a_HRes)
{
	try
	{
		SetErrorInfo(a_ErrMsgID , a_HRes) ;
	}
	catch (...)
	{
		DecrementPingCount();
	}

	DecrementPingCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\dll\pingtask.cpp ===
/******************************************************************

   CPingProvider.CPP -- WMI provider class implementation



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  

   Description: 
   
******************************************************************/

#include <stdafx.h>
#include <ntddtcp.h>
#include <ipinfo.h>
#include <tdiinfo.h>
#include <winsock2.h>
#include <provimex.h>
#include <provexpt.h>
#include <provtempl.h>
#include <provmt.h>
#include <typeinfo.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>
#include <provval.h>
#include <provtype.h>
#include <provtree.h>
#include <provdnf.h>
#include <winsock.h>
#include "ipexport.h"
#include "icmpapi.h"

#include ".\res_str.h"

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <PingProv.h>
#include <Pingtask.h>
#include <Pingfac.h>

extern HMODULE ghModule ;

// Property names
//===============	

const WCHAR *Ping_Address = L"Address" ;
const WCHAR *Ping_Timeout = L"Timeout" ;
const WCHAR *Ping_TimeToLive = L"TimeToLive" ;
const WCHAR *Ping_BufferSize = L"BufferSize" ;
const WCHAR *Ping_NoFragmentation = L"NoFragmentation" ;
const WCHAR *Ping_TypeofService = L"TypeofService" ;
const WCHAR *Ping_RecordRoute = L"RecordRoute" ;
const WCHAR *Ping_TimestampRoute = L"TimestampRoute" ;
const WCHAR *Ping_SourceRouteType = L"SourceRouteType" ;
const WCHAR *Ping_SourceRoute = L"SourceRoute" ;
const WCHAR *Ping_ResolveAddressNames = L"ResolveAddressNames" ;

const static WCHAR *Ping_StatusCode = L"StatusCode" ;
const static WCHAR *Ping_ResponseTime = L"ResponseTime" ;
const static WCHAR *Ping_RouteRecord = L"RouteRecord" ;
const static WCHAR *Ping_ReplySize = L"ReplySize" ;
const static WCHAR *Ping_ReplyInconsistency = L"ReplyInconsistency" ;
const static WCHAR *Ping_ResponseTimeToLive = L"ResponseTimeToLive" ;
const static WCHAR *Ping_ProtocolAddress = L"ProtocolAddress" ;
const static WCHAR *Ping_TimeStampRecord = L"TimeStampRecord" ;
const static WCHAR *Ping_TimeStampRecordAddress = L"TimeStampRecordAddress" ;
const static WCHAR *Ping_TimeStampRecordAddressResolved = L"TimeStampRecordAddressResolved" ;
const static WCHAR *Ping_RouteRecordResolved = L"RouteRecordResolved" ;
const static WCHAR *Ping_ProtocolAddressResolved = L"ProtocolAddressResolved" ;
const static WCHAR *Ping_ResolveError = L"PrimaryAddressResolutionStatus" ;

CPingTaskObject::CPingErrorObject::~CPingErrorObject()
{
	if (m_Description != NULL)
	{
		delete [] m_Description;
	}
}

void CPingTaskObject::CPingErrorObject::SetInfo(LPCWSTR a_description, HRESULT a_status)
{
	m_Status = a_status;

	if (m_Description != NULL)
	{
		delete [] m_Description;
		m_Description = NULL;
	}

	if (a_description != NULL)
	{
		int t_len = wcslen(a_description);

		if (t_len > 0)
		{
			m_Description = new WCHAR[t_len+1];
			m_Description[t_len] = L'\0';
			wcsncpy(m_Description, a_description, t_len);
		}
	}
}

CPingTaskObject::CPingTaskObject (CPingProvider *a_Provider ,
									IWbemObjectSink *a_NotificationHandler ,
									IWbemContext *a_Ctx
									): m_NotificationHandler(NULL),
									m_Ctx(NULL),
									m_Provider(NULL),
									m_PingCount(0),
									m_ThreadToken(NULL)
{
	InitializeCriticalSection(&m_CS);

	if (a_NotificationHandler != NULL)
	{
		m_NotificationHandler = a_NotificationHandler;
		m_NotificationHandler->AddRef();
	}

	if (a_Ctx != NULL)
	{
		m_Ctx = a_Ctx;
		m_Ctx->AddRef();
	}

	if (a_Provider != NULL)
	{
		m_Provider = a_Provider;
		m_Provider->AddRef();
	}
}

CPingTaskObject::~CPingTaskObject ()
{
	if (m_NotificationHandler != NULL)
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = TRUE;
    
		if ( FAILED(m_ErrorObject.GetStatus ()) )
		{
			t_Status = GetStatusObject ( &t_NotifyStatus ) ;
		}

		if ( t_Status )
		{
			m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetStatus () , 0 , t_NotifyStatus ) ;
        
			if (t_NotifyStatus)
			{
				t_NotifyStatus->Release () ;
			}
		}
		else
		{
			m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetStatus () , 0 , NULL ) ;
		}

		m_NotificationHandler->Release();
		m_NotificationHandler = NULL;
	}

	if (m_Ctx != NULL)
	{
		m_Ctx->Release();
		m_Ctx = NULL;
	}

	if (m_Provider != NULL)
	{
		m_Provider->Release();
		m_Provider = NULL;
	}

	if (m_ThreadToken != NULL)
	{
		CloseHandle(m_ThreadToken);
		m_ThreadToken = NULL;
	}

	DeleteCriticalSection(&m_CS);
}

void CPingTaskObject::DecrementPingCount()
{
	if (0 == InterlockedDecrement(&m_PingCount))
	{
		delete this;
	}
}

BOOL CPingTaskObject :: GetThreadToken()
{
	BOOL t_RetVal = OpenThreadToken(
							  GetCurrentThread(),									// handle to thread
							  TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,	// access to process
							  TRUE,												// use thread security
							  &m_ThreadToken										// pointer to token handle
							);

	if (!t_RetVal)
	{
			SetErrorInfo(IDS_DUP_THRDTOKEN  ,
						WBEM_E_ACCESS_DENIED ) ;
	}

	return t_RetVal;
}

BOOL CPingTaskObject :: SetThreadToken(BOOL a_Reset)
{
	BOOL t_RetVal = ::SetThreadToken(NULL, a_Reset ? NULL : m_ThreadToken);

	return t_RetVal;
}

BOOL CPingTaskObject :: GetStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	HRESULT t_Result = WBEM_E_FAILED ;

    if ( m_Provider->GetNotificationObject ( m_Ctx, a_NotifyObject ) )
    {
		_variant_t t_Variant((long) m_ErrorObject.GetStatus (), VT_I4) ;
		t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			LPCWSTR t_descr = m_ErrorObject.GetDescription ();

			if ( t_descr != NULL ) 
			{
				t_Variant = t_descr ;

				t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;

				if ( ! SUCCEEDED ( t_Result ) )
				{
					(*a_NotifyObject)->Release () ;
					*a_NotifyObject = NULL;
				}
			}
		}
		else
		{
			(*a_NotifyObject)->Release () ;
			*a_NotifyObject = NULL ;
		}
	}

	return (SUCCEEDED (t_Result)) ;
}


BOOL CPingTaskObject::GetClassObject ( IWbemClassObject **a_ppClass )
{
	BOOL t_bRetVal = FALSE;

	if ((a_ppClass != NULL) && (m_Provider != NULL))
	{
		*a_ppClass = NULL;

		if (m_Provider->GetClassObject(a_ppClass) && ((*a_ppClass) != NULL))
		{
			t_bRetVal = TRUE;
		}
	}

	return t_bRetVal;
}

HRESULT CPingTaskObject::Icmp_ResolveAddress ( LPCWSTR a_Path , ULONG &a_IpAddress, DWORD *a_pdwErr )
{
	HRESULT t_Result = WBEM_E_NOT_FOUND ;

	if (a_pdwErr)
	{
		*a_pdwErr = 0 ;
	}

	ProvIpAddressType t_IpAddress ( a_Path ) ;

	if ( ! t_IpAddress.IsValid () ) 
	{
		char *t_AnsiAddress = UnicodeToDbcsString ( a_Path ) ;

		if ( t_AnsiAddress )
		{
			struct hostent *t_HostEntry = gethostbyname ( t_AnsiAddress  ) ;

			if ( t_HostEntry )
			{
				/*
				 * If we find a host entry, set up the internet address
				 */
				t_IpAddress = ProvIpAddressType ( ntohl ( * ( long * ) t_HostEntry->h_addr ) ) ;
			}
			else
			{
				DWORD dwErr = WSAGetLastError();

				if (a_pdwErr)
				{
					*a_pdwErr = dwErr ;
				}
			}

			delete [] t_AnsiAddress ;
		}
	}
	
	if (  t_IpAddress.IsValid () ) 
	{
		a_IpAddress = htonl ( t_IpAddress.GetValue () ) ;

		t_Result = S_OK ;
	}

	return t_Result ;
}

HRESULT CPingTaskObject::SetInstanceKeys(IWbemClassObject *a_Inst , CPingCallBackObject *a_Reply)
{
	if ((a_Inst == NULL) || (a_Reply == NULL))
	{
		return WBEM_E_FAILED;
	}

	//set all 11 keys!

	HRESULT t_RetVal = SetUint32Property( a_Inst, Ping_Timeout, a_Reply->GetTimeout() ) ;

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_TimeToLive, a_Reply->GetTimeToLive() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_BufferSize, a_Reply->GetSendSize() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_TypeofService, a_Reply->GetTypeofService() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_RecordRoute, a_Reply->GetRecordRoute() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_TimestampRoute, a_Reply->GetTimestampRoute() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetUint32Property( a_Inst, Ping_SourceRouteType, a_Reply->GetSourceRouteType() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetBOOLProperty( a_Inst, Ping_NoFragmentation, a_Reply->GetNoFragmentation() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetBOOLProperty( a_Inst, Ping_ResolveAddressNames, a_Reply->GetResolveAddress() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetStringProperty( a_Inst, Ping_SourceRoute, a_Reply->GetSourceRoute() ) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		t_RetVal = SetStringProperty( a_Inst, Ping_Address, a_Reply->GetAddressString()) ;
	}

	if (SUCCEEDED (t_RetVal))
	{
		//not a key so we don't report if this fails...
		SetUint32Property( a_Inst, Ping_ResolveError, a_Reply->GetResolveError() ) ;
	}

	return t_RetVal;
}

HRESULT CPingTaskObject::SetUint32Property(

	IWbemClassObject *a_Inst,
	LPCWSTR a_Name,
	ULONG a_Val
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

	_variant_t t_var((long)a_Val);

	return (a_Inst->Put(a_Name, 0, &t_var, 0));
}

HRESULT CPingTaskObject::SetUint32ArrayProperty(
												
	IWbemClassObject *a_Inst ,
	LPCWSTR a_Name ,
	ULONG* a_Vals ,
	ULONG a_Count
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

    SAFEARRAYBOUND t_rgsabound[1];
    SAFEARRAY* t_psa = NULL;
    t_rgsabound[0].lLbound = 0;
    t_rgsabound[0].cElements = a_Count;
    t_psa = SafeArrayCreate(VT_I4, 1, t_rgsabound);
	HRESULT t_RetVal = S_OK;

	if (NULL != t_psa)
	{
		try
		{
			LONG *t_pdata = NULL;

			if (SUCCEEDED(SafeArrayAccessData(t_psa, (void **)&t_pdata)))
			{
				try
				{
					memcpy((void *)t_pdata, (void *)a_Vals, a_Count*sizeof(ULONG));
					SafeArrayUnaccessData(t_psa);
				}
				catch (...)
				{
					SafeArrayUnaccessData(t_psa);
					throw;
				}

				VARIANT t_var;
				VariantInit(&t_var);
				t_var.vt = VT_ARRAY|VT_I4;
				t_var.parray = t_psa;
				t_psa = NULL;

				try
				{
					t_RetVal = a_Inst->Put(a_Name, 0, &t_var, 0);
				}
				catch (...)
				{
					VariantClear(&t_var);
					throw;
				}
				
				VariantClear(&t_var);
			}
		}
		catch(...)
		{
			if (t_psa != NULL)
			{
				SafeArrayDestroy(t_psa);
			}

			throw;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return t_RetVal;
}


HRESULT CPingTaskObject::SetStringProperty(

	IWbemClassObject *a_Inst,
	LPCWSTR a_Name,
	LPCWSTR a_Val
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

	_variant_t t_var(a_Val);

	return (a_Inst->Put(a_Name, 0, &t_var, 0));
}

HRESULT CPingTaskObject::SetBOOLProperty(

	IWbemClassObject *a_Inst,
	LPCWSTR a_Name,
	BOOL a_Val
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

	_variant_t t_var(a_Val ? true : false);

	return (a_Inst->Put(a_Name, 0, &t_var, 0));
}

void CPingTaskObject::IPAddressToString(_variant_t &a_var, ULONG a_Val, BOOL a_Resolve)
{
	if (!a_Resolve)
	{
		ProvIpAddressType t_ProtocolAddress ( ntohl(a_Val) ) ;
		wchar_t *t_AddressString = t_ProtocolAddress.GetStringValue () ;
		a_var = t_AddressString;
		delete [] t_AddressString ;
	}
	else
	{
		struct in_addr t_Address;
		t_Address.S_un.S_addr = a_Val; //assumes in param in network order when resolving
		struct hostent *t_hostent = gethostbyaddr((char *) &t_Address, sizeof(t_Address), AF_INET);

		if (t_hostent != NULL)
		{
			a_var = t_hostent->h_name;
		}
		else
		{
			ProvIpAddressType t_ProtocolAddress ( ntohl(a_Val) ) ;
			wchar_t *t_AddressString = t_ProtocolAddress.GetStringValue () ;
			a_var = t_AddressString;
			delete [] t_AddressString ;
		}
	}
}

HRESULT CPingTaskObject::SetIPProperty(

	IWbemClassObject *a_Inst ,
	LPCWSTR a_Name ,
	ULONG a_Val ,
	BOOL a_Resolve
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

	_variant_t t_var;
	IPAddressToString(t_var, a_Val, a_Resolve);

	return (a_Inst->Put(a_Name, 0, &t_var, 0));
}

HRESULT CPingTaskObject::SetIPArrayProperty(
											
	IWbemClassObject *a_Inst ,
	LPCWSTR a_Name ,
	ULONG* a_Vals ,
	ULONG a_Count ,
	BOOL a_Resolve
)
{
	if ((a_Inst == NULL) || (a_Name == NULL))
	{
		return WBEM_E_FAILED;
	}

    SAFEARRAYBOUND t_rgsabound[1];
    SAFEARRAY* t_psa = NULL;
    t_rgsabound[0].lLbound = 0;
    t_rgsabound[0].cElements = a_Count;
    t_psa = SafeArrayCreate(VT_BSTR, 1, t_rgsabound);
	HRESULT t_RetVal = S_OK;

	if (NULL != t_psa)
	{
		try
		{
			BSTR *t_pdata = NULL;

			if (SUCCEEDED(SafeArrayAccessData(t_psa, (void **)&t_pdata)))
			{
				try
				{
					for (int i = 0; i < a_Count; i++)
					{
						_variant_t t_var;
						IPAddressToString(t_var, a_Vals[i], a_Resolve);
						VARIANT t_NoDelVar = t_var.Detach() ;
						t_pdata[i] = t_NoDelVar.bstrVal;
					}

					SafeArrayUnaccessData(t_psa);
				}
				catch (...)
				{
					SafeArrayUnaccessData(t_psa);
					throw;
				}
				
				VARIANT t_var;
				VariantInit(&t_var);
				t_var.vt = VT_ARRAY|VT_BSTR;
				t_var.parray = t_psa;
				t_psa = NULL;

				try
				{
					t_RetVal = a_Inst->Put(a_Name, 0, &t_var, 0);
				}
				catch (...)
				{
					VariantClear(&t_var);
					throw;
				}
				
				VariantClear(&t_var);
			}
		}
		catch(...)
		{
			if (t_psa != NULL)
			{
				SafeArrayDestroy(t_psa);
			}

			throw;
		}
	}
	else
	{
		throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
	}

	return t_RetVal;
}

HRESULT CPingTaskObject::Icmp_IndicateResolveError (CPingCallBackObject *a_Reply)
{
	HRESULT t_RetVal = S_OK;
	IWbemClassObjectPtr t_Cls;
	IWbemClassObjectPtr t_Inst;
	
	if (a_Reply != NULL)
	{
		if (GetClassObject ( &t_Cls ) )
		{
			t_RetVal = t_Cls->SpawnInstance(0, &t_Inst);

			if (SUCCEEDED (t_RetVal))
			{
				//put the keys...
				t_RetVal = SetInstanceKeys(t_Inst , a_Reply);

				if (SUCCEEDED(t_RetVal))
				{
					//Indicate!
					IWbemClassObject *t_pTmp = (IWbemClassObject*) t_Inst;
					m_NotificationHandler->Indicate(1, &t_pTmp);
				}
			}
		}
	}
	else
	{
		//should not be NULL!!
		t_RetVal = WBEM_E_FAILED;
	}

	return t_RetVal;
}

HRESULT CPingTaskObject::Icmp_DecodeAndIndicate (CPingCallBackObject *a_Reply)
{
	HRESULT t_RetVal = S_OK;
	PICMP_ECHO_REPLY t_Reply = ( PICMP_ECHO_REPLY ) a_Reply->GetReplyBuffer() ;
	IWbemClassObjectPtr t_Cls;
	IWbemClassObjectPtr t_Inst;
	
	if (t_Reply != NULL)
	{

		if (GetClassObject ( &t_Cls ) )
		{
			t_RetVal = t_Cls->SpawnInstance(0, &t_Inst);

			if (SUCCEEDED (t_RetVal))
			{
				//put the keys...
				t_RetVal = SetInstanceKeys(t_Inst , a_Reply);
			}

			if (SUCCEEDED (t_RetVal))
			{
				ULONG t_StatusCode = 0;

				if ( ( 0 != IcmpParseReplies(t_Reply, a_Reply->GetSendSize()) ) &&
					( t_Reply->Status == IP_SUCCESS ) )
				{
					ProvIpAddressType t_IpAddress((ULONG)ntohl(t_Reply->Address ));
					SetIPProperty(t_Inst , Ping_ProtocolAddress, t_Reply->Address , FALSE);
					
					if (a_Reply->GetResolveAddress())
					{
						SetIPProperty(t_Inst , Ping_ProtocolAddressResolved, t_Reply->Address , TRUE);
					}

					SetUint32Property( t_Inst, Ping_ResponseTime, t_Reply->RoundTripTime ) ;
					SetUint32Property( t_Inst, Ping_ResponseTimeToLive, t_Reply->Options.Ttl ) ;
					SetUint32Property( t_Inst, Ping_ReplySize, t_Reply->DataSize ) ;
					
					BOOL t_ReplyInconsistency = FALSE;

					if ( t_Reply->DataSize == a_Reply->GetSendSize() ) 
					{
						try
						{
							UCHAR *t_SendPtr = & ( a_Reply->GetSendBuffer() [ 0 ] );
							UCHAR *t_ReplyPtr = (UCHAR*) t_Reply->Data ;

							for (ULONG t_Index = 0; t_Index < t_Reply->DataSize; t_Index ++ )
							{
								if ( *t_SendPtr ++ != *t_ReplyPtr ++ ) 
								{
									t_ReplyInconsistency = TRUE ;
									break;
								}
							}
						}
						catch(...)
						{
							t_ReplyInconsistency = TRUE ;
						}
					}
					else
					{
						t_ReplyInconsistency = TRUE ;
					}

					SetBOOLProperty( t_Inst, Ping_ReplyInconsistency, t_ReplyInconsistency ) ;

					if ( t_Reply->Options.OptionsSize )
					{
						ULONG t_RouteSourceCount = 0;
						ULONG *t_RouteSource = NULL;
						ULONG t_TimestampCount = 0;
						ULONG *t_Timestamp = NULL;
						ULONG *t_TimestampRoute = NULL;

						HRESULT t_Result = Icmp_DecodeResponse (

							t_Reply ,
							t_RouteSourceCount ,
							t_RouteSource ,
							t_TimestampCount ,
							t_TimestampRoute ,
							t_Timestamp
						) ;

						if (SUCCEEDED (t_Result))
						{
							if (t_RouteSource != NULL)
							{
								SetIPArrayProperty(
												
									t_Inst ,
									Ping_RouteRecord ,
									t_RouteSource ,
									t_RouteSourceCount ,
									FALSE
								);
							}

							if (t_TimestampRoute != NULL)
							{
								SetIPArrayProperty(
												
									t_Inst ,
									Ping_TimeStampRecordAddress ,
									t_TimestampRoute ,
									t_TimestampCount ,
									FALSE
								);
							}

							if (t_Timestamp != NULL)
							{
								SetUint32ArrayProperty(
																				
									t_Inst ,
									Ping_TimeStampRecord ,
									t_Timestamp ,
									t_TimestampCount
								);
							}

							if (a_Reply->GetResolveAddress())
							{
								if (t_RouteSource != NULL)
								{
									SetIPArrayProperty(
													
										t_Inst ,
										Ping_RouteRecordResolved ,
										t_RouteSource ,
										t_RouteSourceCount ,
										TRUE
									);
								}

								if (t_TimestampRoute != NULL)
								{
									SetIPArrayProperty(
													
										t_Inst ,
										Ping_TimeStampRecordAddressResolved ,
										t_TimestampRoute ,
										t_TimestampCount ,
										TRUE
									);
								}
							}

							delete [] t_RouteSource;
							delete [] t_TimestampRoute;
							delete [] t_Timestamp;
						}
					}
				}
				else 
				{
					t_StatusCode = 	t_Reply->Status ;
				}

				SetUint32Property( t_Inst, Ping_StatusCode, t_StatusCode ) ;
			}

			if (SUCCEEDED(t_RetVal))
			{
				//Indicate!
				IWbemClassObject *t_pTmp = (IWbemClassObject*) t_Inst;
				m_NotificationHandler->Indicate(1, &t_pTmp);
			}
		}
		else
		{
			t_RetVal = WBEM_E_FAILED;
		}
	}
	else
	{
		//should not be NULL!!
		t_RetVal = WBEM_E_FAILED;
	}

	return t_RetVal;
}

void CPingTaskObject::SetErrorInfo(DWORD a_ErrMsgID, HRESULT a_HRes, BOOL a_Force)
{
	CCritSecAutoUnlock t_AutoLockUnlock(&m_CS);

	if (a_Force || SUCCEEDED(m_ErrorObject.GetStatus()) )
	{
		//convert id to string...
		WCHAR t_ErrMsgBuff[255];
		WCHAR *t_ErrMsg = t_ErrMsgBuff;
		int t_buffSz = 255;
		int t_copied = LoadString(ghModule, a_ErrMsgID, t_ErrMsg, t_buffSz);

		//try expanding a couple of times
		//if it is still too big, too bad it'll be truncated
		//not even localized strings should be this big (1500chars = 3k)
		for (int i = 2; (i < 4) && (t_copied == t_buffSz); i++)
		{
			t_ErrMsg = new WCHAR[t_buffSz * i];
			t_buffSz = t_buffSz * i;
			t_copied = LoadString(ghModule, a_ErrMsgID, t_ErrMsg, t_buffSz);
		}

		m_ErrorObject.SetInfo(t_ErrMsg, a_HRes);

		if (t_ErrMsg != t_ErrMsgBuff)
		{
			delete [] t_ErrMsg;
		}
	}
}

HRESULT CPingTaskObject::Icmp_DecodeResponse (PICMP_ECHO_REPLY a_Reply ,
											  ULONG &a_RouteSourceCount ,
											  ULONG *&a_RouteSource ,
											  ULONG &a_TimestampCount ,
											  ULONG *&a_TimestampRoute ,
											  ULONG *&a_Timestamp)
{
	HRESULT t_Result = S_OK ;

    uchar *t_OptionPtr = a_Reply->Options.OptionsData ;
    uchar *t_EndPtr = t_OptionPtr + a_Reply->Options.OptionsSize ;
	BOOL t_Done = FALSE ;

	try
	{
		while ( ( t_OptionPtr < t_EndPtr ) && ! t_Done ) 
		{
			// Get the option type

			switch ( t_OptionPtr [ 0 ] )
			{
				case IP_OPT_EOL:
				{
					t_Done = TRUE;
				}
				break;

				case IP_OPT_NOP:
				{
					t_OptionPtr ++ ;
				}
				break ;

				case IP_OPT_SECURITY:
				{
					t_OptionPtr += 11 ;
				}
				break ;

				case IP_OPT_SID:
				{
					t_OptionPtr += 4;
				}
				break;

				case IP_OPT_RR:
				case IP_OPT_LSRR:
				case IP_OPT_SSRR:
				{
					if ( ( t_OptionPtr + 3 ) <= t_EndPtr ) 
					{
						ULONG t_OptionLength = t_OptionPtr [ 1 ] ;

						if ( ( ( t_OptionPtr + t_OptionLength ) > t_EndPtr ) || ( t_OptionLength < 3 ) )
						{
							// INVALID_RR_OPTION

							t_Done = TRUE ;
							t_Result = WBEM_E_FAILED ;
						}
						else
						{
							ULONG t_RouteTableEndOffset = t_OptionPtr [ 2 ] ;

							if ( t_RouteTableEndOffset < 4 )
							{
								// Advance because the entry is a bad encoding, require 4 bytes for atleast one address

								t_OptionPtr += t_OptionLength ;
							}
							else
							{
								if ( t_RouteTableEndOffset > ( t_OptionLength + 1 ) ) 
								{
									// The actual route table end index is larger than the option itself, therefore decode as much as possible

									t_RouteTableEndOffset = t_OptionLength + 1 ;
								}

								// Count the entries

								ULONG t_RouteEntryOffset = 4 ;
								a_RouteSourceCount = 0;

								while ( ( t_RouteEntryOffset + 3 ) < t_RouteTableEndOffset ) 
								{
									a_RouteSourceCount ++ ;
									t_RouteEntryOffset += 4 ;
								}

								// Extract the routes
								
								if (a_RouteSourceCount > 0)
								{
									a_RouteSource = new ULONG[a_RouteSourceCount];
									a_RouteSourceCount = 0;
									t_RouteEntryOffset = 4 ;

									while ( ( t_RouteEntryOffset + 3 ) < t_RouteTableEndOffset ) 
									{
//										a_RouteSource[a_RouteSourceCount++] = * ( ( IPAddr * ) ( t_OptionPtr + t_RouteEntryOffset - 1 ) ) ;
										memcpy ( &a_RouteSource[a_RouteSourceCount++], t_OptionPtr + t_RouteEntryOffset - 1, sizeof ( IPAddr ) );
										t_RouteEntryOffset += 4 ;
									}
								}
								// Advance to the next option

								t_OptionPtr += t_OptionLength ;
							}
						}
					}
					else
					{
						// INVALID_RR_OPTION

						t_Done = TRUE ;
						t_Result = WBEM_E_FAILED ;
					}
				}
				break;

				case IP_OPT_TS:
				{
					if ( ( t_OptionPtr + 4 ) <= t_EndPtr ) 
					{
						ULONG t_OptionLength = t_OptionPtr [ 1 ] ;
						ULONG t_TimestampTableEndOffset = t_OptionPtr [ 2 ] ;

						if ( t_TimestampTableEndOffset >= 5 )
						{
							if ( t_TimestampTableEndOffset > ( t_OptionLength + 1 ) ) 
							{
								// The actual timestamp table end index is larger than the option itself, therefore decode as much as possible

								t_TimestampTableEndOffset = t_OptionLength + 1 ;
							}

							ULONG t_AddressMode = t_OptionPtr [ 3 ] & 1 ;

							// Count the entries

							ULONG t_TimestampEntryOffset = 5 ;

							while ( ( t_TimestampEntryOffset + 3 ) < t_TimestampTableEndOffset )
							{
								if ( t_AddressMode )
								{
									if ( ( t_TimestampEntryOffset + 8 ) <= t_TimestampTableEndOffset )
									{
										t_TimestampEntryOffset += 8 ;
									}
									else
									{
										break;
									}
								}
								else
								{
									t_TimestampEntryOffset += 4 ;
								}

								a_TimestampCount++ ;
							}

							// Extract the entries
							if (a_TimestampCount > 0)
							{
								a_TimestampRoute = new ULONG[a_TimestampCount];
								a_Timestamp = new ULONG[a_TimestampCount];
								a_TimestampCount = 0;
								t_TimestampEntryOffset = 5 ;

								while ( ( t_TimestampEntryOffset + 3 ) < t_TimestampTableEndOffset )
								{
									if (( t_AddressMode ) && ( ( t_TimestampEntryOffset + 8 ) <= t_TimestampTableEndOffset ))
									{
//										a_TimestampRoute[a_TimestampCount] = * ( ( IPAddr * ) ( t_OptionPtr + t_TimestampEntryOffset - 1 ) ) ;
										memcpy ( &a_TimestampRoute[a_TimestampCount], t_OptionPtr + t_TimestampEntryOffset - 1, sizeof ( IPAddr ) );
										t_TimestampEntryOffset += 4 ;
									}
									else
									{
										a_TimestampRoute[a_TimestampCount] = 0;
									}

//									a_Timestamp[a_TimestampCount++] = * ( ( ULONG * ) ( t_OptionPtr + t_TimestampEntryOffset - 1 ) ) ;
									memcpy ( &a_Timestamp[a_TimestampCount++], t_OptionPtr + t_TimestampEntryOffset - 1, sizeof ( ULONG ) );
									t_TimestampEntryOffset += 4 ;
								}
							}

							t_OptionPtr += t_OptionLength ;
						}
						else
						{
							// INVALID_RR_OPTION

							t_Done = TRUE ;
							t_Result = WBEM_E_FAILED ;
						}
					}
					else
					{
						// INVALID_TS_OPTION

						t_Done = TRUE ;
						t_Result = WBEM_E_FAILED ;
					}
				}
				break;

				default:
				{
					if ( ( t_OptionPtr + 2 ) > t_EndPtr ) 
					{
						t_Done = TRUE ;
					}
					else
					{
						t_OptionPtr += t_OptionPtr [ 1 ] ;
					}
				}
				break;
			}
		}
	}
	catch (...)
	{
		if (a_RouteSource != NULL)
		{
			delete [] a_RouteSource;
			a_RouteSource = NULL;
		}

		if (a_TimestampRoute != NULL)
		{
			delete [] a_TimestampRoute;
			a_TimestampRoute = NULL;
		}

		if (a_Timestamp != NULL)
		{
			delete [] a_Timestamp;
			a_Timestamp = NULL;
		}

		throw;
	}

	if (FAILED(t_Result))
	{
		if (a_RouteSource != NULL)
		{
			delete [] a_RouteSource;
			a_RouteSource = NULL;
		}

		if (a_TimestampRoute != NULL)
		{
			delete [] a_TimestampRoute;
			a_TimestampRoute = NULL;
		}

		if (a_Timestamp != NULL)
		{
			delete [] a_Timestamp;
			a_Timestamp = NULL;
		}
	}

	return t_Result ;
}

HRESULT CPingTaskObject::Icmp_RequestResponse (

   LPCWSTR a_AddressString ,
   ULONG a_Address ,
   ULONG a_TimeToLive ,
   ULONG a_Timeout ,
   ULONG a_SendSize ,
   BOOL a_NoFragmentation ,
   ULONG a_TypeofService ,
   ULONG a_RecordRoute ,
   ULONG a_TimestampRoute ,
   ULONG a_SourceRouteType ,
   LPCWSTR a_SourceRoute,
   BOOL a_ResolveAddress,
   ULONG a_ResolveError
)
{
	HRESULT t_Result = S_OK ;

	CPingCallBackObject *t_Ctxt = new CPingCallBackObject(
			
											this,
											a_AddressString,
											a_Address,
											a_TimeToLive,
											a_Timeout,
											a_SendSize,
											a_NoFragmentation,
											a_TypeofService,
											a_RecordRoute,
											a_TimestampRoute,
											a_SourceRouteType,
											a_SourceRoute,
											a_ResolveAddress,
											a_ResolveError
										);
	t_Ctxt->AddRef();

	try
	{
		if (a_ResolveError == 0)
		{
			//attach t_Ctxt to thread and make the thread do a
			//t_Ctxt->SendEcho();
			BOOL t_Sent = FALSE;
			WmiStatusCode t_StatusCode = t_Ctxt->Initialize () ;

			if (t_StatusCode == e_StatusCode_Success )
			{
				t_StatusCode = CPingProvider :: s_PingThread->EnQueue (0 , *t_Ctxt) ;

				if (t_StatusCode == e_StatusCode_Success )
				{
					t_Sent = TRUE;
				}
			}
			
			if (!t_Sent)
			{
				t_Result = WBEM_E_FAILED ;
				SetErrorInfo(IDS_ICMPECHO ,
										 WBEM_E_FAILED ) ;
				try
				{
					t_Ctxt->Release();
				}
				catch(...)
				{
					t_Ctxt = NULL;
					throw;
				}
			}
		}
		else
		{
			t_Result = Icmp_IndicateResolveError(t_Ctxt);
			t_Ctxt->Disconnect();
			t_Ctxt->Release();
			t_Ctxt = NULL;

			if (SUCCEEDED(t_Result))
			{
				DecrementPingCount();
			}
		}
	}
	catch (...)
	{
		t_Ctxt->Release();
		throw;
	}

    return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\dll\pingfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: OLE MS SNMP PROPERTY PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <stdafx.h>
#include <provexpt.h>
#include <pingfac.h>

#include <Allocator.h>
#include <Thread.h>
#include <HashTable.h>

#include <pingprov.h>

LONG CPingProviderClassFactory :: s_ObjectsInProgress = 0 ;
LONG CPingProviderClassFactory :: s_LocksInProgress = 0 ;

//***************************************************************************
//
// CPingProviderClassFactory::CPingProviderClassFactory
// CPingProviderClassFactory::~CPingProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CPingProviderClassFactory :: CPingProviderClassFactory () : m_ReferenceCount(0)
{
	InterlockedIncrement ( & s_ObjectsInProgress ) ;
}

CPingProviderClassFactory::~CPingProviderClassFactory ()
{
	InterlockedDecrement ( & s_ObjectsInProgress ) ;
}

//***************************************************************************
//
// CPingProviderClassFactory::QueryInterface
// CPingProviderClassFactory::AddRef
// CPingProviderClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CPingProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
    SetStructuredExceptionHandler seh;

    try
    {
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			(*iplpv) = (IClassFactory*) this ;
		}
		else if ( iid == IID_IClassFactory )
		{
			(*iplpv) = (IClassFactory*) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
    }
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}


STDMETHODIMP_( ULONG ) CPingProviderClassFactory :: AddRef ()
{
    SetStructuredExceptionHandler seh;

    try
    {
		return InterlockedIncrement ( & m_ReferenceCount ) ;
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

STDMETHODIMP_(ULONG) CPingProviderClassFactory :: Release ()
{
    SetStructuredExceptionHandler seh;

    try
    {
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
    }
    catch(Structured_Exception e_SE)
    {
        return 0;
    }
    catch(Heap_Exception e_HE)
    {
        return 0;
    }
    catch(...)
    {
        return 0;
    }
}

//***************************************************************************
//
// CPingProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CPingProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;
    SetStructuredExceptionHandler seh;

    try
    {
		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION ;
		}
		else
		{
			IWbemServices *lpunk = ( IWbemServices * ) new CPingProvider ;

			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
				else
				{
				}
			}			
		}
    }
    catch(Structured_Exception e_SE)
    {
        status = E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        status = E_OUTOFMEMORY;
    }
    catch(...)
    {
        status = E_UNEXPECTED;
    }

	return status ;
}

//***************************************************************************
//
// CPingProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CPingProviderClassFactory :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

    SetStructuredExceptionHandler seh;

    try
    {
		if ( fLock )
		{
			InterlockedIncrement ( & s_LocksInProgress ) ;
		}
		else
		{
			InterlockedDecrement ( & s_LocksInProgress ) ;
		}

		return S_OK	;
    }
    catch(Structured_Exception e_SE)
    {
        return E_UNEXPECTED;
    }
    catch(Heap_Exception e_HE)
    {
        return E_OUTOFMEMORY;
    }
    catch(...)
    {
        return E_UNEXPECTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\dll\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

WMIPRECOMP=1

TARGETNAME=WMIPICMP
TARGETPATH=obj
TARGETTYPE=DYNLINK

USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
USE_VCCOM=1

C_DEFINES=$(C_DEFINES) /D_WINDLL /D_WIN32_DCOM

DLLENTRY=_DllMainCRTStartup
DLLDEF=$(O)\IcmpEcho.def

LINKLIBS= \
	$(FRAMEWORK_MFC_LIB)

TARGETLIBS=\
	$(SDK_LIB_PATH)\advapi32.lib \
	$(NET_LIB_PATH)\icmp.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\rpcutil.lib \
	$(SDK_LIB_PATH)\wbemuuid.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\wsock32.lib \
	$(UTILLIB_LIB) \
	$(WMIIDL_LIB) \
	$(STDLIBRARY_LIB) \
	$(CIMWIN32_LIB) \
 	$(FRAMEWORK_THRD_LIB) \
	$(FRAMEWORK_EXPT_LIB) \
	$(CONTAINER_LIB) \


INCLUDES=\
	$(INCLUDES); \
	..\..\inc ; \
	.. ; \
	$(CONTAINER_INC); \
	$(CONTAINER_SRC); \
	$(FRAMEWORK_EXPT_INC); \
 	$(FRAMEWORK_THRD_INC); \
	$(FRAMEWORK_MFC_INC); \
	$(UTILLIB_INC); \
	$(STDLIBRARY_INC); \
	$(WMIIDL_INC); \
	$(CIMWIN32_LIB_INC); \
	$(NET_INC_PATH); \
        $(WBEMCOMN_INC)



SOURCES=\
	IcmpEcho.rc  \
	MainDll.cpp \
	pingfac.cpp \
	pingprov.cpp \
	pingtask.cpp \
	pingget.cpp \
	pingquery.cpp \
	pingcallback.cpp \
	globals.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\inc\pingfac.h ===
// (C) 1999 Microsoft Corporation 

#ifndef _PingProvClassFactory_H
#define _PingProvClassFactory_H

class CPingProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;


    CPingProviderClassFactory () ;
    ~CPingProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

#endif // _PingProvClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\dll\stdafx.h ===
// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntobapi.h>
#include <ntstatus.h>
}

#include <objbase.h>
#include <initguid.h>
#include <fwcommon.h>
#include <cominit.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\dll\res_str.h ===
/******************************************************************

   CPingProvider.CPP -- WMI provider class implementation



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
  
   
******************************************************************/


#define IDS_CALLBACK_PREMATURE          1
#define IDS_IMPERSONATE_RECEIVE         2
#define IDS_ICMPCREATEFILE_FAIL         3
#define IDS_RR_MAX                      4
#define IDS_RR_MAX_INDEX                5
#define IDS_TS_MAX                      6
#define IDS_TS_MAX_INDEX                7
#define IDS_SR_MAX                      8
#define IDS_SR_MAX_INDEX                9
#define IDS_SR_PARSE                    10
#define IDS_ICMPSENDECHO2               11
#define IDS_IMPERSONATE_SEND            12
#define IDS_DUP_THRDTOKEN               13
#define IDS_ICMPECHO                    14
#define IDS_CLASS_DEFN                  15
#define IDS_INVALID_CLASS               16
#define IDS_OBJ_PATH                    17
#define IDS_OBJ_PATH_KEYS               18
#define IDS_OBJ_PATH_DUP_KEYS           19
#define IDS_OBJ_PATH_ADDR               20
#define IDS_ADDR_TYPE                   21
#define IDS_TO_TYPE                     22
#define IDS_TTL_TYPE                    23
#define IDS_BUFF_TYPE                   24
#define IDS_NOFRAG_TYPE                 25
#define IDS_TOS_TYPE                    26
#define IDS_RR_TYPE                     27
#define IDS_TS_TYPE                     28
#define IDS_SRT_TYPE                    29
#define IDS_SR_TYPE                     30
#define IDS_RA_TYPE                     31
#define IDS_UNK_PROP                    32
#define IDS_UNK_KEY                     33
#define IDS_NO_KEYS                     34
#define IDS_DECODE_GET                  35
#define IDS_QUERY_ADDR                  36
#define IDS_QUERY_ADDR_INVALID          37
#define IDS_QUERY_TO                    38
#define IDS_QUERY_TTL                   39
#define IDS_QUERY_BUF                   40
#define IDS_QUERY_NOFRAG                41
#define IDS_QUERY_TOS                   42
#define IDS_QUERY_RR                    43
#define IDS_QUERY_TS                    44
#define IDS_QUERY_SRT                   45
#define IDS_QUERY_SR                    46
#define IDS_QUERY_RA                    47
#define IDS_QUERY_BROAD                 48
#define IDS_QUERY_NARROW                49
#define IDS_QUERY_UNUSABLE              50
#define IDS_QUERY_ANALYZE               51
#define IDS_QUERY_PARSE                 52
#define IDS_DECODE_QUERY                53
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\inc\pingprov.h ===
/******************************************************************

   CPingProvider.H -- WMI provider class definition

 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _CPingProvider_H_
#define _CPingProvider_H_

#define PROVIDER_NAME_CPINGPROVIDER L"Win32_PingStatus"

// Property name externs -- defined in CPingProvider.cpp
//=================================================

#define MAX_BUFFER_SIZE       (sizeof(ICMP_ECHO_REPLY) + 0xfff7 + MAX_OPT_SIZE)
#define DEFAULT_BUFFER_SIZE         (0x2000 - 8)
#define DEFAULT_SEND_SIZE           32
#define DEFAULT_COUNT               4
#define DEFAULT_TTL                 128
#define DEFAULT_TOS                 0
#define DEFAULT_TIMEOUT             1000L
#define MIN_INTERVAL                1000L

#define WBEM_CLASS_EXTENDEDSTATUS			L"__ExtendedStatus"
#define WBEM_PROPERTY_STATUSCODE			L"StatusCode"
#define WBEM_PROPERTY_PROVSTATUSMESSAGE		L"Description"

#define PING_KEY_PROPERTY_COUNT		11


_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

class CCritSecAutoUnlock
{
private:

	CRITICAL_SECTION *m_CritSec;
	BOOL m_bLocked;

public:

	CCritSecAutoUnlock(CRITICAL_SECTION *a_CritSec) : m_CritSec(NULL), m_bLocked(FALSE)
	{
		EnterCriticalSection(a_CritSec);
		m_CritSec = a_CritSec;
		m_bLocked = TRUE;
	}

	~CCritSecAutoUnlock()
	{
		LeaveEarly();
	}

	void LeaveEarly()
	{
		if ((m_bLocked) && (m_CritSec != NULL))
		{
			LeaveCriticalSection(m_CritSec);
			m_CritSec = NULL;
			m_bLocked = FALSE;
		}
	}

};

class CKeyEntry
{
public:

	LPCWSTR m_key ;
	
public:

	CKeyEntry ( CKeyEntry & a_key )
	{
		m_key = a_key.Get();
	}

	CKeyEntry ( LPCWSTR a_key )
	{
		m_key = a_key;
	}

	CKeyEntry (void)
	{
		m_key = NULL;
	}

	~CKeyEntry ()
	{
		m_key = NULL ;
	}

	LPCWSTR Get ( ) const
	{
		return m_key ;
	}

	void *operator new ( size_t a_Size , CKeyEntry *a_key )
	{
		return a_key ;
	}

	void operator delete ( void *a_Ptr , CKeyEntry *a_key )
	{
	}

} ;

extern LONG CompareElement ( const CKeyEntry &a_Arg1 , const CKeyEntry & a_Arg2 );
extern BOOL operator== ( const CKeyEntry &a_Arg1 , const CKeyEntry &a_Arg2 );
extern BOOL operator< ( const CKeyEntry &a_Arg1 , const CKeyEntry &a_Arg2 );
extern ULONG Hash ( const CKeyEntry & a_Arg );

class CPingThread : public WmiThread < ULONG > 
{
private:

	WmiAllocator &m_Allocator ;
	BOOL m_Init;

protected:

public:	/* Internal */

    CPingThread (WmiAllocator & a_Allocator) ;

    ~CPingThread () ;

	WmiStatusCode Initialize_Callback () ;

	WmiStatusCode UnInitialize_Callback () ;
};

class CPingProvider : public IWbemServices, public IWbemProviderInit
{
private:
	LONG m_referenceCount ;         //Object reference count
	IWbemClassObject *m_notificationClassObject ;
	IWbemClassObject *m_ClassObject ;
	IWbemServices *m_server ;
	BOOL m_bInitial ;

protected:

	BOOL CreateNotificationObject ( IWbemContext *a_Ctx ) ;
	BOOL ImpersonateClient();

public:

	static CRITICAL_SECTION s_CS;
	static CPingThread *s_PingThread ;
	static WmiAllocator *s_Allocator ;
	static WmiHashTable <CKeyEntry, ULONG, 12> *s_HashTable; // one more bucket than we have keys.

	static HRESULT Global_Startup();
	static HRESULT Global_Shutdown();
	static LPCWSTR s_KeyTable[PING_KEY_PROPERTY_COUNT];

        // Constructor/destructor
        //=======================

        CPingProvider ();
        ~CPingProvider () ;

		BOOL GetClassObject ( IWbemClassObject **a_ppClass ) ;
		BOOL GetNotificationObject ( IWbemContext *a_Ctx , IWbemClassObject **a_ppObj );


	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize(

			/* [in] */ LPWSTR pszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR pszNamespace,
			/* [in] */ LPWSTR pszLocale,
			/* [in] */ IWbemServices *pCIMOM,         // For anybody
			/* [in] */ IWbemContext *pCtx,
			/* [in] */ IWbemProviderInitSink *pInitSink     // For init signals
			);        

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\ping\inc\pingtask.h ===
/******************************************************************



   PingTask.H -- Task object definitions



 Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved


   Description: 
   

*******************************************************************/

#ifndef _CPingTask_H_
#define _CPingTask_H_

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#define PING_MAX_IPS ( MAX_OPT_SIZE / 4 /*sizeof(ULONG)*/ )

extern const WCHAR *Ping_Address;
extern const WCHAR *Ping_Timeout;
extern const WCHAR *Ping_TimeToLive;
extern const WCHAR *Ping_BufferSize;
extern const WCHAR *Ping_NoFragmentation;
extern const WCHAR *Ping_TypeofService;
extern const WCHAR *Ping_RecordRoute;
extern const WCHAR *Ping_TimestampRoute;
extern const WCHAR *Ping_SourceRouteType;
extern const WCHAR *Ping_SourceRoute;
extern const WCHAR *Ping_ResolveAddressNames;

#define PING_ADDRESS_INDEX				0
#define PING_TIMEOUT_INDEX				1
#define PING_TIMETOLIVE_INDEX			2
#define PING_BUFFERSIZE_INDEX			3
#define PING_NOFRAGMENTATION_INDEX		4
#define PING_TYPEOFSERVICE_INDEX		5
#define PING_RECORDROUTE_INDEX			6
#define PING_TIMESTAMPROUTE_INDEX		7
#define PING_SOURCEROUTETYPE_INDEX		8
#define PING_SOURCEROUTE_INDEX			9
#define PING_RESOLVEADDRESSNAMES_INDEX	10

class CPingTaskObject;

class CPingCallBackObject : public WmiTask < ULONG > 
{
private:
	
	CPingTaskObject *m_ParentTask;
	UCHAR *m_ReplyBuffer;
	UCHAR *m_SendBuffer;
	ULONG m_Address;
	ULONG m_TimeToLive;
	ULONG m_Timeout;
	ULONG m_SendSize;
	ULONG m_ReplySize;
	BOOL m_NoFragmentation;
	ULONG m_TypeofService;
	ULONG m_RecordRoute;
	ULONG m_TimestampRoute;
	ULONG m_SourceRouteType;
	CStringW m_AddressString;
	CStringW m_SourceRoute;
	ULONG m_SourceRouteArray[PING_MAX_IPS];
	ULONG m_SourceRouteCount;
	BOOL m_ResolveAddress;
	HANDLE m_IcmpHandle;
	ULONG m_ResolveError;

	BOOL ParseSourceRoute();
	void SendError(DWORD a_ErrMsgID, HRESULT a_HRes);
	BOOL GetIcmpHandle();

public:

	//Simple access methods
	UCHAR* GetReplyBuffer() { return m_ReplyBuffer ; }
	UCHAR* GetSendBuffer() { return m_SendBuffer ; }
	ULONG GetAddress() { return m_Address ; }
	LPCWSTR GetAddressString() { return m_AddressString ; }
	ULONG GetTimeToLive() { return m_TimeToLive ; }
	ULONG GetTimeout() { return m_Timeout ; }
	ULONG GetSendSize() { return m_SendSize ; }
	ULONG GetReplySize() { return m_ReplySize ; }
	BOOL GetNoFragmentation() { return m_NoFragmentation ; }
	ULONG GetTypeofService() { return m_TimeToLive ; }
	ULONG GetRecordRoute() { return m_RecordRoute ; }
	ULONG GetTimestampRoute() { return m_TimestampRoute ; }
	ULONG GetSourceRouteType() { return m_SourceRouteType ; }
	LPCWSTR GetSourceRoute() { return m_SourceRoute ; }
	ULONG* GetSourceRouteArray() { return m_SourceRouteArray ; }
	ULONG GetSourceRouteCount() { return m_SourceRouteCount ; }
	BOOL GetResolveAddress() { return m_ResolveAddress ; }
	ULONG GetResolveError() { return m_ResolveError ; }
	

	//Async call routines
	void HandleResponse();
	void SendEcho();

	CPingCallBackObject(
		CPingTaskObject *a_ParentTask,
		LPCWSTR a_AddressString,
		ULONG a_Address,
		ULONG a_TimeToLive,
		ULONG a_Timeout,
		ULONG a_SendSize,
		BOOL a_NoFragmentation,
		ULONG a_TypeofService,
		ULONG a_RecordRoute,
		ULONG a_TimestampRoute,
		ULONG a_SourceRouteType,
		LPCWSTR a_SourceRoute,
		BOOL a_ResolveAddress,
		ULONG a_ResolveError
	);

	WmiStatusCode Process ( WmiThread <ULONG> &a_Thread ) ;
	void Disconnect() { m_ParentTask = NULL ; }

	~CPingCallBackObject();

};

class CPingTaskObject
{
private:

protected:

	class CPingErrorObject
	{
	private:
		LPWSTR	m_Description;
		HRESULT m_Status;

	public:
			CPingErrorObject(): m_Description(NULL), m_Status (S_OK) {}

		void	SetInfo(LPCWSTR a_description, HRESULT a_status);
		HRESULT	GetStatus() const { return m_Status; }
		LPCWSTR	GetDescription() const { return m_Description; }

			~CPingErrorObject();
	};

	CPingErrorObject m_ErrorObject ;
	IWbemObjectSink *m_NotificationHandler ;
	IWbemContext *m_Ctx ;
	CPingProvider *m_Provider ;
	HANDLE m_ThreadToken ;
	CRITICAL_SECTION m_CS;
	LONG m_PingCount;

	void SetErrorInfo(DWORD a_ErrMsgID, HRESULT a_HRes, BOOL a_Force = FALSE);
	HRESULT Icmp_DecodeAndIndicate (CPingCallBackObject *a_Reply);
	HRESULT Icmp_IndicateResolveError (CPingCallBackObject *a_Reply);
	void IPAddressToString(_variant_t &a_var, ULONG a_Val, BOOL a_Resolve);
	void DecrementPingCount();
	
	HRESULT SetInstanceKeys(IWbemClassObject *a_Inst , CPingCallBackObject *a_Reply);

	HRESULT SetStringProperty(

		IWbemClassObject *a_Inst,
		LPCWSTR a_name,
		LPCWSTR a_val
	) ;

	HRESULT SetBOOLProperty(

		IWbemClassObject *a_Inst,
		LPCWSTR a_name,
		BOOL a_val
	) ;

	HRESULT SetUint32Property(

		IWbemClassObject *a_Inst,
		LPCWSTR a_name,
		ULONG a_val
	) ;

	HRESULT SetUint32ArrayProperty(
												
		IWbemClassObject *a_Inst ,
		LPCWSTR a_Name ,
		ULONG* a_Vals ,
		ULONG a_Count
	) ;

	HRESULT SetIPProperty(

		IWbemClassObject *a_Inst ,
		LPCWSTR a_Name ,
		ULONG a_Val ,
		BOOL a_Resolve
	) ;

	HRESULT SetIPArrayProperty(
												
		IWbemClassObject *a_Inst ,
		LPCWSTR a_Name ,
		ULONG* a_Vals ,
		ULONG a_Count ,
		BOOL a_Resolve
	) ;

	HRESULT Icmp_DecodeResponse (

		PICMP_ECHO_REPLY a_Reply ,
		ULONG &a_RouteSourceCount ,
		ULONG *&a_RouteSource ,
		ULONG &a_TimestampCount ,
		ULONG *&a_TimestampRoute ,
		ULONG *&a_Timestamp
	) ;

	HRESULT Icmp_RequestResponse ( 

		LPCWSTR a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeToLive ,
		ULONG a_Timeout ,
		ULONG a_SendSize ,
		BOOL a_NoFragmentation ,
		ULONG a_TypeofService ,
		ULONG a_RecordRoute ,
		ULONG a_TimestampRoute ,
		ULONG a_SourceRouteType ,
		LPCWSTR a_SourceRoute,
		BOOL a_ResolveAddress,
		ULONG a_ResolveError
	) ;

	BOOL GetClassObject ( IWbemClassObject **a_ppClass ) ;
	BOOL SetProperties(CPingCallBackObject *a_Response) ;
	BOOL GetStatusObject ( IWbemClassObject **a_NotifyObject ) ;

public:

	CPingTaskObject (

		CPingProvider *a_Provider ,
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *a_Ctx
	) ;

	virtual void HandleResponse (CPingCallBackObject *a_reply) = 0 ;
	virtual void HandleErrorResponse (DWORD a_ErrMsgID, HRESULT a_HRes) = 0 ;
	BOOL GetThreadToken();
	BOOL SetThreadToken(BOOL a_Reset);
	static HRESULT Icmp_ResolveAddress ( LPCWSTR a_Path , ULONG &a_IpAddress , DWORD *a_pdwErr = NULL ) ;
	virtual ~CPingTaskObject () ;
} ;

class CPingGetAsync : public CPingTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;

protected:

		HRESULT GetDefaultTTL ( DWORD &a_TimeToLive ) ;

public:

	~CPingGetAsync () ;
	CPingGetAsync (

		CPingProvider *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;
	
	BOOL GetObject () ;
	BOOL PerformGet () ;
	void HandleResponse (CPingCallBackObject *a_reply) ;
	void HandleErrorResponse (DWORD a_ErrMsgID, HRESULT a_HRes) ;
} ;


class CPingQueryAsync : public CPingTaskObject, public QueryPreprocessor
{
private:

	wchar_t *m_QueryFormat ; 
	wchar_t *m_Query ;

	QueryPreprocessor :: QuadState Compare ( 

		wchar_t *a_Operand1 , 
		wchar_t *a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState Compare ( 

		LONG a_Operand1 , 
		LONG a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState CompareString ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

	QueryPreprocessor :: QuadState CompareInteger ( 

		IWbemClassObject *a_ClassObject ,
		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

	HRESULT RecurseAddress (

		void *pMethodContext, 
		PartitionSet *a_PartitionSet
	) ;

	HRESULT RecurseTimeOut (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseTimeToLive (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseBufferSize (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive ,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseNoFragmentation (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseTypeOfService (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseRecordRoute (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		ULONG a_TypeOfService,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseTimestampRoute (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		ULONG a_TypeOfService,
		ULONG a_RecordRoute,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseSourceRouteType (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		ULONG a_TypeOfService,
		ULONG a_RecordRoute,
		ULONG a_TimestampRoute,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseSourceRoute (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		ULONG a_TypeOfService,
		ULONG a_RecordRoute,
		ULONG a_TimestampRoute,
		ULONG a_SourceRouteType,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	) ;

	HRESULT RecurseResolveAddressNames (

		void *pMethodContext, 
		wchar_t *a_AddressString ,
		ULONG a_Address ,
		ULONG a_TimeOut ,
		ULONG a_TimeToLive,
		ULONG a_SendSize,
		BOOL a_NoFragmentation ,
		ULONG a_TypeOfService,
		ULONG a_RecordRoute,
		ULONG a_TimestampRoute,
		ULONG a_SourceRouteType,
		LPCWSTR a_SourceRoute,
		PartitionSet *a_PartitionSet ,
		ULONG a_ResolveError
	);

protected:

        // Reading Functions
        //============================

		WmiTreeNode *AllocTypeNode ( 

			void *a_Context ,
			BSTR a_PropertyName , 
			VARIANT &a_Variant , 
			WmiValueNode :: WmiValueFunction a_PropertyFunction ,
			WmiValueNode :: WmiValueFunction a_ConstantFunction ,
			WmiTreeNode *a_Parent 
		) ;

		QuadState InvariantEvaluate ( 

			void *a_Context ,
			WmiTreeNode *a_Operator ,
			WmiTreeNode *a_Operand 
		) ;

		WmiRangeNode *AllocInfiniteRangeNode (

			void *a_Context ,
			BSTR a_PropertyName 
		) ;

		virtual DWORD GetPriority ( BSTR a_PropertyName ) ;

public:

	CPingQueryAsync ( 

		CPingProvider *a_Provider , 
		BSTR a_QueryFormat , 
		BSTR a_Query , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~CPingQueryAsync () ;

	BOOL ExecQuery () ;
	void HandleResponse (CPingCallBackObject *a_reply) ;
	void HandleErrorResponse (DWORD a_ErrMsgID, HRESULT a_HRes) ;
} ;

#endif //_CPingTask_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\smbios\smbdpmi\smbdpmi.c ===
// Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.

#pragma warning (disable:4001)	// I want to use single line comments

//==============================================================================
//	smbdpmi.c


#pragma warning (disable:4102)	// I want to use unreferenced labels for readablity in _asm sections

#include <dos.h>


// some standard typedefs and defines

#ifndef BOOL
typedef unsigned int BOOL;
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

#ifndef USHORT
typedef unsigned short USHORT;
#endif

#ifndef ULONG
typedef unsigned long ULONG;
#endif

#ifndef TRUE
#define TRUE	1
#endif

#ifndef FALSE
#define FALSE	0
#endif

#define VMAJOR	0
#define VMINOR	80

#define DATFILE	"SMBIOS.DAT"
#define VERFILE	"SMBIOS.EPS"

// structure to hold memory allocation info
typedef struct tagMEMSTRUCT
{
	ULONG	Size;
	ULONG	BaseAddress;
	ULONG	Handle;
	USHORT	Segment;

} MEMSTRUCT;

// The EPS structures are defined here
#pragma pack(1)

// Entry point structure for DPMI services
typedef struct tagDPMI_EPS
{
	USHORT	PMEntry_Segment;
	USHORT	PMEntry_Offset;
	BYTE	Proc_Type;
	BYTE	vmajor;
	BYTE	vminor;
	USHORT	Paragraphs;

} DPMI_EPS;

// Entry point structure for SMBIOS
typedef struct tagSMB_EPS
{
	char	anchor[4];	
	BYTE	checksum;
	BYTE	length;
	BYTE	version_major;
	BYTE	version_minor;
	USHORT	max_struct_size;
	BYTE	revision;
	BYTE	formatted[5];
	char	ianchor[5];
	BYTE	ieps_checksum;
	USHORT	table_length;
	ULONG	table_addr;
	USHORT	struct_count;
	BYTE	bcd_revision;

} SMB_EPS;

// Entry point structure for DMIBIOS
typedef struct tagDMI_EPS
{
	char	anchor[5];
	BYTE	checksum;
	USHORT	table_length;
	ULONG	table_addr;
	USHORT	struct_count;
	BYTE	bcd_revision;

} DMI_EPS;


// combined SMBIOS / DMIBIOS entry point structure
typedef union tagANY_EPS
{
	DMI_EPS	dmi;
	SMB_EPS	sm;

} ANY_EPS;


// PnP BIOS entry point structure
typedef struct tagPNP_EPS
{
	char	Signature[4];
	BYTE	Version;
	BYTE	Length;
	USHORT	Control_field;
	BYTE	Checksum;
	ULONG	Event_notify_flag_addr;
	USHORT	RM_16bit_entry_off;
	USHORT	RM_16bit_entry_seg;
	USHORT	PM_16bit_entry_off;
	ULONG	PM_16bit_entry_seg;
	ULONG	OEM_Device_Id;
	USHORT	RM_16bit_data_seg;
	ULONG	PM_16bit_data_seg;

} PNP_EPS;

// SMBIOS structure header
typedef struct _tagSHF
{
	BYTE	Type;
	BYTE	Length;
	USHORT	Handle;

} SHF;


#pragma pack()

typedef void (far *VOIDFUNC)( void );

// yanked these from the DMI BIOS spec

// typedef for calling PnP function 50h
typedef short (far *PNPFUNC50)(
  short Function,	/* PnP BIOS Function 50h */
  unsigned char far *dmiBIOSRevision,	/* Revision of the SMBIOS Extensions */
  unsigned short far *NumStructures,	/* Max. Number of Structures the BIOS will return */
  unsigned short far *StructureSize,	/* Size of largest SMBIOS Structure */
  unsigned long far *dmiStorageBase,	/* 32-bit physical base address for memory-mapped */
 	/*  SMBIOS data */
  unsigned short far *dmiStorageSize,	/* Size of the memory-mapped SMBIOS data */
  unsigned short BiosSelector );	/* PnP BIOS readable/writable selector */

// typedef for calling PnP function 50h
typedef short (far *PNPFUNC51)(
  short Function,	/* PnP BIOS Function 51h */
  unsigned short far *Structure,	/* Structure number/handle to retrieve*/
  unsigned char far *dmiStrucBuffer,	/* Pointer to buffer to copy structure data to */
  unsigned short dmiSelector,	/* SMBIOS data read/write selector */
  unsigned short BiosSelector );	/* PnP BIOS readable/writable selector */


// SMBIOS functions
#define GET_DMI_INFORMATION				0x50
#define GET_DMI_STRUCTURE				0x51
#define SET_DMI_STRUCTURE				0x52 
#define GET_DMI_STRUCTURE_CHANGE_INFO 	0x53
#define DMI_CONTROL						0x54
#define GET_GPNV_INFORMATION			0x55
#define READ_GPNV_DATA					0x56
#define WRITE_GPNV_DATA					0x57


// SMBIOS function return codes
#define DMI_SUCCESS					0x00
#define DMI_UNKNOWN_FUNCTION		0x81
#define DMI_FUNCTION_NOT_SUPPORTED	0x82
#define DMI_INVALID_HANDLE			0x83
#define DMI_BAD_PARAMETER			0x84
#define DMI_INVALID_SUBFUNCTION		0x85
#define DMI_NO_CHANGE				0x86
#define DMI_ADD_STRUCTURE_FAILED	0x87
#define DMI_READ_ONLY				0x8D
#define DMI_LOCK_NOT_SUPPORTED		0x90
#define DMI_CURRENTLY_LOCKED		0x91
#define DMI_INVALID_LOCK			0x92

// anchor types
#define ANCHOR_NONE		0
#define ANCHOR_SELECT	1
#define ANCHOR_DMI		2
#define ANCHOR_SM		4
#define ANCHOR_PNP		8

// prototypes for support functions
void far *GetSMB_EPS( unsigned int anchor );
void far *GetPnP_EPS( void );
BOOL StartPM( void );
void End_PM( BYTE error );
USHORT MakeSelector( ULONG lin_addr, USHORT limit );
BOOL FreeSelector( USHORT  selector );
void RawDump( BYTE far *data, USHORT length );
USHORT GetDataPathname( char *pathname, char far *envdata );
USHORT WriteFileData( char far *filepath, BYTE far *datablock, USHORT datasize );

BOOL PM_DataAlloc( MEMSTRUCT *ms );
BOOL PM_DataFree( MEMSTRUCT *ms );
BOOL DOS_DataAlloc( MEMSTRUCT *ms );

BOOL GetByTableMethod( ANY_EPS far *dmi );
BOOL GetByStructMethod( PNP_EPS far *pnp );

USHORT GetStructureLength( SHF far *pshf );
USHORT RunChecksum( BYTE far *bptr, USHORT length );

void far *CVSEG( void far *realptr );
BOOL MakeFilePath( char far *FilePath, char far *DirPath, char far *FileName );

void OutMsgRaw( char far *msg );
void OutMsgSX( char far *msg, USHORT val );
void OutMsgLX( char far *msg, ULONG lval );
void OutMsgFP( char far *msg, void far *vptr );
void OutMsgSD( char far *msg, USHORT dval );
void OutMsgBX( char far *msg, BYTE bval );
void OutMsgSS( char far *msg, char far *strg );
void OutMsgVD( char far *msg, USHORT ver1, USHORT ver2 );

USHORT OpenFile( char far *filepath );
USHORT WriteFile( USHORT handle, BYTE far *datablock, USHORT datasize );
void CloseFile( USHORT handle );


BOOL verbose = FALSE;
char DirPath[265] = "";
char FilePath[265] = "";
char helptext0[] = "Command options:\r\n\t/a\tLook for a specific EPS - use SM, DMI, or PnP (i.e. /a SM)\r\n";
char helptext1[] = "\t\t/v\tVerbose  - Gives noise about what's happening\r\n";
char helptext2[] = "\t/d\tRaw Dump - Display SM BIOS data only, no file write\r\n";

// skip the pitfalls of dynamic allocation and use an static buffer
BYTE dbuff[4096];


USHORT near mainp( char far *args, char far *envdata )
{
	ANY_EPS far *dmi;
	PNP_EPS far *pnp;
	BOOL dodump, PMode, result, help;
	USHORT anchor;

	verbose = FALSE;
	PMode   = FALSE;
	dodump  = FALSE;
	help    = FALSE;
	result  = FALSE;
	anchor  = ANCHOR_DMI | ANCHOR_SM | ANCHOR_PNP;

 	GetDataPathname( DirPath, envdata );

	// check for command line options

	while ( *args++ != 0x0d )
	{
		if  ( args[0] == '-' || args[0] == '/' )
		{
			switch ( args[1] )
			{
				case 'v':
				case 'V':
					verbose = TRUE;
					break;

				case 'd':
				case 'D':
					dodump = TRUE;
					break;

				case 'a':
				case 'A':
					anchor = ANCHOR_SELECT;
					break;

				case '?':
				case 'h':
				case 'H':
					help = TRUE;
					break;

				default:
					break;
			}
		}
		else if ( anchor == ANCHOR_SELECT )
		{
			if ( args[0] == 'D' && args[1] == 'M' && args[2] == 'I' )
			{
				anchor = ANCHOR_DMI;
			}
			else if ( args[0] == 'S' && args[1] == 'M' )
			{
				anchor = ANCHOR_SM;
			}
			else if ( args[0] == 'P' && args[1] == 'n' && args[2] == 'P' )
			{
				anchor = ANCHOR_PNP;
			}
			else
			{
				anchor = ANCHOR_DMI | ANCHOR_SM | ANCHOR_PNP;
			}
		}
		while ( *args != 0x20 && *args != 0x0d )
		{
			args++;
		}
	}

	if ( help || verbose )
	{
		OutMsgVD( "Microsoft (R) SMBIOS Data Locator  Version ", VMAJOR, VMINOR );
		OutMsgRaw( "Copyright (c) 1995-2001 Microsoft Corporation.  All rights reserved.\r\n\n" );
		if ( help )
		{
			OutMsgRaw( helptext0 );
			OutMsgRaw( helptext1 );
			OutMsgRaw( helptext2 );
			return 0;
		}
	}

	dmi = (void far *) 0;
	pnp = (void far *) 0;

	if ( anchor == ANCHOR_SELECT )
	{
		anchor = ANCHOR_DMI | ANCHOR_SM | ANCHOR_PNP;
	}
	if ( anchor & ( ANCHOR_SM | ANCHOR_DMI ) )
	{
		dmi = GetSMB_EPS( anchor );
		if ( dmi )
		{
			anchor &= ~ANCHOR_PNP;
		}
	}
	if ( anchor & ANCHOR_PNP )
	{
		pnp = GetPnP_EPS( );
	}

	if ( dmi || pnp )
	{
		if ( dmi )
		{
			if ( StartPM( ) == 0 )
			{
				PMode = TRUE;
				// change the segment of the dmi structure into a standard selector
				_asm
				{
					mov ax, 0002h
					mov bx, word ptr dmi + 2
					int 31h
					mov word ptr dmi + 2, ax
				}
				result = GetByTableMethod( dmi );
			}
			else
			{
				result = 0;
			}
		}
		else if ( pnp )
		{
			result = GetByStructMethod( pnp );
		}
	}
	else if ( verbose )
	{
		OutMsgRaw( "\n  SMBIOS NOT Found!!!\r\n" );
	}

	if ( result )
	{
		if ( dodump )
		{
			if ( verbose )
			{
				OutMsgRaw( "_________________________________________\r\n\n" );
				OutMsgRaw( "Dumping SMBIOS Data...\r\n" );
				OutMsgRaw( "_________________________________________\r\n\n" );
			}
			//RawDump( table_data, (USHORT) ms.Size );
		}
		else
		{
			USHORT eps_length;

			if ( dmi )
			{
				eps_length = *( (char far *) dmi + 1 ) == 'D' ? (USHORT) sizeof( DMI_EPS ) : dmi->sm.length;

				MakeFilePath( FilePath, DirPath, VERFILE );
				if ( verbose )
				{
					OutMsgSS( "  Writing EPS data file at:\r\n    ", FilePath );
					OutMsgRaw( "\n" );
				}
				WriteFileData( (char far *) FilePath, (void far *) dmi, (USHORT) eps_length );
			}
		}
	}
	else if ( !dodump )	// write a dummy file if there's a failure
	{
		ULONG scratch = 0;

		MakeFilePath( FilePath, DirPath, DATFILE );
		if ( verbose )
		{
			OutMsgSS( "  Writing stub data file at:\r\n    ", FilePath );
		}
		WriteFileData( (char far *) FilePath, (BYTE far *) &scratch, sizeof( ULONG ) );
	}	

	return 0;
}


// Find the SMBIOS Entry Point Structure
void far *GetSMB_EPS( unsigned int anchor )
{
	ANY_EPS far *eps;
	ULONG offset;
	BOOL found, dmi;
	USHORT i;

	// According to Fabrizio, some EPS's are also located in segment E000 so we have
	// to check another 64k
	USHORT SegArray[] = { 0xe000, 0xf000 };

	found   = FALSE;

	if ( verbose )
	{
		OutMsgRaw( "_________________________________________\r\n\n" );
		OutMsgRaw( "Looking for SMBIOS EPS...\r\n" );
		OutMsgRaw( "_________________________________________\r\n\n" );
	}

	for ( i = 0; !found && ( i < sizeof( SegArray ) / sizeof( USHORT ) ); i++ )
	{
		if ( verbose )
		{
			OutMsgSX( "  Scanning Segment:\t\t", SegArray[i] );
			//OutMsgRaw( "\r\n" );
		}
		offset  = 0;
		while ( offset < 0x10000 )
		{
			eps = (ANY_EPS far *) _MK_FP( SegArray[i], (USHORT) offset );

			if ( anchor & ANCHOR_SM &&
				eps->sm.anchor[0] == '_' && eps->sm.anchor[1] == 'S' &&
				eps->sm.anchor[2] == 'M' && eps->sm.anchor[3] == '_' &&
				eps->sm.length >= sizeof( SMB_EPS ) &&
				eps->sm.ianchor[0] == '_' && eps->sm.ianchor[1] == 'D' &&
				eps->sm.ianchor[2] == 'M' && eps->sm.ianchor[3] == 'I' &&
				eps->sm.ianchor[4] == '_' )
			{
				if ( RunChecksum( (BYTE far *) eps, eps->sm.length ) == 0 )
				{
					found = TRUE;
					dmi = FALSE;
					break;
				}
			}
			else if ( anchor & ANCHOR_DMI &&
				eps->dmi.anchor[0] == '_' && eps->dmi.anchor[1] == 'D' &&
				eps->dmi.anchor[2] == 'M' && eps->dmi.anchor[3] == 'I' &&
				eps->dmi.anchor[4] == '_' )
			{
				if ( RunChecksum( (BYTE far *) eps, sizeof( DMI_EPS ) ) == 0 )
				{
					found = TRUE;
					dmi = TRUE;
					break;
				}
			}
			offset += 0x10;
	  	}
	}

	if ( found && verbose )
	{
		OutMsgRaw( "_________________________________________\r\n\n" );
		OutMsgRaw( "SMBIOS Found...\r\n" );
		OutMsgRaw( "_________________________________________\r\n\n" );
		OutMsgSS( "  Anchor:\t\t\t", dmi ? "\"_DMI_\"" : "\"_SM_\"" );
		OutMsgFP( "  EPS Found at:\t\t\t", eps );
		OutMsgBX( "  EPS checksum:\t\t\t", (BYTE) ( dmi ? eps->dmi.checksum : eps->sm.checksum ) );
		OutMsgVD( "  Version:\t\t\t", dmi ? (USHORT) ( eps->dmi.bcd_revision >> 4 ) : (USHORT) ( eps->sm.bcd_revision >> 4 ),
										dmi ? (USHORT) ( eps->dmi.bcd_revision & 0x0f ) :(USHORT) ( eps->sm.bcd_revision & 0x0f ) );
		OutMsgSD( "  Structure Count:\t\t", (USHORT) ( dmi ? eps->dmi.struct_count : eps->sm.struct_count ) );
		OutMsgLX( "  Table 32-bit Address:\t\t", dmi ? eps->dmi.table_addr : eps->sm.table_addr );
		OutMsgSD( "  Table Length:\t\t\t", dmi ? eps->dmi.table_length : eps->sm.table_length );
	}

	return found ? (void far *) eps : (void far *) 0;
}


// Find the PnP Entry Point Structure
void far *GetPnP_EPS( void )
{
	PNP_EPS far *pnp;
	ULONG offset;
	BOOL found;

	offset  = 0;
	found   = FALSE;

	if ( verbose )
	{
		OutMsgRaw( "_________________________________________\r\n\n" );
		OutMsgRaw( "Looking for PnP BIOS EPS...\r\n" );
		OutMsgRaw( "_________________________________________\r\n\n" );
		OutMsgRaw( "  Scanning Segment:\t\tf000\r\n" );
	}
	while ( offset < 0x10000 )
	{
		pnp = (PNP_EPS far *) _MK_FP( 0xf000, (USHORT) offset );

		if ( pnp->Signature[0] == '$' && pnp->Signature[1] == 'P' &&
			pnp->Signature[2] == 'n' && pnp->Signature[3] == 'P' &&
			pnp->Length >= sizeof( PNP_EPS ) )
		{
			if ( RunChecksum( (BYTE far *) pnp, pnp->Length ) == 0 )
			{
				found = TRUE;
				break;
			}
		}
		offset += 0x10;		// increment to next paragraph
	}
			
	if ( found && verbose )
	{
		OutMsgRaw( "_________________________________________\r\n\n" );
		OutMsgRaw( "PnP BIOS Found...\r\n" );
		OutMsgRaw( "_________________________________________\r\n\n" );
		OutMsgRaw( "  Anchor:\t\t\t\"$PnP\"\r\n" );
		OutMsgFP( "  EPS Found at:\t\t\t", pnp );
		OutMsgBX( "  EPS checksum:\t\t\t", pnp->Checksum );
		OutMsgVD( "  Version:\t\t\t", (USHORT) ( pnp->Version >> 4 ), (USHORT) ( pnp->Version & 0x0f ) );
		OutMsgFP( "  Real Mode Entry Point:\t", _MK_FP( pnp->RM_16bit_entry_seg, pnp->RM_16bit_entry_off ) );
		OutMsgSX( "  Real Mode Data Segment:\t", pnp->RM_16bit_data_seg );
		OutMsgLX( "  32-bit Entry Point Address:\t",  pnp->PM_16bit_entry_seg + pnp->PM_16bit_entry_off );
		OutMsgLX( "  32-bit Base Data Address:\t",  pnp->PM_16bit_data_seg );
		OutMsgLX( "  OEM Device Id:\t\t", pnp->OEM_Device_Id );
	}

	return found ? pnp : (void far *) 0;
}


BOOL GetByTableMethod( ANY_EPS far *dmi  )
{
	BOOL result;
	USHORT hfile;

	result = FALSE;

	if ( dmi )
	{
		// convert the SMBIOS eps to a DMI BIOS eps by adding 16 bytes
		if ( *( (char far *) dmi + 1 ) == 'S' )
		{
			dmi = (ANY_EPS far *) ( (BYTE far * ) dmi + 16 );
		}

		MakeFilePath( FilePath, DirPath, DATFILE );
		hfile = OpenFile( FilePath );

		if ( hfile != 0xffff )
		{
			BYTE far *table_src;
			BYTE far *table_dest;
			USHORT smb_selector, i, j;

			// get a far pointer for the table source memory
			smb_selector = MakeSelector( dmi->dmi.table_addr, dmi->dmi.table_length );
			if ( smb_selector )
			{
				table_src = (BYTE far *) _MK_FP( smb_selector, 0 );

				// get a far pointer for the table destination
				//table_dest = (BYTE far *) _MK_FP( ms->Segment, 0 );
				table_dest = (BYTE far *) dbuff;

				if ( verbose )
				{
					OutMsgRaw( "_________________________________________\r\n\n" );
					OutMsgRaw( "Copying SMBIOS Table Data from ROM...\r\n" );
					OutMsgRaw( "_________________________________________\r\n\n" );
					OutMsgFP( "  Protected Mode Table Address:\t", _MK_FP( smb_selector, 0 ) );
				}

				for ( i = 0, j = 0; j < dmi->dmi.table_length; i++, j++ )
				{
					if ( i >= 4096 )
					{
						WriteFile( hfile, table_dest, i );
						i = 0;
					}
					table_dest[i] = table_src[j];
				}
				if ( i > 0 )
				{
					WriteFile( hfile, table_dest, i );
				}
				CloseFile( hfile );
				if ( verbose )
				{
					OutMsgSD( "  Bytes Copied:\t\t\t", j );
					OutMsgSS( "  Writing SMBIOS data file at:\r\n    ", FilePath );
				}
				// free the selector for the source table
				FreeSelector( smb_selector );
				result = TRUE;
			}
		}
	}

	return result;
}


BOOL GetByStructMethod( PNP_EPS far *pnp )
{
	BYTE	bios_rev;
	USHORT	struct_count;
	USHORT	struct_size;
	ULONG	store_base;
	USHORT	store_size;
	short	result;

	PNPFUNC50	GetSMBInfo;
	PNPFUNC51	GetSMBStruct;

	result = -1;
	
	if ( pnp && pnp->RM_16bit_entry_seg )
	{

 		// sorry, but I have to convert "data" pointers to function pointers
#		pragma warning (disable : 4055)
 		GetSMBInfo   = (PNPFUNC50) _MK_FP( pnp->RM_16bit_entry_seg, pnp->RM_16bit_entry_off );
 		GetSMBStruct = (PNPFUNC51) _MK_FP( pnp->RM_16bit_entry_seg, pnp->RM_16bit_entry_off );
#		pragma warning (default : 4055)

		if ( verbose )
		{
			OutMsgRaw( "_________________________________________\r\n\n" );
			OutMsgRaw( "DMI BIOS Information...\r\n" );
			OutMsgRaw( "_________________________________________\r\n\n" );
			OutMsgBX( "  PnP BIOS Functon:\t\t", GET_DMI_INFORMATION );
		}
		result = GetSMBInfo( GET_DMI_INFORMATION,
		                     (BYTE far *) &bios_rev,
		                     (USHORT far *) &struct_count,
	                         (USHORT far *) &struct_size,
	                         (ULONG far *) &store_base,
	                         (USHORT far *) &store_size,
		                     pnp->RM_16bit_data_seg );
	}
	if ( result == DMI_SUCCESS )
	{
		BYTE far *struct_dest;
		BYTE far *table_dest;
		USHORT smb_segment;
		USHORT handle;
		USHORT struct_length;
		USHORT byte_count;
		USHORT hfile;
		USHORT meter;

		if ( verbose )
		{
			OutMsgVD( "  BIOS Revision:\t\t", (USHORT) bios_rev >> 4, (USHORT) bios_rev & 0x0f );
			OutMsgSD( "  Structure count:\t\t", struct_count );
			OutMsgSD( "  Structure size:\t\t", struct_size );
			OutMsgLX( "  Storage base:\t\t\t", store_base );
			OutMsgSD( "  Storage size:\t\t\t", store_size );
		}

		handle = 0;
		byte_count = 0;

		MakeFilePath( FilePath, DirPath, DATFILE );
		hfile = OpenFile( FilePath );

		if ( hfile != 0xffff )
		{
			if ( verbose )
			{
				OutMsgRaw( "_________________________________________\r\n\n" );
				OutMsgRaw( "Copying DMI BIOS Data...\r\n" );
				OutMsgRaw( "_________________________________________\r\n\n" );
				OutMsgBX( "  Iterate PnP BIOS Functon:\t", GET_DMI_STRUCTURE );
			}
			//struct_dest = (BYTE far *) _MK_FP( ms->Segment, 0 );
			table_dest = (BYTE far *) dbuff;
			struct_dest = (BYTE far *) dbuff;
			//smb_sel = MakeSelector( store_base, store_size );

			// were not in protected mode so this wont be used...but we'll make a seg value anyway
			smb_segment = (USHORT) ( store_base >> 4 );
			meter = 0;
			struct_count = 0;
			while ( handle != 0xffff && byte_count < 65536 )
			{
				result = GetSMBStruct( GET_DMI_STRUCTURE,
				                       (USHORT far *) &handle,
				                       (BYTE far *) struct_dest,
				                       smb_segment,
				                       pnp->RM_16bit_data_seg );

				if ( result == DMI_SUCCESS )
				{
					struct_length = GetStructureLength( (SHF far *) struct_dest );
					struct_dest += struct_length;
					byte_count += struct_length;
					meter += struct_length;
					struct_count++;
					if ( meter > ( 4096 - struct_size ) )
					{
						WriteFile( hfile, table_dest, meter );
						struct_dest = table_dest;
						meter = 0;
					}
				}
			}
			if ( meter > 0 )
			{
				WriteFile( hfile, table_dest, meter );
			}
			CloseFile( hfile );

			if ( verbose )
			{
				OutMsgSD( "  Structures copied:\t\t", struct_count );
				OutMsgSD( "  Total bytes retrieved:\t", byte_count );
				OutMsgSS( "  Writing SMBIOS data file at:\r\n    ", FilePath );
			}
			result = DMI_SUCCESS;
		}
	}
	if ( verbose )
	{
		switch ( result )
		{		
			case DMI_SUCCESS:
			break;

			case DMI_UNKNOWN_FUNCTION:
			case DMI_FUNCTION_NOT_SUPPORTED:
			{
				OutMsgBX( "  DMI structures not available:\trc =  ", (BYTE) result );
			}
			break;

			default:
			{
				OutMsgRaw( "  PnP call (GET_DMI_INFORMATION) failed.\r\n" );
			}
			break;
		}
	}

	return result == DMI_SUCCESS;
}


// protected mode functions...

BOOL StartPM( void )
{
	BOOL			result;
	unsigned int	PMEntry_Segment;
	unsigned int	PMEntry_Offset;
	unsigned char	Proc_Type;
	unsigned char	VMajor;
	unsigned char	VMinor;
	unsigned int	Paragraphs;

	unsigned int far *PMEntry;

	OutMsgRaw( "_________________________________________\r\n" );
	OutMsgRaw( "\nSwitching to Protected Mode...\r\n" );
	OutMsgRaw( "_________________________________________\r\n\n" );

	// get DPMI entry point data
	_asm
	{
		mov ax, 1687h
		int 2Fh
		mov result, ax
	}
	if ( !result )
	{
		// set the dpmi EPS data
		_asm
		{
			mov Proc_Type, cl
			mov VMajor, dh
			mov VMinor, dl
			mov Paragraphs, si
			mov PMEntry_Segment, es
			mov PMEntry_Offset, di
		}

		result = 1;
		PMEntry = _MK_FP( PMEntry_Segment, PMEntry_Offset );
		_asm
		{
			;check if needed and allocate necessary DPMI host data area
			Check_Host_Mem:
				test si, si
				jz Start_PM
				mov bx, si
		        mov ah, 48h
		        int 21h
				jc PMEntry_Fail
		        mov es, ax					;data area segment
		
			Start_PM:
		        xor ax, ax					;clear to indicate 16-bit app
		        call dword ptr PMEntry		;do the switch!
		        jc PMEntry_Fail
				mov result, 0
		
			PMEntry_Fail:
		}
	}

	if ( verbose)
	{
		if ( !result )
		{
			OutMsgFP( "  DPMI Entry Point:\t\t", _MK_FP( PMEntry_Segment, PMEntry_Offset ) );
			OutMsgSD( "  Processor Type:\t\t80", (USHORT) Proc_Type * 100 + 86 );
			OutMsgVD( "  DPMI Version:\t\t\t", VMajor, VMinor );
			OutMsgSD( "  Paragraphs needed:\t\t", (USHORT) Paragraphs );
		}
		else
		{
			OutMsgRaw( "  Protected Mode Switch Failed!!!\r\n" );
		}
	}

	return result;
}

// switch back to Real Mode and terminate with error code
void End_PM( BYTE error )
{
	_asm
	{
		mov al, error
		mov ah, 4Ch
		int 21h
	}
}

USHORT MakeSelector( ULONG lin_addr, USHORT limit )
{
	USHORT new_sel;
	BOOL result;

	new_sel = 0;

	// Allocate a descriptor then set the address and limit
	_asm
	{
		mov ax, 0000h						;Allocate LDT descriptor function
		mov cx, 0001h						;just one, smbios data outta be < 64k
		int 31h
		jc were_hosed
		mov new_sel, ax

		;Set selector base address
		mov ax, 0007h						;Set Segment base address function
		mov bx, new_sel						;use our new selector value
		mov cx, word ptr lin_addr + 2 		;get the high word of the linear address
		mov dx, word ptr lin_addr			;get the low word of the linear address
		int 31h
		jc were_hosed

		;Set selector limit
		mov ax, 0008h						;Set Segment limit function
		mov bx, new_sel						;use our new selector value
		xor cx, cx							;our limit can't be > 64k, null the high word
		mov dx, limit						;use table length as limit
		int 31h
		jc were_hosed

		mov result, 0
		jmp alloc_done

		were_hosed:
		mov result, 1

		alloc_done:
	}

	if ( result && new_sel )
	{
		FreeSelector( new_sel );
		new_sel = 0;
	}

	return new_sel;
}


BOOL FreeSelector( USHORT selector )
{
	BOOL result = FALSE;

	if ( selector )
	{
		_asm
		{
			Free_Selector:
				mov ax, 0001h		;Free LDT Descriptor function
				mov bx, selector	;use our allocated selector
				int 31h
				jnc	Free_Fail
				mov result, 1
			Free_Fail:
		}
	}

	return result;	
}

//==============================================================================
//	Data allocation functions

#if 0
BOOL DOS_DataAlloc( MEMSTRUCT *ms )
{
	BOOL result;
	USHORT temp_seg, pghs;

	pghs = (USHORT) ( ms->Size >> 4 );
	pghs += (USHORT) ( ( ms->Size % 16 ) ? 1 : 0 );

	_asm
	{
		dda_start:
			mov bx, pghs
			mov ah, 48h
			int 21h
			jc dda_fail
			mov temp_seg, ax				;data area segment
			mov result, 1
			jmp dda_done
		dda_fail:
			mov result, 0
		dda_done:
	}
	if ( result )
	{
		ms->Segment = temp_seg;
		ms->BaseAddress = (ULONG) ms->Segment << 4;
	}
	else
	{
		ms->Segment = 0;
		ms->BaseAddress = 0;
	}
	ms->Handle = 0;

	return result;
}


BOOL PM_DataAlloc( MEMSTRUCT *ms )
{
	BOOL result;
	unsigned long bsize, temp_addr, temp_handle;

	bsize = ms->Size;

	_asm
	{
		la_start:
			mov ax, 0501h
			mov bx, word ptr bsize + 2
			mov cx, word ptr bsize
			int 31h
			jc la_error
			mov word ptr temp_addr + 2, bx				
			mov word ptr temp_addr, cx				
			mov word ptr temp_handle + 2, si				
			mov word ptr temp_handle, di				
			mov result, 1
			jmp la_done

		la_error:
			mov result, 0

		la_done:
	}

	if ( result )
	{
		ms->BaseAddress = temp_addr;
		ms->Handle      = temp_handle;
		ms->Segment     = MakeSelector( ms->BaseAddress, (USHORT) ms->Size );
		// if we can't make the selector then free the memory
		if ( !ms->Segment )
		{
			PM_DataFree( ms );
			result = FALSE;
		}
	}
	if ( !result )
	{
		ms->BaseAddress = 0;
		ms->Handle      = 0;
		ms->Segment     = 0;
	}

	return result;
}


BOOL PM_DataFree( MEMSTRUCT *ms )
{
	if ( ms->Handle )
	{
		ULONG handle;

		handle = ms->Handle;

		_asm
		{
			mov ax, 0502h
			mov si, word ptr handle + 2
			mov di, word ptr handle
			int 31h
		}
		return TRUE;
	}
	else
	{
		return FALSE;
	}

}
#endif


void far *CVSEG( void far *realptr )
{
	_asm
	{
		mov ax, 0002h
		mov bx, word ptr realptr + 2
		int 31h
		mov word ptr realptr + 2, ax
	}

	return realptr;
}

// Hex dump of a data block to stdio
void RawDump( BYTE far *data, USHORT length )
{
	USHORT i;
	BYTE far *dval;

	dval = (BYTE far *) data;

	for ( i = 0; i < length; i++, dval++ )
	{
		if ( !( i % 16 ) )
		{
			OutMsgRaw( "\r\n" );
		}
		OutMsgBX( " ", *dval );
	}
	OutMsgRaw( "\r\n" );
}


// hokey function to get system dir strings from envp
USHORT GetDataPathname( char *pathname, char far *envdata )
{
	USHORT limit, h, i, j = 0;
	BOOL skip;
	char matcher, matchee;
	char *datfilepath;
	char far *penv;
	BYTE dosv_major, dosv_minor;

	// get "true" DOS version
	_asm
	{
		mov ax, 3306h
		int 21h
		mov dosv_major, bl
		mov dosv_minor, bh
	}
	switch ( dosv_major << 8 | dosv_minor )
	{
		case 0x0700:	// Win95
		case 0x070a:	// Win95 SP1, Win95 OSR2, Win98
		case 0x0800:	// Millennium
		case 0x0532:	// Win NT
		{
			datfilepath = "\\SYSTEM";
		}
		break;

		//case 0x0532:	// Win NT
		//{
		//	datfilepath = "\\SYSTEM32\\DRIVERS\\SMBIOS.DAT";
		//}
		//break;

		default:		// some other DOS
		{
			datfilepath = "";
		}
		break;
	}

	penv = envdata;

	while ( *penv )
	{
		for ( h = 0; h < 2; h++ )
		{
			limit = (USHORT) ( ( h == 0 ) ? 7 : 11 );
			skip = FALSE;
			for ( i = 0; !skip && i < limit; i++ )
			{
				if ( h == 0 )	// look for Win9X windir first
				{
					switch ( i )
					{
						case 0: matcher = 'W'; break;
						case 1: matcher = 'I'; break;
						case 2: matcher = 'N'; break;
						case 3: matcher = 'D'; break;
						case 4: matcher = 'I'; break;
						case 5: matcher = 'R'; break;
						case 6: matcher = '='; break;
					}
				}
				else
				{
					switch ( i )	// look for windir in NTVDM
					{
						case 0: matcher = 'S'; break;
						case 1: matcher = 'Y'; break;
						case 2: matcher = 'S'; break;
						case 3: matcher = 'T'; break;
						case 4: matcher = 'E'; break;
						case 5: matcher = 'M'; break;
						case 6: matcher = 'R'; break;
						case 7: matcher = 'O'; break;
						case 8: matcher = 'O'; break;
						case 9: matcher = 'T'; break;
						case 10: matcher = '='; break;
					}
				}
				matchee = penv[i];
				if ( matchee >= 'a' && matchee <= 'z' )
				{
					matchee -= ( 'a' - 'A' );
				}
				if ( matchee != matcher )
				{
					skip = TRUE;
				}
			}
			if ( !skip && i == limit )
			{
				break;
			}
		}
		if ( !skip && i == limit )
		{
			break;
		}
		else
		{
			while ( *penv++ );
		}
	}
	if ( penv )
	{
		while ( penv[i + j] )
		{
			*pathname++ = penv[i + j++];
		}
		for ( i = 0; datfilepath[i] != '\0'; i++, j++ )
		{
			*pathname++ = datfilepath[i];
		}
		*pathname = '\0';			
	}

	return j;
}


//==============================================================================
//	File I/O routines

USHORT WriteFileData( char far *filepath, BYTE far *datablock, USHORT datasize )
{
	USHORT bytes;

	_asm
	{
		Create_File:
			push ds							;save current ds
			mov dx, word ptr filepath + 2	;set segment of filepath
			mov ds, dx
			mov dx, word ptr filepath		;set offset of filepath
			xor cx, cx
			mov ah, 3ch						
			int 21h
			jc File_Failure
			mov bx, ax						;copy file handle

		Write_File:
			mov dx, word ptr datablock + 2	;set segment of datablock
			mov ds, dx
			mov dx, word ptr datablock		;set offset of datablock
			mov cx, word ptr datasize		;set the file data block length
			mov ah, 40h
			int 21h
			pop ds							;restore old ds

		Close_File:
			mov ah, 3eh
			int 21h

		File_Failure:
	}

	return bytes;
}

USHORT OpenFile( char far *filepath )
{
	USHORT handle;

	// need a far fwrite, so we'll do it the hard way
	_asm
	{
		Create_File:
			push ds							;save current ds
			mov dx, word ptr filepath + 2	;set segment of filepath
			mov ds, dx
			mov dx, word ptr filepath		;set offset of filepath
			xor cx, cx
			mov ah, 3ch						
			int 21h
			jnc Create_Done
			mov ax, 0ffffh					;set invalid file handle
		Create_Done:
			mov handle, ax						;copy file handle
			pop ds							;restore old ds
	}

	return handle;
}


USHORT WriteFile( USHORT handle, BYTE far *datablock, USHORT datasize )
{
	USHORT bytes;

	_asm
	{
		Write_Block:
			mov bx, handle
			push ds							;save current ds
			mov dx, word ptr datablock + 2	;set segment of datablock
			mov ds, dx
			mov dx, word ptr datablock		;set offset of datablock
			mov cx, word ptr datasize		;set the file data block length
			mov ah, 40h
			int 21h
			mov bytes, ax
			pop ds							;restore old ds
	}

	return bytes;
}

void CloseFile( USHORT handle )
{
	_asm
	{
		Close_File:
			mov bx, handle
			mov ah, 3eh
			int 21h
	}
}


USHORT GetStructureLength( SHF far *pshf )
{
	BYTE far *pend;
	USHORT len;

	len = 0;

	// move past formatted area
	pend = (BYTE far *) pshf + pshf->Length;
	
	// look for the double NULL
	while ( pend[0] || pend[1] )
	{
		pend++;
		len++;
	}

	return pshf->Length + len + 2;
}


USHORT RunChecksum( BYTE far *bptr, USHORT length )
{
	// run the checksum on the EPS to validate it
	USHORT bytesum = 0;

	while ( length-- )
	{
		bytesum += (USHORT) *bptr++;
	}

	return bytesum & 0x00ff;
}

BOOL MakeFilePath( char far *FilePath, char far *DirPath, char far *FileName )
{
	BOOL result = FALSE;

	while ( *DirPath )
	{
		*FilePath++ = *DirPath++;
	}
	*FilePath++ = '\\';
	while ( *FileName )
	{
		*FilePath++ = *FileName++;
	}

	return result;
} 


//==============================================================================
//	STDOUT functions here

void OutMsgRaw( char far *msg )
{
	USHORT count;

	for ( count = 0; msg[count] && count < 80; count++ );

	_asm
	{
		push ds
		mov dx, word ptr msg + 2
		mov ds, dx
		mov dx, word ptr msg
		mov cx, count
		mov	bx, 1
		mov ah, 40h
		int 21h
		pop ds							;restore old ds
	}
}



USHORT HexToAsc( BYTE byteval )
{
	USHORT asc;

	asc = (USHORT) ( byteval & 0xf0 ) << 4;
	asc |= (USHORT) ( byteval & 0x0f );

	asc += (USHORT) ( ( ( asc & 0xff00 ) < 0x0a00 ) ? 0x3000 : 0x5700 );
	asc += (USHORT) ( ( ( asc & 0x00ff ) < 0x000a ) ? 0x0030 : 0x0057 );

	return asc;
}


void OutMsgSD( char far *msg, USHORT dval )
{
	char dstrg[9];
	USHORT count, i;

	count = 0;

	do
	{
		for ( i = count; i > 0; i-- )
		{
			dstrg[i] = dstrg[i-1];
		}
		dstrg[0] = (char) ( ( dval % 10 ) + '0' );
		dval /= 10;
		count++;
	}
	while ( dval );

	dstrg[count++] = '\r';
	dstrg[count++] = '\n';
	dstrg[count] = '\0';

	OutMsgRaw( msg );
	OutMsgRaw( dstrg );
}

void OutMsgVD( char far *msg, USHORT ver1, USHORT ver2 )
{
	char dstrg[9];
	USHORT count, i;

	OutMsgRaw( msg );

	count = 0;

	do
	{
		for ( i = count; i > 0; i-- )
		{
			dstrg[i] = dstrg[i-1];
		}
		dstrg[0] = (char) ( ( ver1 % 10 ) + '0' );
		ver1 /= 10;
		count++;
	}
	while ( ver1 );

	dstrg[count++] = '.';
	dstrg[count] = '\0';

	OutMsgRaw( dstrg );

	count = 0;

	do
	{
		for ( i = count; i > 0; i-- )
		{
			dstrg[i] = dstrg[i-1];
		}
		dstrg[0] = (char) ( ( ver2 % 10 ) + '0' );
		ver2 /= 10;
		count++;
	}
	while ( ver2 );
	dstrg[count++] = '\r';
	dstrg[count++] = '\n';
	dstrg[count] = '\0';

	OutMsgRaw( dstrg );
}



void OutMsgBX( char far *msg, BYTE bval )
{
	char bstrg[5];
	USHORT asc;

	asc = HexToAsc( bval );
	bstrg[0] = (char) ( asc >> 8 );
	bstrg[1] = (char) ( asc & 0x00ff );
	bstrg[2] = '\r';
	bstrg[3] = '\n';
	bstrg[4] = '\0';

	OutMsgRaw( msg );
	OutMsgRaw( bstrg );
}

void OutMsgSX( char far *msg, USHORT val )
{
	char sstrg[7];
	USHORT asc;

	asc = HexToAsc( (BYTE) ( val >> 8 ) );
	sstrg[0] = (char) ( asc >> 8 );
	sstrg[1] = (char) ( asc & 0x00ff );
	asc = HexToAsc( (BYTE) ( val & 0x00ff ) );
	sstrg[2] = (char) ( asc >> 8 );
	sstrg[3] = (char) ( asc & 0x00ff );
	sstrg[4] = '\r';
	sstrg[5] = '\n';
	sstrg[6] = '\0';

	OutMsgRaw( msg );
	OutMsgRaw( sstrg );
}


void OutMsgLX( char far *msg, ULONG lval )
{
	USHORT asc, val;
	char lstrg[11];

	val = (USHORT) ( lval >> 16 );
	asc = HexToAsc( (BYTE) ( val >> 8 ) );
	lstrg[0] = (char) ( asc >> 8 );
	lstrg[1] = (char) ( asc & 0x00ff );
	asc = HexToAsc( (BYTE) ( val & 0x00ff ) );
	lstrg[2] = (char) ( asc >> 8 );
	lstrg[3] = (char) ( asc & 0x00ff );

	val = (USHORT) ( lval & 0xffff );
	asc = HexToAsc( (BYTE) ( val >> 8 ) );
	lstrg[4] = (char) ( asc >> 8 );
	lstrg[5] = (char) ( asc & 0x00ff );
	asc = HexToAsc( (BYTE) ( val & 0x00ff ) );
	lstrg[6] = (char) ( asc >> 8 );
	lstrg[7] = (char) ( asc & 0x00ff );
	lstrg[8] = '\r';
	lstrg[9] = '\n';
	lstrg[10] = '\0';

	OutMsgRaw( msg );
	OutMsgRaw( lstrg );
}


void OutMsgFP( char far *msg, void far *vptr )
{
	char lstrg[12];
	USHORT asc, seg_fp, off_fp;

	seg_fp = (USHORT) _FP_SEG( vptr );
	off_fp = (USHORT) _FP_OFF( vptr );

	asc = HexToAsc( (BYTE) ( seg_fp >> 8 ) );
	lstrg[0] = (char) ( asc >> 8 );
	lstrg[1] = (char) ( asc & 0x00ff );
	asc = HexToAsc( (BYTE) ( seg_fp & 0x00ff ) );
	lstrg[2] = (char) ( asc >> 8 );
	lstrg[3] = (char) ( asc & 0x00ff );
	lstrg[4] = ':';
	asc = HexToAsc( (BYTE) ( off_fp >> 8 ) );
	lstrg[5] = (char) ( asc >> 8 );
	lstrg[6] = (char) ( asc & 0x00ff );
	asc = HexToAsc( (BYTE) ( off_fp & 0x00ff ) );
	lstrg[7] = (char) ( asc >> 8 );
	lstrg[8] = (char) ( asc & 0x00ff );
	lstrg[9] = '\r';
	lstrg[10] = '\n';
	lstrg[11] = '\0';

	OutMsgRaw( msg );
	OutMsgRaw( lstrg );
}


void OutMsgSS( char far *msg, char far *strg )
{
	OutMsgRaw( msg );
	OutMsgRaw( strg );
	OutMsgRaw( "\r\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\smbios\smbios\driver.c ===
/*++



Copyright (c) 1993-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    driver.c

Abstract:

    Just the DriverEntry point for the SMBIOS driver

Environment:

    kernel mode only

Notes:

    For the sake of simplicity this sample does not attempt to
    recognize resource conflicts with other drivers/devices. A
    real-world driver would call IoReportResource usage to
    determine whether or not the resource is available, and if
    so, register the resource under it's name.

Revision History:

--*/

#include "precomp.h"
#include "driver.h"
//#include "stdarg.h"


void	DoSMBIOS();



#if DBG
#define DriverKdPrint(arg) DbgPrint arg
#else
#define DriverKdPrint(arg)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{

    PDEVICE_OBJECT deviceObject = NULL;
    NTSTATUS       ntStatus;
    WCHAR	   deviceNameBuffer[] = L"\\Device\\Driver";
    UNICODE_STRING deviceNameUnicodeString;
    WCHAR	   deviceLinkBuffer[] = L"\\DosDevices\\Driver";
    UNICODE_STRING deviceLinkUnicodeString;



    DriverKdPrint (("Driver.SYS: entering DriverEntry\n"));

    DoSMBIOS();

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\smbios\smbdpmi\startup.asm ===
name    startup
;**************************************************************************
;**************************************************************************
; Copyright 1999 Microsoft Corporation
;
;


extrn	_mainp:near



_STACK	segment word public 'STACK'
tstack	db		8192 dup(?)
bstack:
_STACK	ends

_DATA   segment word public 'DATA'
envdata	dd		?
cmdline	dd		?

_DATA   ends

DGROUP	group	_STACK, _DATA

_TEXT	segment word public 'CODE'
		assume	cs:_TEXT,ds:DGROUP



				public	_Startup

_Startup		proc    near

; store off the command line and environment addresses

                mov     ax, seg DGROUP
                mov     es, ax                  ;Leave DS pointing at PSP

                lea     di, cmdline
				mov		bx, ds
				mov		es:[di+2], bx
				mov		bx, 0081h
				mov		es:[di], bx
                lea     di, envdata
				mov		si, 002ch
				mov		bx, [si]
				mov		es:[di+2], bx
				mov		bx, 0000h
				mov		es:[di], bx

; now setup DS and SS
				mov		ds, ax
				mov		ss, ax
				lea		sp, bstack

; call mainp()
				mov		bx, word ptr envdata + 2
				push	bx
				mov		bx,	word ptr envdata
				push	bx
				mov		bx, word ptr cmdline + 2
				push	bx
				mov		bx, word ptr cmdline
				push	bx
				call	near ptr _mainp
				add		sp, 8

; terminate
				mov		ah, 4ch
				int		21h
_Startup endp


;***********************************************************************

IF 0
; stub for testing
_dodpmi  proc    near
;		mov		ax, 0
;		ret
	;// get DPMI entry point data

	mov ax, 1687h
	int 2Fh
	;mov result, ax

	or ax, ax
	jnz PMEntry_Fail

	;		mov Proc_Type, cl
	;		mov VMajor, dh
	;		mov VMinor, dl
	;		mov Paragraphs, si
			mov PMEntry_Segment, es
			mov PMEntry_Offset, di

		;result = 1;
		;PMEntry = _MK_FP( PMEntry_Segment, PMEntry_Offset );
		;_asm
		;{
			;check if needed and allocate necessary DPMI host data area
			Check_Host_Mem:
				test si, si
				jz Start_PM
				mov bx, si
		        mov ah, 48h
		        int 21h
				jc PMEntry_Fail
		        mov es, ax					;data area segment
		
			Start_PM:
		        xor ax, ax					;clear to indicate 16-bit app
		        call dword ptr PMENTRY_Offset	;do the switch!
		        jc PMEntry_Fail
				;mov result, 0
		
			PMEntry_Fail:
		ret

_dodpmi	endp
        

_dodosalloc	proc	near

			mov ax, 5800h
			int 21h

			mov bx, 0081h
			mov ax, 5801h
			int 21h

		dda_start:
			mov bx, pghs
			mov ax, 4800h
			int 21h
			jc dda_fail
			mov bx, ax				;data area segment
		dda_fail:
	
	ret

_dodosalloc	endp
ENDIF

_TEXT   ends

        end     _Startup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\smbios\smbios\driver.h ===
/*++



Copyright (c) 1993-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    driver.h

Abstract:


Environment:

    kernel & User mode

Notes:


Revision History:

--*/


//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define FILE_DEVICE_MAPMEM  0x00002525
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\smbios\smbios\smbios.h ===
/*++ 



Copyright (c) 1989-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    io.h

Abstract:

    This module contains definitions that describe SMBIOS

Author:

    Alan Warwick (AlanWar) 12-Feb-1998


Revision History:


--*/

#ifndef _SMBIOS_
#define _SMBIOS_

//
// SMBIOS error codes
#define DMI_SUCCESS 0x00
#define DMI_UNKNOWN_FUNCTION 0x81
#define DMI_FUNCTION_NOT_SUPPORTED 0x82
#define DMI_INVALID_HANDLE 0x83
#define DMI_BAD_PARAMETER 0x84
#define DMI_INVALID_SUBFUNCTION 0x85
#define DMI_NO_CHANGE 0x86
#define DMI_ADD_STRUCTURE_FAILED 0x87

//
// SMBIOS registry values
#define SMBIOSPARENTKEYNAME L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter"

#define SMBIOSIDENTIFIERVALUENAME L"Identifier"
#define SMBIOSIDENTIFIERVALUEDATA L"PNP BIOS"
#define SMBIOSDATAVALUENAME		L"Configuration Data"

#define MAXSMBIOSKEYNAMESIZE 256

//
// SMBIOS table search
#define SMBIOS_EPS_SEARCH_SIZE      0x10000
#define SMBIOS_EPS_SEARCH_START     0x000f0000
#define SMBIOS_EPS_SEARCH_INCREMENT 0x10

#pragma pack(push, 1)
typedef struct _SMBIOS_TABLE_HEADER
{
    UCHAR Signature[4];             // _SM_ (ascii)
    UCHAR Checksum;
    UCHAR Length;
    UCHAR MajorVersion;
    UCHAR MinorVersion;
    USHORT MaximumStructureSize;
    UCHAR EntryPointRevision;
    UCHAR Reserved[5];
    UCHAR Signature2[5];           // _DMI_ (ascii)
    UCHAR IntermediateChecksum;
    USHORT StructureTableLength;
    ULONG StructureTableAddress;
    USHORT NumberStructures;
    UCHAR Revision;
} SMBIOS_EPS_HEADER, *PSMBIOS_EPS_HEADER;

typedef struct _SMBIOS_STRUCT_HEADER
{
    UCHAR Type;
    UCHAR Length;
    USHORT Handle;
    UCHAR Data[];
} SMBIOS_STRUCT_HEADER, *PSMBIOS_STRUCT_HEADER;


typedef struct _DMIBIOS_TABLE_HEADER
{
    UCHAR Signature2[5];           // _DMI_ (ascii)
    UCHAR IntermediateChecksum;
    USHORT StructureTableLength;
    ULONG StructureTableAddress;
    USHORT NumberStructures;
    UCHAR Revision;
} DMIBIOS_EPS_HEADER, *PDMIBIOS_EPS_HEADER;

#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\smbios\smbios\dmi.h ===
/*++ 



Copyright (c) 1989-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    io.h

Abstract:

    This module contains definitions that describe SMBIOS

Author:

    Alan Warwick (AlanWar) 12-Feb-1998


Revision History:


--*/

#ifndef _SMBIOS_
#define _SMBIOS_

//
// SMBIOS error codes
#define DMI_SUCCESS 0x00
#define DMI_UNKNOWN_FUNCTION 0x81
#define DMI_FUNCTION_NOT_SUPPORTED 0x82
#define DMI_INVALID_HANDLE 0x83
#define DMI_BAD_PARAMETER 0x84
#define DMI_INVALID_SUBFUNCTION 0x85
#define DMI_NO_CHANGE 0x86
#define DMI_ADD_STRUCTURE_FAILED 0x87

//
// SMBIOS registry values
#define SMBIOSPARENTKEYNAME L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter"

#define SMBIOSIDENTIFIERVALUENAME L"Identifier"
#define SMBIOSIDENTIFIERVALUEDATA L"PNP BIOS"
#define SMBIOSDATAVALUENAME		L"Configuration Data"

#define MAXSMBIOSKEYNAMESIZE 256

//
// SMBIOS table search
#define SMBIOS_EPS_SEARCH_SIZE      0x10000
#define SMBIOS_EPS_SEARCH_START     0x000f0000
#define SMBIOS_EPS_SEARCH_INCREMENT 0x10

#pragma pack(push, 1)
typedef struct _SMBIOS_TABLE_HEADER
{
    UCHAR Signature[4];             // _SM_ (ascii)
    UCHAR Checksum;
    UCHAR Length;
    UCHAR MajorVersion;
    UCHAR MinorVersion;
    USHORT MaximumStructureSize;
    UCHAR EntryPointRevision;
    UCHAR Reserved[5];
    UCHAR Signature2[5];           // _DMI_ (ascii)
    UCHAR IntermediateChecksum;
    USHORT StructureTableLength;
    ULONG StructureTableAddress;
    USHORT NumberStructures;
    UCHAR Revision;
} SMBIOS_EPS_HEADER, *PSMBIOS_EPS_HEADER;

typedef struct _SMBIOS_STRUCT_HEADER
{
    UCHAR Type;
    UCHAR Length;
    USHORT Handle;
    UCHAR Data[];
} SMBIOS_STRUCT_HEADER, *PSMBIOS_STRUCT_HEADER;


typedef struct _DMIBIOS_TABLE_HEADER
{
    UCHAR Signature2[5];           // _DMI_ (ascii)
    UCHAR IntermediateChecksum;
    USHORT StructureTableLength;
    ULONG StructureTableAddress;
    USHORT NumberStructures;
    UCHAR Revision;
} DMIBIOS_EPS_HEADER, *PDMIBIOS_EPS_HEADER;

#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\smbios\smbios\smbios.c ===
/*++



Copyright (c) 1998-2001 Microsoft Corporation, All Rights Reserved

Module Name:

    smbios.c

Abstract:

    Driver for SMBIOS support on NT 4

Author:

    Dilip Naik


Revision History:


--*/

#include "precomp.h"
#include <string.h>
#include "smbios.h"

#define SMBIOSDATFILE L"\\SystemRoot\\system\\SMBIOS.DAT"
#define SMBIOSEPSFILE L"\\SystemRoot\\system\\SMBIOS.EPS"


NTSTATUS
SMBiosOpenAndWriteFile(
	PUCHAR	SMBiosVirtualAddress,
	ULONG	SMBiosDataLength,
    IN PUNICODE_STRING FileExt
	);

void DoSMBIOS(

    )
/*++

Routine Description:

    Search for the SMBIOS 2.1 EPS structure.

Arguments:

    SMBiosVirtualAddress is the beginning virtual address to start searching
        for the SMBIOS 2.1 EPS anchor string.
            
    BiosSize is the number of bytes to search for the anchor string

Return Value:

    Pointer to SMBIOS 2.1 EPS or NULL if EPS not found

--*/
{
    PUCHAR SearchEnd;
    UCHAR CheckSum;
    PSMBIOS_EPS_HEADER SMBiosEPSHeader;
    ULONG i;
    PHYSICAL_ADDRESS BiosPhysicalAddress;
    PHYSICAL_ADDRESS SMBiosPhysicalAddress;
    PUCHAR SMBiosVirtualAddress;
    BOOLEAN Found;
    ULONG   SMBiosTableLength;
    PDMIBIOS_EPS_HEADER DMIBiosEPSHeader;
    ULONG CheckLength;
	PUCHAR BiosVirtualAddress;
	UNICODE_STRING  FileName;

    PAGED_CODE();

    Found = FALSE;
    

    // Scan the BIOS memory for the SMBIOS signature string

    BiosPhysicalAddress.QuadPart = SMBIOS_EPS_SEARCH_START;
    BiosVirtualAddress = MmMapIoSpace(BiosPhysicalAddress,
                                      SMBIOS_EPS_SEARCH_SIZE,
                                      MmCached);

    if (BiosVirtualAddress != NULL)
    {

#if DBG
	    KdPrint(("WBEM:Scanning memory for SMBIOS data\n"));
#endif
    
    	//
    	// Scan the bios for the two anchor strings that that signal the 
    	// SMBIOS table.
        SMBiosVirtualAddress = BiosVirtualAddress;
    	SearchEnd = SMBiosVirtualAddress + SMBIOS_EPS_SEARCH_SIZE -
	    				     2 * SMBIOS_EPS_SEARCH_INCREMENT;
    	while (SMBiosVirtualAddress < SearchEnd)
	    {
    	    SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)SMBiosVirtualAddress;
	        DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)SMBiosVirtualAddress;
	    
     	    //
	        //	The string matching below probably needs to be changed.
    	    //	Strictly speaking, both anchor striungs "_SM_" and
	        //	"_DMI_" need to be present as per standards. "Rumors"
    	    //	abound that non-standard implementations in terms of the
    	    //	anchor string abound, so we need to check for both
	        //   _DMI_ and _SM_
            // First check for _DMI_ anchor string
            if ((DMIBiosEPSHeader->Signature2[0] == '_') &&
                (DMIBiosEPSHeader->Signature2[1] == 'D') &&	       
                (DMIBiosEPSHeader->Signature2[2] == 'M') &&       
                (DMIBiosEPSHeader->Signature2[3] == 'I') &&       
                (DMIBiosEPSHeader->Signature2[4] == '_'))
            {
#if DBG               
                KdPrint(("WBEM: Found possible DMIBIOS EPS Header at %x\n", SMBiosEPSHeader));
#endif           
                CheckLength = sizeof(DMIBIOS_EPS_HEADER);
            } 
       
            //
            // Then check for full _SM_ anchor string
            else if (SMBiosEPSHeader->Signature[0] == '_' && 
                     SMBiosEPSHeader->Signature[1] == 'S' &&
                     SMBiosEPSHeader->Signature[2] == 'M' && 
                     SMBiosEPSHeader->Signature[3] == '_' &&
                     SMBiosEPSHeader->Length >= sizeof(SMBIOS_EPS_HEADER) &&
                     SMBiosEPSHeader->Signature2[0] == '_' && 
                     SMBiosEPSHeader->Signature2[1] == 'D' &&
                     SMBiosEPSHeader->Signature2[2] == 'M' && 
                     SMBiosEPSHeader->Signature2[3] == 'I' &&
                     SMBiosEPSHeader->Signature2[4] == '_' )

            {
#if DBG               
                KdPrint(("WBEM: Found possible SMBIOS EPS Header at %x\n", SMBiosEPSHeader));
#endif           
                CheckLength = SMBiosEPSHeader->Length;	       
                DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)&SMBiosEPSHeader->Signature2[0];
            } else {
                //
                // Did not find anchor string, go search next paragraph
                SMBiosVirtualAddress += SMBIOS_EPS_SEARCH_INCREMENT;
                continue;
            }
       
            //
            // Verify anchor string with checksum
            CheckSum = 0;
            for (i = 0; i < CheckLength ; i++) 
            {
                CheckSum += SMBiosVirtualAddress[i];
            }
       
            if (CheckSum == 0) 
            {
#if DBG               
                KdPrint(("WBEM: Found SMBIOS EPS Header at %x\n", SMBiosEPSHeader));
#endif           
                Found = TRUE;
                SMBiosTableLength = DMIBiosEPSHeader->StructureTableLength;
                SMBiosPhysicalAddress.HighPart = 0;
                SMBiosPhysicalAddress.LowPart = DMIBiosEPSHeader->StructureTableAddress;
				RtlInitUnicodeString(&FileName, SMBIOSEPSFILE);

	            SMBiosOpenAndWriteFile(
		    		SMBiosVirtualAddress,
			    	CheckLength,
					&FileName
				);
    	        break;
            }
	   
            SMBiosVirtualAddress += SMBIOS_EPS_SEARCH_INCREMENT;        
        }
	
        MmUnmapIoSpace(BiosVirtualAddress, SMBIOS_EPS_SEARCH_SIZE);
    }

    if ( Found )
    {
#if DBG
        KdPrint(("WBEM:Found SMBIOS Header and the checksum matched\n"));
#endif
    	SMBiosVirtualAddress = MmMapIoSpace(SMBiosPhysicalAddress,
                                            SMBiosTableLength,
                                            MmCached);

        if (SMBiosVirtualAddress != NULL)
    	{
			RtlInitUnicodeString(&FileName, SMBIOSDATFILE);

            SMBiosOpenAndWriteFile(
	    		SMBiosVirtualAddress,
		    	SMBiosTableLength,
				&FileName
			);
            MmUnmapIoSpace(SMBiosVirtualAddress, SMBiosTableLength);
        } else {
            SMBiosOpenAndWriteFile((PUCHAR)&i, sizeof(ULONG), &FileName);
    	}
    }
    else
    {
#if DBG
        KdPrint(("WBEM:Did not find SMBIOS data via scanning\n"));
        // Open & write a 4 byte long file. This serves a number of purposes
        // One is that we know the SMBiosOpenAndWriteFile function works. It 
		// also tells the SMBIOS provider that this is a machine where the 
		// driver did not manage to get SMBIOS data
#endif

		RtlInitUnicodeString(&FileName, SMBIOSDATFILE);
		SMBiosOpenAndWriteFile((PUCHAR)&i, sizeof(ULONG), &FileName);
    }
}

NTSTATUS
SMBiosOpenAndWriteFile(
	PUCHAR	SMBiosVirtualAddress,
	ULONG	SMBiosDataLength,
    PUNICODE_STRING FileName
	)
/*++

Routine Description:

    This routine opens & write the smbios data file

Arguments:

    fileName - The name of the file

Return Value:

    STATUS_INSUFFICIENT_RESOURCES if not enough memory for filename
         or fileimage buffer, or
    STATUS_NO_SUCH_FILE if the file cannot be opened,
    STATUS_UNSUCCESSFUL if the length of the read file is 1, or if the
         file cannot be read.
                        
    STATUS_SUCCESS otherwise.

--*/
{
   NTSTATUS ntStatus;
   IO_STATUS_BLOCK IoStatus;
   HANDLE NtFileHandle;
   OBJECT_ATTRIBUTES ObjectAttributes;


   InitializeObjectAttributes ( &ObjectAttributes,
								FileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

   ntStatus = ZwCreateFile( &NtFileHandle,
               			    SYNCHRONIZE | GENERIC_WRITE,
                            &ObjectAttributes,
                            &IoStatus,
                            NULL,                          // alloc size = none
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ,
              			    FILE_OVERWRITE_IF,
                            FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,  // eabuffer
                            0 );   // ealength

    if ( !NT_SUCCESS( ntStatus ) )
    {
#if DBG
	KdPrint(("WBEM: Error opening file %x\n", ntStatus));
#endif
        ntStatus = STATUS_NO_SUCH_FILE;
        return ntStatus;
    }

    // Opened the file. Now write to it

   ntStatus = ZwWriteFile( NtFileHandle,
                          NULL,
                          NULL,
                          NULL,
                          &IoStatus,
			  SMBiosVirtualAddress,
			  SMBiosDataLength,
                          NULL,
                          NULL );

   if( (!NT_SUCCESS(ntStatus)) )
   {
#if DBG
	    KdPrint(("WBEM:error writing file %x\n", ntStatus));
#endif
        ntStatus = STATUS_UNSUCCESSFUL;
        return ntStatus;
   }

   ZwClose( NtFileHandle );
   return STATUS_SUCCESS;
}

#if 0
   ntStatus = ZwReadFile( NtFileHandle,
                          NULL,
                          NULL,
                          NULL,
                          &IoStatus,
                          FileImage,
                          LengthOfFile,
                          NULL,
                          NULL );

   if( (!NT_SUCCESS(ntStatus)) || (IoStatus.Information != LengthOfFile) )
   {
        ZwCFDump(
            ZWCFERRORS, ("error reading file %x\n", ntStatus));
        ntStatus = STATUS_UNSUCCESSFUL;
        ExFreePool( FileImage );
        return ntStatus;
   }

   ZwClose( NtFileHandle );

   ExFreePool( FileImage );

   return ntStatus;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\smbios\smbios\precomp.h ===
//

// Copyright (c) 2000-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#include <ntddk.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\address.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: address.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "address.h"
#include <winsock.h>
#include <iomanip.h>

// this character separates the field values in a dot-notation representation
#define FIELD_SEPARATOR '.'
#define IPX_FIELD_SEPARATOR ':'


SnmpTransportIpAddress::SnmpTransportIpAddress ( IN  const UCHAR *address, IN const USHORT address_length ) 
{
    allocated = FALSE;
    is_valid = FALSE;

    if ( address_length != SNMP_IP_ADDR_LEN )
        return;

    is_valid = TRUE;

    for ( ULONG index = 0 ; index < SNMP_IP_ADDR_LEN ; index ++ )
    {
        field [ index ] = address [ index ] ;
    }
}


// sets the fields to the contents extracted from the dotted
// decimal address string in parameter
SnmpTransportIpAddress::SnmpTransportIpAddress ( IN const char *address , IN const ULONG addressResolution )
{
    allocated = FALSE;

    if ( addressResolution & SNMP_ADDRESS_RESOLVE_VALUE )
    {
        is_valid = GetIpAddress ( address ) ;
        if ( is_valid == FALSE )
        {
// Try GetHostByName

            if ( addressResolution & SNMP_ADDRESS_RESOLVE_NAME )
            {
                hostent FAR *hostEntry = gethostbyname ( address ); 
                if ( hostEntry )
                {
                    is_valid = TRUE ;
                    field [ 0 ] = ( UCHAR ) hostEntry->h_addr [ 0 ] ;
                    field [ 1 ] = ( UCHAR ) hostEntry->h_addr [ 1 ] ;
                    field [ 2 ] = ( UCHAR ) hostEntry->h_addr [ 2 ] ;
                    field [ 3 ] = ( UCHAR ) hostEntry->h_addr [ 3 ] ;
                }
            }
        }   
    }
    else if ( addressResolution & SNMP_ADDRESS_RESOLVE_NAME )
    {
        hostent FAR *hostEntry = gethostbyname ( address ); 
        if ( hostEntry )
        {
            is_valid = TRUE ;
            field [ 0 ] = ( UCHAR ) hostEntry->h_addr [ 0 ] ;
            field [ 1 ] = ( UCHAR ) hostEntry->h_addr [ 1 ] ;
            field [ 2 ] = ( UCHAR ) hostEntry->h_addr [ 2 ] ;
            field [ 3 ] = ( UCHAR ) hostEntry->h_addr [ 3 ] ;
        }
    }
}

BOOL SnmpTransportIpAddress::ValidateAddress ( IN const char *address , IN const ULONG addressResolution )
{
    BOOL is_valid = FALSE ;

    if ( addressResolution & SNMP_ADDRESS_RESOLVE_VALUE )
    {

        // create a stream to read the fields from
        istrstream address_stream((char *)address);

        // contains the maximum value for a USHORT. used
        // for comparison with the field values read
        const UCHAR max_uchar = -1;

        // consecutive fields must be separated by a
        // FIELD_SEPARATOR
        char separator;

        // a field is first read into this for comparison
        // with max_uchar
        ULONG temp_field;

        // read the first three (USHORT,FIELD_SEPARATOR) pairs
        // check if the stream is good before each read
        for(int i=0; i < (SNMP_IP_ADDR_LEN-1); i++)
        {
            if ( !address_stream.good() )
                break;

            address_stream >> temp_field;
            if ( temp_field > max_uchar )
            {
                address_stream.clear ( ios :: badbit ) ;
                break;
            }

            if ( !address_stream.good() )
                break;

            address_stream >> separator;
            if ( separator != FIELD_SEPARATOR )
            {
                address_stream.clear ( ios :: badbit ) ;
                break;
            }
        }

        if ( address_stream.good() )
        {
            address_stream >> temp_field;
            if (temp_field <= max_uchar)
            {
            // make sure that there are is nothing more left in the
            // stream

                if ( address_stream.eof() )
                {
                    is_valid = TRUE;
                }
            }
        }

        if ( ! is_valid )
        {
            if ( addressResolution & SNMP_ADDRESS_RESOLVE_NAME )
            {
                hostent FAR *hostEntry = gethostbyname ( address ); 
                if ( hostEntry )
                {
                    is_valid = TRUE ;
                }
            }
        }
    }
    else
    {
        if ( addressResolution & SNMP_ADDRESS_RESOLVE_NAME )
        {
            hostent FAR *hostEntry = gethostbyname ( address ); 
            if ( hostEntry )
            {
                is_valid = TRUE ;
            }
        }
    }

    return is_valid ;
}

BOOL SnmpTransportIpAddress::GetIpAddress ( IN const char *address )
{
    // create a stream to read the fields from
    istrstream address_stream((char *)address);

    // contains the maximum value for a USHORT. used
    // for comparison with the field values read
    const UCHAR max_uchar = -1;

    // consecutive fields must be separated by a
    // FIELD_SEPARATOR
    char separator;

    // a field is first read into this for comparison
    // with max_uchar
    ULONG temp_field;

    is_valid = FALSE;

    // read the first three (USHORT,FIELD_SEPARATOR) pairs
    // check if the stream is good before each read
    for(int i=0; i < (SNMP_IP_ADDR_LEN-1); i++)
    {
        if ( !address_stream.good() )
            break;

        address_stream >> temp_field;
        if ( temp_field > max_uchar )
        {
            address_stream.clear ( ios :: badbit ) ;
            break;
        }


        field[i] = (UCHAR)temp_field;

        if ( !address_stream.good() )
            break;

        address_stream >> separator;
        if ( separator != FIELD_SEPARATOR )
        {
            address_stream.clear ( ios :: badbit ) ;
            break;
        }
    }

    if ( address_stream.good() )
    {
        address_stream >> temp_field;
        if (temp_field <= max_uchar)
        {
            field[SNMP_IP_ADDR_LEN-1] = (UCHAR)temp_field;

        // make sure that there are is nothing more left in the
        // stream

            if ( address_stream.eof() )
            {
                is_valid = TRUE;
            }
        }
    }

    return is_valid ;
}

// set the fields to the lower 32 bits in the ULONG parameter
// in general, sets the SNMP_IP_ADDR_LEN fields, each of size 8 bits

#pragma warning (disable:4244)

SnmpTransportIpAddress::SnmpTransportIpAddress( IN const ULONG address )
{
    allocated = FALSE;

    // flag starts with the last byte on

    ULONG hostOrder = ntohl ( address ) ;

    field [ 0 ] = ( hostOrder >> 24 ) & 0xff ;
    field [ 1 ] = ( hostOrder >> 16 ) & 0xff ;
    field [ 2 ] = ( hostOrder >> 8 ) & 0xff ;
    field [ 3 ] = hostOrder & 0xff ;

    is_valid = TRUE;
}

#pragma warning (default:4244)

// free the dotted notation string if it was allocated
SnmpTransportIpAddress::~SnmpTransportIpAddress()
{
    if ( allocated )
        delete[] dotted_notation;
}

// returns the number of fields copied
USHORT SnmpTransportIpAddress::GetAddress ( OUT UCHAR *address , IN const USHORT length ) const
{
    // if the stream is valid, copy the fields onto the
    // buffer pointed to by address.
    if ( is_valid )
    {
        // only these many fields need be copied
        USHORT len = MIN(length,SNMP_IP_ADDR_LEN);

        for(int i=0; i < len; i++)
            address[i] = field[i];

        return len;
    }
    else
        return 0;
}


// prepares a dot-notation representation of the address and points 
// the dotted_notation char ptr to the allocated string.
// Note: memory for the decimal notation string is allocated only when
// the char *GetAddress method is called (and the address is valid)
// this memory must be freed if required
char *SnmpTransportIpAddress::GetAddress() 
{
    // do all this only when the address is valid
    if ( is_valid )
    {
        // if already allocated, return the stored string
        if ( allocated )
            return dotted_notation;
        else
        {
            // create a temp. output stream to prepare the char string
            dotted_notation = new char[ MAX_ADDRESS_LEN ];
            allocated = TRUE;
            sprintf ( 

                dotted_notation, 
                "%d.%d.%d.%d" , 
                (ULONG)field[0],
                (ULONG)field[1],
                (ULONG)field[2],
                (ULONG)field[3]
            );

            return dotted_notation;
        }
    }
    else
        return NULL;
}


SnmpTransportAddress *SnmpTransportIpAddress::Copy () const
{
    SnmpTransportIpAddress *new_address = new SnmpTransportIpAddress();

    if ( is_valid )
        *new_address = field;

    return new_address;
}


// checks if the two instances represent equal addresses
BOOL SnmpTransportIpAddress::operator== ( IN const SnmpTransportIpAddress & address ) const
{
    // if both the instances are valid, then a field
    // by field comparison, starting with the most
    // significant field (index 0) yields the answer
    if ( (is_valid) && address.IsValid() )
    {
        UCHAR temp[SNMP_IP_ADDR_LEN];

        address.GetAddress(temp,SNMP_IP_ADDR_LEN);
    
        for(int i=0; i < SNMP_IP_ADDR_LEN; i++)
            if ( field[i] != temp[i] )
                return FALSE;

        return TRUE;
    }
    else    // if either of them is invalid, they
            // cannot be equal
        return FALSE;
}
        

// sets the internal address to the specified parameter
// and makes the instance valid
SnmpTransportIpAddress &SnmpTransportIpAddress::operator= ( IN const UCHAR *ipAddr )
{
    if ( ipAddr == NULL )
        return *this;

    const UCHAR max_uchar = -1;

    for(int i=0; i < SNMP_IP_ADDR_LEN; i++)
    {
        if ( ipAddr[i] > max_uchar )
            return *this;

        field[i] = ipAddr[i];
    }


    is_valid = TRUE;

    // if a dotted-notation char string was prepared for the previous address
    // free the allocated memory
    if ( allocated )
    {
        delete[] dotted_notation;
        allocated = FALSE;
    }
        
    return *this;
}


// copies the specified instance (parameter) onto itself
// if the parameter instance is found valid
SnmpTransportIpAddress &SnmpTransportIpAddress::operator= ( IN const SnmpTransportIpAddress &address )
{
    const UCHAR max_uchar = -1;

    // if valid, proceed
    if (address.IsValid())
    {
        // get address fields
        address.GetAddress(field,SNMP_IP_ADDR_LEN);

        // copy the obtained fields onto local fields
        for( int i=0; i < SNMP_IP_ADDR_LEN; i++ )
            if ( field[i] > max_uchar )
                return *this;

        is_valid = TRUE;

        // since the address changes, free the previously 
        // allocated dotted-notation char string
        if ( allocated )
        {
            delete[] dotted_notation;
            allocated = FALSE;
        }
    }

    return *this;
}


// returns the field requested by the parameter index
// if the index is illegal, an OutOfRange exception is
// raised
UCHAR SnmpTransportIpAddress::operator[] ( IN const USHORT index ) const
{
    // if valid and the index is legal, return the field
    if ( (is_valid) && (BETWEEN(index,0,SNMP_IP_ADDR_LEN)) )
        return field[index];

    // should never reach here if the caller checked the index
    return 0;
}

SnmpTransportIpxAddress::SnmpTransportIpxAddress ( IN  const UCHAR *address, IN const USHORT address_length )   
{
    allocated = FALSE;
    is_valid = FALSE;

    if ( address_length != SNMP_IPX_ADDR_LEN )
        return;

    is_valid = TRUE;

    for ( ULONG index = 0 ; index < SNMP_IPX_ADDR_LEN ; index ++ )
    {
        field [ index ] = address [ index ] ;
    }
}


// sets the fields to the contents extracted from the dotted
// decimal address string in parameter
SnmpTransportIpxAddress::SnmpTransportIpxAddress ( IN const char *address )
{
    allocated = FALSE;

    is_valid = GetIpxAddress ( address )    ;
}

UCHAR HexToDecInteger ( char token ) 
{
    if ( token >= '0' && token <= '9' )
    {
        return token - '0' ;
    }
    else if ( token >= 'a' && token <= 'f' )
    {
        return token - 'a' + 10 ;
    }
    else if ( token >= 'A' && token <= 'F' )
    {
        return token - 'A' + 10 ;
    }
    else
    {
        return 0 ;
    }
}

#pragma warning (disable:4244)

BOOL SnmpTransportIpxAddress::ValidateAddress ( IN const char *address )
{
    BOOL is_valid = TRUE ;

    // create a stream to read the fields from
    istrstream address_stream((char *)address);

    address_stream.setf ( ios :: hex ) ;

    ULONG t_NetworkAddress ;
    address_stream >> t_NetworkAddress ;

    if ( address_stream.good() )
    {
    // consecutive fields must be separated by a
    // FIELD_SEPARATOR
        char separator;

        address_stream >> separator;
        if ( separator == IPX_FIELD_SEPARATOR )
        {
            ULONG t_StationOctets = 0 ;
            while ( is_valid && t_StationOctets < 6 )
            {
                int t_OctetHigh = address_stream.get () ;
                int t_OctetLow = address_stream.get () ;

                if ( isxdigit ( t_OctetHigh ) && isxdigit ( t_OctetLow ) )
                {
                    t_StationOctets ++ ;
                }
                else
                {
                    is_valid = FALSE ;
                }
            }

            if ( t_StationOctets != 6 )
            {
                is_valid = FALSE ;
            }
        }

        if ( address_stream.eof() )
        {
            is_valid = TRUE;
        }
    }
    else
    {
        is_valid = FALSE ;
    }

    return is_valid ;

}

BOOL SnmpTransportIpxAddress::GetIpxAddress ( IN const char *address )
{
    // create a stream to read the fields from
    istrstream address_stream((char *)address);

    address_stream.setf ( ios :: hex ) ;

    is_valid = TRUE ;

    ULONG t_NetworkAddress ;
    address_stream >> t_NetworkAddress ;

    if ( address_stream.good() )
    {
        field [ 0 ] = ( t_NetworkAddress >> 24 ) & 0xff ;
        field [ 1 ] = ( t_NetworkAddress >> 16 ) & 0xff ;
        field [ 2 ] = ( t_NetworkAddress >> 8 ) & 0xff ;
        field [ 3 ] = t_NetworkAddress & 0xff ;

    // consecutive fields must be separated by a
    // FIELD_SEPARATOR
        char separator;

        address_stream >> separator;
        if ( separator == IPX_FIELD_SEPARATOR )
        {
            ULONG t_StationOctets = 0 ;
            while ( is_valid && t_StationOctets < 6 )
            {
                int t_OctetHigh = address_stream.get () ;
                int t_OctetLow = address_stream.get () ;

                if ( isxdigit ( t_OctetHigh ) && isxdigit ( t_OctetLow ) )
                {
                    UCHAR t_Octet = ( HexToDecInteger ( (char)t_OctetHigh ) << 4 ) + HexToDecInteger ( (char)t_OctetLow ) ;
                    field [ 4 + t_StationOctets ] = t_Octet ;
                    t_StationOctets ++ ;
                }
                else
                {
                    is_valid = FALSE ;
                }
            }

            if ( t_StationOctets != 6 )
            {
                is_valid = FALSE ;
            }
        }

        if ( address_stream.eof() )
        {
            is_valid = TRUE;
        }
    }
    else
    {
        is_valid = FALSE ;
    }

    return is_valid ;
}

#pragma warning (default:4244)

// free the dotted notation string if it was allocated
SnmpTransportIpxAddress::~SnmpTransportIpxAddress()
{
    if ( allocated )
        delete[] dotted_notation;
}

// returns the number of fields copied
USHORT SnmpTransportIpxAddress::GetAddress ( OUT UCHAR *address , IN const USHORT length ) const
{
    // if the stream is valid, copy the fields onto the
    // buffer pointed to by address.
    if ( is_valid )
    {
        // only these many fields need be copied
        USHORT len = MIN(length,SNMP_IPX_ADDR_LEN);

        for(int i=0; i < len; i++)
            address[i] = field[i];

        return len;
    }
    else
        return 0;
}


// prepares a dot-notation representation of the address and points 
// the dotted_notation char ptr to the allocated string.
// Note: memory for the decimal notation string is allocated only when
// the char *GetAddress method is called (and the address is valid)
// this memory must be freed if required
char *SnmpTransportIpxAddress::GetAddress() 
{
    // do all this only when the address is valid
    if ( is_valid )
    {
        // if already allocated, return the stored string
        if ( allocated )
            return dotted_notation;
        else
        {
            // create a temp. output stream to prepare the char string
            char temp[MAX_ADDRESS_LEN];
            ostrstream temp_stream(temp, MAX_ADDRESS_LEN);

            // if any problems with the stream return NULL
            if ( !temp_stream.good() )
                return NULL;

            temp_stream.setf ( ios :: hex ) ;
            temp_stream.width ( 8 ) ;
            temp_stream.fill ( '0' ) ;

            ULONG t_NetworkAddress = ( field [ 0 ] << 24 ) + 
                                     ( field [ 1 ] << 16 ) + 
                                     ( field [ 2 ] << 8  ) + 
                                     ( field [ 3 ] ) ;

            // output the fields separated by the FIELD_SEPARATOR onto the output stream
            temp_stream << t_NetworkAddress << IPX_FIELD_SEPARATOR ;
;
            for(int i=SNMP_IPX_NETWORK_LEN; (temp_stream.good()) && (i < SNMP_IPX_ADDR_LEN); i++)
            {
                temp_stream.width ( 2 ) ;
                temp_stream << (ULONG)field[i];
            }

            // if any problems with the stream return NULL
            if ( !temp_stream.good() )
                return NULL;

            // end of string
            temp_stream << (char)EOS;

            // allocate the required memory and copy the prepared string onto it
            int len = strlen(temp);
            dotted_notation = new char[len+1];
            allocated = TRUE;
            strcpy(dotted_notation, temp);

            return dotted_notation;
        }
    }
    else
        return NULL;
}


SnmpTransportAddress *SnmpTransportIpxAddress::Copy () const
{
    SnmpTransportIpxAddress *new_address = new SnmpTransportIpxAddress();

    if ( is_valid )
        *new_address = field;

    return new_address;
}


// checks if the two instances represent equal addresses
BOOL SnmpTransportIpxAddress::operator== ( IN const SnmpTransportIpxAddress & address ) const
{
    // if both the instances are valid, then a field
    // by field comparison, starting with the most
    // significant field (index 0) yields the answer
    if ( (is_valid) && address.IsValid() )
    {
        UCHAR temp[SNMP_IPX_ADDR_LEN];

        address.GetAddress(temp,SNMP_IPX_ADDR_LEN);
    
        for(int i=0; i < SNMP_IPX_ADDR_LEN; i++)
            if ( field[i] != temp[i] )
                return FALSE;

        return TRUE;
    }
    else    // if either of them is invalid, they
            // cannot be equal
        return FALSE;
}
        

// sets the internal address to the specified parameter
// and makes the instance valid
SnmpTransportIpxAddress &SnmpTransportIpxAddress::operator= ( IN const UCHAR *ipAddr )
{
    if ( ipAddr == NULL )
        return *this;

    const UCHAR max_uchar = -1;

    for(int i=0; i < SNMP_IPX_ADDR_LEN; i++)
    {
        if ( ipAddr[i] > max_uchar )
            return *this;

        field[i] = ipAddr[i];
    }


    is_valid = TRUE;

    // if a dotted-notation char string was prepared for the previous address
    // free the allocated memory
    if ( allocated )
    {
        delete[] dotted_notation;
        allocated = FALSE;
    }
        
    return *this;
}


// copies the specified instance (parameter) onto itself
// if the parameter instance is found valid
SnmpTransportIpxAddress &SnmpTransportIpxAddress::operator= ( IN const SnmpTransportIpxAddress &address )
{
    const UCHAR max_uchar = -1;

    // if valid, proceed
    if (address.IsValid())
    {
        // get address fields
        address.GetAddress(field,SNMP_IPX_ADDR_LEN);

        // copy the obtained fields onto local fields
        for( int i=0; i < SNMP_IPX_ADDR_LEN; i++ )
            if ( field[i] > max_uchar )
                return *this;

        is_valid = TRUE;

        // since the address changes, free the previously 
        // allocated dotted-notation char string
        if ( allocated )
        {
            delete[] dotted_notation;
            allocated = FALSE;
        }
    }

    return *this;
}


// returns the field requested by the parameter index
// if the index is illegal, an OutOfRange exception is
// raised
UCHAR SnmpTransportIpxAddress::operator[] ( IN const USHORT index ) const
{
    // if valid and the index is legal, return the field
    if ( (is_valid) && (BETWEEN(index,0,SNMP_IPX_ADDR_LEN)) )
        return field[index];

    // should never reach here if the caller checked the index
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\dummy.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: dummy.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "error.h"
#include "encdec.h"
#include "sec.h"
#include "vblist.h"
#include "pdu.h"
#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"
#include "session.h"

// over-rides the HandleEvent method provided by the
// WinSnmpSession. Alerts the owner of a sent frame event

LONG_PTR SessionWindow::HandleEvent (

    HWND hWnd ,
    UINT message ,
    WPARAM wParam ,
    LPARAM lParam
)
{
    LONG rc = 0;

    // check if the message needs to be handled

    if ( message == Window :: g_SentFrameEvent )
    {
        // inform the owner of a sent frame event

        owner.HandleSentFrame ( 

            ( SessionFrameId ) wParam 
        ) ;
    }
    else if ( message == Window :: g_DeleteSessionEvent )
    {
        // inform the owner of the event

        owner.HandleDeletionEvent () ;
    }
    else
    {
        return Window::HandleEvent(

            hWnd, 
            message, 
            wParam, 
            lParam
        );
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\encdec.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: encdec.cpp
Written By: S.Menzies
----------------------------------------------------------*/

#include "precomp.h"
#include <winsock2.h>
#include "common.h"
#include "sync.h"
#include "encap.h"
#include "value.h"
#include "vblist.h"
#include "vbl.h"
#include "fs_reg.h"
#include "error.h"
#include "encdec.h"
#include "sec.h"
#include "pdu.h"
#include "pseudo.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "ophelp.h"
#include "op.h"
#include "tsess.h"

const WinSnmpInteger winsnmp_pdu_type[] = {SNMP_PDU_GET, SNMP_PDU_GETNEXT, SNMP_PDU_SET};
const ULONG num_pdus = sizeof(winsnmp_pdu_type)/sizeof(WinSnmpInteger);

CriticalSection SnmpEncodeDecode :: s_CriticalSection;

void FreeDescriptor ( smiVALUE &a_Value )
{
    switch ( a_Value.syntax )
    {
        case SNMP_SYNTAX_OCTETS :
        case SNMP_SYNTAX_BITS :
        case SNMP_SYNTAX_OPAQUE :
        case SNMP_SYNTAX_IPADDR :
        case SNMP_SYNTAX_NSAPADDR :
        {
            SnmpFreeDescriptor ( 

                SNMP_SYNTAX_OCTETS ,
                & a_Value.value.string
            ) ;
        }
        break ;

        case SNMP_SYNTAX_OID :
        {
            SnmpFreeDescriptor (

                SNMP_SYNTAX_OID, 
                (smiOCTETS *)(&a_Value.value.oid)
            );
        }
        break ;

        default:
        {
        }
        break ;
    }
}


// returns an SnmpVarBind containing an SnmpObjectIdentifier and an
// SnmpValue created using the instance(OID) and the value(VALUE)
SnmpVarBind *GetVarBind (

    IN smiOID &instance,
    IN smiVALUE &value
)
{
    // create an SnmpObjectIdentifier using the instance value
    SnmpObjectIdentifier id(instance.ptr, instance.len);
    SnmpValue *snmp_value = NULL;

    // for each possible value for value.syntax, create the
    // corresponding SnmpValue

    switch(value.syntax)
    {
        case SNMP_SYNTAX_NULL:      // null value
        {
            snmp_value = new SnmpNull();
        }
        break;

        case SNMP_SYNTAX_INT:       // integer *(has same value as SNMP_SYNTAX_INT32)*
        {
            snmp_value = new SnmpInteger(value.value.sNumber);
        }
        break;

        case SNMP_SYNTAX_UINT32:        // integer *(has same value as SNMP_SYNTAX_GAUGE)*
        {
            snmp_value = new SnmpUInteger32(value.value.uNumber);
        }
        break;

        case SNMP_SYNTAX_CNTR32:    // counter32
        {
            snmp_value = new SnmpCounter (value.value.uNumber);
        }
        break;

        case SNMP_SYNTAX_GAUGE32:   // gauge
        {
            snmp_value = new SnmpGauge(value.value.uNumber);
        }
        break;
            
        case SNMP_SYNTAX_TIMETICKS: // time ticks
        {
            snmp_value = new SnmpTimeTicks(value.value.uNumber);
        }
        break;

        case SNMP_SYNTAX_OCTETS:    // octets
        {
            snmp_value = new SnmpOctetString(value.value.string.ptr,
                                             value.value.string.len);
        }
        break;

        case SNMP_SYNTAX_OPAQUE:    // opaque value
        {
            snmp_value = new SnmpOpaque(value.value.string.ptr,
                                        value.value.string.len);
        }
        break;

        case SNMP_SYNTAX_OID:       // object identifier
        {
            snmp_value = new SnmpObjectIdentifier(value.value.oid.ptr,
                                                  value.value.oid.len);
        }
        break;

        case SNMP_SYNTAX_IPADDR:    // ip address value
        {
            if ( value.value.string.ptr )
            {
                snmp_value = new SnmpIpAddress(ntohl(*((ULONG *)value.value.string.ptr)));
            }
            else
            {
                snmp_value = new SnmpNull();
            }
        }
        break;

        case SNMP_SYNTAX_CNTR64:    // counter64
        {
            snmp_value = new SnmpCounter64 (value.value.hNumber.lopart , value.value.hNumber.hipart );
        }
        break;

        case SNMP_SYNTAX_NOSUCHOBJECT:
        {
            snmp_value = new SnmpNoSuchObject ;
        }
        break ;

        case SNMP_SYNTAX_NOSUCHINSTANCE:
        {
            snmp_value = new SnmpNoSuchInstance ;
        }
        break ;

        case SNMP_SYNTAX_ENDOFMIBVIEW:
        {
            snmp_value = new SnmpEndOfMibView ;
        }
        break ;

        default:
        {
            // it must be an unsupported type 
            // return an SnmpNullValue by default
            snmp_value = new SnmpNull();
        
        }
        break;
    };

    SnmpVarBind *var_bind = NULL ;

    if ( snmp_value ) 
    {
        var_bind = new SnmpVarBind(id, *snmp_value);
    }

    delete snmp_value;

    return var_bind;
}

void GetOID(OUT smiOID &oid, IN SnmpObjectIdentifier &instance)
{
    // determine length
    oid.len = instance.GetValueLength();

    // allocate space
    oid.ptr = new smiUINT32[oid.len];

    // copy the identifier values
    ULONG *value = instance.GetValue();

    for(UINT i=0; i < oid.len; i++)
        oid.ptr[i] = value[i];
}

// returns a winsnmp VALUE in the value OUT parameter corresponding
// to the specified snmp_value. makes use of run-time type information
// for the purpose
void GetValue(OUT smiVALUE &value, IN SnmpValue &snmp_value)
{
    // for each SnmpValue type, check if it is a pointer
    // to the derived type. If so, fill in the smiValue
    // and return

    SnmpNull *null_value = dynamic_cast<SnmpNull *>(&snmp_value);

    if ( null_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_NULL;

        return;
    }

    SnmpInteger *integer_value = dynamic_cast<SnmpInteger *>(&snmp_value);

    if ( integer_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_INT;

        value.value.sNumber = integer_value->GetValue();

        return;
    }

    SnmpGauge *gauge_value = dynamic_cast<SnmpGauge *>(&snmp_value);

    if ( gauge_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_GAUGE32;

        value.value.uNumber = gauge_value->GetValue();

        return;
    }

    SnmpCounter *counter_value = dynamic_cast<SnmpCounter *>(&snmp_value);

    if ( counter_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_CNTR32;

        value.value.uNumber = counter_value->GetValue();

        return;
    }

    SnmpTimeTicks *timeTicks_value = dynamic_cast<SnmpTimeTicks *>(&snmp_value);

    if ( timeTicks_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_TIMETICKS;

        value.value.uNumber = timeTicks_value->GetValue();

        return;
    }

    SnmpOpaque *opaque_value = dynamic_cast<SnmpOpaque *>(&snmp_value);

    if ( opaque_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_OPAQUE;

        value.value.string.len = opaque_value->GetValueLength();
        value.value.string.ptr = new smiBYTE[value.value.string.len];

        UCHAR *source = opaque_value->GetValue();

        for(UINT i=0; i < value.value.string.len; i++)
            value.value.string.ptr[i] = source[i];

        return;
    }

    SnmpOctetString *string_value = dynamic_cast<SnmpOctetString *>(&snmp_value);

    if ( string_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_OCTETS;

        value.value.string.len = string_value->GetValueLength();
        value.value.string.ptr = new smiBYTE[value.value.string.len];

        UCHAR *source = string_value->GetValue();

        for(UINT i=0; i < value.value.string.len; i++)
            value.value.string.ptr[i] = source[i];

        return;
    }

    SnmpObjectIdentifier *oid_value = dynamic_cast<SnmpObjectIdentifier *>(&snmp_value);

    if ( oid_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_OID;

        GetOID(value.value.oid, *oid_value);

        return;
    }

    SnmpIpAddress *ip_address_value = dynamic_cast<SnmpIpAddress *>(&snmp_value);

    if ( ip_address_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_IPADDR;
        value.value.string.len = IP_ADDR_LEN;
        value.value.string.ptr = new smiBYTE[IP_ADDR_LEN];

        ULONG address = htonl ( ip_address_value->GetValue() ) ;
        UCHAR *t_Address = ( UCHAR * ) & address ;

        for(int i=IP_ADDR_LEN-1; i >= 0; i--)
        {
            value.value.string.ptr[i] = t_Address [ i ] ;
        }

        return;
    }

    SnmpUInteger32 *uinteger32_value = dynamic_cast<SnmpUInteger32 *>(&snmp_value);

    if ( uinteger32_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_UINT32;

        value.value.uNumber = uinteger32_value->GetValue();

        return;
    }

    SnmpCounter64 *counter64_value = dynamic_cast<SnmpCounter64 *>(&snmp_value);

    if ( counter64_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_CNTR64;

        value.value.hNumber.lopart = counter64_value->GetLowValue();
        value.value.hNumber.hipart = counter64_value->GetHighValue();

        return;
    }

    SnmpEndOfMibView *endofmibview_value = dynamic_cast<SnmpEndOfMibView *>(&snmp_value);

    if ( endofmibview_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_ENDOFMIBVIEW;

        return;
    }

    SnmpNoSuchObject *nosuchobject_value = dynamic_cast<SnmpNoSuchObject *>(&snmp_value);

    if ( nosuchobject_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_NOSUCHOBJECT;

        return;
    }

    SnmpNoSuchInstance *nosuchinstance_value = dynamic_cast<SnmpNoSuchInstance *>(&snmp_value);

    if ( nosuchinstance_value != NULL )
    {
        value.syntax = SNMP_SYNTAX_NOSUCHINSTANCE;

        return;
    }

    // we should not have come here 
    // did we check all supported types?
    throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);
}

void LocalFreeVb(IN smiOID &oid, IN smiVALUE &value)
{
    if ( oid.len > 0 )
        delete[] oid.ptr;

    switch( value.syntax )
    {
        case SNMP_SYNTAX_OCTETS:    // octets
        case SNMP_SYNTAX_OPAQUE:    // opaque value
        case SNMP_SYNTAX_IPADDR:    // ip address value
            {
                delete[] value.value.string.ptr;
                break;
            }

        case SNMP_SYNTAX_OID:       // object identifier
            {
                delete[] value.value.oid.ptr;
                break;
            }

        default:
            break;
    };
}

void SetWinSnmpVbl(SnmpVarBindList &var_bind_list, HSNMP_VBL vbl)
{
    // reset the list
    var_bind_list.Reset();

    // for each var_bind, create a pair <oid, value> and
    // insert it into the vbl 
    while( var_bind_list.Next() )
    {
        const SnmpVarBind *var_bind = var_bind_list.Get();

        smiOID instance;
        GetOID(instance, var_bind->GetInstance());

        smiVALUE value;
        GetValue(value, var_bind->GetValue());

        // insert a new var bind
        SnmpSetVb(vbl, 0, &instance, &value);

        LocalFreeVb(instance, value);
    }
}

BOOL DecodeVarBindList ( 

    HSNMP_VBL a_Vbl , 
    SnmpVarBindList &a_SnmpVarBindList 
)
{
    smiINT t_VblCount = SnmpCountVbl ( a_Vbl ) ;
    for ( smiINT t_Count = 1 ; t_Count <= t_VblCount ; t_Count ++ )
    {
        smiOID t_Instance;
        smiVALUE t_Value;

        SNMPAPI_STATUS t_Status = SnmpGetVb (

            a_Vbl, 
            t_Count, 
            & t_Instance, 
            & t_Value
        ) ;

        if ( t_Status == SNMPAPI_FAILURE )
        {
            return FALSE ;
        }

        SnmpVarBind *t_VarBind = GetVarBind ( t_Instance , t_Value ) ;
        if ( ! t_VarBind )
        {
            SnmpFreeDescriptor (

                SNMP_SYNTAX_OID,
                (smiOCTETS *) & t_Instance
            ) ;

            return FALSE ;          
        }

        a_SnmpVarBindList.AddNoReallocate ( *t_VarBind ) ;

        SnmpFreeDescriptor (

            SNMP_SYNTAX_OID,
            (smiOCTETS *) & t_Instance
        ) ;

        FreeDescriptor ( t_Value ) ;
    }

    return TRUE ;
}

BOOL SnmpEncodeDecode :: DestroyStaticComponents ()
{
    return TRUE ;
}

BOOL SnmpEncodeDecode :: InitializeStaticComponents ()
{
    return TRUE ;
}

SnmpEncodeDecode :: SnmpEncodeDecode () : m_IsValid ( FALSE ) , m_Session ( NULL ) , m_Window ( NULL )
{
    Window *t_Window = new Window ;
    m_Window = t_Window ;
}

SnmpEncodeDecode :: ~SnmpEncodeDecode () 
{
    if ( m_IsValid )
    {
        HSNMP_SESSION t_Session = ( HSNMP_SESSION ) m_Session ;
        SnmpClose ( t_Session ) ;
    }

    Window *t_Window = ( Window * ) m_Window ;

    delete t_Window ;
}

BOOL SnmpEncodeDecode :: EncodeFrame (

    OUT SnmpPdu &a_SnmpPdu ,
    IN RequestId a_RequestId,
    IN PduType a_PduType,
    IN SnmpErrorReport &a_SnmpErrorReport ,
    IN SnmpVarBindList &a_SnmpVarBindList,
    IN SnmpCommunityBasedSecurity *&a_SnmpCommunityBasedSecurity ,
    IN SnmpTransportAddress *&a_SrcTransportAddress ,
    IN SnmpTransportAddress *&a_DstTransportAddress
) 
{
    a_SnmpPdu.SetRequestId ( a_RequestId ) ;
    a_SnmpPdu.SetPduType ( a_PduType ) ;
    a_SnmpPdu.SetErrorReport ( a_SnmpErrorReport ) ;
    a_SnmpPdu.SetVarBindList ( a_SnmpVarBindList ) ;

    if ( a_SnmpCommunityBasedSecurity )
        a_SnmpPdu.SetCommunityName ( *a_SnmpCommunityBasedSecurity ) ;

    if ( a_SrcTransportAddress )
        a_SnmpPdu.SetSourceAddress ( *a_SrcTransportAddress ) ;

    if ( a_DstTransportAddress )
        a_SnmpPdu.SetDestinationAddress ( *a_DstTransportAddress ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: DecodeFrame (

    IN SnmpPdu &a_SnmpPdu ,
    OUT RequestId a_RequestId,
    OUT PduType a_PduType ,
    OUT SnmpErrorReport &a_SnmpErrorReport ,
    OUT SnmpVarBindList *&a_SnmpVarBindList ,
    OUT SnmpCommunityBasedSecurity *&a_SnmpCommunityBasedSecurity ,
    OUT SnmpTransportAddress *&a_SrcTransportAddress ,
    OUT SnmpTransportAddress *&a_DstTransportAddress 
) 
{
    a_SrcTransportAddress = & a_SnmpPdu.GetSourceAddress ();
    a_DstTransportAddress = & a_SnmpPdu.GetDestinationAddress () ;
    a_PduType = a_SnmpPdu.GetPduType () ;
    a_RequestId = a_SnmpPdu.GetRequestId () ;
    a_SnmpVarBindList = & a_SnmpPdu.GetVarbindList () ;
    a_SnmpCommunityBasedSecurity = & a_SnmpPdu.GetCommunityName () ;
    a_SnmpErrorReport = a_SnmpPdu.GetErrorReport () ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: EncodeFrame (

    IN SnmpPdu &a_SnmpPdu ,
    OUT void *a_ImplementationEncoding 
) 
{
    WinSnmpVariables *t_WinSnmpVariables = ( WinSnmpVariables * ) a_ImplementationEncoding ;

    RequestId t_SnmpRequestId = a_SnmpPdu.GetRequestId () ;
    PduType t_SnmpPduType = a_SnmpPdu.GetPduType () ;
    SnmpErrorReport &t_SnmpErrorReport = a_SnmpPdu.GetErrorReport () ;
    SnmpCommunityBasedSecurity &t_SnmpCommunityBasedSecurity = a_SnmpPdu.GetCommunityName () ;
    SnmpVarBindList &t_SnmpVarBindList = a_SnmpPdu.GetVarbindList () ;
    SnmpTransportAddress &t_SrcTransportAddress = a_SnmpPdu.GetSourceAddress () ;
    SnmpTransportAddress &t_DstTransportAddress = a_SnmpPdu.GetDestinationAddress () ;

    if ( ! m_IsValid )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    HSNMP_SESSION t_Session = ( HSNMP_SESSION ) m_Session ;

    HSNMP_VBL t_Vbl = SnmpCreateVbl ( t_Session , NULL , NULL ) ;
    if ( t_Vbl == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ( ( HSNMP_SESSION ) m_Session ) 
        ) ;
    }

    SetWinSnmpVbl ( t_SnmpVarBindList , t_Vbl ) ;

    smiINT t_RequestId = t_SnmpRequestId ;
    smiINT t_PduType = winsnmp_pdu_type[t_SnmpPduType] ;
    smiINT t_ErrorStatus = t_SnmpErrorReport.GetStatus () ;
    smiINT t_ErrorIndex = t_SnmpErrorReport.GetIndex () ;

    HSNMP_PDU t_Pdu ;
    t_Pdu = SnmpCreatePdu ( 

        t_Session, 
        t_PduType, 
        t_RequestId, 
        t_ErrorStatus, 
        t_ErrorIndex , 
        t_Vbl
    );

    if ( t_Pdu == SNMPAPI_FAILURE )
    {
        SnmpFreeVbl ( t_Vbl ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ( ( HSNMP_SESSION ) m_Session ) 
        ) ;
    }

    CriticalSectionLock t_CriticalSectionLock ( s_CriticalSection ) ;

    SnmpOctetString t_OctetString ( NULL , 0 ) ;
    t_SnmpCommunityBasedSecurity.GetCommunityName ( t_OctetString ) ;

    smiOCTETS t_Name;
    t_Name.len = t_OctetString.GetValueLength () ;
    t_Name.ptr = t_OctetString.GetValue () ;

    HSNMP_CONTEXT t_Context ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    SetTranslateMode () ;

    t_Context = SnmpStrToContext (

        t_Session,
        &t_Name
    ) ;

    t_CriticalSectionLock.UnLock () ;

    if ( t_Context == SNMPAPI_FAILURE )
    {
        SnmpFreePdu ( t_Pdu ) ;
        SnmpFreeVbl ( t_Vbl ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (t_Session) 
        );
    }

    t_WinSnmpVariables->m_RequestId = t_RequestId;
    t_WinSnmpVariables->m_Pdu = t_Pdu ;
    t_WinSnmpVariables->m_Vbl = t_Vbl ;
    t_WinSnmpVariables->m_SrcEntity = NULL ;
    t_WinSnmpVariables->m_DstEntity = NULL ;
    t_WinSnmpVariables->m_Context = t_Context ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: DecodeFrame (

    IN void *a_ImplementationEncoding ,
    OUT SnmpPdu &a_SnmpPdu
) 
{
    WinSnmpVariables *t_WinSnmpVariables = ( WinSnmpVariables * ) a_ImplementationEncoding ;

    RequestId t_SnmpRequestId ;
    PduType t_SnmpPduType ;
    SnmpErrorReport t_SnmpErrorReport ;
    SnmpCommunityBasedSecurity *t_SnmpCommunityBasedSecurity ;
    SnmpVarBindList *t_SnmpVarBindList ;
    SnmpTransportAddress *t_SrcTransportAddress ;
    SnmpTransportAddress *t_DstTransportAddress ;

    if ( ! m_IsValid )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }


    HSNMP_ENTITY t_SrcEntity = t_WinSnmpVariables->m_SrcEntity ;
    HSNMP_ENTITY t_DstEntity = t_WinSnmpVariables->m_DstEntity ;
    HSNMP_CONTEXT t_Context = t_WinSnmpVariables->m_Context ;
    HSNMP_PDU t_Pdu = t_WinSnmpVariables->m_Pdu ;

    smiOCTETS t_Community ; 
    SNMPAPI_STATUS t_Status = SnmpContextToStr (

        t_Context , 
        &t_Community 
    );

    if (SNMPAPI_FAILURE == t_Status)
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    t_SnmpCommunityBasedSecurity = new SnmpCommunityBasedSecurity ;

    SnmpOctetString t_SnmpOctetString ( t_Community.ptr , t_Community.len ) ;

    SnmpFreeDescriptor ( SNMP_SYNTAX_OCTETS, &t_Community );

    t_SnmpCommunityBasedSecurity->SetCommunityName ( t_SnmpOctetString ) ;

    if ( t_SrcEntity )
    {
        char buff[MAX_ADDRESS_LEN];
        t_Status = SnmpEntityToStr(t_SrcEntity, MAX_ADDRESS_LEN, (LPSTR)buff);
        if (SNMPAPI_FAILURE == t_Status)
        {
            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError (( HSNMP_SESSION)m_Session) 
            );
        }

        SnmpTransportIpAddress *t_SrcIpAddress = new SnmpTransportIpAddress (buff, SNMP_ADDRESS_RESOLVE_VALUE);

        if (t_SrcIpAddress->IsValid())
        {
            t_SrcTransportAddress = t_SrcIpAddress ;
        }
        else
        {
            delete t_SrcIpAddress ;

            SnmpTransportIpxAddress *t_SrcIpxAddress = new SnmpTransportIpxAddress (buff);

            if (t_SrcIpxAddress->IsValid())
            {
                t_SrcTransportAddress = t_SrcIpxAddress ;
            }   
            else
            {
                delete t_SrcIpxAddress ;

                throw GeneralException (

                    Snmp_Error, 
                    Snmp_Local_Error,
                    __FILE__,
                    __LINE__,
                    SnmpGetLastError (( HSNMP_SESSION)m_Session) 
                );
            }
        }
    }

    if ( t_DstEntity )
    {
        char buff[MAX_ADDRESS_LEN];
        t_Status = SnmpEntityToStr(t_DstEntity, MAX_ADDRESS_LEN, (LPSTR)buff);
        if (SNMPAPI_FAILURE == t_Status)
        {
            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError (( HSNMP_SESSION)m_Session) 
            );
        }

        SnmpTransportIpAddress *t_DstIpAddress = new SnmpTransportIpAddress (buff, SNMP_ADDRESS_RESOLVE_VALUE);

        if (t_DstIpAddress->IsValid())
        {
            t_DstTransportAddress = t_DstIpAddress ;
        }
        else
        {
            delete t_DstIpAddress ;

            SnmpTransportIpxAddress *t_DstIpxAddress = new SnmpTransportIpxAddress (buff);

            if (t_DstIpxAddress->IsValid())
            {
                t_DstTransportAddress = t_DstIpxAddress ;
            }   
            else
            {
                delete t_DstIpxAddress ;

                throw GeneralException (

                    Snmp_Error, 
                    Snmp_Local_Error,
                    __FILE__,
                    __LINE__,
                    SnmpGetLastError (( HSNMP_SESSION)m_Session) 
                );
            }
        }
    }
    
    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session)
        ) ;
    }

    if ( t_PduType == SNMP_PDU_GET )
    {
        t_SnmpPduType = GET ;
    }
    else if ( t_PduType == SNMP_PDU_SET )
    {
        t_SnmpPduType = SET ;
    }
    else if ( t_PduType == SNMP_PDU_GETNEXT )
    {
        t_SnmpPduType = GETNEXT ;
    }
    else if ( t_PduType == SNMP_PDU_RESPONSE )
    {
        t_SnmpPduType = RESPONSE ;
    }

    t_SnmpRequestId = t_RequestId ;

    t_SnmpErrorReport.SetStatus ( ( SnmpStatus ) t_ErrorStatus ) ;
    t_SnmpErrorReport.SetIndex ( t_ErrorIndex ) ;
    t_SnmpErrorReport.SetError ( t_ErrorStatus == SNMP_ERROR_NOERROR ? Snmp_Success : Snmp_Error ) ;

    t_SnmpVarBindList = new SnmpVarBindList ;

    if ( ! DecodeVarBindList ( t_Vbl , *t_SnmpVarBindList ) )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session)
        ) ;
    }

    a_SnmpPdu.SetRequestId ( t_SnmpRequestId ) ;
    a_SnmpPdu.SetErrorReport ( t_SnmpErrorReport ) ;
    a_SnmpPdu.SetSourceAddress ( *t_SrcTransportAddress ) ;
    a_SnmpPdu.SetDestinationAddress ( *t_DstTransportAddress ) ;
    a_SnmpPdu.SetVarBindList ( *t_SnmpVarBindList ) ;
    a_SnmpPdu.SetCommunityName ( *t_SnmpCommunityBasedSecurity ) ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpEncodeDecode :: DecodeFrame- received frame_id (%d) \r\n\r\n" , t_RequestId
    ) ;

    smiOCTETS t_Octets ;

    if ( SnmpEncodeMsg (

        m_Session,
        t_SrcEntity, 
        t_DstEntity,
        t_Context, 
        t_Pdu ,
        & t_Octets 

    ) != SNMPAPI_FAILURE )
    {
        ULONG t_Len = t_Octets.len ;
        UCHAR *t_Ptr = t_Octets.ptr ;

        ULONG t_RowLength = t_Len / 16 ;
        ULONG t_Remainder = t_Len % 16 ;
        
        ULONG t_Index = 0 ;
        for ( ULONG t_RowIndex = 0 ; t_RowIndex < t_RowLength ; t_RowIndex ++ )
        {
            ULONG t_StoredIndex = t_Index ;

            for ( ULONG t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%2.2lx  " , t_Ptr [ t_Index ++ ] ) ;
            }

            SnmpDebugLog :: s_SnmpDebugLog->Write ( L"        " ) ;

            for ( t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
            {
                if ( ( t_Ptr [ t_StoredIndex ] >= 0x20 ) && ( t_Ptr [ t_StoredIndex ] <= 0x7f ) ) 
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%c" , t_Ptr [ t_StoredIndex ] ) ;
                }
                else
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write (  L"." ) ;
                }

                t_StoredIndex ++ ;
            }

            SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\r\n" ) ;
        }       

        ULONG t_StoredIndex = t_Index ;
        for ( ULONG t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
        {
            if ( t_ColumnIndex < t_Remainder )
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%2.2lx  " , t_Ptr [ t_Index ++ ] ) ;
            }
            else
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write (  L"    " ) ;
            }
        }

        SnmpDebugLog :: s_SnmpDebugLog->Write ( L"        " ) ;

        for ( t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
        {
            if ( t_ColumnIndex < t_Remainder )
            {
                if ( t_Ptr [ t_StoredIndex ] >= 0x20 && t_Ptr [ t_StoredIndex ] <= 0x7f ) 
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%c" , t_Ptr [ t_StoredIndex ] ) ;
                }
                else
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write (  L"." ) ;
                }

                t_StoredIndex ++ ;
            }
        }

        SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\r\n\r\n" ) ;

        SnmpFreeDescriptor ( 

            SNMP_SYNTAX_OCTETS ,
            & t_Octets
        ) ;
    }
    else
    {
        DWORD t_LastError = SnmpGetLastError ((HSNMP_SESSION) m_Session) ;
        SnmpDebugLog :: s_SnmpDebugLog->Write ( L"Encode Failure\r\n\r\n" ) ;
    }
)

    SnmpFreeVbl ( t_Vbl ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: SetRequestId (

    IN OUT SnmpPdu &a_SnmpPdu ,
    IN RequestId a_RequestId

)
{
    return a_SnmpPdu.SetRequestId ( a_RequestId ) ;
}   

BOOL SnmpEncodeDecode :: SetVarBindList (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpVarBindList &a_SnmpVarBindList
)
{
    return a_SnmpPdu.SetVarBindList ( a_SnmpVarBindList ) ;
}


BOOL SnmpEncodeDecode :: SetCommunityName ( 

    IN SnmpPdu &a_SnmpPdu ,
    IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 

)
{
    return a_SnmpPdu.SetCommunityName ( a_SnmpCommunityBasedSecurity ) ;
}

BOOL SnmpEncodeDecode :: SetErrorReport (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpErrorReport &a_SnmpErrorReport

)
{
    return a_SnmpPdu.SetErrorReport ( a_SnmpErrorReport ) ;

}

BOOL SnmpEncodeDecode :: SetPduType (

    IN SnmpPdu &a_SnmpPdu ,
    OUT PduType a_PduType

)
{
    return a_SnmpPdu.SetPduType ( a_PduType ) ;
}

BOOL SnmpEncodeDecode :: SetSourceAddress ( 

    IN OUT SnmpPdu &a_SnmpPdu ,
    IN SnmpTransportAddress &a_TransportAddress 

)
{
    return a_SnmpPdu.SetSourceAddress ( a_TransportAddress ) ;
}

BOOL SnmpEncodeDecode :: SetDestinationAddress ( 

    IN OUT SnmpPdu &a_SnmpPdu ,
    IN SnmpTransportAddress &a_TransportAddress 

)
{
    return a_SnmpPdu.SetDestinationAddress ( a_TransportAddress ) ;
}

BOOL SnmpEncodeDecode :: GetSourceAddress ( 

    IN SnmpPdu &a_SnmpPdu ,
    SnmpTransportAddress *&a_TransportAddress
)
{
    a_TransportAddress = a_SnmpPdu.GetSourceAddress ().Copy ()  ;
    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetDestinationAddress (

    IN SnmpPdu &a_SnmpPdu ,
    SnmpTransportAddress *&a_TransportAddress
)
{
    a_TransportAddress = a_SnmpPdu.GetDestinationAddress ().Copy ()  ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetPduType (

    IN SnmpPdu &a_SnmpPdu ,
    OUT PduType &a_PduType 

)
{
    a_PduType = a_SnmpPdu.GetPduType () ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetRequestId (

    IN SnmpPdu &a_SnmpPdu ,
    RequestId &a_RequestId 
)
{
    a_RequestId = a_SnmpPdu.GetRequestId () ;
    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetErrorReport (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpErrorReport &a_SnmpErrorReport 

)
{
    a_SnmpErrorReport = a_SnmpPdu.GetErrorReport () ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetVarbindList (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpVarBindList &a_SnmpVarBindList

)
{
    a_SnmpVarBindList = a_SnmpPdu.GetVarbindList () ;
    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetCommunityName ( 

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 

)
{
    a_SnmpCommunityBasedSecurity = a_SnmpPdu.GetCommunityName () ;

    return TRUE;    
}

SnmpV1EncodeDecode::SnmpV1EncodeDecode () 
{
    try 
    {
        InitializeVariables();
    }
    catch(GeneralException exception)
    {
    }
}

SnmpV1EncodeDecode::~SnmpV1EncodeDecode(void)
{
}

void SnmpV1EncodeDecode::InitializeVariables()
{
    m_IsValid = FALSE;

    smiUINT32 t_MajorVersion = 1 ;
    smiUINT32 t_MinorVersion = 1 ;
    smiUINT32 t_Level = 2 ;
    smiUINT32 t_TranslateMode = SNMPAPI_UNTRANSLATED_V1 ;
    smiUINT32 t_RetransmitMode = SNMPAPI_OFF ;
    
    SNMPAPI_STATUS t_StartupStatus = SnmpStartup (

        &t_MajorVersion,
        &t_MinorVersion,
        &t_Level,
        &t_TranslateMode,
        &t_RetransmitMode
    );

    if ( t_StartupStatus == SNMPAPI_FAILURE )
    {
        DWORD t_LastError = SnmpGetLastError ( 0 ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

    HSNMP_SESSION t_Session ;

    t_Session = SnmpOpen (

        ( ( Window * ) m_Window ) ->GetWindowHandle (), 
        Window :: g_NullEventId 
    ) ;

    if ( t_Session == SNMPAPI_FAILURE )
    {
        DWORD t_LastError = SnmpGetLastError ( 0 ) ;

        throw GeneralException ( 

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

    m_Session = ( void * ) t_Session ;

    m_IsValid = TRUE;
}

void SnmpV1EncodeDecode :: SetTranslateMode ()
{
    SnmpSetTranslateMode ( SNMPAPI_UNTRANSLATED_V1 ) ;
}

SnmpV2CEncodeDecode::SnmpV2CEncodeDecode () 
{
    InitializeVariables();
}

SnmpV2CEncodeDecode::~SnmpV2CEncodeDecode(void)
{
}

void SnmpV2CEncodeDecode::InitializeVariables()
{
    m_IsValid = FALSE;

    smiUINT32 t_MajorVersion = 1 ;
    smiUINT32 t_MinorVersion = 1 ;
    smiUINT32 t_Level = 2 ;
    smiUINT32 t_TranslateMode = SNMPAPI_UNTRANSLATED_V2 ;
    smiUINT32 t_RetransmitMode = SNMPAPI_OFF ;
    
    SNMPAPI_STATUS t_StartupStatus = SnmpStartup (

        &t_MajorVersion,
        &t_MinorVersion,
        &t_Level,
        &t_TranslateMode,
        &t_RetransmitMode
    );

    if ( t_StartupStatus == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

    HSNMP_SESSION t_Session ;

    t_Session = SnmpOpen (

        ( ( Window * ) m_Window ) ->GetWindowHandle (), 
        Window :: g_NullEventId 
    ) ;

    if ( t_Session == SNMPAPI_FAILURE )
    {
        DWORD t_LastError = SnmpGetLastError ( 0 ) ;

        throw GeneralException ( 

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

    m_Session = ( void * ) t_Session ;

    m_IsValid = TRUE;
}

void SnmpV2CEncodeDecode :: SetTranslateMode ()
{
    SnmpSetTranslateMode ( SNMPAPI_UNTRANSLATED_V2 ) ;
}

BOOL SnmpEncodeDecode :: EncodePduFrame (

    OUT SnmpPdu &a_SnmpPdu ,
    IN RequestId a_RequestId,
    IN PduType a_PduType,
    IN SnmpErrorReport &a_SnmpErrorReport ,
    IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity ,
    IN SnmpVarBindList &a_SnmpVarBindList,
    IN SnmpTransportAddress &a_SrcTransportAddress ,
    IN SnmpTransportAddress &a_DstTransportAddress
) 
{
    if ( ! m_IsValid )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    HSNMP_SESSION t_Session = ( HSNMP_SESSION ) m_Session ;

    HSNMP_VBL t_Vbl = SnmpCreateVbl ( t_Session , NULL , NULL ) ;
    SetWinSnmpVbl ( a_SnmpVarBindList , t_Vbl ) ;
    smiOCTETS t_Buffer ;

    smiINT t_RequestId = a_RequestId ;
    smiINT t_PduType = winsnmp_pdu_type[a_PduType] ;
    smiINT t_ErrorStatus = a_SnmpErrorReport.GetStatus () ;
    smiINT t_ErrorIndex = a_SnmpErrorReport.GetIndex () ;

    HSNMP_PDU t_Pdu ;
    t_Pdu = SnmpCreatePdu ( 

        t_Session, 
        t_PduType, 
        t_RequestId, 
        t_ErrorStatus, 
        t_ErrorIndex , 
        t_Vbl
    );

    if ( t_Pdu == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ( ( HSNMP_SESSION ) m_Session ) 
        ) ;
    }

    HSNMP_ENTITY t_SrcEntity ;

    char *t_SrcAddress = a_SrcTransportAddress.GetAddress () ;

    CriticalSectionLock t_CriticalSectionLock ( s_CriticalSection ) ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    SetTranslateMode () ;

    t_SrcEntity = SnmpStrToEntity (

        t_Session ,
        t_SrcAddress
    ) ;

    t_CriticalSectionLock.UnLock () ;

    if ( t_SrcEntity == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (t_Session) 
        );
    }

    HSNMP_ENTITY t_DstEntity ;

    char *t_DstAddress = a_DstTransportAddress.GetAddress () ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    SetTranslateMode () ;

    t_DstEntity = SnmpStrToEntity ( 

        t_Session , 
        t_DstAddress
    );

    t_CriticalSectionLock.UnLock () ;

    if ( t_DstEntity == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (t_Session) 
        );
    }

    SnmpOctetString t_OctetString ( NULL , 0 ) ;
    a_SnmpCommunityBasedSecurity.GetCommunityName ( t_OctetString ) ;

    smiOCTETS t_Name;
    t_Name.len = t_OctetString.GetValueLength () ;
    t_Name.ptr = t_OctetString.GetValue () ;

    HSNMP_CONTEXT t_Context ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    SetTranslateMode () ;

    t_Context = SnmpStrToContext (

        t_Session,
        &t_Name
    ) ;

    t_CriticalSectionLock.UnLock () ;

    if ( t_Context == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (t_Session) 
        );
    }

    SNMPAPI_STATUS t_Status = SnmpEncodeMsg (

        ( HSNMP_SESSION ) m_Session, 
        ( HSNMP_ENTITY ) t_SrcEntity, 
        ( HSNMP_ENTITY ) t_DstEntity, 
        ( HSNMP_CONTEXT ) t_Context, 
        ( HSNMP_PDU ) t_Pdu, 
        &t_Buffer
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException(

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    a_SnmpPdu.SetPdu ( t_Buffer.ptr, t_Buffer.len);

    SnmpFreeDescriptor ( SNMP_SYNTAX_OCTETS , & t_Buffer ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeVbl ( t_Vbl ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreeContext ( t_Context ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: DecodePduFrame (

    IN SnmpPdu &a_SnmpPdu ,
    OUT RequestId a_RequestId,
    OUT PduType a_PduType ,
    OUT SnmpErrorReport &a_SnmpErrorReport ,
    OUT SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity ,
    OUT SnmpVarBindList &a_SnmpVarBindList ,
    OUT SnmpTransportAddress *&a_SrcTransportAddress ,
    OUT SnmpTransportAddress *&a_DstTransportAddress 
) 
{
    if ( ! m_IsValid )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    smiOCTETS t_smiOCTETS ;
    t_smiOCTETS.ptr = a_SnmpPdu.GetFrame () ;
    t_smiOCTETS.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context ;

    HSNMP_PDU t_Pdu;
    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        ( HSNMP_SESSION ) m_Session,
        &t_SrcEntity, 
        &t_DstEntity, 
        &t_Context , 
        &t_Pdu, 
        &t_smiOCTETS
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    smiOCTETS t_Community ; 
    t_Status = SnmpContextToStr (

        t_Context , 
        &t_Community 
    );

    if (SNMPAPI_FAILURE == t_Status)
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    SnmpOctetString t_SnmpOctetString ( t_Community.ptr , t_Community.len ) ;

    SnmpFreeDescriptor ( SNMP_SYNTAX_OCTETS, &t_Community );

    a_SnmpCommunityBasedSecurity.SetCommunityName ( t_SnmpOctetString ) ;

    if ( t_SrcEntity )
    {
        char buff[MAX_ADDRESS_LEN];
        t_Status = SnmpEntityToStr(t_SrcEntity, MAX_ADDRESS_LEN, (LPSTR)buff);
        if (SNMPAPI_FAILURE == t_Status)
        {
            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError (( HSNMP_SESSION)m_Session) 
            );
        }

        SnmpTransportIpAddress *t_SrcIpAddress = new SnmpTransportIpAddress (buff, SNMP_ADDRESS_RESOLVE_VALUE);

        if (t_SrcIpAddress->IsValid())
        {
            a_SrcTransportAddress = t_SrcIpAddress ;
        }
        else
        {
            delete t_SrcIpAddress ;

            SnmpTransportIpxAddress *t_SrcIpxAddress = new SnmpTransportIpxAddress (buff);

            if (t_SrcIpxAddress->IsValid())
            {
                a_SrcTransportAddress = t_SrcIpxAddress ;
            }   
            else
            {
                delete t_SrcIpxAddress ;

                throw GeneralException (

                    Snmp_Error, 
                    Snmp_Local_Error,
                    __FILE__,
                    __LINE__,
                    SnmpGetLastError (( HSNMP_SESSION)m_Session) 
                );
            }
        }
    }

    if ( t_DstEntity )
    {
        char buff[MAX_ADDRESS_LEN];
        t_Status = SnmpEntityToStr(t_DstEntity, MAX_ADDRESS_LEN, (LPSTR)buff);
        if (SNMPAPI_FAILURE == t_Status)
        {
            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError (( HSNMP_SESSION)m_Session) 
            );
        }

        SnmpTransportIpAddress *t_DstIpAddress = new SnmpTransportIpAddress (buff, SNMP_ADDRESS_RESOLVE_VALUE);

        if (t_DstIpAddress->IsValid())
        {
            a_DstTransportAddress = t_DstIpAddress ;
        }
        else
        {
            delete t_DstIpAddress ;

            SnmpTransportIpxAddress *t_DstIpxAddress = new SnmpTransportIpxAddress (buff);

            if (t_DstIpxAddress->IsValid())
            {
                a_DstTransportAddress = t_DstIpxAddress ;
            }   
            else
            {
                delete t_DstIpxAddress ;

                throw GeneralException (

                    Snmp_Error, 
                    Snmp_Local_Error,
                    __FILE__,
                    __LINE__,
                    SnmpGetLastError (( HSNMP_SESSION)m_Session) 
                );
            }
        }
    }
    
    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session)
        ) ;
    }

    if ( t_PduType == SNMP_PDU_GET )
    {
        a_PduType = GET ;
    }
    else if ( t_PduType == SNMP_PDU_SET )
    {
        a_PduType = SET ;
    }
    else if ( t_PduType == SNMP_PDU_GETNEXT )
    {
        a_PduType = GETNEXT ;
    }
    else if ( t_PduType == SNMP_PDU_RESPONSE )
    {
        a_PduType = RESPONSE ;
    }


    a_RequestId = t_RequestId ;

    a_SnmpErrorReport.SetStatus ( ( SnmpStatus ) t_ErrorStatus ) ;
    a_SnmpErrorReport.SetIndex ( t_ErrorIndex ) ;
    a_SnmpErrorReport.SetError ( Snmp_Success ) ;

    if ( ! DecodeVarBindList ( t_Vbl , a_SnmpVarBindList ) )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session)
        ) ;
    }

    SnmpFreeVbl ( t_Vbl ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: SetPduRequestId (

    IN OUT SnmpPdu &a_SnmpPdu ,
    IN RequestId a_RequestId

)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    if ( t_SrcEntity )
    {
        SnmpFreeEntity ( t_SrcEntity ) ;
    }

    if ( t_DstEntity )
    {
        SnmpFreeEntity ( t_DstEntity ) ;
    }

    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    // obtain the var bind list
    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    t_Status = SnmpSetPduData (

        t_Pdu, 
        &t_PduType , 
        &a_RequestId, 
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    t_SrcEntity = SnmpStrToEntity ( (HSNMP_SESSION) m_Session, LOOPBACK_ADDRESS ) ;
    t_DstEntity = SnmpStrToEntity ( (HSNMP_SESSION) m_Session, LOOPBACK_ADDRESS ) ;

    t_Buffer.ptr = NULL; 
    t_Buffer.len = 0;

    t_Status = SnmpEncodeMsg (

        (HSNMP_SESSION) m_Session,
        t_SrcEntity, 
        t_DstEntity,
        t_Context, 
        t_Pdu, 
        &t_Buffer
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        ) ;
    }

    a_SnmpPdu.SetPdu (

        t_Buffer.ptr, 
        t_Buffer.len
    );

    SnmpFreeDescriptor (

        SNMP_SYNTAX_OCTETS,
        & t_Buffer
    ) ;

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeVbl ( t_Vbl ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: SetPduVarBindList (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpVarBindList &a_SnmpVarBindList

)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    HSNMP_VBL t_NewVbl = SnmpCreateVbl ( (HSNMP_SESSION) m_Session , NULL , NULL ) ;
    SetWinSnmpVbl ( a_SnmpVarBindList , t_Vbl ) ;

    t_Status = SnmpSetPduData (

        t_Pdu, 
        &t_PduType , 
        &t_RequestId, 
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_NewVbl
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    t_Buffer.ptr = NULL; 
    t_Buffer.len = 0;

    t_Status = SnmpEncodeMsg (

        (HSNMP_SESSION) m_Session,
        t_SrcEntity, 
        t_DstEntity,
        t_Context, 
        t_Pdu, 
        &t_Buffer
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        ) ;
    }

    a_SnmpPdu.SetPdu (

        t_Buffer.ptr, 
        t_Buffer.len
    );

    SnmpFreeDescriptor (

        SNMP_SYNTAX_OCTETS,
        & t_Buffer
    ) ;

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeVbl ( t_Vbl ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: SetPduCommunityName ( 

    IN SnmpPdu &a_SnmpPdu ,
    IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 

)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    SnmpOctetString t_OctetString ( NULL , 0 ) ;
    a_SnmpCommunityBasedSecurity.GetCommunityName ( t_OctetString ) ;

    smiOCTETS t_Name;
    t_Name.len = t_OctetString.GetValueLength () ;
    t_Name.ptr = t_OctetString.GetValue () ;

    HSNMP_CONTEXT t_NewContext ;

    CriticalSectionLock t_CriticalSectionLock ( s_CriticalSection ) ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    SetTranslateMode () ;

    t_NewContext = SnmpStrToContext (

        ( HSNMP_SESSION ) m_Session,
        &t_Name
    ) ;

    if ( t_SrcEntity )
    {
        SnmpFreeEntity ( t_SrcEntity ) ;
    }

    if ( t_DstEntity )
    {
        SnmpFreeEntity ( t_DstEntity ) ;
    }

    t_SrcEntity = SnmpStrToEntity ( (HSNMP_SESSION) m_Session, LOOPBACK_ADDRESS ) ;
    if ( t_SrcEntity == SNMPAPI_FAILURE )
    {
        t_CriticalSectionLock.UnLock () ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    t_DstEntity = SnmpStrToEntity ( (HSNMP_SESSION) m_Session, LOOPBACK_ADDRESS ) ;

    if ( t_DstEntity == SNMPAPI_FAILURE )
    {
        t_CriticalSectionLock.UnLock () ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    t_CriticalSectionLock.UnLock () ;

    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    t_Status = SnmpSetPduData (

        t_Pdu, 
        &t_PduType , 
        &t_RequestId, 
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    t_Buffer.ptr = NULL; 
    t_Buffer.len = 0;

    t_Status = SnmpEncodeMsg (

        (HSNMP_SESSION) m_Session,
        t_SrcEntity, 
        t_DstEntity,
        t_NewContext, 
        t_Pdu, 
        &t_Buffer
    ) ;

    SnmpFreeContext ( t_NewContext ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        ) ;
    }

    a_SnmpPdu.SetPdu (

        t_Buffer.ptr, 
        t_Buffer.len
    );

    SnmpFreeDescriptor (

        SNMP_SYNTAX_OCTETS,
        & t_Buffer
    ) ;

    if ( t_SrcEntity )
    {
        SnmpFreeEntity ( t_SrcEntity ) ;
    }

    if ( t_DstEntity )
    {
        SnmpFreeEntity ( t_DstEntity ) ;
    }

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeVbl ( t_Vbl ) ;
    SnmpFreePdu ( t_Pdu ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: SetPduErrorReport (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpErrorReport &a_SnmpErrorReport

)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    t_ErrorStatus = a_SnmpErrorReport.GetStatus () ;
    t_ErrorIndex = a_SnmpErrorReport.GetIndex () ;

    t_Status = SnmpSetPduData (

        t_Pdu, 
        &t_PduType , 
        &t_RequestId, 
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    t_Buffer.ptr = NULL; 
    t_Buffer.len = 0;

    t_Status = SnmpEncodeMsg (

        (HSNMP_SESSION) m_Session,
        t_SrcEntity, 
        t_DstEntity,
        t_Context, 
        t_Pdu, 
        &t_Buffer
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        ) ;
    }

    a_SnmpPdu.SetPdu (

        t_Buffer.ptr, 
        t_Buffer.len
    );

    SnmpFreeDescriptor (

        SNMP_SYNTAX_OCTETS,
        & t_Buffer
    ) ;

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeVbl ( t_Vbl ) ;

    return TRUE ;

}

BOOL SnmpEncodeDecode :: SetPduPduType (

    IN SnmpPdu &a_SnmpPdu ,
    OUT PduType a_PduType

)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    t_Status = SnmpSetPduData (

        t_Pdu, 
        &winsnmp_pdu_type[a_PduType],  
        &t_RequestId, 
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    t_Buffer.ptr = NULL; 
    t_Buffer.len = 0;

    t_Status = SnmpEncodeMsg (

        (HSNMP_SESSION) m_Session,
        t_SrcEntity, 
        t_DstEntity,
        t_Context, 
        t_Pdu, 
        &t_Buffer
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        ) ;
    }

    a_SnmpPdu.SetPdu (

        t_Buffer.ptr, 
        t_Buffer.len
    );

    SnmpFreeDescriptor (

        SNMP_SYNTAX_OCTETS,
        & t_Buffer
    ) ;

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeVbl ( t_Vbl ) ;

    return TRUE ;

}

BOOL SnmpEncodeDecode :: SetPduSourceAddress ( 

    IN OUT SnmpPdu &a_SnmpPdu ,
    IN SnmpTransportAddress &a_TransportAddress 

)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    HSNMP_ENTITY t_NewSrcEntity ;

    char *t_SrcAddress = a_TransportAddress.GetAddress () ;

    CriticalSectionLock t_CriticalSectionLock ( s_CriticalSection ) ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    SetTranslateMode () ;

    t_NewSrcEntity = SnmpStrToEntity (

        ( HSNMP_SESSION ) m_Session ,
        t_SrcAddress
    ) ;

    t_CriticalSectionLock.UnLock () ;

    if ( t_NewSrcEntity == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );
    }

    t_Buffer.ptr = NULL; 
    t_Buffer.len = 0;

    t_Status = SnmpEncodeMsg (

        (HSNMP_SESSION) m_Session,
        t_NewSrcEntity, 
        t_DstEntity,
        t_Context, 
        t_Pdu, 
        &t_Buffer
    ) ;

    SnmpFreeEntity ( t_NewSrcEntity ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        ) ;
    }

    a_SnmpPdu.SetPdu (

        t_Buffer.ptr, 
        t_Buffer.len
    );

    SnmpFreeDescriptor (

        SNMP_SYNTAX_OCTETS,
        & t_Buffer
    ) ;

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;

    return TRUE ;

}

BOOL SnmpEncodeDecode :: SetPduDestinationAddress ( 

    IN OUT SnmpPdu &a_SnmpPdu ,
    IN SnmpTransportAddress &a_TransportAddress 

)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    HSNMP_ENTITY t_NewDstEntity ;

    char *t_DstAddress = a_TransportAddress.GetAddress () ;

    CriticalSectionLock t_CriticalSectionLock ( s_CriticalSection ) ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    SetTranslateMode () ;

    t_NewDstEntity = SnmpStrToEntity (

        ( HSNMP_SESSION ) m_Session ,
        t_DstAddress
    ) ;

    t_CriticalSectionLock.UnLock () ;

    if ( t_NewDstEntity == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );
    }

    t_Buffer.ptr = NULL; 
    t_Buffer.len = 0;

    t_Status = SnmpEncodeMsg (

        (HSNMP_SESSION) m_Session,
        t_SrcEntity, 
        t_NewDstEntity,
        t_Context, 
        t_Pdu, 
        &t_Buffer
    ) ;

    SnmpFreeEntity ( t_NewDstEntity ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        ) ;
    }

    a_SnmpPdu.SetPdu (

        t_Buffer.ptr, 
        t_Buffer.len
    );

    SnmpFreeDescriptor (

        SNMP_SYNTAX_OCTETS,
        & t_Buffer
    ) ;

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetPduSourceAddress ( 

    IN SnmpPdu &a_SnmpPdu ,
    SnmpTransportAddress *&a_TransportAddress
)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    char buff[MAX_ADDRESS_LEN];
    t_Status = SnmpEntityToStr(t_SrcEntity, MAX_ADDRESS_LEN, (LPSTR)buff);
    if (SNMPAPI_FAILURE == t_Status)
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    SnmpTransportIpAddress *t_SrcIpAddress = new SnmpTransportIpAddress (buff, SNMP_ADDRESS_RESOLVE_VALUE);

    if (t_SrcIpAddress->IsValid())
    {
        a_TransportAddress = t_SrcIpAddress ;
    }
    else
    {
        delete t_SrcIpAddress ;

        SnmpTransportIpxAddress *t_SrcIpxAddress = new SnmpTransportIpxAddress (buff);

        if (t_SrcIpxAddress->IsValid())
        {
            a_TransportAddress = t_SrcIpxAddress ;
        }   
        else
        {
            delete t_SrcIpxAddress ;

            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError (( HSNMP_SESSION)m_Session) 
            );
        }
    }

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetPduDestinationAddress (

    IN SnmpPdu &a_SnmpPdu ,
    SnmpTransportAddress *&a_TransportAddress
)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    char buff[MAX_ADDRESS_LEN];
    t_Status = SnmpEntityToStr(t_DstEntity, MAX_ADDRESS_LEN, (LPSTR)buff);
    if (SNMPAPI_FAILURE == t_Status)
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    SnmpTransportIpAddress *t_DstIpAddress = new SnmpTransportIpAddress (buff, SNMP_ADDRESS_RESOLVE_VALUE);

    if (t_DstIpAddress->IsValid())
    {
        a_TransportAddress = t_DstIpAddress ;
    }
    else
    {
        delete t_DstIpAddress ;

        SnmpTransportIpxAddress *t_DstIpxAddress = new SnmpTransportIpxAddress (buff);

        if (t_DstIpxAddress->IsValid())
        {
            a_TransportAddress = t_DstIpxAddress ;
        }   
        else
        {
            delete t_DstIpxAddress ;

            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError (( HSNMP_SESSION)m_Session) 
            );
        }
    }

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;

    return TRUE ;

}

BOOL SnmpEncodeDecode :: GetPduPduType (

    IN SnmpPdu &a_SnmpPdu ,
    OUT PduType &a_PduType 

)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    if ( t_PduType == SNMP_PDU_GET )
    {
        a_PduType = GET ;
    }
    else if ( t_PduType == SNMP_PDU_SET )
    {
        a_PduType = SET ;
    }
    else if ( t_PduType == SNMP_PDU_GETNEXT )
    {
        a_PduType = GETNEXT ;
    }
    else if ( t_PduType == SNMP_PDU_RESPONSE )
    {
        a_PduType = RESPONSE ;
    }
    else
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeVbl ( t_Vbl ) ;
    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetPduRequestId (

    IN SnmpPdu &a_SnmpPdu ,
    RequestId &a_RequestId 
)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    a_RequestId = t_RequestId ;

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeVbl ( t_Vbl ) ;

    return TRUE ;
}

BOOL SnmpEncodeDecode :: GetPduErrorReport (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpErrorReport &a_SnmpErrorReport 

)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    a_SnmpErrorReport.SetStatus ( ( SnmpStatus ) t_ErrorStatus ) ;
    a_SnmpErrorReport.SetIndex ( t_ErrorIndex ) ;

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeVbl ( t_Vbl ) ;

    return TRUE ;

}

BOOL SnmpEncodeDecode :: GetPduVarbindList (

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpVarBindList &a_SnmpVarBindList

)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    HSNMP_VBL t_Vbl ;
    smiINT t_RequestId ;
    smiINT t_PduType ;
    smiINT t_ErrorStatus ;
    smiINT t_ErrorIndex ;

    t_Status = SnmpGetPduData (

        t_Pdu, 
        &t_PduType, 
        &t_RequestId,
        &t_ErrorStatus, 
        &t_ErrorIndex, 
        &t_Vbl
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );  
    }

    if ( ! DecodeVarBindList ( t_Vbl , a_SnmpVarBindList ) )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session)
        ) ;
    }

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeVbl ( t_Vbl ) ;

    return TRUE ;

}

BOOL SnmpEncodeDecode :: GetPduCommunityName ( 

    IN SnmpPdu &a_SnmpPdu ,
    OUT SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 

)
{
    smiOCTETS t_Buffer ;
    t_Buffer.ptr = a_SnmpPdu.GetFrame () ;
    t_Buffer.len = a_SnmpPdu.GetFrameLength () ;

    HSNMP_ENTITY t_SrcEntity ;
    HSNMP_ENTITY t_DstEntity ;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    // decode the message for the PDU

    SNMPAPI_STATUS t_Status = SnmpDecodeMsg (

        (HSNMP_SESSION) m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu, 
        &t_Buffer  
    ) ;

    if ( t_Status == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session)
        );  
    }

    char buff[MAX_ADDRESS_LEN];
    t_Status = SnmpEntityToStr(t_SrcEntity, MAX_ADDRESS_LEN, (LPSTR)buff);
    if (SNMPAPI_FAILURE == t_Status)
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    smiOCTETS t_Community ; 
    t_Status = SnmpContextToStr (

        t_Context , 
        &t_Community 
    );

    if (SNMPAPI_FAILURE == t_Status)
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError (( HSNMP_SESSION)m_Session) 
        );
    }

    SnmpOctetString t_SnmpOctetString ( t_Community.ptr , t_Community.len ) ;

    SnmpFreeDescriptor ( SNMP_SYNTAX_OCTETS, &t_Community );

    a_SnmpCommunityBasedSecurity.SetCommunityName ( t_SnmpOctetString ) ;

    return TRUE;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\flow.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: flow.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "flow.h"
#include "frame.h"
#include "message.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"

#include "dummy.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"

// Add to the end of the queue.
void MessageStore::Enqueue( Message &new_message )
{
    AddTail(&new_message);
}


// Remove and return the first element in the Store
Message* MessageStore::Dequeue(void)
{
    if ( !IsEmpty() )
        return RemoveHead();

    return NULL;
}

// remove and return the message with the session_frame_id
// throws a GeneralException(Snmp_Error, Snmp_Local_Error) if not found
Message *MessageStore::DeleteMessage(SessionFrameId session_frame_id)
{
    POSITION current = GetHeadPosition();

    while ( current != NULL )
    {
        POSITION prev_current = current;
        Message *message = GetNext(current);

        // if a match is found
        if ( message->GetSessionFrameId() == session_frame_id )
        {
               RemoveAt(prev_current);
               return message;
        }
    }

    // if not found, throw an exception
    throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);

    // should never reach here;
    return NULL;
}

// goes through the store and deletes all stored message ptrs
MessageStore::~MessageStore(void)
{
    POSITION current = GetHeadPosition();

    while ( current != NULL )
    {
        POSITION prev_current = current;
        Message *message = GetNext(current);

        delete message;
    }

    RemoveAll();
}

// obtains the session CriticalSection lock before calling TransmitMessage
void FlowControlMechanism::TransmitMessageUnderProtection(Message *message)
{
    CriticalSectionLock access_lock(session->session_CriticalSection);

    if ( !access_lock.GetLock(INFINITE) )
        throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);

    TransmitMessage(message);

    // access_lock.UnLock();   The lock may be released at this point
}

// create a waiting message 
// register with the frame_registry and let it Transmit
void FlowControlMechanism::TransmitMessage(Message *message)
{
    try
    {
        // create a waiting message
        WaitingMessage *waiting_message = 
            new WaitingMessage(*session, *message);

        // register with the frame registry
        session->frame_registry.RegisterFrame(message->GetSessionFrameId(), 
                                              *waiting_message);

        // increment the number of outstanding messages before transmission
        // to avoid problems in case of callback due to a message receipt
        outstanding_messages++; 

        // let the message transmit
        waiting_message->Transmit();

        // if the window closes give a FlowControlOn callback
        // if an exception is raised in Transmit, this is never
        // called
        if ( outstanding_messages == window_size )
            session->SessionFlowControlOn();
    }
    catch(GeneralException exception)
    {
        // in case of an exception, undo the increment
        // in outstanding messages

        // do not bother if the window opens up because the
        // corresponding FlowControlOn was not called
        outstanding_messages--; 

        // rethrow the exception
        throw;
    }
}


// transmits a message(if present) for each empty slot in the
// window.
void FlowControlMechanism::ClearMessageStore(void)
{
    while (outstanding_messages < window_size)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L" checking message store\n" 
    ) ;
)
        // if any message is waiting in the queue, deque it
        Message *message = message_store.Dequeue();
    
        // if there is a message, create waiting message, register it and xmit
        // (since we are already within the system, no need to call
        //  TransmitMessageUnderProtection)
        if ( message != NULL )
        {
            // all the exception handling has already been
            // performed - nothing needs to be done here
            try
            {
                TransmitMessage(message);
            }
            catch(GeneralException exception) {}
        }
        else // no messages in queue
            return;
    }
}


// initializes the private variables
FlowControlMechanism::FlowControlMechanism(SnmpImpSession &session, 
                                           UINT window_size)
{
    FlowControlMechanism::session = &session;
    FlowControlMechanism::window_size = window_size;
    outstanding_messages = 0;
}


// sends message if within the flow control window
// else queues it up
void FlowControlMechanism::SendMessage(Message &message)
{
    // check to see if it may be transmitted immediately,
    // create a waiting message 
    // register with the frame_registry and let it Transmit
    if ( outstanding_messages < window_size )
        TransmitMessageUnderProtection(&message);
    else    // else Enqueue onto the message store
        message_store.Enqueue(message);
}


// It removes the frame from its message store and deletes it
void FlowControlMechanism::DeleteMessage(SessionFrameId session_frame_id)
{
    Message *message = message_store.DeleteMessage(session_frame_id);

    delete message;
}


// this is called by a waiting_message indicating arrival or
// a lack of it
void FlowControlMechanism::NotifyReceipt(WaitingMessage &waiting_message, 
                                         IN const SnmpPdu *snmp_pdu, 
                                         SnmpErrorReport &error_report)
{
    smiOCTETS msg_buffer = {0,NULL};

    // if this opens up the window, signal FlowControlOff
    outstanding_messages--; 
    if ( (outstanding_messages+1) == window_size )
        session->SessionFlowControlOff();

    SessionFrameId session_frame_id = waiting_message.GetMessage()->GetSessionFrameId();

    // in case of an error
    // Note: NotifyOperation either posts a SENT_FRAME event to be processed
    // later or sets the variables needed to inform the operation of the
    // reply when the control returns to the session
    if ( error_report.GetError() != Snmp_Success )
        session->NotifyOperation(session_frame_id, SnmpPdu(), error_report);        
    else // if a reply is succesfully received
    {
        // pass the message to session->NotifyOperation
        session->NotifyOperation(session_frame_id, *snmp_pdu, error_report);
    }


    // deregister the frame from the message registry
    session->frame_registry.DeregisterFrame(session_frame_id);

    // destroy waiting message
    delete &waiting_message;

    // transmits messages in message store as long as the
    // flow control window is open
    ClearMessageStore();
}


// this is called when, although the session does 
// not need to be informed, the flow control window
// must advance (such as frame cancellation)
// also destroys the waiting_message
void FlowControlMechanism::AdvanceWindow(WaitingMessage &waiting_message)
{
    // remove the session_frame_id from the frame_registry
    session->frame_registry.DeregisterFrame(
        waiting_message.GetMessage()->GetSessionFrameId());

    // if the flow control window opens up, signal FlowControlOff
    outstanding_messages--; 
    if ( (outstanding_messages+1) == window_size )
        session->SessionFlowControlOff();

    // transmits messages in message store as long as the
    // flow control window is open
    ClearMessageStore();

    // delete the waiting message
    delete &waiting_message;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\fs_reg.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: fs_reg.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "fs_reg.h"
#include "sec.h"

FrameState::FrameState(IN SessionFrameId session_frame_id, IN VBList &vblist)
         : session_frame_id(session_frame_id),
           vblist(&vblist)
{}


FrameState::~FrameState(void)
{
    delete vblist;
}


FrameStateRegistry::~FrameStateRegistry()
{
    DestroySecurity();
}


FrameState *FrameStateRegistry::Get(IN SessionFrameId session_frame_id)
{
    FrameState *frame_state;
    BOOL found = mapping.Lookup(session_frame_id, frame_state);

    if ( found )
        return frame_state;
    else
        return NULL;
}


FrameState *FrameStateRegistry::Remove(IN SessionFrameId session_frame_id)
{
    FrameState *frame_state = Get(session_frame_id);

    if ( frame_state != NULL )
        mapping.RemoveKey(session_frame_id);

    return frame_state;
}


FrameState *FrameStateRegistry::GetNext(OUT SessionFrameId *session_frame_id)
{
    if ( current_pointer == NULL )
        return NULL;

    SessionFrameId local_session_frame_id;
    FrameState *frame_state;

    mapping.GetNextAssoc(current_pointer, local_session_frame_id, frame_state);

    if ( session_frame_id != NULL )
        *session_frame_id = local_session_frame_id;

    return frame_state;
}


void FrameStateRegistry::RegisterSecurity(IN SnmpSecurity *snmp_security)
{
    if ( snmp_security != NULL )
    {
        security = snmp_security->Copy();

        if ( !(*security)() )
            throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);
    }
    else
        security = NULL;
}

SnmpSecurity *FrameStateRegistry::GetSecurity() const
{
    return security;
}

void FrameStateRegistry::DestroySecurity()
{
    if ( security != NULL )
    {
        delete security;
        security = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\idmap.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: idmap.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "idmap.h"
#include "frame.h"

void IdMapping::Associate(IN TransportFrameId transport_frame_id,
                          IN SessionFrameId session_frame_id)
{
    forward_store[transport_frame_id] = session_frame_id;
    backward_store[session_frame_id] = transport_frame_id;
}

SessionFrameId IdMapping::DisassociateTransportFrameId(IN TransportFrameId transport_frame_id)
{
    SessionFrameId session_frame_id;
        
    if ( !forward_store.Lookup(transport_frame_id, session_frame_id) )
        return ILLEGAL_SESSION_FRAME_ID;

    forward_store.RemoveKey(transport_frame_id);
    backward_store.RemoveKey(session_frame_id);

    return session_frame_id;
}


TransportFrameId IdMapping::DisassociateSessionFrameId(IN SessionFrameId session_frame_id)
{
    TransportFrameId transport_frame_id;

    if ( !backward_store.Lookup(session_frame_id, transport_frame_id) )
        return ILLEGAL_TRANSPORT_FRAME_ID;

    backward_store.RemoveKey(session_frame_id);
    forward_store.RemoveKey(transport_frame_id);

    return transport_frame_id;
}


BOOL IdMapping::CheckIfAssociated(IN SessionFrameId session_frame_id)
{
    TransportFrameId transport_frame_id;

    return backward_store.Lookup(session_frame_id, transport_frame_id);
}

IdMapping::~IdMapping(void)
{
    forward_store.RemoveAll();
    backward_store.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\frame.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: frame.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "flow.h"
#include "frame.h"
#include "idmap.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "ssent.h"

#include "dummy.h"
#include "opreg.h"
#include "session.h"

SessionFrameId FrameRegistry::GenerateSessionFrameId(void)
{
    SessionFrameId session_frame_id = next_session_frame_id++;

    if ( next_session_frame_id == ILLEGAL_SESSION_FRAME_ID )
        next_session_frame_id++;

    return session_frame_id;
}


void FrameRegistry::RegisterFrame(IN const SessionFrameId session_frame_id, 
                                  IN WaitingMessage &waiting_message)
{
    mapping[session_frame_id] = &waiting_message;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"frame %d registered\n" ,session_frame_id
    ) ;
)

}

    
// returns NULL if no such waiting message
WaitingMessage *FrameRegistry::GetWaitingMessage(IN const SessionFrameId session_frame_id)
{
    WaitingMessage *waiting_message;
    BOOL found = mapping.Lookup(session_frame_id, waiting_message);

    if ( found )
        return waiting_message;
    else
        return NULL;
}


void FrameRegistry::DeregisterFrame(IN const SessionFrameId session_frame_id)
{
    if ( !mapping.RemoveKey(session_frame_id) )
        throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"frame %d removed\n" ,session_frame_id
    ) ;
)
}

// if the specified waiting message is found,
//  cancel the <TransportFrameId, SessionFrameId> association,
//  ensure that no sent message notifications shall be passed to the operation
//  remove any buffered responses for the waiting message
//  inform the flow control mechanism
// otherwise, the message is still in the flow control queue
//  inform the flow control mechanism
void FrameRegistry::CancelFrameNotification(IN const SessionFrameId session_frame_id)
{
    WaitingMessage *waiting_message;
    BOOL found = mapping.Lookup(session_frame_id, waiting_message);

    // obtain corresponding waiting_message
    if ( found )
    {
        // ensure that sent message notifications shall not
        // be passed on to the operation
        session->id_mapping.DisassociateSessionFrameId(session_frame_id);

        // remove any SnmpErrorReport for an attempt to send the message
        session->store.Remove(session_frame_id);

        // inform flow control mechanism
        // it advances window and destroys the waiting_message
        session->flow_control.AdvanceWindow(*waiting_message);
    }
    else // the frame must still be in the flow control message queue
        session->flow_control.DeleteMessage(session_frame_id);
}


// destroy each stored waiting message in the local store and
// remove all associations
FrameRegistry::~FrameRegistry(void)
{
    // get the first position
    POSITION current = mapping.GetStartPosition();

    // while the position isn't null
    while ( current != NULL )
    {
        SessionFrameId id;
        WaitingMessage *waiting_message;

        // get the next pair
        mapping.GetNextAssoc(current, id, waiting_message);

        // delete the ptr
        delete waiting_message;
    }

    // remove all the keys
    mapping.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\message.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: message.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "message.h"
#include "idmap.h"
#include "dummy.h"
#include "flow.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"

#include "frame.h"
#include "opreg.h"
#include "ssent.h"

#include "session.h"

#define ILLEGAL_PDU_HANDLE 100000
#define ILLEGAL_VBL_HANDLE 100000

Message::Message(IN const SessionFrameId session_frame_id, IN SnmpPdu &snmp_pdu, 
                 SnmpOperation &snmp_operation
                 ) : snmp_pdu(&snmp_pdu), operation(snmp_operation)
{
    Message::session_frame_id = session_frame_id;
}
    
SessionFrameId Message::GetSessionFrameId(void) const
{
    return session_frame_id;
}

SnmpOperation &Message::GetOperation(void) const
{
    return operation;
}

SnmpPdu &Message::GetSnmpPdu(void) const
{
    return *snmp_pdu;
}

void Message::SetSnmpPdu(IN SnmpPdu &new_snmp_pdu)
{
    delete snmp_pdu;
    snmp_pdu = &new_snmp_pdu;
}

Message::~Message(void)
{
    delete snmp_pdu;
}


// deregisters the waiting message from the message registry
// for each request id stored in the RequestIdList
void WaitingMessage::DeregisterRequestIds()
{
    for( UINT request_ids_left = request_id_list.GetCount();
         request_ids_left > 0;
         request_id_list.RemoveHead(), request_ids_left--)
         {
             RequestId request_id = request_id_list.GetHead();
             session->message_registry.RemoveMessage(request_id);
         }
}

// an exit fn - prepares an error report and calls
// ReceiveReply to signal a non-receipt
void WaitingMessage::WrapUp(IN SnmpErrorReport &error_report)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: WrapUp () session_id(%d), frame_id(%d)\n" ,message->GetSessionFrameId(), last_transport_frame_id
    ) ;
)

    try // ignore any exceptions arising during the ReceiveReply
    {
        // no reply to receive
        ReceiveReply(NULL, error_report);
    }
    catch(GeneralException exception) {}
}


// initializes the private variables
WaitingMessage::WaitingMessage(IN SnmpImpSession &session, 
                               IN Message &message) : session ( NULL ) , message ( NULL ), reply_snmp_pdu ( NULL )
{
    WaitingMessage::session = &session;

    // the message ptr must be deleted by the waiting message
    WaitingMessage::message = &message;

    // sent message has not been processed yet
    sent_message_processed = FALSE;

    // set illegal values for last_transport_frame_id
    last_transport_frame_id = ILLEGAL_TRANSPORT_FRAME_ID;

    // these values are currently obtained from the
    // session, but may be specified per message later
    max_rexns = SnmpImpSession :: RetryCount ( session.GetRetryCount() ) ;
    rexns_left = max_rexns;
    strobes = 0 ;

    active = FALSE;
}


// sends the message. involves request_id generation,
// registering with the message_registry, decoding the
// message and updating the pdu and registering a timer
// event
void WaitingMessage::Transmit()
{
    try
    {
        // generate request_id and register with the registry
        RequestId request_id = 
            session->message_registry.GenerateRequestId(*this);
    
        // insert the request id into the message
        // if unsuccessful, the exception handler gets called
        session->m_EncodeDecode.SetRequestId(

            message->GetSnmpPdu(),
            request_id 
            
        );

        last_transport_frame_id = request_id ;

        // append the request id to the request id list
        request_id_list.AddTail(request_id);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: Transmit - About to transmit (session (%d), frame_id(%d))\n", message->GetSessionFrameId(), request_id
    ) ;
)

        // save the previous value of active and set the active
        // flag. This is needed to check on returning whether the 
        // waiting message needs to be destroyed
        BOOL prev_active_state = active;
        active = TRUE;
        strobes = GetTickCount () ;

        // send message

        session->transport.TransportSendFrame(last_transport_frame_id, message->GetSnmpPdu());

        session->id_mapping.Associate(last_transport_frame_id, message->GetSessionFrameId());

        // if asked to destroy self, well, do it (and return)
        if ( !active )
        {
            delete this;
            return;
        }

        // restore the previous value of "active"
        active = prev_active_state;

        // generate timer_event_id and register with the timer
        session->timer.SetMessageTimerEvent(*this);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: Transmit - Transmitted session_id(%d),frame_id(%d))\n",message->GetSessionFrameId(), request_id
    ) ;
)
    }
    catch(GeneralException exception)
    {
        WrapUp(exception);

        throw;
    }
}

// used by the timer to notify the waiting message of
// a timer event. if need, the message is retransmitted.
// when all rexns are exhausted, ReceiveReply is called
void WaitingMessage::TimerNotification()
{
    DWORD t_Ticks = GetTickCount () ;
    if ( strobes > t_Ticks ) 
    {
        strobes = t_Ticks ; // Take hit on clock overflow
        return ;
    }

    if ( ( t_Ticks - strobes ) >= SnmpImpSession :: RetryTimeout ( session->GetRetryTimeout () ) )
    {

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: TimerNotification - timed out after (%ld)" , ( t_Ticks - strobes ) 
    ) ;
)

        // if any rexns left, update rexns_left, send message
        if ( rexns_left > 0 )
        {
            // generate request_id and register with the registry
            RequestId request_id = session->message_registry.GenerateRequestId(*this);
        
            // insert the request id into the message
            // if unsuccessful, the exception handler gets called
            try
            {
                session->m_EncodeDecode.SetRequestId(

                    message->GetSnmpPdu() ,
                    request_id
                );
            }
            catch(GeneralException exception)
            {
                WrapUp(exception);
                return;
            }

            last_transport_frame_id = request_id ;

            // append the request id to the request id list
            request_id_list.AddTail(request_id);

            BOOL prev_active_state = active;
            active = TRUE;

            strobes = GetTickCount () ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: TimerNotification - Resend %d.%d, req_id(%d), this(%d) at time (%d)\n",message->GetSessionFrameId(), rexns_left, request_id, this, strobes
    ) ;
)

            session->id_mapping.DisassociateTransportFrameId(last_transport_frame_id);

            // send message
            session->transport.TransportSendFrame(last_transport_frame_id, message->GetSnmpPdu());

            // associate the last transport frame id with the session frame id
            session->id_mapping.Associate(last_transport_frame_id, message->GetSessionFrameId());

            // if asked to destroy self, well, do it (and return)
            if ( !active )
            {
                delete this;
                return;
            }

            // restore the previous value of "active"
            active = prev_active_state;

            rexns_left--;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: TimerNotification - Retransmitted session_id(%d),frame_id(%d))\n",message->GetSessionFrameId(), last_transport_frame_id
    ) ;
)

        }
        else
        {   
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: TimerNotification - No response session_id(%d),frame_id(%d))\n",message->GetSessionFrameId(), last_transport_frame_id
    ) ;
)

            // else wrap up as no response has been received
            WrapUp(SnmpErrorReport(Snmp_Error, Snmp_No_Response));

            return; // since the waiting_message would have been destroyed
        }
    }
    else
    {
    }
}


// A call to this function signifies that state corresponding to the
// waiting_message need not be kept any further
// if required, it cancels the timer event and 
// deregisters with the message registry
// it notifies the flow control mechanism of the termination
// which destroys the waiting_message
void WaitingMessage::ReceiveReply(IN const SnmpPdu *snmp_pdu, IN SnmpErrorReport &error_report)
{   
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: ReceiveReply (this(%d), session_id(%d),frame_id(%d),error(%d), status(%d))\n",this, message->GetSessionFrameId(), last_transport_frame_id,error_report.GetError(), error_report.GetStatus()
    ) ;
)

    // cancels registrations with message registry
    DeregisterRequestIds();

    // cancels timer event
    session->timer.CancelMessageTimer(*this,session->timer_event_id);


    // if required (the corresponding SENT event has not been signaled
    // yet), cancel the association with the last transport frame id
    if ( last_transport_frame_id != ILLEGAL_TRANSPORT_FRAME_ID )
    {
        session->id_mapping.DisassociateTransportFrameId(last_transport_frame_id);
        last_transport_frame_id = ILLEGAL_TRANSPORT_FRAME_ID;
    }
    
    // call fc_mech.NotifyReceipt(this,pdu,error_report)
    // which should destroy the waiting message
    session->flow_control.NotifyReceipt(*this, snmp_pdu, error_report);
}


// buffers the snmp pdu received as a reply
void WaitingMessage::BufferReply(IN const SnmpPdu &reply_snmp_pdu)
{
    if ( WaitingMessage::reply_snmp_pdu == NULL )
    {

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"WaitingMessage :: Buffering reply %d, %d, this(%d)\n",message->GetSessionFrameId(), rexns_left, this
    ) ;
)
        WaitingMessage::reply_snmp_pdu = new SnmpPdu((SnmpPdu&)reply_snmp_pdu);
    }
}

// returns TRUE if a reply has been buffered
BOOL WaitingMessage::ReplyBuffered()
{
    return (reply_snmp_pdu != NULL);
}

// returns a ptr to the buffered reply pdu, if buffered
// otherwise a null ptr is returned
// IMPORTANT: it sets the reply_snmp_pdu to NULL, so that it may not
// be deleted when the waiting message is destroyed
SnmpPdu *WaitingMessage::GetBufferedReply()
{
    SnmpPdu *to_return = reply_snmp_pdu;
    reply_snmp_pdu = NULL;

    return to_return;
}

// informs the waiting message that a sent message has been
// processed 
void WaitingMessage::SetSentMessageProcessed()
{
    sent_message_processed = TRUE;
}

// if a sent message has been processed, it returns TRUE, else FALSE
BOOL WaitingMessage::GetSentMessageProcessed()
{
    return sent_message_processed;
}

void WaitingMessage::SelfDestruct(void)
{
    if ( !active )
    {
        delete this;
        return;
    }
    else // else, set the active flag to FALSE
         // when this is detected, it'll self destruct
        active = FALSE;
}

TimerEventId WaitingMessage::GetTimerEventId ()
{
    return m_TimerEventId ;
}

void WaitingMessage::SetTimerEventId ( TimerEventId a_TimerEventId )
{
    m_TimerEventId = a_TimerEventId ;
}

// if required, it cancels registration with the message_registry and
// the timer event with the timer.
WaitingMessage::~WaitingMessage(void)
{
    // if required, cancel registrations with message registry
    if ( !request_id_list.IsEmpty() )
        DeregisterRequestIds();

    session->timer.CancelMessageTimer(*this,session->timer_event_id);

    // if required (the corresponding SENT event has not been signaled
    // yet), cancel the association with the last transport frame id
    if ( last_transport_frame_id != ILLEGAL_TRANSPORT_FRAME_ID )
        session->id_mapping.DisassociateTransportFrameId(last_transport_frame_id);

    // if a reply pdu has been buffered, destroy it
    if ( reply_snmp_pdu != NULL )
    {
        delete &reply_snmp_pdu->GetVarbindList () ;
        delete reply_snmp_pdu;
    }

    // deletes the message ptr
    delete message;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\pseudo.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: pseudo.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "pseudo.h"
#include "fs_reg.h"
#include "ophelp.h"
#include "op.h"

LONG_PTR OperationWindow::HandleEvent (

    HWND hWnd, 
    UINT user_msg_id, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    return owner.ProcessInternalEvent(

        hWnd, 
        user_msg_id, 
        wParam, 
        lParam
    );
}

OperationWindow::OperationWindow (

    IN SnmpOperation &owner 

) : owner(owner)
{
}

OperationWindow ::~OperationWindow ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\opreg.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: opreg.cpp
Written By: B.Rajeev
----------------------------------------------------------*/
#include "precomp.h"
#include <provexpt.h>

#include "fs_reg.h"
#include "pseudo.h"
#include "ophelp.h"
#include "opreg.h"
#include "op.h"

OperationRegistry::OperationRegistry()
{
    num_registered = 0;
}

void OperationRegistry::Register(IN SnmpOperation &operation)
{
    // flagging the operation as registered
    store[&operation] = NULL;
    num_registered++;
}

void OperationRegistry::Deregister(IN SnmpOperation &operation)
{
    // flag the operation as unregistered
    store.RemoveKey(&operation);
    num_registered--;
}

OperationRegistry::~OperationRegistry()
{
   store.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\reg.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: reg.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "message.h"
#include "dummy.h"
#include "reg.h"
#include "idmap.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"

#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "ssent.h"
#include "opreg.h"

#include "session.h"

RequestId MessageRegistry::next_request_id = 1 ;

RequestId MessageRegistry::GenerateRequestId(
             IN WaitingMessage &waiting_message)
{
    RequestId request_id = next_request_id++;

    if (next_request_id == ILLEGAL_REQUEST_ID)
        next_request_id++;

    mapping[request_id] = &waiting_message;

    return request_id;
}



// used by the event handler to notify the message registry
// of a message receipt
// it must receive the message and notify the concerned 
// waiting message of the event
void MessageRegistry::MessageArrivalNotification(IN SnmpPdu &snmp_pdu)
{
    // determine the concerned waiting message and pass it the SnmpPdu
    RequestId request_id ;

    session->m_EncodeDecode.GetRequestId(snmp_pdu,request_id);

    // if failed, return, as there is no use going any further
    if ( request_id == ILLEGAL_REQUEST_ID ) 
        return;

    WaitingMessage *waiting_message;
    BOOL found = mapping.Lookup(request_id, waiting_message);

    // if no such waiting message, return
    if ( !found )
        return;

    // check if still waiting for the SentFrameEvent on
    // this waiting message
    SessionFrameId session_frame_id = waiting_message->GetMessage()->GetSessionFrameId();

    // if not waiting for the sent frame event
    //      let the waiting message receive the reply
    // else buffer the snmp pdu
    if ( waiting_message->GetSentMessageProcessed() == TRUE )
        waiting_message->ReceiveReply(&snmp_pdu);
    else
        waiting_message->BufferReply(snmp_pdu);
}


// delete (request_id, waiting_message) pair
void MessageRegistry::RemoveMessage(IN RequestId request_id)
{
    if ( !mapping.RemoveKey(request_id) )
        throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);
}


MessageRegistry::~MessageRegistry(void)
{
    mapping.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\ophelp.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: ophelp.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "value.h"
#include "encdec.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "vbl.h"
#include "fs_reg.h"
#include "pseudo.h"
#include "encap.h"
#include "error.h"
#include "ophelp.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "op.h"
#include <winsock.h>

// returns an SnmpTransportAddress created using the HSNMP_ENTITY
// this method returns the first transport address it can create
// using the string form of the HSNMP_ENTITY supplied
SnmpTransportAddress *OperationHelper::GetTransportAddress(IN HSNMP_ENTITY &haddr)
{
    char buff[MAX_ADDRESS_LEN];
    SNMPAPI_STATUS status = SnmpEntityToStr(haddr, MAX_ADDRESS_LEN, (LPSTR)buff);

    if (SNMPAPI_FAILURE == status)
    {
        return (SnmpTransportAddress *)NULL;
    }

    //first try ip...
    SnmpTransportIpAddress *retip = new SnmpTransportIpAddress(buff, SNMP_ADDRESS_RESOLVE_VALUE);

    if (retip->IsValid())
    {
        return (SnmpTransportAddress *)retip;
    }
    
    delete retip;

    //next try ipx...
    SnmpTransportIpxAddress *retipx = new SnmpTransportIpxAddress(buff);

    if (retipx->IsValid())
    {
        return (SnmpTransportAddress *)retipx;
    }
    
    delete retipx;

    //nothing worked...
    return (SnmpTransportAddress *)NULL;
}

// returns an SnmpSecurity created using the HSNMP_CONTEXT
// this method returns the first security context it can create
// using the string form of the HSNMP_CONTEXT supplied
SnmpSecurity *OperationHelper::GetSecurityContext(IN HSNMP_CONTEXT &hctxt)
{
    smiOCTETS buff; 
    SNMPAPI_STATUS status = SnmpContextToStr(hctxt, &buff);

    if (SNMPAPI_FAILURE == status)
    {
        return (SnmpSecurity *)NULL;
    }

    SnmpOctetString octstr( (UCHAR *)(buff.ptr), (ULONG)(buff.len) );
    SnmpCommunityBasedSecurity* retval = new SnmpCommunityBasedSecurity(octstr);
    SnmpFreeDescriptor (SNMP_SYNTAX_OCTETS, &buff);

    if (NULL != (*retval)())
    {
        return (SnmpSecurity *)retval;
    }
    
    delete retval;
    return (SnmpSecurity *)NULL;
}

// returns an SnmpVarBind containing an SnmpObjectIdentifier and an
// SnmpValue created using the instance(OID) and the value(VALUE)
SnmpVarBind *OperationHelper::GetVarBind(IN smiOID &instance,
                                         IN smiVALUE &value)
{
    SnmpVarBind *var_bind = NULL ;

    // create an SnmpObjectIdentifier using the instance value
    SnmpObjectIdentifier id(instance.ptr, instance.len);

    // for each possible value for value.syntax, create the
    // corresponding SnmpValue

    switch(value.syntax)
    {
        case SNMP_SYNTAX_NULL:      // null value
        {
            var_bind = new SnmpVarBind(id, SnmpNull () );
        }
        break;

        case SNMP_SYNTAX_INT:       // integer *(has same value as SNMP_SYNTAX_INT32)*
        {
            var_bind = new SnmpVarBind(id, SnmpInteger(value.value.sNumber) ) ;
        }
        break;

        case SNMP_SYNTAX_UINT32:        // integer *(has same value as SNMP_SYNTAX_GAUGE)*
        {
            var_bind = new SnmpVarBind(id, SnmpUInteger32(value.value.uNumber) ) ;
        }
        break;

        case SNMP_SYNTAX_CNTR32:    // counter32
        {
            var_bind = new SnmpVarBind(id, SnmpCounter (value.value.uNumber) ) ;
        }
        break;

        case SNMP_SYNTAX_GAUGE32:   // gauge
        {
            var_bind = new SnmpVarBind(id, SnmpGauge(value.value.uNumber) );
        }
        break;
            
        case SNMP_SYNTAX_TIMETICKS: // time ticks
        {
            var_bind = new SnmpVarBind(id, SnmpTimeTicks(value.value.uNumber) );
        }
        break;

        case SNMP_SYNTAX_OCTETS:    // octets
        {
            var_bind = new SnmpVarBind(id, SnmpOctetString(value.value.string.ptr,
                                             value.value.string.len) ) ;
        }
        break;

        case SNMP_SYNTAX_OPAQUE:    // opaque value
        {
            var_bind = new SnmpVarBind(id, SnmpOpaque(value.value.string.ptr,
                                        value.value.string.len) );
        }
        break;

        case SNMP_SYNTAX_OID:       // object identifier
        {
            var_bind = new SnmpVarBind(id, SnmpObjectIdentifier(value.value.oid.ptr,
                                                  value.value.oid.len) );
        }
        break;

        case SNMP_SYNTAX_IPADDR:    // ip address value
        {
            if ( value.value.string.ptr )
            {
                var_bind = new SnmpVarBind(id, SnmpIpAddress(ntohl(*((ULONG *)value.value.string.ptr))) );
            }
            else
            {

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"OperationHelper::DecodeVarBind: Invalid encoding\n" 
    ) ;
)
                var_bind = NULL ;
            }
        }
        break;

        case SNMP_SYNTAX_CNTR64:    // counter64
        {
            var_bind = new SnmpVarBind(id, SnmpCounter64 (value.value.hNumber.lopart , value.value.hNumber.hipart ) );
        }
        break;

        case SNMP_SYNTAX_NOSUCHOBJECT:
        {
            var_bind = new SnmpVarBind(id, SnmpNoSuchObject () ) ;
        }
        break ;

        case SNMP_SYNTAX_NOSUCHINSTANCE:
        {
            var_bind = new SnmpVarBind(id, SnmpNoSuchInstance () ) ;
        }
        break ;

        case SNMP_SYNTAX_ENDOFMIBVIEW:
        {
            var_bind = new SnmpVarBind(id, SnmpEndOfMibView () ) ;
        }
        break ;

        default:
        {
            // it must be an unsupported type 
            // return an SnmpNullValue by default
            var_bind = new SnmpVarBind(id, SnmpNull() );
        
        }
        break;
    };

    return var_bind;
}

            
void OperationHelper::TransmitFrame (

    OUT SessionFrameId &session_frame_id, 
    VBList &vbl)
{
    SnmpSecurity *security = operation.frame_state_registry.GetSecurity();

    // encode a frame
    SnmpPdu *t_SnmpPdu = new SnmpPdu ;
    SnmpErrorReport t_SnmpErrorReport ;
    SnmpTransportAddress *t_SrcTransportAddress = NULL ;
    SnmpTransportAddress *t_DstTransportAddress = NULL ;
    SnmpCommunityBasedSecurity *t_SnmpcommunityBasedSecurity = NULL ;

    try 
    {
        operation.session.GetSnmpEncodeDecode ().EncodeFrame (

            *t_SnmpPdu ,
            session_frame_id ,
            operation.GetPduType () ,
            t_SnmpErrorReport ,
            vbl.GetVarBindList () ,
            t_SnmpcommunityBasedSecurity ,
            t_SrcTransportAddress ,
            t_DstTransportAddress
        );
    }
    catch ( GeneralException exception )
    {
        delete t_SnmpPdu ;

        operation.m_OperationWindow.PostMessage (  

            Window :: g_SendErrorEvent , 
            (WPARAM)&vbl, 
            (LPARAM)(new GeneralException(exception))
        );
    }

    if ( security != NULL )
    {
        operation.session.SessionSendFrame (

            operation, 
            session_frame_id, 
            *t_SnmpPdu,
            *security
        );
    }
    else
    {
        operation.session.SessionSendFrame (

            operation, 
            session_frame_id, 
            *t_SnmpPdu
        );
    }
}

void OperationHelper::ReceiveResponse (

    ULONG var_index ,
    SnmpVarBindList &sent_var_bind_list,
    SnmpVarBindList &received_var_bind_list,
    SnmpErrorReport &error_report
)
{
    
    // check if the var bind list has the same length

    if ( sent_var_bind_list.GetLength() != received_var_bind_list.GetLength () )
    {
        operation.is_valid = FALSE;
        return;
    }

    sent_var_bind_list.Reset();
    received_var_bind_list.Reset();

    ULONG t_Index = 0 ;
    while( sent_var_bind_list.Next() && received_var_bind_list.Next() )
    {
        const SnmpVarBind *sent_var_bind = sent_var_bind_list.Get();
        const SnmpVarBind *received_var_bind = received_var_bind_list.Get();

        operation.ReceiveVarBindResponse(

            var_index + t_Index ,
            *sent_var_bind, 
            *received_var_bind, 
            error_report
        );

        t_Index ++ ;
    }
}


// processes the response (successful or otherwise) for the specified
// frame. the frame may be retransmitted in case of a reply bearing
// an errored index
void OperationHelper::ProcessResponse (

    FrameState *frame_state,
    SnmpVarBindList &a_SnmpVarBindList ,
    SnmpErrorReport &a_SnmpErrorReport
)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"OperationHelper::ProcessResponse: eindex(%d), error(%d), status(%d)\n",a_SnmpErrorReport.GetIndex(), a_SnmpErrorReport.GetError(), a_SnmpErrorReport.GetStatus()
    ) ;
)

    // if there is an error in a particular var bind
    if ( (a_SnmpErrorReport.GetIndex () != 0) && (a_SnmpErrorReport.GetStatus () != SNMP_ERROR_NOERROR) )
    {
        if ( operation.GetPduType () != SnmpEncodeDecode :: PduType :: SET )
        {
            // delete the corresponding var bind from the VBList 
            // in the frame_state and announce the receipt of 
            // errored var bind by making a callback
            VBList *vblist = frame_state->GetVBList();
            SnmpVarBind *errored_vb;

            try
            {
                errored_vb = vblist->Get(a_SnmpErrorReport.GetIndex () );
            }
            catch(GeneralException exception)
            {
                operation.ReceiveErroredResponse(

                    frame_state->GetVBList()->GetIndex () ,
                    frame_state->GetVBList()->GetVarBindList(), 
                    exception
                );

                delete &frame_state;
                return;
            }

            // *** (SnmpStatus) casting
            SnmpErrorReport report(Snmp_Error, a_SnmpErrorReport.GetStatus () , a_SnmpErrorReport.GetIndex () );

            operation.ReceiveErroredVarBindResponse(

                vblist->GetIndex () + a_SnmpErrorReport.GetIndex () - 1 ,
                *errored_vb, 
                report
            );

            delete errored_vb;

            try
            {
                vblist->Remove (a_SnmpErrorReport.GetIndex () );
            }
            catch(GeneralException exception)
            {
                operation.ReceiveErroredResponse(

                    frame_state->GetVBList()->GetIndex () ,
                    frame_state->GetVBList()->GetVarBindList(), 
                    exception
                );

                delete &frame_state;
                return;
            }

            // if the VarBindList becomes empty, corresp. frame state
            // may be deleted
            if ( vblist->GetVarBindList().Empty() )
                delete frame_state;
            else
            {
                // Split the frame in half

                SnmpVarBindList &vbl = vblist->GetVarBindList ();

                if ( a_SnmpErrorReport.GetIndex () > 1 )
                {
                    SnmpVarBindList *t_Car = vbl.Car ( a_SnmpErrorReport.GetIndex () - 1 ) ;
                    VBList *t_List = new VBList (

                        operation.session.GetSnmpEncodeDecode () ,
                        *t_Car,
                        vblist->GetIndex () 
                    ) ;
                        
                    operation.SendFrame(*t_List) ;
                }

                if ( a_SnmpErrorReport.GetIndex () < vbl.GetLength () )
                {
                    SnmpVarBindList *t_Cdr = vbl.Cdr ( a_SnmpErrorReport.GetIndex () - 1 ) ;

                    VBList *t_List = new VBList (

                        operation.session.GetSnmpEncodeDecode () ,
                        *t_Cdr,
                        vblist->GetIndex () + a_SnmpErrorReport.GetIndex () 
                    ) ;
                        
                    operation.SendFrame(*t_List) ;
                }

                // re-send the frame using the old frame_state

                delete frame_state ;
            }

            return;
        }
        else
        {
            VBList *vblist = frame_state->GetVBList();
            SnmpVarBind *errored_vb;

            try
            {
                errored_vb = vblist->Remove(a_SnmpErrorReport.GetIndex () );
            }
            catch(GeneralException exception)
            {
                operation.ReceiveErroredResponse(

                    frame_state->GetVBList()->GetIndex () ,
                    frame_state->GetVBList()->GetVarBindList(), 
                    exception
                );

                delete &frame_state;
                return;
            }

            // *** (SnmpStatus) casting
            SnmpErrorReport report(Snmp_Error, a_SnmpErrorReport.GetStatus () , a_SnmpErrorReport.GetIndex () );

            operation.ReceiveErroredVarBindResponse(

                vblist->GetIndex () + a_SnmpErrorReport.GetIndex () - 1 ,
                *errored_vb, 
                report
            );

            delete errored_vb;

            SnmpErrorReport t_SnmpErrorReport ;

            operation.ReceiveErroredResponse(

                vblist->GetIndex () + a_SnmpErrorReport.GetIndex () - 1 ,
                frame_state->GetVBList()->GetVarBindList(), 
                t_SnmpErrorReport
            );

            // destroy the frame_state: since the only case when the
            // old frame_state is reused is when there is an error
            // in a particular index and we wouldn't have come here in that case
            delete frame_state;

            return ;
        }
    }

    // otherwise, check the error status
    switch(a_SnmpErrorReport.GetStatus () )
    {
        case SNMP_ERROR_NOERROR:
        {
            // call ReceiveResponse for each vb
            ReceiveResponse (
                frame_state->GetVBList()->GetIndex (),
                frame_state->GetVBList()->GetVarBindList(), 
                a_SnmpVarBindList , 
                a_SnmpErrorReport
            );
        }
        break;

        case SNMP_ERROR_TOOBIG:
        {
            if ( operation.GetPduType () != SnmpEncodeDecode :: PduType :: SET )
            {
                // callback FrameTooBig()
                operation.FrameTooBig();

                // check if the callback cancelled the operation
                if ( ! operation.in_progress )
                    return;

                // obtain the list, length
                SnmpVarBindList &list = frame_state->GetVBList()->GetVarBindList();
                UINT length = list.GetLength();

                // if the length is 1, call ReceiveErroredResponse
                if ( length == 1 )
                {
                        // *** casting Snmp_Status ***
                    SnmpErrorReport report(Snmp_Error, a_SnmpErrorReport.GetStatus () , a_SnmpErrorReport.GetIndex () );

                    operation.ReceiveErroredVarBindResponse(

                        frame_state->GetVBList()->GetIndex () + a_SnmpErrorReport.GetIndex () - 1 ,
                        *(list[1]), 
                        report
                    );
                }
                else // split the list midway and send both fragments
                {
                    operation.SendVarBindList(

                        list, 
                        (length/2),
                        frame_state->GetVBList()->GetIndex () + a_SnmpErrorReport.GetIndex () - 1 
                    );
                }
            }
            else
            {
                // *** casting Snmp_Status ***
                SnmpErrorReport report(Snmp_Error, a_SnmpErrorReport.GetStatus () , a_SnmpErrorReport.GetIndex ());

                // for each varbind in varbindlist
                // call ReceiveResponse for each vb
                operation.ReceiveErroredResponse(

                    frame_state->GetVBList()->GetIndex (), 
                    frame_state->GetVBList()->GetVarBindList(), 
                    report
                );
            }
        }
        break;

        default:
        {
            // *** casting Snmp_Status ***
            SnmpErrorReport report(Snmp_Error, a_SnmpErrorReport.GetStatus () , a_SnmpErrorReport.GetIndex ());

            // for each varbind in varbindlist
            // call ReceiveResponse for each vb
            operation.ReceiveErroredResponse(

                frame_state->GetVBList()->GetIndex (), 
                frame_state->GetVBList()->GetVarBindList(), 
                report
            );
        }
        break;
    }

    
    // destroy the frame_state: since the only case when the
    // old frame_state is reused is when there is an error
    // in a particular index and we wouldn't have come here in that case
    delete frame_state;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\op.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: op.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "encap.h"
#include "value.h"
#include "vblist.h"
#include "vbl.h"
#include "fs_reg.h"
#include "error.h"
#include "sec.h"
#include "pdu.h"
#include "pseudo.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "ophelp.h"
#include "op.h"
#include "encdec.h"


void SnmpOperation::ReceiveResponse()
{
}

// the operation uses window messaging encapsulated within the dummy session
// to make the callbacks to an operation user, asynchronous with respect
// to the user's call to SendRequest
// the events currently posted are SEND_ERROR and OPERATION_COMPLETION
LONG SnmpOperation::ProcessInternalEvent(

    HWND hWnd, 
    UINT user_msg_id,
    WPARAM wParam, 
    LPARAM lParam
)
{
    LONG rc = 0;

    CriticalSectionLock access_lock(exclusive_CriticalSection); // TRUE

    // obtain exclusive access into the system
    if ( !access_lock.GetLock(INFINITE) )
    {
        is_valid = FALSE;
        return rc;
    }

    // return immediately, if the operation is not valid
    if ( !is_valid )
        return rc;

    // process the message

    if ( user_msg_id == Window :: g_SendErrorEvent )
    {
    // in case the attempt to send a frame failed
       VBList *vblist = (VBList *)wParam;
       GeneralException *exception = (GeneralException *)lParam;

       ReceiveErroredResponse(vblist->GetIndex (),vblist->GetVarBindList(), *exception);
       
       delete vblist;
       delete exception;
    }
    else if ( user_msg_id == Window :: g_OperationCompletedEvent )
    {
// signals completion of the operation

        frame_state_registry.DestroySecurity();
        in_progress = FALSE;
        ReceiveResponse();
    }
    else
    {
    // predefined window message
        DefWindowProc(hWnd, user_msg_id, wParam, lParam);
    }

    // give up exclusive access
    access_lock.UnLock();

    // since this is also a point of entry into the SnmpOperation
    // we must check for deletion of the operation
    CheckOperationDeletion();

    return rc;
}

// this method may be called to delete the Operation
// note: the operation is deleted when a public method
// returns. For this reason, if a public method calls another 
// public method, it must not access any per-class variables
// after that.
void SnmpOperation::DestroyOperation()
{
    delete_operation = TRUE;
}


// its mandatory for every public method to call this method
// before returning to the caller
// it checks if the call sequence included a call to DestroyOperation
// and if so, deletes "this" before returning
void SnmpOperation::CheckOperationDeletion()
{
    if ( delete_operation == TRUE )
        delete this;
}

#pragma warning (disable:4355)

// initializes variables and, if successful, registers itself with the session
SnmpOperation::SnmpOperation(

    SnmpSession &snmp_session

) : session(snmp_session),
    m_OperationWindow(*this),
    helper(*this)
{
    in_progress = FALSE;
    is_valid = FALSE;

    if ( !m_OperationWindow() )
        return;

    varbinds_per_pdu = SnmpImpSession :: VarbindsPerPdu ( session.GetVarbindsPerPdu() ) ;

    delete_operation = FALSE;
    is_valid = TRUE;

    session.RegisterOperation(*this);
}

#pragma warning (default:4355)

// on destruction, the operation cancels all outstanding frames,
// frees the allocated memory for variables and deregisters with the session
SnmpOperation::~SnmpOperation(void)
{
    // calls to public functions from this point should not
    // cause repeated deletion - so set the flag to FALSE
    delete_operation = FALSE;

    // cancel any outstanding frames
    CancelRequest();
    
    // deregister with session
    session.DeregisterOperation(*this);
}


// sends the varbinds in the var bind list packaged in several
// frames each carrying atmost varbinds_per_pdu varbinds
// if the security context is not NULL, same is used as the context
// for all the generated frames

void SnmpOperation::SendRequest(

    IN SnmpVarBindList &varBindList,
    IN SnmpSecurity *security
)
{
    // if not valid, return immediately
    if ( !is_valid )
        return;

    CriticalSectionLock access_lock(exclusive_CriticalSection); // TRUE

    // obtain exclusive access into the system
    if ( !access_lock.GetLock(INFINITE) )
    {
        is_valid = FALSE;
        return;
    }

    // if already in progress, we cannot proceed
    if ( in_progress == TRUE )
        return;

    in_progress = TRUE;

    // if length of varBindList exceeds varbinds_per_pdu
    // call FrameOverRun()
    if ( varBindList.GetLength() > varbinds_per_pdu )
        FrameOverRun();

    // check if the send request has been cancelled in the
    // meantime. Proceed only if still in progress
    if ( !in_progress )
        return;

    // register the security for the duration of SendRequest
    // (until a reply for the last outstanding frame is received) 
    frame_state_registry.RegisterSecurity(security);

    // send the varbind list
    SendVarBindList(varBindList);

    // if no outstanding frames, post a message for the completion
    // of operation. This message, when processed, shall set the
    // in_progress status, destroy security and call ReceiveResponse
    if ( frame_state_registry.Empty() )
    {
        m_OperationWindow.PostMessage ( 

            Window :: g_OperationCompletedEvent , 
            0, 
            0
        );
    }

    // give up exclusive access
    // access_lock.UnLock();   The lock may be released at this point
}


void SnmpOperation::SendRequest(IN SnmpVarBindList &varBindList)
{
    SendRequest(varBindList, NULL);
    CheckOperationDeletion();
}

void SnmpOperation::SendRequest(

    IN SnmpVarBindList &varBindList,
    IN SnmpSecurity &security
)
{
    SendRequest(varBindList, &security);
    CheckOperationDeletion();
}


// sends the varbinds in the var bind list packaged in several
// frames each carrying atmost MIN(varbinds_per_pdu, max_size) varbinds
void SnmpOperation::SendVarBindList(IN SnmpVarBindList &varBindList,
                                    IN UINT max_size,
                                    IN ULONG var_index )
{
    UINT max_varbinds_per_pdu = MIN(varbinds_per_pdu, max_size);
    UINT list_length = varBindList.GetLength();

    // set list iterator to the start of the list, 
    // current_position <- 0
    varBindList.Reset();
    varBindList.Next();
    UINT current_position = 0;

    // chop up the varBindList into segments atmost max_varbinds_per_pdu
    // in size and send them in separate frames
    while ( current_position < list_length )
    {
        UINT segment_length = MIN((list_length-current_position), max_varbinds_per_pdu);

        // create copy of the varBindList from
        // current_position (of length segment_length)
        SnmpVarBindList *list_segment = varBindList.CopySegment(segment_length);

        // create a VBList and call SendFrame with it

        SendFrame ( 

            *(new VBList(session.GetSnmpEncodeDecode (),*list_segment,var_index + current_position + 1))
        );  

        // update current_position
        current_position += segment_length;
    }
}


// transmits a frame with the var binds in the vblist
// using the session and registers the frame state
void SnmpOperation::SendFrame(VBList &vblist)
{
    try
    {
        SessionFrameId session_frame_id = 0L;

        helper.TransmitFrame (

            session_frame_id, 
            vblist
        );

        FrameState *frame_state = new FrameState(session_frame_id,vblist);

        // insert a frame_state(session_frame_id, vblist)
        frame_state_registry.Insert(session_frame_id, *frame_state );
    }
    catch(GeneralException exception)
    {
        // post a message to signal the error in sending the frame
        // when processed, it shall call ReceiveErroredResponse and
        // delete the vblist
        m_OperationWindow.PostMessage (  

            Window :: g_SendErrorEvent , 
            (WPARAM)&vblist, 
            (LPARAM)(new GeneralException(exception))
        );
    }
}


// used to retransmit a frame specified by the frame state
// the frame state is reused by giving it a different session frame id
void SnmpOperation::SendFrame(FrameState &frame_state)
{
    try
    {
        SessionFrameId session_frame_id = 0L;

        helper.TransmitFrame (

            session_frame_id, 
            *frame_state.GetVBList()
        );

        frame_state.SetSessionFrameId(session_frame_id);

        // insert a frame_state(session_frame_id, vblist)
        frame_state_registry.Insert(session_frame_id, frame_state);
    }
    catch(GeneralException exception)
    {
        ReceiveErroredResponse (

            frame_state.GetVBList()->GetIndex (),
            frame_state.GetVBList()->GetVarBindList(), 
            exception
        );

        delete &frame_state;
    }

}


// a sent frame notification from the session signifies one transmission
// of the frame. atmost one notification per session frame id can 
// signal an error in transmission
void SnmpOperation::SentFrame(

    IN const SessionFrameId session_frame_id,
    IN const SnmpErrorReport &error_report
)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Sent %d\n" ,session_frame_id
    ) ;
)

    // if there was an error in sending, let ReceiveFrame handle it
    // otherwise ignore it and wait for the reply
    if ( error_report.GetError() != Snmp_Success )
    {
        ReceiveFrame (

            session_frame_id, 
            SnmpPdu(), 
            error_report
        );
    }
    else
    {
        CheckOperationDeletion();
    }

    // since ReceiveFrame might have deleted the operation, we
    // must call CheckOperationDeletion only in the else 
}

// cancels all the frames whose frame states are currently present in
// the frame state registry
void SnmpOperation::CancelRequest()
{
    // if not valid, return immediately
    if ( !is_valid )
        return;

    CriticalSectionLock exclusive_lock(exclusive_CriticalSection);

    // obtain exclusive access
    if ( !exclusive_lock.GetLock(INFINITE) )
    {
        is_valid = FALSE;
        return;
    }

    // if not in progress, there is nothing to be done
    if ( !in_progress )
        return;

    // reset the frame_state_registry to set
    // the iterator to the beginning
    frame_state_registry.ResetIterator();

    // cancel all outstanding frames
    while (1)
    {
        // for each registered frame_state

        // remove it from the frame_state_registry
        FrameState *frame_state = frame_state_registry.GetNext();

        // if no more frames, we are done
        if ( frame_state == NULL )
            break;

        // cancel the corresponding frame
        session.SessionCancelFrame(

            frame_state->GetSessionFrameId()
        );

        // destroy frame_state
        delete frame_state;
    }

    // remove all the associations
    frame_state_registry.RemoveAll();

    // destroy the security
    frame_state_registry.DestroySecurity();
    
    // in_progress <- FALSE
    in_progress = FALSE;

    m_OperationWindow.PostMessage ( 

        Window :: g_OperationCompletedEvent , 
        0, 
        0
    );

    // leave exclusive access
    exclusive_lock.UnLock();

    CheckOperationDeletion();
}


void SnmpOperation::ReceiveErroredResponse(

    ULONG var_index ,
    SnmpVarBindList &errored_list,
    const SnmpErrorReport &error_report
)
{
    ULONG t_Index = 0 ;
    errored_list.Reset();
    while( errored_list.Next() )
    {
        const SnmpVarBind *var_bind = errored_list.Get();

        ReceiveErroredVarBindResponse(

            var_index + t_Index ,
            *var_bind, 
            error_report
        );

        t_Index ++ ;
    }
}


// ReceiveFrame is called by the session when a reply is received for
// an outstanding frame or it has received no response for its
// retransmissions. It may also be called by the SnmpOperation::SentFrame
// when the error report shows an error during transmission
// It decodes the received snmp pdu and processes it or else, if no
// reply has been received, informs the user of the error report
// when all no outstanding frames remain, an OPERATION_COMPLETION event
// is posted to inform the user of the event asynchronously

void SnmpOperation::ReceiveFrame(

    IN const SessionFrameId session_frame_id,
    IN const SnmpPdu &snmpPdu,
    IN const SnmpErrorReport &errorReport
)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpOperation::ReceiveFrame: received(%d), error(%d), status(%d)\n",session_frame_id, errorReport.GetError(), errorReport.GetStatus()
    ) ;
)

    // if not valid, return immediately
    if ( !is_valid )
        return;

    CriticalSectionLock exclusive_lock(exclusive_CriticalSection);

    // obt. exclusive access
    if ( !exclusive_lock.GetLock(INFINITE) )
    {
        is_valid = FALSE;
        return;
    }

    // if not in progress, nothing needs to be done
    // ignore the 
    if ( !in_progress )
        return;

    // get corresponding frame_state
    FrameState *frame_state = frame_state_registry.Remove(session_frame_id);

    // if no such frame_state return
    if ( frame_state == NULL )
        return;

    // decode the frame to extract 
    // vbl, error-index, error-status

    SnmpErrorReport t_SnmpErrorReport ;
    SnmpVarBindList *t_SnmpVarBindList ;
    SnmpCommunityBasedSecurity *t_SnmpCommunityBasedSecurity = NULL ;
    SnmpTransportAddress *t_SrcTransportAddress = NULL ;
    SnmpTransportAddress *t_DstTransportAddress = NULL ;
    SnmpEncodeDecode :: PduType t_PduType  = SnmpEncodeDecode :: PduType :: GET;
    RequestId t_RequestId = 0 ;
    
    try
    {
        session.GetSnmpEncodeDecode ().DecodeFrame (

            ( SnmpPdu& ) snmpPdu ,
            t_RequestId ,
            t_PduType ,
            t_SnmpErrorReport ,
            t_SnmpVarBindList ,
            t_SnmpCommunityBasedSecurity ,
            t_SrcTransportAddress ,
            t_DstTransportAddress
        );
    }
    catch(GeneralException exception)
    {
        CheckOperationDeletion();
        return;
    }

    t_SnmpErrorReport = errorReport ;

    helper.ProcessResponse (

        frame_state, 
        *t_SnmpVarBindList, 
        t_SnmpErrorReport
    );

    // if the registry is empty,
    // destroy security, set in_progress, release exclusive access
    // call ReceiveResponse() to signal completion finally
    if ( frame_state_registry.Empty() )
    {
        frame_state_registry.DestroySecurity();
        in_progress = FALSE;

        // leave exclusive access: so that the ReceiveResponse
        // call back may be able to make another SendRequest
        exclusive_lock.UnLock();

        // call the user to inform him of completion
        ReceiveResponse();
    }
    else
    {
        // leave exclusive access
        exclusive_lock.UnLock();
    }
        
    CheckOperationDeletion();
}


// The GetOperation sends the GET PDU
SnmpEncodeDecode :: PduType SnmpGetOperation::GetPduType(void)
{
    return SnmpEncodeDecode :: GET;
}


// The GetOperation sends the GETNEXT PDU
SnmpEncodeDecode ::PduType SnmpGetNextOperation::GetPduType(void)
{
    return SnmpEncodeDecode :: GETNEXT;
}


// The GetOperation sends the SET PDU
SnmpEncodeDecode :: PduType SnmpSetOperation::GetPduType(void)
{
    return SnmpEncodeDecode :: SET;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\pdu.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: pdu.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "encdec.h"
#include "vblist.h"
#include "sec.h"
#include "address.h"
#include "pdu.h"

SnmpPdu::SnmpPdu():m_SourceAddress (NULL),m_DestinationAddress(NULL),m_SnmpCommunityName (NULL),length(0),ptr(NULL),m_SnmpVarBindList(NULL)
{
    is_valid = FALSE;
}


SnmpPdu::SnmpPdu(IN SnmpPdu &snmpPdu):m_SourceAddress (NULL),m_DestinationAddress(NULL),m_SnmpCommunityName (NULL),m_SnmpVarBindList(NULL)
{
    is_valid = FALSE;

    Initialize(snmpPdu.GetFrame(), snmpPdu.GetFrameLength());

    m_RequestId = snmpPdu.m_RequestId ;
    m_PduType = snmpPdu.m_PduType ;
    m_ErrorReport = snmpPdu.m_ErrorReport ;
    m_SnmpVarBindList = new SnmpVarBindList ( *snmpPdu.m_SnmpVarBindList ) ;
    m_SourceAddress = snmpPdu.m_SourceAddress ? snmpPdu.m_SourceAddress->Copy () : NULL ;
    m_DestinationAddress = snmpPdu.m_DestinationAddress ? snmpPdu.m_DestinationAddress->Copy () : NULL ;
    m_SnmpCommunityName = snmpPdu.m_SnmpCommunityName ? ( SnmpCommunityBasedSecurity * ) snmpPdu.m_SnmpCommunityName->Copy () : NULL ;

    is_valid = TRUE ;
}

SnmpPdu::SnmpPdu(IN const UCHAR *frame, IN const ULONG &frameLength) : m_SourceAddress (NULL),m_DestinationAddress(NULL),m_SnmpCommunityName (NULL),m_SnmpVarBindList(NULL)
{
    Initialize(frame, frameLength);
}

SnmpPdu::~SnmpPdu(void) 
{
    FreeFrame();
    FreePdu () ;
}

void SnmpPdu::FreeFrame(void)
{
    if ( is_valid )
    {
        delete[] ptr;
    }
}

void SnmpPdu::FreePdu ()
{
    delete m_SnmpCommunityName ;
    delete m_DestinationAddress ;
    delete m_SourceAddress ;
}

void SnmpPdu::Initialize(IN const UCHAR *frame, IN const ULONG &frameLength)
{
    if ( frame )
    {
        length = frameLength;
        ptr = new UCHAR[frameLength];
        memcpy(ptr, frame, length);
    }
    else
    {
        length = 0 ;
        ptr = NULL ;
    }

    is_valid = TRUE;
}

ULONG SnmpPdu::GetFrameLength() const
{
    return ( (is_valid)?length:0 );
}

UCHAR *SnmpPdu::GetFrame() const
{
    return ( (is_valid)?ptr:NULL );
}

void SnmpPdu::SetPdu ( IN SnmpPdu &a_SnmpPdu )
{
    FreeFrame();
    FreePdu () ;

    Initialize(a_SnmpPdu.GetFrame(), a_SnmpPdu.GetFrameLength());

    m_RequestId = a_SnmpPdu.m_RequestId ;
    m_PduType = a_SnmpPdu.m_PduType ;
    m_ErrorReport = a_SnmpPdu.m_ErrorReport ;
    m_SnmpVarBindList = new SnmpVarBindList ( *a_SnmpPdu.m_SnmpVarBindList ) ;
    m_SourceAddress = a_SnmpPdu.m_SourceAddress ? a_SnmpPdu.m_SourceAddress->Copy () : NULL ;
    m_DestinationAddress = a_SnmpPdu.m_DestinationAddress ? a_SnmpPdu.m_DestinationAddress->Copy () : NULL ;
    m_SnmpCommunityName = a_SnmpPdu.m_SnmpCommunityName ? ( SnmpCommunityBasedSecurity * ) a_SnmpPdu.m_SnmpCommunityName->Copy () : NULL ;

}

void SnmpPdu::SetPdu(IN const UCHAR *frame, IN const ULONG frameLength)
{
    FreeFrame();

    Initialize(frame, frameLength);
}

BOOL SnmpPdu :: SetRequestId ( IN RequestId a_RequestId )
{
    m_RequestId = a_RequestId ;

    return TRUE ;
}

BOOL SnmpPdu :: SetVarBindList ( OUT SnmpVarBindList &a_SnmpVarBindList )
{
    if ( m_SnmpVarBindList )
        delete m_SnmpVarBindList ;

    m_SnmpVarBindList = &a_SnmpVarBindList ;

    return TRUE ;
}

BOOL SnmpPdu :: SetCommunityName ( IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity )
{
    delete m_SnmpCommunityName ;
    m_SnmpCommunityName = &a_SnmpCommunityBasedSecurity ;

    return TRUE ;
}

BOOL SnmpPdu :: SetErrorReport ( OUT SnmpErrorReport &a_SnmpErrorReport )
{
    m_ErrorReport = a_SnmpErrorReport ;

    return TRUE ;
}

BOOL SnmpPdu :: SetPduType ( OUT SnmpEncodeDecode :: PduType a_PduType )
{
    m_PduType = a_PduType ;
    return TRUE ;
}

BOOL SnmpPdu :: SetSourceAddress ( IN SnmpTransportAddress &a_TransportAddress )
{
    delete m_SourceAddress ;
    m_SourceAddress = &a_TransportAddress ;

    return TRUE ;
}

BOOL SnmpPdu :: SetDestinationAddress ( IN SnmpTransportAddress &a_TransportAddress )
{
    delete m_DestinationAddress ;
    m_DestinationAddress = &a_TransportAddress ;

    return TRUE ;
}

SnmpTransportAddress &SnmpPdu :: GetSourceAddress ()
{
    return *m_SourceAddress ;
}

SnmpTransportAddress &SnmpPdu :: GetDestinationAddress ()
{
    return *m_DestinationAddress ;
}

SnmpEncodeDecode :: PduType &SnmpPdu :: GetPduType ()
{
    return m_PduType ;
}

RequestId &SnmpPdu :: GetRequestId ()
{
    return m_RequestId ;
}

SnmpErrorReport &SnmpPdu :: GetErrorReport ()
{
    return m_ErrorReport ;

}

SnmpVarBindList &SnmpPdu :: GetVarbindList ()
{
    return *m_SnmpVarBindList ;
}

SnmpCommunityBasedSecurity &SnmpPdu :: GetCommunityName ()
{
    return *m_SnmpCommunityName ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\snmpcont.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\ssent.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: ssent.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "ssent.h"

void SessionSentStateStore::Register(IN SessionFrameId id, 
                                      IN SnmpOperation &operation,
                                      IN const SnmpErrorReport &error_report)
{
    store[id] = new ErrorInfo(operation, error_report);
}


SnmpErrorReport SessionSentStateStore::Remove(IN SessionFrameId id, OUT SnmpOperation *&operation) 
{
    ErrorInfo *error_info;

    BOOL found = store.Lookup(id, error_info);

    if ( !found )
    {
        operation = NULL;
        return SnmpErrorReport(Snmp_Error, Snmp_Local_Error);
    }

    store.RemoveKey(id);

    SnmpErrorReport to_return(error_info->GetErrorReport());
    operation = error_info->GetOperation();

    delete error_info;

    return to_return;
}


void SessionSentStateStore::Remove(IN SessionFrameId id)
{
    SnmpOperation *operation;

    Remove(id, operation);
}

SessionSentStateStore::~SessionSentStateStore(void)
{
    // get the first position
    POSITION current = store.GetStartPosition();

    // while the position isn't null
    while ( current != NULL )
    {
        SessionFrameId id;
        ErrorInfo *error_info;

        // get the next pair
        store.GetNextAssoc(current, id, error_info);

        // delete the ptr
        delete error_info;
    }

    // remove all the keys
    store.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\snmptype.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <typeinfo.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <winsock.h>
#include <strstrea.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>

#if _MSC_VER >= 1100
template <> UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key )
#else
UINT HashKey ( wchar_t *key )
#endif
{
    UCHAR *value = ( UCHAR * ) key ;
    ULONG length = wcslen ( key ) * sizeof ( wchar_t ) ;

    UINT hash;
    if (length > 1)
    {
        USHORT even = 0;
        USHORT odd = 0;

        for (ULONG i = length >> 1; i--;)
        {
            even += towlower (*value++) ;
            odd += towlower (*value++) ;
        }
        if (length & 1)
        {
            even += towlower (*value);
        }
        hash = odd>>8;
        hash |= (odd & 0xff) << 8;
        hash ^= even;
    }
    else
    {
        hash = *value;
    }

    return hash ;
}

#if _MSC_VER >= 1100
typedef wchar_t * WbemHack_wchar_t ;
template<> BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const WbemHack_wchar_t *pElement1, const WbemHack_wchar_t *pElement2 )
#else
BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 )
#endif
{
    return _wcsicmp ( *pElement1 , *pElement2 ) == 0 ;
}

CBString::CBString(int nSize) : m_pString ( NULL )
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString) : m_pString ( NULL )
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) 
    {
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}

DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString )
{
    size_t textLength = mbstowcs ( NULL , dbcsString , 0  ) ;
    wchar_t *unicodeString = new wchar_t [ textLength + 1 ] ;
    textLength = mbstowcs ( unicodeString , dbcsString , textLength + 1 ) ;
    if ( textLength == -1 )
    {
        delete [] unicodeString ;
        unicodeString = NULL ;
    }

    return unicodeString ;
}

DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString )
{
    size_t textLength = wcstombs ( NULL , unicodeString , 0 ) ;
    char *dbcsString = new char [ textLength + 1 ] ;
    textLength = wcstombs ( dbcsString , unicodeString , textLength + 1 ) ;
    if ( textLength == -1 )
    {
        delete [] dbcsString ;
        dbcsString = NULL ;
    }

    return dbcsString ;
}

DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) 
{
    if ( string )
    {
        int textLength = wcslen ( string ) ;

        wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;
        wcscpy ( textBuffer , string ) ;

        return textBuffer ;
    }
    else
    {
        return NULL ;
    }
}

DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix )
{
    int prefixTextLength = 0 ;
    if ( prefix )
    {
        prefixTextLength = wcslen ( prefix ) ;
    }

    int suffixTextLength = 0 ;
    if ( suffix )
    {
        suffixTextLength = wcslen ( suffix ) ;
    }

    if ( prefix || suffix )
    {
        int textLength = prefixTextLength + suffixTextLength ;
        wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;

        if ( prefix )
        {
            wcscpy ( textBuffer , prefix ) ;
        }

        if ( suffix )
        {
            wcscpy ( & textBuffer [ prefixTextLength ] , suffix ) ;
        }

        return textBuffer ;
    }   
    else
        return NULL ;
}

SnmpLexicon :: SnmpLexicon () : position ( 0 ) , tokenStream ( NULL ) , token ( INVALID_ID )
{
    value.token = NULL ;
}

SnmpLexicon :: ~SnmpLexicon ()
{
    switch ( token ) 
    {
        case TOKEN_ID:
        {
            delete [] value.token ;
        }
        break ;
    
        default:
        {
        } ;
    }
}

void SnmpLexicon :: SetToken ( SnmpLexicon :: LexiconToken a_Token )
{
    token = a_Token ;
}

SnmpLexicon :: LexiconToken SnmpLexicon :: GetToken ()
{
    return token ;
}

SnmpLexiconValue *SnmpLexicon :: GetValue ()
{
    return &value ;
}

SnmpAnalyser :: SnmpAnalyser ( const wchar_t *tokenStream ) : status ( TRUE ) , position ( 0 ) , stream ( NULL ) 
{
    if ( tokenStream )
    {
        stream = new wchar_t [ wcslen ( tokenStream ) + 1 ] ;
        wcscpy ( stream , tokenStream ) ;
    }
}

SnmpAnalyser :: ~SnmpAnalyser () 
{
    delete [] stream ;
}

void SnmpAnalyser :: Set ( const wchar_t *tokenStream ) 
{
    status = 0 ;
    position = NULL ;

    delete [] stream ;
    stream = NULL ;
    stream = new wchar_t [ wcslen ( tokenStream ) + 1 ] ;
    wcscpy ( stream , tokenStream ) ;
}

void SnmpAnalyser :: PutBack ( const SnmpLexicon *token ) 
{
    position = token->position ;
}

SnmpAnalyser :: operator void * () 
{
    return status ? this : NULL ;
}

SnmpLexicon *SnmpAnalyser :: Get ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace ) 
{
    SnmpLexicon *lexicon = NULL ;

    if ( stream )
    {
        lexicon = GetToken ( unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) ;
    }
    else
    {
        lexicon = CreateLexicon () ;
        lexicon->position = position ;
        lexicon->token = SnmpLexicon :: EOF_ID ;
    }

    return lexicon ;
}

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define TOKEN_START 5000
#define WHITESPACE_START 6000
#define ACCEPT_STATE ANALYSER_ACCEPT_STATE
#define REJECT_STATE ANALYSER_REJECT_STATE 

SnmpLexicon *SnmpAnalyser :: GetToken ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace )  
{
    SnmpLexicon *lexicon = CreateLexicon () ;
    lexicon->position = position ;

    Initialise () ;

    ULONG state = 0 ;

/* 
 * Integer Definitions
 */

    BOOL negative = FALSE ;
    BOOL positive = FALSE ;

    ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
    ULONG positiveMagicPosDigit = 5 ;
    ULONG positiveDatum = 0 ;   

    LONG negativeMagicMult = ( LONG ) ( ( ( ULONG ) ( 1L << 31L ) ) / 10L ) ; 
    ULONG negativeMagicNegDigit = 8 ;
    ULONG negativeMagicPosDigit = 7 ;
    LONG negativeDatum = 0 ;    

/*
 * Token Definitions
 */

    ULONG token_start = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = stream [ position ] ;
        if ( Analyse ( lexicon , state , token , stream , position , unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) )
        {
        }
        else
        {
            switch ( state )
            {
                case 0:
                {
                    if ( IsAlpha ( token ) )
                    {
                        state = TOKEN_START ;
                        token_start = position ;
                    }
                    else if ( SnmpAnalyser :: IsLeadingDecimal ( token ) )
                    {
                        state = DEC_INTEGER_START + 1  ;
                        negativeDatum = ( token - 48 ) ;
                    }
                    else if ( token == L'+' )
                    {
                        if ( unSignedIntegersOnly ) 
                        {
                            state = ACCEPT_STATE ;
                            lexicon->token = SnmpLexicon :: PLUS_ID ;
                        }
                        else
                        {
                            state = DEC_INTEGER_START ;
                        }
                    }
                    else if ( token == L'-' ) 
                    {
                        if ( unSignedIntegersOnly )
                        {
                            state = ACCEPT_STATE ;
                            lexicon->token = SnmpLexicon :: MINUS_ID ;
                        }
                        else
                        {
                            negative = TRUE ;
                            state = DEC_INTEGER_START ;
                        }
                    }
                    else if ( token == L'0' )
                    {
                        if ( ! leadingIntegerZeros ) 
                        {
                            state = 1 ;
                        }
                        else
                        {
                            negativeDatum = 0 ;
                            state = DEC_INTEGER_START + 1 ;
                        }
                    }
                    else if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                    {
                        if ( eatSpace )
                        {
                            state = 0 ;
                        }
                        else
                        {
                            lexicon->token = SnmpLexicon :: WHITESPACE_ID ;
                            state = WHITESPACE_START ;
                        }
                    }
                    else if ( token == L'(' )
                    {
                        lexicon->token = SnmpLexicon :: OPEN_PAREN_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else if ( token == L')' )
                    {
                        lexicon->token = SnmpLexicon :: CLOSE_PAREN_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else if ( token == L',' )
                    {
                        lexicon->token = SnmpLexicon :: COMMA_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else if ( token == L':' )
                    {
                        lexicon->token = SnmpLexicon :: COLON_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else if ( token == L'.' )
                    {
                        state = 2;
                    }
                    else if ( IsEof ( token ) )
                    {
                        lexicon->token = SnmpLexicon :: EOF_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
                break ;

                case 1:
                {
                    if ( token == L'x' || token == L'X' )
                    {
                        state = HEX_INTEGER_START ;             
                    }
                    else if ( SnmpAnalyser :: IsOctal ( token ) )
                    {
                        state = OCT_INTEGER_START ;
                        positiveDatum = ( token - 48 ) ;
                    }
                    else
                    {
                        if ( unSignedIntegersOnly )
                        {
                            lexicon->token = SnmpLexicon :: UNSIGNED_INTEGER_ID ;
                            lexicon->value.unsignedInteger = 0 ;
                        }
                        else
                        {
                            lexicon->token = SnmpLexicon :: SIGNED_INTEGER_ID ;
                            lexicon->value.signedInteger = 0 ;
                        }

                        state = ACCEPT_STATE ;
                        position -- ;
                    }
                }
                break ;

                case 2:
                {
                    if ( token == L'.' )
                    {
                        lexicon->token = SnmpLexicon :: DOTDOT_ID ;
                        state = ACCEPT_STATE ;
                    }
                    else
                    {
                        lexicon->token = SnmpLexicon :: DOT_ID ;
                        position -- ;
                        state = ACCEPT_STATE  ;
                    }
                }
                break ;

                case TOKEN_START:
                {
                    if ( IsAlphaNumeric ( token ) ) 
                    {
                        state = TOKEN_START ;
                    }
                    else 
                    {
                        state = ACCEPT_STATE ;
                        lexicon->token = SnmpLexicon :: TOKEN_ID ;
                        lexicon->value.token = new wchar_t [ position - token_start + 1 ] ;
                        wcsncpy ( 

                            lexicon->value.token , 
                            & stream [ token_start ] , 
                            position - token_start 
                        ) ;

                        lexicon->value.token [ position - token_start ] = 0 ;

                        position -- ;
                    }
                }
                break ;

                case WHITESPACE_START:
                {
                    if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                    {
                        state = WHITESPACE_START ;
                    }
                    else
                    {
                        state = ACCEPT_STATE ;
                        position -- ;
                    }
                }
                break;

                case HEX_INTEGER_START:
                {
                    if ( SnmpAnalyser :: IsHex ( token ) )
                    {
                        positiveDatum = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                        state = HEX_INTEGER_START + 1 ;
                    }
                    else
                    {
                        state = REJECT_STATE ;
                    }
                }
                break ;

                case HEX_INTEGER_START+1:
                {
                    if ( SnmpAnalyser :: IsHex ( token ) )
                    {
                        state = HEX_INTEGER_START + 1 ;

                        if ( positiveDatum > positiveMagicMult )
                        {
                            state = REJECT_STATE ;
                        }
                        else if ( positiveDatum == positiveMagicMult ) 
                        {
                            if ( SnmpAnalyser :: HexWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
                            {
                                state = REJECT_STATE ;
                            }
                        }

                        positiveDatum = ( positiveDatum << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    }
                    else
                    {
                        lexicon->token = SnmpLexicon :: UNSIGNED_INTEGER_ID ;
                        lexicon->value.unsignedInteger = positiveDatum ;
                        state = ACCEPT_STATE ;

                        position -- ;
                    }
                }
                break ;

                case OCT_INTEGER_START:
                {
                    if ( SnmpAnalyser :: IsOctal ( token ) )
                    {
                        state = OCT_INTEGER_START ;

                        if ( positiveDatum > positiveMagicMult )
                        {
                            state = REJECT_STATE ;
                        }
                        else if ( positiveDatum == positiveMagicMult ) 
                        {
                            if ( SnmpAnalyser :: OctWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
                            {
                                state = REJECT_STATE ;
                            }
                        }

                        positiveDatum = ( positiveDatum << 3 ) + SnmpAnalyser :: OctWCharToDecInteger ( token ) ;
                    }
                    else
                    {
                        lexicon->token = SnmpLexicon :: UNSIGNED_INTEGER_ID ;
                        lexicon->value.unsignedInteger = positiveDatum ;
                        state = ACCEPT_STATE ;

                        position -- ;
                    }
                }
                break ;

                case DEC_INTEGER_START:
                {
                    if ( SnmpAnalyser :: IsDecimal ( token ) )
                    {
                        negativeDatum = ( token - 48 ) ;
                        state = DEC_INTEGER_START + 1 ;
                    }
                    else 
                    if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                    {
                        state = DEC_INTEGER_START ;
                    }
                    else state = REJECT_STATE ;
                }   
                break ;

                case DEC_INTEGER_START+1:
                {
                    if ( SnmpAnalyser :: IsDecimal ( token ) )
                    {   
                        state = DEC_INTEGER_START + 1 ;

                        if ( positive )
                        {
                            if ( positiveDatum > positiveMagicMult )
                            {
                                state = REJECT_STATE ;
                            }
                            else if ( positiveDatum == positiveMagicMult ) 
                            {
                                if ( ( ULONG ) ( token - 48 ) > positiveMagicPosDigit ) 
                                {
                                    state = REJECT_STATE ;
                                }
                            }
                        }
                        else
                        {
                            if ( negativeDatum > negativeMagicMult )
                            {
                                state = REJECT_STATE ;
                            }
                            else if ( negativeDatum == negativeMagicMult ) 
                            {
                                if ( negative ) 
                                {
                                    if ( ( ULONG ) ( token - 48 ) > negativeMagicNegDigit ) 
                                    {
                                        state = REJECT_STATE ;
                                    }
                                }
                                else
                                {
                                    if ( ( ULONG ) ( token - 48 ) > negativeMagicPosDigit ) 
                                    {
                                        positiveDatum = negativeDatum ;
                                        positive = TRUE ;
                                    }
                                }
                            }
                        }

                        if ( positive )
                        {
                            positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
                        }
                        else
                        {
                            negativeDatum = negativeDatum * 10 + ( token - 48 ) ;
                        }
                    }
                    else
                    {
                        if ( negative )
                        {
                            if ( ! unSignedIntegersOnly )
                            {
                                lexicon->token = SnmpLexicon :: SIGNED_INTEGER_ID ;
                                lexicon->value.signedInteger = negativeDatum * -1 ;
                            }
                            else
                            {
                                state = REJECT_STATE ;
                            }
                        }
                        else if ( positive )
                        {
                            lexicon->token = SnmpLexicon :: UNSIGNED_INTEGER_ID ;
                            lexicon->value.unsignedInteger = positiveDatum ;
                        }
                        else
                        {
                            if ( unSignedIntegersOnly )
                            {
                                lexicon->token = SnmpLexicon :: UNSIGNED_INTEGER_ID ;
                                lexicon->value.signedInteger = negativeDatum ;
                            }
                            else
                            {
                                lexicon->token = SnmpLexicon :: SIGNED_INTEGER_ID ;
                                lexicon->value.signedInteger = negativeDatum ;
                            }
                        }

                        state = ACCEPT_STATE ;

                        position -- ;
                    }
                }   
                break ;

                case ACCEPT_STATE:
                case REJECT_STATE:
                default:
                {
                    state = REJECT_STATE ;
                } ;
                break ;
            }
        }

        position ++ ;
    }

    status = ( state != REJECT_STATE ) ;

    return lexicon ;
}

BOOL SnmpAnalyser :: IsLeadingDecimal ( wchar_t token )
{
    return iswdigit ( token ) && ( token != L'0' ) ;
}

BOOL SnmpAnalyser :: IsDecimal ( wchar_t token )
{
    return iswdigit ( token ) ;
}

BOOL SnmpAnalyser :: IsHex ( wchar_t token )
{
    return iswxdigit ( token ) ;
}
    
BOOL SnmpAnalyser :: IsWhitespace ( wchar_t token )
{
    return iswspace ( token ) ;
}

BOOL SnmpAnalyser :: IsOctal ( wchar_t token )
{
    return ( token >= L'0' && token <= L'7' ) ;
}

BOOL SnmpAnalyser :: IsAlpha ( wchar_t token )
{
    return iswalpha ( token ) ;
}

BOOL SnmpAnalyser :: IsAlphaNumeric ( wchar_t token )
{
    return iswalnum ( token ) || ( token == L'_' ) || ( token == L'-' ) ;
}

BOOL SnmpAnalyser :: IsEof ( wchar_t token )
{
    return token == 0 ;
}

ULONG SnmpAnalyser :: OctWCharToDecInteger ( wchar_t token ) 
{
    return token - L'0' ;
}

ULONG SnmpAnalyser :: HexWCharToDecInteger ( wchar_t token ) 
{
    if ( token >= L'0' && token <= L'9' )
    {
        return token - L'0' ;
    }
    else if ( token >= L'a' && token <= L'f' )
    {
        return token - L'a' + 10 ;
    }
    else if ( token >= L'A' && token <= L'F' )
    {
        return token - L'A' + 10 ;
    }
    else
    {
        return 0 ;
    }
}

ULONG SnmpAnalyser :: DecWCharToDecInteger ( wchar_t token ) 
{
    if ( token >= L'0' && token <= L'9' )
    {
        return token - L'0' ;
    }
    else
    {
        return 0 ;
    }
}

wchar_t SnmpAnalyser :: DecIntegerToOctWChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 7 )
    {
        return L'0' + integer ;
    }
    else
    {
        return L'0' ;
    }
}

wchar_t SnmpAnalyser :: DecIntegerToDecWChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 9 )
    {
        return L'0' + integer ;
    }
    else
    {
        return L'0' ;
    }
}

wchar_t SnmpAnalyser :: DecIntegerToHexWChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 9 )
    {
        return L'0' + integer ;
    }
    else if ( integer >= 10 && integer <= 15 )
    {
        return L'a' + ( integer - 10 ) ;
    }
    else
    {
        return L'0' ;
    }
}

ULONG SnmpAnalyser :: OctCharToDecInteger ( char token ) 
{
    return token - '0' ;
}

ULONG SnmpAnalyser :: HexCharToDecInteger ( char token ) 
{
    if ( token >= '0' && token <= '9' )
    {
        return token - '0' ;
    }
    else if ( token >= 'a' && token <= 'f' )
    {
        return token - 'a' + 10 ;
    }
    else if ( token >= 'A' && token <= 'F' )
    {
        return token - 'A' + 10 ;
    }
    else
    {
        return 0 ;
    }
}

ULONG SnmpAnalyser :: DecCharToDecInteger ( char token ) 
{
    if ( token >= '0' && token <= '9' )
    {
        return token - '0' ;
    }
    else
    {
        return 0 ;
    }
}

char SnmpAnalyser :: DecIntegerToOctChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 7 )
    {
        return '0' + integer ;
    }
    else
    {
        return '0' ;
    }
}

char SnmpAnalyser :: DecIntegerToDecChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 9 )
    {
        return '0' + integer ;
    }
    else
    {
        return '0' ;
    }
}

char SnmpAnalyser :: DecIntegerToHexChar ( UCHAR integer )
{
    if ( integer >= 0 && integer <= 9 )
    {
        return '0' + integer ;
    }
    else if ( integer >= 10 && integer <= 15 )
    {
        return 'a' + ( integer - 10 ) ;
    }
    else
    {
        return '0' ;
    }
}

SnmpNegativeRangedType :: SnmpNegativeRangedType ( const wchar_t *rangeValues ) : status ( TRUE ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    if ( rangeValues ) 
    {
        status = Parse ( rangeValues ) ;
    }
}

SnmpNegativeRangedType :: SnmpNegativeRangedType ( const SnmpNegativeRangedType &copy ) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    POSITION position = copy.rangedValues.GetHeadPosition () ;
    while ( position )
    {
        SnmpNegativeRangeType rangeType = copy.rangedValues.GetNext ( position ) ; 
        rangedValues.AddTail ( rangeType ) ;
    }
}

SnmpNegativeRangedType :: ~SnmpNegativeRangedType ()
{
    delete pushBack ;
    rangedValues.RemoveAll () ;
}


void SnmpNegativeRangedType  :: PushBack ()
{
    pushedBack = TRUE ;
}

SnmpLexicon *SnmpNegativeRangedType  :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = NULL ;
        pushBack = analyser.Get () ;
    }

    return pushBack ;
}
    
SnmpLexicon *SnmpNegativeRangedType  :: Match ( SnmpLexicon :: LexiconToken tokenType )
{
    SnmpLexicon *lexicon = Get () ;
    status = ( lexicon->GetToken () == tokenType ) ;
    return status ? lexicon : NULL ;
}

BOOL SnmpNegativeRangedType :: Check ( const LONG &value )
{
    POSITION position = rangedValues.GetHeadPosition () ;
    if ( position )
    {
        while ( position )
        {
            SnmpNegativeRangeType rangeType = rangedValues.GetNext ( position ) ;
            if ( value >= rangeType.GetLowerBound () && value <= rangeType.GetUpperBound () )
            {
                return TRUE ;
            }
        }

        return FALSE ;
    }

    return TRUE ; 

}

BOOL SnmpNegativeRangedType :: Parse ( const wchar_t *rangeValues )
{
    BOOL status = TRUE ;

    analyser.Set ( rangeValues ) ;

    return RangeDef () && RecursiveDef () ;
}

BOOL SnmpNegativeRangedType :: RangeDef ()
{
    BOOL status = TRUE ;

    LONG lowerRange = 0 ;
    LONG upperRange = 0 ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: SIGNED_INTEGER_ID:
        {
            lowerRange = lookAhead->GetValue()->signedInteger ;

            SnmpLexicon *lookAhead = Get () ;
            switch ( lookAhead->GetToken () ) 
            {
                case SnmpLexicon :: DOTDOT_ID:
                {
                    SnmpLexicon *lookAhead = Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case SnmpLexicon :: SIGNED_INTEGER_ID:
                        {
                            upperRange = lookAhead->GetValue()->signedInteger ;
                            SnmpNegativeRangeType rangeType ( lowerRange , upperRange ) ;
                            rangedValues.AddTail ( rangeType ) ;
                        }
                        break ;

                        default:
                        {
                            status = FALSE ;
                        }
                        break ;
                    }
                }
                break ;

                case SnmpLexicon :: EOF_ID:
                case SnmpLexicon :: COMMA_ID:
                {
                    lowerRange = lookAhead->GetValue()->signedInteger ;
                    SnmpNegativeRangeType rangeType ( lowerRange , lowerRange ) ;
                    rangedValues.AddTail ( rangeType ) ;

                    PushBack () ;
                } 
                break ;

                default:
                {
                    status = FALSE ;
                }
                break ;
            }
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL SnmpNegativeRangedType :: RecursiveDef ()
{
    BOOL status = TRUE ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: COMMA_ID:
        {
            PushBack () ;
            Match ( SnmpLexicon :: COMMA_ID ) &&
            RangeDef () &&
            RecursiveDef () ;
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

SnmpPositiveRangedType :: SnmpPositiveRangedType ( const wchar_t *rangeValues ) : status ( TRUE ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    if ( rangeValues ) 
    {
        status = Parse ( rangeValues ) ;
    }
}

SnmpPositiveRangedType :: SnmpPositiveRangedType ( const SnmpPositiveRangedType &copy ) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    POSITION position = copy.rangedValues.GetHeadPosition () ;
    while ( position )
    {
        SnmpPositiveRangeType rangeType = copy.rangedValues.GetNext ( position ) ;
        rangedValues.AddTail ( rangeType ) ;
    }
}

SnmpPositiveRangedType :: ~SnmpPositiveRangedType ()
{
    delete pushBack ;
    rangedValues.RemoveAll () ;
}

void SnmpPositiveRangedType  :: PushBack ()
{
    pushedBack = TRUE ;
}

SnmpLexicon *SnmpPositiveRangedType  :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = NULL ;
        pushBack = analyser.Get ( TRUE ) ;
    }

    return pushBack ;
}
    
SnmpLexicon *SnmpPositiveRangedType  :: Match ( SnmpLexicon :: LexiconToken tokenType )
{
    SnmpLexicon *lexicon = Get () ;
    status = ( lexicon->GetToken () == tokenType ) ;
    return status ? lexicon : NULL ;
}

BOOL SnmpPositiveRangedType :: Check ( const ULONG &value )
{
    POSITION position = rangedValues.GetHeadPosition () ;
    if ( position )
    {
        while ( position )
        {
            SnmpPositiveRangeType rangeType = rangedValues.GetNext ( position ) ;
            if ( value >= rangeType.GetLowerBound () && value <= rangeType.GetUpperBound () )
            {
                return TRUE ;
            }
        }

        return FALSE ;
    }   

    return TRUE ;
}

BOOL SnmpPositiveRangedType :: Parse ( const wchar_t *rangeValues )
{
    BOOL status = TRUE ;

    analyser.Set ( rangeValues ) ;

    return RangeDef () && RecursiveDef () ;
}

BOOL SnmpPositiveRangedType :: RangeDef ()
{
    BOOL status = TRUE ;

    ULONG lowerRange = 0 ;
    ULONG upperRange = 0 ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
        {
            lowerRange = lookAhead->GetValue()->unsignedInteger ;

            SnmpLexicon *lookAhead = Get () ;
            switch ( lookAhead->GetToken () ) 
            {
                case SnmpLexicon :: DOTDOT_ID:
                {
                    SnmpLexicon *lookAhead = Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
                        {
                            upperRange = lookAhead->GetValue()->unsignedInteger ;
                            SnmpPositiveRangeType rangeType ( lowerRange , upperRange ) ;
                            rangedValues.AddTail ( rangeType ) ;
                        }
                        break ;

                        case SnmpLexicon :: SIGNED_INTEGER_ID:
                        {
                            if ( lookAhead->GetValue()->signedInteger >= 0 )
                            {
                                upperRange = lookAhead->GetValue()->unsignedInteger ;
                                SnmpPositiveRangeType rangeType ( lowerRange , upperRange ) ;
                                rangedValues.AddTail ( rangeType ) ;
                            }
                            else
                            {
                                status = FALSE ;
                            }
                        }
                        break ;

                        default:
                        {
                            status = FALSE ;
                        }
                        break ;
                    }
                }
                break ;

                case SnmpLexicon :: EOF_ID:
                case SnmpLexicon :: COMMA_ID:
                {
                    SnmpPositiveRangeType rangeType ( lowerRange , lowerRange ) ;
                    rangedValues.AddTail ( rangeType ) ;

                    PushBack () ;
                } 
                break ;

                default:
                {
                    status = FALSE ;
                }
                break ;
            }
        }
        break ;

        case SnmpLexicon :: SIGNED_INTEGER_ID:
        {
            lowerRange = lookAhead->GetValue()->signedInteger ;
            if ( lowerRange > 0 )
            {
                SnmpLexicon *lookAhead = Get () ;
                switch ( lookAhead->GetToken () ) 
                {
                    case SnmpLexicon :: DOTDOT_ID:
                    {
                        SnmpLexicon *lookAhead = Get () ;
                        switch ( lookAhead->GetToken () ) 
                        {
                            case SnmpLexicon :: UNSIGNED_INTEGER_ID:
                            {
                                upperRange = lookAhead->GetValue()->unsignedInteger ;
                                SnmpPositiveRangeType rangeType ( lowerRange , upperRange ) ;
                                rangedValues.AddTail ( rangeType ) ;
                            }
                            break ;

                            case SnmpLexicon :: SIGNED_INTEGER_ID:
                            {
                                if ( lookAhead->GetValue()->signedInteger >= 0 )
                                {
                                    upperRange = lookAhead->GetValue()->signedInteger ;
                                    SnmpPositiveRangeType rangeType ( lowerRange , upperRange ) ;
                                    rangedValues.AddTail ( rangeType ) ;
                                }
                                else
                                {
                                    status = 0 ;
                                }
                            }
                            break ;

                            default:
                            {
                                status = FALSE ;
                            }
                            break ;
                        }
                    }
                    break ;

                    case SnmpLexicon :: EOF_ID:
                    case SnmpLexicon :: COMMA_ID:
                    {
                        SnmpPositiveRangeType rangeType ( lowerRange , lowerRange ) ;
                        rangedValues.AddTail ( rangeType ) ;

                        PushBack () ;
                    } 
                    break ;

                    default:
                    {
                        status = FALSE ;
                    }
                    break ;
                }
            }
            else
            {
                status = FALSE ;
            }
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL SnmpPositiveRangedType :: RecursiveDef ()
{
    BOOL status = TRUE ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: COMMA_ID:
        {
            PushBack () ;
            Match ( SnmpLexicon :: COMMA_ID ) &&
            RangeDef () &&
            RecursiveDef () ;
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL SnmpInstanceType :: IsValid () const
{
    return status ;
}

BOOL SnmpInstanceType :: IsNull () const
{
    return m_IsNull ;
}

SnmpInstanceType :: operator void *() 
{ 
    return status ? this : NULL ; 
} 

SnmpNullType :: SnmpNullType ( const SnmpNull &nullArg )
{
}

SnmpNullType :: SnmpNullType ( const SnmpNullType &nullArg )
{
}

SnmpNullType :: SnmpNullType ()
{
}

SnmpNullType :: ~SnmpNullType ()
{
}

BOOL SnmpNullType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = TRUE;
    }

    return bResult;
}


SnmpInstanceType *SnmpNullType :: Copy () const 
{
    return new SnmpNullType ( *this ) ;
}

SnmpObjectIdentifier SnmpNullType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    SnmpObjectIdentifier returnValue ( objectIdentifier ) ;
    return returnValue ;
}

SnmpObjectIdentifier SnmpNullType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    SnmpInstanceType :: SetNull ( FALSE ) ;
    SnmpObjectIdentifier returnValue ( objectIdentifier ) ;
    return returnValue ;
}

const SnmpValue *SnmpNullType :: GetValueEncoding () const
{
    return & null ;
}

wchar_t *SnmpNullType :: GetStringValue () const 
{
    wchar_t *returnValue = new wchar_t [ 1 ] ;
    returnValue [ 0 ] = 0L ;
    return returnValue ;
}

SnmpIntegerType :: SnmpIntegerType ( 

    const SnmpIntegerType &integerArg 

) : SnmpInstanceType ( integerArg ) , SnmpNegativeRangedType ( integerArg ) , integer ( integerArg.integer ) 
{
}

SnmpIntegerType :: SnmpIntegerType ( 

    const SnmpInteger &integerArg ,
    const wchar_t *rangeValues

) : SnmpNegativeRangedType ( rangeValues ) , integer ( integerArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpNegativeRangedType :: IsValid () ) ;
}

SnmpIntegerType :: SnmpIntegerType ( 

    const wchar_t *integerArg ,
    const wchar_t *rangeValues

) : SnmpInstanceType ( FALSE ) , SnmpNegativeRangedType ( rangeValues ) , integer ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( integerArg ) && SnmpNegativeRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpNegativeRangedType :: Check ( integer.GetValue () ) ) ;
    }
}

SnmpIntegerType :: SnmpIntegerType ( 

    const LONG integerArg ,
    const wchar_t *rangeValues 

) :  SnmpNegativeRangedType ( rangeValues ) , integer ( integerArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpNegativeRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpNegativeRangedType :: Check ( integer.GetValue () ) ) ;
    }
}

SnmpIntegerType :: SnmpIntegerType ( const wchar_t *rangeValues ) : SnmpNegativeRangedType ( rangeValues ) , 
                                                                    SnmpInstanceType ( TRUE , TRUE ) , 
                                                                    integer ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( SnmpNegativeRangedType :: IsValid () ) ;
}

SnmpIntegerType :: ~SnmpIntegerType () 
{
}

BOOL SnmpIntegerType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = integer.GetValue() == ((const SnmpIntegerType&)value).integer.GetValue();
    }

    return bResult;
}


SnmpInstanceType *SnmpIntegerType :: Copy () const 
{
    return new SnmpIntegerType ( *this ) ;
}

BOOL SnmpIntegerType :: Parse ( const wchar_t *integerArg ) 
{
    BOOL status = TRUE ;

    SnmpAnalyser analyser ;

    analyser.Set ( integerArg ) ;

    SnmpLexicon *lookAhead = analyser.Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: SIGNED_INTEGER_ID:
        {
            integer.SetValue ( lookAhead->GetValue ()->signedInteger ) ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    delete lookAhead ;

    return status ;
}

SnmpObjectIdentifier SnmpIntegerType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG integerValue = integer.GetValue () ;  
    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( & integerValue , 1 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpIntegerType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if ( objectIdentifier.GetValueLength () >= 1 )
    {
        integer.SetValue ( objectIdentifier [ 0 ] ) ;

        SnmpInstanceType :: SetNull ( FALSE ) ;
        SnmpInstanceType :: SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 1 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }

}

const SnmpValue *SnmpIntegerType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? &integer : NULL ;
}

wchar_t *SnmpIntegerType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        wchar_t stringValue [ 40 ] ;
        _ltow ( integer.GetValue () , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

LONG SnmpIntegerType :: GetValue () const
{
    return integer.GetValue () ;
}

SnmpGaugeType :: SnmpGaugeType ( 

    const SnmpGauge &gaugeArg ,
    const wchar_t *rangeValues
    
) : SnmpPositiveRangedType ( rangeValues ) , gauge ( gaugeArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
    }
}

SnmpGaugeType :: SnmpGaugeType ( 

    const SnmpGaugeType &gaugeArg 

) :  SnmpInstanceType ( gaugeArg ) , SnmpPositiveRangedType ( gaugeArg ) , gauge ( gaugeArg.gauge ) 
{
}

SnmpGaugeType :: SnmpGaugeType ( 

    const wchar_t *gaugeArg ,
    const wchar_t *rangeValues

) : SnmpInstanceType ( FALSE ) , SnmpPositiveRangedType ( rangeValues ) , gauge ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( gaugeArg ) && SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
    }
}

SnmpGaugeType :: SnmpGaugeType ( 

    const ULONG gaugeArg ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , gauge ( gaugeArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( gauge.GetValue () ) ) ;
    }
}

SnmpGaugeType :: SnmpGaugeType ( const wchar_t *rangeValues ) : SnmpPositiveRangedType ( rangeValues ) , 
                                                                SnmpInstanceType ( TRUE , TRUE ) , 
                                                                gauge ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
}

SnmpGaugeType :: ~SnmpGaugeType () 
{
}

BOOL SnmpGaugeType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = gauge.GetValue() == ((const SnmpGaugeType&)value).gauge.GetValue();
    }

    return bResult;
}

SnmpInstanceType *SnmpGaugeType :: Copy () const 
{
    return new SnmpGaugeType ( *this ) ;
}

BOOL SnmpGaugeType :: Parse ( const wchar_t *gaugeArg ) 
{
    BOOL status = TRUE ;

    SnmpAnalyser analyser ;

    analyser.Set ( gaugeArg ) ;

    SnmpLexicon *lookAhead = analyser.Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
        {
            gauge.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    delete lookAhead ;

    return status ;
}

SnmpObjectIdentifier SnmpGaugeType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG gaugeValue = gauge.GetValue () ;  
    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( & gaugeValue , 1 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpGaugeType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if ( objectIdentifier.GetValueLength () >= 1 )
    {
        gauge.SetValue ( objectIdentifier [ 0 ] ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;
        SnmpInstanceType :: SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 1 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }

    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpGaugeType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & gauge : NULL ;
}

wchar_t *SnmpGaugeType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull ()  )
    {
        wchar_t stringValue [ 40 ] ;
        _ultow ( gauge.GetValue () , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

ULONG SnmpGaugeType :: GetValue () const
{
    return gauge.GetValue () ;
}

SnmpTimeTicksType :: SnmpTimeTicksType ( 

    const SnmpTimeTicks &timeTicksArg 

) : timeTicks ( timeTicksArg ) 
{
}

SnmpTimeTicksType :: SnmpTimeTicksType ( 

    const SnmpTimeTicksType &timeTicksArg 

) : SnmpInstanceType ( timeTicksArg ) , timeTicks ( timeTicksArg.timeTicks ) 
{
}

SnmpTimeTicksType :: SnmpTimeTicksType ( 

    const wchar_t *timeTicksArg

) : SnmpInstanceType ( FALSE ) , timeTicks ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( timeTicksArg ) ) ;
}

SnmpTimeTicksType :: SnmpTimeTicksType ( 

    const ULONG timeTicksArg

) : timeTicks ( timeTicksArg ) 
{
}

SnmpTimeTicksType :: SnmpTimeTicksType () : SnmpInstanceType ( TRUE , TRUE ) , 
                                            timeTicks ( 0 ) 
{
}

SnmpTimeTicksType :: ~SnmpTimeTicksType () 
{
}

BOOL SnmpTimeTicksType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = timeTicks.GetValue() == ((const SnmpTimeTicksType&)value).timeTicks.GetValue();
    }

    return bResult;
}

SnmpInstanceType *SnmpTimeTicksType :: Copy () const 
{
    return new SnmpTimeTicksType ( *this ) ;
}

BOOL SnmpTimeTicksType :: Parse ( const wchar_t *timeTicksArg ) 
{
    BOOL status = TRUE ;

    SnmpAnalyser analyser ;

    analyser.Set ( timeTicksArg ) ;

    SnmpLexicon *lookAhead = analyser.Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
        {
            timeTicks.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    delete lookAhead ;

    return status ;
}

SnmpObjectIdentifier SnmpTimeTicksType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG timeTicksValue = timeTicks.GetValue () ;  
    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( & timeTicksValue , 1 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpTimeTicksType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if ( objectIdentifier.GetValueLength () >= 1 )
    {
        timeTicks.SetValue ( objectIdentifier [ 0 ] ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;
        SnmpInstanceType :: SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 1 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }

    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpTimeTicksType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & timeTicks : NULL ;
}

wchar_t *SnmpTimeTicksType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull ()  )
    {
        wchar_t stringValue [ 40 ] ;
        _ultow ( timeTicks.GetValue () , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

ULONG SnmpTimeTicksType :: GetValue () const
{
    return timeTicks.GetValue () ;
}

SnmpCounterType :: SnmpCounterType ( const SnmpCounter &counterArg ) : counter ( counterArg ) 
{
}

SnmpCounterType :: SnmpCounterType ( const SnmpCounterType &counterArg ) : SnmpInstanceType ( counterArg ) , counter ( counterArg.counter ) 
{
}

SnmpInstanceType *SnmpCounterType :: Copy () const 
{
    return new SnmpCounterType ( *this ) ;
}

SnmpCounterType :: SnmpCounterType ( const wchar_t *counterArg ) :  SnmpInstanceType ( FALSE ) , 
                                                                counter ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( counterArg ) ) ;
}

BOOL SnmpCounterType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = counter.GetValue() == ((const SnmpCounterType&)value).counter.GetValue();
    }

    return bResult;
}

BOOL SnmpCounterType :: Parse ( const wchar_t *counterArg ) 
{
    BOOL status = TRUE ;

    SnmpAnalyser analyser ;

    analyser.Set ( counterArg ) ;

    SnmpLexicon *lookAhead = analyser.Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
        {
            counter.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    delete lookAhead ;

    return status ;
}

SnmpCounterType :: SnmpCounterType ( const ULONG counterArg ) : counter ( counterArg ) 
{
}

SnmpCounterType :: SnmpCounterType () : SnmpInstanceType ( TRUE , TRUE ) , 
                                        counter ( 0 ) 
{
}

SnmpCounterType :: ~SnmpCounterType () 
{
}

SnmpObjectIdentifier SnmpCounterType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG counterValue = counter.GetValue () ;  
    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( & counterValue , 1 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpCounterType :: Decode ( const SnmpObjectIdentifier &objectIdentifier )
{
    if ( objectIdentifier.GetValueLength () >= 1 )
    {
        counter.SetValue ( objectIdentifier [ 0 ] ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;
        SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 1 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }
    }
    else
    {
        SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpCounterType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & counter : NULL ;
}

wchar_t *SnmpCounterType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        wchar_t stringValue [ 40 ] ;
        _ultow ( counter.GetValue () , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

ULONG SnmpCounterType :: GetValue () const
{
    return counter.GetValue () ;
}

SnmpCounter64Type :: SnmpCounter64Type ( const SnmpCounter64Type &counterArg ) : SnmpInstanceType ( counterArg ) , counter64 ( counterArg.counter64 )
{
}
SnmpCounter64Type :: SnmpCounter64Type ( const ULONG counterHighArg , const ULONG counterLowArg ) : counter64 ( counterLowArg ,  counterHighArg ) 
{
}

SnmpCounter64Type :: SnmpCounter64Type ( const SnmpCounter64 &counterArg ) : counter64 ( counterArg )
{
}

SnmpCounter64Type :: SnmpCounter64Type () : SnmpInstanceType ( TRUE , TRUE ) , counter64 ( 0 , 0 )
{
}

SnmpCounter64Type :: ~SnmpCounter64Type () 
{
}

SnmpInstanceType *SnmpCounter64Type :: Copy () const 
{
    return new SnmpCounter64Type ( *this ) ;
}

SnmpCounter64Type :: SnmpCounter64Type ( const wchar_t *counterArg ) :  SnmpInstanceType ( FALSE ) , counter64 ( 0 , 0 )
{
    SnmpInstanceType :: SetStatus ( Parse ( counterArg ) ) ;
}

BOOL SnmpCounter64Type :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = counter64.Equivalent( ((const SnmpCounter64Type&)value).counter64 );
    }

    return bResult;
}

BOOL SnmpCounter64Type :: Parse ( const wchar_t *counterArg ) 
{
    BOOL status = TRUE ;

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define TOKEN_START 5000

    ULONG state = 0 ;

    ULONG position = 0 ;
/* 
 * Integer Definitions
 */

    BOOL negative = FALSE ;
    BOOL positive = FALSE ;

    DWORDLONG positiveMagicMult = ( DWORDLONG ) ( ( ( DWORDLONG ) -1 ) / 10L ) ; 
    DWORDLONG positiveMagicPosDigit = 5 ;
    DWORDLONG positiveDatum = 0 ;   
    DWORDLONG unsignedInteger = 0 ;
/*
 * Token Definitions
 */

    ULONG token_start = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = counterArg [ position ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsLeadingDecimal ( token ) )
                {
                    state = DEC_INTEGER_START + 1  ;
                    positiveDatum = ( token - 48 ) ;
                }
                else if ( token == L'+' )
                {
                    state = DEC_INTEGER_START ;
                }
                else if ( token == L'-' ) 
                {
                    state = DEC_INTEGER_START ;
                }
                else if ( token == L'0' )
                {
                    state = 1 ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                {
                    state = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( token == L'x' || token == L'X' )
                {
                    state = HEX_INTEGER_START ;             
                }
                else if ( SnmpAnalyser :: IsOctal ( token ) )
                {
                    state = OCT_INTEGER_START ;
                    positiveDatum = ( token - 48 ) ;
                }
                else
                {
                    unsignedInteger = 0 ;

                    state = ACCEPT_STATE ;
                    position -- ;
                }
            }
            break ;

            case HEX_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    positiveDatum = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = HEX_INTEGER_START + 1 ;
                }
                else
                {
                    state = REJECT_STATE ;
                }
            }
            break ;

            case HEX_INTEGER_START+1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    state = HEX_INTEGER_START + 1 ;

                    if ( positiveDatum > positiveMagicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( positiveDatum == positiveMagicMult ) 
                    {
                        if ( SnmpAnalyser :: HexWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    positiveDatum = ( positiveDatum << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                }
                else
                {
                    unsignedInteger = positiveDatum ;
                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }
            break ;

            case OCT_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsOctal ( token ) )
                {
                    state = OCT_INTEGER_START ;

                    if ( positiveDatum > positiveMagicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( positiveDatum == positiveMagicMult ) 
                    {
                        if ( SnmpAnalyser :: OctWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    positiveDatum = ( positiveDatum << 3 ) + SnmpAnalyser :: OctWCharToDecInteger ( token ) ;
                }
                else
                {
                    unsignedInteger = positiveDatum ;
                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }
            break ;

            case DEC_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    positiveDatum = ( token - 48 ) ;
                    state = DEC_INTEGER_START + 1 ;
                }
                else 
                if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                {
                    state = DEC_INTEGER_START ;
                }
                else state = REJECT_STATE ;
            }   
            break ;

            case DEC_INTEGER_START+1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {   
                    state = DEC_INTEGER_START + 1 ;

                    if ( positiveDatum > positiveMagicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( positiveDatum == positiveMagicMult ) 
                    {
                        if ( ( ULONG ) ( token - 48 ) > positiveMagicPosDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
                }
                else
                {
                    unsignedInteger = positiveDatum ;

                    state = ACCEPT_STATE ;

                    position -- ;
                }
            }   
            break ;

            case ACCEPT_STATE:
            case REJECT_STATE:
            default:
            {
                state = REJECT_STATE ;
            } ;
            break ;
        }

        position ++ ;
    }

    status = ( state != REJECT_STATE ) ;
    if ( status )
    {
        counter64.SetValue(( ULONG ) ( unsignedInteger & 0xFFFFFFFF ), ( ULONG ) ( unsignedInteger >> 32 )) ;
    }

    return status ;
}

SnmpObjectIdentifier SnmpCounter64Type :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    SnmpObjectIdentifier returnValue = objectIdentifier ;
    return returnValue ;
}

SnmpObjectIdentifier SnmpCounter64Type :: Decode ( const SnmpObjectIdentifier &objectIdentifier )
{
    return objectIdentifier ;
}

const SnmpValue *SnmpCounter64Type :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? (const SnmpValue *) & counter64 : (const SnmpValue * ) NULL ;
}

wchar_t *SnmpCounter64Type :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        wchar_t stringValue [ 40 ] ;
        DWORDLONG t_Integer =  (DWORDLONG)counter64.GetHighValue () ;
		t_Integer = (t_Integer << 32 ) + counter64.GetLowValue () ;
        _ui64tow ( t_Integer , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

void SnmpCounter64Type :: GetValue ( ULONG &counterHighArg , ULONG &counterLowArg ) const
{
    counterHighArg = counter64.GetHighValue () ;
    counterLowArg = counter64.GetLowValue () ;
}

SnmpIpAddressType :: SnmpIpAddressType ( const SnmpIpAddress &ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

SnmpIpAddressType :: SnmpIpAddressType ( const SnmpIpAddressType &ipAddressArg ) : SnmpInstanceType ( ipAddressArg ) , ipAddress ( ipAddressArg.ipAddress ) 
{
}

SnmpInstanceType *SnmpIpAddressType :: Copy () const 
{
    return new SnmpIpAddressType ( *this ) ;
}

SnmpIpAddressType :: SnmpIpAddressType ( const wchar_t *ipAddressArg ) : SnmpInstanceType ( FALSE ) , 
                                                                            ipAddress ( ( ULONG ) 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( ipAddressArg ) ) ;
}

BOOL SnmpIpAddressType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = ipAddress.GetValue() == ((const SnmpIpAddressType&)value).ipAddress.GetValue();
    }

    return bResult;
}


BOOL SnmpIpAddressType :: Parse ( const wchar_t *ipAddressArg ) 
{
    BOOL status = TRUE ;
/*
 *  Datum fields.
 */

    ULONG datumA = 0 ;
    ULONG datumB = 0 ;
    ULONG datumC = 0 ;
    ULONG datumD = 0 ;

/*
 *  Parse input for dotted decimal IP Address.
 */

    ULONG position = 0 ;
    ULONG state = 0 ;
    while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
    {
/*
 *  Get token from input stream.
 */
        wchar_t token = ipAddressArg [ position ++ ] ;

        switch ( state ) 
        {
/*
 *  Parse first field 'A'.
 */

            case 0:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = ( token - 48 ) ;
                    state = 1 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 2 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 3 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'B'.
 */
            case 4:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'C'.
 */
            case 8:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *  Parse first field 'D'.
 */
            case 12:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            default:
            {
                state = REJECT_STATE ;
            }
            break ;
        }
    }


/*
 *  Check boundaries for IP fields.
 */

    status = ( state != REJECT_STATE ) ;

    if ( state == ACCEPT_STATE )
    {
        status = status && ( ( datumA < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumB < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumC < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumD < 256 ) ? TRUE : FALSE ) ;
    }

    ULONG data = ( datumA << 24 ) + ( datumB << 16 ) + ( datumC << 8 ) + datumD ;
    ipAddress.SetValue ( data ) ;

    return status ; 

}

SnmpIpAddressType :: SnmpIpAddressType ( const ULONG ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

SnmpIpAddressType :: SnmpIpAddressType () : SnmpInstanceType ( TRUE , TRUE ) , 
                                            ipAddress ( ( ULONG ) 0 ) 
{
}

SnmpIpAddressType :: ~SnmpIpAddressType () 
{
}

SnmpObjectIdentifier SnmpIpAddressType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG ipAddressValue = ipAddress.GetValue () ;
    ULONG ipAddressArray [ 4 ] ;

    ipAddressArray [ 0 ] = ( ipAddressValue >> 24 ) & 0xFF  ;
    ipAddressArray [ 1 ] = ( ipAddressValue >> 16 ) & 0xFF ;
    ipAddressArray [ 2 ] = ( ipAddressValue >> 8 ) & 0xFF ;
    ipAddressArray [ 3 ] = ipAddressValue & 0xFF ;

    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( ipAddressArray , 4 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpIpAddressType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if( objectIdentifier.GetValueLength () >= 4 )
    {
        ULONG byteA = objectIdentifier [ 0 ] ;
        ULONG byteB = objectIdentifier [ 1 ] ;
        ULONG byteC = objectIdentifier [ 2 ] ;
        ULONG byteD = objectIdentifier [ 3 ] ;
        ULONG value = ( byteA << 24 ) + ( byteB << 16 ) + ( byteC << 8 ) + byteD ;

        ipAddress.SetValue ( value ) ;

        SnmpInstanceType :: SetNull ( FALSE ) ;
        SnmpInstanceType :: SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 4 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }

    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpIpAddressType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & ipAddress : NULL ;
}

wchar_t *SnmpIpAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG ipAddressValue = ipAddress.GetValue () ;

        wchar_t stringAValue [ 40 ] ;
        _itow ( ipAddressValue >> 24 , stringAValue , 10 );

        wchar_t stringBValue [ 40 ] ;
        _itow ( ( ipAddressValue & 0x00FF0000 ) >> 16 , stringBValue , 10 );

        wchar_t stringCValue [ 40 ] ;
        _itow ( ( ipAddressValue & 0x0000FF00 ) >> 8 , stringCValue , 10 );

        wchar_t stringDValue [ 40 ] ;
        _itow ( ipAddressValue & 0x000000FF , stringDValue , 10 );

        ULONG totalLength = wcslen ( stringAValue ) +
                            wcslen ( stringBValue ) +
                            wcslen ( stringCValue ) +
                            wcslen ( stringDValue ) ;

        returnValue = new wchar_t [ totalLength + 4 + 1 ] ;
        wcscpy ( returnValue , stringAValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringBValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringCValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringDValue ) ;
    }
    else
    {
        ULONG returnValueLength = wcslen ( L"0.0.0.0" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"0.0.0.0" ) ;
    }

    return returnValue ;
}

ULONG SnmpIpAddressType :: GetValue () const
{
    return ipAddress.GetValue () ;
}

SnmpNetworkAddressType :: SnmpNetworkAddressType ( const SnmpIpAddress &ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

SnmpNetworkAddressType :: SnmpNetworkAddressType ( const SnmpNetworkAddressType &networkAddressArg ) : SnmpInstanceType ( networkAddressArg ) , ipAddress ( networkAddressArg.ipAddress ) 
{
}

SnmpInstanceType *SnmpNetworkAddressType :: Copy () const 
{
    return new SnmpNetworkAddressType ( *this ) ;
}

SnmpNetworkAddressType :: SnmpNetworkAddressType ( const wchar_t *networkAddressArg ) : SnmpInstanceType ( FALSE ) , 
                                                                                        ipAddress ( ( ULONG ) 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( networkAddressArg ) ) ;
}

BOOL SnmpNetworkAddressType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = ipAddress.GetValue() == ((const SnmpNetworkAddressType&)value).ipAddress.GetValue();
    }

    return bResult;
}

BOOL SnmpNetworkAddressType :: Parse ( const wchar_t *networkAddressArg ) 
{
    BOOL status = TRUE ;

/*
 *  Datum fields.
 */

    ULONG datumA = 0 ;
    ULONG datumB = 0 ;
    ULONG datumC = 0 ;
    ULONG datumD = 0 ;

/*
 *  Parse input for dotted decimal IP Address.
 */

    ULONG position = 0 ;
    ULONG state = 0 ;
    while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
    {
/*
 *  Get token from input stream.
 */
        wchar_t token = networkAddressArg [ position ++ ] ;

        switch ( state ) 
        {
/*
 *  Parse first field 'A'.
 */

            case 0:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = ( token - 48 ) ;
                    state = 1 ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) state = 0 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 2 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 3 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'B'.
 */
            case 4:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'C'.
 */
            case 8:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *  Parse first field 'D'.
 */
            case 12:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) state = 15 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
                if ( SnmpAnalyser :: IsWhitespace ( token ) ) state = 15 ; 
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;
 
            default:
            {
                state = REJECT_STATE ;
            }
            break ;
        }
    }


/*
 *  Check boundaries for IP fields.
 */

    status = ( state != REJECT_STATE ) ;

    if ( state == ACCEPT_STATE )
    {
        status = status && ( ( datumA < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumB < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumC < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumD < 256 ) ? TRUE : FALSE ) ;
    }

    ULONG data = ( datumA << 24 ) + ( datumB << 16 ) + ( datumC << 8 ) + datumD ;
    ipAddress.SetValue ( data ) ;

    return status ; 
}


SnmpNetworkAddressType :: SnmpNetworkAddressType ( const ULONG ipAddressArg ) : ipAddress ( ipAddressArg ) 
{
}

SnmpNetworkAddressType :: SnmpNetworkAddressType () : SnmpInstanceType ( TRUE , TRUE ) , 
                                                        ipAddress ( ( ULONG ) 0 ) 
{
}

SnmpNetworkAddressType :: ~SnmpNetworkAddressType () 
{
}

SnmpObjectIdentifier SnmpNetworkAddressType :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG ipAddressValue = ipAddress.GetValue () ;
    ULONG networkAddressArray [ 5 ] ;

    networkAddressArray [ 0 ] = 1 ;
    networkAddressArray [ 1 ] = ( ipAddressValue >> 24 ) & 0xFF  ;
    networkAddressArray [ 2 ] = ( ipAddressValue >> 16 ) & 0xFF ;
    networkAddressArray [ 3 ] = ( ipAddressValue >> 8 ) & 0xFF ;
    networkAddressArray [ 4 ] = ipAddressValue & 0xFF ;

    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( networkAddressArray , 5 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpNetworkAddressType :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if ( objectIdentifier.GetValueLength () )
    {
        if ( objectIdentifier [ 0 ] == 1 )
        {
            if( objectIdentifier.GetValueLength () >= 5 )
            {
                ULONG byteA = objectIdentifier [ 1 ] ;
                ULONG byteB = objectIdentifier [ 2 ] ;
                ULONG byteC = objectIdentifier [ 3 ] ;
                ULONG byteD = objectIdentifier [ 4 ] ;
                ULONG value = ( byteA << 24 ) + ( byteB << 16 ) + ( byteC << 8 ) + byteD ;

                ipAddress.SetValue ( value ) ;

                SnmpInstanceType :: SetNull ( FALSE ) ;
                SnmpInstanceType :: SetStatus ( TRUE ) ;

                SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
                BOOL t_Status = objectIdentifier.Suffix ( 5 , returnValue ) ;
                if ( t_Status ) 
                {
                    return returnValue ;
                }
                else
                {
                    return SnmpObjectIdentifier ( NULL , 0 ) ;
                }

            }
            else
            {
                SnmpInstanceType :: SetStatus ( FALSE ) ;
                return objectIdentifier ;
            }
        }
        else
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
            return objectIdentifier ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpNetworkAddressType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & ipAddress : NULL ;
}

wchar_t *SnmpNetworkAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG ipAddressValue = ipAddress.GetValue () ;

        wchar_t stringAValue [ 40 ] ;
        _itow ( ipAddressValue >> 24 , stringAValue , 10 );

        wchar_t stringBValue [ 40 ] ;
        _itow ( ( ipAddressValue & 0x00FF0000 ) >> 16 , stringBValue , 10 );

        wchar_t stringCValue [ 40 ] ;
        _itow ( ( ipAddressValue & 0x0000FF00 ) >> 8 , stringCValue , 10 );

        wchar_t stringDValue [ 40 ] ;
        _itow ( ipAddressValue & 0x000000FF , stringDValue , 10 );

        ULONG totalLength = wcslen ( stringAValue ) +
                            wcslen ( stringBValue ) +
                            wcslen ( stringCValue ) +
                            wcslen ( stringDValue ) ;

        returnValue = new wchar_t [ totalLength + 4 + 1 ] ;
        wcscpy ( returnValue , stringAValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringBValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringCValue ) ;
        wcscat ( returnValue , L"." ) ;
        wcscat ( returnValue , stringDValue ) ;
    }
    else
    {
        ULONG returnValueLength = wcslen ( L"0.0.0.0" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"0.0.0.0" ) ;
    }

    return returnValue ;
}

ULONG SnmpNetworkAddressType :: GetValue () const
{
    return ipAddress.GetValue () ;
}

SnmpObjectIdentifierType :: SnmpObjectIdentifierType ( const SnmpObjectIdentifier &objectIdentifierArg ) : objectIdentifier ( objectIdentifierArg ) 
{
}

SnmpObjectIdentifierType :: SnmpObjectIdentifierType ( const SnmpObjectIdentifierType &objectIdentifierArg ) : SnmpInstanceType ( objectIdentifierArg ) , objectIdentifier ( objectIdentifierArg.objectIdentifier ) 
{
}

SnmpInstanceType *SnmpObjectIdentifierType :: Copy () const 
{
    return new SnmpObjectIdentifierType ( *this ) ;
}

SnmpObjectIdentifierType &SnmpObjectIdentifierType :: operator=(const SnmpObjectIdentifierType &to_copy )
{
    m_IsNull = to_copy.m_IsNull ;
    status = to_copy.status ;
    objectIdentifier = to_copy.objectIdentifier;

    return *this;
}

SnmpObjectIdentifierType :: SnmpObjectIdentifierType ( const wchar_t *objectIdentifierArg ) :   SnmpInstanceType ( FALSE ) , 
                                                                objectIdentifier ( NULL , 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( objectIdentifierArg ) ) ;
}

BOOL SnmpObjectIdentifierType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = objectIdentifier == ((const SnmpObjectIdentifierType&)value).objectIdentifier;
    }

    return bResult;
}

BOOL SnmpObjectIdentifierType :: Parse ( const wchar_t *objectIdentifierArg ) 
{
#define AVERAGE_OID_LENGTH 20

    BOOL status = TRUE ;

    ULONG reallocLength = AVERAGE_OID_LENGTH ;
    ULONG *reallocArray = ( ULONG * ) malloc ( sizeof ( ULONG ) * reallocLength ) ;

    if (reallocArray == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }
    
    ULONG magicMult = ( ( ULONG ) - 1 ) / 10 ; 
    ULONG magicDigit = 5 ;
    ULONG datum = 0 ;   
    ULONG length = 0 ;

    ULONG position = 0 ;
    ULONG state = 0 ;
    while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
    {
/*
 *  Get token from input stream.
 */
        wchar_t token = objectIdentifierArg [ position ++ ] ;

        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    state = 1 ;
                    datum = ( token - 48 ) ;
                }
                else if ( SnmpAnalyser :: IsWhitespace ( token ) ) 
                {
                    state = 0 ;
                }
                else if ( token == 0 ) 
                {
                    state = ACCEPT_STATE ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {   
                    state = 1 ;

                    if ( datum > magicMult )
                    {
                        state = REJECT_STATE ;
                    }
                    else if ( datum == magicMult ) 
                    {
                        if ( ( ULONG ) ( token - 48 ) > magicDigit ) 
                        {
                            state = REJECT_STATE ;
                        }
                    }

                    datum = datum * 10 + ( token - 48 ) ;
                }
                else
                if ( token == L'.' ) 
                {
                    reallocArray [ length ] = datum ;
                    length ++ ;
                    if ( length >= reallocLength )
                    {
                        reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                        reallocArray = ( ULONG * ) realloc ( reallocArray , sizeof ( ULONG ) * reallocLength ) ;

                        if (reallocArray == NULL)
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
                    }

                    state = 2 ;
                }
                else if ( token == 0 ) 
                {
                    reallocArray [ length ] = datum ;

                    length ++ ;
                    state = ACCEPT_STATE ;
                }
                else state = REJECT_STATE ;
            }   
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    state = 1 ;
                    datum = ( token - 48 ) ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    objectIdentifier.SetValue ( reallocArray , length ) ;

    free ( reallocArray ) ;

    if ( length < 2 ) 
    {
        status = FALSE ;
    }

    return status ;
}

SnmpObjectIdentifierType :: SnmpObjectIdentifierType ( const ULONG *value , const ULONG valueLength ) : objectIdentifier ( value , valueLength ) 
{
}

SnmpObjectIdentifierType :: SnmpObjectIdentifierType () : SnmpInstanceType ( TRUE , TRUE ) , 
                                        objectIdentifier ( NULL , 0 ) 
{
}

SnmpObjectIdentifierType :: ~SnmpObjectIdentifierType () 
{
}

SnmpObjectIdentifier SnmpObjectIdentifierType :: Encode ( const SnmpObjectIdentifier &objectIdentifierArg ) const
{
    ULONG objectIdentifierLength = objectIdentifier.GetValueLength () ;
    SnmpObjectIdentifier returnValue = objectIdentifierArg + SnmpObjectIdentifier ( & objectIdentifierLength , 1 ) + objectIdentifier ;
    
    return returnValue ;
}

SnmpObjectIdentifier SnmpObjectIdentifierType :: Decode ( const SnmpObjectIdentifier &objectIdentifierArg )
{
    if ( objectIdentifierArg.GetValueLength () )
    {
        ULONG objectIdentifierLength = objectIdentifierArg [ 0 ] ;
        if ( objectIdentifierArg.GetValueLength () >= objectIdentifierLength )
        {
            objectIdentifier.SetValue ( & objectIdentifierArg [ 1 ] , objectIdentifierLength ) ;
            SnmpInstanceType :: SetNull ( FALSE ) ;
            SnmpInstanceType :: SetStatus ( TRUE ) ;

            ULONG objectIdentifierLength = objectIdentifierArg [ 0 ] ;
            if ( objectIdentifierLength < objectIdentifierArg.GetValueLength () )
            {
                SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
                BOOL t_Status = objectIdentifierArg.Suffix ( objectIdentifierLength + 1 , returnValue ) ;
                if ( t_Status ) 
                {
                    return returnValue ;
                }
                else
                {
                    return SnmpObjectIdentifier ( NULL , 0 ) ;
                }
            }
            else
            {
                SnmpInstanceType :: SetStatus ( FALSE ) ;
                return objectIdentifier ;
            }
        }
        else
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
            return objectIdentifier ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }

}

const SnmpValue *SnmpObjectIdentifierType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & objectIdentifier : NULL ;
}

wchar_t *SnmpObjectIdentifierType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG totalLength = 0 ;
        ULONG reallocLength = AVERAGE_OID_LENGTH ;
        wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

        if (reallocArray == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        ULONG objectIdentifierLength = objectIdentifier.GetValueLength () ;     
        ULONG index = 0 ;
        while ( index < objectIdentifierLength ) 
        {
            wchar_t stringValue [ 40 ] ;
            _ultow ( objectIdentifier [ index ] , stringValue , 10 );
            ULONG stringLength = wcslen ( stringValue ) ;

            if ( ( totalLength + stringLength + 1 ) >= reallocLength )
            {
                reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

                if (reallocArray == NULL)
                {
                    throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                }
            }

            wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
            totalLength = totalLength + stringLength ;

            index ++ ;
            if ( index < objectIdentifierLength )
            {
                if ( ( totalLength + 1 + 1 ) >= reallocLength )
                {
                    reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                    reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;
    
                    if (reallocArray == NULL)
                    {
                        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                    }
                }

                wcscpy ( & reallocArray [ totalLength ] , L"." ) ;
                totalLength ++ ;
            }
        }

        returnValue = new wchar_t [ totalLength + 1 ] ;
        if ( objectIdentifierLength )
        {
            wcscpy ( returnValue , reallocArray ) ;
        }
        else
        {
            returnValue [ 0 ] = 0 ;
        }

        free ( reallocArray ) ;
    }
    else
    {
        ULONG returnValueLength = wcslen ( L"0.0" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"0.0" ) ;
    }

    return returnValue ;
}

ULONG *SnmpObjectIdentifierType :: GetValue () const
{
    return objectIdentifier.GetValue () ;
}

ULONG SnmpObjectIdentifierType :: GetValueLength () const
{
    return objectIdentifier.GetValueLength () ;
}

#define AVERAGE_OCTET_LENGTH 256 

SnmpOpaqueType :: SnmpOpaqueType ( 

    const SnmpOpaque &opaqueArg ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , opaque ( opaqueArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
    }
}

SnmpOpaqueType :: SnmpOpaqueType ( 

    const SnmpOpaqueType &opaqueArg 

) : SnmpInstanceType ( opaqueArg ) , SnmpPositiveRangedType ( opaqueArg ) , opaque ( opaqueArg.opaque ) 
{
}

SnmpOpaqueType :: SnmpOpaqueType ( 

    const wchar_t *opaqueArg ,
    const wchar_t *rangeValues

) : SnmpInstanceType ( FALSE ) , SnmpPositiveRangedType ( rangeValues ) , opaque ( NULL , 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( opaqueArg ) && SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
    }
}

SnmpOpaqueType :: SnmpOpaqueType ( 

    const UCHAR *value , 
    const ULONG valueLength ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , opaque ( value , valueLength ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( opaque.GetValueLength () ) ) ;
    }
}

SnmpOpaqueType :: SnmpOpaqueType ( const wchar_t *rangeValues ) :   SnmpInstanceType ( TRUE , TRUE ) , 
                                                                    SnmpPositiveRangedType ( rangeValues ) ,
                                                                    opaque ( NULL , 0 ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
}

SnmpOpaqueType :: ~SnmpOpaqueType () 
{
}

BOOL SnmpOpaqueType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = opaque.Equivalent( ((const SnmpOpaqueType&)value).opaque );
    }

    return bResult;
}

SnmpInstanceType *SnmpOpaqueType :: Copy () const 
{
    return new SnmpOpaqueType ( *this ) ;
}

BOOL SnmpOpaqueType :: Parse ( const wchar_t *opaqueArg ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
    UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

    if (reallocArray == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

/* 
 * Oqaque Definitions
 */

    BOOL even = FALSE ;
    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = opaqueArg [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;

                even = FALSE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;

                even = FALSE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    if ( reallocLength <= length ) 
                    {
                        reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                        reallocArray = ( UCHAR * ) realloc ( reallocArray , reallocLength * sizeof ( UCHAR ) ) ;

                        if (reallocArray == NULL)
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
                    }

                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    reallocArray [ length ] = ( UCHAR ) byte ;
                    state = 1 ;
                    length ++ ;
                    byte = 0 ;
                    even = TRUE ;
                }
                else if ( token == 0 )
                {
                    state = REJECT_STATE ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( length )
    {
        opaque.SetValue ( reallocArray , length ) ;
    }
    else
    {
        opaque.SetValue ( NULL , 0 ) ;
    }

    free ( reallocArray ) ;

    return status ;
}

SnmpObjectIdentifier SnmpOpaqueType :: Encode ( const SnmpObjectIdentifier &objectIdentifierArg ) const
{
    ULONG opaqueLength = opaque.GetValueLength () ;
    ULONG *objectIdentifier = new ULONG [ opaqueLength ] ;
    UCHAR *opaqueArray = opaque.GetValue () ;
    for ( ULONG index = 0 ; index < opaqueLength ; index ++ )
    {
        objectIdentifier [ index ] = ( ULONG ) opaqueArray [ index ] ;
    }

    SnmpObjectIdentifier returnValue = objectIdentifierArg + SnmpObjectIdentifier ( & opaqueLength , 1 ) + SnmpObjectIdentifier ( objectIdentifier , opaqueLength ) ;
    
    delete [] objectIdentifier ;

    return returnValue ;
}

SnmpObjectIdentifier SnmpOpaqueType :: Decode ( const SnmpObjectIdentifier &objectIdentifierArg )
{
    if ( objectIdentifierArg.GetValueLength () )
    {
        ULONG opaqueLength = objectIdentifierArg [ 0 ] ;
        if ( objectIdentifierArg.GetValueLength () >= opaqueLength + 1 )
        {
            UCHAR *opaqueArray = new UCHAR [ opaqueLength ] ;
            for ( ULONG index = 0 ; index < opaqueLength ; index ++ )
            {
                opaqueArray [ index ] = ( UCHAR ) objectIdentifierArg [ index + 1 ] ;
            }

            opaque.SetValue ( opaqueArray , opaqueLength ) ;

            delete [] opaqueArray ;

            SnmpInstanceType :: SetStatus ( TRUE ) ;
            SnmpInstanceType :: SetNull ( FALSE ) ;

            ULONG opaqueLength = objectIdentifierArg [ 0 ] ;
            if ( opaqueLength < objectIdentifierArg.GetValueLength () )
            {
                SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
                BOOL t_Status = objectIdentifierArg.Suffix ( opaqueLength + 1 , returnValue ) ;
                if ( t_Status ) 
                {
                    return returnValue ;
                }
                else
                {
                    return SnmpObjectIdentifier ( NULL , 0 ) ;
                }
            }
            else
            {
                SnmpInstanceType :: SetStatus ( FALSE ) ;
                return objectIdentifierArg ;
            }
        }
        else
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
            return objectIdentifierArg ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifierArg ;
    }
}

const SnmpValue *SnmpOpaqueType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & opaque : NULL ;
}

wchar_t *SnmpOpaqueType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        ULONG totalLength = 0 ;
        ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
        wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

        if (reallocArray == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        ULONG opaqueLength = opaque.GetValueLength () ;     
        UCHAR *opaqueArray = opaque.GetValue () ;

        ULONG index = 0 ;
        while ( index < opaqueLength ) 
        {
            wchar_t hexValue [ 40 ] ;
            _ultow ( opaqueArray [ index ] , hexValue , 16 );
            ULONG hexLength = wcslen ( hexValue ) ;

            wchar_t stringValue [ 3 ] ;
            ULONG stringLength = 2 ;

            if ( hexLength == 1 )
            {
                stringValue [ 0 ] = L'0' ;
                stringValue [ 1 ] = hexValue [ 0 ] ;
                stringValue [ 2 ] = 0 ;
            }
            else
            {
                stringValue [ 0 ] = hexValue [ 0 ] ;
                stringValue [ 1 ] = hexValue [ 1 ] ;
                stringValue [ 2 ] = 0 ;
            }

            if ( ( totalLength + stringLength + 1 ) >= reallocLength )
            {
                reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

                if (reallocArray == NULL)
                {
                    throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                }
            }

            wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
            totalLength = totalLength + stringLength ;

            index ++ ;
        }

        returnValue = new wchar_t [ totalLength + 1 ] ;
        if ( opaqueLength )
        {
            wcscpy ( returnValue , reallocArray ) ;
        }
        else
        {
            returnValue [ 0 ] = 0 ;
        }

        free ( reallocArray ) ;
    }
    else
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

UCHAR *SnmpOpaqueType :: GetValue () const
{
    return opaque.GetValue () ;
}

ULONG SnmpOpaqueType :: GetValueLength () const
{
    return opaque.GetValueLength () ;
}

SnmpFixedLengthOpaqueType :: SnmpFixedLengthOpaqueType ( 

    const ULONG &fixedLengthArg , 
    const SnmpOpaque &opaqueArg 

) : SnmpOpaqueType ( opaqueArg , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    if ( opaque.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOpaqueType :: SnmpFixedLengthOpaqueType ( 

    const SnmpFixedLengthOpaqueType &opaqueArg 

) : SnmpOpaqueType ( opaqueArg ) ,
    SnmpFixedType ( opaqueArg )
{
    if ( opaque.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpInstanceType *SnmpFixedLengthOpaqueType :: Copy () const 
{
    return new SnmpFixedLengthOpaqueType ( *this ) ;
}

SnmpFixedLengthOpaqueType :: SnmpFixedLengthOpaqueType ( 

    const ULONG &fixedLengthArg ,
    const wchar_t *opaqueArg 

) : SnmpOpaqueType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    SnmpInstanceType :: SetStatus ( Parse ( opaqueArg ) ) ;
    if ( opaque.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOpaqueType :: SnmpFixedLengthOpaqueType ( 

    const ULONG &fixedLengthArg ,
    const UCHAR *value , 
    const ULONG valueLength 

) : SnmpOpaqueType ( value , valueLength , NULL ) ,
    SnmpFixedType ( fixedLengthArg ) 
{
    if ( opaque.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOpaqueType :: SnmpFixedLengthOpaqueType (

    const ULONG &fixedLengthArg

) : SnmpOpaqueType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    SnmpInstanceType :: SetNull ( TRUE ) ;
}

SnmpFixedLengthOpaqueType :: ~SnmpFixedLengthOpaqueType () 
{
}

SnmpObjectIdentifier SnmpFixedLengthOpaqueType :: Encode ( const SnmpObjectIdentifier &objectIdentifierArg ) const
{
    ULONG opaqueLength = opaque.GetValueLength () ;
    ULONG *objectIdentifier = new ULONG [ opaqueLength ] ;
    UCHAR *opaqueArray = opaque.GetValue () ;
    for ( ULONG index = 0 ; index < opaqueLength ; index ++ )
    {
        objectIdentifier [ index ] = ( ULONG ) opaqueArray [ index ] ;
    }

    SnmpObjectIdentifier returnValue = objectIdentifierArg + SnmpObjectIdentifier ( & opaqueLength , 1 ) + SnmpObjectIdentifier ( objectIdentifier , opaqueLength ) ;
    
    delete [] objectIdentifier ;

    return returnValue ;
}

SnmpObjectIdentifier SnmpFixedLengthOpaqueType :: Decode ( const SnmpObjectIdentifier &objectIdentifierArg )
{
    if ( objectIdentifierArg.GetValueLength () >= fixedLength )
    {
        UCHAR *opaqueArray = new UCHAR [ fixedLength ] ;
        for ( ULONG index = 0 ; index < fixedLength ; index ++ )
        {
            opaqueArray [ index ] = ( UCHAR ) objectIdentifierArg [ index + 1 ] ;
        }

        opaque.SetValue ( opaqueArray , fixedLength ) ;

        delete [] opaqueArray ;

        SnmpInstanceType :: SetStatus ( TRUE ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifierArg.Suffix ( fixedLength , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifierArg ;
    }
}

SnmpOctetStringType :: SnmpOctetStringType ( 

    const SnmpOctetString &octetStringArg ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , octetString ( octetStringArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
    }
}

SnmpOctetStringType :: SnmpOctetStringType ( 

    const SnmpOctetStringType &octetStringArg 

) : SnmpInstanceType ( octetStringArg ) , SnmpPositiveRangedType ( octetStringArg ) , octetString ( octetStringArg.octetString ) 
{
}

SnmpOctetStringType :: SnmpOctetStringType ( 

    const wchar_t *octetStringArg ,
    const wchar_t *rangeValues

) : SnmpInstanceType ( FALSE ) , SnmpPositiveRangedType ( rangeValues ) , octetString ( NULL , 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( octetStringArg ) && SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
    }
}

SnmpOctetStringType :: SnmpOctetStringType ( 

    const UCHAR *value , 
    const ULONG valueLength ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , octetString ( value , valueLength ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( octetString.GetValueLength () ) ) ;
    }
}

SnmpOctetStringType :: SnmpOctetStringType ( const wchar_t *rangeValues ) : SnmpPositiveRangedType ( rangeValues ) ,
                                                                            SnmpInstanceType ( TRUE , TRUE ) , 
                                                                            octetString ( NULL , 0 ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
}

SnmpOctetStringType :: ~SnmpOctetStringType () 
{
}

BOOL SnmpOctetStringType :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = octetString.Equivalent( ((const SnmpOctetStringType&)value).octetString );
    }

    return bResult;
}

SnmpInstanceType *SnmpOctetStringType :: Copy () const 
{
    return new SnmpOctetStringType ( *this ) ;
}

BOOL SnmpOctetStringType :: Parse ( const wchar_t *octetStringArg ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
    UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

    if (reallocArray == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

/* 
 * OctetString Definitions
 */

    BOOL even = FALSE ;
    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = octetStringArg [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;

                even = FALSE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;

                even = FALSE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    if ( reallocLength <= length ) 
                    {
                        reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                        reallocArray = ( UCHAR * ) realloc ( reallocArray , reallocLength * sizeof ( UCHAR ) ) ;

                        if (reallocArray == NULL)
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
                    }

                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    reallocArray [ length ] = ( UCHAR ) byte ;
                    state = 1 ;
                    length ++ ;
                    byte = 0 ;
                    even = TRUE ;
                }
                else if ( token == 0 )
                {
                    state = REJECT_STATE ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( length )
    {
        octetString.SetValue ( reallocArray , length ) ;
    }
    else
    {
        octetString.SetValue ( NULL , 0 ) ;
    }

    free ( reallocArray ) ;

    return status ;
}

SnmpObjectIdentifier SnmpOctetStringType :: Encode ( const SnmpObjectIdentifier &objectIdentifierArg ) const
{
    ULONG octetStringLength = octetString.GetValueLength () ;
    ULONG *objectIdentifier = new ULONG [ octetStringLength ] ;
    UCHAR *octetStringArray = octetString.GetValue () ;
    for ( ULONG index = 0 ; index < octetStringLength ; index ++ )
    {
        objectIdentifier [ index ] = ( ULONG ) octetStringArray [ index ] ;
    }

    SnmpObjectIdentifier returnValue = objectIdentifierArg + SnmpObjectIdentifier ( & octetStringLength , 1 ) + SnmpObjectIdentifier ( objectIdentifier , octetStringLength ) ;
    
    delete [] objectIdentifier ;

    return returnValue ;
}

SnmpObjectIdentifier SnmpOctetStringType :: Decode ( const SnmpObjectIdentifier &objectIdentifierArg )
{
    if ( objectIdentifierArg.GetValueLength () )
    {
        ULONG octetStringLength = objectIdentifierArg [ 0 ] ;
        if ( objectIdentifierArg.GetValueLength () >= octetStringLength + 1 )
        {
            UCHAR *octetStringArray = new UCHAR [ octetStringLength ] ;
            for ( ULONG index = 0 ; index < octetStringLength ; index ++ )
            {
                octetStringArray [ index ] = ( UCHAR ) objectIdentifierArg [ index + 1 ] ;
            }

            octetString.SetValue ( octetStringArray , octetStringLength ) ;

            delete [] octetStringArray ;

            SnmpInstanceType :: SetStatus ( TRUE ) ;
            SnmpInstanceType :: SetNull ( FALSE ) ;

            ULONG octetStringLength = objectIdentifierArg [ 0 ] ;

            if ( octetStringLength < objectIdentifierArg.GetValueLength () )
            {
                SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
                BOOL t_Status = objectIdentifierArg.Suffix ( octetStringLength + 1 , returnValue ) ;
                if ( t_Status ) 
                {
                    return returnValue ;
                }
                else
                {
                    return SnmpObjectIdentifier ( NULL , 0 ) ;
                }
            }
            else
            {
                SnmpInstanceType :: SetStatus ( FALSE ) ;
                return objectIdentifierArg ;
            }
        }
        else
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
            return objectIdentifierArg ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifierArg ;
    }
}

const SnmpValue *SnmpOctetStringType :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & octetString : NULL ;
}

wchar_t *SnmpOctetStringType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        ULONG totalLength = 0 ;
        ULONG octetStringLength = octetString.GetValueLength () ;       
        UCHAR *octetStringArray = octetString.GetValue () ;

        returnValue = new wchar_t [ octetStringLength * 2 + 1 ] ;

        ULONG index = 0 ;
        while ( index < octetStringLength ) 
        {
            wchar_t stringValue [ 3 ] ;

            stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
            stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
            stringValue [ 2 ] = 0 ;

            wcscpy ( & returnValue [ totalLength ] , stringValue ) ;
            totalLength = totalLength + 2 ;

            index ++ ;
        }

        returnValue [ octetStringLength * 2 ] = 0 ;
    }
    else
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

UCHAR *SnmpOctetStringType :: GetValue () const
{
    return octetString.GetValue () ;
}

ULONG SnmpOctetStringType :: GetValueLength () const
{
    return octetString.GetValueLength () ;
}

SnmpFixedLengthOctetStringType :: SnmpFixedLengthOctetStringType ( 

    const ULONG &fixedLengthArg , 
    const SnmpOctetString &octetStringArg 

) : SnmpOctetStringType ( octetStringArg , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    if ( octetString.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOctetStringType :: SnmpFixedLengthOctetStringType ( 

    const SnmpFixedLengthOctetStringType &octetStringArg 

) : SnmpOctetStringType ( octetStringArg ) ,
    SnmpFixedType ( octetStringArg )
{
    if ( octetString.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpInstanceType *SnmpFixedLengthOctetStringType :: Copy () const 
{
    return new SnmpFixedLengthOctetStringType ( *this ) ;
}

SnmpFixedLengthOctetStringType :: SnmpFixedLengthOctetStringType ( 

    const ULONG &fixedLengthArg ,
    const wchar_t *octetStringArg 

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    SnmpInstanceType :: SetStatus ( Parse ( octetStringArg ) ) ;
    if ( octetString.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOctetStringType :: SnmpFixedLengthOctetStringType ( 

    const ULONG &fixedLengthArg ,
    const UCHAR *value 

) : SnmpOctetStringType ( value , fixedLengthArg , NULL ) ,
    SnmpFixedType ( fixedLengthArg ) 
{
    if ( octetString.GetValueLength () != fixedLength )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthOctetStringType :: SnmpFixedLengthOctetStringType (

    const ULONG &fixedLengthArg

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL ) ,
    SnmpFixedType ( fixedLengthArg )
{
    SnmpInstanceType :: SetNull ( TRUE ) ;
}

SnmpFixedLengthOctetStringType :: ~SnmpFixedLengthOctetStringType () 
{
}

SnmpObjectIdentifier SnmpFixedLengthOctetStringType :: Encode ( const SnmpObjectIdentifier &objectIdentifierArg ) const
{
    ULONG octetStringLength = octetString.GetValueLength () ;
    ULONG *objectIdentifier = new ULONG [ octetStringLength ] ;
    UCHAR *octetStringArray = octetString.GetValue () ;
    for ( ULONG index = 0 ; index < octetStringLength ; index ++ )
    {
        objectIdentifier [ index ] = ( ULONG ) octetStringArray [ index ] ;
    }

    SnmpObjectIdentifier returnValue = objectIdentifierArg + SnmpObjectIdentifier ( objectIdentifier , octetStringLength ) ;
    
    delete [] objectIdentifier ;

    return returnValue ;
}

SnmpObjectIdentifier SnmpFixedLengthOctetStringType :: Decode ( const SnmpObjectIdentifier &objectIdentifierArg )
{
    if ( objectIdentifierArg.GetValueLength () >= fixedLength )
    {
        UCHAR *octetStringArray = new UCHAR [ fixedLength ] ;
        for ( ULONG index = 0 ; index < fixedLength ; index ++ )
        {
            octetStringArray [ index ] = ( UCHAR ) objectIdentifierArg [ index + 1 ] ;
        }

        octetString.SetValue ( octetStringArray , fixedLength ) ;

        delete [] octetStringArray ;

        SnmpInstanceType :: SetStatus ( TRUE ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifierArg.Suffix ( fixedLength , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifierArg ;
    }
}

SnmpMacAddressType :: SnmpMacAddressType ( const SnmpOctetString &macAddressArg ) : SnmpFixedLengthOctetStringType ( 6 , macAddressArg ) 
{
}

SnmpMacAddressType :: SnmpMacAddressType ( const SnmpMacAddressType &macAddressArg ) : SnmpFixedLengthOctetStringType ( macAddressArg ) 
{
}

SnmpInstanceType *SnmpMacAddressType :: Copy () const 
{
    return new SnmpMacAddressType ( *this ) ;
}

SnmpMacAddressType :: SnmpMacAddressType ( const wchar_t *macAddressArg ) : SnmpFixedLengthOctetStringType ( 6 )  
{
    SnmpInstanceType :: SetStatus ( Parse ( macAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

BOOL SnmpMacAddressType :: Parse ( const wchar_t *macAddressArg ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    UCHAR macAddress [ 6 ] ;

/* 
 * MacAddress Definitions
 */

    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = macAddressArg [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 1 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( length >= 6 ) state = REJECT_STATE ;
                else if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    macAddress [ length ] = ( UCHAR ) byte ;
                    state = 2 ;
                    length ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( token == L':' ) state = 0 ;
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( status )
    {
        octetString.SetValue ( macAddress , 6 ) ;
    }

    return status ;
}

SnmpMacAddressType :: SnmpMacAddressType ( const UCHAR *value ) : SnmpFixedLengthOctetStringType ( 6 , value ) 
{
}

SnmpMacAddressType :: SnmpMacAddressType () : SnmpFixedLengthOctetStringType ( 6 ) 
{
}

SnmpMacAddressType :: ~SnmpMacAddressType () 
{
}

wchar_t *SnmpMacAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        UCHAR *value = octetString.GetValue () ;
        ULONG valueLength = octetString.GetValueLength () ;
        if ( valueLength != 6 )
            throw ;

        returnValue = new wchar_t [ 18 ] ;

        returnValue [ 2 ] = L':' ;
        returnValue [ 5 ] = L':' ;
        returnValue [ 8 ] = L':' ;
        returnValue [ 11 ] = L':' ;
        returnValue [ 14 ] = L':' ;
        returnValue [ 17 ] = 0 ;

        returnValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 0 ] >> 4 ) ;
        returnValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 0 ] & 0xf ) ;

        returnValue [ 3 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 1 ] >> 4 ) ;
        returnValue [ 4 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 1 ] & 0xf ) ;

        returnValue [ 6 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 2 ] >> 4 ) ;
        returnValue [ 7 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 2 ] & 0xf ) ;

        returnValue [ 9 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 3 ] >> 4 ) ;
        returnValue [ 10 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 3 ] & 0xf ) ;

        returnValue [ 12 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 4 ] >> 4 ) ;
        returnValue [ 13 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 4 ] & 0xf ) ;

        returnValue [ 15 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 5 ] >> 4 ) ;
        returnValue [ 16 ] = SnmpAnalyser :: DecIntegerToHexWChar ( value [ 5 ] & 0xf ) ;
    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}

SnmpPhysAddressType :: SnmpPhysAddressType ( 

    const SnmpOctetString &physAddressArg , 
    const wchar_t *rangedValues 

) : SnmpOctetStringType ( physAddressArg , rangedValues ) 
{
}

SnmpPhysAddressType :: SnmpPhysAddressType ( 

    const SnmpPhysAddressType &physAddressArg 

) : SnmpOctetStringType ( physAddressArg ) 
{
}

SnmpInstanceType *SnmpPhysAddressType :: Copy () const 
{
    return new SnmpPhysAddressType ( *this ) ;
}

SnmpPhysAddressType :: SnmpPhysAddressType ( 

    const wchar_t *physAddressArg ,
    const wchar_t *rangedValues

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues )  
{
    SnmpInstanceType :: SetStatus ( Parse ( physAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

BOOL SnmpPhysAddressType :: Parse ( const wchar_t *physAddress ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
    UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

    if (reallocArray == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

/* 
 * PhyAddress Definitions
 */

    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = physAddress [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    if ( reallocLength <= length ) 
                    {
                        reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                        reallocArray = ( UCHAR * ) realloc ( reallocArray , reallocLength * sizeof ( UCHAR ) ) ;

                        if (reallocArray == NULL)
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
                    }

                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    reallocArray [ length ] = ( UCHAR ) byte ;
                    state = 3 ;
                    length ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L':' )
                {
                    state = 1 ;
                }
                else if ( token == 0 )
                {
                    state = ACCEPT_STATE ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( length )
    {
        octetString.SetValue ( reallocArray , length ) ;
    }
    else
    {
        octetString.SetValue ( NULL , 0 ) ;
    }

    free ( reallocArray ) ;

    return status ;
}

SnmpPhysAddressType :: SnmpPhysAddressType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) : SnmpOctetStringType ( value , valueLength , rangedValues ) 
{
}

SnmpPhysAddressType :: SnmpPhysAddressType (

    const wchar_t *rangedValues 

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues ) 
{
    SnmpInstanceType :: SetNull ( TRUE ) ;
}

SnmpPhysAddressType :: ~SnmpPhysAddressType () 
{
}

wchar_t *SnmpPhysAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        ULONG totalLength = 0 ;
        ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
        wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;

        if (reallocArray == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        ULONG physAddressLength = octetString.GetValueLength () ;       
        UCHAR *physAddressArray = octetString.GetValue () ;

        ULONG index = 0 ;
        while ( index < physAddressLength ) 
        {
            wchar_t stringValue [ 3 ] ;

            stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] >> 4 ) ;
            stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] & 0xf ) ;
            stringValue [ 2 ] = 0 ;

            if ( ( totalLength + 2 + 1 ) >= reallocLength )
            {
                reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

                if (reallocArray == NULL)
                {
                    throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                }
            }

            wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
            totalLength = totalLength + 2 ;

            index ++ ;
            if ( index < physAddressLength )
            {
                if ( ( totalLength + 1 + 1 ) >= reallocLength )
                {
                    reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                    reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

                    if (reallocArray == NULL)
                    {
                        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                    }
                }

                wcscpy ( & reallocArray [ totalLength ] , L":" ) ;
                totalLength ++ ;
            }
        }

        returnValue = new wchar_t [ totalLength + 1 ] ;
        if ( physAddressLength )
        {
            wcscpy ( returnValue , reallocArray ) ;
        }
        else
        {
            returnValue [ 0 ] = 0 ;
        }

        free ( reallocArray ) ;
    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}

SnmpFixedLengthPhysAddressType :: SnmpFixedLengthPhysAddressType ( 

    const ULONG &fixedLengthArg ,
    const SnmpOctetString &physAddressArg 

) : SnmpFixedLengthOctetStringType ( fixedLengthArg , physAddressArg ) 
{
}

SnmpFixedLengthPhysAddressType :: SnmpFixedLengthPhysAddressType ( 

    const SnmpFixedLengthPhysAddressType &physAddressArg 

) : SnmpFixedLengthOctetStringType ( physAddressArg ) 
{
}

SnmpInstanceType *SnmpFixedLengthPhysAddressType :: Copy () const 
{
    return new SnmpFixedLengthPhysAddressType ( *this ) ;
}

SnmpFixedLengthPhysAddressType :: SnmpFixedLengthPhysAddressType ( 

    const ULONG &fixedLengthArg ,
    const wchar_t *physAddressArg 

) : SnmpFixedLengthOctetStringType ( fixedLengthArg )
{
    SnmpInstanceType :: SetStatus ( Parse ( physAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpFixedLengthPhysAddressType :: SnmpFixedLengthPhysAddressType (

    const ULONG &fixedLengthArg

) : SnmpFixedLengthOctetStringType ( fixedLengthArg )
{
    SnmpInstanceType :: SetNull ( TRUE ) ;
}

SnmpFixedLengthPhysAddressType :: ~SnmpFixedLengthPhysAddressType () 
{
}

BOOL SnmpFixedLengthPhysAddressType :: Parse ( const wchar_t *physAddress ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
    UCHAR *reallocArray = ( UCHAR * ) malloc ( reallocLength * sizeof ( UCHAR ) ) ;

    if (reallocArray == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

/* 
 * PhyAddress Definitions
 */

    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = physAddress [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else if ( token == 0 ) state = ACCEPT_STATE ;
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    if ( reallocLength <= length ) 
                    {
                        reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                        reallocArray = ( UCHAR * ) realloc ( reallocArray , reallocLength * sizeof ( UCHAR ) ) ;

                        if (reallocArray == NULL)
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
                    }

                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    reallocArray [ length ] = ( UCHAR ) byte ;
                    state = 3 ;
                    length ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L':' )
                {
                    state = 1 ;
                }
                else if ( token == 0 )
                {
                    state = ACCEPT_STATE ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( length == fixedLength )
    {
        octetString.SetValue ( reallocArray , length ) ;
    }
    else
    {
        status = FALSE ;
        octetString.SetValue ( NULL , 0 ) ;
    }

    free ( reallocArray ) ;

    return status ;
}

wchar_t *SnmpFixedLengthPhysAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG totalLength = 0 ;
        ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
        wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;
        
        if (reallocArray == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        ULONG physAddressLength = octetString.GetValueLength () ;       
        UCHAR *physAddressArray = octetString.GetValue () ;

        ULONG index = 0 ;
        while ( index < physAddressLength ) 
        {
            wchar_t stringValue [ 3 ] ;

            stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] >> 4 ) ;
            stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( physAddressArray [ index ] & 0xf ) ;
            stringValue [ 2 ] = 0 ;

            if ( ( totalLength + 2 + 1 ) >= reallocLength )
            {
                reallocLength = reallocLength + AVERAGE_OCTET_LENGTH ;
                reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

                if (reallocArray == NULL)
                {
                    throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                }
            }

            wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
            totalLength = totalLength + 2 ;

            index ++ ;
            if ( index < physAddressLength )
            {
                if ( ( totalLength + 1 + 1 ) >= reallocLength )
                {
                    reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                    reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

                    if (reallocArray == NULL)
                    {
                        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                    }
                }

                wcscpy ( & reallocArray [ totalLength ] , L":" ) ;
                totalLength ++ ;
            }
        }

        returnValue = new wchar_t [ totalLength + 1 ] ;
        if ( physAddressLength )
        {
            wcscpy ( returnValue , reallocArray ) ;
        }
        else
        {
            returnValue [ 0 ] = 0 ;
        }

        free ( reallocArray ) ;
    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}

SnmpDisplayStringType :: SnmpDisplayStringType ( 

    const SnmpOctetString &displayStringArg ,
    const wchar_t *rangeValues

) : SnmpOctetStringType ( displayStringArg , rangeValues ) 
{
}

SnmpDisplayStringType :: SnmpDisplayStringType ( 

    const SnmpDisplayStringType &displayStringArg 

) : SnmpOctetStringType ( displayStringArg ) 
{
}

SnmpInstanceType *SnmpDisplayStringType :: Copy () const 
{
    return new SnmpDisplayStringType ( *this ) ;
}

SnmpDisplayStringType :: SnmpDisplayStringType ( 

    const wchar_t *displayStringArg ,
    const wchar_t *rangeValues

) : SnmpOctetStringType ( NULL , 0 , rangeValues )
{
    char *textBuffer = UnicodeToDbcsString ( displayStringArg ) ;
    if ( textBuffer )
    {
        ULONG textLength = strlen ( textBuffer ) ;

        octetString.SetValue ( ( UCHAR * ) textBuffer , textLength ) ;

        delete [] textBuffer ;

        SnmpInstanceType :: SetStatus ( TRUE ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpDisplayStringType :: SnmpDisplayStringType (

    const wchar_t *rangedValues 

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , rangedValues )
{
    SnmpInstanceType :: SetNull ( TRUE ) ;
}

SnmpDisplayStringType :: ~SnmpDisplayStringType () 
{
}

wchar_t *SnmpDisplayStringType :: GetValue () const 
{
    if ( SnmpInstanceType :: IsValid () )
    {
        if ( ! SnmpInstanceType :: IsNull () )
        {
            char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
            memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
            textBuffer [ octetString.GetValueLength () ] = 0 ;

            wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

            delete [] textBuffer ;

            return unicodeString ;
        }
        else
        {
            return SnmpOctetStringType :: GetStringValue () ;
        }
    }
    else
    {
        return SnmpOctetStringType :: GetStringValue () ;
    }
}

wchar_t *SnmpDisplayStringType :: GetStringValue () const 
{
    if ( SnmpInstanceType :: IsValid () )
    {
        if ( ! SnmpInstanceType :: IsNull () )
        {
            char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
            memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
            textBuffer [ octetString.GetValueLength () ] = 0 ;

            wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

            delete [] textBuffer ;

            return unicodeString ;
        }
        else
        {
            return SnmpOctetStringType :: GetStringValue () ;
        }
    }
    else
    {
        return SnmpOctetStringType :: GetStringValue () ;
    }

}

SnmpFixedLengthDisplayStringType :: SnmpFixedLengthDisplayStringType ( 

    const ULONG &fixedLengthArg ,
    const SnmpOctetString &displayStringArg 

) : SnmpFixedLengthOctetStringType ( fixedLengthArg , displayStringArg ) 
{
}

SnmpFixedLengthDisplayStringType :: SnmpFixedLengthDisplayStringType ( 

    const SnmpFixedLengthDisplayStringType &displayStringArg 

) : SnmpFixedLengthOctetStringType ( displayStringArg ) 
{
}

SnmpInstanceType *SnmpFixedLengthDisplayStringType :: Copy () const 
{
    return new SnmpFixedLengthDisplayStringType ( *this ) ;
}

SnmpFixedLengthDisplayStringType :: SnmpFixedLengthDisplayStringType ( 

    const ULONG &fixedLengthArg ,
    const wchar_t *displayStringArg 

) : SnmpFixedLengthOctetStringType ( fixedLengthArg )
{
    char *textBuffer = UnicodeToDbcsString ( displayStringArg ) ;
    if ( textBuffer )
    {
        ULONG textLength = strlen ( textBuffer ) ;

        octetString.SetValue ( ( UCHAR * ) textBuffer , textLength + 1 ) ;

        delete [] textBuffer ;
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpFixedLengthDisplayStringType :: SnmpFixedLengthDisplayStringType (

    const ULONG &fixedLengthArg

) : SnmpFixedLengthOctetStringType ( fixedLengthArg )
{
}

SnmpFixedLengthDisplayStringType :: ~SnmpFixedLengthDisplayStringType () 
{
}

wchar_t *SnmpFixedLengthDisplayStringType :: GetValue () const 
{
    if ( SnmpInstanceType :: IsValid () )
    {
        char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
        memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
        textBuffer [ octetString.GetValueLength () ] = 0 ;

        wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

        delete [] textBuffer ;

        return unicodeString ;
    }
    else
    {
        return SnmpOctetStringType :: GetStringValue () ;
    }
}

wchar_t *SnmpFixedLengthDisplayStringType :: GetStringValue () const 
{
    if ( SnmpInstanceType :: IsValid () )
    {
        char *textBuffer = new char [ octetString.GetValueLength () + 1 ] ;
        memcpy ( textBuffer , octetString.GetValue () , octetString.GetValueLength () ) ;
        textBuffer [ octetString.GetValueLength () ] = 0 ;

        wchar_t *unicodeString = DbcsToUnicodeString ( textBuffer ) ;

        delete [] textBuffer ;

        return unicodeString ;
    }
    else
    {
        return SnmpOctetStringType :: GetStringValue () ;
    }
}

SnmpEnumeratedType :: SnmpEnumeratedType ( 

    const wchar_t *enumeratedValues , 
    const LONG &enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;

    wchar_t *enumeratedStringValue ;
    if ( integerMap.Lookup ( ( LONG ) enumeratedValue , enumeratedStringValue ) )
    {
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }

    integer.SetValue ( enumeratedValue ) ;

    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpEnumeratedType :: SnmpEnumeratedType ( 

    const wchar_t *enumeratedValues , 
    const SnmpInteger &enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;

    wchar_t *enumeratedStringValue ;
    if ( integerMap.Lookup ( ( LONG ) enumeratedValue.GetValue () , enumeratedStringValue ) )
    {
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }

    integer.SetValue ( enumeratedValue.GetValue () ) ;

    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpEnumeratedType :: SnmpEnumeratedType ( 

    const wchar_t *enumeratedValues , 
    const wchar_t *enumeratedValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;
    LONG enumeratedIntegerValue ;
    if ( stringMap.Lookup ( ( wchar_t * ) enumeratedValue , enumeratedIntegerValue ) )
    {
        integer.SetValue ( enumeratedIntegerValue ) ;
    }
    else
    {
        SnmpAnalyser analyser ;
        analyser.Set ( enumeratedValue ) ;
        SnmpLexicon *lookAhead = analyser.Get () ;
        switch ( lookAhead->GetToken () ) 
        {
            case SnmpLexicon :: UNSIGNED_INTEGER_ID:
            {
                LONG enumerationInteger = lookAhead->GetValue()->signedInteger ;
                integer.SetValue ( enumerationInteger ) ;
            }   
            break ;

            default:
            {
                SnmpInstanceType :: SetStatus ( FALSE ) ;
            }
            break ;
        }

        delete lookAhead ;
    }

    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpEnumeratedType :: SnmpEnumeratedType ( 

    const SnmpEnumeratedType &copy

) : SnmpIntegerType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    POSITION position = copy.integerMap.GetStartPosition () ;
    while ( position )
    {
        LONG enumeratedIntegerValue ;
        wchar_t *enumeratedStringValue ;
        copy.integerMap.GetNextAssoc ( position , enumeratedIntegerValue , enumeratedStringValue ) ;

        wchar_t *stringCopy = new wchar_t [ wcslen ( enumeratedStringValue ) + 1 ] ;
        wcscpy ( stringCopy , enumeratedStringValue ) ;

        integerMap [ enumeratedIntegerValue ] = stringCopy ;
        stringMap [ stringCopy ] = enumeratedIntegerValue ;
    }
}

SnmpEnumeratedType :: SnmpEnumeratedType (

    const wchar_t *enumeratedValues

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( enumeratedValues ) ) ;
}

SnmpEnumeratedType :: ~SnmpEnumeratedType ()
{
    POSITION position = integerMap.GetStartPosition () ;
    while ( position )
    {
        LONG enumeratedIntegerValue ;
        wchar_t *enumeratedStringValue ;
        integerMap.GetNextAssoc ( position , enumeratedIntegerValue , enumeratedStringValue ) ;

        delete [] enumeratedStringValue ;
    }

    integerMap.RemoveAll () ;
    stringMap.RemoveAll () ;

    delete pushBack ;
}

wchar_t *SnmpEnumeratedType :: GetStringValue () const
{
    wchar_t *stringValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        if ( ! SnmpInstanceType :: IsNull () )
        {
            wchar_t *enumeratedValue ;
            if ( integerMap.Lookup ( integer.GetValue () , enumeratedValue ) )
            {
                stringValue = new wchar_t [ wcslen ( enumeratedValue ) + 1 ] ;
                wcscpy ( stringValue , enumeratedValue ) ;
            }
            else
            {
                stringValue = SnmpIntegerType :: GetStringValue () ;
            }
        }
        else
        {
            stringValue = SnmpIntegerType :: GetStringValue () ;
        }
    }
    else
    {
        stringValue = SnmpIntegerType :: GetStringValue () ;
    }

    return stringValue ;
}

wchar_t *SnmpEnumeratedType :: GetValue () const
{
    wchar_t *stringValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        if ( ! SnmpInstanceType :: IsNull () )
        {
            wchar_t *enumeratedValue ;
            if ( integerMap.Lookup ( integer.GetValue () , enumeratedValue ) )
            {
                stringValue = new wchar_t [ wcslen ( enumeratedValue ) + 1 ] ;
                wcscpy ( stringValue , enumeratedValue ) ;
            }
            else
            {
                stringValue = SnmpIntegerType :: GetStringValue () ;
            }
        }
        else
        {
            stringValue = SnmpIntegerType :: GetStringValue () ;
        }
    }
    else
    {
        stringValue = SnmpIntegerType :: GetStringValue () ;
    }

    return stringValue ;
}

SnmpInstanceType *SnmpEnumeratedType :: Copy () const
{
    return new SnmpEnumeratedType ( *this ) ;
}

BOOL SnmpEnumeratedType :: Parse ( const wchar_t *enumeratedValues )
{
    BOOL status = TRUE ;

    analyser.Set ( enumeratedValues ) ;

    return EnumerationDef () && RecursiveDef () ;
}

BOOL SnmpEnumeratedType :: EnumerationDef ()
{
    BOOL status = TRUE ;

    wchar_t *enumerationString = NULL ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: TOKEN_ID:
        {
            wchar_t *tokenString = lookAhead->GetValue()->token ;
            enumerationString = new wchar_t [ wcslen ( tokenString ) + 1 ] ;

			try
			{
				wcscpy ( enumerationString , tokenString ) ;

				SnmpLexicon *lookAhead = Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case SnmpLexicon :: OPEN_PAREN_ID:
					{
						SnmpLexicon *lookAhead = Get () ;
						switch ( lookAhead->GetToken () ) 
						{
							case SnmpLexicon :: UNSIGNED_INTEGER_ID:
							{
								LONG enumerationInteger = lookAhead->GetValue()->signedInteger ;
								integerMap [ enumerationInteger ] = enumerationString ;
								stringMap [ enumerationString ] = enumerationInteger ;
								enumerationString = NULL ;

								Match ( SnmpLexicon :: CLOSE_PAREN_ID ) ;
							}
							break ;

							default:
							{
								status = FALSE ;
							}
							break ;
						}
					}
					break ;

					default:
					{
						status = FALSE ;
					}
					break ;
				}
			}
			catch(...)
			{
				if ( enumerationString )
				{
					delete [] enumerationString ;
				}

				throw;
			}

			if ( enumerationString )
			{
				delete [] enumerationString ;
			}
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL SnmpEnumeratedType :: RecursiveDef ()
{
    BOOL status = TRUE ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: COMMA_ID:
        {
            PushBack () ;
            Match ( SnmpLexicon :: COMMA_ID ) &&
            EnumerationDef () &&
            RecursiveDef () ;
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

void SnmpEnumeratedType  :: PushBack ()
{
    pushedBack = TRUE ;
}

SnmpLexicon *SnmpEnumeratedType  :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = NULL ;
        pushBack = analyser.Get ( TRUE ) ;
    }

    return pushBack ;
}
    
SnmpLexicon *SnmpEnumeratedType  :: Match ( SnmpLexicon :: LexiconToken tokenType )
{
    SnmpLexicon *lexicon = Get () ;
    SnmpInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
    return SnmpInstanceType :: IsValid () ? lexicon : NULL ;
}

SnmpRowStatusType :: SnmpRowStatusType ( 

    const LONG &rowStatusValue 

) : SnmpEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

SnmpRowStatusType :: SnmpRowStatusType ( 

    const wchar_t *rowStatusValue 

) : SnmpEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

SnmpRowStatusType :: SnmpRowStatusType ( 

    const SnmpInteger &rowStatusValue 

) : SnmpEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , rowStatusValue ) 
{
}

SnmpRowStatusType :: SnmpRowStatusType ( 

    const SnmpRowStatusEnum &rowStatusValue 

) : SnmpEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" , ( LONG ) rowStatusValue ) 
{
}

SnmpRowStatusType :: SnmpRowStatusType ( const SnmpRowStatusType &rowStatusValue ) : SnmpEnumeratedType ( rowStatusValue ) 
{
}

SnmpRowStatusType :: SnmpRowStatusType () : SnmpEnumeratedType ( L"active(1),notInService(2),notReady(3),createAndGo(4),createAndWait(5),destroy(6)" )
{
}

SnmpRowStatusType :: ~SnmpRowStatusType () 
{
}

wchar_t *SnmpRowStatusType :: GetStringValue () const 
{
    return SnmpEnumeratedType :: GetStringValue () ;
}

wchar_t *SnmpRowStatusType :: GetValue () const 
{
    return SnmpEnumeratedType :: GetValue () ;
}

SnmpRowStatusType :: SnmpRowStatusEnum SnmpRowStatusType :: GetRowStatus () const 
{
    return ( SnmpRowStatusType :: SnmpRowStatusEnum ) integer.GetValue () ;
} ;

SnmpInstanceType *SnmpRowStatusType :: Copy () const
{
    return new SnmpRowStatusType ( *this ) ;
}

SnmpBitStringType :: SnmpBitStringType ( 

    const wchar_t *bitStringValues , 
    const SnmpOctetString &bitStringValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;

    BOOL valueStatus = TRUE ;

    ULONG bitCounter = 0 ;
    UCHAR *value = bitStringValue.GetValue () ;
    ULONG valueLength = bitStringValue.GetValueLength () ;
    ULONG valueIndex = 0 ;

    while ( valueIndex < valueLength ) 
    {
        for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
        {
            ULONG bitValue = ( bit == 0 ) ? 0x80 : ( 1 << (7 - bit) ) ;
            bitValue = value [ valueIndex ] & bitValue ;
            if ( bitValue )                 
            {
                bitValue = bit + ( valueIndex * 8 ) ;
                wchar_t *bitStringStringValue ;
                if ( integerMap.Lookup ( bitValue , bitStringStringValue ) )
                {
                }
                else
                {
                    valueStatus = FALSE ;
                }
            }
        }

        valueIndex ++ ;
    }

    octetString.SetValue ( bitStringValue.GetValue () , bitStringValue.GetValueLength () ) ;

    SnmpInstanceType :: SetStatus ( valueStatus ) ;

    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpBitStringType :: SnmpBitStringType ( 

    const wchar_t *bitStringValues , 
    const wchar_t **bitStringValueArray , 
    const ULONG &bitStringValueLength 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;

    BOOL valueStatus = TRUE ;

    if ( bitStringValueLength )
    {
        ULONG maximumValue = 0 ;
        for ( ULONG index = 0 ; index < bitStringValueLength ; index ++ )
        {
            ULONG bitStringIntegerValue ;
            const wchar_t *bitStringValue = bitStringValueArray [ index ] ;
            if ( stringMap.Lookup ( ( wchar_t * ) bitStringValue , bitStringIntegerValue ) )
            {
                maximumValue = maximumValue < bitStringIntegerValue ? bitStringIntegerValue : maximumValue ;
            }
            else
            {
                SnmpAnalyser analyser ;
                analyser.Set ( bitStringValue ) ;
                SnmpLexicon *lookAhead = analyser.Get () ;
                switch ( lookAhead->GetToken () ) 
                {
                    case SnmpLexicon :: UNSIGNED_INTEGER_ID:
                    {
                        ULONG bitStringIntegerValue = lookAhead->GetValue()->signedInteger ;
                        maximumValue = maximumValue < bitStringIntegerValue ? bitStringIntegerValue : maximumValue ;
                    }   
                    break ;

                    default:
                    {
                        valueStatus = FALSE ;
                    }
                    break ;
                }

                delete lookAhead ;
            }
        }

        if ( valueStatus )
        {
            ULONG valueLength = ( maximumValue >> 3 ) + 1 ;
            UCHAR *value = new UCHAR [ valueLength ] ;
            memset ( value , 0 , sizeof ( UCHAR ) ) ;
            
            for ( ULONG index = 0 ; ( index < bitStringValueLength ) && valueStatus ; index ++ )
            {
                ULONG bitStringIntegerValue ;
                const wchar_t *bitStringValue = bitStringValueArray [ index ] ;
                if ( stringMap.Lookup ( ( wchar_t * ) bitStringValue , bitStringIntegerValue ) )
                {
                    ULONG byte = bitStringIntegerValue >> 3 ;
                    UCHAR bit = ( UCHAR ) ( bitStringIntegerValue & 0x7 ) ;
                    bit = ( bit == 0 ) ? 0x80 : ( 1 << (7 - bit) ) ;
                    value [ byte ] = value [ byte ] | bit ;
                }
                else
                {
                    SnmpAnalyser analyser ;
                    analyser.Set ( bitStringValue ) ;
                    SnmpLexicon *lookAhead = analyser.Get () ;
                    switch ( lookAhead->GetToken () ) 
                    {
                        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
                        {
                            LONG bitStringIntegerValue = lookAhead->GetValue()->signedInteger ;
                            ULONG byte = bitStringIntegerValue >> 3 ;
                            UCHAR bit = ( UCHAR ) ( bitStringIntegerValue & 0x7 ) ;
                            bit = ( bit == 0 ) ? 0x80 : ( 1 << (7 - bit) ) ;
                            value [ byte ] = value [ byte ] | bit ;
                        }   
                        break ;

                        default:
                        {
                        }
                        break ;
                    }

                    delete lookAhead ;

                    valueStatus = FALSE ;
                }
            }

            octetString.SetValue ( value , valueLength ) ;
            delete [] value ;
        }
    }
    else
    {
        octetString.SetValue ( NULL , 0 ) ;
    }

    SnmpInstanceType :: SetStatus ( valueStatus ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpBitStringType :: SnmpBitStringType ( 

    const SnmpBitStringType &copy

) : SnmpOctetStringType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    POSITION position = copy.integerMap.GetStartPosition () ;
    while ( position )
    {
        ULONG bitStringIntegerValue ;
        wchar_t *bitStringStringValue ;
        copy.integerMap.GetNextAssoc ( position , bitStringIntegerValue , bitStringStringValue ) ;

        wchar_t *stringCopy = new wchar_t [ wcslen ( bitStringStringValue ) + 1 ] ;
        wcscpy ( stringCopy , bitStringStringValue ) ;

        integerMap [ bitStringIntegerValue ] = stringCopy ;
        stringMap [ stringCopy ] = bitStringIntegerValue ;
    }
}

SnmpBitStringType :: SnmpBitStringType (

    const wchar_t *bitStringValues

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( bitStringValues ) ) ;
}

SnmpBitStringType :: ~SnmpBitStringType ()
{
    POSITION position = integerMap.GetStartPosition () ;
    while ( position )
    {
        ULONG bitStringIntegerValue ;
        wchar_t *bitStringStringValue ;
        integerMap.GetNextAssoc ( position , bitStringIntegerValue , bitStringStringValue ) ;

        delete [] bitStringStringValue ;
    }

    integerMap.RemoveAll () ;
    stringMap.RemoveAll () ;

    delete pushBack ;
}

ULONG SnmpBitStringType :: GetValue ( wchar_t **&stringValue ) const
{
    ULONG stringValueLength = 0 ;
    stringValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull () )
    {
        UCHAR *value = octetString.GetValue () ;
        ULONG valueLength = octetString.GetValueLength () ;
        ULONG valueIndex = 0 ;

        BOOL valueStatus = TRUE ;

        while ( ( valueIndex < valueLength ) && valueStatus )
        {
            for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
            {
                ULONG bitValue = ( bit == 0 ) ? 0x80 : ( 1 << (7 - bit) ) ;
                bitValue = value [ valueIndex ] & bitValue ;
                if ( bitValue )                 
                {
                    stringValueLength ++ ;
                }
            }

            valueIndex ++ ;
        }

        if ( stringValueLength )
        {
            stringValue = new wchar_t * [ stringValueLength ] ;

            ULONG stringValueIndex = 0 ;
            valueIndex = 0 ;
            while ( valueIndex < valueLength ) 
            {
                for ( ULONG bit = 0 ; bit < 8 ; bit ++ )
                {
                    ULONG bitValue = ( bit == 0 ) ? 0x80 : ( 1 << (7 - bit) ) ;
                    bitValue = value [ valueIndex ] & bitValue ;
                    if ( bitValue )                 
                    {
                        bitValue = bit + ( valueIndex << 3 ) ;
                        wchar_t *bitStringStringValue ;
                        if ( integerMap.Lookup ( ( LONG ) bitValue , bitStringStringValue ) )
                        {
                            stringValue [ stringValueIndex ++ ] = UnicodeStringDuplicate ( bitStringStringValue ) ;
                        }
                        else
                        {
                            wchar_t stringValueBuffer [ 40 ] ;
                            _ultow ( bitValue , stringValueBuffer , 10 );
                            wchar_t *returnValue = new wchar_t [ wcslen ( stringValueBuffer ) + 1 ] ;
                            wcscpy ( returnValue , stringValueBuffer ) ;
                            stringValue [ stringValueIndex ++ ] = returnValue ;

                            valueStatus = FALSE ;
                        }
                    }
                }

                valueIndex ++ ;
            }
        }
    }

    return stringValueLength ;
}

wchar_t *SnmpBitStringType :: GetStringValue () const
{
    return SnmpOctetStringType :: GetStringValue () ;
}

SnmpInstanceType *SnmpBitStringType :: Copy () const
{
    return new SnmpBitStringType ( *this ) ;
}

BOOL SnmpBitStringType :: Parse ( const wchar_t *bitStringValues )
{
    BOOL status = TRUE ;

    analyser.Set ( bitStringValues ) ;

    return BitStringDef () && RecursiveDef () ;
}

BOOL SnmpBitStringType :: BitStringDef ()
{
    BOOL status = TRUE ;

    wchar_t *bitStringString = NULL ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: TOKEN_ID:
        {
            wchar_t *tokenString = lookAhead->GetValue()->token ;
            bitStringString = new wchar_t [ wcslen ( tokenString ) + 1 ] ;
			try
			{
				wcscpy ( bitStringString , tokenString ) ;

				SnmpLexicon *lookAhead = Get () ;
				switch ( lookAhead->GetToken () ) 
				{
					case SnmpLexicon :: OPEN_PAREN_ID:
					{
						SnmpLexicon *lookAhead = Get () ;
						switch ( lookAhead->GetToken () ) 
						{
							case SnmpLexicon :: UNSIGNED_INTEGER_ID:
							{
								LONG bitStringInteger = lookAhead->GetValue()->signedInteger ;
								integerMap [ bitStringInteger ] = bitStringString ;
								stringMap [ bitStringString ] = bitStringInteger ;
								bitStringString = NULL;

								Match ( SnmpLexicon :: CLOSE_PAREN_ID ) ;
							}
							break ;

							default:
							{
								status = FALSE ;
							}
							break ;
						}
					}
					break ;

					default:
					{
						status = FALSE ;
					}
					break ;
				}
			}
			catch(...)
			{
				if ( bitStringString )
				{
					delete [] bitStringString ;
				}

				throw;
			}

			if ( bitStringString )
			{
				delete [] bitStringString ;
			}
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

BOOL SnmpBitStringType :: RecursiveDef ()
{
    BOOL status = TRUE ;

    SnmpLexicon *lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: COMMA_ID:
        {
            PushBack () ;
            Match ( SnmpLexicon :: COMMA_ID ) &&
            BitStringDef () &&
            RecursiveDef () ;
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
            PushBack () ;
        } 
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    return status ;
}

void SnmpBitStringType  :: PushBack ()
{
    pushedBack = TRUE ;
}

SnmpLexicon *SnmpBitStringType  :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = NULL ;
        pushBack = analyser.Get ( TRUE ) ;
    }

    return pushBack ;
}
    
SnmpLexicon *SnmpBitStringType  :: Match ( SnmpLexicon :: LexiconToken tokenType )
{
    SnmpLexicon *lexicon = Get () ;
    SnmpInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
    return SnmpInstanceType :: IsValid () ? lexicon : NULL ;
}

SnmpDateTimeType :: SnmpDateTimeType ( 

    const SnmpOctetString &dateTimeValue 

) : SnmpOctetStringType ( dateTimeValue , NULL ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    ULONG valueLength = dateTimeValue.GetValueLength () ;
    if ( valueLength != 8 && valueLength != 11 )
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpDateTimeType :: SnmpDateTimeType ( 

    const wchar_t *dateTimeValue 

) : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( dateTimeValue ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

SnmpDateTimeType :: SnmpDateTimeType ( 

    const SnmpDateTimeType &copy

) : SnmpOctetStringType ( copy ) , pushBack ( NULL ) , pushedBack ( FALSE ) 
{
}

SnmpDateTimeType :: SnmpDateTimeType () : pushBack ( NULL ) , pushedBack ( FALSE ) 
{
}

SnmpDateTimeType :: ~SnmpDateTimeType ()
{
}

wchar_t *SnmpDateTimeType :: GetValue () const
{
    wchar_t *stringValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG valueLength = octetString.GetValueLength () ;
        
        if (valueLength == 8 || valueLength == 11)
        {
            UCHAR *value = octetString.GetValue () ;

            USHORT *yearPtr = ( USHORT * ) & value [ 0 ] ;
            UCHAR *monthPtr = ( UCHAR * ) & value [ 2 ] ;
            UCHAR *dayPtr = ( UCHAR * ) & value [ 3 ] ;
            UCHAR *hourPtr = ( UCHAR * ) & value [ 4 ] ;
            UCHAR *minutesPtr = ( UCHAR * ) & value [ 5 ] ;
            UCHAR *secondsPtr = ( UCHAR * ) & value [ 6 ] ;
            UCHAR *deciSecondsPtr = ( UCHAR * ) & value [ 7 ] ;

            char dateTime [ 80 ] ;
            ostrstream oStrStream(dateTime, 80) ;

            oStrStream << ( ULONG ) ( ntohs ( *yearPtr ) ) ;
            oStrStream << "-" ;
            oStrStream << ( ULONG ) ( *monthPtr ) ;
            oStrStream << "-" ;
            oStrStream << ( ULONG ) ( *dayPtr ) ;
            oStrStream << "," ;
            oStrStream << ( ULONG ) ( *hourPtr ) ;
            oStrStream << ":" ;
            oStrStream << ( ULONG ) ( *minutesPtr ) ;
            oStrStream << ":" ;
            oStrStream << ( ULONG ) ( *secondsPtr ) ;
            oStrStream << "." ;
            oStrStream << ( ULONG ) ( *deciSecondsPtr ) ;

            if ( valueLength == 11 )
            {
                UCHAR *UTC_directionPtr = ( UCHAR * ) & value [ 8 ] ;
                UCHAR *UTC_hoursPtr = ( UCHAR * ) & value [ 9 ] ;
                UCHAR *UTC_minutesPtr = ( UCHAR * ) & value [ 10 ] ;

                oStrStream << "," ;
        
                if ( *UTC_directionPtr == '+' )
                {
                    oStrStream << "+" ;
                }
                else
                {
                    oStrStream << "-" ;
                }

                oStrStream << ( ULONG ) ( *UTC_hoursPtr ) ;
                oStrStream << ":" ;
                oStrStream << ( ULONG ) ( *UTC_minutesPtr ) ;
            }

            oStrStream << ends ;

            stringValue = DbcsToUnicodeString ( dateTime ) ;
        }
    }

    if (!stringValue)
    {
        stringValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return stringValue ;
}

wchar_t *SnmpDateTimeType :: GetStringValue () const
{
    wchar_t *stringValue = GetValue () ;
    return stringValue ;
}

SnmpInstanceType *SnmpDateTimeType :: Copy () const
{
    return new SnmpDateTimeType ( *this ) ;
}

BOOL SnmpDateTimeType :: Parse ( const wchar_t *dateTimeValues )
{
    BOOL status = TRUE ;

    analyser.Set ( dateTimeValues ) ;

    return DateTimeDef () ;
}

BOOL SnmpDateTimeType :: DateTimeDef ()
{
    BOOL status = TRUE ;

    ULONG year = 0 ;
    ULONG month = 0 ;
    ULONG day = 0 ;
    ULONG hour = 0 ;
    ULONG minutes = 0 ;
    ULONG seconds = 0 ;
    ULONG deciSeconds = 0 ;
    ULONG UTC_present = FALSE ;
    ULONG UTC_direction = 0 ;
    ULONG UTC_hours = 0 ;
    ULONG UTC_minutes = 0 ;

    SnmpLexicon *lookAhead = NULL ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    year = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: MINUS_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    month = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: MINUS_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    day = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: COMMA_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    hour = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: COLON_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    minutes = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: COLON_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    seconds = lookAhead->GetValue()->unsignedInteger ;

    if ( ! Match ( SnmpLexicon :: DOT_ID ) ) return FALSE ;

    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

    deciSeconds = lookAhead->GetValue()->unsignedInteger ;

    lookAhead = Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: COMMA_ID:
        {
            lookAhead = Get () ;
            switch ( lookAhead->GetToken () ) 
            {
                case SnmpLexicon :: PLUS_ID:
                {
                    UTC_present = TRUE ;
                    UTC_direction = '+' ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

                    UTC_hours = lookAhead->GetValue()->unsignedInteger ;

                    if ( ! Match ( SnmpLexicon :: COLON_ID ) ) return FALSE ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

                    UTC_minutes = lookAhead->GetValue()->unsignedInteger ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: EOF_ID ) ) == FALSE ) return FALSE ;
                }
                break ;

                case SnmpLexicon :: MINUS_ID:
                {
                    UTC_present = TRUE ;
                    UTC_direction = '-' ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

                    UTC_hours = lookAhead->GetValue()->unsignedInteger ;

                    if ( ! Match ( SnmpLexicon :: COLON_ID ) ) return FALSE ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: UNSIGNED_INTEGER_ID ) ) == FALSE ) return FALSE ;

                    UTC_minutes = lookAhead->GetValue()->unsignedInteger ;

                    if ( ( lookAhead = Match ( SnmpLexicon :: EOF_ID ) ) == FALSE ) return FALSE ;
                }
                break ;

                default:
                {
                    status = FALSE ;
                }
                break ;
            }
        }
        break ;

        case SnmpLexicon :: EOF_ID:
        {
        }
        break ;
    
        default:
        {
            status = FALSE ;
        }
        break ; 
    }

    if ( status ) 
    {
        status = FALSE ;

        if ( year <= 65535 )
        if ( month >= 1 && month <= 12 )
        if ( day >= 1 && day <= 31 )
        if ( hour <= 23 )
        if ( minutes <= 59 )
        if ( seconds <= 60 )
        if ( UTC_present )
        {
            if ( UTC_hours <= 11 )
            if ( UTC_minutes <= 59 )
            {
                status = TRUE ;
            }
        }
        else
        {
            status = TRUE ;
        }

        if ( status )
        {

// Encode here

            Encode ( 

                year ,
                month ,
                day ,
                hour ,
                minutes ,
                seconds ,
                deciSeconds ,
                UTC_present ,
                UTC_direction ,
                UTC_hours ,
                UTC_minutes
            ) ;
        }
    }

    return status ;
}

void SnmpDateTimeType :: Encode (

    const ULONG &year ,
    const ULONG &month ,
    const ULONG &day ,
    const ULONG &hour ,
    const ULONG &minutes ,
    const ULONG &seconds ,
    const ULONG &deciSeconds ,
    const ULONG &UTC_present ,
    const ULONG &UTC_direction ,
    const ULONG &UTC_hours ,
    const ULONG &UTC_minutes
) 
{
    UCHAR *value = NULL ;
    ULONG valueLength = 0 ;

    if ( UTC_present )
    {
        valueLength = 11 ;
    }
    else
    {   
        valueLength = 8 ;
    }

    value = new UCHAR [ valueLength ] ;

    USHORT *yearPtr = ( USHORT * ) & value [ 0 ] ;
    UCHAR *monthPtr = ( UCHAR * ) & value [ 2 ] ;
    UCHAR *dayPtr = ( UCHAR * ) & value [ 3 ] ;
    UCHAR *hourPtr = ( UCHAR * ) & value [ 4 ] ;
    UCHAR *minutesPtr = ( UCHAR * ) & value [ 5 ] ;
    UCHAR *secondsPtr = ( UCHAR * ) & value [ 6 ] ;
    UCHAR *deciSecondsPtr = ( UCHAR * ) & value [ 7 ] ;

    *yearPtr = htons ( ( USHORT ) year ) ;
    *monthPtr = ( UCHAR ) month ;
    *dayPtr = ( UCHAR ) day ;
    *hourPtr = ( UCHAR ) hour ;
    *minutesPtr = ( UCHAR ) minutes ;
    *secondsPtr = ( UCHAR ) seconds ;
    *deciSecondsPtr = ( UCHAR ) deciSeconds ;

    if ( UTC_present )
    {
        UCHAR *UTC_directionPtr = ( UCHAR * ) & value [ 8 ] ;
        UCHAR *UTC_hoursPtr = ( UCHAR * ) & value [ 9 ] ;
        UCHAR *UTC_minutesPtr = ( UCHAR * ) & value [ 10 ] ;

        *UTC_directionPtr = ( UCHAR ) UTC_direction ;
        *UTC_hoursPtr = ( UCHAR ) UTC_hours ;
        *UTC_minutesPtr = ( UCHAR ) UTC_minutes ;
    }

    octetString.SetValue ( value , valueLength ) ;

    delete [] value ;
}

void SnmpDateTimeType  :: PushBack ()
{
    pushedBack = TRUE ;
}

SnmpLexicon *SnmpDateTimeType  :: Get ()
{
    if ( pushedBack )
    {
        pushedBack = FALSE ;
    }
    else
    {
        delete pushBack ;
        pushBack = NULL ;
        pushBack = analyser.Get ( TRUE , TRUE ) ;
    }

    return pushBack ;
}
    
SnmpLexicon *SnmpDateTimeType  :: Match ( SnmpLexicon :: LexiconToken tokenType )
{
    SnmpLexicon *lexicon = Get () ;
    SnmpInstanceType :: SetStatus ( lexicon->GetToken () == tokenType ) ;
    return SnmpInstanceType :: IsValid () ? lexicon : NULL ;
}

SnmpOSIAddressType :: SnmpOSIAddressType ( 

    const SnmpOctetString &osiAddressArg 

) : SnmpOctetStringType ( osiAddressArg , NULL ) 
{
    if ( osiAddressArg.GetValueLength () > 1 )
    {
        UCHAR *value = osiAddressArg.GetValue () ;
        ULONG NSAPLength = value [ 0 ] ;

        if ( ! ( NSAPLength < osiAddressArg.GetValueLength () ) )
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpOSIAddressType :: SnmpOSIAddressType ( 

    const SnmpOSIAddressType &osiAddressArg 

) : SnmpOctetStringType ( osiAddressArg ) 
{
}

SnmpInstanceType *SnmpOSIAddressType :: Copy () const 
{
    return new SnmpOSIAddressType ( *this ) ;
}

SnmpOSIAddressType :: SnmpOSIAddressType ( 

    const wchar_t *osiAddressArg 

) : SnmpOctetStringType ( ( const UCHAR * ) NULL , 0 , NULL )  
{
    SnmpInstanceType :: SetStatus ( Parse ( osiAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

BOOL SnmpOSIAddressType :: Parse ( const wchar_t *osiAddress ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;


/* 
 * OSIAddress Definitions
 */

/*
         -- for a SnmpOSIAddress of length m:
          --
          -- octets   contents            encoding
          --    1     length of NSAP      "n" as an unsigned-integer
          --                                (either 0 or from 3 to 20)
          -- 2..(n+1) NSAP                concrete binary representation
          -- (n+2)..m TSEL                string of (up to 64) octets
          --
          SnmpOSIAddress ::= TEXTUAL-CONVENTION
              DISPLAY-HINT "*1x:/1x:"
              STATUS       current
              DESCRIPTION
                      "Represents an OSI transport-address."
              SYNTAX       OCTET STRING (SIZE (1 | 4..85))
*/

    UCHAR *OSIValue = new UCHAR [ 1 + 20 + 64 ] ;

    UCHAR NSAPLength = 0 ;
    ULONG TSELLength = 0 ;

    ULONG byte = 0 ;    
    ULONG position = 0 ;

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = osiAddress [ position ++ ] ;
        switch ( state )
        {
            case 0:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else
                {
                    if ( token == L'/' ) 
                        state = 4 ;
                    else 
                        state = REJECT_STATE ;  
                }
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 2 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    OSIValue [ 1 + NSAPLength ] = ( UCHAR ) byte ;
                    state = 3 ;
                    NSAPLength ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L':' )
                {
                    if ( NSAPLength < 20 ) 
                    {
                        state = 1 ;
                    }
                    else 
                        state = REJECT_STATE ;
                }
                else 
                {
                    if ( token == L'/' )
                    {
                        if ( NSAPLength >= 2 ) 
                        {
                            OSIValue [ 0 ] = NSAPLength ;
                            state = 4 ;
                        }
                        else state = REJECT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
            }
            break ;

            case 4:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = 5 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 5:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    OSIValue [ 1 + NSAPLength + TSELLength ] = ( UCHAR ) byte ;
                    state = 6 ;
                    TSELLength ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 6:
            {
                if ( token == L':' )
                {
                    if ( TSELLength < 64 ) 
                    {
                        state = 4 ;
                    }
                    else state = REJECT_STATE ;
                }
                else 
                {
                    if ( token == 0 )
                    {
                        state = ACCEPT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
            }
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( status )
    {
        octetString.SetValue ( OSIValue , 1 + NSAPLength + TSELLength ) ;
    }
    else
    {
        octetString.SetValue ( NULL , 0 ) ;
    }

    delete [] OSIValue ;

    return status ;
}

SnmpOSIAddressType :: SnmpOSIAddressType ( 

    const UCHAR *value , 
    const ULONG valueLength 

) : SnmpOctetStringType ( value , valueLength , NULL ) 
{
    if ( valueLength > 1 )
    {
        ULONG NSAPLength = value [ 0 ] ;

        if ( ! ( NSAPLength < valueLength ) )
        {
            SnmpInstanceType :: SetStatus ( FALSE ) ;
        }
    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
    }
}

SnmpOSIAddressType :: SnmpOSIAddressType () : SnmpOctetStringType ( NULL ) 
{
}

SnmpOSIAddressType :: ~SnmpOSIAddressType () 
{
}

wchar_t *SnmpOSIAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        ULONG octetStringLength = octetString.GetValueLength () ;       
        UCHAR *octetStringArray = octetString.GetValue () ;

        if ( octetStringLength < 1 )
            throw ;

        ULONG NSAPLength = octetStringArray [ 0 ] ;

        if ( NSAPLength < octetStringLength )
        {
            ULONG totalLength = 0 ;
            ULONG reallocLength = AVERAGE_OCTET_LENGTH ;
            wchar_t *reallocArray = ( wchar_t * ) malloc ( sizeof ( wchar_t ) * reallocLength ) ;
    
            if (reallocArray == NULL)
            {
                throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
            }

            ULONG index = 1 ;
            while ( index <= NSAPLength ) 
            {
                wchar_t stringValue [ 4 ] ;

                if ( index != NSAPLength )
                {
                    stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
                    stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
                    stringValue [ 2 ] = L':' ;
                    stringValue [ 3 ] = 0 ;

                    if ( ( totalLength + 3 + 1 ) >= reallocLength )
                    {
                        reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                        reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

                        if (reallocArray == NULL)
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
                    }

                    wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
                    totalLength = totalLength + 3 ;
                }
                else
                {
                    stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
                    stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
                    stringValue [ 2 ] = 0 ;

                    if ( ( totalLength + 2 + 1 ) >= reallocLength )
                    {
                        reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                        reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

                        if (reallocArray == NULL)
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
                    }

                    wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
                    totalLength = totalLength + 2 ;
                }


                index ++ ;
            }

            wchar_t stringValue [ 2 ] ;

            stringValue [ 0 ] = L'/' ;
            stringValue [ 1 ] = 0 ;

            if ( ( totalLength + 1 + 1 ) >= reallocLength )
            {
                reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

                if (reallocArray == NULL)
                {
                    throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                }
            }

            wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
            totalLength = totalLength + 1 ;

            while ( index < octetStringLength )
            {
                wchar_t stringValue [ 4 ] ;

                if ( index != ( octetStringLength - 1 ) )
                {
                    stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
                    stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
                    stringValue [ 2 ] = L':' ;
                    stringValue [ 3 ] = 0 ;

                    if ( ( totalLength + 3 + 1 ) >= reallocLength )
                    {
                        reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                        reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

                        if (reallocArray == NULL)
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
                    }

                    wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
                    totalLength = totalLength + 3 ;
                }
                else
                {
                    stringValue [ 0 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] >> 4 ) ;
                    stringValue [ 1 ] = SnmpAnalyser :: DecIntegerToHexWChar ( octetStringArray [ index ] & 0xf ) ;
                    stringValue [ 2 ] = 0 ;

                    if ( ( totalLength + 2 + 1 ) >= reallocLength )
                    {
                        reallocLength = reallocLength + AVERAGE_OID_LENGTH ;
                        reallocArray = ( wchar_t * ) realloc ( reallocArray , reallocLength * sizeof ( wchar_t ) ) ;

                        if (reallocArray == NULL)
                        {
                            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
                        }
                    }

                    wcscpy ( & reallocArray [ totalLength ] , stringValue ) ;
                    totalLength = totalLength + 2 ;
                }


                index ++ ;
            }

            returnValue = new wchar_t [ totalLength + 1 ] ;
            wcscpy ( returnValue , reallocArray ) ;

            free ( reallocArray ) ;
        }
        else
            throw ;
    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}

SnmpUDPAddressType :: SnmpUDPAddressType ( 

    const SnmpOctetString &udpAddressArg 

) : SnmpFixedLengthOctetStringType ( 6 , udpAddressArg ) 
{
}

SnmpUDPAddressType :: SnmpUDPAddressType ( 

    const SnmpUDPAddressType &udpAddressArg 

) : SnmpFixedLengthOctetStringType ( udpAddressArg ) 
{
}

SnmpInstanceType *SnmpUDPAddressType :: Copy () const 
{
    return new SnmpUDPAddressType ( *this ) ;
}

SnmpUDPAddressType :: SnmpUDPAddressType ( 

    const wchar_t *udpAddressArg 

) : SnmpFixedLengthOctetStringType ( 6 )  
{
    SnmpInstanceType :: SetStatus ( Parse ( udpAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

BOOL SnmpUDPAddressType :: Parse ( const wchar_t *udpAddressArg ) 
{
    BOOL status = TRUE ;
/*
 *  Datum fields.
 */
    UCHAR udpAddress [ 6 ] ;

    ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
    ULONG positiveMagicPosDigit = 5 ;
    ULONG positiveDatum = 0 ;   

    ULONG datumA = 0 ;
    ULONG datumB = 0 ;
    ULONG datumC = 0 ;
    ULONG datumD = 0 ;

/*
 *  Parse input for dotted decimal IP Address.
 */

    ULONG position = 0 ;
    ULONG state = 0 ;
    while ( state != REJECT_STATE && state != ACCEPT_STATE ) 
    {
/*
 *  Get token from input stream.
 */
        wchar_t token = udpAddressArg [ position ++ ] ;

        switch ( state ) 
        {
/*
 *  Parse first field 'A'.
 */

            case 0:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = ( token - 48 ) ;
                    state = 1 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case 1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 2 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 2:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumA = datumA * 10 + ( token - 48 ) ;
                    state = 3 ;
                }
                else if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 3:
            {
                if ( token == L'.' ) state = 4 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'B'.
 */
            case 4:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                { 
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 5 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 5:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 6 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 6:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) ) 
                {
                    datumB = datumB * 10 + ( token - 48 ) ;
                    state = 7 ;
                }
                else if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 7:
            {
                if ( token == L'.' ) state = 8 ;
                else state = REJECT_STATE ;
            }
            break ;

/*
 *  Parse first field 'C'.
 */
            case 8:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 9 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 9:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 10 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 10:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumC = datumC * 10 + ( token - 48 ) ;
                    state = 11 ;
                }
                else if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 11:
            {
                if ( token == L'.' ) state = 12 ;
                else state = REJECT_STATE ;
            }
            break ;
 
/*
 *  Parse first field 'D'.
 */
            case 12:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 13 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 13:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 14 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 14:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    datumD = datumD * 10 + ( token - 48 ) ;
                    state = 15 ;
                }
                else if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;
 
            case 15:
            {
                if ( token == L'/' ) state = 16 ;
                else state = REJECT_STATE ;
            }
            break ;

            case 16:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    state = 17 ;
                    positiveDatum = ( token - 48 ) ;
                }
                else state = REJECT_STATE ;
            }   
            break ;

            case 17:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {   
                    state = 17 ;

                    if ( positiveDatum > 65535 ) state = REJECT_STATE ;
    
                    positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
                }
                else if ( token == 0 )
                {
                    state = ACCEPT_STATE ;
                }
                else state = REJECT_STATE ;
            }   
            break ;
 
            default:
            {
                state = REJECT_STATE ;
            }
            break ;
        }
    }


/*
 *  Check boundaries for IP fields.
 */

    status = ( state != REJECT_STATE ) ;

    if ( state == ACCEPT_STATE )
    {
        status = status && ( ( datumA < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumB < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumC < 256 ) ? TRUE : FALSE ) ;
        status = status && ( ( datumD < 256 ) ? TRUE : FALSE ) ;
    }

    udpAddress [ 0 ] = ( UCHAR ) datumA ;
    udpAddress [ 1 ] = ( UCHAR ) datumB ;
    udpAddress [ 2 ] = ( UCHAR ) datumC ;
    udpAddress [ 3 ] = ( UCHAR ) datumD ;

    USHORT *portPtr = ( USHORT * ) & udpAddress [ 4 ] ;
    *portPtr = htons ( ( USHORT ) positiveDatum ) ;

    octetString.SetValue ( udpAddress , 6 ) ;

    return status ; 
}

SnmpUDPAddressType :: SnmpUDPAddressType ( const UCHAR *value ) : SnmpFixedLengthOctetStringType ( 6 , value ) 
{
}

SnmpUDPAddressType :: SnmpUDPAddressType () : SnmpFixedLengthOctetStringType ( 6 ) 
{
}

SnmpUDPAddressType :: ~SnmpUDPAddressType () 
{
}

wchar_t *SnmpUDPAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        UCHAR *value = octetString.GetValue () ;
        ULONG valueLength = octetString.GetValueLength () ;
        if ( valueLength != 6 )
            throw ;

        char ipxAddress [ 40 ] ;
        ostrstream oStrStream ( ipxAddress , 40 ) ;

        oStrStream << ( ( ULONG ) value [ 0 ] ) ;
        oStrStream << "." ;
        oStrStream << ( ( ULONG ) value [ 1 ] ) ;
        oStrStream << "." ;
        oStrStream << ( ( ULONG ) value [ 2 ] ) ;
        oStrStream << "." ;
        oStrStream << ( ( ULONG ) value [ 3 ] ) ;

        oStrStream << "/" ;
    
        ULONG portNumber =  ntohs ( * ( ( USHORT * ) & value [ 4 ] ) ) ;

        oStrStream << portNumber ;

        oStrStream << ends ;

        returnValue = DbcsToUnicodeString ( ipxAddress ) ;

    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}

SnmpIPXAddressType :: SnmpIPXAddressType ( const SnmpOctetString &ipxAddressArg ) : SnmpFixedLengthOctetStringType ( 12 , ipxAddressArg ) 
{
}

SnmpIPXAddressType :: SnmpIPXAddressType ( const SnmpIPXAddressType &ipxAddressArg ) : SnmpFixedLengthOctetStringType ( ipxAddressArg ) 
{
}

SnmpInstanceType *SnmpIPXAddressType :: Copy () const 
{
    return new SnmpIPXAddressType ( *this ) ;
}

SnmpIPXAddressType :: SnmpIPXAddressType ( const wchar_t *ipxAddressArg ) : SnmpFixedLengthOctetStringType ( 12 )  
{
    SnmpInstanceType :: SetStatus ( Parse ( ipxAddressArg ) ) ;
    SnmpInstanceType :: SetNull ( FALSE ) ;
}

BOOL SnmpIPXAddressType :: Parse ( const wchar_t *ipxAddressArg ) 
{
    BOOL status = TRUE ;

    ULONG state = 0 ;

    UCHAR ipxAddress [ 12 ] ;

/*
          SnmpIPXAddress ::= TEXTUAL-CONVENTION
              DISPLAY-HINT "4x.1x:1x:1x:1x:1x:1x.2d"
              STATUS       current
              DESCRIPTION
                      "Represents an IPX address."
              SYNTAX       OCTET STRING (SIZE (12))
 */

/* 
 * IPXAddress Definitions
 */

    ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
    ULONG positiveMagicPosDigit = 5 ;
    ULONG positiveDatum = 0 ;   

    ULONG length = 0 ;
    ULONG byte = 0 ;    
    ULONG position = 0 ;

#define NETWORK_HEX_INTEGER_START 0
#define STATION_HEX_INTEGER_START 100
#define PORT_DEC_INTEGER_START 200

    while ( state != REJECT_STATE && state != ACCEPT_STATE )
    {
        wchar_t token = ipxAddressArg [ position ++ ] ;
        switch ( state )
        {
            case NETWORK_HEX_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = NETWORK_HEX_INTEGER_START + 1 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case NETWORK_HEX_INTEGER_START+1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    ipxAddress [ length ] = ( UCHAR ) byte ;
                    state = NETWORK_HEX_INTEGER_START + 2 ;
                    length ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case NETWORK_HEX_INTEGER_START+2:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = NETWORK_HEX_INTEGER_START + 1 ;
                }
                else
                {
                    if ( token == L'.' ) 
                    {
                        if ( length ==4 )
                        {
                            state = STATION_HEX_INTEGER_START ;
                        }
                        else
                            state = REJECT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
            }
            break ;

            case STATION_HEX_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    state = STATION_HEX_INTEGER_START + 1 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case STATION_HEX_INTEGER_START + 1:
            {
                if ( SnmpAnalyser :: IsHex ( token ) )
                {
                    byte = ( byte << 4 ) + SnmpAnalyser :: HexWCharToDecInteger ( token ) ;
                    ipxAddress [ length ] = ( UCHAR ) byte ;
                    state = STATION_HEX_INTEGER_START + 2 ;
                    length ++ ;
                    byte = 0 ;
                }
                else state = REJECT_STATE ;
            }
            break ;

            case STATION_HEX_INTEGER_START + 2 :
            {
                if ( token == L':' )
                {
                    state = STATION_HEX_INTEGER_START ;
                }
                else 
                {
                    if ( token == L'.' )
                    {
                        if ( length == 10 ) 
                        {
                            state = PORT_DEC_INTEGER_START ;
                        }
                        else state = REJECT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
            }
            break ;

            case PORT_DEC_INTEGER_START:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {
                    state = PORT_DEC_INTEGER_START + 1 ;
                    positiveDatum = ( token - 48 ) ;
                }
                else state = REJECT_STATE ;
            }   
            break ;

            case PORT_DEC_INTEGER_START+1:
            {
                if ( SnmpAnalyser :: IsDecimal ( token ) )
                {   
                    state = PORT_DEC_INTEGER_START + 1 ;

                    if ( positiveDatum > 65535 ) state = REJECT_STATE ;
    
                    positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
                }
                else 
                {
                    if ( token == 0 )
                    {
                        USHORT *portPtr = ( USHORT * ) & ipxAddress [ 10 ] ;
                        *portPtr = htons ( ( USHORT ) positiveDatum ) ;

                        state = ACCEPT_STATE ;
                    }
                    else state = REJECT_STATE ;
                }
            }   
            break ;

            default:
            {
                state = REJECT_STATE ; 
            }
            break ;
        }
    }

    status = ( state != REJECT_STATE ) ;

    if ( status )
    {
        octetString.SetValue ( ipxAddress , 12 ) ;
    }

    return status ;
}

SnmpIPXAddressType :: SnmpIPXAddressType ( const UCHAR *value ) : SnmpFixedLengthOctetStringType ( 12 , value ) 
{
}

SnmpIPXAddressType :: SnmpIPXAddressType () : SnmpFixedLengthOctetStringType ( 12 ) 
{
}

SnmpIPXAddressType :: ~SnmpIPXAddressType () 
{
}

wchar_t *SnmpIPXAddressType :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( SnmpInstanceType :: IsValid () )
    {
        UCHAR *value = octetString.GetValue () ;
        ULONG valueLength = octetString.GetValueLength () ;
        if ( valueLength != 12 )
            throw ;

        char ipxAddress [ 80 ] ;
        ostrstream oStrStream ( ipxAddress , 80) ;

        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 0 ] >> 4 ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 0 ] & 0xf ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 1 ] >> 4 ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 1 ] & 0xf ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 2 ] >> 4 ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 2 ] & 0xf ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 3 ] >> 4 ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 3 ] & 0xf ) ;

        oStrStream << "." ;
    
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 4 ] >> 4 ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 4 ] & 0xf ) ;
        oStrStream << ":" ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 5 ] >> 4 ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 5 ] & 0xf ) ;
        oStrStream << ":" ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 6 ] >> 4 ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 6 ] & 0xf ) ;
        oStrStream << ":" ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 7 ] >> 4 ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 7 ] & 0xf ) ;
        oStrStream << ":" ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 8 ] >> 4 ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 8 ] & 0xf ) ;
        oStrStream << ":" ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 9 ] >> 4 ) ;
        oStrStream << SnmpAnalyser :: DecIntegerToHexChar ( value [ 9 ] & 0xf ) ;

        oStrStream << "." ;

        ULONG portNumber =  ntohs ( * ( ( USHORT * ) & value [ 10 ] ) ) ;

        oStrStream << portNumber ;

        oStrStream << ends ;

        returnValue = DbcsToUnicodeString ( ipxAddress ) ;
    }
    else
    {
        returnValue = SnmpOctetStringType :: GetStringValue () ;
    }

    return returnValue ;
}


SnmpUInteger32Type :: SnmpUInteger32Type ( 

    const SnmpUInteger32 &ui_integerArg ,
    const wchar_t *rangeValues
    
) : SnmpPositiveRangedType ( rangeValues ) , ui_integer32 ( ui_integerArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( ui_integer32.GetValue () ) ) ;
    }
}

SnmpUInteger32Type :: SnmpUInteger32Type ( 

    const SnmpUInteger32Type &ui_integerArg 

) :  SnmpInstanceType ( ui_integerArg ) , SnmpPositiveRangedType ( ui_integerArg ) , ui_integer32 ( ui_integerArg.ui_integer32 ) 
{
}

SnmpUInteger32Type :: SnmpUInteger32Type ( 

    const wchar_t *ui_integerArg ,
    const wchar_t *rangeValues

) : SnmpInstanceType ( FALSE ) , SnmpPositiveRangedType ( rangeValues ) , ui_integer32 ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( Parse ( ui_integerArg ) && SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( ui_integer32.GetValue () ) ) ;
    }
}

SnmpUInteger32Type :: SnmpUInteger32Type ( 

    const ULONG ui_integerArg ,
    const wchar_t *rangeValues

) : SnmpPositiveRangedType ( rangeValues ) , ui_integer32 ( ui_integerArg ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
    if ( SnmpInstanceType :: IsValid () )
    {
        SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: Check ( ui_integer32.GetValue () ) ) ;
    }
}

SnmpUInteger32Type :: SnmpUInteger32Type ( const wchar_t *rangeValues ) : SnmpPositiveRangedType ( rangeValues ) , 
                                                                SnmpInstanceType ( TRUE , TRUE ) , 
                                                                ui_integer32 ( 0 ) 
{
    SnmpInstanceType :: SetStatus ( SnmpPositiveRangedType :: IsValid () ) ;
}

SnmpUInteger32Type :: ~SnmpUInteger32Type () 
{
}

BOOL SnmpUInteger32Type :: Equivalent (IN const SnmpInstanceType &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = ui_integer32.GetValue() == ((const SnmpUInteger32Type&)value).ui_integer32.GetValue();
    }

    return bResult;
}

SnmpInstanceType *SnmpUInteger32Type :: Copy () const 
{
    return new SnmpUInteger32Type ( *this ) ;
}

BOOL SnmpUInteger32Type :: Parse ( const wchar_t *ui_integerArg ) 
{
    BOOL status = TRUE ;

    SnmpAnalyser analyser ;

    analyser.Set ( ui_integerArg ) ;

    SnmpLexicon *lookAhead = analyser.Get () ;
    switch ( lookAhead->GetToken () ) 
    {
        case SnmpLexicon :: UNSIGNED_INTEGER_ID:
        {
            ui_integer32.SetValue ( lookAhead->GetValue ()->unsignedInteger ) ;
        }
        break ;

        default:
        {
            status = FALSE ;
        }
        break ;
    }

    delete lookAhead ;

    return status ;
}

SnmpObjectIdentifier SnmpUInteger32Type :: Encode ( const SnmpObjectIdentifier &objectIdentifier ) const
{
    ULONG ui_integer32Value = ui_integer32.GetValue () ;  
    SnmpObjectIdentifier returnValue = objectIdentifier + SnmpObjectIdentifier ( & ui_integer32Value , 1 );
    return returnValue ;
}

SnmpObjectIdentifier SnmpUInteger32Type :: Decode ( const SnmpObjectIdentifier &objectIdentifier ) 
{
    if ( objectIdentifier.GetValueLength () >= 1 )
    {
        ui_integer32.SetValue ( objectIdentifier [ 0 ] ) ;
        SnmpInstanceType :: SetNull ( FALSE ) ;
        SnmpInstanceType :: SetStatus ( TRUE ) ;

        SnmpObjectIdentifier returnValue ( NULL , 0 ) ;
        BOOL t_Status = objectIdentifier.Suffix ( 1 , returnValue ) ;
        if ( t_Status ) 
        {
            return returnValue ;
        }
        else
        {
            return SnmpObjectIdentifier ( NULL , 0 ) ;
        }

    }
    else
    {
        SnmpInstanceType :: SetStatus ( FALSE ) ;
        return objectIdentifier ;
    }
}

const SnmpValue *SnmpUInteger32Type :: GetValueEncoding () const
{
    return SnmpInstanceType :: IsValid () ? & ui_integer32 : NULL ;
}

wchar_t *SnmpUInteger32Type :: GetStringValue () const 
{
    wchar_t *returnValue = NULL ;

    if ( ! SnmpInstanceType :: IsNull ()  )
    {
        wchar_t stringValue [ 40 ] ;
        _ultow ( ui_integer32.GetValue () , stringValue , 10 );
        returnValue = new wchar_t [ wcslen ( stringValue ) + 1 ] ;
        wcscpy ( returnValue , stringValue ) ;
    }
    else 
    {
        ULONG returnValueLength = wcslen ( L"" ) + 1 ;
        returnValue = new wchar_t [ returnValueLength ] ;
        wcscpy ( returnValue , L"" ) ;
    }

    return returnValue ;
}

ULONG SnmpUInteger32Type :: GetValue () const
{
    return ui_integer32.GetValue () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\sec.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: sec.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "encdec.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "value.h"
#include "ssess.h"

const char *SnmpCommunityBasedSecurity::GetCommunityName() const
{
    return community_name;
}

void SnmpCommunityBasedSecurity::Initialize()
{
    is_valid = TRUE;
}


SnmpCommunityBasedSecurity::SnmpCommunityBasedSecurity(IN const SnmpCommunityBasedSecurity &security) : community_name ( NULL ) 
{
   const char *new_community_name = security.GetCommunityName();
   community_name = new char[strlen(new_community_name)+1];
   strcpy(community_name, new_community_name);

   Initialize();
}


SnmpCommunityBasedSecurity::SnmpCommunityBasedSecurity(IN const char *communityName) : community_name ( NULL) 
{
   community_name = new char[strlen(communityName)+1];
   strcpy(community_name, communityName);

   Initialize();
}

SnmpCommunityBasedSecurity::SnmpCommunityBasedSecurity(IN const SnmpOctetString &octetString) : community_name ( NULL ) 
{
    int length = octetString.GetValueLength();
    community_name = new char[length+1];

    strncpy(community_name, (char *)octetString.GetValue(), length);
    community_name[length] = EOS;

    Initialize();
}


SnmpCommunityBasedSecurity::~SnmpCommunityBasedSecurity()
{
    delete [] community_name;
}

SnmpErrorReport SnmpCommunityBasedSecurity::Secure (
                        
    IN SnmpEncodeDecode &a_SnmpEncodeDecode,
    IN OUT SnmpPdu &snmpPdu
) 
{
    SnmpCommunityBasedSecurity *t_Community = (SnmpCommunityBasedSecurity *)(this->Copy());
    if ( a_SnmpEncodeDecode.SetCommunityName (snmpPdu, *t_Community) == FALSE )
        return SnmpErrorReport(Snmp_Transport, Snmp_Local_Error);
    else
        return SnmpErrorReport(Snmp_Success, Snmp_No_Error);
}


SnmpSecurity *SnmpCommunityBasedSecurity::Copy() const
{
    return new SnmpCommunityBasedSecurity(community_name);
}

void SnmpCommunityBasedSecurity::SetCommunityName ( IN const SnmpOctetString &a_OctetString )
{
    delete [] community_name ;
    community_name = NULL;
    community_name = new char [ a_OctetString.GetValueLength () + 1 ] ;
    strncpy ( community_name , ( char * ) a_OctetString.GetValue () , a_OctetString.GetValueLength () ) ;
    community_name [ a_OctetString.GetValueLength () ] = 0 ;
}

void SnmpCommunityBasedSecurity:: SetCommunityName ( IN const char *a_CommunityName )
{
    delete [] community_name ;
    community_name = NULL;
    community_name = new char [ strlen ( a_CommunityName ) + 1 ] ;
    strcpy ( community_name , a_CommunityName ) ;
}

void SnmpCommunityBasedSecurity:: GetCommunityName ( SnmpOctetString &a_SnmpOctetString ) const 
{
    a_SnmpOctetString.SetValue ( ( UCHAR * ) community_name , strlen ( community_name ) ) ;
}

SnmpCommunityBasedSecurity &SnmpCommunityBasedSecurity :: operator=(IN const SnmpCommunityBasedSecurity &to_copy) 
{
    delete [] community_name ;
    community_name = NULL;
    community_name = new char [ strlen ( to_copy.community_name ) + 1 ] ;
    strcpy ( community_name , to_copy.community_name ) ;
    return *this ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\snmpauto.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <typeinfo.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>

#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey <SnmpObjectIdentifierType&> (SnmpObjectIdentifierType &key)
#else
UINT HashKey (SnmpObjectIdentifierType &key)
#endif
{
    SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) key.GetValueEncoding () ;
    UCHAR *value = ( UCHAR * ) objectIdentifier->GetValue () ;
    ULONG length = objectIdentifier->GetValueLength () * sizeof ( ULONG ) ;

#if 1
    ULONG t_Length = length >> 2 ;
    value += t_Length ;
    length = length - t_Length ;
#endif

    UINT hash;
    if (length > 1)
    {
        USHORT even = 0;
        USHORT odd = 0;
#if 0
        for (ULONG i = length >> 1; i--;)
        {
            even += *value++;
            odd += *value++;
        }
        if (length & 1)
        {
            even += *value;
        }
#else
        for (ULONG i = length >> 2; i--;)
        {
            even += *value++;
            even += *value++;
            even += *value++;
            odd += *value++;
        }
        if (length & 1)
        {
            even += *value;
        }
#endif
        hash = odd>>8;
        hash |= (odd & 0xff) << 8;
        hash ^= even;
    }
    else
    {
        hash = *value;
    }

    return hash ;
}

#if _MSC_VER >= 1100
template<> BOOL AFXAPI CompareElements <SnmpObjectIdentifierType , SnmpObjectIdentifierType >( 

     const SnmpObjectIdentifierType* pElement1, 
     const SnmpObjectIdentifierType* pElement2 
)
#else
BOOL CompareElements ( 

     SnmpObjectIdentifierType* pElement1, 
     SnmpObjectIdentifierType* pElement2 
)

#endif
{
    return *( ( SnmpObjectIdentifier * ) pElement1->GetValueEncoding () ) == *( ( SnmpObjectIdentifier * )pElement2->GetValueEncoding () ) ;
}

VarBindObject :: VarBindObject ( 

    const SnmpObjectIdentifier &replyArg , 
    const SnmpValue &valueArg 

) : value ( NULL ) , 
    reply ( replyArg ) 
{
    value = valueArg.Copy () ;
}

VarBindObject :: ~VarBindObject ()
{
    delete value ;
}

SnmpObjectIdentifier &VarBindObject :: GetObjectIdentifier () 
{
    return reply ;
}

SnmpValue &VarBindObject :: GetValue () 
{
    return *value ;
}


VarBindQueue :: VarBindQueue ()
{
}

VarBindQueue :: ~VarBindQueue ()
{
    POSITION position = queue.GetHeadPosition () ;
    while ( position )
    {
        VarBindObject *varBindObject = queue.GetNext ( position ) ;
        delete varBindObject ;
    }

    queue.RemoveAll () ;
}

void VarBindQueue :: Add ( VarBindObject *varBindObject )
{
    queue.AddTail ( varBindObject ) ;
}

VarBindObject *VarBindQueue :: Get () 
{
    return queue.IsEmpty () ? NULL : queue.GetHead ()  ;
}

VarBindObject *VarBindQueue :: Delete () 
{
    VarBindObject *object = NULL ;

    if ( ! queue.IsEmpty () )
    {
        object = queue.GetHead ()  ;
        queue.RemoveHead () ;
    }
    
    return object ;
}

VarBindObjectRequest :: VarBindObjectRequest ( 

    const SnmpObjectIdentifierType &varBindArg 

) : varBind ( varBindArg ) , requested ( varBindArg ) , repeatRequest ( TRUE ) 
{
}

VarBindObjectRequest :: VarBindObjectRequest ( 

    const SnmpObjectIdentifierType &varBindArg ,
    const SnmpObjectIdentifierType &requestedVarBindArg 

) : varBind ( varBindArg ) , requested ( requestedVarBindArg ) , repeatRequest ( TRUE ) 
{
}

VarBindObjectRequest :: VarBindObjectRequest () : repeatRequest ( TRUE )
{
}

VarBindObjectRequest :: ~VarBindObjectRequest () 
{
}

const SnmpObjectIdentifierType &VarBindObjectRequest :: GetRequested () const 
{
    return requested ;
}

const SnmpObjectIdentifierType &VarBindObjectRequest :: GetVarBind () const 
{
    return varBind ;
}

void VarBindObjectRequest :: SetRequested ( const SnmpObjectIdentifierType &requestedArg ) 
{
    requested = requestedArg ;
}

void VarBindObjectRequest :: SetVarBind ( const SnmpObjectIdentifierType &varBindArg ) 
{
    varBind = varBindArg ;
}

void VarBindObjectRequest :: AddQueuedObject ( VarBindObject *object ) 
{
    varBindResponseQueue.Add ( object ) ;
}

VarBindObject *VarBindObjectRequest :: GetQueuedObject () 
{
    return varBindResponseQueue.Get () ;
}

VarBindObject *VarBindObjectRequest :: DeleteQueueudObject () 
{
    return varBindResponseQueue.Delete () ;
}

GetNextOperation :: GetNextOperation (

    IN SnmpSession &session ,
    SnmpAutoRetrieveOperation &autoRetrieveOperation 

) : SnmpGetNextOperation ( session ) , 
    operation ( NULL ) ,
    minimumInstance ( NULL , 0 ) ,
    cancelledRequest ( FALSE ) ,
    m_RequestContainerLength ( 0 ) ,
    m_RequestContainer ( NULL ) ,
    m_RequestIndexContainer ( NULL )
{
    operation = &autoRetrieveOperation ;
}

GetNextOperation :: ~GetNextOperation ()
{
    Cleanup () ;

    delete [] m_RequestContainer ;
    delete [] m_RequestIndexContainer ;
    delete operation ;
}

void GetNextOperation :: Cleanup ()
{
    if ( m_RequestContainer )
    {
        for ( ULONG t_Index = 0 ; t_Index < m_RequestContainerLength ; t_Index ++ )
        {
            VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;
            m_RequestContainer [ t_Index ] = NULL ; 
            delete varBindObjectRequest ;
        }
    }
}
void GetNextOperation :: SendRequest ( 

    SnmpVarBindList &varBindList 
)
{
    cancelledRequest = FALSE ;

    ULONG t_Count = varBindList.GetLength () ;

    m_RequestContainerLength = t_Count ;

    m_RequestContainer = new VarBindObjectRequest * [ t_Count ] ;
    m_RequestIndexContainer = new ULONG [ t_Count ] ;

    ULONG t_Index = 0 ;
    varBindList.Reset () ;
    while ( varBindList.Next () )
    {
        const SnmpVarBind *varBind = varBindList.Get () ;
        SnmpObjectIdentifierType requestObject ( varBind->GetInstance () ) ;
        VarBindObjectRequest *request = new VarBindObjectRequest ( requestObject ) ;
        m_RequestContainer  [ t_Index ] = request ;

        t_Index ++ ;
    }

    Send () ;
}

void GetNextOperation :: SendRequest ( 

    SnmpVarBindList &varBindList , 
    SnmpVarBindList &startVarBindList 
)
{
    cancelledRequest = FALSE ;

    ULONG t_Count = varBindList.GetLength () ;

    m_RequestContainerLength = t_Count ;

    m_RequestContainer = new VarBindObjectRequest * [ t_Count ] ;
    m_RequestIndexContainer = new ULONG [ t_Count ] ;

    ULONG t_Index = 0 ;
    varBindList.Reset () ;
    startVarBindList.Reset () ;
    while ( startVarBindList.Next () && varBindList.Next () )
    {
        const SnmpVarBind *varBind = varBindList.Get () ;
        const SnmpVarBind *startVarBind = startVarBindList.Get () ;
        SnmpObjectIdentifierType requestObject ( varBind->GetInstance () ) ;
        SnmpObjectIdentifierType startRequestObject ( startVarBind->GetInstance () ) ;
        VarBindObjectRequest *request = new VarBindObjectRequest ( requestObject , startRequestObject ) ;
        m_RequestContainer  [ t_Index ] = request ;

        t_Index ++ ;
    }

    Send () ;
}

void GetNextOperation :: DestroyOperation ()
{
    SnmpGetNextOperation :: DestroyOperation () ;
}

void GetNextOperation :: CancelRequest ()
{
    cancelledRequest = TRUE ;
    SnmpGetNextOperation :: CancelRequest () ;
}

void GetNextOperation :: Send ()
{
    BOOL t_Count = 0 ;
    SnmpVarBindList sendVarBindList ;
    for ( ULONG t_Index = 0 ; t_Index < m_RequestContainerLength ; t_Index ++ )
    {
        SnmpObjectIdentifierType objectIdentifierType ;
        VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;

        if ( varBindObjectRequest->GetRepeatRequest () )
        {
            SnmpNull snmpNull ;
            SnmpVarBind varBind ( 

                * ( SnmpObjectIdentifier * ) varBindObjectRequest->GetRequested ().GetValueEncoding () ,
                snmpNull 
            ) ;

            sendVarBindList.Add ( varBind ) ;

            m_RequestIndexContainer [ t_Count ] = t_Index ;
            t_Count ++ ;
        }
    }

    SnmpGetNextOperation :: SendRequest ( sendVarBindList ) ;
}

void GetNextOperation :: SentFrame (

    IN const SessionFrameId session_frame_id ,
    const SnmpErrorReport &errorReport 
) 
{
    switch ( errorReport.GetError () )
    {
        case Snmp_Success:
        {
        }
        break ;

        default:
        {
        }
        break ;
    }

    operation->SentFrame ( session_frame_id , errorReport ) ;
    SnmpGetNextOperation :: SentFrame ( session_frame_id , errorReport ) ;
}

void GetNextOperation :: ReceiveResponse () 
{
    BOOL receiveComplete = TRUE ;

    for ( ULONG t_Index = 0 ; t_Index < m_RequestContainerLength ; t_Index ++ )
    {
        VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;
        if ( varBindObjectRequest->GetRepeatRequest () )
        {
            receiveComplete = FALSE ;
        }
    }

    if ( ! cancelledRequest )
    {
// Check to see if we have finished

        if ( ! receiveComplete )
        {
// Request next response

            Send () ;
        }

// Process received information

        while ( ProcessRow () ) ;
    }

    if ( receiveComplete )
    {
// We've finished

        operation->ReceiveResponse () ;

// Clear all resources

        Cleanup () ;
    }
}

BOOL GetNextOperation :: ProcessRow ()
{
// Process Row information


    BOOL initialised = FALSE ;
    BOOL objectHasNoValueAndIsRepeating = FALSE ;
    SnmpObjectIdentifier objectIdentifier ( NULL , 0 ) ;
    SnmpObjectIdentifier suffix ( NULL , 0 ) ;

// Determine minimum instance

    for ( ULONG t_Index = 0 ; t_Index < m_RequestContainerLength ; t_Index ++ )
    {
        VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;
        VarBindObject *queuedObject = varBindObjectRequest->GetQueuedObject () ;
        if ( queuedObject )
        {
// Get row information associated with table property, i.e. instance of initial varbind requested.

            SnmpObjectIdentifierType varBindType = varBindObjectRequest->GetVarBind () ;
            SnmpObjectIdentifier *varBind = ( SnmpObjectIdentifier * ) varBindType.GetValueEncoding () ;
            if(varBind)
            {
                BOOL t_Status = queuedObject->GetObjectIdentifier ().Suffix ( varBind->GetValueLength () , suffix ) ;
                if ( t_Status )
                {
                    if ( initialised )
                    {
                        if ( suffix < objectIdentifier ) 
                        {
// Least instance so far

                            objectIdentifier = suffix ;
                        }
                        else
                        {
// Greater Than
                        }
                    }
                    else
                    {

// objectIdentifier hasn't been set to a legal instance yet.

                        objectIdentifier = suffix ;
                        initialised = TRUE ;
                    }       
                }
                else
                {
// No more rows as yet
                }
            }
        }
        else
        {
            if ( varBindObjectRequest->GetRepeatRequest () )
            {
                objectHasNoValueAndIsRepeating = TRUE ;
            }
        }
    }

    if ( initialised && ( ! objectHasNoValueAndIsRepeating ) )
    {
        minimumInstance = objectIdentifier ;

// Process all columns which contain row of least minimum

        for ( ULONG t_Index = 0 ; t_Index < m_RequestContainerLength ; t_Index ++ )
        {
            VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;
            VarBindObject *queuedObject = varBindObjectRequest->GetQueuedObject () ;
            if ( queuedObject )
            {
                SnmpObjectIdentifierType varBindType = varBindObjectRequest->GetVarBind () ;
                SnmpObjectIdentifier *varBind = ( SnmpObjectIdentifier * ) varBindType.GetValueEncoding () ;

                if ( varBind && queuedObject->GetObjectIdentifier ().Suffix ( varBind->GetValueLength () , suffix ) )
                {
                    if ( suffix == minimumInstance ) 
                    {
// Row to be processed

                        SnmpNull snmpNull ;
                        SnmpErrorReport errorReport ( Snmp_Success , Snmp_No_Error )  ;
                        SnmpVarBind requestVarBind ( *varBind , snmpNull ) ;
                        SnmpVarBind replyVarBind ( minimumInstance , queuedObject->GetValue () ) ;
                
                        operation->ReceiveRowVarBindResponse ( t_Index + 1 , requestVarBind , replyVarBind , errorReport ) ;

// Check CancelRequest hasn't been called in callback

                        if ( cancelledRequest )
                        {
                            return FALSE ;
                        }

// Remove row 
                        VarBindObject *queuedObject = varBindObjectRequest->DeleteQueueudObject () ;
                        delete queuedObject ;
                    }
                    else
                    {
// Row is lexicographically greater than process row
                    }
                }
                else
                {
// Problem Here
                }
            }
        }

// Forward call to AutoRetrieveOperation
    
        operation->ReceiveRowResponse () ;
    }
    else
    {
// Zero rows to process
    }

    return initialised && ( ! objectHasNoValueAndIsRepeating ) ;
}

void GetNextOperation :: ReceiveVarBindResponse (

    IN const ULONG &var_bind_index,
    IN const SnmpVarBind &requestVarBind ,
    IN const SnmpVarBind &replyVarBind ,
    IN const SnmpErrorReport &error
) 
{
    ULONG t_Index = m_RequestIndexContainer [ var_bind_index - 1 ] ;
    VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;
/*
 * check for v2c errored responses
 */

    if ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpEndOfMibView ) ) 
    {
// Stop further requests for this column

        varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
    }
    else
    {
    // Locate request object

// Check we haven't gone backwards lexicographically, which would result in an infinitely repeating request.

        if ( replyVarBind.GetInstance () > requestVarBind.GetInstance () )
        {
// Check we haven't reached end of table

            SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier *) varBindObjectRequest->GetVarBind ().GetValueEncoding () ;
            if ( objectIdentifier && replyVarBind.GetInstance().Equivalent ( *objectIdentifier , objectIdentifier->GetValueLength () ) )  
            {
// Add row information to column of table

                SnmpObjectIdentifier snmpObjectIdentifier ( 0 , NULL ) ;
                SnmpObjectIdentifier suffix ( 0 , NULL ) ;
                SnmpNull snmpNull ;

                BOOL t_Status = replyVarBind.GetInstance().Suffix ( objectIdentifier->GetValueLength () , suffix ) ;
                if ( t_Status )
                {
                    SnmpVarBind sendVarBind ( snmpObjectIdentifier , snmpNull ) ;
                    SnmpVarBind adjustedReplyVarBind ( suffix , replyVarBind.GetValue () ) ;

                    LONG t_Option = operation->EvaluateNextRequest (

                        var_bind_index,
                        requestVarBind ,
                        adjustedReplyVarBind ,
                        sendVarBind
                    ) ;

                    if ( t_Option == 0 )
                    {
                        VarBindObject *varBindObject = new VarBindObject ( replyVarBind.GetInstance () , replyVarBind.GetValue () ) ;
                        varBindObjectRequest->AddQueuedObject ( varBindObject ) ;

    // Update map to identify request next time around

                        SnmpObjectIdentifierType replyObject ( replyVarBind.GetInstance () ) ;
                        varBindObjectRequest->SetRequested ( replyObject ) ;
                    }
                    else if ( t_Option > 0 )
                    {
                        VarBindObject *varBindObject = new VarBindObject ( replyVarBind.GetInstance () , replyVarBind.GetValue () ) ;
                        varBindObjectRequest->AddQueuedObject ( varBindObject ) ;

    // Update map to identify request next time around

                        SnmpObjectIdentifierType replyObject ( *objectIdentifier + sendVarBind.GetInstance () ) ;
                        varBindObjectRequest->SetRequested ( replyObject ) ;

                    }
                    else 
                    {
                        VarBindObject *varBindObject = new VarBindObject ( replyVarBind.GetInstance () , replyVarBind.GetValue () ) ;
                        varBindObjectRequest->AddQueuedObject ( varBindObject ) ;

                        varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
                    }
                }
                else 
                {
                    varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
                }
            }
            else
            {
// instance received is not row of column, i.e End Of Table

                varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
            }
        }
        else
        {
// instance requested is greater than instance replied

            varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
        }
    }

    operation->ReceiveVarBindResponse ( var_bind_index,requestVarBind , replyVarBind , error ) ;
}

void GetNextOperation :: ReceiveErroredVarBindResponse(

    IN const ULONG &var_bind_index,
    IN const SnmpVarBind &requestVarBind  ,
    IN const SnmpErrorReport &error
) 
{
    ULONG t_Index = m_RequestIndexContainer [ var_bind_index - 1 ] ;
    VarBindObjectRequest *varBindObjectRequest = m_RequestContainer [ t_Index ] ;

    switch ( error.GetError () )
    {
        case Snmp_Success:
        {
/* 
 * Can't happen
 */
        }
        break ;

        default:
        {
// Stop further requests for this column

            varBindObjectRequest->SetRepeatRequest ( FALSE ) ;
        }
        break ;
    }

    operation->ReceiveErroredVarBindResponse ( var_bind_index , requestVarBind , error ) ;
}

void GetNextOperation :: FrameTooBig () 
{
    operation->FrameTooBig () ;
}

void GetNextOperation :: FrameOverRun () 
{
    operation->FrameTooBig () ;
}

SnmpAutoRetrieveOperation :: SnmpAutoRetrieveOperation (IN SnmpSession &session) 
{
    operation = new GetNextOperation ( session , *this ) ;
}

SnmpAutoRetrieveOperation :: ~SnmpAutoRetrieveOperation ()
{
}

void SnmpAutoRetrieveOperation :: DestroyOperation ()
{
    operation->DestroyOperation () ;
}

void SnmpAutoRetrieveOperation :: CancelRequest () 
{
    operation->CancelRequest () ;
}

void SnmpAutoRetrieveOperation :: SendRequest ( SnmpVarBindList &varBindList )
{
    operation->SendRequest ( varBindList ) ;
}

void SnmpAutoRetrieveOperation :: SendRequest ( SnmpVarBindList &varBindList , SnmpVarBindList &startVarBindList )
{
    operation->SendRequest ( varBindList , startVarBindList ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\session.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: session.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "dummy.h"
#include "flow.h"
#include "reg.h"
#include "frame.h"
#include "timer.h"
#include "message.h"

#include "tsent.h"

#include "transp.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "pseudo.h"
#include "fs_reg.h"
#include "ophelp.h"
#include "op.h"
#include <winsock.h>
#include "trap.h"

SnmpSession::SnmpSession (
        IN SnmpTransport &transportProtocol,
        IN SnmpSecurity &security,
        IN SnmpEncodeDecode &a_SnmpEncodeDecode  ,
        IN const ULONG retryCount,
        IN const ULONG retryTimeout,
        IN const ULONG varbindsPerPdu,
        IN const ULONG flowControlWindow 
    )
{
    retry_count = retryCount;
    retry_timeout = retryTimeout;
    varbinds_per_pdu = varbindsPerPdu;
    flow_control_window = flowControlWindow;
}

#pragma warning (disable:4355)

SnmpImpSession::SnmpImpSession ( 
        IN SnmpTransport &transportProtocol,
        IN SnmpSecurity &security,
        IN SnmpEncodeDecode &a_SnmpEncodeDecode  ,
        IN const ULONG retryCount,
        IN const ULONG retryTimeout,
        IN const ULONG varbindsPerPdu,
        IN const ULONG flowControlWindow)
        : SnmpSession(transportProtocol, security, a_SnmpEncodeDecode,
                      RetryCount(retryCount),
                      RetryTimeout(retryTimeout),
                      VarbindsPerPdu(varbindsPerPdu),
                      WindowSize(flowControlWindow)),
          m_SessionWindow(*this),
          transport(transportProtocol), 
          security(security),
          m_EncodeDecode(a_SnmpEncodeDecode) ,
          flow_control(*this, SnmpImpSession :: WindowSize ( GetFlowControlWindow() ) ),
          message_registry(*this), 
          frame_registry(*this),
          timer(*this)
{
    is_valid = FALSE;

    if ( !transport() || !security() || !m_SessionWindow() )
        return;

    received_session_frame_id = ILLEGAL_SESSION_FRAME_ID;
    is_valid = TRUE;
    destroy_self = FALSE;

    strobe_count = 1 ;

    // generate timer_event_id and register with the timer
    timer_event_id = timer.SetTimerEvent(MIN(100,retry_timeout/10));

}

#pragma warning (default:4355)

ULONG SnmpImpSession::RetryCount(IN const ULONG retry_count) 
{
    return retry_count ;
}


ULONG SnmpImpSession::RetryTimeout(IN const ULONG retry_timeout) 
{
    return ( (retry_timeout==0)? 
             DEF_RETRY_TIMEOUT: retry_timeout);
}


ULONG SnmpImpSession::VarbindsPerPdu(IN const ULONG varbinds_per_pdu) 
{
    return ( (varbinds_per_pdu==0)? 
             DEF_VARBINDS_PER_PDU: varbinds_per_pdu);
}


ULONG SnmpImpSession::WindowSize(IN const ULONG window_size) 
{
    return ( (window_size==0)? DEF_WINDOW_SIZE: window_size);
}


void SnmpImpSession::RegisterOperation(IN SnmpOperation &operation)
{
    CriticalSectionLock access_lock(session_CriticalSection);

    if ( !access_lock.GetLock(INFINITE) )
        return;

    operation_registry.Register(operation);

    // access_lock.UnLock();   The lock may be released at this point
}

// updates the number of operations currently registered
// when the count goes to 0 and the destroy_self flag is set,
// it posts the WinSnmpSession :: g_DeleteSessionEvent message.
void SnmpImpSession::DeregisterOperation(IN SnmpOperation &operation)
{
    CriticalSectionLock access_lock(session_CriticalSection);

    if ( !access_lock.GetLock(INFINITE) )
        return;

    operation_registry.Deregister(operation);

    if ( (destroy_self == TRUE) &&
         (operation_registry.GetNumRegistered() == 0) )
        m_SessionWindow.PostMessage(Window :: g_DeleteSessionEvent, 0, 0);

    // access_lock.UnLock();   The lock may be released at this point
}


// when the WinSnmpSession :: g_DeleteSessionEvent is received, the session deletes itself
// no locks are obtained since our assumption is that no other objects would be
// accessing the session at this time
void SnmpImpSession::HandleDeletionEvent()
{
    delete this;
}

// the session posts a message to destroy self if the number of registered
// sessions is 0. otherwise the session is flagged for the same action when
// the number of registered operations drops to 0.
BOOL SnmpImpSession::DestroySession()
{
    CriticalSectionLock access_lock(session_CriticalSection);

    if ( !access_lock.GetLock(INFINITE) )
        return FALSE;

    if ( operation_registry.GetNumRegistered() == 0 )
    {
        m_SessionWindow.PostMessage(Window :: g_DeleteSessionEvent, 0, 0);
        return TRUE;
    }
    else
        destroy_self = TRUE;    // flag self for destruction

    access_lock.UnLock();

    return FALSE;
}

    
void SnmpImpSession::SessionSendFrame
(  
    IN SnmpOperation &operation,
    OUT SessionFrameId &session_frame_id,
    IN SnmpPdu &snmpPdu
)
{
    SessionSendFrame(operation, session_frame_id, snmpPdu, security);
}


void SnmpImpSession::SessionSendFrame
(  
    IN SnmpOperation &operation,
    OUT SessionFrameId &session_frame_id,
    IN SnmpPdu &snmpPdu,
    IN SnmpSecurity &snmp_security
)
{
    try
    {
        CriticalSectionLock access_lock(session_CriticalSection);

        if ( !access_lock.GetLock(INFINITE) )
            return;

        if ( !is_valid )
            return;

        session_frame_id = frame_registry.GenerateSessionFrameId();

        SnmpErrorReport error_report = snmp_security.Secure ( 

            m_EncodeDecode,
            snmpPdu
        );

        // if already errored, register the error report in the sent state
        if ( error_report.GetError() != Snmp_Success )
        {   
            delete & snmpPdu;

            store.Register(session_frame_id, operation, SnmpErrorReport(Snmp_Error, Snmp_Local_Error) );

            m_SessionWindow.PostMessage(Window :: g_SentFrameEvent, session_frame_id, 0);

            return;
        }

        Message *message = 
            new Message(session_frame_id, snmpPdu, operation);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"new message(id%d,op%d)\n",session_frame_id, &(message->GetOperation())
    ) ;
)
        flow_control.SendMessage(*message);
    }
    catch(GeneralException exception)
    {
        return;
    }
}

void SnmpImpSession::HandleSentFrame (

    IN SessionFrameId  session_frame_id
)
{
    SnmpOperation *operation;
    SnmpErrorReport error_report = store.Remove(session_frame_id, operation);

    // ignore it if no corresponding operation
    if ( operation == NULL )
        return;

    operation->SentFrame(session_frame_id, error_report);
}

SnmpOperation *SnmpImpSession::GetOperation(IN const SessionFrameId session_frame_id)
{
    WaitingMessage *waiting_message = frame_registry.GetWaitingMessage(session_frame_id);

    if (waiting_message == NULL)
        return NULL;

    return &(waiting_message->GetMessage()->GetOperation());
}

void SnmpImpSession::SessionSentFrame 
(
    IN TransportFrameId  transport_frame_id,  
    IN SnmpErrorReport &errorReport
)
{
    try
    {
        CriticalSectionLock access_lock(session_CriticalSection);

        if ( !access_lock.GetLock(INFINITE) )
            return;

        // obtain and remove the session frame id
        // obtain corresponding operation and inform it
        SessionFrameId session_frame_id = id_mapping.DisassociateTransportFrameId(transport_frame_id);

        // determine corresponding waiting message
        WaitingMessage *waiting_message = frame_registry.GetWaitingMessage(session_frame_id);

        // ignore if no such waiting message
        if (waiting_message == NULL)
            return;

        // if the error report shows an error during transport,
        // wrap up the waiting message and return
        if ( errorReport.GetError() != Snmp_Success )
        {
            waiting_message->WrapUp(SnmpErrorReport(errorReport));
            return;
        }

        // inform the waiting message of the sent message processing event
        waiting_message->SetSentMessageProcessed();

        // determine the corresponding operation 
        SnmpOperation *operation = &(waiting_message->GetMessage()->GetOperation());

        access_lock.UnLock();

        // call to the operation is made outside the lock
        operation->SentFrame(session_frame_id, errorReport);

        // obtain the lock again to process the corresponding buffered
        // waiting message, if any
        if ( !access_lock.GetLock(INFINITE) )
            return;

        // if no such buffered snmp pdu, return
        if ( !waiting_message->ReplyBuffered() )
            return;

        SnmpPdu *snmp_pdu = waiting_message->GetBufferedReply();

        // set the state information for processing the buffered message
        received_session_frame_id = ILLEGAL_SESSION_FRAME_ID;

        // proceed with processing the snmp_pdu
        waiting_message->ReceiveReply(snmp_pdu);

        // save the information needed to notify the targeted operation
        // before releasing the lock
        SessionFrameId target_session_frame_id = received_session_frame_id;
        SnmpOperation *target_operation = operation_to_notify;

        access_lock.UnLock();

        // inform the target operation of the frame receipt
        if ( target_session_frame_id != ILLEGAL_SESSION_FRAME_ID )
        {
            target_operation->ReceiveFrame(target_session_frame_id, *snmp_pdu, 
                                           SnmpErrorReport(Snmp_Success, Snmp_No_Error));
        }

        delete & snmp_pdu->GetVarbindList () ; 
        delete snmp_pdu;
    }
    catch(GeneralException exception)
    {
        return;
    }
}
    
void SnmpImpSession::SessionReceiveFrame (

    IN SnmpPdu &snmpPdu,
    IN SnmpErrorReport &errorReport
)
{
    try
    {
        CriticalSectionLock access_lock(session_CriticalSection);

        if ( !access_lock.GetLock(INFINITE) )
            return;

        // set the state information for processing the buffered message
        received_session_frame_id = ILLEGAL_SESSION_FRAME_ID;

        // proceed with processing the snmp_pdu
        message_registry.MessageArrivalNotification(snmpPdu);

        // save the information needed to notify the targeted operation
        // before releasing the lock
        SessionFrameId target_session_frame_id = received_session_frame_id;
        SnmpOperation *target_operation = operation_to_notify;

        access_lock.UnLock();

        // inform the target operation of the frame receipt
        if ( target_session_frame_id != ILLEGAL_SESSION_FRAME_ID )
            target_operation->ReceiveFrame(target_session_frame_id, snmpPdu, 
                                           errorReport);
    }
    catch(GeneralException exception)
    {
        return;
    }
}

void SnmpImpSession::NotifyOperation (

    IN const SessionFrameId session_frame_id,
    IN const SnmpPdu &snmp_pdu,
    IN const SnmpErrorReport &error_report
)
{
    // determine the corresponding operation and 
    // call its SessionReceiveFrame
    SnmpOperation *operation = GetOperation(session_frame_id);

    if ( error_report.GetError() != Snmp_Success )
    {
        store.Register(session_frame_id, *operation, error_report );

        m_SessionWindow.PostMessage(Window :: g_SentFrameEvent,
                                  session_frame_id, 0);
    }
    else
    {
        received_session_frame_id = session_frame_id;
        operation_to_notify = operation;
    }
}


SnmpErrorReport SnmpImpSession::SessionCancelFrame ( 

    IN const SessionFrameId session_frame_id 
)
{
    if ( !is_valid )
        return SnmpErrorReport(Snmp_Error, Snmp_Local_Error);

    try
    {
        CriticalSectionLock access_lock(session_CriticalSection);

        if ( !access_lock.GetLock(INFINITE) )
            return SnmpErrorReport(Snmp_Error, Snmp_Local_Error);

        frame_registry.CancelFrameNotification(session_frame_id);

        access_lock.UnLock();
    }
    catch(GeneralException exception)
    {
        return exception;
    }

    // if we have reached this place, we must have succeeded
    return SnmpErrorReport(Snmp_Success, Snmp_No_Error);
}


SnmpImpSession::~SnmpImpSession(void)
{
    // if required, cancels timer event
    if ( timer_event_id != ILLEGAL_TIMER_EVENT_ID )
    {
        timer.CancelTimer(timer_event_id);
        timer_event_id = ILLEGAL_TIMER_EVENT_ID;
    }
}



void * SnmpV1OverIp::operator()(void) const
{
    if ( (SnmpUdpIpImp::operator()() == NULL) ||
        (SnmpV1EncodeDecode::operator()() == NULL) ||
         (SnmpCommunityBasedSecurity::operator()() == NULL) ||
         (SnmpImpSession::operator()() == NULL) )
         return NULL;
    else
        return (void *)this;
}

void * SnmpV1OverIpx::operator()(void) const
{
    if ( (SnmpIpxImp::operator()() == NULL) ||
        (SnmpV1EncodeDecode::operator()() == NULL) ||
         (SnmpCommunityBasedSecurity::operator()() == NULL) ||
         (SnmpImpSession::operator()() == NULL) )
         return NULL;
    else
        return (void *)this;
}

void * SnmpV2COverIp::operator()(void) const
{
    if ( (SnmpUdpIpImp::operator()() == NULL) ||
        (SnmpV2CEncodeDecode::operator()() == NULL) ||
         (SnmpCommunityBasedSecurity::operator()() == NULL) ||
         (SnmpImpSession::operator()() == NULL) )
         return NULL;
    else
        return (void *)this;
}

void * SnmpV2COverIpx::operator()(void) const
{
    if ( (SnmpIpxImp::operator()() == NULL) ||
        (SnmpV2CEncodeDecode::operator()() == NULL) ||
         (SnmpCommunityBasedSecurity::operator()() == NULL) ||
         (SnmpImpSession::operator()() == NULL) )
         return NULL;
    else
        return (void *)this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\startup.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include <provexpt.h>

#include <snmpstd.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <winsock.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include "common.h"
#include "startup.h"
#include "sync.h"
#include "dummy.h"
#include "flow.h"
#include "reg.h"
#include "frame.h"
#include "timer.h"
#include "message.h"

#include "tsent.h"

#include "transp.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "pseudo.h"
#include "fs_reg.h"
#include "ophelp.h"
#include "op.h"
#include <winsock.h>
#include "trap.h"

CRITICAL_SECTION s_CriticalSection ;

LONG SnmpClassLibrary :: s_ReferenceCount = 0 ;

BOOL SnmpClassLibrary :: Startup ()
{
    EnterCriticalSection ( & s_CriticalSection ) ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpClassLibrary :: Startup, s_ReferenceCount = %lx\n" , s_ReferenceCount
    ) ;
)

    BOOL status = TRUE ;

    s_ReferenceCount ++ ;

    if ( s_ReferenceCount == 1 )
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Creating library resources\n" 
    ) ;
)

        status = FALSE ;

        SnmpDebugLog :: Startup () ;
        SnmpThreadObject :: Startup () ;

        Timer::g_timerThread = new SnmpClThreadObject ;
        if ( Timer::g_timerThread )
        {
            try
            {
				Timer::g_timerThread->BeginThread () ;
                Timer::g_timerThread->WaitForStartup () ;

                WORD wVersionRequested;  
                WSADATA wsaData; 

                wVersionRequested = MAKEWORD(1, 1); 
                status = ( WSAStartup ( wVersionRequested , &wsaData ) == 0 ) ;
                if ( status )
                {
                    BOOL WindowStatus = FALSE ;
                    BOOL TimerStatus = FALSE ;
                    BOOL EncodeStatus = FALSE ;

                    try
                    {
                        WindowStatus = Window::InitializeStaticComponents () ;
                        TimerStatus = Timer::InitializeStaticComponents () ;
                        EncodeStatus = SnmpEncodeDecode :: InitializeStaticComponents () ;

                        status = WindowStatus & TimerStatus & EncodeStatus ;
                        if ( status )
                        {
                            SnmpTrapManager ::s_TrapMngrPtr = NULL ;

                            try
                            {
                                SnmpTrapManager ::s_TrapMngrPtr = new SnmpTrapManager();

                                status = SnmpTrapManager ::s_TrapMngrPtr ? TRUE : FALSE ;
                            }
                            catch ( ... )
                            {
                                delete SnmpTrapManager ::s_TrapMngrPtr ;
                                SnmpTrapManager ::s_TrapMngrPtr = NULL ;

                                status = FALSE ;
                            }
                        }
                    }
                    catch ( ... )
                    {
                        status = FALSE ;
                    }
                    
                    if ( ! status )
                    {
                        if ( TimerStatus )
                        {
                            Timer::DestroyStaticComponents();
                        }

                        if ( WindowStatus )
                        {
                            Window::DestroyStaticComponents();
                        }

                        if ( EncodeStatus )
                        {
                            SnmpEncodeDecode :: DestroyStaticComponents() ;
                        }

                        WSACleanup () ;
                    }
                }
            }
            catch ( ... )
            {
                status = FALSE ;
            }

            if ( ! status )
            {
                Timer::g_timerThread->SignalThreadShutdown () ;
                Timer::g_timerThread = NULL ;
            }
        }

        if ( ! status )
        {
            SnmpDebugLog :: Closedown () ;
            SnmpThreadObject :: Closedown () ;

            s_ReferenceCount -- ;
        }
    }

    LeaveCriticalSection ( & s_CriticalSection ) ;

    return status ;
}

void SnmpClassLibrary :: Closedown () 
{
    EnterCriticalSection ( & s_CriticalSection ) ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpClassLibrary :: Closedown, s_ReferenceCount = %lx\n" , s_ReferenceCount
    ) ;
)

    if ( InterlockedDecrement ( & s_ReferenceCount ) <= 0 )
    {
        if ( Timer::g_timerThread )
        {
            Timer::g_timerThread->SignalThreadShutdown () ;
            Timer::g_timerThread = NULL ;
        }

        if ( SnmpTrapManager ::s_TrapMngrPtr )
        {
            delete SnmpTrapManager ::s_TrapMngrPtr ;
            SnmpTrapManager ::s_TrapMngrPtr = NULL;
        }

        SnmpDebugLog :: Closedown () ;
        SnmpThreadObject :: Closedown () ;

        Timer::DestroyStaticComponents();
        Window::DestroyStaticComponents();
        SnmpEncodeDecode :: DestroyStaticComponents() ;

        SnmpCleanup();

        WSACleanup () ;
    }

    LeaveCriticalSection ( & s_CriticalSection ) ;
}

HINSTANCE g_hInst = NULL ;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

    HINSTANCE hInstance, 
    ULONG ulReason , 
    LPVOID pvReserved
)
{
    g_hInst=hInstance;
    BOOL status = TRUE ;
    SetStructuredExceptionHandler seh;

    try
    {
        if ( DLL_PROCESS_DETACH == ulReason )
        {
            DeleteCriticalSection ( & s_CriticalSection ) ;
        }
        else if ( DLL_PROCESS_ATTACH == ulReason )
        {
            InitializeCriticalSection ( & s_CriticalSection ) ;
			DisableThreadLibraryCalls(hInstance);			// 158024 
        }
        else if ( DLL_THREAD_DETACH == ulReason )
        {
        }
        else if ( DLL_THREAD_ATTACH == ulReason )
        {
        }
    }
    catch(Structured_Exception e_SE)
    {
        status = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        status = FALSE;
    }

    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\timer.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: timer.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "timer.h"
#include "message.h"
#include "dummy.h"

#include "flow.h"
#include "frame.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"

SnmpClThreadObject *Timer :: g_timerThread = NULL ;
UINT Timer :: g_SnmpWmTimer = SNMP_WM_TIMER ;

// static CriticalSection and CMap
CriticalSection Timer::timer_CriticalSection;
TimerMapping Timer::timer_mapping;

TimerEventId Timer :: next_timer_event_id = ILLEGAL_TIMER_EVENT_ID+1 ;
Window *SnmpTimerObject :: window = NULL ;
CMap <UINT_PTR,UINT_PTR,SnmpTimerObject *,SnmpTimerObject *> SnmpTimerObject :: timerMap ;

SnmpClThreadObject :: SnmpClThreadObject () : SnmpThreadObject ( "SnmpCl" ) 
{
}

void SnmpClThreadObject :: Initialise ()
{
}
 
void SnmpClThreadObject :: Uninitialise ()
{
    delete SnmpTimerObject :: window ;
    SnmpTimerObject :: window = NULL ;
    delete this ;
}

SnmpClTrapThreadObject :: SnmpClTrapThreadObject () : SnmpThreadObject ( "SnmpClTrapThread" ) 
{
}

void SnmpClTrapThreadObject :: Initialise ()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpClTrapThreadObject::Initialise: Initialised!!\n"

    ) ;
)
}
 
void SnmpClTrapThreadObject :: Uninitialise ()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpClTrapThreadObject::Uninitialise: About to destroy trap thread\n"

    ) ;
)
    delete this ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpClTrapThreadObject::Uninitialise: Trap thread destroyed!!\n"

    ) ;
)
}


Timer::Timer(SnmpImpSession &session)
{
    Timer::session = &session;
}

BOOL Timer::CreateCriticalSection()
{
    return TRUE;
}

void Timer::DestroyCriticalSection()
{
}

BOOL Timer::InitializeStaticComponents()
{
    return CreateCriticalSection();
}

void Timer::DestroyStaticComponents()
{
    DestroyCriticalSection();
}

// generates and returns a new event id
// associates the pair (event_id, waiting_message)
// creates the timer event
TimerEventId Timer::SetTimerEvent(UINT timeout_value)
{
    TimerEventId suggested_event_id = next_timer_event_id++;
    if ( suggested_event_id == ILLEGAL_TIMER_EVENT_ID )
       suggested_event_id = next_timer_event_id++;

    // let the dummy session receive the window messages for timer events
    TimerEventId event_id = 
        SnmpSetTimer( session->m_SessionWindow.GetWindowHandle(), suggested_event_id, 
                  timeout_value, NULL );

    if ( (event_id == ILLEGAL_TIMER_EVENT_ID) ||
         (event_id != suggested_event_id) )
         throw GeneralException(Snmp_Error, Snmp_Local_Error,__FILE__,__LINE__);

    return event_id;
}

// generates and returns a new event id
// associates the pair (event_id, waiting_message)
// creates the timer event
void Timer::SetMessageTimerEvent(WaitingMessage &waiting_message)
{
    CriticalSectionLock session_lock(session->session_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        return; // no use throwing exception

    TimerEventId event_id = session->timer_event_id;
    // register the timer event in both the instance CMap and the global CMap
    waiting_message_mapping.AddTail ( &waiting_message ) ;

    session_lock.UnLock();   

    CriticalSectionLock timer_lock(Timer::timer_CriticalSection);

    if ( !timer_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    timer_mapping[event_id] = this;

    timer_lock.UnLock();   

}

// Removes the association (event_id, waiting_message)
// and also kills the registered timer event
void Timer::CancelMessageTimer(WaitingMessage &waiting_message,TimerEventId event_id)
{
    CriticalSectionLock session_lock(session->session_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        return; // no use throwing exception

    // remove the timer event from the instance CMap

    POSITION t_Position = waiting_message_mapping.GetHeadPosition () ;
    while ( t_Position )
    {
        POSITION t_OldPosition = t_Position ;
        WaitingMessage *t_Message = waiting_message_mapping.GetNext ( t_Position ) ;
        if ( t_Message == & waiting_message )
        {
            waiting_message_mapping.RemoveAt(t_OldPosition);
            break ;
        }
    }

    session_lock.UnLock();   

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Cancelled Message TimerEvent %d\n", event_id
    ) ;
)

}


// Removes the association (event_id, waiting_message)
// and also kills the registered timer event
void Timer::CancelTimer(TimerEventId event_id)
{
    CriticalSectionLock timer_lock(Timer::timer_CriticalSection);

    if ( !timer_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    // remove the timer event from the global CMap
    timer_mapping.RemoveKey(event_id);

    timer_lock.UnLock();   

    SnmpKillTimer(NULL, event_id);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Cancelled TimerEvent %d\n", event_id
    ) ;
)
}

// it determines the corresponding Timer and calls 
// its TimerEventNotification with the appropriate parameters
void CALLBACK Timer::HandleGlobalEvent(HWND hWnd ,UINT message,
                                       UINT_PTR idEvent, DWORD dwTime)
{
    CriticalSectionLock timer_lock(Timer::timer_CriticalSection);

    if ( !timer_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    Timer *timer;
    TimerEventId event_id = idEvent;
    BOOL found = timer_mapping.Lookup(event_id, timer);

    timer_lock.UnLock();   

    // if no such timer event, return
    if ( !found )
        return;

    // let the timer handle the event
    timer->TimerEventNotification(event_id);

    return;
}


// used by the event handler to notify the timer event.
// it must notify the corresponding waiting message
void Timer::TimerEventNotification(TimerEventId event_id)
{
    CriticalSectionLock session_lock(session->session_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        return; // no use throwing exception

    WaitingMessage *waiting_message;

    // identify the waiting message corresponding to
    // the event_id. if no such event, ignore it

    POSITION t_Position = waiting_message_mapping.GetHeadPosition () ;
    while ( t_Position )
    {
        waiting_message = waiting_message_mapping.GetNext ( t_Position ) ;
        // notify the waiting message of the event
        waiting_message->TimerNotification();
    }

    // session_lock.UnLock();   The lock may be released at this point
}

// remove all the (timer_event_id, timer) associations
// from the static mapping data structure
Timer::~Timer(void)
{
    WaitingMessage *waiting_message;

    POSITION current = waiting_message_mapping.GetHeadPosition();

    while ( current != NULL )
    {
        waiting_message = waiting_message_mapping.GetNext(current);

        TimerEventId event_id = waiting_message->GetTimerEventId () ;

        CriticalSectionLock timer_lock(Timer::timer_CriticalSection);

        if ( !timer_lock.GetLock(INFINITE) )
            throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

        timer_mapping.RemoveKey ( event_id  );

        timer_lock.UnLock(); 

        SnmpKillTimer(NULL, event_id );
    }

    waiting_message_mapping.RemoveAll();
}

SnmpTimerObject :: SnmpTimerObject (

    HWND hWndArg,               // handle of window for timer messages
    UINT_PTR timerIdArg,            // timer identifier
    UINT elapsedArg,            // time-out value
    TIMERPROC lpTimerFuncArg    // address of timer procedure

) : hWnd ( hWndArg ) ,
    timerId ( timerIdArg ) ,
    lpTimerFunc ( lpTimerFuncArg ) 
{
    if ( ! window )
        window = new Window ;

    timerId = SetTimer ( 

        window->GetWindowHandle(), 
        timerId , 
        elapsedArg , 
        lpTimerFunc 
    ) ;

    CriticalSectionLock session_lock(Timer::timer_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    if ( timerId ) 
    {
        timerMap [ timerId ] = this ;
    }
    else
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;
}

SnmpTimerObject :: ~SnmpTimerObject ()
{
    if (window)
    {
        KillTimer ( window->GetWindowHandle () , timerId ) ;
    }

    CriticalSectionLock session_lock(Timer::timer_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    timerMap.RemoveKey ( timerId );
}

void SnmpTimerObject :: TimerNotification ( HWND hWnd , UINT timerId )
{
    PostMessage ( hWnd , Timer :: g_SnmpWmTimer , timerId , 0 ) ;
}

SnmpSetTimerObject :: SnmpSetTimerObject (

    HWND hWndArg,               // handle of window for timer messages
    UINT_PTR nIDEventArg,           // timer identifier
    UINT uElapseArg,            // time-out value
    TIMERPROC lpTimerFuncArg    // address of timer procedure

) : hWnd ( hWndArg ) ,
    timerId ( nIDEventArg ) ,
    elapsedTime ( uElapseArg ) ,
    lpTimerFunc ( lpTimerFuncArg ) 
{
}

SnmpSetTimerObject :: ~SnmpSetTimerObject ()
{
}

void SnmpSetTimerObject :: Process ()
{
    SnmpTimerObject *object = new SnmpTimerObject ( 

        hWnd ,
        timerId ,
        elapsedTime ,
        lpTimerFunc 
    ) ;

    Complete () ;
}

SnmpKillTimerObject :: SnmpKillTimerObject (

    HWND hWndArg ,              // handle of window that installed timer
    UINT_PTR uIDEventArg            // timer identifier

) : hWnd ( hWndArg ) ,
    timerId ( uIDEventArg ) , 
    status ( TRUE )
{
}

void SnmpKillTimerObject :: Process ()
{
    CriticalSectionLock session_lock(Timer::timer_CriticalSection);

    if ( !session_lock.GetLock(INFINITE) )
        throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

    SnmpTimerObject *object ;
    if ( SnmpTimerObject :: timerMap.Lookup ( timerId , object ) )
    {
        delete object ;
    }
    else
    {
        status = FALSE ;
    }

    Complete () ;   
}

UINT_PTR SnmpSetTimer (

    HWND hWnd,              // handle of window for timer messages
    UINT_PTR nIDEvent,          // timer identifier
    UINT uElapse,           // time-out value,
    TIMERPROC lpTimerFunc   // address of timer procedure
)
{
    SnmpSetTimerObject object ( hWnd , nIDEvent , uElapse , lpTimerFunc ) ;
    Timer :: g_timerThread->ScheduleTask ( object ) ;
    object.Exec () ;
    if ( object.Wait () )
    {
        Timer :: g_timerThread->ReapTask ( object ) ;
        return object.GetTimerId () ;
    }
    else
    {
        Timer :: g_timerThread->ReapTask ( object ) ;
        return FALSE ;
    }
}

BOOL SnmpKillTimer (

    HWND hWnd,      // handle of window that installed timer
    UINT_PTR uIDEvent   // timer identifier
)
{
    SnmpKillTimerObject object ( hWnd , uIDEvent ) ;

    Timer :: g_timerThread->ScheduleTask ( object ) ;

    object.Exec () ;
    if ( object.Wait () )
    {
        Timer :: g_timerThread->ReapTask ( object ) ;
        return object.GetStatus () ;
    }
    else
    {
        Timer :: g_timerThread->ReapTask ( object ) ;
        return FALSE ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\ssess.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: ssess.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "ssess.h"
#include "pdu.h"

SecuritySession::SecuritySession(IN const char *context_string)
: WinSnmpSession(LOOPBACK_ADDRESS, WinSnmpSession :: g_NullEventId, context_string)
{}

// inserts the security context into the in_pdu and returns it in
// the out parameter out_pdu
// it decodes the in_pdu to obtain the necessary details and encodes
// them with the security context into out_pdu
BOOL SecuritySession::InsertContext(IN const SnmpPdu &in_pdu,
                                    OUT SnmpPdu &out_pdu)
{
    smiOCTETS message_buffer;
    HSNMP_ENTITY source_entity, destination_entity;
    HSNMP_PDU pdu;

    message_buffer.ptr = in_pdu.GetFrame();
    message_buffer.len = in_pdu.GetFrameLength();

    // decode the message
    SNMPAPI_STATUS status = 
        SnmpDecodeMsg(session_handle,
                      &source_entity, &destination_entity, 
                      NULL, (LPHSNMP_PDU) &pdu, 
                      &message_buffer);

    if ( status == SNMPAPI_FAILURE )
        return FALSE;

    HSNMP_VBL vbl;
    status = SnmpGetPduData(pdu, NULL, NULL, NULL, NULL, &vbl);

    if ( status == SNMPAPI_FAILURE )
        return FALSE;

    status = SnmpSetPduData(pdu, NULL, NULL, NULL, NULL, &vbl);

    if ( status == SNMPAPI_FAILURE )
        return FALSE;

    // uses the context defined in the WinSnmpSession to encode
    // the message
    status = SnmpEncodeMsg(session_handle,
                           src_entity, dst_entity,
                           context, pdu, &message_buffer);
    
    SnmpFreeEntity(source_entity);
    SnmpFreeEntity(destination_entity);
    SnmpFreeVbl(vbl);
    SnmpFreePdu(pdu);

    if ( status == SNMPAPI_FAILURE )
    {
        return FALSE;
    }


    out_pdu.SetPdu(message_buffer.ptr, message_buffer.len);
    SnmpFreeDescriptor (SNMP_SYNTAX_OCTETS,&message_buffer) ;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\transp.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: transp.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "sync.h"
#include "address.h"
#include "tsess.h"
#include "tsent.h"
#include "idmap.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "opreg.h"

#include "session.h"
#include "transp.h"

/*------------------------------------------------------------
Purpose: The SnmpTransport class provides the implementation 
of the transport protocol layer for use by the SnmpSession class. 
The SnmpImpTransport provides a UDP implementation of the 
transport layer.
-------------------------------------------------------------*/

TransportFrameId SnmpImpTransport::next_transport_frame_id = ILLEGAL_TRANSPORT_FRAME_ID ;

SnmpTransport::SnmpTransport (

    IN SnmpSession &session,
    IN const SnmpTransportAddress &transportAddress

) :transport_address(transportAddress.Copy())
{
}
    
SnmpTransportAddress &SnmpTransport::GetTransportAddress() 
{
    return *transport_address;
}

SnmpTransport::~SnmpTransport()
{
    delete transport_address;
}

SnmpImpTransport::SnmpImpTransport (

    IN SnmpSession &session,
    IN const SnmpTransportAddress &address

) :     SnmpTransport(session, address),
        session(session)
{
    is_valid = FALSE;
    transport_created = FALSE;

    if ( !GetTransportAddress()() )
        return;

    try {

        transport = new TransportWindow(*this);
    }
    catch ( GeneralException exception ) 
    {
        return ; 
    }

    transport_created = TRUE;

    if ( !(*transport)() )
        return;

    is_valid = TRUE;
}


SnmpImpTransport::~SnmpImpTransport(void)
{
    if ( transport_created )
        delete transport;
}


void SnmpImpTransport::TransportSendFrame(

    OUT TransportFrameId &transport_frame_id, 
    IN SnmpPdu &snmpPdu
)
{
    if ( next_transport_frame_id == ILLEGAL_TRANSPORT_FRAME_ID )
        next_transport_frame_id++;

    store.Register(transport_frame_id, SnmpErrorReport(Snmp_Success, Snmp_No_Error) );

    transport->PostMessage(Window :: g_SentFrameEvent,
                           transport_frame_id, 0);


DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"posted: transport_frame_id = %d\n", transport_frame_id
    ) ;
)

    try 
    {
        if ( transport->SendPdu(snmpPdu) == FALSE )
            store.Modify(transport_frame_id, SnmpErrorReport(Snmp_Error, Snmp_Local_Error));
    }
    catch ( GeneralException exception )
    {
        store.Modify(transport_frame_id, SnmpErrorReport(Snmp_Error, Snmp_Local_Error));
    }
}

void SnmpImpTransport::HandleSentFrame(IN TransportFrameId transport_frame_id)
{
    TransportSentFrame(transport_frame_id, store.Remove(transport_frame_id));
}

void SnmpImpTransport::TransportSentFrame(IN TransportFrameId transport_frame_id, 
                                            IN SnmpErrorReport &errorReport)
{
    session.SessionSentFrame(transport_frame_id, errorReport);
}

void SnmpImpTransport::TransportReceiveFrame (

    IN SnmpPdu &snmpPdu ,
    IN SnmpErrorReport &errorReport 
)
{
    session.SessionReceiveFrame(snmpPdu, errorReport);
}

SnmpUdpIpTransport :: SnmpUdpIpTransport (

    IN SnmpSession &session,
    IN const SnmpTransportIpAddress &ipAddress

) : SnmpImpTransport ( session , ipAddress ) 
{
}

void * SnmpUdpIpImp::operator()(void) const
{
    if ( ( SnmpTransportIpAddress::operator()() == NULL ) ||
        ( SnmpImpTransport::operator()() == NULL ) )
        return NULL;
    else
        return (void *)this;
}

SnmpIpxTransport :: SnmpIpxTransport (

    IN SnmpSession &session,
    IN const SnmpTransportIpxAddress &ipxAddress

) : SnmpImpTransport ( session , ipxAddress ) 
{
}

void * SnmpIpxImp::operator()(void) const
{
    if ( ( SnmpTransportIpxAddress::operator()() == NULL ) ||
        ( SnmpImpTransport::operator()() == NULL ) )
        return NULL;
    else
        return (void *)this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\trap.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "common.h"
#include "address.h"
#include "timer.h"
#include "sec.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "vblist.h"
#include "ophelp.h"
#include "window.h"
#include "trap.h"
#include "trapsess.h"

SnmpTrapManager *SnmpTrapManager ::s_TrapMngrPtr = NULL ;

SnmpTrapTaskObject::SnmpTrapTaskObject(SnmpTrapManager* managerPtr,
                                       SnmpWinSnmpTrapSession** pptrapsess)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapTaskObject::SnmpTrapTaskObject: Creating a new trap task object\n" 

    ) ;
)
    m_mptr = managerPtr;
    m_pptrapsess = pptrapsess;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapTaskObject::SnmpTrapTaskObject: Created a new trap task object\n" 

    ) ;
)
}


void SnmpTrapTaskObject::Process ()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapTaskObject::Process: Entering...\n" 

    ) ;
)

    *m_pptrapsess = new SnmpWinSnmpTrapSession(m_mptr);

    if (NULL == (**m_pptrapsess)())
    {
        (*m_pptrapsess)->DestroySession();
        *m_pptrapsess = NULL;
    }

    Complete();

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapTaskObject::Process: Exiting\n" 

    ) ;
)
}


SnmpTrapManager::SnmpTrapManager() : m_trapThread ( NULL ), m_trapSession ( NULL )
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::SnmpTrapManager: Entering...\n" 

    ) ;
)
    m_bListening = FALSE;
    m_trapThread = new SnmpClTrapThreadObject;
	m_trapThread->BeginThread();

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::SnmpTrapManager: Exiting\n" 

    ) ;
)
}

SnmpTrapManager::~SnmpTrapManager()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::~SnmpTrapManager: Entering...\n" 

    ) ;
)

    if (NULL != m_trapSession)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::~SnmpTrapManager: Destroy the session\n" 

    ) ;
)
        m_trapSession->DestroySession();
    }
    
    if ( NULL != m_trapThread )
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::~SnmpTrapManager: Kill the thread\n" 

    ) ;
)
        m_trapThread->SignalThreadShutdown();
    }

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::~SnmpTrapManager: Exiting\n" 

    ) ;
)
}


BOOL SnmpTrapManager::RegisterReceiver(SnmpTrapReceiver *trapRx)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::RegisterReceiver: Entering...\n" 

    ) ;
)

    if (NULL == trapRx)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::RegisterReceiver: Exiting with FALSE, invalid argument\n" 

    ) ;
)
        return FALSE;
    }

    if (!m_bListening)
    {
        SnmpTrapTaskObject trap_task = SnmpTrapTaskObject(this, &m_trapSession);
        m_trapThread->ScheduleTask(trap_task);
        trap_task.Exec();
        trap_task.Wait();
        m_trapThread->ReapTask(trap_task);

        if (NULL == m_trapSession)
        {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::RegisterReceiver: Exiting with FALSE, invalid trap session\n" 

    ) ;
)
            return FALSE;
        }

        m_bListening = TRUE;
    }

    BOOL bRet =  m_receivers.Add(trapRx);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::RegisterReceiver: Exiting with %s\n" ,
        bRet ? L"TRUE" : L"FALSE, failed to add to store of receivers"

    ) ;
)

    return bRet;
}


BOOL SnmpTrapManager::UnRegisterReceiver (SnmpTrapReceiver *trapRx)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::UnRegisterReceiver: Entering...\n" 

    ) ;
)
    if (!m_bListening || (NULL == trapRx))
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::UnRegisterReceiver: Exiting with FALSE, invalid trap session\n" 

    ) ;
)
        return FALSE;
    }


    BOOL bRet = m_receivers.Delete(trapRx);

    if (bRet && m_receivers.IsEmpty())
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::UnRegisterReceiver: Destroy trap session, no more receivers\n"

    ) ;
)
        m_trapSession->DestroySession();
        m_trapSession = NULL;
        m_bListening = FALSE;
    }

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapManager::UnRegisterReceiver: Exiting with %s\n" ,
        bRet ? L"TRUE" : L"FALSE, failed to remove from store of receivers"

    ) ;
)

    return bRet;
}


SnmpTrapReceiver::SnmpTrapReceiver()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiver::SnmpTrapReceiver: Creating a new SnmpTrapReceiver\n"

    ) ;
)
    m_cRef = 1;
    m_bregistered = SnmpTrapManager ::s_TrapMngrPtr->RegisterReceiver(this);

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiver::SnmpTrapReceiver: %s this trap receiver\n" ,
        m_bregistered ? L"Succeessfully registered" : L"Failed to register"
    ) ;
)

}

SnmpTrapReceiver::~SnmpTrapReceiver()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiver::~SnmpTrapReceiver: deleted this trap receiver\n"
    ) ;
)
}

BOOL SnmpTrapReceiver::DestroyReceiver()
{
    if (0 != InterlockedDecrement(&m_cRef))
    {
        return FALSE;
    }

    if (m_bregistered)
    {
        SnmpTrapManager ::s_TrapMngrPtr->UnRegisterReceiver(this);
        m_bregistered = FALSE;
    }
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiver::DestroyReceiver: Destroyed and unregistered this trap receiver\n"
    ) ;
)

    delete this;
    return TRUE;
}



SnmpTrapReceiverStore::SnmpTrapReceiverStore() : m_HandledRxStack ( NULL ), m_UnHandledRxStack ( NULL )
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::SnmpTrapReceiverStore: Created store\n"
    ) ;
)
    m_HandledRxStack = (void *)(new CList<SnmpTrapReceiver*, SnmpTrapReceiver*>);
    m_UnHandledRxStack = (void *)(new CList<SnmpTrapReceiver*, SnmpTrapReceiver*>);
	InitializeCriticalSection(&m_Lock);
}


BOOL SnmpTrapReceiverStore::Add(SnmpTrapReceiver* receiver)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Add: Entering...\n"
    ) ;
)
	Lock();

    BOOL bRet = FALSE;

    if (((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->IsEmpty())
    {
        bRet =  (NULL != ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->AddTail(receiver));
    }
    else
    {
        bRet = (NULL != ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->AddTail(receiver));
    }

	Unlock();

    DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Add: Exiting with %s...\n",
        bRet ? L"TRUE" : L"FALSE"
    ) ;
)

    return bRet;
}


BOOL SnmpTrapReceiverStore::Delete(SnmpTrapReceiver* receiver)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Delete: Entering...\n"
    ) ;
)

    Lock();

    //first check the m_HandledRxStack
    POSITION pos = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->GetHeadPosition();
    
    while(NULL != pos)
    {
        POSITION delpos = pos;
        SnmpTrapReceiver* rx = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->GetNext(pos);

        if (rx == receiver)
        {
            ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->RemoveAt(delpos);
            Unlock();
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Delete: Exiting with TRUE\n"
    ) ;
)

            return TRUE;
        }
    }

    //now check the m_UnHandledRxStack
    pos = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->GetHeadPosition();
    
    while(NULL != pos)
    {
        POSITION delpos = pos;
        SnmpTrapReceiver* rx = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->GetNext(pos);

        if (rx == receiver)
        {
            ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->RemoveAt(delpos);
            Unlock();
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Delete: Exiting with TRUE\n"
    ) ;
)
            return TRUE;
        }
    }

    Unlock();
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::Delete: Exiting with FALSE\n"
    ) ;
)
    return FALSE;
}


void SnmpTrapReceiverStore::Lock()
{
    EnterCriticalSection(&m_Lock);
}


void SnmpTrapReceiverStore::Unlock()
{
    LeaveCriticalSection(&m_Lock);
}

BOOL SnmpTrapReceiverStore::IsEmpty()
{
    Lock();
    BOOL ret =  ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->IsEmpty() && ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->IsEmpty();
    Unlock();
    return ret;
}


SnmpTrapReceiver* SnmpTrapReceiverStore::GetNext()
{
    SnmpTrapReceiver* ret = NULL;   
    Lock();

    if (!((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->IsEmpty())
    {
        ret = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->RemoveHead();
        ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->AddTail(ret);
    }
    else
    {
        CList<SnmpTrapReceiver*, SnmpTrapReceiver*> *tmp = ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack);
        m_UnHandledRxStack = m_HandledRxStack;
        m_HandledRxStack = (void*)tmp;
    }

    Unlock();
    return ret;
}


SnmpTrapReceiverStore::~SnmpTrapReceiverStore()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpTrapReceiverStore::~SnmpTrapReceiverStore: Deleting store\n"
    ) ;
)
    DeleteCriticalSection(&m_Lock);

    if (m_HandledRxStack)
    {
        ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack)->RemoveAll();
		delete ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_HandledRxStack);
		m_HandledRxStack = NULL;
    }

    if (m_UnHandledRxStack)
    {
        ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack)->RemoveAll();
		delete ((CList<SnmpTrapReceiver*, SnmpTrapReceiver*>*)m_UnHandledRxStack);
		m_UnHandledRxStack = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\tsess.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: tsess.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "error.h"
#include "encdec.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"

#include "tsent.h"

#include "transp.h"
#include "tsess.h"
#include "sync.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"

TransportWindow::TransportWindow (

    SnmpImpTransport &owner_transport

) : owner ( owner_transport ) , m_Session ( NULL )
{
    smiUINT32 t_MajorVersion = 1 ;
    smiUINT32 t_MinorVersion = 1 ;
    smiUINT32 t_Level = 2 ;
    smiUINT32 t_TranslateMode = SNMPAPI_UNTRANSLATED_V1 ;
    smiUINT32 t_RetransmitMode = SNMPAPI_OFF ;

    CriticalSectionLock t_CriticalSectionLock ( SnmpEncodeDecode :: s_CriticalSection ) ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;
    
    SNMPAPI_STATUS t_StartupStatus = SnmpStartup (

        &t_MajorVersion,
        &t_MinorVersion,
        &t_Level,
        &t_TranslateMode,
        &t_RetransmitMode
    );

    t_CriticalSectionLock.UnLock () ;

    if ( t_StartupStatus == SNMPAPI_FAILURE )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

    m_Session = SnmpOpen (

        GetWindowHandle (), 
        Window :: g_MessageArrivalEvent 
    ) ;

    if ( m_Session == SNMPAPI_FAILURE )
    {
        m_Session = NULL;
        DWORD t_LastError = SnmpGetLastError (0) ;
        throw GeneralException ( 

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__
        );
    }

}

TransportWindow::~TransportWindow ()
{
    HSNMP_SESSION t_Session = ( HSNMP_SESSION ) m_Session ;
    if ( t_Session )
        SnmpClose ( t_Session ) ;
}

// over-rides the HandleEvent method provided by the
// WinSnmpSession. Receives the Pdu and passes it to
// the owner (SnmpTransport)

LONG_PTR TransportWindow::HandleEvent (

    HWND hWnd ,
    UINT message ,
    WPARAM wParam ,
    LPARAM lParam
)
{
    LONG rc = 0;

    try 
    {
        // check if the message needs to be handled
        if ( message == Window :: g_MessageArrivalEvent )
        {
            // inform the owner of a successful message receipt
            SnmpPdu t_SnmpPdu ;

            if ( ReceivePdu ( t_SnmpPdu ) )
            {
                owner.TransportReceiveFrame ( t_SnmpPdu , t_SnmpPdu.GetErrorReport () ) ; 

                delete & t_SnmpPdu.GetVarbindList () ; 
            }
            else
            {
            }
        }
        else if ( message == Window :: g_SentFrameEvent )
        {
            // inform the owner of a sent frame event
            // the error report will be ignored in this case
            owner.HandleSentFrame( (TransportFrameId)wParam );
        }
        else
        {
            return Window::HandleEvent(hWnd, message, wParam, lParam);
        }
    }
    catch ( GeneralException exception )
    {
    }

    return rc;
}

// sends the specified pdu. it decodes the SnmpPdu to extract
// parameters needed for SnmpSendMsg. the return value denotes
// success and failure in transmission
// we return on encoutering an error from the winsnmp library call

BOOL TransportWindow :: SendPdu (

    IN SnmpPdu &a_SnmpPdu
)
{
    WinSnmpVariables t_WinSnmpVariables ;

    BOOL t_Status ;
    try 
    {
        t_Status = owner.session.GetSnmpEncodeDecode ().EncodeFrame ( a_SnmpPdu , &t_WinSnmpVariables ) ;
        if ( ! t_Status )
        {
            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError ((HSNMP_SESSION) m_Session) 
            );
        }
    }
    catch ( GeneralException exception )
    {
        throw ;
    }

    HSNMP_CONTEXT t_Context = t_WinSnmpVariables.m_Context ;
    HSNMP_PDU t_Pdu = t_WinSnmpVariables.m_Pdu ;
    HSNMP_VBL t_Vbl = t_WinSnmpVariables.m_Vbl ;

    char *t_DstAddress = owner.GetTransportAddress ().GetAddress () ;

    CriticalSectionLock t_CriticalSectionLock ( SnmpEncodeDecode :: s_CriticalSection ) ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    owner.session.GetSnmpEncodeDecode ().SetTranslateMode () ;

    HSNMP_ENTITY t_SrcEntity = SnmpStrToEntity (

        ( HSNMP_SESSION ) m_Session ,
        LOOPBACK_ADDRESS 
    ) ;

    if ( t_SrcEntity == SNMPAPI_FAILURE )
    {
        SnmpFreeContext ( t_Context ) ;
        SnmpFreePdu ( t_Pdu ) ;
        SnmpFreeVbl ( t_Vbl ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );
    }

    HSNMP_ENTITY t_DstEntity = SnmpStrToEntity (

        ( HSNMP_SESSION ) m_Session ,
        t_DstAddress
    ) ;

    t_CriticalSectionLock.UnLock () ;

    if ( t_DstEntity == SNMPAPI_FAILURE )
    {
        SnmpFreeContext ( t_Context ) ;
        SnmpFreeEntity ( t_SrcEntity ) ;
        SnmpFreePdu ( t_Pdu ) ;
        SnmpFreeVbl ( t_Vbl ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );
    }

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Transport::SendPdu: sending %d\r\n\r\n" , t_WinSnmpVariables.m_RequestId 

    ) ;

    smiOCTETS t_Octets ;

    SnmpSetRetransmitMode ( SNMPAPI_OFF ) ;

    if ( SnmpEncodeMsg (

        m_Session,
        t_SrcEntity, 
        t_DstEntity,
        t_Context, 
        t_Pdu ,
        & t_Octets 

    ) != SNMPAPI_FAILURE )
    {
        ULONG t_Len = t_Octets.len ;
        UCHAR *t_Ptr = t_Octets.ptr ;

        ULONG t_RowLength = t_Len / 16 ;
        ULONG t_Remainder = t_Len % 16 ;
        
        ULONG t_Index = 0 ;
        for ( ULONG t_RowIndex = 0 ; t_RowIndex < t_RowLength ; t_RowIndex ++ )
        {
            ULONG t_StoredIndex = t_Index ;

            for ( ULONG t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%2.2lx  " , t_Ptr [ t_Index ++ ] ) ;
            }

            SnmpDebugLog :: s_SnmpDebugLog->Write ( L"        " ) ;

            for ( t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
            {
                if ( ( t_Ptr [ t_StoredIndex ] >= 0x20 ) && ( t_Ptr [ t_StoredIndex ] <= 0x7f ) ) 
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%c" , t_Ptr [ t_StoredIndex ] ) ;
                }
                else
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write (  L"." ) ;
                }

                t_StoredIndex ++ ;
            }

            SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\r\n" ) ;
        }       

        ULONG t_StoredIndex = t_Index ;
        for ( ULONG t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
        {
            if ( t_ColumnIndex < t_Remainder )
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%2.2lx  " , t_Ptr [ t_Index ++ ] ) ;
            }
            else
            {
                SnmpDebugLog :: s_SnmpDebugLog->Write (  L"    " ) ;
            }
        }

        SnmpDebugLog :: s_SnmpDebugLog->Write ( L"        " ) ;

        for ( t_ColumnIndex = 0 ; t_ColumnIndex < 16 ; t_ColumnIndex ++ )
        {
            if ( t_ColumnIndex < t_Remainder )
            {
                if ( t_Ptr [ t_StoredIndex ] >= 0x20 && t_Ptr [ t_StoredIndex ] <= 0x7f ) 
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write ( L"%c" , t_Ptr [ t_StoredIndex ] ) ;
                }
                else
                {
                    SnmpDebugLog :: s_SnmpDebugLog->Write (  L"." ) ;
                }

                t_StoredIndex ++ ;
            }
        }

        SnmpDebugLog :: s_SnmpDebugLog->Write ( L"\r\n\r\n" ) ;

        SnmpFreeDescriptor ( 

            SNMP_SYNTAX_OCTETS ,
            & t_Octets
        ) ;
    }
)

    SnmpSetRetransmitMode ( SNMPAPI_OFF ) ;

    // send message
    t_Status = SnmpSendMsg (

        m_Session,
        t_SrcEntity, 
        t_DstEntity,
        t_Context, 
        t_Pdu
    );

    if ( t_Status == SNMPAPI_FAILURE )
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Transport::SendPdu: failed sending %d\r\n\r\n" , t_WinSnmpVariables.m_RequestId 

    ) ;
)
        SnmpFreeContext ( t_Context ) ;
        SnmpFreeEntity ( t_SrcEntity ) ;
        SnmpFreeEntity ( t_DstEntity ) ;
        SnmpFreePdu ( t_Pdu ) ;
        SnmpFreeVbl ( t_Vbl ) ;

        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        ) ;
    }

    SnmpFreeContext ( t_Context ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeVbl ( t_Vbl ) ;

    if ( t_Status == SNMPAPI_FAILURE )
        return FALSE;
    else
        return TRUE;
}

BOOL TransportWindow :: ReceivePdu (

    OUT SnmpPdu &a_SnmpPdu 
)
{
    HSNMP_ENTITY t_SrcEntity = NULL;
    HSNMP_ENTITY t_DstEntity = NULL;
    HSNMP_CONTEXT t_Context;
    HSNMP_PDU t_Pdu;

    SNMPAPI_STATUS t_Status = SnmpRecvMsg (

        m_Session ,
        &t_SrcEntity, 
        &t_DstEntity , 
        &t_Context,
        &t_Pdu
    );

    if ( t_SrcEntity ) 
    {
        SnmpFreeEntity ( t_SrcEntity ) ;
    }

    if ( t_DstEntity )
    {
        SnmpFreeEntity ( t_DstEntity ) ;
    }

    if ( t_Status == SNMPAPI_FAILURE )
    {
        if ( SnmpGetLastError ((HSNMP_SESSION) m_Session) == SNMPAPI_NOOP )
        {
            return FALSE ;
        }
        else
        {
            throw GeneralException (

                Snmp_Error, 
                Snmp_Local_Error,
                __FILE__,
                __LINE__,
                SnmpGetLastError ((HSNMP_SESSION) m_Session)
            );  
        }
    }

    CriticalSectionLock t_CriticalSectionLock ( SnmpEncodeDecode :: s_CriticalSection ) ;

    t_CriticalSectionLock.GetLock ( INFINITE ) ;

    owner.session.GetSnmpEncodeDecode ().SetTranslateMode () ;

    t_SrcEntity = SnmpStrToEntity ( (HSNMP_SESSION) m_Session, LOOPBACK_ADDRESS ) ;
    t_DstEntity = SnmpStrToEntity ( (HSNMP_SESSION) m_Session, LOOPBACK_ADDRESS ) ;

    t_CriticalSectionLock.UnLock () ;

    WinSnmpVariables t_WinSnmpVariables ;

    t_WinSnmpVariables.m_SrcEntity = t_SrcEntity ;
    t_WinSnmpVariables.m_DstEntity = t_DstEntity ;
    t_WinSnmpVariables.m_Context = t_Context ;
    t_WinSnmpVariables.m_Pdu = t_Pdu  ;

    t_Status = owner.session.GetSnmpEncodeDecode ().DecodeFrame ( &t_WinSnmpVariables , a_SnmpPdu ) ;
    if ( ! t_Status )
    {
        throw GeneralException (

            Snmp_Error, 
            Snmp_Local_Error,
            __FILE__,
            __LINE__,
            SnmpGetLastError ((HSNMP_SESSION) m_Session) 
        );
    }

    SnmpFreePdu ( t_Pdu ) ;
    SnmpFreeEntity ( t_SrcEntity ) ;
    SnmpFreeEntity ( t_DstEntity ) ;
    SnmpFreeContext ( t_Context ) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\trapsess.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include "precomp.h"
#include "common.h"
#include "address.h"
#include "timer.h"
#include "sec.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "vblist.h"
#include "ophelp.h"
#include "window.h"
#include "trap.h"
#include "trapsess.h"

SnmpWinSnmpTrapSession::SnmpWinSnmpTrapSession(SnmpTrapManager* managerPtr)
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::SnmpWinSnmpTrapSession: Creating a new trap session\n" 

    ) ;
)

    m_bValid = FALSE;
    m_bDestroy = FALSE;
    m_cRef = 1;

    if ( (NULL == Window::operator()()) || (NULL == managerPtr) ||  !RegisterForAllTraps())
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::SnmpWinSnmpTrapSession: Invalid trap session created\n" 

    ) ;
)
        return;
    }
    
    m_managerPtr = managerPtr;
    m_bValid = TRUE;
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::SnmpWinSnmpTrapSession: Valid trap session created\n" 

    ) ;
)
}


SnmpWinSnmpTrapSession::~SnmpWinSnmpTrapSession()
{
    //Deregister for all traps...
    if (m_bValid)
    {
        SnmpRegister(m_session_handle,
                    0, //manager
                    0, //agent
                    0, //context
                    0, //trap_oid
                    SNMPAPI_OFF);
        SnmpClose(m_session_handle);
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::~SnmpWinSnmpTrapSession: Unregistered for traps and closed winsnmp session\n" 

    ) ;
)
    }
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::~SnmpWinSnmpTrapSession: Trap session destroyed\n" 

    ) ;
)
}


BOOL SnmpWinSnmpTrapSession::RegisterForAllTraps()
{
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::RegisterForAllTraps: Registering for all traps...\n" 

    ) ;
)

    smiUINT32 nMajorVersion = 1;
    smiUINT32 nMinorVersion = 1;
    smiUINT32 nLevel = 2;
    smiUINT32 nTranslateMode = SNMPAPI_UNTRANSLATED_V1;
    smiUINT32 nRetransmitMode = SNMPAPI_OFF;
    
    SNMPAPI_STATUS apiStatus = SnmpStartup(&nMajorVersion,
                                                &nMinorVersion,
                                                &nLevel,
                                                &nTranslateMode,
                                                &nRetransmitMode);
    if (SNMPAPI_FAILURE == apiStatus)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::RegisterForAllTraps: Failed to start up winsnmp\n" 

    ) ;
)
        return FALSE;
    }

    m_session_handle = SnmpOpen(GetWindowHandle(), TRAP_EVENT);

    if (SNMPAPI_FAILURE == m_session_handle)
    {
        DWORD t_LastError = SnmpGetLastError ( 0 ) ;
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::RegisterForAllTraps: Failed to open a winsnmp session, error code (%d)\n" ,
        t_LastError

    ) ;
)

        return FALSE;
    }
    
    apiStatus = SnmpRegister(m_session_handle,
                                0, //manager
                                0, //agent
                                0, //context
                                0, //trap_oid
                                SNMPAPI_ON);

    if (SNMPAPI_FAILURE == apiStatus)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::RegisterForAllTraps: Failed to register for all traps\n"

    ) ;
)
        SnmpClose(m_session_handle);
        return FALSE;
    }

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::RegisterForAllTraps: Registered for all traps!\n"

    ) ;
)

    return TRUE;
}

BOOL SnmpWinSnmpTrapSession::PostMessage(UINT user_msg_id, WPARAM wParam, LPARAM lParam)
{
    //call the global PostMessage...
    return ::PostMessage(GetWindowHandle(), user_msg_id, wParam, lParam);
}


LONG_PTR SnmpWinSnmpTrapSession::HandleEvent(HWND hWnd, UINT message,
                                     WPARAM wParam,LPARAM lParam)
{
    InterlockedIncrement(&m_cRef);
    LONG_PTR ret = 0;

    if (TRAP_EVENT == message)
    {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Received Trap\n" 

    ) ;
)

        /*
        never the case 'cos if the list is empty, this session
        would not have been created by the TrapMnager!
        if (m_managerPtr->m_receivers->IsEmpty())
        {
            return 0;
        }
        */

        HSNMP_ENTITY hsrc;
        HSNMP_CONTEXT hctxt;
        HSNMP_VBL hvbl;
        HSNMP_PDU hpdu;

        SNMPAPI_STATUS status = SnmpRecvMsg (m_session_handle,
                                                &hsrc, NULL, &hctxt, &hpdu);
        
        if (SNMPAPI_FAILURE != status)
        {
            SnmpSecurity *ctxt = OperationHelper::GetSecurityContext(hctxt);
            SnmpFreeContext(hctxt);

            if (NULL == ctxt) 
            {
                //conversion failed clean up and return
                SnmpFreePdu(hpdu);
                SnmpFreeEntity(hsrc);
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to security context decode failure\n" 

    ) ;
)
            }
            else
            {
                SnmpTransportAddress *src = OperationHelper::GetTransportAddress(hsrc);
                SnmpFreeEntity(hsrc);

                if (NULL == src)
                {
                    //conversion failed clean up and return
                    delete ctxt;
                    SnmpFreePdu(hpdu);
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to source address decode failure\n" 

    ) ;
)
                }
                else
                {
                    status = SnmpGetPduData(hpdu, NULL, NULL, NULL, NULL, &hvbl);

                    //got the vblist, don't need the pdu
                    SnmpFreePdu(hpdu);

                    
                    if (SNMPAPI_FAILURE == status)
                    {
                        //failed to get varbinds clean up and return
                        delete ctxt;
                        delete src;
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to PDU decode failure\n" 

    ) ;
)
                    }
                    else
                    {
                        UINT vbcount = SnmpCountVbl(hvbl);

                        if (SNMPAPI_FAILURE == vbcount)
                        {
                            delete ctxt;
                            delete src;
                            SnmpFreeVbl(hvbl);
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to VarBind count decode failure\n" 

    ) ;
)
                        }
                        else
                        {
                            SnmpVarBindList vbl;

                            for (UINT i = 1; i <= vbcount; i++)
                            {
                                smiOID vbname;
                                smiVALUE vbvalue;
                                status = SnmpGetVb(hvbl, i, &vbname, &vbvalue);

                                if (SNMPAPI_FAILURE == status)
                                {
                                    delete ctxt;
                                    delete src;
                                    SnmpFreeVbl(hvbl);
                                    hvbl = NULL;
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to complete VarBind decode failure\n" 

    ) ;
)
                                    break;
                                }
                                else
                                {
                                    SnmpVarBind* vb = OperationHelper::GetVarBind(vbname, vbvalue);
                                    if ( ! vb )
                                    {
                                        delete ctxt;
                                        delete src;
                                        SnmpFreeVbl(hvbl);
                                        hvbl = NULL;
                                        SnmpFreeDescriptor(SNMP_SYNTAX_OID, (smiOCTETS *)&vbname);
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to (%d)th VarBind decode failure\n",
        i

    ) ;
)
                                        break;
                                    }

                                    SnmpFreeDescriptor(SNMP_SYNTAX_OID, (smiOCTETS *)&vbname);

                                    switch (vbvalue.syntax)
                                    {
                                        case SNMP_SYNTAX_OCTETS :
                                        case SNMP_SYNTAX_BITS :
                                        case SNMP_SYNTAX_OPAQUE :
                                        case SNMP_SYNTAX_IPADDR :
                                        case SNMP_SYNTAX_NSAPADDR :
                                        {
                                            SnmpFreeDescriptor(SNMP_SYNTAX_OCTETS, &vbvalue.value.string);
                                        }
                                        break ;

                                        case SNMP_SYNTAX_OID :
                                        {
                                            SnmpFreeDescriptor(SNMP_SYNTAX_OID,
                                                                (smiOCTETS *)(&vbvalue.value.oid));
                                        }
                                        break ;

                                        default:
                                        {
                                        }
                                    }

                                    vbl.AddNoReallocate (*vb);
                                }
                            }

                            if (hvbl != NULL)
                            {
                                SnmpFreeVbl(hvbl);
                                SnmpTrapReceiver * rx = m_managerPtr->m_receivers.GetNext();

                                while (NULL != rx)
                                {
                                    InterlockedIncrement(&(rx->m_cRef));
                                    rx->Receive(*src, *ctxt, vbl);
                                    rx->DestroyReceiver();
                                    rx = m_managerPtr->m_receivers.GetNext();
                                }

                                delete ctxt;
                                delete src;
                            }
                            else
                            {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to receive failure\n" 

    ) ;
)
                            }
                        }
                    }
                }
            }
        }
        else
        {
DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"SnmpWinSnmpTrapSession::HandleEvent: Discarding Trap due to decode error\n" 

    ) ;
)
        }
    }
    else
    {
        ret = Window::HandleEvent(hWnd, message, wParam, lParam);
    }

    DestroySession();
    return ret;
}

BOOL SnmpWinSnmpTrapSession::DestroySession()
{
    if (0 != InterlockedDecrement(&m_cRef))
    {
        return FALSE;
    }

    delete this;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\tsent.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: tsent.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "tsent.h"

void TransportSentStateStore::Register(IN TransportFrameId id, 
                              IN const SnmpErrorReport &error_report)
{
    store[id] = new SnmpErrorReport(error_report);
}

void TransportSentStateStore::Modify(IN TransportFrameId id, 
                            IN const SnmpErrorReport &error_report)
{
    SnmpErrorReport *old_error_report = NULL ;

    store.Lookup(id, old_error_report);

    if ( old_error_report )
    {
        old_error_report->SetError(error_report.GetError());
        old_error_report->SetStatus(error_report.GetStatus());
    }
}

SnmpErrorReport TransportSentStateStore::Remove(IN TransportFrameId id) 
{
    SnmpErrorReport *error_report = NULL ;

    store.Lookup(id, error_report);

    store.RemoveKey(id);

    SnmpErrorReport to_return ;

    if ( error_report )
    {
        to_return = (*error_report);
        delete error_report;
    }

    return to_return;
}

TransportSentStateStore::~TransportSentStateStore(void)
{
    // get the first position
    POSITION current = store.GetStartPosition();

    // while the position isn't null
    while ( current != NULL )
    {
        TransportFrameId id;
        SnmpErrorReport *error_report = NULL ;

        // get the next pair
        store.GetNextAssoc(current, id, error_report);

        // delete the ptr
        delete error_report;
    }

    // remove all the keys
    store.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\vblist.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: vblist.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "vblist.h"

#define INDEX_VALUE(index) ((index==ILLEGAL_INDEX)?-1:index)
    

SnmpVarBindListNode::SnmpVarBindListNode(const SnmpVarBind *varbind) : varbind ( NULL )
{
    SnmpVarBindListNode::varbind = 
            (varbind==NULL)?NULL: new SnmpVarBind(*varbind);

    // previous and next both point to itself
    previous = next = this;
}

SnmpVarBindListNode::SnmpVarBindListNode(const SnmpVarBind &varbind) : varbind ( NULL )
{
    SnmpVarBindListNode::varbind = new SnmpVarBind(varbind);

    // previous and next both point to itself
    previous = next = this;
}

SnmpVarBindListNode::SnmpVarBindListNode(SnmpVarBind &varbind) : varbind ( NULL )
{
    SnmpVarBindListNode::varbind = & varbind;

    // previous and next both point to itself
    previous = next = this;
}

SnmpVarBindList::ListPosition::~ListPosition()
{
    vblist->DestroyPosition(this);
}


void SnmpVarBindList::EmptyLookupTable(void)
{
    // get the first position
    POSITION current = lookup_table.GetStartPosition();

    // while the position isn't null
    while ( current != NULL )
    {
        PositionHandle  position_handle;
        PositionInfo *position_info;

        // get the next pair
        lookup_table.GetNextAssoc(current, position_handle, position_info);

        // delete the ptr
        delete position_info;
    }
}

SnmpVarBindList::SnmpVarBindList()
        : head(NULL), current_node(&head), next_position_handle(0)
{
    length = 0;
    current_index = ILLEGAL_INDEX;
}


SnmpVarBindList::SnmpVarBindList(IN SnmpVarBindList &varBindList)
                                : head(NULL), current_node(&head), next_position_handle(0)
{
    Initialize(varBindList);
}


void SnmpVarBindList::Initialize(IN SnmpVarBindList &varBindList)
{
    // obtain handle to current position
    ListPosition *list_position = varBindList.GetPosition();

    // get the varBind to identify the parameter list's current
    // position. If it currently points to the head, do the
    // same for local list
    const SnmpVarBind *current_var_bind = varBindList.Get();
    if ( current_var_bind == NULL )
        current_node = &head;

    // reset the list
    varBindList.Reset();
    
    // iterate through the list
    while( varBindList.Next() )
    {
        const SnmpVarBind *current = varBindList.Get();

        // add each varbind to the end of the list 
        Insert(&head,
               new SnmpVarBindListNode(current));

        // when we get to the current var bind in the parameter
        // list, set current_node to point to the node that has
        // just been inserted
        if ( current_var_bind == current )
            current_node = head.GetPrevious();
    }

    // set back the original iterator postion for the parameter list
    varBindList.GotoPosition(list_position);

    // set the current_index, length
    current_index = varBindList.GetCurrentIndex();
    length = varBindList.GetLength();

    // destroy the list_position
    delete list_position;
}


SnmpVarBindList &SnmpVarBindList::operator=(IN SnmpVarBindList &vblist)
{
    FreeList();
    Initialize(vblist);

    return *this;
}

SnmpVarBindList::~SnmpVarBindList()
{
   FreeList();
}

void SnmpVarBindList::FreeList()
{
    // reset the iterator to the start of the list
    Reset();
    Next();

    // while we do not reach the end of the list
    // at each node, obtain the next node and delete the node
    while (current_node != &head)
    {
        SnmpVarBindListNode *new_current_node = current_node->GetNext();

        delete current_node;

        current_node = new_current_node;
    }

    EmptyLookupTable();
}

void SnmpVarBindList::GoForward(SnmpVarBindListNode *from_node,
                                UINT distance)
{
    current_node = from_node;

    for(; distance > 0; distance--)
        current_node = current_node->GetNext();
}

void SnmpVarBindList::GoBackward(SnmpVarBindListNode *from_node,
                                 UINT distance)
{
    current_node = from_node;

    for(; distance > 0; distance--)
        current_node = current_node->GetPrevious();
}


BOOL SnmpVarBindList::GotoIndex(UINT index)
{
    // check if such an index exists currently
    if ( index >= length )
        return FALSE;

    // calculate the forward and reverse distances from the
    // head and the current_node to find the shortest way
    // to the specified index
    int d1, d2, d3, abs_d2;

    d1 = index+1; // forward distance from head
    d2 = index - INDEX_VALUE(current_index); // distance from current_node
    d3 = length - index; // reverse distance from head

    abs_d2 = abs(d2);   // d2 may be negative

    if ( d1 < abs_d2 )
    {
        if ( d1 < d3 )
            GoForward(&head, d1);
        else
            GoBackward(&head, d3);
    }
    else
    {
        if ( d2 > 0 )
            GoForward(current_node, abs_d2);
        else if ( d2 < 0 )
            GoBackward(current_node, abs_d2);
    }

    current_index = index;

    return TRUE;
}


void SnmpVarBindList::Insert(SnmpVarBindListNode *current, SnmpVarBindListNode *new_node)
{
    current->GetPrevious()->SetNext(new_node);
    new_node->SetPrevious(current->GetPrevious());
    new_node->SetNext(current);
    current->SetPrevious(new_node);
}

void SnmpVarBindList::Release(SnmpVarBindListNode *current)
{
  current->GetPrevious()->SetNext(current->GetNext());
  current->GetNext()->SetPrevious(current->GetPrevious());

  delete current;
}

// Prepares a copy of the list between the indices
// [current_index .. current_index+segment_length-1] and
// returns the varbindlist. If any of the indices do not
// exist, NULL is returned
SnmpVarBindList *SnmpVarBindList::CopySegment(IN const UINT segment_length)
{
    if ( current_index == ILLEGAL_INDEX )
        return NULL;

    // check if the required number of varbinds exist in
    // the remainder of the list
    if ( (current_index + segment_length) > length )
        return NULL;

    // create an empty list
    SnmpVarBindList *var_bind_list = new SnmpVarBindList;

    // Add each var bind in the range to the new list
    for(UINT i=0; i < segment_length; i++)
    {
        var_bind_list->Add(*(current_node->GetVarBind()));

        current_node = current_node->GetNext();
    }

    // now current_node points to the node at 
    // current_index+segment_length (one beyond the last
    // node in the range)
    // set current_index (check if back at head)
    if ( current_node != &head )
        current_index += segment_length;
    else
        current_index = ILLEGAL_INDEX;

    // return the new list
    return var_bind_list;
}

// Prepares a copy of the list between the indices
// [ 1.. index ] and
// returns the varbindlist. If any of the indices do not
// exist, NULL is returned
SnmpVarBindList *SnmpVarBindList::Car ( IN const UINT index )
{
    // check if the required number of varbinds exist in
    // the remainder of the list
    if ( index > length )
        return NULL;

    // create an empty list
    SnmpVarBindList *var_bind_list = new SnmpVarBindList;

    Reset () ;

    // Add each var bind in the range to the new list
    for(UINT i=0; i < index; i++)
    {
        Next () ;
        var_bind_list->Add(*(current_node->GetVarBind()));
    }

    current_index = ILLEGAL_INDEX;

    // return the new list
    return var_bind_list;
}

// Prepares a copy of the list between the indices
// [ 1.. index ] and
// returns the varbindlist. If any of the indices do not
// exist, NULL is returned
SnmpVarBindList *SnmpVarBindList::Cdr (IN const UINT index )
{
    // check if the required number of varbinds exist in
    // the remainder of the list
    if ( index > length )
        return NULL;

    // create an empty list
    SnmpVarBindList *var_bind_list = new SnmpVarBindList;

    Reset () ;
    for(UINT i=0; i < index; i++)
    {
        Next () ;
    }

    // Add each var bind in the range to the new list
    for(i=index; i < length; i++)
    {
        Next () ;
        var_bind_list->Add(*(current_node->GetVarBind()));
    }

    current_index = ILLEGAL_INDEX;

    // return the new list
    return var_bind_list;
}

void SnmpVarBindList::Remove()
{
    if ( current_node != &head )
    {
        // not beyond the list

        SnmpVarBindListNode *new_current_node =
            current_node->GetNext();

        Release(current_node);

        current_node = new_current_node;

        length--;
        if ( current_node == &head )
            current_index = ILLEGAL_INDEX;
    }
}


SnmpVarBindList::ListPosition *SnmpVarBindList::GetPosition()
{
    lookup_table.SetAt(next_position_handle, 
                       new PositionInfo(current_node, current_index));
    return new ListPosition(next_position_handle++,this);
}


BOOL SnmpVarBindList::Next()
{
    // get next node
    SnmpVarBindListNode *next_node = current_node->GetNext();

    // if next node is head, return false
    if ( next_node == &head )
        return FALSE;
    else
    {
        // set current node to next node, 
        current_node = next_node;
        
        // update index, return TRUE
        if ( current_index == ILLEGAL_INDEX )
            current_index = 0;
        else
            current_index++;
        return TRUE;
    }
}



void SnmpVarBindList::GotoPosition(ListPosition *list_position)
{
    // confirm that the list position belongs to this list,
    // obtain the corresponding vblistnode and set current_node
    // to point to it
    if ( list_position->GetList() == this )
    {
        PositionHandle handle = list_position->GetPosition();           

        // check if such a position exists
        PositionInfo *position_info;
        BOOL found = lookup_table.Lookup(handle, position_info);

        if ( found )
        {
            current_node = position_info->current_node;
            current_index = position_info->current_index;
            delete position_info;
        }
    }
}

void SnmpVarBindList::DestroyPosition(ListPosition *list_position)
{
    lookup_table.RemoveKey(list_position->GetPosition());
}

/*
void SnmpVarBindList::Print(ostrstream &s)
{
    SnmpVarBindListNode *current = head.GetNext();

    while ( current != &head )
    {
        // mark the current node
        if ( current == current_node )
            s << '*';
        current->GetVarBind()->GetInstance().Print(s);

        // separate varbinds
        s << '&';

        current = current->GetNext();
    }

    s << '|';   // shows that print has finished
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\wsess.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: wsess.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "wsess.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\vbl.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: vbl.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include <typeinfo.h>
#include "common.h"
#include "encap.h"
#include "vbl.h"
#include <winsock.h>

#define IP_ADDR_LEN 4
#define BYTE_SIZE 8
#define BYTE_ON_FLAG 255

VBList::VBList(

    IN SnmpEncodeDecode &a_SnmpEncodeDecode , 
    IN SnmpVarBindList &var_bind_list ,
    IN ULONG index
) : var_bind_list ( NULL )
{
    m_Index = index ;

    VBList::var_bind_list = &var_bind_list;

    // Extract session from EncodeDecode object

    WinSNMPSession t_Session = NULL ;

    SnmpV1EncodeDecode *t_SnmpV1EncodeDecode = dynamic_cast<SnmpV1EncodeDecode *>(&a_SnmpEncodeDecode);
    if ( t_SnmpV1EncodeDecode )
    {
        t_Session = ( HSNMP_SESSION ) t_SnmpV1EncodeDecode->GetWinSnmpSession () ;
    }
    else
    {
        SnmpV2CEncodeDecode *t_SnmpV2CEncodeDecode = dynamic_cast<SnmpV2CEncodeDecode *>(&a_SnmpEncodeDecode);
        if ( t_SnmpV2CEncodeDecode )
        {
            t_Session = ( HSNMP_SESSION ) t_SnmpV2CEncodeDecode->GetWinSnmpSession () ;
        }
        else
        {
            throw ;
        }
    }
}

// the VarBindList and the WinSnmpVbl are indexed differently.
//     [0..(length-1)]     [1..length]
// the parameter index refers to the WinSnmpVbl index
SnmpVarBind *VBList::Get(IN UINT vbl_index)
{
    UINT length = var_bind_list->GetLength();

    if ( vbl_index > length )
        return NULL;

    SnmpVarBind *var_bind = new SnmpVarBind(*((*var_bind_list)[vbl_index-1]));

    return var_bind;
}


// the VarBindList and the WinSnmpVbl are indexed differently.
//     [0..(length-1)]     [1..length]
// the parameter index refers to the WinSnmpVbl index
SnmpVarBind *VBList::Remove(IN UINT vbl_index)
{
    UINT length = var_bind_list->GetLength();

    if ( vbl_index > length )
        return NULL;

    SnmpVarBind *var_bind = new SnmpVarBind(*((*var_bind_list)[vbl_index-1]));

    var_bind_list->Remove();

    return var_bind;
}

// the VarBindList and the WinSnmpVbl are indexed differently.
//     [0..(length-1)]     [1..length]
// the parameter index refers to the WinSnmpVbl index
void VBList::Delete(IN UINT vbl_index)
{
    UINT length = var_bind_list->GetLength();

    if ( vbl_index > length )
        return ;

    var_bind_list->Remove();

}

VBList::~VBList(void) 
{ 
    delete var_bind_list;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\window.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: window.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include "common.h"
#include "timer.h"
#include "window.h"


extern HINSTANCE g_hInst ;

WindowMapping Window::mapping;

CriticalSection Window::window_CriticalSection;

UINT Window :: g_TimerMessage = SNMP_WM_TIMER ;
UINT Window :: g_SendErrorEvent = SEND_ERROR_EVENT ;
UINT Window :: g_OperationCompletedEvent = OPERATION_COMPLETED_EVENT ;
UINT Window :: g_MessageArrivalEvent = MESSAGE_ARRIVAL_EVENT ;
UINT Window :: g_SentFrameEvent = SENT_FRAME_EVENT ;
UINT Window :: g_NullEventId = NULL_EVENT_ID ;
UINT Window :: g_DeleteSessionEvent = DELETE_SESSION_EVENT ;

Window::Window ( 

    char *templateCode, 
    BOOL display 
) : window_handle ( NULL )
{
    // is invalid
    is_valid = FALSE;

    // initialize the window

    Initialize (

        templateCode, 
        HandleGlobalEvent, 
        display
    ) ;

    // if handle is null, return

    if ( window_handle == NULL )
        return;

    is_valid = TRUE;
}

LONG_PTR CALLBACK WindowsMainProc (

    HWND hWnd, 
    UINT message ,
    WPARAM wParam ,
    LPARAM lParam
)
{
    return DefWindowProc(hWnd, message, wParam, lParam);
}

BOOL Window::CreateCriticalSection ()
{
    return TRUE ;
}

void Window::DestroyCriticalSection()
{
}


void Window::Initialize (

    char *templateCode, 
    WNDPROC EventHandler,
    BOOL display
)
{
    WNDCLASS  wc ;
 
    wc.style            = CS_HREDRAW | CS_VREDRAW ;
    wc.lpfnWndProc      = EventHandler ;
    wc.cbClsExtra       = 0 ;
    wc.cbWndExtra       = 0 ;
    wc.hInstance        = g_hInst ;
    wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
    wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
    wc.lpszMenuName     = NULL ;
    wc.lpszClassName    = L"templateCode" ;
 
    ATOM winClass = RegisterClass ( &wc ) ;

    if ( ! winClass ) 
    {
        DWORD t_GetLastError = GetLastError () ;

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Window::Initialise: Error = %lx\n" , t_GetLastError 
    ) ;
)

    }

    window_handle = CreateWindow (

        L"templateCode" ,              // see RegisterClass() call
        L"templateCode" ,                      // text for window title bar
        WS_OVERLAPPEDWINDOW ,               // window style
        CW_USEDEFAULT ,                     // default horizontal position
        CW_USEDEFAULT ,                     // default vertical position
        CW_USEDEFAULT ,                     // default width
        CW_USEDEFAULT ,                     // default height
        NULL ,                              // overlapped windows have no parent
        NULL ,                              // use the window class menu
        g_hInst,                            // instance (0 is used)
        NULL                                // pointer not needed
    ) ;

    if ( window_handle == NULL )
        return;

    // obtain lock
    CriticalSectionLock lock(window_CriticalSection);   

    // if cannot obtain lock, destroy the window
    // since the window cannot be registered, future messages to
    // it cannot be passed to it for processing
    if ( !lock.GetLock(INFINITE) )
    {
        DestroyWindow(window_handle);
        window_handle = NULL;
        return;
    }

    // register the window with the mapping 
    // (HWND,event_handler)
    mapping[window_handle] = this;

    // release lock
    lock.UnLock();

    if ( display == TRUE )
    {
        ShowWindow ( window_handle , SW_SHOW ) ;
    }
}

BOOL Window::InitializeStaticComponents()
{
    return CreateCriticalSection();
}

void Window::DestroyStaticComponents()
{
    DestroyCriticalSection();
}

// it determines the corresponding EventHandler and calls it
// with the appropriate parameters
LONG_PTR CALLBACK Window::HandleGlobalEvent (

    HWND hWnd ,
    UINT message ,
    WPARAM wParam ,
    LPARAM lParam
)
{
    LONG_PTR rc = 0 ;

    // send timer events to the Timer

    if ( message == WM_TIMER )
    {
#if 1
        UINT timerId = ( UINT ) wParam ;
        SnmpTimerObject *timerObject ;

        CriticalSectionLock session_lock(Timer::timer_CriticalSection);

        if ( !session_lock.GetLock(INFINITE) )
            throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;


        if ( SnmpTimerObject :: timerMap.Lookup ( timerId , timerObject ) )
        {
            SnmpTimerObject :: TimerNotification ( timerObject->GetHWnd () , timerId ) ;
        }
        else
        {
        }
#else

        UINT timerId = ( UINT ) wParam ;
        SnmpTimerObject *timerObject ;

        CriticalSectionLock session_lock(Timer::timer_CriticalSection);

        if ( !session_lock.GetLock(INFINITE) )
            throw GeneralException ( Snmp_Error , Snmp_Local_Error,__FILE__,__LINE__ ) ;

        if ( SnmpTimerObject :: timerMap.Lookup ( timerId , timerObject ) )
        {
            Timer::HandleGlobalEvent(timerObject->GetHWnd (), Timer :: g_SnmpWmTimer, timerId, lParam);
        }
        else
        {
        }

#endif
        return rc ;
    }

    if ( message == Timer :: g_SnmpWmTimer )
    {
        Timer::HandleGlobalEvent(
            hWnd, 
            message, 
            wParam, 
            (DWORD)lParam
            );
        return rc;
    }

    Window *window;

    // obtain lock
    CriticalSectionLock lock(window_CriticalSection);   

    // if cannot obtain lock, print a debug error message
    // and return
    if ( !lock.GetLock(INFINITE) )
    {

DebugMacro4( 

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

        __FILE__,__LINE__,
        L"Window::HandleGlobalEvent: ignoring window message (unable to obtain lock)\n"
    ) ;
)
        return rc;
    }

    BOOL found = mapping.Lookup(hWnd, window);

    // release lock
    lock.UnLock();

    // if no such window, return
    if ( !found )
        return DefWindowProc(hWnd, message, wParam, lParam);

    // let the window handle the event
    return window->HandleEvent(hWnd, message, wParam, lParam);
}

// calls the default handler
// a deriving class may override this, but
// must call this method explicitly for default
// case handling

LONG_PTR Window::HandleEvent (

    HWND hWnd ,
    UINT message ,
    WPARAM wParam ,
    LPARAM lParam
)
{
    return DefWindowProc ( hWnd , message , wParam , lParam );
}

Window::~Window(void)
{
    if ( window_handle != NULL )
    {

        // obtain lock
        CriticalSectionLock lock(window_CriticalSection);   

        if ( lock.GetLock(INFINITE) )
        {
            mapping.RemoveKey(window_handle);
        }

        // release lock
        lock.UnLock();

        DestroyWindow(window_handle);
        UnregisterClass ( L"templateCode" , 0 ) ;

    }
}

BOOL Window::PostMessage(

    UINT user_msg_id,
    WPARAM wParam, 
    LPARAM lParam
)
{
    return ::PostMessage(GetWindowHandle(), user_msg_id, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\value.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: value.cpp
Written By: B.Rajeev
----------------------------------------------------------*/

#include "precomp.h"
#include <typeinfo.h>
#include "common.h"
#include "address.h"
#include "value.h"

#define MAX_FIELDS 100
#define FIELD_SEPARATOR '.'

BOOL SnmpNull :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = TRUE;
    }

    return bResult;
}


// Copy constructor
SnmpInteger::SnmpInteger ( IN const SnmpInteger &value )
{
    val = value.GetValue();
}

BOOL SnmpInteger :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpInteger &)value);
    }

    return bResult;
}

LONG SnmpInteger::GetValue () const
{ 
    return val; 
}

void SnmpInteger::SetValue ( IN const LONG value ) 
{ 
    val = value; 
}

SnmpValue *SnmpInteger::Copy () const 
{ 
    return new SnmpInteger(val);
}

// Copy constructor
SnmpGauge::SnmpGauge ( IN const SnmpGauge &value )
{
    val = value.GetValue();
}

BOOL SnmpGauge :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpGauge &)value);
    }

    return bResult;
}

ULONG SnmpGauge::GetValue () const
{ 
    return val; 
}

void SnmpGauge::SetValue ( IN const ULONG value ) 
{ 
    val = value; 
}

SnmpValue *SnmpGauge::Copy () const 
{ 
    return new SnmpGauge(val);
}

// Copy constructor
SnmpCounter::SnmpCounter ( IN const SnmpCounter &value )
{
    val = value.GetValue();
}

BOOL SnmpCounter :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpCounter &)value);
    }

    return bResult;
}

ULONG SnmpCounter::GetValue () const
{ 
    return val; 
}

void SnmpCounter::SetValue ( IN const ULONG value ) 
{ 
    val = value; 
}

SnmpValue *SnmpCounter::Copy () const 
{ 
    return new SnmpCounter(val);
}

// Copy constructor
SnmpTimeTicks::SnmpTimeTicks ( IN const SnmpTimeTicks &value )
{
    val = value.GetValue();
}

BOOL SnmpTimeTicks :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpTimeTicks &)value);
    }

    return bResult;
}

ULONG SnmpTimeTicks::GetValue () const
{ 
    return val; 
}

void SnmpTimeTicks::SetValue ( IN const ULONG value ) 
{ 
    val = value; 
}

SnmpValue *SnmpTimeTicks::Copy () const 
{ 
    return new SnmpTimeTicks(val);
}

void SnmpOctetString::OverWrite(IN const UCHAR *value)
{
    if ( value && length )
    {
        memcpy(val, value, sizeof(UCHAR)*length);
    }
}

void SnmpOctetString::Initialize(IN const UCHAR *value, IN const ULONG valueLength)
{
    is_valid = FALSE;

    if ( (value == NULL) && (valueLength != 0) )
        return;

    length = valueLength;
    val = Replicate(value, valueLength);
    is_valid = TRUE;
}


void SnmpOctetString::UnReplicate(UCHAR *value)
{
    if ( is_valid == TRUE )
        delete[] val;
}

SnmpOctetString::SnmpOctetString ( IN const UCHAR *value , IN const ULONG valueLength ) : is_valid ( FALSE )
{       
    Initialize(value, valueLength);
}

SnmpOctetString::SnmpOctetString ( IN const SnmpOctetString &value ) : is_valid ( FALSE )
{
    Initialize(value.GetValue(), value.GetValueLength());
}

SnmpOctetString::~SnmpOctetString ()
{
    UnReplicate(val);
}


ULONG SnmpOctetString::GetValueLength () const 
{ 
    return length; 
}

UCHAR *SnmpOctetString::GetValue () const 
{ 
    return val; 
}

SnmpValue *SnmpOctetString::Copy () const 
{
    return new SnmpOctetString(val, length);
}
    
UCHAR *SnmpOctetString::Replicate(IN const UCHAR *value, IN const ULONG valueLength)
{
    if ( value )
    {
        UCHAR *temp = new UCHAR[valueLength];

        memcpy(temp, value, sizeof(UCHAR)*valueLength);

        return temp;
    }
    else
    {
        return NULL ;
    }
}

void SnmpOctetString::SetValue ( IN const UCHAR *value , IN const ULONG valueLength )
{
    if (length != valueLength)
    {
        UnReplicate(val);
        Initialize(value, valueLength);
    }
    else
        OverWrite(value);
}

BOOL SnmpOctetString :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpOctetString &)value);
    }

    return bResult;
}

BOOL SnmpOctetString::Equivalent(IN const SnmpOctetString &snmp_octet_string) const
{
    if ( is_valid && snmp_octet_string() )
    {
        if ( length != snmp_octet_string.GetValueLength() )
            return FALSE;

        UCHAR *octet_values = snmp_octet_string.GetValue();

        for( UINT i=0; i < length; i++)
        {
            if ( val[i] != octet_values[i] )
                return FALSE;
        }

        return TRUE;
    }
    else
        return FALSE;
}

void SnmpObjectIdentifier::OverWrite(IN const ULONG *value)
{
    if ( value )
    {
        memcpy(val, value, sizeof(ULONG)*length);
    }
}

void SnmpObjectIdentifier::Initialize(IN const ULONG *value, IN const ULONG valueLength)
{   
    if ( ( (value == NULL) && (valueLength != 0) ) || ( valueLength == 0 ) )
    {
        length = 0 ;
        val = NULL ;
        return;
    }

    length = valueLength;

    if ( length <= DEFAULT_OBJECTIDENTIFIER_LENGTH )
    {
        val = m_value ;
        memcpy(val , value, sizeof(ULONG)*length);
        is_valid = TRUE;

    }
    else
    {
        val = new ULONG[length];
        memcpy(val , value, sizeof(ULONG)*length);
        is_valid = TRUE;
    }
}

void SnmpObjectIdentifier::UnReplicate(ULONG *value)
{
    if ( ( is_valid == TRUE ) & ( length > DEFAULT_OBJECTIDENTIFIER_LENGTH ) )
    {
        delete[] val;
    }
}

SnmpObjectIdentifier::SnmpObjectIdentifier ( IN const ULONG *value , IN const ULONG valueLength ) : val ( NULL ) , length ( 0 ) , is_valid ( TRUE ) 
{   
    Initialize(value, valueLength);
}

SnmpObjectIdentifier::SnmpObjectIdentifier ( IN const SnmpObjectIdentifier &value ) : val ( NULL ) , length ( 0 ) , is_valid ( TRUE ) 
{
    Initialize(value.GetValue(), value.GetValueLength());
}

SnmpObjectIdentifier::~SnmpObjectIdentifier ()
{
    UnReplicate(val);
}

ULONG SnmpObjectIdentifier::GetValueLength () const 
{ 
    return length; 
}

ULONG *SnmpObjectIdentifier::GetValue () const 
{ 
    return val; 
}

SnmpValue *SnmpObjectIdentifier::Copy () const 
{
    return new SnmpObjectIdentifier(val, length);
}

        
ULONG *SnmpObjectIdentifier::Replicate(IN const ULONG *value, IN const ULONG valueLength) const
{
    if ( value )
    {
        ULONG *temp = new ULONG[valueLength];
        memcpy(temp, value, sizeof(ULONG)*valueLength);
        return temp;
    }
    else
    {
        return NULL ;
    }
}

        
ULONG *SnmpObjectIdentifier::Replicate(IN const ULONG *first_value, 
                                       IN const ULONG first_length,
                                       IN const ULONG *second_value,
                                       IN const ULONG second_length) const
{
    if ( first_value && second_value )
    {
        ULONG new_length = first_length + second_length;
        ULONG *temp = new ULONG[new_length];
            
        int first_value_size = sizeof(ULONG)*first_length;

        memcpy(temp, first_value, first_value_size);
        memcpy(temp + first_length, second_value, 
                    sizeof(ULONG)*second_length);
        return temp;
    }
    else if ( first_value )
    {
        ULONG *temp = new ULONG [ first_length];
        memcpy(temp, first_value, sizeof(ULONG)*first_length);
        return temp;
    }
    else if ( second_value )
    {
        ULONG *temp = new ULONG [ second_length];
        memcpy(temp, second_value, sizeof(ULONG)*second_length);
        return temp;

    }
    else
    {
        return NULL ;
    }
}


SnmpObjectIdentifier::Comparison SnmpObjectIdentifier::Compare(IN const SnmpObjectIdentifier &first, 
                                                               IN const SnmpObjectIdentifier &second) const
{
    ULONG *first_string = first.GetValue();
    ULONG *second_string = second.GetValue();
    int first_length = first.GetValueLength();
    int second_length = second.GetValueLength();
    int min_length = MIN(first_length,second_length);

    for(int i=0; i < min_length; i++)
    {
        if ( first_string[i] < second_string[i] )
            return LESS_THAN;
        else if ( first_string[i] > second_string[i] )
            return GREATER_THAN;
        else
            continue;
    }

    if ( first_length < second_length )
        return LESS_THAN;
    else if ( first_length > second_length )
            return GREATER_THAN;
    else
        return EQUAL_TO;
}

void SnmpObjectIdentifier::SetValue ( IN const ULONG *value , IN const ULONG valueLength )
{
    if (valueLength)
    {
        if ( length != valueLength)
        {
            UnReplicate(val);
            Initialize(value, valueLength);
        }
        else
        {
            OverWrite(value);
        }
    }
    else
    {
        UnReplicate(val);
        val = NULL ;
        length = 0 ;
    }
}

// A null terminated dot-separated string representing the 
// object identifer value is passed and the private fields
// and length are set from it
SnmpObjectIdentifier::SnmpObjectIdentifier(IN const char *value)
{
    is_valid = FALSE;

    UINT str_len = strlen(value);
    if ( str_len <= 0 )
        return;

    ULONG temp_field[MAX_FIELDS];

    // create an input stream from the string
    istrstream input_stream((char *)value);

    // consecutive fields must be separated by a
    // FIELD_SEPARATOR
    char separator;

    input_stream >> temp_field[0];

    if ( input_stream.bad() || input_stream.fail() )
        return;

    // while the stream still has something,
    // read (FIELD_SEPARATOR, ULONG) pairs from the input stream
    // and set the temp_fields
    // check if the read was bad or failed after the event
    for( int i = 1 ; (i < MAX_FIELDS) && (!input_stream.eof()); i++)
    {
        input_stream >> separator;

        if ( input_stream.bad() || input_stream.fail() )
            return;

        if ( separator != FIELD_SEPARATOR )
            return;

        input_stream >> temp_field[i];
 
        if ( input_stream.bad() || input_stream.fail() )
            return;
    }

    is_valid = TRUE;

    // set the length
    length = i;
    val = NULL ;

    // create memory for the fields and copy temp_fields into it
    Initialize(temp_field, length);
}


BOOL SnmpObjectIdentifier::Equivalent(IN const SnmpObjectIdentifier &value,
                                       IN ULONG max_length) const
{
    if ( (!is_valid) || (!value()) )
        return FALSE;

    if ( (length < max_length) || (value.GetValueLength() < max_length) )
        return FALSE;

    ULONG *value_string = value.GetValue();

    for( UINT i=0; i < max_length; i++ )
        if ( val[i] != value_string[i] )
            return FALSE;

    return TRUE;
}

BOOL SnmpObjectIdentifier::Equivalent(IN const SnmpObjectIdentifier &value) const
{
    if ( (!is_valid) || (!value()) )
        return FALSE;

    ULONG *value_string = value.GetValue();

    for( UINT i=length; i ; i-- )
    {
        if ( val[i-1] != value_string[i-1] )
            return FALSE;
    }

    return TRUE;
}

BOOL SnmpObjectIdentifier :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpObjectIdentifier &)value);
    }

    return bResult;
}

SnmpObjectIdentifier SnmpObjectIdentifier::operator+ ( IN const SnmpObjectIdentifier &value ) const
{   
    ULONG *temp_plus_array = Replicate(val, length, value.GetValue(), value.GetValueLength());

    SnmpObjectIdentifier local_identifier(temp_plus_array, length+value.GetValueLength());
    delete[] temp_plus_array;

    return SnmpObjectIdentifier(local_identifier);
}

// Determines the fields (starting from left), common to the
// two object identifiers and returns a new object identifier
// with only these fields. If nothing is shared, NULL is returned
SnmpObjectIdentifier *SnmpObjectIdentifier::Cut( SnmpObjectIdentifier &value ) const
{
    // determine the smaller of the two lengths
    int min_length = MIN(length, value.GetValueLength());
    ULONG *other_field = value.GetValue();

    // compare the fields
    for(int index=0; index < min_length; index++)
        if ( val[index] != other_field[index] )
            break;

    // if nothing in common - return NULL
    if ( index == 0 )
        return NULL;

    // they must have the fields in the range [0..(index-1)] common
    // therefore, a common length of "index"
    return new SnmpObjectIdentifier(other_field, index);
}


ULONG &SnmpObjectIdentifier::operator [] ( IN const ULONG index ) const
{
    if ( index < length )
        return val[index];

    // should never reach here if the user checks the
    // index value before
    return val[0];
}

//returns an allocated char* representation of the OID.
//The return value  must be freed by the caller i.e. delete []
char *SnmpObjectIdentifier::GetAllocatedString() const
{
    char * retVal = NULL ;

    if (length)
    {
        retVal = new char [ length * 18 ] ;
        ostrstream s ( retVal , length * 18 ) ;
        s << val[0];
        UINT i = 1;
        char dot = '.';

        while (i < length)
        {
            s << dot << val[i++] ;
        }
        
        s << ends ;
    }

    return retVal;
}
        

SnmpIpAddress::SnmpIpAddress ( IN const char *value )
{
    // create a stream to read the fields from
    istrstream address_stream((char *)value);

    // store the values [0..255] separated by FIELD_SEPARATORs
    // in the value string
    UCHAR field[SNMP_IP_ADDR_LEN];

    // contains the maximum value for a UCHAR. used
    // for comparison with the field values read
    const UCHAR max_uchar = -1;

    // consecutive fields must be separated by a
    // FIELD_SEPARATOR
    char separator;

    // a field is first read into this for comparison
    // with max_uchar
    ULONG temp_field;

    is_valid = FALSE;

    // read the first three (UCHAR,FIELD_SEPARATOR) pairs
    // check if the stream is good before each read
    for(int i=0; i < (SNMP_IP_ADDR_LEN-1); i++)
    {
        if ( !address_stream.good() )
            return;

        address_stream >> temp_field;
        if ( temp_field > max_uchar )
            return;

        field[i] = (UCHAR)temp_field;

        if ( !address_stream.good() )
            return;

        address_stream >> separator;
        if ( separator != FIELD_SEPARATOR )
            return;
    }

    if ( !address_stream.good() )
        return;

    address_stream >> temp_field;
    if (temp_field > max_uchar)
        return;

    field[SNMP_IP_ADDR_LEN-1] = (UCHAR)temp_field;

    // make sure that there are is nothing more left in the
    // stream
    if ( !address_stream.eof() )
        return;

    ULONG byteA = field [ 0 ] ;
    ULONG byteB = field [ 1 ] ;
    ULONG byteC = field [ 2 ] ;
    ULONG byteD = field [ 3 ] ;

    val = ( byteA << 24 ) + ( byteB << 16 ) + ( byteC << 8 ) + byteD ;

    is_valid = TRUE;
}


// Copy constructor
SnmpIpAddress::SnmpIpAddress ( IN const SnmpIpAddress &value )
{
    if ( value() )
    {
        val = value.GetValue();
        is_valid = TRUE;
    }
    else
        is_valid = FALSE;
}

BOOL SnmpIpAddress :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpIpAddress &)value);
    }

    return bResult;
}


ULONG SnmpIpAddress::GetValue () const
{ 
    return val; 
}

void SnmpIpAddress::SetValue ( IN const ULONG value ) 
{ 
    val = value;
    is_valid = TRUE;
}

SnmpValue *SnmpIpAddress::Copy () const 
{ 
    return new SnmpIpAddress(val);
}

// Copy constructor
SnmpUInteger32::SnmpUInteger32 ( IN const SnmpUInteger32 &value )
{
    val = value.GetValue();
}

ULONG SnmpUInteger32::GetValue () const
{ 
    return val; 
}

void SnmpUInteger32::SetValue ( IN const ULONG value ) 
{ 
    val = value; 
}

SnmpValue *SnmpUInteger32::Copy () const 
{ 
    return new SnmpUInteger32(val);
}

BOOL SnmpUInteger32 :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpUInteger32 &)value);
    }

    return bResult;
}

// Copy constructor
SnmpCounter64::SnmpCounter64( IN const SnmpCounter64 &value )
{
    lval = value.GetLowValue();
    hval = value.GetHighValue();
}

ULONG SnmpCounter64::GetLowValue () const
{ 
    return lval; 
}

ULONG SnmpCounter64::GetHighValue () const
{ 
    return hval; 
}

void SnmpCounter64::SetValue ( IN const ULONG lvalue , IN const ULONG hvalue ) 
{ 
    lval = lvalue; 
    hval = hvalue ;
}

SnmpValue *SnmpCounter64::Copy () const 
{ 
    return new SnmpCounter64(lval,hval);
}

BOOL SnmpCounter64 :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpCounter64 &)value);
    }

    return bResult;
}

BOOL SnmpNoSuchInstance :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = TRUE;
    }

    return bResult;
}

BOOL SnmpNoSuchObject :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = TRUE;
    }

    return bResult;
}

BOOL SnmpEndOfMibView :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = TRUE;
    }

    return bResult;
}

BOOL SnmpOpaque :: Equivalent (IN const SnmpValue &value) const
{
    BOOL bResult = FALSE;

    if (typeid(*this) == typeid(value))
    {
        bResult = Equivalent((const SnmpOpaque &)value);
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\dummy.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: dummy.hpp

Written By:	B.Rajeev

Purpose: 

Provides a derivative of the WinSnmpSession class for the SnmpImpSession
class for manipulating WinSnmp information and processing Windows
messages
-----------------------------------------------------------------*/

#ifndef __DUMMY_SESSION__
#define __DUMMY_SESSION__

#include "forward.h"
#include "wsess.h"
#include "reg.h"

class SessionWindow : public Window
{
	SnmpImpSession &owner;

	// over-rides the HandlerEvent method provided by the
	// WinSnmpSession. Alerts the owner of a sent frame event
	
	LONG_PTR HandleEvent (

		HWND hWnd ,
		UINT message ,
		WPARAM wParam ,
		LPARAM lParam
	);

public:

	SessionWindow (

		IN SnmpImpSession &owner
	
	) : owner(owner) {}

	~SessionWindow () {}

};


#endif // __DUMMY_SESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\address.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*-----------------------------------------------------------------
Filename: address.hpp

Written By:	B.Rajeev

Purpose: 

Provides an abstract class SnmpTransportAddress for manipulating
SNMP transport address information. The class SnmpTransportIpAddress
provides an implementation of the abstract class for IP addresses
-----------------------------------------------------------------*/

#ifndef __ADDRESS__
#define __ADDRESS__

// an IP address is specified using these many UCHAR fields
#define SNMP_IP_ADDR_LEN 4
#define SNMP_IPX_ADDR_LEN 10
#define SNMP_IPX_NETWORK_LEN 4
#define SNMP_IPX_STATION_LEN 6

// behaviour of ip address resolution

#define SNMP_ADDRESS_RESOLVE_VALUE 1
#define SNMP_ADDRESS_RESOLVE_NAME 2

// The SNMP transport information is defined by this abstract class
// since this class may not be instantiated, the copy constructor
// and the "=" operators have been made private and give null definitions
class DllImportExport SnmpTransportAddress
{  
private: 

	// should not be called - returns itself
	SnmpTransportAddress & operator= ( IN const SnmpTransportAddress &address ) 
	{
		return *this;
	}

	// private copy constructor
	SnmpTransportAddress(IN const SnmpTransportAddress &address) {}

protected:

	// protected constructor
	SnmpTransportAddress () {}

public:

	virtual ~SnmpTransportAddress () {}
    	    
	virtual BOOL IsValid () const = 0;

	virtual SnmpTransportAddress *Copy () const  = 0;

	// enables indexing a particular UCHAR field of the address
	virtual UCHAR operator [] ( IN const USHORT  index ) const  = 0;

	// copies the UCHAR fields describing the address onto the OUT UCHAR *
	// parameter. atmost the specified USHORT fields are copied and the
	// number of copied fields is returned
	virtual USHORT GetAddress ( OUT UCHAR * , IN const  USHORT ) const  = 0;

	// returns the number of UCHAR fields currently describing the address
	virtual USHORT GetAddressLength () const  = 0;

	// returns a character string representation of the address
	virtual char *GetAddress () = 0;

	virtual operator void *() const = 0;

	virtual void *operator()(void) const  = 0;
} ;

// provides an implementation of the SnmpTransportAddress for IP addresses
class DllImportExport SnmpTransportIpAddress : public SnmpTransportAddress
{
private:                           

	BOOL is_valid;
	UCHAR field[SNMP_IP_ADDR_LEN];

	// the dotted notation character string representation of the address
	// is constructed on demand and stored in the field 'dotted_notation'
	// the field 'allocated' is flagged 'dotted_notation' points to
	// allocated memory
	BOOL allocated;
	char *dotted_notation;

	BOOL GetIpAddress ( IN const char *address ) ;

public:

	SnmpTransportIpAddress ( IN  const UCHAR *address, IN const USHORT address_length );	

	SnmpTransportIpAddress ( IN const char *address, IN const ULONG addressResolution = SNMP_ADDRESS_RESOLVE_VALUE );

	// the input parameter 'address' contains a single value (32bits) to
	// be stored internally in SNMP_IP_ADDR_LEN UCHAR fields
	SnmpTransportIpAddress ( IN const ULONG address );

	SnmpTransportIpAddress ( IN const SnmpTransportIpAddress &address )	
	{
		allocated = FALSE;
		*this = address;
	}

	SnmpTransportIpAddress ()
	{
		is_valid = FALSE;
		allocated = FALSE;
	}

	~SnmpTransportIpAddress();

	USHORT GetAddress ( OUT UCHAR *address , IN const USHORT length ) const ;

	USHORT GetAddressLength () const	
	{ 
		return ((is_valid)?SNMP_IP_ADDR_LEN:0);
	}

    // memory for the decimal notation string is allocated only when
    // the char *GetAddress method is called (and the address is valid)
    // this memory must be freed if required
	char *GetAddress ();

	BOOL IsValid () const 	
	{
		return is_valid;
	}

	SnmpTransportAddress *Copy () const ;

	BOOL operator== ( IN const SnmpTransportIpAddress & address ) const ;

	BOOL operator!= ( IN const SnmpTransportIpAddress & address ) const 	
	{
		return !(*this==address);
	}

	SnmpTransportIpAddress & operator= ( IN const UCHAR *ipAddr ) ;
	SnmpTransportIpAddress & operator= ( IN const SnmpTransportIpAddress &address ); 
	UCHAR operator [] ( IN const USHORT index ) const ;

	void * operator()(void) const
	{
		return ( (is_valid==TRUE)?(void *)this:NULL );
	}

	operator void *() const
	{
		return SnmpTransportIpAddress::operator()();
	}

	static BOOL ValidateAddress ( IN const char *address , IN const ULONG addressResolution = SNMP_ADDRESS_RESOLVE_VALUE ) ;

};

// provides an implementation of the SnmpTransportAddress for IP addresses
class DllImportExport SnmpTransportIpxAddress : public SnmpTransportAddress
{
private:                           

	BOOL is_valid;
	UCHAR field[SNMP_IPX_ADDR_LEN];

	// the dotted notation character string representation of the address
	// is constructed on demand and stored in the field 'dotted_notation'
	// the field 'allocated' is flagged 'dotted_notation' points to
	// allocated memory
	BOOL allocated;
	char *dotted_notation;

	BOOL GetIpxAddress ( IN const char *address ) ;

public:

	SnmpTransportIpxAddress ( IN  const UCHAR *address, IN const USHORT address_length );	

	SnmpTransportIpxAddress ( IN const char *address );

	SnmpTransportIpxAddress ( IN const SnmpTransportIpxAddress &address )	
	{
		allocated = FALSE;
		*this = address;
	}

	SnmpTransportIpxAddress ()
	{
		is_valid = FALSE;
		allocated = FALSE;
	}

	~SnmpTransportIpxAddress();

	USHORT GetAddress ( OUT UCHAR *address , IN const USHORT length ) const ;

	USHORT GetAddressLength () const	
	{ 
		return ((is_valid)?SNMP_IPX_ADDR_LEN:0);
	}

    // memory for the decimal notation string is allocated only when
    // the char *GetAddress method is called (and the address is valid)
    // this memory must be freed if required
	char *GetAddress ();

	BOOL IsValid () const 	
	{
		return is_valid;
	}

	SnmpTransportAddress *Copy () const ;

	BOOL operator== ( IN const SnmpTransportIpxAddress & address ) const ;

	BOOL operator!= ( IN const SnmpTransportIpxAddress & address ) const 	
	{
		return !(*this==address);
	}

	SnmpTransportIpxAddress & operator= ( IN const UCHAR *ipxAddr ) ;
	SnmpTransportIpxAddress & operator= ( IN const SnmpTransportIpxAddress &address ); 
	UCHAR operator [] ( IN const USHORT index ) const ;

	void * operator()(void) const
	{
		return ( (is_valid==TRUE)?(void *)this:NULL );
	}

	operator void *() const
	{
		return SnmpTransportIpxAddress::operator()();
	}

	static BOOL ValidateAddress ( IN const char *address ) ;
};



#endif // __ADDRESS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\encap.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: encap.hpp

Written By:	B.Rajeev

Purpose: Includes the winsnmp.h file and provides typedef 
		 declarations for some WinSnmp types.
-----------------------------------------------------------------*/

#ifndef __ENCAPSULATE__
#define __ENCAPSULATE__

#include <winsnmp.h>

typedef smiINT	WinSnmpInteger;
typedef smiINT32 WinSnmpInteger32;
typedef HSNMP_PDU WinSnmpPdu;
typedef HSNMP_VBL WinSnmpVbl;
typedef smiOCTETS WinSnmpOctetArray;



#endif // __ENCAPSULATE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\common.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: common.hpp
Purpose	: Provides common constant, typedef, macro and
		  exception declarations. 
Written By:	B.Rajeev
-----------------------------------------------------------------*/


#ifndef __COMMON__
#define __COMMON__

#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <provexpt.h>
#include <limits.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>
#include <winsnmp.h>
#include <objbase.h>

#define DllImport	__declspec( dllimport )
#define DllExport	__declspec( dllexport )

#ifdef SNMPCLINIT
#define DllImportExport DllExport
#else
#define DllImportExport DllImport
#endif

// maximum length of decimal dot notation addresses
#define MAX_ADDRESS_LEN			100

// end of string character
#define EOS '\0'

#define MIN(a,b) ((a<=b)?a:b)

// returns TRUE if i is in [min,max), else FALSE
#define BETWEEN(i, min, max) ( ((i>=min)&&(i<max))?TRUE:FALSE )

// a default community name
#define COMMUNITY_NAME "public"

// a default destination address is the loopback address
// this way we don't have to determine the local ip address
#define LOOPBACK_ADDRESS "127.0.0.1"

// for exception specification
#include "excep.h"

// provides typedefs that encapsulate the winSNMP types
#include "encap.h"

#include "sync.h"

#endif // __COMMON__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\error.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: error.hpp
Purpose	: To provide enumerated types for SNMP error 
		  and status. It also provides the declaration
		  of the SnmpErrorReport which encapsulates the
		  error and status values.
Written By:	B.Rajeev
-----------------------------------------------------------------*/

#ifndef __ERROR__
#define __ERROR__

// specifies legal Error values
enum SnmpError 
{
	Snmp_Success	= 0 ,
	Snmp_Error		= 1 ,
	Snmp_Transport	= 2
} ;

// specifies legal Status values
enum SnmpStatus
{
	Snmp_No_Error				= 0 ,
	Snmp_Too_Big				= 1 ,
	Snmp_No_Such_Name			= 2 ,
	Snmp_Bad_Value				= 3 ,
	Snmp_Read_Only				= 4 ,
	Snmp_Gen_Error				= 5 ,

	Snmp_No_Access				= 6 ,
	Snmp_Wrong_Type				= 7 ,
	Snmp_Wrong_Length			= 8 ,
	Snmp_Wrong_Encoding			= 9 ,
	Snmp_Wrong_Value			= 10 ,
	Snmp_No_Creation			= 11 ,
	Snmp_Inconsistent_Value		= 12 ,
	Snmp_Resource_Unavailable	= 13 ,
	Snmp_Commit_Failed			= 14 ,
	Snmp_Undo_Failed			= 15 ,
	Snmp_Authorization_Error	= 16 ,
	Snmp_Not_Writable			= 17 ,
	Snmp_Inconsistent_Name		= 18 ,

	Snmp_No_Response			= 19 ,
	Snmp_Local_Error			= 20 ,
	Snmp_General_Abort			= 21 
} ;


// Encapsulates the Error and Status values for an
// SNMP operation
// Provides Get and Set operations to set these values
// and check a 'void *' operator to check for error

class DllImportExport SnmpErrorReport
{
private:

	SnmpError error;
	SnmpStatus status;
	unsigned long int index ;

public:

	SnmpErrorReport () : error ( Snmp_Success ) , status ( Snmp_No_Error ) , index ( 0 ) {}

	SnmpErrorReport(IN const SnmpError error, IN const SnmpStatus status, IN const unsigned long int index = 0 )
		: error(error), status(status), index(index) 
	{}

	SnmpErrorReport(IN const SnmpErrorReport &error)
	{
		SnmpErrorReport::error = error.GetError();
		SnmpErrorReport::status = error.GetStatus();
		SnmpErrorReport::index = error.GetIndex () ;
	}

	virtual ~SnmpErrorReport() {}

	SnmpStatus GetStatus() const { return status; }
	SnmpError GetError() const { return error; }
	unsigned long int GetIndex () const { return index ; }

	void SetStatus(IN const SnmpStatus status)
	{
		SnmpErrorReport::status = status;
	}

	void SetError(IN const SnmpError error)
	{
		SnmpErrorReport::error = error;
	}

	void SetIndex ( IN const unsigned long int index ) 
	{
		SnmpErrorReport::index = index ;
	}

	void *operator()(void) const
	{
		return ((error == Snmp_Success)?(void *)this:NULL);
	}

	operator void *() const
	{
		return SnmpErrorReport::operator()();
	}
};



#endif // __ERROR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\encdec.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-------------------------------------------------------
filename: encdec.hpp
author: B.Rajeev
purpose: Provides declarations for the class PseudoSession.
-------------------------------------------------------*/

#ifndef __ENCODE_DECODE__
#define __ENCODE_DECODE__

#include "forward.h"
#include "error.h"

#define IP_ADDR_LEN 4
#define ILLEGAL_REQUEST_ID 0
typedef long RequestId;

class DllImportExport SnmpEncodeDecode
{
friend VBList;
friend SnmpImpTransport;
friend SnmpImpSession;
friend SnmpCommunityBasedSecurity;
friend SnmpClassLibrary;
friend TransportWindow;

protected:

	BOOL m_IsValid;

	void *m_Session;
	void *m_Window ;

	static CriticalSection s_CriticalSection;

	void *GetWinSnmpSession () { return m_Session ; }

	virtual void SetTranslateMode () = 0 ;

	static BOOL DestroyStaticComponents () ;
	static BOOL InitializeStaticComponents () ;

public:

	enum PduType {GET, GETNEXT, SET,GETBULK,RESPONSE };

	SnmpEncodeDecode ();

	virtual BOOL EncodeFrame (

		OUT SnmpPdu &a_SnmpPdu ,
		IN RequestId a_RequestId,
		IN PduType a_PduType,
		IN SnmpErrorReport &a_SnmpErrorReport ,
		IN SnmpVarBindList &a_SnmpVarBindList,
		IN SnmpCommunityBasedSecurity *&a_SnmpCommunityBasedSecuity ,
		IN SnmpTransportAddress *&a_SrcTransportAddress ,
		IN SnmpTransportAddress *&a_DstTransportAddress
	) ;

	virtual BOOL EncodeFrame (

		IN SnmpPdu &a_SnmpPdu ,
		OUT void *a_ImplementationEncoding 

	) ;

	virtual BOOL SetVarBindList (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpVarBindList &a_SnmpVarBindList

	) ;

	virtual BOOL SetCommunityName ( 

		IN SnmpPdu &a_SnmpPdu ,
		IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 
	
	) ;

	virtual BOOL SetErrorReport (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpErrorReport &a_SnmpErrorReport

	) ;

	virtual BOOL SetPduType (

		IN SnmpPdu &a_SnmpPdu ,
		OUT PduType a_PduType

	) ;

	virtual BOOL SetSourceAddress ( 

		IN OUT SnmpPdu &a_SnmpPdu ,
		IN SnmpTransportAddress &a_TransportAddress 

	) ;

	virtual BOOL SetDestinationAddress ( 

		IN OUT SnmpPdu &a_SnmpPdu ,
		IN SnmpTransportAddress &a_TransportAddress 

	) ;

	virtual BOOL SetRequestId (

		IN OUT SnmpPdu &a_SnmpPdu ,
		IN RequestId request_id

	) ;

	virtual BOOL DecodeFrame (

		IN SnmpPdu &a_SnmpPdu ,
		OUT RequestId a_RequestId,
		OUT PduType a_PduType ,
		OUT SnmpErrorReport &a_SnmpErrorReport ,
		OUT SnmpVarBindList *&a_SnmpVarBindList ,
		OUT SnmpCommunityBasedSecurity *&a_SnmpCommunityBasedSecurity ,
		OUT SnmpTransportAddress *&a_SrcTransportAddress ,
		OUT SnmpTransportAddress *&a_DstTransportAddress 

	) ;

	virtual BOOL DecodeFrame (

		IN void *a_ImplementationEncoding ,
		OUT SnmpPdu &a_SnmpPdu
	) ;

	virtual BOOL GetPduType (

		IN SnmpPdu &a_SnmpPdu ,
		OUT PduType &a_PduType 

	) ;

	virtual BOOL GetRequestId (

		IN SnmpPdu &a_SnmpPdu ,
		RequestId &a_RequestId

	) ;

	virtual BOOL GetErrorReport (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpErrorReport &a_SnmpErrorReport 

	) ;

	virtual BOOL GetCommunityName ( 

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 
	
	) ;

	virtual BOOL GetVarbindList (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpVarBindList &a_SnmpVarBindList

	) ;

	virtual BOOL GetSourceAddress ( 

		IN SnmpPdu &a_SnmpPdu ,
		SnmpTransportAddress *&a_TransportAddress

	) ;

	virtual BOOL GetDestinationAddress (

		IN SnmpPdu &a_SnmpPdu ,
		SnmpTransportAddress *&a_TransportAddress

	) ;

	virtual BOOL EncodePduFrame (

		OUT SnmpPdu &a_SnmpPdu ,
		IN RequestId a_RequestId,
		IN PduType a_PduType,
		IN SnmpErrorReport &a_SnmpErrorReport ,
		IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecuity ,
		IN SnmpVarBindList &a_SnmpVarBindList,
		IN SnmpTransportAddress &a_SrcTransportAddress ,
		IN SnmpTransportAddress &a_DstTransportAddress
	) ;

	virtual BOOL SetPduVarBindList (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpVarBindList &a_SnmpVarBindList

	) ;

	virtual BOOL SetPduCommunityName ( 

		IN SnmpPdu &a_SnmpPdu ,
		IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 
	
	) ;

	virtual BOOL SetPduErrorReport (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpErrorReport &a_SnmpErrorReport

	) ;

	virtual BOOL SetPduPduType (

		IN SnmpPdu &a_SnmpPdu ,
		OUT PduType a_PduType

	) ;

	virtual BOOL SetPduSourceAddress ( 

		IN OUT SnmpPdu &a_SnmpPdu ,
		IN SnmpTransportAddress &a_TransportAddress 

	) ;

	virtual BOOL SetPduDestinationAddress ( 

		IN OUT SnmpPdu &a_SnmpPdu ,
		IN SnmpTransportAddress &a_TransportAddress 

	) ;

	virtual BOOL SetPduRequestId (

		IN OUT SnmpPdu &a_SnmpPdu ,
		IN RequestId request_id

	) ;

	virtual BOOL DecodePduFrame (

		IN SnmpPdu &a_SnmpPdu ,
		OUT RequestId a_RequestId,
		OUT PduType a_PduType ,
		OUT SnmpErrorReport &a_SnmpErrorReport ,
		OUT SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity ,
		OUT SnmpVarBindList &a_SnmpVarBindList ,
		OUT SnmpTransportAddress *&a_SrcTransportAddress ,
		OUT SnmpTransportAddress *&a_DstTransportAddress 

	) ;

	virtual BOOL GetPduPduType (

		IN SnmpPdu &a_SnmpPdu ,
		OUT PduType &a_PduType 

	) ;

	virtual BOOL GetPduRequestId (

		IN SnmpPdu &a_SnmpPdu ,
		RequestId &a_RequestId

	) ;

	virtual BOOL GetPduErrorReport (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpErrorReport &a_SnmpErrorReport 

	) ;

	virtual BOOL GetPduCommunityName ( 

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 
	
	) ;

	virtual BOOL GetPduVarbindList (

		IN SnmpPdu &a_SnmpPdu ,
		OUT SnmpVarBindList &a_SnmpVarBindList

	) ;

	virtual BOOL GetPduSourceAddress ( 

		IN SnmpPdu &a_SnmpPdu ,
		SnmpTransportAddress *&a_TransportAddress

	) ;

	virtual BOOL GetPduDestinationAddress (

		IN SnmpPdu &a_SnmpPdu ,
		SnmpTransportAddress *&a_TransportAddress

	) ;


	virtual void *operator()() const
	{
		return ( m_IsValid ? (void *) this: NULL );
	}

	virtual ~SnmpEncodeDecode ();
};

class DllImportExport SnmpV1EncodeDecode : public SnmpEncodeDecode
{
friend VBList;
friend SnmpImpTransport;
friend SnmpImpSession;
friend SnmpCommunityBasedSecurity;

private:

	void InitializeVariables();

protected:

	void SetTranslateMode () ;
	
public:

	SnmpV1EncodeDecode () ;
	~SnmpV1EncodeDecode ();
};

class DllImportExport SnmpV2CEncodeDecode : public SnmpEncodeDecode
{
private:

	// initializes the pdu
	void InitializeVariables();

protected:

	void SetTranslateMode () ;

public:

	SnmpV2CEncodeDecode () ;
	~SnmpV2CEncodeDecode ();
};

#endif // __ENCODE_DECODE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\excep.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: encap.hpp

Written By:	B.Rajeev

Purpose: The GeneralException is thrown on encountering situations
such as an errored call to the WinSNMP library and mutex/timer calls.
It encapsulates the SnmpErrorReport since that is the vehicle for exchange
of error information for SNMPCL objects 
-----------------------------------------------------------------*/

#ifndef __EXCEPTION__
#define __EXCEPTION__

#include "error.h"


// This exception is used to convey the error and status
// for exception error situations to the calling methods
class DllImportExport GeneralException: public SnmpErrorReport
{
private:

	int line ;
	char *file ;
	DWORD errorCode ;
	
public:
	GeneralException(IN const SnmpError error, IN const SnmpStatus status, char *fileArg = NULL , int lineArg = 0 , DWORD errorCodeArg = 0 )
		: SnmpErrorReport(error, status) , line ( lineArg ) , errorCode ( errorCodeArg ) 
	{
		file = fileArg ? _strdup ( fileArg ) : NULL ;
	}

	GeneralException(IN const SnmpErrorReport &error_report,char *fileArg = NULL , int lineArg = 0 , DWORD errorCodeArg = 0 )
		: SnmpErrorReport(error_report) , line ( lineArg ) , errorCode ( errorCodeArg ) 
	{
		file = fileArg ? _strdup ( fileArg ) : NULL ;
	}

	GeneralException(IN const GeneralException &exception )
		: SnmpErrorReport(exception)
	{
		line = exception.line ;
		errorCode = exception.errorCode ;
		file = exception.file ? _strdup ( exception.file ) : NULL ;
	}

	~GeneralException() { free ( file ) ; }

	int  GetLine () { return line ; }
	char *GetFile () { return file ; }

};


#endif // __EXCEPTION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\flow.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: address.hpp

Written By:	B.Rajeev

Purpose: Provides a flow control mechanism for the SnmpImpSession. 
-----------------------------------------------------------------*/

#ifndef __FLOW_CONTROL__
#define __FLOW_CONTROL__


#include "forward.h"
#include "common.h"

/*--------------------------------------------------
Overview:
--------

  MessageStore: Provides queue like access to a store of messages.
  In addition to the Enqueue, Dequeue primites, it also	enables
  deletion of specified messages from the queue.
				

  FlowControlMechanism: It encapsulates the flow control
  mechanism for the session. Once the window is full, incoming 
  messages are buffered. A reply triggers off further message 
  transmission until the window is full. If we give up on a 
  message after retrying a specified number of times, the flow
  control mechanism must be informed of it. It signals FlowControl
  On/Off (through callback methods), when the window limits are reached
--------------------------------------------------*/

// a CList is used to implement the message store
typedef CList<Message *, Message *> CListStore;

class MessageStore : private CListStore
{
#ifdef WANT_MFC
	DECLARE_DYNAMIC(MessageStore);
#endif
	
public:

    // Add to the end of the queue.
    void Enqueue( Message &new_message );

    // Remove and return the first element in the Store
    Message* Dequeue(void);

	// checks if the queue is empty
	BOOL IsEmpty(void)
	{
		return CListStore::IsEmpty();
	}

	// remove the message possessing the session_frame_id and return it
	Message *DeleteMessage(SessionFrameId session_frame_id);

	~MessageStore(void);
}; 

class FlowControlMechanism
{
	
	// the session providing the context for flow control
	SnmpImpSession *session;

	UINT outstanding_messages;

	// this value is specified by the session on creation
	UINT window_size;
	
	// provides queue like access to a store of messages
	MessageStore message_store;

	// obtains lock on the session CriticalSection before
	// calling TransmitMessage
	void TransmitMessageUnderProtection(Message *message);

	// creates a waiting message, registers it with the message
	// registry and lets it transmit
	void TransmitMessage(Message *message);

	// transmits messages in message store as long as
	// the window is open
	void ClearMessageStore(void);

public:

	// initializes the private variable
	FlowControlMechanism(SnmpImpSession &session, UINT window_size);


	// sends message if within the flow control window
	// else Stores it up
	void SendMessage(Message &message);

	// It removes the message frame from its message_Store
	void DeleteMessage(SessionFrameId session_frame_id);

	// this is called by a waiting_message indicating arrival
	// or by the message registry
	void NotifyReceipt(WaitingMessage &waiting_message, 
					   IN const SnmpPdu *snmp_pdu,
					   SnmpErrorReport &error_report);

	// this is called when the session does not need
	// to be informed, but the flow control window
	// must advance (such as frame cancellation)
	// also destroys the waiting_message
	void AdvanceWindow(WaitingMessage &waiting_message);
};


#endif // __FLOW_CONTROL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\forward.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-----------------------------------------------------------------
Filename: forward.hpp

Written By:	B.Rajeev

Purpose: Provides forward declarations for the types and classes of the
SNMP class library
-----------------------------------------------------------------*/

#ifndef __FORWARD__
#define __FORWARD__

// globally visible typedefs
typedef ULONG TransportFrameId;
typedef ULONG SessionFrameId;

typedef HANDLE Mutex;
typedef HANDLE Semaphore;

// forward declarations for the various classes

class MsgIdStore;
class Window;

class TransportSentStateStore;
class SnmpTransportAddress;
class SnmpTransportIpxAddress;
class SnmpTransportIpAddress;
class TransportSession;
class SnmpTransport;
class SnmpImpTransport;
class SnmpUdpIpTransport;
class SnmpUdpIpImp;
class SnmpIpxTransport;
class SnmpIpxImp;

class SnmpSession;
class SnmpImpSession;
class SnmpV1OverIp;
class SnmpV2COverIp;
class SnmpV1OverIpx;
class SnmpV2COverIpx;
class SnmpOperation;
class SnmpGetRequest;
class SnmpSetRequest;
class SnmpGetNextRequest;
class SnmpEncodeDecode ;
class SnmpV1EncodeDecode ;
class SnmpV2CEncodeDecode ;

class SnmpPdu;

class SecuritySession;
class SnmpSecurity;
class SnmpCommunityBasedSecurity;

class SnmpValue;
class SnmpNull;
class SnmpIpAddress;
class SnmpTimeTicks;
class SnmpGauge;
class SnmpOpaque;
class SnmpInteger;
class SnmpObjectIdentifier;
class SnmpOctetString;
class SnmpCounter;

class SnmpVarBind;
class SnmpVarBindList;

class OperationWindow ;
class SessionWindow;
class TransportWindow;
class OperationRegistry;
class SessionSentStateStore;
class IdMapping;
class SnmpPduBuffer;
class SessionWindow;
class Timer;
class MessageRegistry;
class FrameRegistry;
class EventHandler;
class FlowControlMechanism;
class Message;
class WaitingMessage;
class SnmpClassLibrary;
class FrameState;
class FrameStateRegistry;
class PseudoSession;
class OperationHelper;
class VBList;

class SnmpTrapManager;
class SnmpWinSnmpTrapSession;

// class ;

#endif // __FORWARD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\fs_reg.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------------
Filename: fs_reg.hpp
Author: B.Rajeev
Purpose: Provides declarations for the FrameState and the
		 FrameStateRegistry classes. 
--------------------------------------------------------*/


#ifndef __FRAME_STATE_REGISTRY
#define __FRAME_STATE_REGISTRY

#include "forward.h"
#include "common.h"
#include "vbl.h"

// The FrameState stores the state information pertaining to a Session Frame
// They may be reused, if the frame is retransmitted with modifications.
class FrameState
{
	// the session frame id may be used to cancel the frame or associate
	// a reply with the varbinds sent in the frame
	SessionFrameId session_frame_id;

	// This is a (winsnmp vbl, SnmpVarBindList) pair representing
	// the list of var binds sent in the session frame
	VBList *vblist;

public:

	FrameState(IN SessionFrameId session_frame_id, IN VBList &vblist);

	SessionFrameId GetSessionFrameId(void) { return session_frame_id; }

	// since, frames may be retransmitted (after updating the var bind list)
	// they may be reused, with a different session frame id
	void SetSessionFrameId(IN SessionFrameId session_frame_id)
	{
		FrameState::session_frame_id = session_frame_id;
	}

	VBList *GetVBList(void) { return vblist; }
	
	~FrameState(void);
};


typedef CMap< SessionFrameId, SessionFrameId &, FrameState *, FrameState *& > FrameStateMapping;


// The FrameStateRegistry stores the FrameStates for all outstanding
// session frames. It stores <session_frame_id, FrameState> pairs allowing insertion,
// removal and a destructive traversal.
// It is used to detect completion of an operation (when it becomes empty),
// to cancel all outstanding frames and access to individual frame states

class FrameStateRegistry
{
	// determines the security context for a SendRequest and applies
	// to all the frames (including rexns) carrying varbinds from the
	// specified SnmpVarBindList
	SnmpSecurity *security;

	// stores the FrameStates
	FrameStateMapping mapping;

	// points to the currrent position, enabling a traversal
	POSITION current_pointer;

public:

	FrameStateRegistry()
	{
		security = NULL;
		current_pointer = mapping.GetStartPosition();
	}

	~FrameStateRegistry();

	void Insert(IN SessionFrameId session_frame_id, IN FrameState &frame_state)
	{
		mapping[session_frame_id] = &frame_state;
	}

	FrameState *Remove(IN SessionFrameId session_frame_id);

	// doesn't remove the <session_frame_id, FrameState> association
	FrameState *Get(IN SessionFrameId session_frame_id);

	void ResetIterator(void)
	{
		current_pointer = mapping.GetStartPosition();
	}

	FrameState *GetNext(OUT SessionFrameId *session_frame_id = NULL);

	void RemoveAll(void)
	{
		mapping.RemoveAll();
	}

	BOOL Empty(void)
	{
		return mapping.IsEmpty();
	}

	BOOL End(void)
	{
		return ( (current_pointer==NULL)?TRUE:FALSE );
	}

	// we reuse the frame state registry over several operations
	// this method enables change in the security context
	void RegisterSecurity(IN SnmpSecurity *security);

	SnmpSecurity *GetSecurity() const;

	// destroys an existing security context 
	void DestroySecurity();
};


#endif // __FRAME_STATE_REGISTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\frame.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: frame.hpp
Author: B.Rajeev
Purpose: Provides declarations for the FrameRegistry class.
--------------------------------------------------*/


#ifndef __FRAME_REGISTRY__
#define __FRAME_REGISTRY__

#define ILLEGAL_SESSION_FRAME_ID 0

#include "forward.h"
#include "common.h"
#include "message.h"

typedef CMap<SessionFrameId, SessionFrameId, WaitingMessage *, WaitingMessage *> FrameMapping;

/*--------------------------------------------------
Overview:
---------

  FrameRegistry: Provides access to WaitingMessages in a store 
  through their SessionFrameId. 
  
	This enables cancellation of SendFrame request. The frame id
  is supplied by the calling SnmpOperation to the session.
  When the operation tries to cancel a SendFrame request,
  SnmpImpSession calls the CancelFrameNotification. This method
  informs the flow control mechanism of the event (which may 
  Deregister the waiting message erasing the 
  <SessionFrameId, WaitingMessage>association).
--------------------------------------------------*/

class FrameRegistry
{
	// it stores the waiting messages in the context of this session
	SnmpImpSession *session;  

	// used to generate session frame ids
	SessionFrameId next_session_frame_id;

	// stores pairs of the form <SessionFrameId, WaitingMessage *>
	FrameMapping mapping;

public:

	FrameRegistry(IN SnmpImpSession &session)
	{
		FrameRegistry::session = &session;
		next_session_frame_id = ILLEGAL_SESSION_FRAME_ID+1;
	}

	SessionFrameId GenerateSessionFrameId(void);

	void RegisterFrame(IN const SessionFrameId session_frame_id, IN WaitingMessage &waiting_message);

	void DeregisterFrame(IN const SessionFrameId session_frame_id);
	
	// returns NULL if no such waiting message
	WaitingMessage *GetWaitingMessage(IN const SessionFrameId session_frame_id);

	void CancelFrameNotification(IN const SessionFrameId session_frame_id);

	~FrameRegistry(void);
};


#endif // __FRAME_REGISTRY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\gen.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: gen.hpp
Author: B.Rajeev
Purpose: Generates IDs under the protection of a
		 CriticalSection. After each generation, the next_id 
		 variable is incremented and no attempt is 
		 made to generate unique ids. 
--------------------------------------------------*/

#ifndef __GEN__
#define __GEN__

#include "sync.h"

template <class IdType, UINT ILLEGAL_ID>
class ProtectedIdGenerator
{
	BOOL is_valid;
	IdType next_id;
	CriticalSection CriticalSection;

public:

	ProtectedIdGenerator(IdType start_id);

	~ProtectedIdGenerator();

	IdType GetNextId(void);

	void *operator()(void)
	{
		return ( (is_valid)?(void *)this:NULL );
	}
};



template <class IdType, UINT ILLEGAL_ID>
ProtectedIdGenerator<IdType, ILLEGAL_ID>::ProtectedIdGenerator(IdType start_id)
{
	is_valid = FALSE;
	CriticalSection = CreateCriticalSection(NULL,FALSE,NULL);
	if ( CriticalSection == NULL )
		return;	
	next_id = start_id;

	is_valid = TRUE;
}

template <class IdType, UINT ILLEGAL_ID>
ProtectedIdGenerator<IdType, ILLEGAL_ID>::~ProtectedIdGenerator()
{
   if ( CriticalSection != NULL )
	CloseHandle(CriticalSection);
}

template <class IdType, UINT ILLEGAL_ID>
IdType ProtectedIdGenerator<IdType, ILLEGAL_ID>::GetNextId(void)
{
	IdType to_return;
	CriticalSectionLock CriticalSection_lock(CriticalSection);

	// try to obtain lock
	BOOL result = CriticalSection_lock.GetLock(INFINITE);

			// if unsuccessful
	if ( result == FALSE )
		throw GeneralException(Snmp_Error, Snmp_Local_Error);
	else	// if successful
	{
		next_id++;

		if (next_id == ILLEGAL_ID)
			next_id++;

		to_return = next_id;
	}

	CriticalSection_lock.UnLock();

	return to_return;
}


#endif // __GEN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\msgid.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __MSG_ID__
#define __MSG_ID__

#endif // __MSG_ID__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\message.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: message.hpp
Author: B.Rajeev
Purpose: Provides declarations for the Message and
		 WaitingMessage classes.
--------------------------------------------------*/


#ifndef __MESSAGE__
#define __MESSAGE__

#include "forward.h"
#include "common.h"
#include "error.h"
#include "reg.h"
#include "timer.h"


/*--------------------------------------------------
Overview: 

  Message: Stores the parameters passed to the session with 
  a call to the SendFrame method. A message may either be
  transmitted immediately or enqueued in the FlowControlMechanism 
  queue for future transmission. After transmission, the message
  becomes a part of a WaitingMessage.

  WaitingMessage: Encapsulates the state maintained for each outstanding 
  reply. This includes its timer_event_id, retransmission 
  information (Message ptr) etc.

  Note - A Message/WaitingMessage may be cancelled at any time
--------------------------------------------------*/

class Message
{
	SessionFrameId session_frame_id;
	SnmpPdu *snmp_pdu;
	SnmpOperation &operation;

public:

	Message(IN const SessionFrameId session_frame_id, 
			IN SnmpPdu &snmp_pdu,
			IN SnmpOperation &snmp_operation);

	SessionFrameId GetSessionFrameId(void) const;

	SnmpOperation &GetOperation(void) const;

	void SetSnmpPdu(IN SnmpPdu &snmp_pdu);

	SnmpPdu &GetSnmpPdu(void) const;

	~Message(void);
};


// instances store the list of request ids used for a waiting message
typedef CList<RequestId, RequestId> RequestIdList;

// encapsulates state for a message that is transmitted and
// subsequently waits for a reply. It uses the timer to rexmt
// the message and if the reply isn't forthcoming, informs the
// flow control mechanism that no reply has been received. When
// a reply is received it informs the fc mech. of the event
// Each transmission of the waiting message uses a different request id

class WaitingMessage
{
	// it operates in the session's context
	SnmpImpSession *session;
	Message *message;
	SnmpPdu *reply_snmp_pdu;
	TransportFrameId last_transport_frame_id;
	TimerEventId m_TimerEventId ;

	// stores the list of request ids used for the waiting message
	// (inclusive of the original transmission)
	RequestIdList request_id_list;

	UINT max_rexns;
	UINT rexns_left;
	UINT strobes;

	BOOL sent_message_processed;
	BOOL active;

	// deregisters the waiting message from the message registry
	// for each request id stored in the RequestIdList
	void DeregisterRequestIds();

public:

	// initializes the private variables. in future, 
	// max_rexns and timeout_period might be obtained this way 
	// rather than from the session
	WaitingMessage(IN SnmpImpSession &session, IN Message &message);

	// returns the private message
	Message *GetMessage(void)
	{
		return message;
	}

	TimerEventId GetTimerEventId () ;

	void SetTimerEventId ( TimerEventId a_TimerEventId ) ;

	// sends the message. involves request_id generation,
	// registering with the message_registry, decoding the
	// message, updating the pdu and registering a timer event
	void Transmit();

	// used by the timer to notify the waiting message of
	// a timer event. if need, the message is retransmitted.
	// when all rexns are exhausted, ReceiveReply is called
	void TimerNotification(void);

	// A call to this function signifies that state corresponding to the
	// waiting_message need not be kept any further
	// it notifies the flow control mechanism of the termination
	// which destroys the waiting_message
	void ReceiveReply(IN const SnmpPdu *snmp_pdu, 
					  IN SnmpErrorReport &snmp_error_report = SnmpErrorReport(Snmp_Success, Snmp_No_Error));

	// The WinSnmp implementation, posts an event when a message is received,
	// however, when a call is made to the library to receive a message,
	// it hands them out in no specific order. Therefore, responses may
	// be received before their corresponding SENT_FRAME event is processed.
	// The following methods are concerned with buffering and
	// retrieving such snmp pdus.

	// buffers the snmp pdu received as a reply
	void BufferReply(IN const SnmpPdu &reply_snmp_pdu);

	// returns TRUE if a reply has been buffered
	BOOL ReplyBuffered();

	// returns a ptr to the buffered reply pdu, if buffered
	// otherwise a null ptr is returned
	// IMPORTANT: it sets the reply_snmp_pdu to NULL, so that it may 
	// not be deleted when the waiting message is destroyed
	SnmpPdu *GetBufferedReply();

	// informs the waiting message that a sent message has been
	// processed 
	void SetSentMessageProcessed();

	// if a sent message has been processed, it returns TRUE, else FALSE
	BOOL GetSentMessageProcessed();

	// an exit fn - prepares an error report and calls
	// ReceiveReply to signal a non-receipt
	void WrapUp( IN SnmpErrorReport &error_report =
					SnmpErrorReport(Snmp_Error, Snmp_Local_Error) );

	void SelfDestruct(void);

	// if required, it cancels registration with the message_registry and
	// the timer event with the timer, deletes message ptr
	~WaitingMessage(void);
};


#endif // __MESSAGE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\op.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: op.hpp   (operation.hpp)
Author: B.Rajeev
Purpose: Provides declarations for the SnmpOperation base
		 class and the classes derived from it -
		 SnmpGetOperation, SnmpGetNextOperation, SnmpSetOperation.
--------------------------------------------------*/

#ifndef __OPERATION__
#define __OPERATION__

#include "forward.h"
#include "error.h"
#include "encdec.h"

#define SEND_ERROR_EVENT (WM_USER+4)
#define OPERATION_COMPLETED_EVENT (WM_USER+5)

/*--------------------------------------------------
Overview: The SnmpOperation class defines protocol operations 
within the SNMP class library, the user of the class library is 
not expected to interact directly with SNMP frames exposed within 
the SnmpSession interface i.e. the user of the class library need 
not call into any SnmpSession method or derive from the 
SnmpSession class other than to receive flow control information, 
unless of course this is a requirement. The SnmpOperation defines 
the type of protocol request to send, the variable binding 
information requested and the frame encoding operation used to 
generate the required SNMP protocol data units.
--------------------------------------------------*/
  
// This is the base class for the Get, GetNext and Set operations.
// A few notables are -
// 1. It makes the callbacks to an operation user (ReceiveResponse etc.), 
// asynchronous with respect to the user's call to SendRequest.
// 2. The base class implementation registers and deregisters itself with
// the session in the constructor and the destructor respectively
// 3. a class deriving from the SnmpOperation method that provides
// alternate definitions for the "non-pure" virtual methods must
// also call the virtual method 
class DllImportExport SnmpOperation
{
	friend class OperationWindow;

	// only purpose of the OperationHelper is to separate certain winsnmp 
	// typedefs in the parameter list of a few methods from the 
	// SnmpOperation header file
	friend class OperationHelper;

private:

	// each public method checks for this flag before exiting. if the
	// flag is set, the operation must delete itself. only method that
	// sets it on is the protected DestroyOperation
	BOOL delete_operation;

	// its mandatory for every public method to call this method
	// before returning to the caller
	// it checks if the call sequence included a call to DestroyOperation
	// and if so, deletes "this" before returning
	void CheckOperationDeletion();

	// "=" operator has been
	// made private so that a copy may not be made
	SnmpOperation & operator= ( IN const SnmpOperation &snmp_operation )
	{
		return *this;
	}
	
	// sends a Frame with the VBList specifying the list of varbinds
	// in winsnmp vbl and SnmpVarBindList
	void SendFrame(VBList &list_segment);

	// transmits the specified frame state. its used for retransmitting
	// a current frame state after modifications in its var bind list
	void SendFrame(FrameState &frame_state);

	// sends the specified var bind list in snmp pdus each carrying
	// atmost max_size var binds
	void SendVarBindList(

		SnmpVarBindList &var_bind_list,
		UINT max_size = UINT_MAX,
		ULONG var_index = 0 
	);

	// makes the ReceiveErroredResponse callback for each varbind in
	// the errored_list
	void ReceiveErroredResponse(

		ULONG var_index ,
		SnmpVarBindList &errored_list,
		const SnmpErrorReport &error_report
	);

	// processes internal events such as error during sending
	// a frame or completion of an operation
	LONG ProcessInternalEvent(

		HWND hWnd, 
		UINT user_msg_id,
		WPARAM wParam, 
		LPARAM lParam
	);

	// both the public SendRequest methods call this for sending the varbindlist
	void SendRequest(

		IN SnmpVarBindList &varBindList,
		IN SnmpSecurity *security
	);

protected:

	SnmpSession &session;

	// used for hiding winsnmp manipulations and window messaging
	OperationWindow m_OperationWindow;

	// References to the following instances are used instead of 
	// embedded instances themselves. This is done to avoid including
	// the header files providing their declaration

	// unrecoverable errors during initialization or processing	(not yet)
	// set this field to FALSE
	BOOL is_valid;

	// only one operation may be in progress at a time
	BOOL in_progress;

	// only one thread is permitted to execute SnmpOperation methods
	CriticalSection exclusive_CriticalSection;

	// keeps all the FrameStates (for all outstanding Frames)
	FrameStateRegistry frame_state_registry;

	// hides winsnmp typedefs from this file
	OperationHelper helper;

	// atmost these many varbinds may be transmitted in any snmp pdu
	UINT varbinds_per_pdu;

	SnmpOperation(SnmpSession &snmp_session);

	// each time a pdu is prepared, it obtains the pdu type from the
	// derived class
	virtual SnmpEncodeDecode :: PduType GetPduType(void) = 0;

	virtual void ReceiveResponse();

	virtual void ReceiveVarBindResponse(

		IN const ULONG &varBindIndex ,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) {}

	virtual void ReceiveErroredVarBindResponse(

		IN const ULONG &varBindIndex ,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) {}

	virtual void FrameTooBig() {}

	virtual void FrameOverRun() {}

	// this method may be called to delete the Operation
	// note: the operation is deleted when a public method
	// returns. For this reason, if a public method calls another 
	// public method, it must not access any per-class variables
	// after that.
	void DestroyOperation();

public:

	virtual ~SnmpOperation() ;

	// packages the var binds in the var bind list into a series of
	// snmp pdus, each with at most varbinds_per_pdu var binds and
	// hands them to the session for transmission
	virtual void SendRequest(IN SnmpVarBindList &varBindList);

	// sends the frames with an additionally specified security context
	// (uses the session SendFrame with a security parameter
	virtual void SendRequest(
	
		IN SnmpVarBindList &varBindList,
		IN SnmpSecurity &security
	);

	// cancels all the session frames for which frame states exist in the
	// frame state registry (all outstanding frames)
	void CancelRequest();

	// called by the session or the SnmpOperation SendFrame method
	// to signal a valid reply, or an errored response (error in sending
	// timeout)
	void ReceiveFrame(

		IN const SessionFrameId session_frame_id,
		IN const SnmpPdu &snmpPdu,
		IN const SnmpErrorReport &errorReport
	);

	// called by the session to signal a frame transmission (successful
	// or otherwise) or a timeout situation. since a frame may be
	// retransmitted, in the absence of a response, more than one
	// SendFrame callback may be issued for the same session_frame_id.
	// however, atmost one errored SentFrame call may be made for each
	// frame/session_frame_id
	virtual void SentFrame (

		IN const SessionFrameId session_frame_id,
		IN const SnmpErrorReport &error_report
	);

	// used to check if the operation is valid
	void *operator()(void) const
	{
		return ( (is_valid)?(void *)this:NULL );
	}

	operator void *() const
	{
		return SnmpOperation::operator()();
	}

	static UINT g_SendErrorEvent ;
	static UINT g_OperationCompleteEvent ;
};


class DllImportExport SnmpGetOperation: public SnmpOperation
{
protected:

	SnmpEncodeDecode :: PduType GetPduType(void);

public:

	SnmpGetOperation(SnmpSession &snmp_session) : SnmpOperation(snmp_session)
	{}
};


class DllImportExport SnmpGetNextOperation: public SnmpOperation
{

protected:

	SnmpEncodeDecode :: PduType GetPduType(void);

public:

	SnmpGetNextOperation(IN SnmpSession &snmp_session) : SnmpOperation(snmp_session)
	{}
};



class DllImportExport SnmpSetOperation: public SnmpOperation
{
protected:

	SnmpEncodeDecode :: PduType GetPduType(void);

public:

	SnmpSetOperation(SnmpSession &snmp_session) : SnmpOperation(snmp_session)
	{}
};


#endif // __OPERATION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\idmap.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: idmap.hpp
Author: B.Rajeev
Purpose: Provides declarations for the IdMapping class.
--------------------------------------------------*/

#ifndef __ID_MAPPING__
#define __ID_MAPPING__

#include "forward.h"
#include "common.h"

#define ILLEGAL_TRANSPORT_FRAME_ID 0

typedef CMap<TransportFrameId, TransportFrameId &, SessionFrameId, SessionFrameId &> ForwardStore;
typedef CMap<SessionFrameId, SessionFrameId &, TransportFrameId, TransportFrameId &> BackwardStore;

// When a session frame is passed to the transport for transmission, the
// transport assigns a TransportFrameId to the frame.
// The IdMapping class provides a mapping between the SessionFrameIds and 
// TransportFrameIds
// NOTE: At any time, several transport frame ids may be associated with a
// session frame id, but the session frame id is only associated with the
// last registered transport frame id. DissociateSessionFrameId is called,
// the session frame id association is lost, however, other transport frame 
// ids remain associated with the session frame id
// If this is not desired in the future, a list of associated transport frame
// ids must be maintained for each session frame id 

class IdMapping
{
	// We need access by both the SessionFrameId and the TransportFrameId.
	// To avoid a CMap traversal, two CMaps are used to store the 
	// FrameIds, indexed by the TransportFrameId and the 
	// SessionFrameId respectively.
	ForwardStore forward_store;
	BackwardStore backward_store;

public:

	void Associate(IN TransportFrameId transport_frame_id,
				   IN SessionFrameId session_frame_id);

	SessionFrameId DisassociateTransportFrameId(IN TransportFrameId transport_frame_id);

	TransportFrameId DisassociateSessionFrameId(IN SessionFrameId session_frame_id);

	BOOL CheckIfAssociated(IN SessionFrameId session_frame_id);

	~IdMapping(void);
};

#endif // __ID_MAPPING__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\ophelp.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: ophelp.hpp
Author: B.Rajeev
Purpose: Provides declarations for the OperationHelper class
--------------------------------------------------*/

#ifndef __OPERATION_HELPER__
#define __OPERATION_HELPER__

#include "forward.h"

// The only purpose of this class is to hide the winsnmp
// typedefs in its method parameters from the file providing 
// operation class declaration

class OperationHelper
{
	SnmpOperation &operation;

public:

	OperationHelper(IN SnmpOperation &operation)
		: operation(operation)
	{}

	// calls the session to transmit the frame
	void TransmitFrame (

		OUT SessionFrameId &session_frame_id, 
		VBList &vbl
	);

	void ReceiveResponse (

		ULONG var_index,
		SnmpVarBindList &sent_var_bind_list,
		SnmpVarBindList &received_var_bind_list,
		SnmpErrorReport &error_report
	);

	// processes the response (successful or otherwise) for the specified
	// frame. the frame may be retransmitted in case of a reply bearing
	// an errored index
	void ProcessResponse (

		FrameState *frame_state,
		SnmpVarBindList &a_SnmpVarBindList ,
		SnmpErrorReport &error_report
	);

	//static functions which turn WINSNMP objects into SNMPCL objects.
	//these helper functions are static so that they may be used elsewhere.
	static SnmpVarBind *GetVarBind(

		IN smiOID &instance, 
		IN smiVALUE &value
	);

	static SnmpTransportAddress *GetTransportAddress(

		IN HSNMP_ENTITY &haddr
	);

	static SnmpSecurity *GetSecurityContext(

		IN HSNMP_CONTEXT &hctxt
	);
};


#endif // __OPERATION_HELPER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\opreg.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: opreg.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the OperationRegistry class
--------------------------------------------------*/

#ifndef __OPERATION_REGISTRY__
#define __OPERATION_REGISTRY__


#include "common.h"
#include "forward.h"

// stores the registered SnmpOperation instances and keeps a count of them
class OperationRegistry
{
	
	typedef CMap<SnmpOperation *, SnmpOperation *, void *, void *> Store;

	Store store;

	UINT num_registered;

public:

	OperationRegistry();

	void Register(IN SnmpOperation &operation);

	void Deregister(IN SnmpOperation &operation);

	UINT GetNumRegistered()
	{
		return num_registered;
	}

	~OperationRegistry();
};


#endif // __OPERATION_REGISTRY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\pdu.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: pdu.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the SnmpPdu class
--------------------------------------------------*/

#ifndef __SNMP_PDU__
#define __SNMP_PDU__

// encapsulates an Snmp Pdu. it is represented as an unsigned 
// character string (non-null terminated) and its length

class DllImportExport SnmpPdu
{
	// a pdu is invalid until the string and its length are specified
	// in the constructor or through SetPdu
	BOOL is_valid;
	UCHAR *ptr;
	ULONG length;

	RequestId m_RequestId ;
	SnmpEncodeDecode :: PduType m_PduType ;
	SnmpErrorReport m_ErrorReport ;
	SnmpVarBindList *m_SnmpVarBindList ;
	SnmpTransportAddress *m_SourceAddress ;
	SnmpTransportAddress *m_DestinationAddress ;
	SnmpCommunityBasedSecurity *m_SnmpCommunityName ;
	
	void Initialize(IN const UCHAR *frame, 
					IN const ULONG &frameLength);

	void FreeFrame(void);

	void FreePdu () ;

public:

	SnmpPdu();
	SnmpPdu(IN SnmpPdu &snmpPdu);
	SnmpPdu(IN const UCHAR *frame, IN const ULONG &frameLength);

	virtual ~SnmpPdu(void) ;

	ULONG GetFrameLength() const;

	UCHAR *GetFrame() const;

	void SetPdu(IN const UCHAR *frame, IN const ULONG frameLength);
	void SetPdu(IN SnmpPdu &a_SnmpPdu ) ;

	virtual BOOL SetVarBindList (

		OUT SnmpVarBindList &a_SnmpVarBindList

	) ;

	virtual BOOL SetCommunityName ( 

		IN SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity 
	
	) ;

	virtual BOOL SetErrorReport (

		OUT SnmpErrorReport &a_SnmpErrorReport

	) ;

	virtual BOOL SetPduType (

		OUT SnmpEncodeDecode :: PduType a_PduType

	) ;

	virtual BOOL SetSourceAddress ( 

		IN SnmpTransportAddress &a_TransportAddress 

	) ;

	virtual BOOL SetDestinationAddress ( 

		IN SnmpTransportAddress &a_TransportAddress 

	) ;

	virtual BOOL SetRequestId (

		IN RequestId request_id

	) ;

	virtual SnmpEncodeDecode :: PduType & GetPduType () ;

	virtual RequestId & GetRequestId () ;

	virtual SnmpErrorReport &GetErrorReport () ;

	virtual SnmpCommunityBasedSecurity &GetCommunityName () ;

	virtual SnmpVarBindList &GetVarbindList () ;

	virtual SnmpTransportAddress &GetSourceAddress () ;

	virtual SnmpTransportAddress &GetDestinationAddress () ;

	void *operator()(void) const
	{
		return ( (is_valid)? (void *)this: NULL );
	}

	operator void *() const
	{
		return SnmpPdu::operator()();
	}
};


#endif // __SNMP_PDU__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\pch.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "common.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\pseudo.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*-------------------------------------------------------
filename: pseudo.hpp
author: B.Rajeev
purpose: Provides declarations for the class OperationSession.
-------------------------------------------------------*/


#ifndef __PSEUDO_SESSION__
#define __PSEUDO_SESSION__ 

#include "forward.h"
#include "wsess.h"

// Its windows messaging services
// are used by the operation for internal events

class OperationWindow : public Window
{
private:

	// hands the window message events to the owner for processing
	SnmpOperation &owner;

	// over-rides the callback from WinSnmpSession for window message events
	LONG_PTR HandleEvent (

		HWND hWnd, 
		UINT user_msg_id, 
		WPARAM wParam, 
		LPARAM lParam
	);

public:

	OperationWindow (

		IN SnmpOperation &owner
	);

	~OperationWindow ();
};

#endif // __PSEUDO_SESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\sec.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: sec.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the SnmpSecurity class
--------------------------------------------------*/

#ifndef __SECURITY__
#define __SECURITY__

#include "forward.h"
#include "error.h"

#define SnmpV1Security SnmpCommunityBasedSecurity

// provides the security context under which snmp pdus are transmitted
class DllImportExport SnmpSecurity
{
private:

	// the "=" operator and the copy constructor have been made
	// private to prevent copies of the SnmpSecurity instance from
	// being made
	SnmpSecurity &operator=(IN const SnmpSecurity &security)
	{
		return *this;
	}

	SnmpSecurity(IN const SnmpSecurity &snmp_security) {}

protected:

	SnmpSecurity() {}

public:

	virtual ~SnmpSecurity(){}

	virtual SnmpErrorReport Secure (

		IN SnmpEncodeDecode &snmpEncodeDecode,
		IN OUT SnmpPdu &snmpPdu

	) = 0;

	virtual SnmpSecurity *Copy() const = 0;

	virtual void * operator()(void) const = 0;

	virtual operator void *() const = 0;
};


class DllImportExport SnmpCommunityBasedSecurity: public SnmpSecurity
{
protected:

	char *community_name;

	BOOL is_valid;

	void Initialize();

public:

	SnmpCommunityBasedSecurity ( IN const SnmpCommunityBasedSecurity &a_SnmpCommunityBasedSecurity ) ;
	SnmpCommunityBasedSecurity ( IN const char *a_CommunityName = "public" ) ;
	SnmpCommunityBasedSecurity ( IN const SnmpOctetString &a_OctetString ) ;

	~SnmpCommunityBasedSecurity () ;

	SnmpErrorReport Secure (
	
		IN SnmpEncodeDecode &snmpEncodeDecode,
		IN OUT SnmpPdu &snmpPdu

	) ;

	SnmpSecurity *Copy() const;

	SnmpCommunityBasedSecurity &operator=(IN const SnmpCommunityBasedSecurity &to_copy) ;

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	operator void *() const
	{
		return SnmpCommunityBasedSecurity::operator()();
	}

	void SetCommunityName ( IN const SnmpOctetString &a_OctetString ) ;
	void SetCommunityName ( IN const char *a_CommunityName ) ;

	void GetCommunityName ( SnmpOctetString &a_SnmpOctetString ) const ;
	const char *GetCommunityName() const;
};

#endif // __SECURITY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\session.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: session.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the SnmpSession class
--------------------------------------------------*/
#ifndef __SESSION__
#define __SESSION__

#include "forward.h"
#include "address.h"
#include "sec.h"

#include "tsent.h"

#include "transp.h"
#include "encdec.h"

typedef UINT_PTR TimerEventId;

#define DEF_RETRY_COUNT			1
#define DEF_RETRY_TIMEOUT		500
#define DEF_VARBINDS_PER_PDU	10
#define DEF_WINDOW_SIZE			4


#pragma warning (disable:4355)

/*------------------------------------------------------------
Overview: The SnmpSession class provides the framework for the 
communications session between client and protocol stack. The 
SnmpSession exposes SNMP frame ( use the term frame and protocol 
data unit interchangeably throughout this document ) transmission 
and reception independently of the transport stack implementation. 
The SnmpSession provides the interface between communication 
subsystem and protocol operation generation.

The SnmpImpSession class provides an implementation of the 
SnmpSession abstract class.
------------------------------------------------------------*/

class DllImportExport SnmpSession
{
private:

	// the "=" operator and the copy constructor have been
	// made private to prevent any copies from being made
	SnmpSession & operator=( const SnmpSession & ) 
	{
		return *this;
	}

	SnmpSession(IN const SnmpSession &snmp_session) {}

protected:

	ULONG retry_count;
	ULONG retry_timeout;
	ULONG varbinds_per_pdu;
	ULONG flow_control_window;

/*
 * User overridable callback functions
 */

	virtual void SessionFlowControlOn() {}
	virtual void SessionFlowControlOff() {}

/*
 * End User overridable callback functions
 */

	SnmpSession(

		IN SnmpTransport &transportProtocol,
		IN SnmpSecurity &security,
		IN SnmpEncodeDecode &a_SnmpEncodeDecode  ,
		IN const ULONG retryCount = DEF_RETRY_COUNT,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE

		);

public:

	virtual ~SnmpSession () {}

/*
 * System overridable operation functions
 */

	virtual SnmpTransport &GetTransportProtocol () const = 0 ;

	virtual SnmpSecurity &GetSnmpSecurity () const = 0 ;

	virtual SnmpEncodeDecode &GetSnmpEncodeDecode () const = 0 ;

	// all operations must register themselves before
	// using the Session services and must deregister
	// for the session to be destroyed

	virtual void RegisterOperation(IN SnmpOperation &operation) = 0;

	virtual void DeregisterOperation(IN SnmpOperation &operation) = 0;

	// the session is destroyed if the number of registered sessions
	// is 0. otherwise the session is flagged to be destroyed when
	// the number of registered operations drops to 0.
	virtual BOOL DestroySession() = 0;

	virtual SnmpErrorReport SessionCancelFrame ( IN const SessionFrameId session_frame_id ) = 0 ;

	virtual void SessionSendFrame (  

		IN SnmpOperation &operation ,
		OUT SessionFrameId &session_frame_id ,
		IN SnmpPdu &SnmpPdu,
		IN SnmpSecurity &security

	)  = 0 ;

	virtual void SessionSendFrame (  

		IN SnmpOperation &operation ,
		OUT SessionFrameId &session_frame_id ,
		IN SnmpPdu &SnmpPdu

	)  = 0 ;

	virtual void SessionReceiveFrame (

		IN SnmpPdu &snmpPdu,
		IN SnmpErrorReport &errorReport

	)  = 0 ;

	virtual void SessionSentFrame (

             IN TransportFrameId  transport_frame_id,  
             IN SnmpErrorReport &errorReport
	
	) = 0;

	virtual void * operator()(void) const = 0;

  
/*
 * End system overridable operation functions
 */

	ULONG GetRetryCount () const
	{
		return retry_count;
	}

	ULONG GetRetryTimeout () const
	{
		return retry_timeout;
	}

	ULONG GetVarbindsPerPdu () const
	{
		return varbinds_per_pdu;
	}

	ULONG GetFlowControlWindow() const
	{
		return flow_control_window;
	}

	
} ;


class DllImportExport SnmpImpSession : public SnmpSession
{
private:

	SessionFrameId received_session_frame_id;
	SnmpOperation *operation_to_notify;

	friend class WaitingMessage;
	friend class FlowControlMechanism;
	friend class Timer;
	friend class MessageRegistry;
	friend class FrameRegistry;
	friend class SessionWindow;

	BOOL is_valid;

	// References to the following instances are used instead of 
	// embedded instances themselves. This is done to avoid including
	// the header files providing their declaration
	
	SessionWindow m_SessionWindow;

	CriticalSection session_CriticalSection;

	FlowControlMechanism flow_control;
	Timer	timer;
	TimerEventId timer_event_id;
	UINT strobe_count ;
	MessageRegistry message_registry;
	FrameRegistry frame_registry;

	SnmpTransport &transport;
	SnmpSecurity &security;	
	SnmpEncodeDecode &m_EncodeDecode ;

	SessionSentStateStore store;
	IdMapping id_mapping;

	// the operation registry keeps track of the registered
	// operations
	OperationRegistry operation_registry;

	// if this flag is TRUE, the session must delete this when
	// the number of registered operations falls to 0
	BOOL destroy_self;

 
	void NotifyOperation(IN const SessionFrameId session_frame_id,
						 IN const SnmpPdu &snmp_pdu,
						 IN const SnmpErrorReport &error_report);

	SnmpOperation *GetOperation(IN const SessionFrameId session_frame_id);

	// the Handle* methods handle internal windows events
	// these are called by the DummySession
	void HandleSentFrame (IN SessionFrameId  session_frame_id);

	void HandleDeletionEvent();


protected:

	SnmpImpSession ( 

		IN SnmpTransport &transportProtocol  ,
		IN SnmpSecurity &security  ,
		IN SnmpEncodeDecode &a_SnmpEncodeDecode  ,
		IN const ULONG retryCount = DEF_RETRY_COUNT ,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT ,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU  ,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE 
	) ;

public:

	~SnmpImpSession () ;

	SnmpTransport &GetTransportProtocol () const { return transport ; }

	SnmpSecurity &GetSnmpSecurity () const { return security ; }

	SnmpEncodeDecode &GetSnmpEncodeDecode () const { return m_EncodeDecode ; }

	void RegisterOperation(IN SnmpOperation &operation);

	void DeregisterOperation(IN SnmpOperation &operation);

	// the session is destroyed if the number of registered sessions
	// is 0. otherwise the session is flagged to be destroyed when
	// the number of registered operations drops to 0.
	BOOL DestroySession();

	SnmpErrorReport SessionCancelFrame ( IN const SessionFrameId session_frame_id ) ;

	void SessionSendFrame ( IN SnmpOperation &operation,
							OUT SessionFrameId &session_frame_id ,
							IN SnmpPdu &snmpPdu) ;

	void SessionSendFrame(IN SnmpOperation &operation,
						  OUT SessionFrameId &session_frame_id,
						  IN SnmpPdu &snmpPdu,
						  IN SnmpSecurity &snmp_security);

	void SessionReceiveFrame(IN SnmpPdu &snmpPdu,
							 IN SnmpErrorReport &errorReport);

	void SessionSentFrame(

             IN TransportFrameId  transport_frame_id,  
             IN SnmpErrorReport &errorReport);

	void * operator()(void) const
	{
		return (is_valid?(void *)this:NULL);
	}

	operator void *() const
	{
		return SnmpImpSession::operator()();
	}

	static ULONG RetryCount(IN const ULONG retry_count) ;
	
	static ULONG RetryTimeout(IN const ULONG retry_timeout) ;

	static ULONG VarbindsPerPdu(IN const ULONG varbinds_per_pdu) ;

	static ULONG WindowSize(IN const ULONG window_size) ;

} ;


class DllImportExport SnmpV1OverIp : public SnmpUdpIpImp , public SnmpCommunityBasedSecurity , public SnmpImpSession , public SnmpV1EncodeDecode
{
private:
protected:
public:

	SnmpV1OverIp ( 

		IN const char *ipAddress ,
		IN const ULONG addressResolution = SNMP_ADDRESS_RESOLVE_VALUE ,
		IN const char *communityName = "public" ,
		IN const ULONG retryCount = DEF_RETRY_COUNT ,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT ,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU  ,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE 
	)
	: 	  SnmpUdpIpImp(*this, ipAddress,addressResolution),
		  SnmpCommunityBasedSecurity(communityName),
		  SnmpImpSession(*this, *this,*this, retryCount,
				   retryTimeout, varbindsPerPdu, flowControlWindow)
	{}

	void * operator()(void) const;

	~SnmpV1OverIp () {}
} ;

class DllImportExport SnmpV2COverIp : public SnmpUdpIpImp , public SnmpCommunityBasedSecurity , public SnmpImpSession , public SnmpV2CEncodeDecode
{
private:
protected:
public:

	SnmpV2COverIp ( 

		IN const char *ipAddress ,
		IN const ULONG addressResolution = SNMP_ADDRESS_RESOLVE_VALUE ,
		IN const char *communityName = "public" ,
		IN const ULONG retryCount = DEF_RETRY_COUNT ,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT ,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU  ,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE 
	)
	: 	  SnmpUdpIpImp(*this, ipAddress,addressResolution),
		  SnmpCommunityBasedSecurity(communityName),
		  SnmpImpSession(*this, *this,*this, retryCount,
				   retryTimeout, varbindsPerPdu, flowControlWindow)
	{}

	void * operator()(void) const;

	~SnmpV2COverIp () {}
} ;

class DllImportExport SnmpV1OverIpx : public SnmpIpxImp , public SnmpCommunityBasedSecurity , public SnmpImpSession , public SnmpV1EncodeDecode
{
private:
protected:
public:

	SnmpV1OverIpx ( 

		IN const char *ipxAddress ,
		IN const char *communityName = "public" ,
		IN const ULONG retryCount = DEF_RETRY_COUNT ,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT ,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU  ,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE 
	)
	: 	  SnmpIpxImp(*this, ipxAddress),
		  SnmpCommunityBasedSecurity(communityName),
		  SnmpImpSession(*this, *this,*this, retryCount,
				   retryTimeout, varbindsPerPdu, flowControlWindow)
	{}

	void * operator()(void) const;

	~SnmpV1OverIpx () {}
} ;

class DllImportExport SnmpV2COverIpx : public SnmpIpxImp , public SnmpCommunityBasedSecurity , public SnmpImpSession , public SnmpV2CEncodeDecode
{
private:
protected:
public:

	SnmpV2COverIpx ( 

		IN const char *ipxAddress ,
		IN const char *communityName = "public" ,
		IN const ULONG retryCount = DEF_RETRY_COUNT ,
		IN const ULONG retryTimeout = DEF_RETRY_TIMEOUT ,
		IN const ULONG varbindsPerPdu = DEF_VARBINDS_PER_PDU  ,
		IN const ULONG flowControlWindow = DEF_WINDOW_SIZE 
	)
	: 	  SnmpIpxImp(*this, ipxAddress),
		  SnmpCommunityBasedSecurity(communityName),
		  SnmpImpSession(*this, *this,*this, retryCount,
				   retryTimeout, varbindsPerPdu, flowControlWindow)
	{}

	void * operator()(void) const;

	~SnmpV2COverIpx () {}
} ;

#pragma warning (default:4355)

#endif // __SESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\snmpcl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __SINGLE_HEADER__
#define __SINGLE_HEADER__

#define DllImport	__declspec( dllimport )
#define DllExport	__declspec( dllexport )

#ifdef SNMPCLINIT
#define DllImportExport DllExport
#else
#define DllImportExport DllImport
#endif

#include <limits.h>
#include "sync.h"
#include "startup.h"
#include "address.h"
#include "error.h"
#include "encdec.h"
#include "vblist.h"
#include "sec.h"
#include "pdu.h"
#include "trap.h"

#include "tsent.h"

#include "transp.h"

#include "dummy.h"
#include "flow.h"
#include "frame.h"
#include "timer.h"
#include "message.h"
#include "ssent.h"
#include "idmap.h"
#include "opreg.h"

#include "session.h"
#include "pseudo.h"
#include "fs_reg.h"
#include "ophelp.h"
#include "op.h"
#include "value.h"

#endif // __SINGLE_HEADER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\reg.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*--------------------------------------------------
Filename: reg.hpp
Author: B.Rajeev
Purpose: Provides declarations for the MessageRegistry class
--------------------------------------------------*/



#ifndef __REG__
#define __REG__

#include "common.h"
#include "encdec.h"
#include "message.h"

/*--------------------------------------------------
Overview:
--------

  MessageRegistry: It maintains a mapping 
  <request_id, waiting_message *>. Before transmission, a waiting 
  message registers itself with the registry. 
  When the session notifies the registry of a message
  arrival event, the registry notifies the waiting message of the event
--------------------------------------------------*/

typedef CMap< RequestId, RequestId, WaitingMessage *, WaitingMessage * > RequestMap;

class MessageRegistry
{
	// the v1 session: for obtaining session information,
	// event handler
	SnmpImpSession *session;

	// map for (event_id, waiting_message) association and
	// unique request_id generation
	static RequestId next_request_id;
	RequestMap mapping;

public:

	MessageRegistry(IN SnmpImpSession &session)
	{
		MessageRegistry::session = &session;
	}

	// generates and returns a new request id. It also 
	// associates the waiting message with the request id
	RequestId GenerateRequestId(IN WaitingMessage &waiting_message);

	// used by the session to notify the message registry
	// of a message receipt (when it is received from the Transport)
	// it must notify the concerned waiting message of the event
	void MessageArrivalNotification(IN SnmpPdu &snmp_pdu);

	// delete (request_id, waiting_message) pair
	void RemoveMessage(IN RequestId request_id);

	~MessageRegistry(void);
};

#endif // __REG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\snmpauto.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#if _MSC_VER >= 1100
template<> DllImportExport UINT AFXAPI HashKey <SnmpObjectIdentifierType&> (SnmpObjectIdentifierType &key) ;
#else
DllImportExport UINT HashKey (SnmpObjectIdentifierType &key) ;
#endif

#if _MSC_VER >= 1100
template<> DllImportExport BOOL AFXAPI CompareElements <SnmpObjectIdentifierType , SnmpObjectIdentifierType >( 

	 const SnmpObjectIdentifierType* pElement1, 
	 const SnmpObjectIdentifierType* pElement2 
) ;
#else
DllImportExport BOOL CompareElements ( 

	 SnmpObjectIdentifierType* pElement1, 
	 SnmpObjectIdentifierType* pElement2 
) ;
#endif

class VarBindObject 
{
private:

	SnmpObjectIdentifier reply ;
	SnmpValue *value ;

protected:
public:

	VarBindObject ( const SnmpObjectIdentifier &replyArg , const SnmpValue &valueArg ) ;
	virtual ~VarBindObject () ;

	SnmpObjectIdentifier &GetObjectIdentifier () ;
	SnmpValue &GetValue () ;
} ;

class VarBindQueue 
{
private:

	CList <VarBindObject *, VarBindObject *&> queue ;

protected:
public:

	VarBindQueue () ;
	virtual ~VarBindQueue () ;

	void Add ( VarBindObject *varBindObject ) ;
	VarBindObject *Get () ;
	VarBindObject *Delete () ;
} ;

class VarBindObjectRequest 
{
private:

	BOOL repeatRequest ;
	VarBindQueue varBindResponseQueue ;
	SnmpObjectIdentifierType varBind ;
	SnmpObjectIdentifierType requested ;

protected:
public:

	VarBindObjectRequest ( const SnmpObjectIdentifierType &varBindArg ) ;
	VarBindObjectRequest ( 

		const SnmpObjectIdentifierType &varBindArg ,
		const SnmpObjectIdentifierType &requestedVarBindArg 
	) ;

	VarBindObjectRequest () ;
	virtual ~VarBindObjectRequest () ;

	const SnmpObjectIdentifierType &GetRequested () const ;
	const SnmpObjectIdentifierType &GetVarBind () const ;
	
	void AddQueuedObject ( VarBindObject *object ) ;
	VarBindObject *GetQueuedObject () ;
	VarBindObject *DeleteQueueudObject () ;

	void SetRequested ( const SnmpObjectIdentifierType &requestedArg ) ;
	void SetVarBind ( const SnmpObjectIdentifierType &varBindArg ) ;

	BOOL GetRepeatRequest () { return repeatRequest ; }
	void SetRepeatRequest ( BOOL repeatRequestArg = TRUE ) { repeatRequest = repeatRequestArg ; }
} ;


class GetNextOperation ;
class DllImportExport SnmpAutoRetrieveOperation 
{
friend GetNextOperation ;
private:

	BOOL status ;
	GetNextOperation *operation ;

protected:

	SnmpAutoRetrieveOperation (SnmpSession &snmp_session);

	virtual void ReceiveResponse() {} ;

	virtual void ReceiveRowResponse () {} ;

	virtual void ReceiveRowVarBindResponse(

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error) {}

	virtual void ReceiveVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error) {}

	virtual void ReceiveErroredVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error) {}

	virtual LONG EvaluateNextRequest (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN SnmpVarBind &sendVarBind

	) { return 0 ; }

	virtual void FrameTooBig() {}

	virtual void FrameOverRun() {}

	void DestroyOperation () ;

public:


	virtual ~SnmpAutoRetrieveOperation() ;

	virtual void SendRequest (

		IN SnmpVarBindList &scopeVarBindList , 
		IN SnmpVarBindList &varBindList 
	);

	virtual void SendRequest (

		IN SnmpVarBindList &varBindList 
	);

	void CancelRequest();

	void ReceiveFrame(IN const SessionFrameId session_frame_id,
					  IN const SnmpPdu &snmpPdu,
					  IN const SnmpErrorReport &errorReport) {} ;

	virtual void SentFrame(IN const SessionFrameId session_frame_id,
						   IN const SnmpErrorReport &error_report) {} ;

	void *operator()(void) const ;

} ;



class DllImportExport GetNextOperation : public SnmpGetNextOperation
{
private:

	ULONG m_RequestContainerLength ;
	VarBindObjectRequest **m_RequestContainer ;
	ULONG *m_RequestIndexContainer ;

	BOOL cancelledRequest ;
	SnmpObjectIdentifier minimumInstance ;
	SnmpAutoRetrieveOperation *operation ;

	void Cleanup () ;
	BOOL ProcessRow () ;
	void Send () ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(	

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error
	) ;

	void FrameTooBig() ;

	void FrameOverRun() ;

	void SentFrame(

		IN const SessionFrameId session_frame_id,
		IN const SnmpErrorReport &error_report
	);

public:

	GetNextOperation (IN SnmpSession &session, SnmpAutoRetrieveOperation &autoRetrieveOperation ) ;
	~GetNextOperation () ;

	void SendRequest ( 

		SnmpVarBindList &varBindList , 
		SnmpVarBindList &startVarBindList 
	) ;

	void SendRequest ( SnmpVarBindList &varBindList ) ;
	void CancelRequest () ;

	void DestroyOperation () ;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\snmpcont.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __SNMPCONT_H
#define __SNMPCONT_H

#include <provexpt.h>

template<class TYPE, class ARG_TYPE>
class SnmpList 
{
private:

	CCriticalSection * criticalSection ;
	CList <TYPE, ARG_TYPE> clist ;

protected:
public:

	SnmpList ( BOOL threadSafeArg = FALSE ) ;
	virtual ~SnmpList () ;

	int GetCount() const;
	BOOL IsEmpty() const;

	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

	TYPE RemoveHead();
	TYPE RemoveTail();

	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	void AddHead(SnmpList<TYPE,ARG_TYPE>* pNewList);
	void AddTail(SnmpList<TYPE,ARG_TYPE>* pNewList);

	void RemoveAll();

	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); 
	TYPE GetNext(POSITION& rPosition) const; 
	TYPE& GetPrev(POSITION& rPosition); 
	TYPE GetPrev(POSITION& rPosition) const; 

	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
	POSITION FindIndex(int nIndex) const;
} ;

template<class TYPE, class ARG_TYPE>
SnmpList <TYPE,ARG_TYPE>:: SnmpList ( BOOL threadSafeArg ) : criticalSection ( NULL )
{
	if ( threadSafeArg )	
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
SnmpList <TYPE,ARG_TYPE> :: ~SnmpList () 
{
	if ( criticalSection ) 
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
int SnmpList <TYPE,ARG_TYPE> :: GetCount() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		int count = clist.GetCount () ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return clist.GetCount () ;
	}
}

template<class TYPE, class ARG_TYPE>
BOOL SnmpList <TYPE,ARG_TYPE> :: IsEmpty() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL isEmpty = clist.IsEmpty () ;
		criticalSection->Unlock () ;
		return isEmpty ;
	}
	else
	{
		return clist.IsEmpty () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE &SnmpList <TYPE,ARG_TYPE> :: GetHead () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &head = clist.GetHead () ;
		criticalSection->Unlock () ;
		return head;
	}
	else
	{
		return clist.GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: GetHead () const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE head = clist.GetHead () ;
		criticalSection->Unlock () ;
		return head ;
	}
	else
	{
		return clist.GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE &SnmpList <TYPE,ARG_TYPE> :: GetTail()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &tail = clist.GetTail () ;
		criticalSection->Unlock () ;
		return tail ;
	}
	else
	{
		return clist.GetTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: GetTail() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE tail = clist.GetTail () ;
		criticalSection->Unlock () ;
		return tail ;
	}
	else
	{
		return clist.GetTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: RemoveHead()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE head = clist.RemoveHead () ;
		criticalSection->Unlock () ;
		return head ;
	}
	else
	{
		return clist.RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: RemoveTail()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE tail = clist.RemoveTail () ;
		criticalSection->Unlock () ;
		return tail ;
	}
	else
	{
		return clist.RemoveTail () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: AddHead(ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.AddHead ( newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.AddHead ( newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: AddTail(ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.AddTail ( newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.AddTail ( newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpList <TYPE,ARG_TYPE> :: AddHead(SnmpList<TYPE,ARG_TYPE> *pNewList)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.AddHead ( pNewList->clist ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.AddHead ( pNewList->clist ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpList <TYPE,ARG_TYPE> :: AddTail(SnmpList<TYPE,ARG_TYPE> *pNewList)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.AddTail ( pNewList->clist ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.AddTail ( pNewList->clist ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpList <TYPE,ARG_TYPE> :: RemoveAll ()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.RemoveAll () ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.RemoveAll () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: GetHeadPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.GetHeadPosition () ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.GetHeadPosition () ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: GetTailPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.GetTailPosition () ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.GetTailPosition () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& SnmpList <TYPE,ARG_TYPE> :: GetNext(POSITION& rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &type = clist.GetNext ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetNext ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: GetNext(POSITION& rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = clist.GetNext ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetNext ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& SnmpList <TYPE,ARG_TYPE> :: GetPrev(POSITION& rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &type = clist.GetPrev ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetPrev ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: GetPrev(POSITION& rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = clist.GetPrev ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetPrev ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE& SnmpList <TYPE,ARG_TYPE> :: GetAt(POSITION rPosition)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE &type = clist.GetAt ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetAt ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpList <TYPE,ARG_TYPE> :: GetAt(POSITION rPosition) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = clist.GetAt ( rPosition ) ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return clist.GetAt ( rPosition ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpList <TYPE,ARG_TYPE> :: SetAt(POSITION pos, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.SetAt ( pos , newElement ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.SetAt ( pos , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpList <TYPE,ARG_TYPE> :: RemoveAt(POSITION position)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		clist.RemoveAt ( position ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		clist.RemoveAt ( position ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: InsertBefore(POSITION position, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.InsertBefore ( position , newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.InsertBefore ( position , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: InsertAfter(POSITION position, ARG_TYPE newElement)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.InsertAfter ( position , newElement ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.InsertAfter ( position , newElement ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: Find(ARG_TYPE searchValue, POSITION startAfter ) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.Find ( searchValue , startAfter ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.Find ( searchValue , startAfter ) ;
	}
}

template<class TYPE, class ARG_TYPE>
POSITION SnmpList <TYPE,ARG_TYPE> :: FindIndex(int nIndex) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = clist.Find ( nIndex ) ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return clist.Find ( nIndex ) ;
	}
}

template<class TYPE, class ARG_TYPE>
class SnmpStack : public SnmpList<TYPE,ARG_TYPE>
{
private:

	CCriticalSection * criticalSection ;

protected:
public:

	SnmpStack ( BOOL threadSafeArg = FALSE ) ;
	virtual ~SnmpStack () ;

	void Add ( ARG_TYPE type ) ;
	TYPE Get () ;
	TYPE Delete () ;
} ;

template<class TYPE, class ARG_TYPE>
SnmpStack <TYPE, ARG_TYPE> :: SnmpStack ( BOOL threadSafeArg ) :
	SnmpList<TYPE,ARG_TYPE> ( FALSE ) ,
	criticalSection ( NULL )
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
SnmpStack <TYPE, ARG_TYPE> :: ~SnmpStack () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
void SnmpStack <TYPE, ARG_TYPE> :: Add ( ARG_TYPE type ) 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		AddHead ( type ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		AddHead ( type ) ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpStack <TYPE, ARG_TYPE> :: Get () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = GetHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpStack <TYPE,ARG_TYPE> :: Delete () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = RemoveHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
class SnmpQueue : public SnmpList<TYPE,ARG_TYPE>
{
private:

	CCriticalSection * criticalSection ;

protected:
public:

	SnmpQueue ( BOOL threadSafeArg = FALSE ) ;
	virtual ~SnmpQueue () ;

	void Add ( ARG_TYPE type ) ;
	TYPE Get () ;
	TYPE Delete () ;
	void Rotate () ;

} ;

template<class TYPE, class ARG_TYPE>
SnmpQueue <TYPE, ARG_TYPE> :: SnmpQueue ( BOOL threadSafeArg ) : 
	SnmpList<TYPE,ARG_TYPE> ( FALSE ) ,
	criticalSection ( NULL )
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = NULL ;
}

template<class TYPE, class ARG_TYPE>
SnmpQueue <TYPE, ARG_TYPE> :: ~SnmpQueue () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class TYPE, class ARG_TYPE>
void SnmpQueue <TYPE, ARG_TYPE> :: Add ( ARG_TYPE type ) 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		AddTail ( type ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		AddTail ( type ) ;
	}
}


template<class TYPE, class ARG_TYPE>
TYPE SnmpQueue <TYPE, ARG_TYPE> :: Get () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = GetHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return GetHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
TYPE SnmpQueue <TYPE, ARG_TYPE> :: Delete () 
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = RemoveHead () ;
		criticalSection->Unlock () ;
		return type ;
	}
	else
	{
		return RemoveHead () ;
	}
}

template<class TYPE, class ARG_TYPE>
void SnmpQueue <TYPE, ARG_TYPE> :: Rotate ()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		TYPE type = Delete () ;
		Add ( type ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		TYPE type = Delete () ;
		Add ( type ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class SnmpMap 
{
private:

	CCriticalSection * criticalSection ;
	CMap <KEY, ARG_KEY, VALUE, ARG_VALUE> cmap ;

protected:
public:

	SnmpMap ( BOOL threadSafe = FALSE ) ;
	virtual ~SnmpMap () ;

	int GetCount () const  ;
	BOOL IsEmpty () const ;
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const ;
	VALUE& operator[](ARG_KEY key) ;
	void SetAt(ARG_KEY key, ARG_VALUE newValue) ;
	BOOL RemoveKey(ARG_KEY key) ;
	void RemoveAll () ;
	POSITION GetStartPosition() const ;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const ;
	BOOL GetCurrentAssoc(POSITION rPosition, KEY& rKey, VALUE& rValue) const;
} ;


template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SnmpMap ( BOOL threadSafeArg ) : criticalSection ( NULL )
{
	if ( threadSafeArg )
		criticalSection = new CCriticalSection ;
	else
		criticalSection = FALSE ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: ~SnmpMap () 
{
	if ( criticalSection )
		delete criticalSection ;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
int SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetCount() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		int count = cmap.GetCount () ;
		criticalSection->Unlock () ;
		return count ;
	}
	else
	{
		return cmap.GetCount () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: IsEmpty() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL isEmpty = cmap.IsEmpty () ;
		criticalSection->Unlock () ;
		return isEmpty ;
	}
	else
	{
		return cmap.IsEmpty () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: Lookup(ARG_KEY key, VALUE& rValue) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL lookup = cmap.Lookup ( key , rValue ) ;
		criticalSection->Unlock () ;
		return lookup ;
	}
	else
	{
		return cmap.Lookup ( key , rValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: operator[](ARG_KEY key)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		VALUE &value = cmap.operator [] ( key ) ;
		criticalSection->Unlock () ;
		return value ;
	}
	else
	{
		return cmap.operator [] ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: SetAt(ARG_KEY key, ARG_VALUE newValue)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		cmap.SetAt ( key , newValue ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		cmap.SetAt ( key , newValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveKey(ARG_KEY key)
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		BOOL removeKey = cmap.RemoveKey ( key ) ;
		criticalSection->Unlock () ;
		return removeKey ;
	}
	else
	{
		return cmap.RemoveKey ( key ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: RemoveAll()
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		cmap.RemoveAll () ;
		criticalSection->Unlock () ;
	}
	else
	{
		cmap.RemoveAll () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
POSITION SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE> :: GetStartPosition() const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		POSITION position = cmap.GetStartPosition () ;
		criticalSection->Unlock () ;
		return position ;
	}
	else
	{
		return cmap.GetStartPosition () ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const
{
	if ( criticalSection )
	{
		criticalSection->Lock () ;
		cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		cmap.GetNextAssoc ( rNextPosition , rKey , rValue ) ;
	}
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL SnmpMap <KEY, ARG_KEY, VALUE, ARG_VALUE>:: GetCurrentAssoc(POSITION rPosition, KEY& rKey, VALUE& rValue) const
{
	BOOL t_Status ;

	if ( criticalSection )
	{
		criticalSection->Lock () ;
		t_Status = cmap.GetCurrentAssoc ( rPosition , rKey , rValue ) ;
		criticalSection->Unlock () ;
	}
	else
	{
		t_Status = cmap.GetCurrentAssoc ( rPosition , rKey , rValue ) ;
	}

	return t_Status ;
}

#endif // __SNMPCONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\ssent.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: session.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the ErrorInfo and
		 the SessionSentStateStore classes
--------------------------------------------------*/

#ifndef __SESSION_SENT_STATE_STORE
#define __SESSION_SENT_STATE_STORE

#include "common.h"
#include "forward.h"

// encapsulates the state information required to inform the SnmpOperation
// of any errors in an attempt to transmit (ex. unable to encode the
// security context)

class ErrorInfo
{
	SnmpOperation *operation;
	SnmpErrorReport error_report;

public:

	ErrorInfo(SnmpOperation &operation, IN const SnmpErrorReport &error_report)
		: operation(&operation), error_report(error_report)
	{}

	SnmpOperation *GetOperation(void)
	{
		return operation;
	}

	SnmpErrorReport GetErrorReport(void)
	{
		return error_report;
	}
};


// stores the ErrorInfo data structure for frames that errored in
// an attempt to transmit

class SessionSentStateStore
{
	typedef CMap<SessionFrameId, SessionFrameId, ErrorInfo *, ErrorInfo *> Store;

	Store store;

public:

	// makes a copy of the error report for storage
	void Register(IN SessionFrameId id, 
				  IN SnmpOperation &operation,
				  IN const SnmpErrorReport &error_report);

	SnmpErrorReport Remove(IN SessionFrameId id, OUT SnmpOperation *&operation);

	void Remove(IN SessionFrameId id);

	~SessionSentStateStore(void);
};



#endif // __SESSION_SENT_STATE_STORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\ssess.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: ssess.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the SecuritySession class
--------------------------------------------------*/

#ifndef __SECURITY_SESSION__
#define __SECURITY_SESSION__

#include "forward.h"
#include "common.h"
#include "wsess.h"

// this class is provided to just hide the
// details of winSnmp by avoiding manipulating
// the winSnmp handles directly

#endif // __SECURITY_SESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\sync.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: sync.hpp 
Author: B.Rajeev
Purpose: Provides declarations for the MutexLock and 
		 the SemaphoreLock classes (derived from a 
		 generic Lock template class)
--------------------------------------------------*/
#ifndef __SYNC__
#define __SYNC__

// for exception specification
#include "excep.h"

typedef HANDLE Mutex;
typedef HANDLE Semaphore;

#define IMMEDIATE 0

// a generic template class used to build synchronization primitives
// like a Mutex and a Semaphore

template <class SyncObjType>
class Lock
{	
protected:

	// the sync_obj may be a mutex/semaphore etc.
	SyncObjType	sync_obj;

	// number of locks on the sync obj
	LONG num_locks;

	// an option that specifies if the held locks must be released
	// when the lock is destroyed
	BOOL release_on_destroy;

	virtual DWORD OpenOperation(DWORD wait_time) = 0 ;

	virtual BOOL ReleaseOperation(LONG num_release = 1, 
								  LONG *previous_count = NULL) = 0;

public:

	Lock(SyncObjType sync_obj, BOOL release_on_destroy = TRUE) : sync_obj ( sync_obj )
	{ 
		num_locks = 0;
		Lock::release_on_destroy = release_on_destroy;
	}

	BOOL GetLock(DWORD wait_time);

	UINT UnLock(LONG num_release = 1);
};

template <class SyncObjType>
BOOL Lock<SyncObjType>::GetLock(DWORD wait_time)
{
	DWORD wait_result = OpenOperation (wait_time);
	
	if ( wait_result == WAIT_FAILED )
		return FALSE;
	else if ( wait_result == WAIT_TIMEOUT )
		return FALSE;
	else
	{
		num_locks++;
		return TRUE;
	}
}

template <class SyncObjType>
UINT Lock<SyncObjType>::UnLock(LONG num_release)
{	
	LONG previous_count;
	BOOL release_result = 
		ReleaseOperation(num_release, &previous_count);

	if ( release_result == TRUE )
		num_locks -= num_release;
	else
		throw GeneralException(Snmp_Error, Snmp_Local_Error);

	return previous_count;
}

class MutexLock : public Lock<Mutex>
{
private:

	BOOL ReleaseOperation(LONG num_release = 1, 
						  LONG *previous_count = NULL)
	{
		// both parameters are ignored
		return ReleaseMutex(sync_obj);
	}

	DWORD OpenOperation(DWORD wait_time) 
	{
		return WaitForSingleObject(sync_obj, wait_time);
	}

public:

	MutexLock(Mutex mutex, BOOL release_on_destroy = TRUE)
		: Lock<Mutex>(mutex, release_on_destroy)
	{}

	~MutexLock(void)
	{ 
		if ( (release_on_destroy == TRUE) && (num_locks != 0) )
			UnLock(num_locks);
	}
};

class SemaphoreLock : public Lock<Semaphore>
{
private:

	DWORD OpenOperation(DWORD wait_time) 
	{
		return WaitForSingleObject(sync_obj, wait_time);
	}

	BOOL ReleaseOperation(LONG num_release = 1, 
						  LONG *previous_count = NULL) 
	{ 
		return ReleaseSemaphore(sync_obj, num_release, previous_count); 
	}

public:
	SemaphoreLock(Semaphore semaphore, 
				  BOOL release_on_destroy = TRUE)
				  : Lock<Semaphore>(semaphore, release_on_destroy)
	{}

	~SemaphoreLock(void)
	{ 
		if ( (release_on_destroy == TRUE) && (num_locks != 0) )
			UnLock(num_locks);
	}
};

class CriticalSectionLock;
class CriticalSection 
{
friend CriticalSectionLock;
private:

	CRITICAL_SECTION m_CriticalSection ;

public:

	CriticalSection () 
	{
		InitializeCriticalSection ( &m_CriticalSection ) ;
	}
	
	~CriticalSection()
	{ 
		DeleteCriticalSection ( &m_CriticalSection ) ;
	}
};

class CriticalSectionLock : public Lock<CriticalSection&>
{
private:

	BOOL ReleaseOperation(LONG num_release = 1, 
						  LONG *previous_count = NULL)
	{
		// both parameters are ignored
		LeaveCriticalSection(&sync_obj.m_CriticalSection);
		return TRUE;
	}

	DWORD OpenOperation(DWORD wait_time) 
	{
		EnterCriticalSection(&sync_obj.m_CriticalSection);
		return TRUE;
	}

public:

	CriticalSectionLock(CriticalSection &criticalSection, BOOL release_on_destroy = TRUE)
		: Lock<CriticalSection &>(criticalSection, release_on_destroy)
	{}

	~CriticalSectionLock(void)
	{ 
		if ( (release_on_destroy == TRUE) && (num_locks != 0) )
			UnLock(num_locks);
	}
};

#endif // __SYNC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\timer.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: timer.hpp
Author: B.Rajeev
Purpose: Provides declarations for the Timer class.
--------------------------------------------------*/


#ifndef __TIMER__
#define __TIMER__

#define ILLEGAL_TIMER_EVENT_ID	0
#define RETRY_TIMEOUT_FACTOR 10
typedef UINT_PTR TimerEventId;

#include <snmpevt.h>
#include <snmpthrd.h>

#include "forward.h"
#include "common.h"
#include "message.h"

typedef CMap< TimerEventId, TimerEventId, Timer *, Timer * > TimerMapping;
typedef CList< WaitingMessage * , WaitingMessage * > WaitingMessageContainer;

class SnmpClThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	SnmpClThreadObject () ;

	void Initialise () ; 
	void Uninitialise () ;

} ;

class SnmpClTrapThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	SnmpClTrapThreadObject () ;

	void Initialise () ; 
	void Uninitialise () ;

} ;

/*--------------------------------------------------
Overview
--------

  Timer: Provides methods for setting and cancelling timer
events. When the timer is informed of a timer event, it determines
the corresponding waiting message and notifies it.

  note - the timer has static data structures which enable it
  to identify the timer instance corresponding to a timer event id.
  therefore, each timer event must not only be registered as a
  <timer_event_id, waiting_message *> pair within a timer instance, but
  also as a <timer_event_id, timer *> pair in the static CMap. The CriticalSection
  is needed to serialize access to the CMap
--------------------------------------------------*/

class Timer
{
	// counter to generate timer_event_id
	static TimerEventId next_timer_event_id;

	// v1 session: for obtaining the event handler
	SnmpImpSession *session;

	// map for (event_id, waiting_message) association and
	// unique event_id generation
	static TimerMapping timer_mapping;
	WaitingMessageContainer waiting_message_mapping;

	static BOOL CreateCriticalSection();

	static void DestroyCriticalSection();

public:

	Timer(SnmpImpSession &session);

	// generates and returns a new event id
	// associates the pair (event_id, waiting_message)
	// creates the timer event
	void SetMessageTimerEvent (WaitingMessage &waiting_message);

	TimerEventId SetTimerEvent(UINT timeout_value);

	// Removes the association (event_id, waiting_message)
	void CancelMessageTimer(WaitingMessage &waiting_message,TimerEventId event_id);

	// Kills the registered timer event
	void CancelTimer(TimerEventId event_id);

	// used to create the static CriticalSection
	static BOOL InitializeStaticComponents();

	// used to destroy the static CriticalSection
	static void DestroyStaticComponents();

	// it determines the corresponding Timer and calls 
	// its TimerEventNotification with the appropriate parameters
	static void CALLBACK HandleGlobalEvent(HWND hWnd ,UINT message,
										   UINT_PTR idEvent, DWORD dwTime);

	// informs the timer instance of the event. the instance
	// must pass the event to the corresponding waiting message
	void TimerEventNotification(TimerEventId event_id);

	virtual ~Timer(void);

	static SnmpClThreadObject *g_timerThread ;

	static UINT g_SnmpWmTimer ;

	// the CriticalSection serializes accesses to the static timer_mapping
	static CriticalSection timer_CriticalSection;

};

class SnmpTimerObject
{
private:

	HWND hWnd ;
	UINT_PTR timerId ;
	TIMERPROC lpTimerFunc ;

protected:
public:

	SnmpTimerObject ( 

		HWND hWnd , 
		UINT_PTR timerId , 
		UINT elapsedTime ,
		TIMERPROC lpTimerFunc 
	) ;

	~SnmpTimerObject () ;

	UINT_PTR GetTimerId () { return timerId ; }
	HWND GetHWnd () { return hWnd ; }
	TIMERPROC GetTimerFunc () { return lpTimerFunc ; }

	static Window *window ;
	static CMap <UINT_PTR,UINT_PTR,SnmpTimerObject *,SnmpTimerObject *> timerMap ;
	static void TimerNotification ( HWND hWnd , UINT timerId ) ;

} ;

class SnmpTimerEventObject : public SnmpTaskObject
{
private:
protected:

	SnmpTimerEventObject () {} 

public:

	virtual ~SnmpTimerEventObject () {} ;
} ;

class SnmpSetTimerObject : public SnmpTimerEventObject
{
private:

	UINT_PTR timerId ;
	HWND hWnd ;
	UINT elapsedTime ;
	TIMERPROC lpTimerFunc ;

protected:
public:

	SnmpSetTimerObject (

		HWND hWnd,				// handle of window for timer messages
		UINT_PTR nIDEvent,			// timer identifier
		UINT uElapse,			// time-out value
		TIMERPROC lpTimerFunc	// address of timer procedure
   ) ;

	~SnmpSetTimerObject () ;

	UINT_PTR GetTimerId () { return timerId ; }

	void Process () ;
} ;

class SnmpKillTimerObject : public SnmpTimerEventObject
{
private:

	BOOL status ;
	HWND hWnd ;
	UINT_PTR timerId ;

protected:
public:

	SnmpKillTimerObject (

		HWND hWnd ,				// handle of window that installed timer
		UINT_PTR uIDEvent			// timer identifier
	) ;

	~SnmpKillTimerObject () {} ;

	void Process () ;

	BOOL GetStatus () { return status ; }
} ;

UINT_PTR SnmpSetTimer (

	HWND hWnd,				// handle of window for timer messages
	UINT_PTR nIDEvent,			// timer identifier
	UINT uElapse,			// time-out value,
	TIMERPROC lpTimerFunc 	// address of timer procedure
) ;

BOOL SnmpKillTimer (

    HWND hWnd,		// handle of window that installed timer
    UINT_PTR uIDEvent 	// timer identifier
) ;

#endif // __TIMER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\startup.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __STARTUP__
#define __STARTUP__

class DllImportExport SnmpClassLibrary 
{
private:
protected:

	static LONG s_ReferenceCount ;

	SnmpClassLibrary () {} ;

public:

	virtual ~SnmpClassLibrary () {} 

	static BOOL Startup () ;
	static void Closedown () ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\snmptype.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#include <provexpt.h>

DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString ) ;
DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString ) ;
DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix ) ;
DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) ;

class DllImportExport CBString
{
private:

    BSTR    m_pString;

public:

    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) 
		{
            SysFreeString(m_pString);
        }
        
		m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#if _MSC_VER >= 1100
template <> DllImportExport UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key ) ;
#else
DllImportExport UINT HashKey ( wchar_t *key ) ;
#endif

#if _MSC_VER >= 1100
typedef wchar_t * HmmHack_wchar_t ;
template<> DllImportExport BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const HmmHack_wchar_t *pElement1, const HmmHack_wchar_t *pElement2 ) ;
#else
DllImportExport BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 ) ;
#endif

union SnmpLexiconValue
{
	LONG signedInteger ;
	ULONG unsignedInteger ;
	wchar_t *token ;
} ;

class SnmpAnalyser;
class DllImportExport SnmpLexicon
{
friend SnmpAnalyser ;
public:

enum LexiconToken {

	TOKEN_ID ,
	SIGNED_INTEGER_ID ,
	UNSIGNED_INTEGER_ID ,
	COLON_ID ,
	COMMA_ID ,
	OPEN_PAREN_ID ,
	CLOSE_PAREN_ID ,
	DOT_ID ,
	DOTDOT_ID ,
	PLUS_ID ,
	MINUS_ID ,
	EOF_ID,
	WHITESPACE_ID,
	INVALID_ID,
	USERDEFINED_ID
} ;

private:

	wchar_t *tokenStream ;
	ULONG position ;
	LexiconToken token ;
	SnmpLexiconValue value ;

protected:
public:

	SnmpLexicon () ;
	~SnmpLexicon () ;

	void SetToken ( SnmpLexicon :: LexiconToken a_Token ) ;
	SnmpLexicon :: LexiconToken GetToken () ;
	SnmpLexiconValue *GetValue () ;
} ;

#define ANALYSER_ACCEPT_STATE 10000
#define ANALYSER_REJECT_STATE 10001

/* 
	User defined states should be greater than 20000
 */

class DllImportExport SnmpAnalyser
{
private:

	wchar_t *stream ;
	ULONG position ;
	BOOL status ;

	SnmpLexicon *GetToken (  BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

protected:

	virtual void Initialise () {} ;

	virtual SnmpLexicon *CreateLexicon () { return new SnmpLexicon ; }

	virtual BOOL Analyse ( 

		SnmpLexicon *lexicon , 
		ULONG &state , 
		const wchar_t token , 
		const wchar_t *tokenStream , 
		ULONG &position , 
		BOOL unSignedIntegersOnly , 
		BOOL leadingIntegerZeros , 
		BOOL eatSpace 
	) 
	{ return FALSE ; }

public:

	SnmpAnalyser ( const wchar_t *tokenStream = NULL ) ;
	virtual ~SnmpAnalyser () ;

	void Set ( const wchar_t *tokenStream ) ;

	SnmpLexicon *Get ( BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

	void PutBack ( const SnmpLexicon *token ) ;

	virtual operator void * () ;

	static BOOL IsEof ( wchar_t token ) ;
	static BOOL IsLeadingDecimal ( wchar_t token ) ;
	static BOOL IsDecimal ( wchar_t token ) ;
	static BOOL IsOctal ( wchar_t token ) ;
	static BOOL IsHex ( wchar_t token ) ;	
	static BOOL IsAlpha ( wchar_t token ) ;
	static BOOL IsAlphaNumeric ( wchar_t token ) ;
	static BOOL IsWhitespace ( wchar_t token ) ;

	static ULONG OctWCharToDecInteger ( wchar_t token ) ;
	static ULONG HexWCharToDecInteger ( wchar_t token ) ;
	static ULONG DecWCharToDecInteger ( wchar_t token ) ;
	static wchar_t DecIntegerToHexWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToDecWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToOctWChar ( UCHAR integer ) ;

	static ULONG OctCharToDecInteger ( char token ) ;
	static ULONG HexCharToDecInteger ( char token ) ;
	static ULONG DecCharToDecInteger ( char token ) ;
	static char DecIntegerToHexChar ( UCHAR integer ) ;
	static char DecIntegerToDecChar ( UCHAR integer ) ;
	static char DecIntegerToOctChar ( UCHAR integer ) ;

} ;

class DllImportExport SnmpNegativeRangeType
{
private:
protected:

	LONG lowerBound ;
	LONG upperBound ;

public:

	SnmpNegativeRangeType ( const SnmpNegativeRangeType &rangeType ) : lowerBound ( rangeType.lowerBound ) , upperBound ( rangeType.upperBound ) {}
	SnmpNegativeRangeType ( LONG lowerBoundArg , LONG upperBoundArg ) : lowerBound ( lowerBoundArg ) , upperBound ( upperBoundArg ) {}
	SnmpNegativeRangeType () : lowerBound ( 0 ) , upperBound ( 0 ) { } ;
	virtual ~SnmpNegativeRangeType () {}


	LONG GetLowerBound () { return lowerBound ; }
	LONG GetUpperBound () { return upperBound ; }
	void SetUpperBound ( const LONG &upperBoundArg ) { upperBound = upperBoundArg ; }
	void SetLowerBound ( const LONG &lowerBoundArg ) { lowerBound = lowerBoundArg ; }

	virtual SnmpNegativeRangeType *Copy () { return new SnmpNegativeRangeType ( *this ) ; }
} ;

class SnmpNegativeRangedType
{
private:
protected:

	BOOL status ;

	SnmpList <SnmpNegativeRangeType,SnmpNegativeRangeType> rangedValues ;

	BOOL Parse ( const wchar_t *rangedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	SnmpAnalyser analyser ;
	SnmpLexicon *pushBack ;

	void PushBack () ;
	SnmpLexicon *Get () ;
	SnmpLexicon *Match ( SnmpLexicon :: LexiconToken tokenType ) ;

	BOOL RecursiveDef () ;
	BOOL RangeDef () ;

public:

	SnmpNegativeRangedType ( const SnmpNegativeRangedType &rangedValues ) ;
	SnmpNegativeRangedType ( const wchar_t *rangedValues = NULL ) ;
	virtual ~SnmpNegativeRangedType () ;

	BOOL IsValid () { return status ; }

	void SetStatus ( const BOOL &statusArg ) { status = statusArg ; }

	BOOL Check ( const LONG &value ) ;

	virtual operator void* () { return status ? this : NULL ; } 

} ;

class DllImportExport SnmpPositiveRangeType
{
private:
protected:

	ULONG lowerBound ;
	ULONG upperBound ;

public:

	SnmpPositiveRangeType ( const SnmpPositiveRangeType &rangeType ) : lowerBound ( rangeType.lowerBound ) , upperBound ( rangeType.upperBound ) {}
	SnmpPositiveRangeType ( ULONG lowerBoundArg , LONG upperBoundArg ) : lowerBound ( lowerBoundArg ) , upperBound ( upperBoundArg ) {}
	SnmpPositiveRangeType () : lowerBound ( 0 ) , upperBound ( 0 ) { } ;
	virtual ~SnmpPositiveRangeType () {}


	ULONG GetLowerBound () { return lowerBound ; }
	ULONG GetUpperBound () { return upperBound ; }
	void SetUpperBound ( const ULONG &upperBoundArg ) { upperBound = upperBoundArg ; }
	void SetLowerBound ( const ULONG &lowerBoundArg ) { lowerBound = lowerBoundArg ; }

	virtual SnmpPositiveRangeType *Copy () { return new SnmpPositiveRangeType ( *this ) ; }
} ;

class DllImportExport SnmpPositiveRangedType
{
private:
protected:

	BOOL status ;

	SnmpList <SnmpPositiveRangeType,SnmpPositiveRangeType> rangedValues ;

	BOOL Parse ( const wchar_t *rangedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	SnmpAnalyser analyser ;
	SnmpLexicon *pushBack ;

	void PushBack () ;
	SnmpLexicon *Get () ;
	SnmpLexicon *Match ( SnmpLexicon :: LexiconToken tokenType ) ;

	BOOL RecursiveDef () ;
	BOOL RangeDef () ;

public:

	SnmpPositiveRangedType ( const SnmpPositiveRangedType &rangedValues ) ;
	SnmpPositiveRangedType ( const wchar_t *rangedValues = NULL ) ;
	virtual ~SnmpPositiveRangedType () ;

	void SetStatus ( const BOOL &statusArg ) { status = statusArg ; }

	BOOL IsValid () { return status ; }

	BOOL Check ( const ULONG &value ) ;

	virtual operator void* () { return status ? this : NULL ; }
} ;

class DllImportExport SnmpFixedType
{
private:
protected:

	ULONG fixedLength ;

public:

	SnmpFixedType ( const SnmpFixedType &fixedLengthArg ) { fixedLength = fixedLengthArg.fixedLength ; }
	SnmpFixedType ( const ULONG fixedLengthArg ) { fixedLength = fixedLengthArg ; }
	virtual ~SnmpFixedType () {} ;
} ;

class DllImportExport SnmpInstanceType 
{
private:
protected:

	BOOL m_IsNull ;
	BOOL status ;

	SnmpInstanceType ( const SnmpInstanceType &copy ) { status = copy.status ; m_IsNull = copy.m_IsNull ; }
	SnmpInstanceType ( BOOL statusArg = TRUE , BOOL nullArg = FALSE ) { status = statusArg ; m_IsNull = nullArg ; } ;
	virtual BOOL Equivalent (IN const SnmpInstanceType &value) const = 0;

public:

	virtual ~SnmpInstanceType () {} ;

	virtual SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const = 0  ;
	virtual SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) = 0 ;

	virtual const SnmpValue *GetValueEncoding () const = 0 ;
	virtual wchar_t *GetStringValue () const = 0 ;

	virtual SnmpInstanceType *Copy () const = 0 ;

	virtual operator void *() ;

	void SetStatus ( BOOL statusArg ) { status = statusArg ; }
	void SetNull ( BOOL nullArg ) { m_IsNull = nullArg ; }

	virtual BOOL IsValid () const ;
	virtual BOOL IsNull () const ;
	virtual BOOL IsSNMPV1Type () const { return TRUE ; }
	virtual BOOL IsSNMPV2CType () const { return TRUE ; }

	BOOL operator==(IN const SnmpInstanceType &value) const
	{
		return Equivalent(value) ;
	}

	BOOL operator!=(IN const SnmpInstanceType &value) const
	{
		return !((*this) == value) ;
	}

} ;

class DllImportExport SnmpNullType : public SnmpInstanceType
{
private:

	SnmpNull null ;

protected:

	BOOL Equivalent (IN const SnmpInstanceType &value) const;

public:

	SnmpNullType ( const SnmpNullType &nullArg ) ;
	SnmpNullType ( const SnmpNull &nullArg ) ;
	SnmpNullType () ;
	~SnmpNullType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;

	BOOL IsSNMPV2CType () const { return FALSE ; }
} ;

class DllImportExport SnmpIntegerType : public SnmpInstanceType , protected SnmpNegativeRangedType
{
private:
protected:

	SnmpInteger integer ;
	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *integerArg ) ;

public:

	SnmpIntegerType ( const SnmpIntegerType &integerArg ) ;
	SnmpIntegerType ( const SnmpInteger &integerArg , const wchar_t *rangeValues ) ;
	SnmpIntegerType ( const wchar_t *integerArg , const wchar_t *rangeValues ) ;
	SnmpIntegerType ( const LONG integerArg , const wchar_t *rangeValues ) ;
	SnmpIntegerType ( const wchar_t *rangeValues = NULL ) ;
	~SnmpIntegerType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const ;
	wchar_t *GetStringValue () const ;
	LONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpGaugeType : public SnmpInstanceType , protected SnmpPositiveRangedType
{
private:
protected:

	SnmpGauge gauge ;

	BOOL Parse ( const wchar_t *gaugeArg )  ;
	BOOL Equivalent (IN const SnmpInstanceType &value) const ;

public:

	SnmpGaugeType ( const SnmpGaugeType &gaugeArg ) ;
	SnmpGaugeType ( const SnmpGauge &gaugeArg , const wchar_t *rangeValues ) ;
	SnmpGaugeType ( const wchar_t *gaugeArg , const wchar_t *rangeValues ) ;
	SnmpGaugeType ( const ULONG gaugeArg , const wchar_t *rangeValues ) ;
	SnmpGaugeType ( const wchar_t *rangeValues = NULL ) ;
	~SnmpGaugeType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpUInteger32Type : public SnmpInstanceType , protected SnmpPositiveRangedType
{
private:
protected:

	SnmpUInteger32 ui_integer32 ;

	BOOL Parse ( const wchar_t *ui_integerArg )  ;
	BOOL Equivalent (IN const SnmpInstanceType &value) const ;

public:

	SnmpUInteger32Type ( const SnmpUInteger32Type &ui_integerArg ) ;
	SnmpUInteger32Type ( const SnmpUInteger32 &ui_integerArg , const wchar_t *rangeValues ) ;
	SnmpUInteger32Type ( const wchar_t *ui_integerArg , const wchar_t *rangeValues ) ;
	SnmpUInteger32Type ( const ULONG ui_integerArg , const wchar_t *rangeValues ) ;
	SnmpUInteger32Type ( const wchar_t *rangeValues = NULL ) ;
	~SnmpUInteger32Type () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;


class DllImportExport  SnmpTimeTicksType : public SnmpInstanceType
{
private:
protected:

	SnmpTimeTicks timeTicks ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *timeTicksArg )  ;

public:

	SnmpTimeTicksType ( const SnmpTimeTicks &timeTicksArg ) ;
	SnmpTimeTicksType ( const SnmpTimeTicksType &timeTicksArg ) ;
	SnmpTimeTicksType ( const wchar_t *timeTicksArg ) ;
	SnmpTimeTicksType ( const ULONG timeTicksArg ) ;
	SnmpTimeTicksType () ;
	~SnmpTimeTicksType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpCounterType : public SnmpInstanceType 
{
private:
protected:

	SnmpCounter counter ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *counterArg )  ;

public:

	SnmpCounterType ( const SnmpCounter &counterArg ) ;
	SnmpCounterType ( const SnmpCounterType &counterArg ) ;
	SnmpCounterType ( const wchar_t *counterArg ) ;
	SnmpCounterType ( const ULONG counterArg ) ;
	SnmpCounterType () ;
	~SnmpCounterType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;
	
	SnmpInstanceType *Copy () const ;

} ;

class DllImportExport  SnmpCounter64Type : public SnmpInstanceType 
{
private:
protected:

	SnmpCounter64 counter64;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *counterArg )  ;

public:

	SnmpCounter64Type ( const SnmpCounter64Type &counterArg ) ;
	SnmpCounter64Type ( const SnmpCounter64 &counterArg ) ;
	SnmpCounter64Type ( const wchar_t *counterArg ) ;
	SnmpCounter64Type ( const ULONG counterHighArg , const ULONG counterLowArg ) ;
	SnmpCounter64Type () ;
	~SnmpCounter64Type () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	void GetValue ( ULONG &counterHighArg , ULONG &counterLowArg ) const ;

	BOOL IsSNMPV1Type () const { return FALSE ; } 
	
	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpIpAddressType : public SnmpInstanceType
{
private:
protected:

	SnmpIpAddress ipAddress ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *ipAddressArg )  ;

public:

	SnmpIpAddressType ( const SnmpIpAddress &ipAddressArg ) ;
	SnmpIpAddressType ( const SnmpIpAddressType &ipAddressArg ) ;
	SnmpIpAddressType ( const wchar_t *ipAddressArg ) ;
	SnmpIpAddressType ( const ULONG ipAddressArg ) ;
	SnmpIpAddressType () ;
	~SnmpIpAddressType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpNetworkAddressType : public SnmpInstanceType
{
private:
protected:

	SnmpIpAddress ipAddress ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *gaugeArg )  ;

public:

	SnmpNetworkAddressType ( const SnmpIpAddress &ipAddressArg ) ;
	SnmpNetworkAddressType ( const SnmpNetworkAddressType &ipAddressArg ) ;
	SnmpNetworkAddressType ( const wchar_t *networkAddressArg ) ;
	SnmpNetworkAddressType ( const ULONG ipAddressArg ) ;
	SnmpNetworkAddressType () ;
	~SnmpNetworkAddressType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const  ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpObjectIdentifierType : public SnmpInstanceType
{
private:
protected:

	SnmpObjectIdentifier objectIdentifier ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *objectIdentifierArg )  ;

public:

	SnmpObjectIdentifierType ( const SnmpObjectIdentifier &objectIdentifierArg ) ;
	SnmpObjectIdentifierType ( const SnmpObjectIdentifierType &objectIdentifierArg ) ;
	SnmpObjectIdentifierType ( const wchar_t *objectIdentifierArg ) ;
	SnmpObjectIdentifierType ( IN const ULONG *value , IN const ULONG valueLength ) ;
	SnmpObjectIdentifierType () ;
	~SnmpObjectIdentifierType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	ULONG *GetValue () const ;

	SnmpInstanceType *Copy () const ;

	SnmpObjectIdentifierType &operator=(const SnmpObjectIdentifierType &to_copy ) ;
} ;

class DllImportExport  SnmpOpaqueType : public SnmpInstanceType , protected SnmpPositiveRangedType
{
private:
protected:

	SnmpOpaque opaque ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *opaqueArg )  ;

public:

	SnmpOpaqueType ( const SnmpOpaque &opaqueArg , const wchar_t *rangedValues ) ;
	SnmpOpaqueType ( const SnmpOpaqueType &opaqueArg ) ;
	SnmpOpaqueType ( const wchar_t *opaqueArg , const wchar_t *rangedValues ) ;
	SnmpOpaqueType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	SnmpOpaqueType ( const wchar_t *rangedValues = NULL ) ;
	~SnmpOpaqueType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	UCHAR *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpFixedLengthOpaqueType : public SnmpOpaqueType , protected SnmpFixedType
{
private:
protected:
public:

	SnmpFixedLengthOpaqueType ( const ULONG &fixedLength , const SnmpOpaque &opaqueArg ) ;
	SnmpFixedLengthOpaqueType ( const SnmpFixedLengthOpaqueType &opaqueArg ) ;
	SnmpFixedLengthOpaqueType ( const ULONG &fixedLength , const wchar_t *opaqueArg ) ;
	SnmpFixedLengthOpaqueType ( const ULONG &fixedLengthArg , const UCHAR *value , const ULONG valueLength ) ;
	SnmpFixedLengthOpaqueType ( const ULONG &fixedLength ) ;
	~SnmpFixedLengthOpaqueType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpOctetStringType : public SnmpInstanceType , protected SnmpPositiveRangedType
{
private:
protected:

	SnmpOctetString octetString ;

	BOOL Equivalent (IN const SnmpInstanceType &value) const ;
	BOOL Parse ( const wchar_t *octetStringArg )  ;

public:

	SnmpOctetStringType ( const SnmpOctetString &octetStringArg , const wchar_t *rangedValues ) ;
	SnmpOctetStringType ( const SnmpOctetStringType &octetStringArg ) ;
	SnmpOctetStringType ( const wchar_t *octetStringArg , const wchar_t *rangedValues ) ;
	SnmpOctetStringType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	SnmpOctetStringType ( const wchar_t *rangedValues = NULL ) ;
	~SnmpOctetStringType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	const SnmpValue *GetValueEncoding () const;
	wchar_t *GetStringValue () const ;
	ULONG GetValueLength () const ;
	UCHAR *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpFixedLengthOctetStringType : public SnmpOctetStringType , protected SnmpFixedType
{
private:
protected:
public:

	SnmpFixedLengthOctetStringType ( const ULONG &fixedLength , const SnmpOctetString &octetStringArg ) ;
	SnmpFixedLengthOctetStringType ( const SnmpFixedLengthOctetStringType &octetStringArg ) ;
	SnmpFixedLengthOctetStringType ( const ULONG &fixedLength , const wchar_t *octetStringArg ) ;
	SnmpFixedLengthOctetStringType ( const ULONG &fixedLength , const UCHAR *value ) ;
	SnmpFixedLengthOctetStringType ( const ULONG &fixedLength ) ;
	~SnmpFixedLengthOctetStringType () ;

	SnmpObjectIdentifier Encode ( const SnmpObjectIdentifier &objectIdentifier ) const ;
	SnmpObjectIdentifier Decode ( const SnmpObjectIdentifier &objectIdentifier ) ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpMacAddressType : public SnmpFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *macAddressArg )  ;

public:

	SnmpMacAddressType ( const SnmpOctetString &macAddressArg ) ;
	SnmpMacAddressType ( const SnmpMacAddressType &macAddressArg ) ;
	SnmpMacAddressType ( const wchar_t *macAddressArg ) ;
	SnmpMacAddressType ( const UCHAR *macAddressArg ) ;
	SnmpMacAddressType () ;
	~SnmpMacAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpPhysAddressType : public SnmpOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *physAddressArg )  ;

public:

	SnmpPhysAddressType ( const SnmpOctetString &physAddressArg , const wchar_t *rangedValues  ) ;
	SnmpPhysAddressType ( const SnmpPhysAddressType &physAddressArg ) ;
	SnmpPhysAddressType ( const wchar_t *physAddressArg , const wchar_t *rangedValues ) ;
	SnmpPhysAddressType ( const UCHAR *value , const ULONG valueLength , const wchar_t *rangedValues ) ;
	SnmpPhysAddressType ( const wchar_t *rangedValues = NULL ) ;
	~SnmpPhysAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpFixedLengthPhysAddressType : public SnmpFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *physAddressArg )  ;

public:

	SnmpFixedLengthPhysAddressType ( const ULONG &fixedLength , const SnmpOctetString &physAddressArg ) ;
	SnmpFixedLengthPhysAddressType ( const SnmpFixedLengthPhysAddressType &physAddressArg ) ;
	SnmpFixedLengthPhysAddressType ( const ULONG &fixedLength , const wchar_t *physAddressArg ) ;
	SnmpFixedLengthPhysAddressType ( const ULONG &fixedLength , const UCHAR *value , const ULONG valueLength ) ;
	SnmpFixedLengthPhysAddressType ( const ULONG &fixedLength ) ;
	~SnmpFixedLengthPhysAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpDisplayStringType : public SnmpOctetStringType
{
private:
protected:
public:

	SnmpDisplayStringType ( const SnmpOctetString &displayStringArg , const wchar_t *rangedValues ) ;
	SnmpDisplayStringType ( const SnmpDisplayStringType &displayStringArg ) ;
	SnmpDisplayStringType ( const wchar_t *displayStringArg , const wchar_t *rangedValues ) ;
	SnmpDisplayStringType ( const wchar_t *rangedValues = NULL ) ;
	~SnmpDisplayStringType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpFixedLengthDisplayStringType : public SnmpFixedLengthOctetStringType 
{
private:
protected:
public:

	SnmpFixedLengthDisplayStringType ( const ULONG &fixedLength , const SnmpOctetString &displayStringArg ) ;
	SnmpFixedLengthDisplayStringType ( const SnmpFixedLengthDisplayStringType &displayStringArg ) ;
	SnmpFixedLengthDisplayStringType ( const ULONG &fixedLength , const wchar_t *displayStringArg ) ;
	SnmpFixedLengthDisplayStringType ( const ULONG &fixedLength ) ;
	~SnmpFixedLengthDisplayStringType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpEnumeratedType : public SnmpIntegerType
{
private:

	SnmpMap <LONG, const LONG,wchar_t *,wchar_t *> integerMap ;
	SnmpMap <wchar_t *,wchar_t *,LONG,LONG> stringMap ;

	BOOL Parse ( const wchar_t *enumeratedValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	SnmpAnalyser analyser ;
	SnmpLexicon *pushBack ;

	void PushBack () ;
	SnmpLexicon *Get () ;
	SnmpLexicon *Match ( SnmpLexicon :: LexiconToken tokenType ) ;

	BOOL EnumerationDef () ;
	BOOL RecursiveDef () ;

protected:
public:

	SnmpEnumeratedType ( const wchar_t *enumeratedValues , const LONG &enumeratedValue ) ;
	SnmpEnumeratedType ( const wchar_t *enumeratedValues , const wchar_t *enumeratedValue ) ;
	SnmpEnumeratedType ( const wchar_t *enumeratedValues , const SnmpInteger &enumeratedValue ) ;
	SnmpEnumeratedType ( const SnmpEnumeratedType &enumerateValues ) ;
	SnmpEnumeratedType ( const wchar_t *enumeratedValues ) ;
	~SnmpEnumeratedType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpRowStatusType : public SnmpEnumeratedType
{
private:
protected:
public:

	enum SnmpRowStatusEnum
	{
		active = 1 ,
		notInService = 2 ,
		notReady = 3 ,
		createAndGo = 4 ,
		createAndWait = 5,
		destroy = 6
	} ;

	SnmpRowStatusType ( const LONG &rowStatusValue ) ;
	SnmpRowStatusType ( const wchar_t *rowStatusValue ) ;
	SnmpRowStatusType ( const SnmpInteger &rowStatusValue ) ;
	SnmpRowStatusType ( const SnmpRowStatusType &rowStatusValue ) ;
	SnmpRowStatusType ( const SnmpRowStatusEnum &rowStatusValue ) ;
	SnmpRowStatusType () ;
	~SnmpRowStatusType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;
	SnmpRowStatusEnum GetRowStatus () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpBitStringType : public SnmpOctetStringType
{
private:

	SnmpMap <ULONG, const ULONG,wchar_t *,wchar_t *> integerMap ;
	SnmpMap <wchar_t *,wchar_t *,ULONG,ULONG> stringMap ;

	BOOL Parse ( const wchar_t *bitStringValues ) ;

//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	SnmpAnalyser analyser ;
	SnmpLexicon *pushBack ;

	void PushBack () ;
	SnmpLexicon *Get () ;
	SnmpLexicon *Match ( SnmpLexicon :: LexiconToken tokenType ) ;

	BOOL BitStringDef () ;
	BOOL RecursiveDef () ;

protected:
public:

	SnmpBitStringType ( const wchar_t *bitStringValues , const SnmpOctetString &bitStringValue ) ;
	SnmpBitStringType ( const wchar_t *bitStringValues , const wchar_t **bitStringValue , const ULONG &bitStringValueLength ) ;
	SnmpBitStringType ( const SnmpBitStringType &bitStringValues ) ;
	SnmpBitStringType ( const wchar_t *bitStringValues ) ;
	~SnmpBitStringType () ;

	wchar_t *GetStringValue () const ;
	ULONG SnmpBitStringType :: GetValue ( wchar_t **&stringValue ) const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport SnmpDateTimeType : public SnmpOctetStringType
{
private:

	void Encode (

		const ULONG &year ,
		const ULONG &month ,
		const ULONG &day ,
		const ULONG &hour ,
		const ULONG &minutes ,
		const ULONG &seconds ,
		const ULONG &deciSeconds ,
		const ULONG &UTC_present ,
		const ULONG &UTC_direction ,
		const ULONG &UTC_hours ,
		const ULONG &UTC_minutes
	) ;

	BOOL Parse ( const wchar_t *dateTimeValue ) ;
	BOOL DateTimeDef () ;
//
//	Lexical analysis information used when parsing token stream
//

	BOOL pushedBack ;
	SnmpAnalyser analyser ;
	SnmpLexicon *pushBack ;

	void PushBack () ;
	SnmpLexicon *Get () ;
	SnmpLexicon *Match ( SnmpLexicon :: LexiconToken tokenType ) ;

protected:
public:

	SnmpDateTimeType ( const wchar_t *dateTimeValue ) ;
	SnmpDateTimeType ( const SnmpDateTimeType &dateTimeValue ) ;
	SnmpDateTimeType ( const SnmpOctetString &dateTimeValue ) ;
	SnmpDateTimeType () ;
	~SnmpDateTimeType () ;

	wchar_t *GetStringValue () const ;
	wchar_t *GetValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport SnmpOSIAddressType : public SnmpOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *osiAddressArg )  ;

public:

	SnmpOSIAddressType ( const SnmpOctetString &osiAddressArg ) ;
	SnmpOSIAddressType ( const SnmpOSIAddressType &osiAddressArg ) ;
	SnmpOSIAddressType ( const wchar_t *osiAddressArg ) ;
	SnmpOSIAddressType ( const UCHAR *value , const ULONG valueLength ) ;
	SnmpOSIAddressType () ;
	~SnmpOSIAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpUDPAddressType : public SnmpFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *udpAddressArg )  ;

public:

	SnmpUDPAddressType ( const SnmpOctetString &udpAddressArg ) ;
	SnmpUDPAddressType ( const SnmpUDPAddressType &udpAddressArg ) ;
	SnmpUDPAddressType ( const wchar_t *udpAddressArg ) ;
	SnmpUDPAddressType ( const UCHAR *udpAddressArg ) ;
	SnmpUDPAddressType () ;
	~SnmpUDPAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;

class DllImportExport  SnmpIPXAddressType : public SnmpFixedLengthOctetStringType
{
private:
protected:

	BOOL Parse ( const wchar_t *ipxAddressArg )  ;

public:

	SnmpIPXAddressType ( const SnmpOctetString &ipxAddressArg ) ;
	SnmpIPXAddressType ( const SnmpIPXAddressType &ipxAddressArg ) ;
	SnmpIPXAddressType ( const wchar_t *ipxAddressArg ) ;
	SnmpIPXAddressType ( const UCHAR *ipxAddressArg ) ;
	SnmpIPXAddressType () ;
	~SnmpIPXAddressType () ;

	wchar_t *GetStringValue () const ;

	SnmpInstanceType *Copy () const ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\transp.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: transp.hpp  (transport.hpp)
Author: B.Rajeev
Purpose: Provides declarations for the SnmpTransport class
		and its derivatives
--------------------------------------------------*/

#ifndef __TRANSPORT__
#define __TRANSPORT__

#include "forward.h"
#include "address.h"

#pragma warning (disable:4355)

class DllImportExport SnmpTransport
{
private:

	SnmpTransportAddress *transport_address;

	// the "=" operator and the copy constructor have been
	// made private to prevent any copies from being made
	SnmpTransport &operator=(IN const SnmpTransport &transport)
	{
		return *this;
	}

	SnmpTransport(IN const SnmpTransport &snmp_transport) {}

protected:

	SnmpTransport(IN SnmpSession &session,
		IN const SnmpTransportAddress &transportAddress); 

	virtual void TransportFlowControlOn() = 0;

	virtual void TransportFlowControlOff() = 0;

public:

	virtual ~SnmpTransport();
	

	virtual void TransportSendFrame(
		
		OUT TransportFrameId &transport_frame_id, 
		IN SnmpPdu &snmpPdu
		
	) = 0 ;

	virtual void TransportReceiveFrame (

		IN SnmpPdu &snmpPdu,
		IN SnmpErrorReport &errorReport 

	) = 0 ;

	virtual void TransportSentFrame (

		IN TransportFrameId transport_frame_id,  
        IN SnmpErrorReport &errorReport 

	)  = 0;

	virtual SnmpTransportAddress &GetTransportAddress() ;

	virtual void * operator()(void) const = 0;

};

// forward declaration
class TransportSession;

class DllImportExport SnmpImpTransport: public SnmpTransport
{
	friend TransportWindow;

private:

	BOOL transport_created;
	SnmpSession &session;
	TransportWindow *transport;

	// References to the following instances are used instead of 
	// embedded instances themselves. This is done to avoid including
	// the header files providing their declaration
	
	TransportSentStateStore store;
	static TransportFrameId next_transport_frame_id;

protected:

	BOOL is_valid;

	virtual void HandleSentFrame(IN const TransportFrameId transport_frame_id);
	
	void TransportFlowControlOn() {}

	void TransportFlowControlOff() {}

public:

	SnmpImpTransport(IN SnmpSession &session,
					   IN const SnmpTransportAddress &address);

	~SnmpImpTransport();

	void TransportSendFrame (  

        OUT TransportFrameId &transport_frame_id,
		IN SnmpPdu &snmpPdu
	) ;

	void TransportReceiveFrame (

		IN SnmpPdu &snmpPdu ,
		IN SnmpErrorReport &errorReport 
	) ;

	void TransportSentFrame (

        IN TransportFrameId transport_frame_id,  
        IN SnmpErrorReport &errorReport 

    );

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

};

class DllImportExport SnmpUdpIpTransport: public SnmpImpTransport
{
private:
protected:
public:

	SnmpUdpIpTransport(IN SnmpSession &session,
					   IN const SnmpTransportIpAddress &ipAddress);
};

class DllImportExport SnmpUdpIpImp : public SnmpTransportIpAddress , 
					 public SnmpUdpIpTransport 
{
public:

	SnmpUdpIpImp(IN SnmpSession &session,
				 IN const char *address,
				 IN const ULONG addressResolution = SNMP_ADDRESS_RESOLVE_VALUE )
				 : SnmpTransportIpAddress(address,addressResolution),
				   SnmpUdpIpTransport(session, *this)
	{}

	SnmpUdpIpImp(IN SnmpSession &session,
				 IN const UCHAR *address)
				 : SnmpTransportIpAddress(address, SNMP_IP_ADDR_LEN),
				   SnmpUdpIpTransport(session, *this)
	{}
	
	SnmpUdpIpImp(IN SnmpSession &session,
				 IN const SnmpTransportIpAddress &address)
				 : SnmpTransportIpAddress(address),				   
				   SnmpUdpIpTransport(session, *this)
	{}

	void * operator()(void) const;
	
	~SnmpUdpIpImp() {}
} ;

class DllImportExport SnmpIpxTransport: public SnmpImpTransport
{
private:
protected:
public:

	SnmpIpxTransport(IN SnmpSession &session,
					   IN const SnmpTransportIpxAddress &ipxAddress);
};

class DllImportExport SnmpIpxImp : public SnmpTransportIpxAddress , 
					 public SnmpIpxTransport 
{
public:

	SnmpIpxImp(IN SnmpSession &session,
				 IN const char *address
				 )
				 : SnmpTransportIpxAddress(address),
				   SnmpIpxTransport(session, *this)
	{}

	SnmpIpxImp(IN SnmpSession &session,
				 IN const UCHAR *address)
				 : SnmpTransportIpxAddress(address, SNMP_IPX_ADDR_LEN),
				   SnmpIpxTransport(session, *this)
	{}
	
	SnmpIpxImp(IN SnmpSession &session,
				 IN const SnmpTransportIpxAddress &address)
				 : SnmpTransportIpxAddress(address),				   
				   SnmpIpxTransport(session, *this)
	{}

	void * operator()(void) const;
	
	~SnmpIpxImp() {}
} ;

#pragma warning (default:4355)

#endif // __TRANSPORT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\trap.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __TRAP_MANAGEMENT__
#define __TRAP_MANAGEMENT__

//#include <snmpevt.h>
//#include <snmpthrd.h>

class SnmpClTrapThreadObject;

class DllImportExport SnmpTrapReceiver
{
friend SnmpWinSnmpTrapSession;	//needs access to m_cRef.
private:
	
	BOOL			m_bregistered;
	LONG			m_cRef;

protected:
	
					SnmpTrapReceiver ();

public:

	virtual void	Receive(SnmpTransportAddress &sender_addr,
								SnmpSecurity &security_context,
								SnmpVarBindList &vbList) = 0;

	BOOL			IsRegistered() { return m_bregistered; }

	BOOL			DestroyReceiver();

					~SnmpTrapReceiver ();

};


class SnmpTrapReceiverStore
{
private:

	CRITICAL_SECTION	m_Lock;
	void*				m_HandledRxStack;
	void*				m_UnHandledRxStack;

	void			Lock();
	void			Unlock();

public:

			SnmpTrapReceiverStore();

	BOOL				Add(SnmpTrapReceiver* receiver);
	BOOL				Delete(SnmpTrapReceiver* receiver);
	BOOL				IsEmpty();
	SnmpTrapReceiver*	GetNext();


			~SnmpTrapReceiverStore();
};


class SnmpTrapManager
{
friend SnmpWinSnmpTrapSession;	//needs access to m_receivers.

private:

	BOOL					m_bListening;
	SnmpWinSnmpTrapSession*	m_trapSession;
	SnmpTrapReceiverStore	m_receivers;
	SnmpClTrapThreadObject*		m_trapThread;


public:
		SnmpTrapManager ();

	BOOL	RegisterReceiver (SnmpTrapReceiver *trapRx);
	BOOL	UnRegisterReceiver (SnmpTrapReceiver *trapRx);
	BOOL	IsListening() const { return m_bListening; }

		~SnmpTrapManager ();

	static SnmpTrapManager *s_TrapMngrPtr;
};



#endif //__TRAP_MANAGEMENT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\trapsess.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __TRAP_SESSION__
#define __TRAP_SESSION__


#define TRAP_EVENT		(WM_USER+1)

class SnmpWinSnmpTrapSession : private Window
{

private:

	SnmpTrapManager*	m_managerPtr;
	BOOL				m_bValid;
	HSNMP_SESSION		m_session_handle;
	BOOL				m_bDestroy;
	LONG				m_cRef;
	
	BOOL	RegisterForAllTraps ();


public:

		SnmpWinSnmpTrapSession (SnmpTrapManager* managerPtr);
	
	BOOL	PostMessage (UINT user_msg_id, WPARAM wParam, LPARAM lParam);
	LONG_PTR	HandleEvent (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	HWND	GetWindowHandle() { return Window::GetWindowHandle(); }
	void*	operator()() const { return ( m_bValid ? (void*)this : NULL ); }
	BOOL	DestroySession();

		~SnmpWinSnmpTrapSession ();
};

class SnmpTrapTaskObject : public SnmpTaskObject
{
private:

	SnmpTrapManager*		m_mptr;
	SnmpWinSnmpTrapSession** m_pptrapsess;

public:

	SnmpTrapTaskObject (SnmpTrapManager* managerPtr, SnmpWinSnmpTrapSession** pptrapsess);
	~SnmpTrapTaskObject () {}

	void Process ();
};


#endif //__TRAP_SESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\tsent.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: tsent.hpp
Author: B.Rajeev
Purpose: Provides declarations for the TransportSentStateStore class
--------------------------------------------------*/

#ifndef __TRANSPORT_SENT_STATE_STORE
#define __TRANSPORT_SENT_STATE_STORE

#include "common.h"
#include "forward.h"

/*---------------------------------------------------------------
Overview: The SnmpUdpIpTransport must call the SnmpSession instance
back with the status of each transmission attempt. Therefore, 
the transport instance registers an error report 
(Snmp_Success, Snmp_No_Error) for the transport_frame_id and posts 
a SENT_FRAME_EVENT before transmission. This is done in order to 
ensure that the sent frame window message is queued before a reply 
(and consequently a window message) is received. in case of an 
error in transmission, the error report is modified to reflect the 
nature of the error. When the SENT_FRAME_EVENT is processed, the 
SnmpSession instance is called back with the error report for the 
transport_frame_id. 

The TransportSentStateStore stores the above mentioned error reports.
-------------------------------------------------------------*/
  
class TransportSentStateStore
{
	typedef CMap<TransportFrameId, TransportFrameId, SnmpErrorReport *, SnmpErrorReport *> Store;

	Store store;

public:

		void Register(IN TransportFrameId id, 
					  IN const SnmpErrorReport &error_report);

		void Modify(IN TransportFrameId id,
					IN const SnmpErrorReport &error_report);

		SnmpErrorReport Remove(IN TransportFrameId id);

		~TransportSentStateStore(void);
};


#endif // __TRANSPORT_SENT_STATE_STORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\tsess.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------
Filename: tsess.hpp
Author: B.Rajeev
Purpose: Provides declarations for the TransportSession class
--------------------------------------------------*/

#ifndef __TRANSPORT_SESSION__
#define __TRANSPORT_SESSION__

#include "wsess.h"

class WinSnmpVariables
{
public:

	HSNMP_ENTITY m_SrcEntity ;
	HSNMP_ENTITY m_DstEntity ;
	HSNMP_CONTEXT m_Context ;
	HSNMP_PDU m_Pdu;
	HSNMP_VBL m_Vbl;
	ULONG m_RequestId ;
} ;

/*---------------------------------------------------------------
Overview: The TransportSession class provides an abstraction for a 
WinSNMP session and a window message queue (both are available through
the WinSnmpSession class). The SnmpUdpIpTransport class uses it 
for services such as sending a PDU, posting window messages for 
internal events and receiving a reply and notifying the 
SnmpUdpIpTransport instance ("owner") of the receipt as well 
as internal events.
-------------------------------------------------------------*/

class TransportWindow : public Window
{
	SnmpImpTransport &owner;
	HSNMP_SESSION m_Session ;

	// over-rides the HandleEvent method provided by the
	// WinSnmpSession. Receives the Pdu and passes it to
	// the owner (SnmpTransport)

	LONG_PTR HandleEvent (

		HWND hWnd ,
		UINT message ,
		WPARAM wParam ,
		LPARAM lParam
	);

	BOOL ReceivePdu ( SnmpPdu &a_Pdu ) ;

public:

	TransportWindow (

		SnmpImpTransport &owner
	);

	~TransportWindow () ;

	BOOL SendPdu ( SnmpPdu &a_Pdu ) ;

};

#endif // __TRANSPORT_SESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\vbl.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*-------------------------------------------------
filename: vbl.hpp
author: B.Rajeev
purpose: To provide declarations for the VBList class.
		 It encapsulates an association between a
		 VarBindList and a winSNMP VBL.
------------------------------------------------*/


#ifndef __VBL__
#define __VBL__

#include "forward.h"
#include "encap.h"
#include "common.h"
#include "encdec.h"
#include "vblist.h"

#define WinSNMPSession HSNMP_SESSION

// Given a var_bind_list creates a WinSnmpVbl. It supports deletion 
// of variable bindings by their index. This deletes the 
// binding from both var_bind_list and the WinSnmpVbl. 
// It also allows direct access to the var_bind_list and the WinSnmpVbl
// for convenience

class VBList
{
	ULONG m_Index ;
	SnmpVarBindList *var_bind_list;

public:

	VBList (

		IN SnmpEncodeDecode &a_SnmpEncodeDecode , 
		IN SnmpVarBindList &var_bind_list,
		IN ULONG index 
	);

	~VBList(void);

	// the two Get functions provide direct access to the
	// VarBindList and the WinSnmpVbl
	SnmpVarBindList &GetVarBindList(void) { return *var_bind_list; }

	ULONG GetIndex () { return m_Index ; }

	// deletes the specified variable binding from both the
	// var_bind_list and the WinSnmpVbl. returns a copy of the
	// deleted VarBind
	SnmpVarBind *Remove(IN UINT vbl_index);

	// gets the specified variable binding from both the
	// var_bind_list and the WinSnmpVbl. returns a copy of the
	// deleted VarBind
	SnmpVarBind *Get (IN UINT vbl_index);

	// deletes the specified variable binding from both the
	// var_bind_list and the WinSnmpVbl. 
	void Delete (IN UINT vbl_index);

};

#endif // __VBL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\vblist.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: vblist.hpp
Written By:	B.Rajeev
Purpose	: To provide declarations of classes for
		  manipulating variable bindings 
		  (object identifier, SNMP value).
----------------------------------------------------------*/

#ifndef __VBLIST__
#define __VBLIST__

#define ILLEGAL_INDEX -1

#include <provexpt.h>

#include "value.h"

// encapsulates a variable binding, that is, a pair
// consisting of an SnmpObjectIdentifier and a corresponding
// SnmpValue

class DllImportExport SnmpVarBind
{
private:

	SnmpObjectIdentifier *identifier;
	SnmpValue *val;

protected:

	virtual void Replicate(IN const SnmpObjectIdentifier &instance,
			 			   IN const SnmpValue &value)
	{
		identifier = (SnmpObjectIdentifier *)instance.Copy();
		val = value.Copy();
	}

public:

	SnmpVarBind(IN const SnmpObjectIdentifier &instance,
			IN const SnmpValue &value) :
			identifier ( NULL ),
			val ( NULL )
	{
		Replicate(instance, value);
	}

	SnmpVarBind(IN const SnmpVarBind &varbind) :
			identifier ( NULL ),
			val ( NULL )
	{
		Replicate(varbind.GetInstance(), varbind.GetValue());
	}

	virtual ~SnmpVarBind()
	{
		delete identifier;
		delete val;
	}

	SnmpObjectIdentifier &GetInstance() const
	{
		return *identifier;
	}

	SnmpValue &GetValue() const
	{
		return *val;
	}

	SnmpVarBind &operator=(IN const SnmpVarBind &var_bind)
	{
		(*identifier) = var_bind.GetInstance();

		delete val;
		val = var_bind.GetValue().Copy();

		return *this;
	}

};


// represents a node in the SnmpVarBindList and stores a varbind

class DllImportExport  SnmpVarBindListNode
{
private:

	SnmpVarBind *varbind;

protected:

	SnmpVarBindListNode *previous;
	SnmpVarBindListNode *next;

public:

	SnmpVarBindListNode(const SnmpVarBind *varbind);

	SnmpVarBindListNode(const SnmpVarBind &varbind);

	SnmpVarBindListNode(SnmpVarBind &varbind);

	~SnmpVarBindListNode()
	{
		// free the varbind if it isn't NULL
		if ( varbind != NULL )
			delete varbind;
	}

	void SetPrevious(SnmpVarBindListNode *new_previous)
	{
		previous = new_previous;
	}

	void SetNext(SnmpVarBindListNode *new_next)
	{
		next = new_next;
	}

	SnmpVarBindListNode *GetPrevious()
	{
		return previous;
	}

	SnmpVarBindListNode *GetNext()
	{
		return next;
	}	

	SnmpVarBind *GetVarBind()
	{
		return varbind;
	}

};


// a circular list of SnmpVarBindListNodes, each storing an 
// SnmpVarBind. it has a dummy head

class DllImportExport SnmpVarBindList
{
	typedef ULONG PositionHandle;

	struct PositionInfo
	{
	public:

		SnmpVarBindListNode *current_node;
		int current_index;

		PositionInfo(SnmpVarBindListNode *current_node,
						int current_index)
		{
			PositionInfo::current_node = current_node;
			PositionInfo::current_index = current_index;
		}
	};	
	
	class ListPosition
	{	
		PositionHandle position_handle;
		SnmpVarBindList *vblist;

	public:

		ListPosition(PositionHandle position_handle,
					SnmpVarBindList *vblist)
		{
			ListPosition::position_handle = position_handle;
			ListPosition::vblist = vblist;
		}

		PositionHandle GetPosition() { return position_handle;}

		SnmpVarBindList *GetList() { return vblist;}

		~ListPosition();

	};

	friend class ListPosition;

	class LookupTable : public CMap<PositionHandle, PositionHandle, PositionInfo * , PositionInfo * >
	{
	};

protected:

	UINT length;
	SnmpVarBindListNode head;
	SnmpVarBindListNode *current_node;
	int current_index;

	PositionHandle next_position_handle;
	LookupTable lookup_table;

	void EmptyLookupTable(void);

	// to set the current_node to the specified distance
	// from the specified node
	void GoForward(SnmpVarBindListNode *current, UINT distance);

	void GoBackward(SnmpVarBindListNode *current, UINT distance);

	// if able to point the current_node at the specified
	// index, returns TRUE, else FALSE
	BOOL GotoIndex(UINT index);

	// inserts the new_node just before the specified node
    void Insert(SnmpVarBindListNode *current, SnmpVarBindListNode *new_node);

    // if 'current' does not point to the head of the list, it
    // deletes the node pointed at by current. Otherwise error
    void Release(SnmpVarBindListNode *current);

	ListPosition *GetPosition();

	void GotoPosition(ListPosition *list_position);

	void DestroyPosition(ListPosition *list_position);

	void Initialize(IN SnmpVarBindList &varBindList);

	void FreeList();
	                
public:

	SnmpVarBindList();

	SnmpVarBindList(IN SnmpVarBindList &varBindList);

	~SnmpVarBindList();

	SnmpVarBindList *CopySegment(IN const UINT segment_size);

	UINT GetLength(void) const { return length; }

	BOOL Empty(void) const { return ( (length==0)?TRUE:FALSE ); }

	int GetCurrentIndex(void) const { return current_index; }

	void Add(IN const SnmpVarBind &varBind)
	{
		Insert(&head,
			   new SnmpVarBindListNode(varBind));
		length++;
	}

	void AddNoReallocate (IN SnmpVarBind &varBind)
	{
		Insert(&head,
			   new SnmpVarBindListNode(varBind));
		length++;
	}

	void Remove();

	SnmpVarBind *operator[](IN const UINT index)
	{
		if ( GotoIndex(index) )
			return current_node->GetVarBind();
		else
			return NULL;
	}

	const SnmpVarBind *Get() const
	{
		return current_node->GetVarBind();
	}

	void Reset()
	{
		current_node = &head;

		current_index = ILLEGAL_INDEX;
	}

	BOOL Next();

	SnmpVarBindList &operator=(IN SnmpVarBindList &vblist);

	SnmpVarBindList *Car ( const UINT index ) ;

	SnmpVarBindList *Cdr ( const UINT index ) ;
};

#endif // __VBLIST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\window.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*--------------------------------------------------------
filename: window.hpp"
author: B.Rajeev
purpose: Provides declarations for the Window class.
--------------------------------------------------------*/

#ifndef __WINDOW__
#define __WINDOW__

#include "forward.h"
#include "common.h"
#include "sync.h"

// these are events shared by all winsnmp session derivatives
#define NULL_EVENT_ID			(WM_USER+1)
#define MESSAGE_ARRIVAL_EVENT	(WM_USER+2)
#define SENT_FRAME_EVENT		(WM_USER+3)
#define SEND_ERROR_EVENT		(WM_USER+4)
#define OPERATION_COMPLETED_EVENT (WM_USER+5)
#define DELETE_SESSION_EVENT	(WM_USER+6)
#define SNMP_WM_TIMER			(WM_USER+7)

#define DUMMY_TITLE "Dummy Window"

typedef CMap< HWND, HWND &, Window *, Window *& > WindowMapping;

// It creates a window and, when asked to, displays it if successful.
// Lets users check for success and obtain a handle to the window 

class Window
{
	BOOL is_valid;
	HWND window_handle;

    // serializes access to the WindowMapping
    static CriticalSection window_CriticalSection;

    // map to associate an HWND with an EventHandler.
	// this is shared by all EventHandlers
	static WindowMapping mapping;

	void Initialize (

		char *templateCode,
		WNDPROC EventHandler,
		BOOL display
	);

	static BOOL CreateCriticalSection () ;

	static void DestroyCriticalSection () ;

public:

	Window ( 

		char *templateCode = DUMMY_TITLE, 
		BOOL display = FALSE 
	) ;

	virtual ~Window(void);

	HWND GetWindowHandle(void) { return window_handle; }

	// it determines the corresponding EventHandler and calls it
	// with the appropriate parameters
	static LONG_PTR CALLBACK HandleGlobalEvent (

		HWND hWnd ,
		UINT message ,
		WPARAM wParam ,
		LPARAM lParam
	);

    static BOOL InitializeStaticComponents () ; 

	static void DestroyStaticComponents () ;

	// calls the default handler
	// a deriving class may override this, but
	// must call this method explicitly for default
	// case handling
	virtual LONG_PTR HandleEvent (

		HWND hWnd ,
		UINT message ,
		WPARAM wParam ,
		LPARAM lParam
	);

	BOOL PostMessage (

		UINT user_msg_id,
		WPARAM wParam, 
		LPARAM lParam
	);

	// lets users check if the window was successfully created
	virtual void * operator()(void) const
	{
		return ( (is_valid)?(void *)this:NULL );
	}

	static UINT g_SendErrorEvent ;
	static UINT g_OperationCompletedEvent ;
	static UINT g_TimerMessage ;
	static UINT g_DeleteSessionEvent ;
	static UINT g_MessageArrivalEvent ;
	static UINT g_SentFrameEvent ;
	static UINT g_NullEventId ;
};

#endif // __WINDOW__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\winforw.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef __WIN_SNMP_FORWARD__
#define __WIN_SNMP_FORWARD__


typedef WinSnmpInteger;
typedef WinSnmpInteger32;
typedef WinSnmpPdu;
typedef WinSnmpVbl;
typedef WinSnmpOctetArray;


#endif __WIN_SNMP_FORWARD__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\wstore.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

/*---------------------------------------------------------
Filename: wstore.hpp
Written By:	B.Rajeev
Purpose	: To provide declarations of the MsgIdStore class 
----------------------------------------------------------*/

#ifndef __MSG_ID_STORE__
#define __MSG_ID_STORE__

#include "forward.h"
#include "msgid.h"
													
#endif // __MSG_ID_STORE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\wsess.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*---------------------------------------------------------
Filename: wsess.hpp
Written By:	B.Rajeev
Purpose	: To provide declarations of the WinSnmpSession class 
----------------------------------------------------------*/

#ifndef __WINSNMPSESSION__
#define __WINSNMPSESSION__

#include "common.h"
#include "window.h"

#endif // __WINSNMPSESSION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\sclcomm\include\value.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
/*-----------------------------------------------------------------
Filename: value.hpp
Purpose	: To specify the classes of various Snmp values and instance
		  identifiers. These classes represent the different types of 
		  values for variables that may populate a MIB. 
Written By:	B.Rajeev
-----------------------------------------------------------------*/


#ifndef __VALUE__
#define __VALUE__

/*-----------------------------------------------------------------
General Overview:
	A variable instance refers to a MIB object, e.g. 
	1.3.6.1.2.1.1.1.0 or 1.3.6.1.2.1.2.1.2.1. The instance is 
	encoded as an SNMP object identifier and is represented by the 
	class SnmpObjectIdentifier. 

  The classes derived from SnmpValue represent the encoding of the 
  information stored within the MIB object. The value is encoded 
  as an implementation of the abstract class SnmpValue. The SNMP 
  class library implements the following derivations of SnmpValue 
  which refer to SNMP BER encoded types.

		SnmpNull
		SnmpInteger
		SnmpCounter32
		SnmpCounter64
		SnmpGauge
		SnmpTimeTicks
		SnmpIPAddress
		SnmpNetworkAddress
		SnmpBitString
		SnmpOctetString
		SnmpOpaque
		SnmpObjectIdentifier

  All the implemented classes provide (in addition to others) -
  1. Constructors to initialize using relevant values or another
	instance of the same class.

  2. GetValue, SetValue methods for obtaining and setting
	relevant values.

  3. "=" operator to over-ride the default assignment operator and
	 an Equivalent method to check for equivalence between two instances
	 of the same (derived) class

  4. Copy methods for obtaining a copy of a specified instance of
	the class.


  note of caution:
  ----------------
		Some of the GetValue functions return pointers
  to dynamically allocated data. Users of the class must make copies
  of the returned values and must not rely on the integrity of this
  pointer or values obtained through it in future (because of 
  SetValue methods, or destruction of corresponding SnmpValue class) 
-----------------------------------------------------------------*/

#include <provexpt.h>


// Abstract class at the root of all Snmp Values


class DllImportExport SnmpValue 
{
	// the "=" operator and the copy constructor have been
	// made private to prevent copies of the SnmpValue instance
	// from being made
	SnmpValue &operator=(IN const SnmpValue &) 
	{
		return *this;
	}

	SnmpValue(IN const SnmpValue &snmp_value) {}

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const = 0;
	SnmpValue() {}

public:

	virtual SnmpValue *Copy () const = 0 ;

	BOOL operator==(IN const SnmpValue &value) const
	{
		return Equivalent(value) ;
	}

	BOOL operator!=(IN const SnmpValue &value) const
	{
		return !((*this) == value) ;
	}

	virtual ~SnmpValue() {}
} ;


// Enables null values for required variables. Its a concrete class
// with dummy constructor and destructors to enable specification of
// null values
class DllImportExport SnmpNull : public SnmpValue
{
protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	// dummy constructor and destructor
	SnmpNull() {}

	~SnmpNull() {}

	SnmpValue &operator=(IN const SnmpNull &to_copy) 
	{
		return *this;
	}

	SnmpValue *Copy() const { return new SnmpNull; }
};


// Allows integer values to be specified
class DllImportExport SnmpInteger : public SnmpValue 
{
private:

	LONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpInteger ( IN const LONG value ) : val(value) {}
	SnmpInteger ( IN const SnmpInteger &value );

	~SnmpInteger () {}

	LONG GetValue () const;

	void SetValue ( IN const LONG value );

	SnmpValue &operator=(IN const SnmpInteger &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpInteger &snmp_integer)	const
	{
		if ( val == snmp_integer.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

	SnmpValue *Copy () const;
} ;

// Encapsulates gauge value
class DllImportExport SnmpGauge : public SnmpValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpGauge ( IN const LONG value ) : val(value) {}
	SnmpGauge ( IN const SnmpGauge &value );
	~SnmpGauge () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpGauge &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpGauge &snmp_gauge)	const
	{
		if ( val == snmp_gauge.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates Counter values
class DllImportExport SnmpCounter : public SnmpValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpCounter ( IN const ULONG value ) : val(value) {}
	SnmpCounter ( IN const SnmpCounter &value );

	~SnmpCounter () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpCounter &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpCounter &snmp_counter)	const
	{
		if ( val == snmp_counter.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates Time Ticks (since an earlier event)
class DllImportExport SnmpTimeTicks : public SnmpValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpTimeTicks ( IN const ULONG value ) : val(value) {}
	SnmpTimeTicks ( IN const SnmpTimeTicks &value );

	~SnmpTimeTicks () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpTimeTicks &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpTimeTicks &snmp_time_ticks) const
	{
		if ( val == snmp_time_ticks.GetValue() )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates octet strings that do not have any terminator.
// The octet string is specified by the pair (val,length) where
// 'val' is a pointer to heap data and 'length' provides the number
// of octets in the data string.
class DllImportExport SnmpOctetString : public SnmpValue
{
private:

	// in case a new 'value' string has the same length as the stored
	// string, the stored string may be overwritten. this avoids
	// having to allocate and deallocate heap memory for the purpose.
	void OverWrite(IN const UCHAR *value);

protected:

	BOOL is_valid;
	UCHAR *val;
	ULONG length;

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;
	virtual void Initialize(IN const UCHAR *value, IN const ULONG valueLength);

	
	// The Replicate and UnReplicate methods allocate and deallocate
	// heap data. Replicate also copies the contents of the parameter
	// 'value' onto the allocated memory. This function may be 
	// implemented different and, thus, the methods have been declared
	// virtual.
	virtual UCHAR *Replicate(IN const UCHAR *value, IN const ULONG valueLength);

	virtual void UnReplicate(UCHAR *value);

public:

	SnmpOctetString ( IN const UCHAR *value , IN const ULONG valueLength );

	SnmpOctetString ( IN const SnmpOctetString &value );

	~SnmpOctetString ();

	void SetValue ( IN const UCHAR *value , IN const ULONG valueLength );

	ULONG GetValueLength () const;
	UCHAR *GetValue () const;

	SnmpValue *Copy () const;


	SnmpValue &operator=(IN const SnmpOctetString &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	BOOL Equivalent(IN const SnmpOctetString &snmp_octet_string) const;
} ;

// OpaqueValue class encapsulates octet strings
class DllImportExport SnmpOpaque : public SnmpValue
{
private:
	SnmpOctetString *octet_string;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpOpaque ( IN const UCHAR *value , IN const ULONG valueLength ) : octet_string ( NULL )
	{
		octet_string = new SnmpOctetString(value, valueLength);
	}

	SnmpOpaque ( IN const SnmpOpaque &value ) : octet_string ( NULL )
	{
		octet_string = new SnmpOctetString(value.GetValue(), value.GetValueLength());
	}
	
	~SnmpOpaque()
	{
		delete octet_string;
	}

	void SetValue ( IN const UCHAR *value , IN const ULONG valueLength )
	{
		octet_string->SetValue(value, valueLength);
	}

	ULONG GetValueLength () const
	{
		return octet_string->GetValueLength();
	}

	UCHAR *GetValue () const
	{
		return octet_string->GetValue();
	}


	SnmpValue &operator=(IN const SnmpOpaque &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	SnmpValue *Copy () const
	{
		return new SnmpOpaque(octet_string->GetValue(),
							  octet_string->GetValueLength());
	}

	void * operator()(void) const
	{
		return (*octet_string)();
	}


	BOOL Equivalent(IN const SnmpOpaque &snmp_opaque) const
	{
		return octet_string->Equivalent(*(snmp_opaque.octet_string));
	}
};

#define DEFAULT_OBJECTIDENTIFIER_LENGTH 32

// Encapsulates the object identifier. An object identifier 
// identifies a MIB object instance
class DllImportExport SnmpObjectIdentifier : public SnmpValue
{
	
	// describes the legal values for a comparison
	enum Comparison {LESS_THAN, EQUAL_TO, GREATER_THAN};

private:

	BOOL is_valid;
	ULONG m_value[DEFAULT_OBJECTIDENTIFIER_LENGTH];
	ULONG *val;
	ULONG length;

	// in case a new 'value' string has the same length as the stored
	// string, the stored string may be overwritten. this avoids
	// having to allocate and deallocate heap memory for the purpose.
	void OverWrite(IN const ULONG *value);

protected:
	
	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;
	virtual void Initialize(IN const ULONG *value, IN const ULONG valueLength);

	
	// The Replicate and UnReplicate methods allocate and deallocate
	// heap data. Replicate also copies the contents of the parameter
	// 'value' onto the allocated memory. This function may be 
	// implemented different and, thus, the methods have been declared
	// virtual.
	virtual ULONG *Replicate(IN const ULONG *value, IN const ULONG valueLength) const;

	// Allocates enough memory to copy the first value followed by
	// the second value to be copied, thus, appending the two values
	virtual ULONG *Replicate(IN const ULONG *first_value, IN const ULONG first_length,
							 IN const ULONG *second_value, IN const ULONG second_length) const;

	virtual void UnReplicate(ULONG *value);

	// This single function
	Comparison Compare(IN const SnmpObjectIdentifier &first, 
					   IN const SnmpObjectIdentifier &second) const;

	BOOL Equivalent(IN const SnmpObjectIdentifier &value) const;

public:

	SnmpObjectIdentifier ( IN const ULONG *value , IN const ULONG valueLength );

	SnmpObjectIdentifier ( IN const char *value );

	SnmpObjectIdentifier ( IN const SnmpObjectIdentifier &value );

	~SnmpObjectIdentifier ();

	void SetValue ( IN const ULONG *value , IN const ULONG valueLength );

	ULONG GetValueLength () const;
	ULONG *GetValue () const;

	SnmpValue *Copy () const;

	BOOL Equivalent(IN const SnmpObjectIdentifier &value,
					 IN ULONG max_length) const;
	
	BOOL operator<(IN const SnmpObjectIdentifier &value)	const
	{
		return (Compare(*this,value) == LESS_THAN)?TRUE:FALSE;

	}

	BOOL operator>(IN const SnmpObjectIdentifier &value)	const
	{
		return (Compare(*this,value) == GREATER_THAN)?TRUE:FALSE;
	}

	BOOL operator<=(IN const SnmpObjectIdentifier &value) const
	{
		return !(*this > value);
	}

	BOOL operator>=(IN const SnmpObjectIdentifier &value) const
	{
		return !(*this < value);
	}

	BOOL operator==(IN const SnmpObjectIdentifier &value) const
	{
		if ( this->GetValueLength() == value.GetValueLength() )
			return Equivalent(value) ;
		else
			return FALSE;
	}

	BOOL operator!=(IN const SnmpObjectIdentifier &value) const
	{
		return !(*this == value);
	}
	
	SnmpObjectIdentifier operator+ ( IN const SnmpObjectIdentifier &value ) const;

	BOOL Prefix( IN ULONG index, SnmpObjectIdentifier &prefix ) const
	{
		if ( index >= length )
			return FALSE;
		
		prefix.UnReplicate (val) ;
		prefix.Initialize (val, index+1) ;
		return TRUE ;
	}

	BOOL Suffix ( IN ULONG index , SnmpObjectIdentifier &suffix ) const
	{
		if ( index >= length )
			return FALSE;

		suffix.UnReplicate (val) ;
		suffix.Initialize ( val+index, length-index ) ;
		return TRUE ;
	}

	SnmpObjectIdentifier *Cut (SnmpObjectIdentifier &value) const;


	ULONG &operator [] ( IN const ULONG index ) const;


	SnmpValue &operator=(IN const SnmpObjectIdentifier &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue(), to_copy.GetValueLength());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	char *GetAllocatedString() const;
} ;


// encapsulates an ip address. represents the 32 bit value in a ULONG
class DllImportExport SnmpIpAddress : public SnmpValue 
{
private:

	// if the dotted decimal representation passed to the constructor
	// is ill-formed, the instance may be invalid
	BOOL is_valid;
	ULONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpIpAddress ( IN const ULONG value )
		:val(value), is_valid(TRUE)
	{}

	// a dotted decimal representation is parsed to obtain the 32 bit value
	SnmpIpAddress ( IN const char *value ) ;

	SnmpIpAddress ( IN const SnmpIpAddress &value );

	~SnmpIpAddress () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpIpAddress &to_copy) 
	{
		if ( to_copy() )
			SetValue(to_copy.GetValue());

		return *this;
	}

	void * operator()(void) const
	{
		return ( is_valid?(void *)this:NULL );
	}

	BOOL Equivalent(IN const SnmpIpAddress &snmp_ip_address) const
	{
		if ( is_valid && snmp_ip_address() )
			return ( val == snmp_ip_address.GetValue() );
		else
			return FALSE;
	}

} ;

// Encapsulates UInteger32 value
class DllImportExport SnmpUInteger32 : public SnmpValue 
{
private:

	ULONG val;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpUInteger32 ( IN const LONG value ) : val(value) {}
	SnmpUInteger32 ( IN const SnmpUInteger32 &value );
	~SnmpUInteger32 () {}

	ULONG GetValue () const;

	void SetValue ( IN const ULONG value );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpUInteger32 &to_copy) 
	{
		SetValue(to_copy.GetValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpUInteger32 &snmp_integer)	const
	{
		if ( val == snmp_integer.GetValue() )
			return TRUE;
		else
			return FALSE;
	}
} ;


// Encapsulates Counter64 values
class DllImportExport SnmpCounter64 : public SnmpValue 
{
private:

	ULONG lval;
	ULONG hval;

protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpCounter64 ( IN const ULONG lvalue , IN const ULONG hvalue ) : lval(lvalue),hval(hvalue) {}
	SnmpCounter64 ( IN const SnmpCounter64 &value );

	~SnmpCounter64 () {}

	ULONG GetLowValue () const;
	ULONG GetHighValue () const;

	void SetValue ( IN const ULONG lvalue , IN const ULONG hvalue );

	SnmpValue *Copy () const;

	SnmpValue &operator=(IN const SnmpCounter64 &to_copy) 
	{
		SetValue(to_copy.GetLowValue(),to_copy.GetHighValue());
		return *this;
	}

	BOOL Equivalent(IN const SnmpCounter64 &snmp_counter )	const
	{
		if ( ( lval == snmp_counter.GetLowValue() ) && ( hval == snmp_counter.GetHighValue() ) )
			return TRUE;
		else
			return FALSE;
	}

} ;

// Encapsulates EndOfMibView values
class DllImportExport SnmpEndOfMibView : public SnmpValue 
{
private:
protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpEndOfMibView () {} ;
	~SnmpEndOfMibView () {} ;

	SnmpValue *Copy () const { return new SnmpEndOfMibView ; }

	SnmpValue &operator=(IN const SnmpEndOfMibView &to_copy) 
	{
		return *this;
	}

} ;

// Encapsulates NoSuchObject values
class DllImportExport SnmpNoSuchObject: public SnmpValue 
{
private:
protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpNoSuchObject () {} ;
	~SnmpNoSuchObject () {} ;

	SnmpValue *Copy () const { return new SnmpNoSuchObject ; }

	SnmpValue &operator=(IN const SnmpNoSuchObject &to_copy) 
	{
		return *this;
	}

} ;

// Encapsulates NoSuchInstance values
class DllImportExport SnmpNoSuchInstance: public SnmpValue 
{
private:
protected:

	virtual BOOL Equivalent(IN const SnmpValue &value)	const ;

public:

	SnmpNoSuchInstance () {} ;
	~SnmpNoSuchInstance () {} ;

	SnmpValue *Copy () const { return new SnmpNoSuchInstance ; }

	SnmpValue &operator=(IN const SnmpNoSuchInstance &to_copy) 
	{
		return *this;
	}
} ;


#endif // __VALUE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\list_o.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized List
//
/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <snmpcoll.h>

/////////////////////////////////////////////////////////////////////////////

CObList::CObList(int nBlockSize)
{
    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

void CObList::RemoveAll()
{
    // destroy elements

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

CObList::~CObList()
{
    RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
/*
 * Implementation note: CNode's are stored in CPlex blocks and
 *  chained together. Free blocks are maintained in a singly linked list
 *  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
 *  Used blocks are maintained in a doubly linked list using both 'pNext'
 *  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
 *   as the head/tail.
 *
 * We never free a CPlex block unless the List is destroyed or RemoveAll()
 *  is used - so the total number of CPlex blocks may grow large depending
 *  on the maximum past size of the list.
 */

CObList::CNode*
CObList::NewNode(CObList::CNode* pPrev, CObList::CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }

    CObList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;

    pNode->data = 0; // start with zero

    return pNode;
}

void CObList::FreeNode(CObList::CNode* pNode)
{
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;

    // if no more elements, cleanup completely
    if (m_nCount == 0)
        RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////

POSITION CObList::AddHead(CObject* newElement)
{
    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (POSITION) pNewNode;
}

POSITION CObList::AddTail(CObject* newElement)
{
    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (POSITION) pNewNode;
}

void CObList::AddHead(CObList* pNewList)
{
    // add a list of same elements to head (maintain order)
    POSITION pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

void CObList::AddTail(CObList* pNewList)
{
    // add a list of same elements
    POSITION pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

CObject* CObList::RemoveHead()
{
    CNode* pOldNode = m_pNodeHead;
    CObject* returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

CObject* CObList::RemoveTail()
{
    CNode* pOldNode = m_pNodeTail;
    CObject* returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

POSITION CObList::InsertBefore(POSITION position, CObject* newElement)
{
    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (POSITION) pNewNode;
}

POSITION CObList::InsertAfter(POSITION position, CObject* newElement)
{
    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (POSITION) pNewNode;
}

void CObList::RemoveAt(POSITION position)
{
    CNode* pOldNode = (CNode*) position;

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}


/////////////////////////////////////////////////////////////////////////////
// slow operations

POSITION CObList::FindIndex(int nIndex) const
{
    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        pNode = pNode->pNext;
    }
    return (POSITION) pNode;
}

POSITION CObList::Find(CObject* searchValue, POSITION startAfter) const
{
    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (pNode->data == searchValue)
            return (POSITION) pNode;
    return NULL;
}


int CObList::GetCount() const
    { return m_nCount; }
BOOL CObList::IsEmpty() const
    { return m_nCount == 0; }
CObject*& CObList::GetHead()
    { return m_pNodeHead->data; }
CObject* CObList::GetHead() const
    { return m_pNodeHead->data; }
CObject*& CObList::GetTail()
    { return m_pNodeTail->data; }
CObject* CObList::GetTail() const
    { return m_pNodeTail->data; }
POSITION CObList::GetHeadPosition() const
    { return (POSITION) m_pNodeHead; }
POSITION CObList::GetTailPosition() const
    { return (POSITION) m_pNodeTail; }
CObject*& CObList::GetNext(POSITION& rPosition) // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
CObject* CObList::GetNext(POSITION& rPosition) const // return *Position++
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pNext;
        return pNode->data; }
CObject*& CObList::GetPrev(POSITION& rPosition) // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
CObject* CObList::GetPrev(POSITION& rPosition) const // return *Position--
    { CNode* pNode = (CNode*) rPosition;
        rPosition = (POSITION) pNode->pPrev;
        return pNode->data; }
CObject*& CObList::GetAt(POSITION position)
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
CObject* CObList::GetAt(POSITION position) const
    { CNode* pNode = (CNode*) position;
        return pNode->data; }
void CObList::SetAt(POSITION pos, CObject* newElement)
    { CNode* pNode = (CNode*) pos;
        pNode->data = newElement; }


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\mtcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include "snmpmt.h"

/////////////////////////////////////////////////////////////////////////////
// Basic synchronization object

CSyncObject::CSyncObject(LPCTSTR pstrName)
{
    m_hObject = NULL;
}

CSyncObject::~CSyncObject()
{
    if (m_hObject != NULL)
    {
        ::CloseHandle(m_hObject);
        m_hObject = NULL;
    }
}

BOOL CSyncObject::Lock(DWORD dwTimeout)
{
    if (::WaitForSingleObject(m_hObject, dwTimeout) == WAIT_OBJECT_0)
        return TRUE;
    else
        return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// Inline function declarations expanded out-of-line


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\plex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include "plex.h"


CPlex* CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
    CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
            // may throw exception
    p->nMax = nMax;
    p->nCur = 0;
    p->pNext = pHead;
    pHead = p;  // change head (adds in reverse order for simplicity)
    return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
    CPlex* p = this;
    while (p != NULL)
    {
        BYTE* bytes = (BYTE*) p;
        CPlex* pNext = p->pNext;
        delete bytes;
        p = pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\mtex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <provexpt.h>
#include <snmpmt.h>

/////////////////////////////////////////////////////////////////////////////
// CSemaphore

CSemaphore::CSemaphore(LONG lInitialCount, LONG lMaxCount,
    LPCTSTR pstrName, LPSECURITY_ATTRIBUTES lpsaAttributes)
    :  CSyncObject(pstrName)
{
    m_hObject = ::CreateSemaphore(lpsaAttributes, lInitialCount, lMaxCount,
        pstrName);
}

CSemaphore::~CSemaphore()
{
}

BOOL CSemaphore::Unlock(LONG lCount, LPLONG lpPrevCount /* =NULL */)
{
    return ::ReleaseSemaphore(m_hObject, lCount, lpPrevCount);
}

/////////////////////////////////////////////////////////////////////////////
// CMutex

CMutex::CMutex(BOOL bInitiallyOwn, LPCTSTR pstrName,
    LPSECURITY_ATTRIBUTES lpsaAttribute /* = NULL */)
    : CSyncObject(pstrName)
{
    m_hObject = ::CreateMutex(lpsaAttribute, bInitiallyOwn, pstrName);
}

CMutex::~CMutex()
{
}

BOOL CMutex::Unlock()
{
    return ::ReleaseMutex(m_hObject);
}

/////////////////////////////////////////////////////////////////////////////
// CEvent

CEvent::CEvent(BOOL bInitiallyOwn, BOOL bManualReset, LPCTSTR pstrName,
    LPSECURITY_ATTRIBUTES lpsaAttribute)
    : CSyncObject(pstrName)
{
    m_hObject = ::CreateEvent(lpsaAttribute, bManualReset,
        bInitiallyOwn, pstrName);
}

CEvent::~CEvent()
{
}

BOOL CEvent::Unlock()
{
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSingleLock

CSingleLock::CSingleLock(CSyncObject* pObject, BOOL bInitialLock)
{
    m_pObject = pObject;
    m_hObject = pObject->m_hObject;
    m_bAcquired = FALSE;

    if (bInitialLock)
        Lock();
}

BOOL CSingleLock::Lock(DWORD dwTimeOut /* = INFINITE */)
{
    m_bAcquired = m_pObject->Lock(dwTimeOut);
    return m_bAcquired;
}

BOOL CSingleLock::Unlock()
{
    if (m_bAcquired)
        m_bAcquired = !m_pObject->Unlock();

    // successfully unlocking means it isn't acquired
    return !m_bAcquired;
}

BOOL CSingleLock::Unlock(LONG lCount, LPLONG lpPrevCount /* = NULL */)
{
    if (m_bAcquired)
        m_bAcquired = !m_pObject->Unlock(lCount, lpPrevCount);

    // successfully unlocking means it isn't acquired
    return !m_bAcquired;
}

/////////////////////////////////////////////////////////////////////////////
// CMultiLock

#define _countof(array) (sizeof(array)/sizeof(array[0]))

CMultiLock::CMultiLock(CSyncObject* pObjects[], DWORD dwCount,
    BOOL bInitialLock): m_pHandleArray ( NULL )
{
    m_ppObjectArray = pObjects;
    m_dwCount = dwCount;

    // as an optimization, skip alloacating array if
    // we can use a small, predeallocated bunch of handles

    if (m_dwCount > _countof(m_hPreallocated))
    {
        m_pHandleArray = new HANDLE[m_dwCount];
        m_bLockedArray = new BOOL[m_dwCount];
    }
    else
    {
        m_pHandleArray = m_hPreallocated;
        m_bLockedArray = m_bPreallocated;
    }

    // get list of handles from array of objects passed
    for (DWORD i = 0; i <m_dwCount; i++)
    {
        m_pHandleArray[i] = pObjects[i]->m_hObject;
        m_bLockedArray[i] = FALSE;
    }

    if (bInitialLock)
        Lock();
}

CMultiLock::~CMultiLock()
{
    Unlock();
    if (m_pHandleArray != m_hPreallocated)
    {
        delete[] m_bLockedArray;
        delete[] m_pHandleArray;
    }
}

DWORD CMultiLock::Lock(DWORD dwTimeOut /* = INFINITE */,
        BOOL bWaitForAll /* = TRUE */, DWORD dwWakeMask /* = 0 */)
{
    DWORD dwResult;
    if (dwWakeMask == 0)
        dwResult = ::WaitForMultipleObjects(m_dwCount,
            m_pHandleArray, bWaitForAll, dwTimeOut);
    else
        dwResult = ::MsgWaitForMultipleObjects(m_dwCount,
            m_pHandleArray, bWaitForAll, dwTimeOut, dwWakeMask);

    if (dwResult < (WAIT_OBJECT_0 + m_dwCount))
    {
        if (bWaitForAll)
        {
            for (DWORD i = 0; i < m_dwCount; i++)
                m_bLockedArray[i] = TRUE;
        }
        else
        {
            m_bLockedArray[dwResult - WAIT_OBJECT_0] = TRUE;
        }
    }
    return dwResult;
}

BOOL CMultiLock::Unlock()
{
    for (DWORD i=0; i < m_dwCount; i++)
    {
        if (m_bLockedArray[i])
            m_bLockedArray[i] = !m_ppObjectArray[i]->Unlock();
    }
    return TRUE;
}

BOOL CMultiLock::Unlock(LONG lCount, LPLONG lpPrevCount /* =NULL */)
{
    BOOL bGotOne = FALSE;
    for (DWORD i=0; i < m_dwCount; i++)
    {
        if (m_bLockedArray[i])
        {
            CSemaphore* pSemaphore = ( CSemaphore *) m_ppObjectArray[i];
            if (pSemaphore != NULL)
            {
                bGotOne = TRUE;
                m_bLockedArray[i] = !m_ppObjectArray[i]->Unlock(lCount, lpPrevCount);
            }
        }
    }

    return bGotOne;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\ansi\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\array_o.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

/////////////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include <provexpt.h>
#include <plex.h>
#include <snmpcoll.h>

CObArray::CObArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CObArray::~CObArray()
{
    delete[] (BYTE*)m_pData;
}

void CObArray::SetSize(int nNewSize, int nGrowBy)
{
    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        delete[] (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
        m_pData = (CObject**) new BYTE[nNewSize * sizeof(CObject*)];

        memset(m_pData, 0, nNewSize * sizeof(CObject*));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(CObject*));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        CObject** pNewData = (CObject**) new BYTE[nNewMax * sizeof(CObject*)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(CObject*));

        // construct remaining elements
        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(CObject*));


        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

int CObArray::Append(const CObArray& src)
{
    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);

    memcpy(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(CObject*));

    return nOldSize;
}

void CObArray::Copy(const CObArray& src)
{
    SetSize(src.m_nSize);

    memcpy(m_pData, src.m_pData, src.m_nSize * sizeof(CObject*));
}

void CObArray::FreeExtra()
{
    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
        CObject** pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (CObject**) new BYTE[m_nSize * sizeof(CObject*)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(CObject*));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CObArray::SetAtGrow(int nIndex, CObject* newElement)
{
    if (nIndex >= m_nSize)
        SetSize(nIndex+1);
    m_pData[nIndex] = newElement;
}

void CObArray::InsertAt(int nIndex, CObject* newElement, int nCount)
{
    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(CObject*));

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(CObject*));

    }

    // insert new value in the gap
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CObArray::RemoveAt(int nIndex, int nCount)
{
    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(CObject*));
    m_nSize -= nCount;
}

void CObArray::InsertAt(int nStartIndex, CObArray* pNewArray)
{
    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

int CObArray::GetSize() const
    { return m_nSize; }
int CObArray::GetUpperBound() const
    { return m_nSize-1; }
void CObArray::RemoveAll()
    { SetSize(0); }
CObject* CObArray::GetAt(int nIndex) const
    { return m_pData[nIndex]; }
void CObArray::SetAt(int nIndex, CObject* newElement)
    { m_pData[nIndex] = newElement; }
CObject*& CObArray::ElementAt(int nIndex)
    { return m_pData[nIndex]; }
const CObject** CObArray::GetData() const
    { return (const CObject**)m_pData; }
CObject** CObArray::GetData()
    { return (CObject**)m_pData; }
int CObArray::Add(CObject* newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
CObject* CObArray::operator[](int nIndex) const
    { return GetAt(nIndex); }
CObject*& CObArray::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\sources.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

WMIPRECOMPSHARED=1
!include $(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn
SOURCES_USED=$(PROJECT_ROOT)\wmi\wbem\common\makefile.cmn

TARGETNAME=snmpmfc
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES=$(INCLUDES); \
	$(SNMP_MFC_INC); \
	$(FRAMEWORK_EXPT_INC)

SOURCES= \
	..\PLEX.cpp \
	..\MTCORE.cpp \
	..\MTEX.cpp \
	..\Array_o.cpp \
	..\List_o.cpp \
	..\strex.cpp \
	..\strcore.cpp

USE_RTTI=1
USE_NATIVE_EH=ASYNC
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\plex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PLEX_H__
#define __PLEX_H__

struct CPlex    // warning variable length structure
{
	CPlex* pNext;
	UINT nMax;
	UINT nCur;
	/* BYTE data[maxNum*elementSize]; */

	void* data() { return this+1; }

	static CPlex* Create(CPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};


#endif //__PLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\snmpstd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __SNMPSTD_H_
#define __SNMPSTD_H_

#include <windows.h>
#include <stdio.h>
#include <provexpt.h>

struct __POSITION { };
typedef __POSITION* POSITION;
#define BEFORE_START_POSITION ((POSITION)-1L)

struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _AFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

class CObject 
{
public:

	CObject () {} ;
	virtual ~CObject () {} ;
} ;

#define AFXAPI __stdcall 
#define AFX_CDECL __cdecl

#pragma warning(disable: 4275)  // deriving exported class from non-exported
#pragma warning(disable: 4251)  // using non-exported as public in exported
#pragma warning(disable: 4114)

#include "snmpstr.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\unicode\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\snmpcoll.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __SNMPCOLL_H__
#define __SNMPCOLL_H__

#include "snmpstd.h"

class CObArray : public CObject
{
public:

// Construction
	CObArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	CObject* GetAt(int nIndex) const;
	void SetAt(int nIndex, CObject* newElement);
	CObject*& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const CObject** GetData() const;
	CObject** GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, CObject* newElement);
	int Add(CObject* newElement);
	int Append(const CObArray& src);
	void Copy(const CObArray& src);

	// overloaded operator helpers
	CObject* operator[](int nIndex) const;
	CObject*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, CObject* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CObArray* pNewArray);

// Implementation
protected:
	CObject** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CObArray();

protected:
	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};

/////////////////////////////////////////////////////////////////////////////

class CObList : public CObject
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CObject* data;
	};
public:

// Construction
	CObList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CObject*& GetHead();
	CObject* GetHead() const;
	CObject*& GetTail();
	CObject* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list!
	CObject* RemoveHead();
	CObject* RemoveTail();

	// add before head or after tail
	POSITION AddHead(CObject* newElement);
	POSITION AddTail(CObject* newElement);

	// add another list of elements before head or after tail
	void AddHead(CObList* pNewList);
	void AddTail(CObList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CObject*& GetNext(POSITION& rPosition); // return *Position++
	CObject* GetNext(POSITION& rPosition) const; // return *Position++
	CObject*& GetPrev(POSITION& rPosition); // return *Position--
	CObject* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CObject*& GetAt(POSITION position);
	CObject* GetAt(POSITION position) const;
	void SetAt(POSITION pos, CObject* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, CObject* newElement);
	POSITION InsertAfter(POSITION position, CObject* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(CObject* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CObList();

	// local typedefs for class templates
	typedef CObject* BASE_TYPE;
	typedef CObject* BASE_ARG_TYPE;
};

#endif //!__SNMPCOLL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\strex.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <snmpstd.h>
#include <snmptempl.h>
#include <snmpstr.h>

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(TCHAR ch, int nLength)
{
    Init();
    if (nLength >= 1)
    {
        AllocBuffer(nLength);
#ifdef _UNICODE
        for (int i = 0; i < nLength; i++)
            m_pchData[i] = ch;
#else
        memset(m_pchData, ch, nLength);
#endif
    }
}

CString::CString(LPCTSTR lpch, int nLength)
{
    Init();
    if (nLength != 0)
    {
        AllocBuffer(nLength);
        memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CString& CString::operator=(TCHAR ch)
{
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CString AFXAPI operator+(const CString& string1, TCHAR ch)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
    return s;
}

CString AFXAPI operator+(TCHAR ch, const CString& string)
{
    CString s;
    s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
    return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
    // out-of-bounds requests return sensible things
    if (nFirst < 0)
        nFirst = 0;
    if (nCount < 0)
        nCount = 0;

    if (nFirst + nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength - nFirst;
    if (nFirst > GetData()->nDataLength)
        nCount = 0;

    CString dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CString CString::Right(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CString dest;
    AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
    return dest;
}

CString CString::Left(int nCount) const
{
    if (nCount < 0)
        nCount = 0;
    else if (nCount > GetData()->nDataLength)
        nCount = GetData()->nDataLength;

    CString dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
    return Left(_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
    return Left(_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(TCHAR ch) const
{
    // find last single character
    LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(LPCTSTR lpszSub) const
{
    // find first matching substring
    LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

    // return -1 for not found, distance from beginning otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// CString formatting

#ifdef _MAC
    #define TCHAR_ARG   int
    #define WCHAR_ARG   unsigned
    #define CHAR_ARG    int
#else
    #define TCHAR_ARG   TCHAR
    #define WCHAR_ARG   WCHAR
    #define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
    #define DOUBLE_ARG  _AFX_DOUBLE
#else
    #define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
    va_list argListSave = argList;

    // make a guess at the maximum length of the resulting string
    int nMaxLen = 0;
    for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
    {
        // handle '%' character, but watch out for '%%'
        if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
        {
            nMaxLen += _tclen(lpsz);
            continue;
        }

        int nItemLen = 0;

        // handle '%' character with format
        int nWidth = 0;
        for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
        {
            // check for valid flags
            if (*lpsz == '#')
                nMaxLen += 2;   // for '0x'
            else if (*lpsz == '*')
                nWidth = va_arg(argList, int);
            else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                *lpsz == ' ')
                ;
            else // hit non-flag character
                break;
        }
        // get width and skip it
        if (nWidth == 0)
        {
            // width indicated by
            nWidth = _ttoi(lpsz);
            for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                ;
        }

        int nPrecision = 0;
        if (*lpsz == '.')
        {
            // skip past '.' separator (width.precision)
            lpsz = _tcsinc(lpsz);

            // get precision and skip it
            if (*lpsz == '*')
            {
                nPrecision = va_arg(argList, int);
                lpsz = _tcsinc(lpsz);
            }
            else
            {
                nPrecision = _ttoi(lpsz);
                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                    ;
            }
        }

        // should be on type modifier or specifier
        int nModifier = 0;
        switch (*lpsz)
        {
        // modifiers that affect size
        case 'h':
            nModifier = FORCE_ANSI;
            lpsz = _tcsinc(lpsz);
            break;
        case 'l':
            nModifier = FORCE_UNICODE;
            lpsz = _tcsinc(lpsz);
            break;

        // modifiers that do not affect size
        case 'F':
        case 'N':
        case 'L':
            lpsz = _tcsinc(lpsz);
            break;
        }

        // now should be on specifier
        switch (*lpsz | nModifier)
        {
        // single characters
        case 'c':
        case 'C':
            nItemLen = 2;
            va_arg(argList, TCHAR_ARG);
            break;
        case 'c'|FORCE_ANSI:
        case 'C'|FORCE_ANSI:
            nItemLen = 2;
            va_arg(argList, CHAR_ARG);
            break;
        case 'c'|FORCE_UNICODE:
        case 'C'|FORCE_UNICODE:
            nItemLen = 2;
            va_arg(argList, WCHAR_ARG);
            break;

        // strings
        case 's':
        {
            LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = lstrlen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

        case 'S':
        {
#ifndef _UNICODE
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6;  // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
#else
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
#endif
            break;
        }

        case 's'|FORCE_ANSI:
        case 'S'|FORCE_ANSI:
        {
            LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = lstrlenA(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }

#ifndef _MAC
        case 's'|FORCE_UNICODE:
        case 'S'|FORCE_UNICODE:
        {
            LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
            if (pstrNextArg == NULL)
               nItemLen = 6; // "(null)"
            else
            {
               nItemLen = wcslen(pstrNextArg);
               nItemLen = max(1, nItemLen);
            }
            break;
        }
#endif
        }

        // adjust nItemLen for strings
        if (nItemLen != 0)
        {
            nItemLen = max(nItemLen, nWidth);
            if (nPrecision != 0)
                nItemLen = min(nItemLen, nPrecision);
        }
        else
        {
            switch (*lpsz)
            {
            // integers
            case 'd':
            case 'i':
            case 'u':
            case 'x':
            case 'X':
            case 'o':
                va_arg(argList, int);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'e':
            case 'f':
            case 'g':
            case 'G':
                va_arg(argList, DOUBLE_ARG);
                nItemLen = 128;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            case 'p':
                va_arg(argList, void*);
                nItemLen = 32;
                nItemLen = max(nItemLen, nWidth+nPrecision);
                break;

            // no output
            case 'n':
                va_arg(argList, int*);
                break;

            default:
                break ;
            }
        }

        // adjust nMaxLen for output nItemLen
        nMaxLen += nItemLen;
    }

    GetBuffer(nMaxLen);
    _vstprintf(m_pchData, lpszFormat, argListSave);
    ReleaseBuffer();

    va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void AFX_CDECL CString::Format(LPCTSTR lpszFormat, ...)
{
    va_list argList;
    va_start(argList, lpszFormat);
    FormatV(lpszFormat, argList);
    va_end(argList);
}

#ifndef _MAC
// formatting (using FormatMessage style formatting)
void AFX_CDECL CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
    // format message into temporary buffer lpszTemp
    va_list argList;
    va_start(argList, lpszFormat);
    LPTSTR lpszTemp;

    if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
        lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
        lpszTemp == NULL)
    {
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    }

    // assign lpszTemp into the resulting string and free the temporary
    *this = lpszTemp;
    LocalFree(lpszTemp);
    va_end(argList);
}

#endif //!_MAC

void CString::TrimRight()
{
    CopyBeforeWrite();

    // find beginning of trailing spaces by starting at beginning (DBCS aware)
    LPTSTR lpsz = m_pchData;
    LPTSTR lpszLast = NULL;
    while (*lpsz != '\0')
    {
        if (_istspace(*lpsz))
        {
            if (lpszLast == NULL)
                lpszLast = lpsz;
        }
        else
            lpszLast = NULL;
        lpsz = _tcsinc(lpsz);
    }

    if (lpszLast != NULL)
    {
        // truncate at trailing space start
        *lpszLast = '\0';
        GetData()->nDataLength = (int)(lpszLast - m_pchData);
    }
}

void CString::TrimLeft()
{
    CopyBeforeWrite();

    // find first non-space character
    LPCTSTR lpsz = m_pchData;
    while (_istspace(*lpsz))
        lpsz = _tcsinc(lpsz);

    // fix up data and length
    int nDataLength = GetData()->nDataLength - (int)(lpsz - m_pchData);
    memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
    GetData()->nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// CString support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CString> (CString* pElements, int nCount)
#else
void AFXAPI ConstructElements(CString* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        memcpy(pElements, &afxEmptyString, sizeof(*pElements));
}

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CString> (CString* pElements, int nCount)
#else
void AFXAPI DestructElements(CString* pElements, int nCount)
#endif
{
    for (; nCount--; ++pElements)
        pElements->~CString();
}

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CString> (CString* pDest, const CString* pSrc, int nCount)
#else
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount)
#endif
{
    for (; nCount--; ++pDest, ++pSrc)
        *pDest = *pSrc;
}

/*
#ifndef OLE2ANSI
#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key)
#else
UINT AFXAPI HashKey(LPCWSTR key)
#endif
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}
#endif

#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCSTR> (LPCSTR key)
#else
UINT AFXAPI HashKey(LPCSTR key)
#endif
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}
*/
UINT AFXAPI HashKeyLPCWSTR(LPCWSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}
UINT AFXAPI HashKeyLPCSTR(LPCSTR key)
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash<<5) + nHash + *key++;
    return nHash;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\strcore.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"
#include <snmpstd.h>
#include <snmptempl.h>
#include <snmpstr.h>


/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int rgInitData[] = { -1, 0, 0, 0 };
static CStringData* afxDataNil = (CStringData*)&rgInitData;
static LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));
// special function to make afxEmptyString work even during initialization
const CString& AFXAPI AfxGetEmptyString()
    { return *(CString*)&afxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
    Init();
}

CString::CString(const CString& stringSrc)
{
    if (stringSrc.GetData()->nRefs >= 0)
    {
        m_pchData = stringSrc.m_pchData;
        InterlockedIncrement(&GetData()->nRefs);
    }
    else
    {
        Init();
        *this = stringSrc.m_pchData;
    }
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
    if (nLen == 0)
        Init();
    else
    {
        CStringData* pData =
            (CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
        pData->nRefs = 1;
        pData->data()[nLen] = '\0';
        pData->nDataLength = nLen;
        pData->nAllocLength = nLen;
        m_pchData = pData->data();
    }
}

void CString::Release()
{
    if (GetData() != afxDataNil)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
        Init();
    }
}

void PASCAL CString::Release(CStringData* pData)
{
    if (pData != afxDataNil)
    {
        if (InterlockedDecrement(&pData->nRefs) <= 0)
            delete[] (BYTE*)pData;
    }
}

void CString::Empty()
{
    if (GetData()->nDataLength == 0)
        return;
    if (GetData()->nRefs >= 0)
        Release();
    else
        *this = &afxChNil;
}

void CString::CopyBeforeWrite()
{
    if (GetData()->nRefs > 1)
    {
        CStringData* pData = GetData();
        Release();
        AllocBuffer(pData->nDataLength);
        memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
    }
}

void CString::AllocBeforeWrite(int nLen)
{
    if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
    {
        Release();
        AllocBuffer(nLen);
    }
}

CString::~CString()
//  free any attached data
{
    if (GetData() != afxDataNil)
    {
        if (InterlockedDecrement(&GetData()->nRefs) <= 0)
            delete[] (BYTE*)GetData();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;
    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCTSTR lpsz)
{
    Init();
    int nLen = SafeStrlen(lpsz);
    if (nLen != 0)
    {
        AllocBuffer(nLen);
        memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef _UNICODE
CString::CString(LPCSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen);
        _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        ReleaseBuffer();
    }
}
#else //_UNICODE
CString::CString(LPCWSTR lpsz)
{
    Init();
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    if (nSrcLen != 0)
    {
        AllocBuffer(nSrcLen*2);
        _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
        ReleaseBuffer();
    }
}
#endif //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
    AllocBeforeWrite(nSrcLen);
    memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
    GetData()->nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
    if (m_pchData != stringSrc.m_pchData)
    {
        if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
            stringSrc.GetData()->nRefs < 0)
        {
            // actual copy necessary since one of the strings is locked
            AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
        }
        else
        {
            // can just copy references around
            Release();
            m_pchData = stringSrc.m_pchData;
            InterlockedIncrement(&GetData()->nRefs);
        }
    }
    return *this;
}

const CString& CString::operator=(LPCTSTR lpsz)
{
    AssignCopy(SafeStrlen(lpsz), lpsz);
    return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef _UNICODE
const CString& CString::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    AllocBeforeWrite(nSrcLen);
    _mbstowcsz(m_pchData, lpsz, nSrcLen+1);
    ReleaseBuffer();
    return *this;
}
#else //!_UNICODE
const CString& CString::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    AllocBeforeWrite(nSrcLen*2);
    _wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
    ReleaseBuffer();
    return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
    int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

    int nNewLen = nSrc1Len + nSrc2Len;
    if (nNewLen != 0)
    {
        AllocBuffer(nNewLen);
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
        memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
    }
}

CString AFXAPI operator+(const CString& string1, const CString& string2)
{
    CString s;
    s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
        string2.GetData()->nDataLength, string2.m_pchData);
    return s;
}

CString AFXAPI operator+(const CString& string, LPCTSTR lpsz)
{
    CString s;
    s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
        CString::SafeStrlen(lpsz), lpsz);
    return s;
}

CString AFXAPI operator+(LPCTSTR lpsz, const CString& string)
{
    CString s;
    s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
        string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
    //  -- the main routine for += operators

    // concatenating an empty string is a no-op!
    if (nSrcLen == 0)
        return;

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
    {
        // we have to grow the buffer, use the ConcatCopy routine
        CStringData* pOldData = GetData();
        ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
        CString::Release(pOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
        GetData()->nDataLength += nSrcLen;
        m_pchData[GetData()->nDataLength] = '\0';
    }
}

const CString& CString::operator+=(LPCTSTR lpsz)
{
    ConcatInPlace(SafeStrlen(lpsz), lpsz);
    return *this;
}

const CString& CString::operator+=(TCHAR ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CString& CString::operator+=(const CString& string)
{
    ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CString::GetBuffer(int nMinBufLength)
{
    if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
    {
        // we have to grow the buffer
        CStringData* pOldData = GetData();
        int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
        if (nMinBufLength < nOldLen)
            nMinBufLength = nOldLen;
        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
        GetData()->nDataLength = nOldLen;
        CString::Release(pOldData);
    }

    // return a pointer to the character storage for this string
    return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
    CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
        nNewLength = lstrlen(m_pchData); // zero terminated

    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
}

LPTSTR CString::GetBufferSetLength(int nNewLength)
{
    GetBuffer(nNewLength);
    GetData()->nDataLength = nNewLength;
    m_pchData[nNewLength] = '\0';
    return m_pchData;
}

void CString::FreeExtra()
{
    if (GetData()->nDataLength != GetData()->nAllocLength)
    {
        CStringData* pOldData = GetData();
        AllocBuffer(GetData()->nDataLength);
        memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
        CString::Release(pOldData);
    }
}

LPTSTR CString::LockBuffer()
{
    LPTSTR lpsz = GetBuffer(0);
    GetData()->nRefs = -1;
    return lpsz;
}

void CString::UnlockBuffer()
{
    if (GetData() != afxDataNil)
        GetData()->nRefs = 1;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CString::Find(TCHAR ch) const
{
    // find first single character
    LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

    // return -1 if not found and index otherwise
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
    LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
    return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

void CString::MakeUpper()
{
    CopyBeforeWrite();
    _tcsupr(m_pchData);
}

void CString::MakeLower()
{
    CopyBeforeWrite();
    _tcslwr(m_pchData);
}

void CString::MakeReverse()
{
    CopyBeforeWrite();
    _tcsrev(m_pchData);
}

void CString::SetAt(int nIndex, TCHAR ch)
{
    CopyBeforeWrite();
    m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
void CString::AnsiToOem()
{
    CopyBeforeWrite();
    ::AnsiToOem(m_pchData, m_pchData);
}
void CString::OemToAnsi()
{
    CopyBeforeWrite();
    ::OemToAnsi(m_pchData, m_pchData);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// CString conversion helpers (these use the current system locale)

int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
    if (count == 0 && mbstr != NULL)
        return 0;

    int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
        mbstr, count, NULL, NULL);

    if (result > 0)
        mbstr[result-1] = 0;
    return result;
}

int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
    if (count == 0 && wcstr != NULL)
        return 0;

    int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
        wcstr, count);

    if (result > 0)
        wcstr[result-1] = 0;
    return result;
}

LPWSTR AFXAPI AfxA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    if (lpa == NULL)
        return NULL;

    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

LPSTR AFXAPI AfxW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    if (lpw == NULL)
        return NULL;

    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}

///////////////////////////////////////////////////////////////////////////////
// OLE BSTR support

BSTR CString::AllocSysString() const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
    BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    BSTR bstr = ::SysAllocStringLen(NULL, nLen);
    if (bstr == NULL)
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        bstr, nLen);
#endif

    return bstr;
}

BSTR CString::SetSysString(BSTR* pbstr) const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
    if (!::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
#else
    int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
        GetData()->nDataLength, NULL, NULL);
    if (!::SysReAllocStringLen(pbstr, NULL, nLen))
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR) ;
    MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength,
        *pbstr, nLen);
#endif

    return *pbstr;
}

// CString
CStringData* CString::GetData() const
    { return ((CStringData*)m_pchData)-1; }
void CString::Init()
    { m_pchData = afxEmptyString.m_pchData; }
CString::CString(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
const CString& CString::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
const CString& CString::operator+=(char ch)
    { *this += (TCHAR)ch; return *this; }
const CString& CString::operator=(char ch)
    { *this = (TCHAR)ch; return *this; }
CString AFXAPI operator+(const CString& string, char ch)
    { return string + (TCHAR)ch; }
CString AFXAPI operator+(char ch, const CString& string)
    { return (TCHAR)ch + string; }
#endif

int CString::GetLength() const
    { return GetData()->nDataLength; }
int CString::GetAllocLength() const
    { return GetData()->nAllocLength; }
BOOL CString::IsEmpty() const
    { return GetData()->nDataLength == 0; }
CString::operator LPCTSTR() const
    { return m_pchData; }
int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
    { return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
int CString::Compare(LPCTSTR lpsz) const
    { return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
int CString::CompareNoCase(LPCTSTR lpsz) const
    { return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
int CString::Collate(LPCTSTR lpsz) const
    { return _tcscoll(m_pchData, lpsz); }   // locale sensitive

TCHAR CString::GetAt(int nIndex) const
{
    return m_pchData[nIndex];
}
TCHAR CString::operator[](int nIndex) const
{
    // same as GetAt
    return m_pchData[nIndex];
}
bool AFXAPI operator==(const CString& s1, const CString& s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) == 0; }
bool AFXAPI operator==(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) == 0; }
bool AFXAPI operator!=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) != 0; }
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) != 0; }
bool AFXAPI operator<(const CString& s1, const CString& s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) < 0; }
bool AFXAPI operator<(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) > 0; }
bool AFXAPI operator>(const CString& s1, const CString& s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) > 0; }
bool AFXAPI operator>(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) < 0; }
bool AFXAPI operator<=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) <= 0; }
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) >= 0; }
bool AFXAPI operator>=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) >= 0; }
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) <= 0; }


///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\snmptempl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXTEMPL_H__
#define __AFXTEMPL_H__

#ifndef __AFXPLEX_H__
#include "plex.h"
#endif

//#include <new.h>
#include "snmpstd.h"
#include "snmpstr.h"

template<class TYPE>
inline void AFXAPI ConstructElements(TYPE* pElements, int nCount)
{
	// first do bit-wise zero initialization
	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	// then call the constructor(s)
	for (; nCount--; pElements++)
		::new((void*)pElements) TYPE;
}

template<class TYPE>
inline void AFXAPI DestructElements(TYPE* pElements, int nCount)
{
	// call the destructor(s)
	for (; nCount--; pElements++)
		pElements->~TYPE();
}

template<class TYPE>
inline void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
	// default is element-copy using assignment
	while (nCount--)
		*pDest++ = *pSrc++;
}

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT AFXAPI HashKey(ARG_KEY key)
{
	// default identity hash - works for most primitive values
	return (UINT)(((UINT_PTR) key) >> 4);
}

///////////////////////////////////////////////////////////////////////////////
// CString support for template collections

#if _MSC_VER >= 1100
template<> void AFXAPI ConstructElements<CString> (CString* pElements, int nCount);
#else
void AFXAPI ConstructElements(CString* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI DestructElements<CString> (CString* pElements, int nCount);
#else
void AFXAPI DestructElements(CString* pElements, int nCount);
#endif

#if _MSC_VER >= 1100
template<> void AFXAPI CopyElements<CString> (CString* pDest, const CString* pSrc, int nCount);
#else
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount);
#endif

/*
#ifndef OLE2ANSI
#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key);
#else
UINT AFXAPI HashKey(LPCWSTR key);
#endif
#endif

#if _MSC_VER >= 1100
template<> UINT AFXAPI HashKey<LPCSTR> (LPCSTR key);
#else
UINT AFXAPI HashKey(LPCSTR key);
#endif
*/
UINT AFXAPI HashKeyLPCWSTR(LPCWSTR key);
UINT AFXAPI HashKeyLPCSTR(LPCSTR key);


/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray 
{
public:
// Construction
	CArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	TYPE GetAt(int nIndex) const;
	void SetAt(int nIndex, ARG_TYPE newElement);
	TYPE& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const TYPE* GetData() const;
	TYPE* GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, ARG_TYPE newElement);
	int Add(ARG_TYPE newElement);
	int Append(const CArray& src);
	void Copy(const CArray& src);

	// overloaded operator helpers
	TYPE operator[](int nIndex) const;
	TYPE& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
	TYPE* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CArray();
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
	{ return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
	{ SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
	{ return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
	{ m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
	{ return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
	{ return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
	{ return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
	if (m_pData != NULL)
	{
		DestructElements<TYPE>(m_pData, m_nSize);
		delete[] (BYTE*)m_pData;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		if (m_pData != NULL)
		{
			DestructElements<TYPE>(m_pData, m_nSize);
			delete[] (BYTE*)m_pData;
			m_pData = NULL;
		}
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
		ConstructElements<TYPE>(m_pData, nNewSize);
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);
		}
		else if (m_nSize > nNewSize)
		{
			// destroy the old elements
			DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = m_nSize / 8;
			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

		// construct remaining elements

		ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);
	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
	return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
	SetSize(src.m_nSize);
	CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
		TYPE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
			// copy new data from old
			memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
	if (nIndex >= m_nSize)
		SetSize(nIndex+1, -1);
	m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount, -1);  // grow it to new size
		// destroy intial data before copying over it
		DestructElements<TYPE>(&m_pData[nOldSize], nCount);
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(TYPE));

		// re-init slots we copied from
		ConstructElements<TYPE>(&m_pData[nIndex], nCount);
	}

	// insert new value in the gap

	while (nCount--)
		m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	DestructElements<TYPE>(&m_pData[nIndex], nCount);
	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(TYPE));
	m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList 
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	CList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CList* pNewList);
	void AddTail(CList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); // return *Position++
	TYPE GetNext(POSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(POSITION& rPosition); // return *Position--
	TYPE GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	POSITION FindIndex(int nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CList();
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
	{ return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
	{ return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
	{ return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
	{ return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		DestructElements<TYPE>(&pNode->data, 1);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
	RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CList::CNode* pPrev, CList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}

	CList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;

	ConstructElements<TYPE>(&pNode->data, 1);
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CList::CNode* pNode)
{
	DestructElements<TYPE>(&pNode->data, 1);
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;

	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
	CNode* pOldNode = (CNode*) position;

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements<TYPE>(&pNode->data, &searchValue))
			return (POSITION)pNode;
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap 
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		KEY key;
		VALUE value;
	};
public:
// Construction
	CMap(int nBlockSize = 10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;
	BOOL GetCurrentAssoc(POSITION rPosition, KEY& rKey, VALUE& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
	~CMap();
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				DestructElements<VALUE>(&pAssoc->value, 1);
				DestructElements<KEY>(&pAssoc->key, 1);
			}
		}
	}

	// free hash table
	delete[] m_pHashTable;
	m_pHashTable = NULL;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
	RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
		// chain them into free list
		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}

	CMap::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;

	ConstructElements<KEY>(&pAssoc->key, 1);
	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CMap::CAssoc* pAssoc)
{
	DestructElements<VALUE>(&pAssoc->value, 1);
	DestructElements<KEY>(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	UINT nHash;
	CAssoc* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	UINT nHash;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	CAssoc* pAssocRet = (CAssoc*)rNextPosition;

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
	}

	// find next association

	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCurrentAssoc(POSITION rPosition,
	KEY& rKey, VALUE& rValue) const
{
	CAssoc* pAssocRet = (CAssoc*)rPosition;

	if (pAssocRet != (CAssoc*) BEFORE_START_POSITION)
	{
		// fill in return data
		rKey = pAssocRet->key;
		rValue = pAssocRet->value;

		return TRUE ;
	}
	else
	{
		return FALSE ;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(int nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(int nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
	void SetAt(int nIndex, TYPE ptr)
		{ BASE_CLASS::SetAt(nIndex, ptr); }

	// Potentially growing the array
	void SetAtGrow(int nIndex, TYPE newElement)
	   { BASE_CLASS::SetAtGrow(nIndex, newElement); }
	int Add(TYPE newElement)
	   { return BASE_CLASS::Add(newElement); }
	int Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
	   { return BASE_CLASS::Append(src); }
	void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
		{ BASE_CLASS::Copy(src); }

	// Operations that move elements around
	void InsertAt(int nIndex, TYPE newElement, int nCount = 1)
		{ BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
	void InsertAt(int nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
	   { BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

	// overloaded operator helpers
	TYPE operator[](int nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](int nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
// Construction
	CTypedPtrList(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// peek at head or tail
	TYPE& GetHead()
		{ return (TYPE&)BASE_CLASS::GetHead(); }
	TYPE GetHead() const
		{ return (TYPE)BASE_CLASS::GetHead(); }
	TYPE& GetTail()
		{ return (TYPE&)BASE_CLASS::GetTail(); }
	TYPE GetTail() const
		{ return (TYPE)BASE_CLASS::GetTail(); }

	// get head or tail (and remove it) - don't call on empty list!
	TYPE RemoveHead()
		{ return (TYPE)BASE_CLASS::RemoveHead(); }
	TYPE RemoveTail()
		{ return (TYPE)BASE_CLASS::RemoveTail(); }

	// add before head or after tail
	POSITION AddHead(TYPE newElement)
		{ return BASE_CLASS::AddHead(newElement); }
	POSITION AddTail(TYPE newElement)
		{ return BASE_CLASS::AddTail(newElement); }

	// add another list of elements before head or after tail
	void AddHead(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddHead(pNewList); }
	void AddTail(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddTail(pNewList); }

	// iteration
	TYPE& GetNext(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetNext(rPosition); }
	TYPE GetNext(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetNext(rPosition); }
	TYPE& GetPrev(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
	TYPE GetPrev(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetPrev(rPosition); }

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position)
		{ return (TYPE&)BASE_CLASS::GetAt(position); }
	TYPE GetAt(POSITION position) const
		{ return (TYPE)BASE_CLASS::GetAt(position); }
	void SetAt(POSITION pos, TYPE newElement)
		{ BASE_CLASS::SetAt(pos, newElement); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:

// Construction
	CTypedPtrMap(int nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// Lookup
	BOOL Lookup(BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

	// Lookup and add if not there
	VALUE& operator[](BASE_CLASS::BASE_ARG_KEY key)
		{ return (VALUE&)BASE_CLASS::operator[](key); }

	// add a new key (key, value) pair
	void SetAt(KEY key, VALUE newValue)
		{ BASE_CLASS::SetAt(key, newValue); }

	// removing existing (key, ?) pair
	BOOL RemoveKey(KEY key)
		{ return BASE_CLASS::RemoveKey(key); }

	// iteration
	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
			(BASE_CLASS::BASE_VALUE&)rValue); }
};

/////////////////////////////////////////////////////////////////////////////

#endif //__AFXTEMPL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\snmpstr.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef _SNMPSTR_H_
#define _SNMPSTR_H_

#include "snmpstd.h"
#include <tchar.h>

struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString AFXAPI operator+(const CString& string1,
			const CString& string2);
	friend CString AFXAPI operator+(const CString& string, TCHAR ch);
	friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString AFXAPI operator+(const CString& string, char ch);
	friend CString AFXAPI operator+(char ch, const CString& string);
#endif
	friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
	friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void AFX_CDECL Format(LPCTSTR lpszFormat, ...);

#ifndef _MAC
	// formatting for localization (uses FormatMessage API)
	void AFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
#endif

#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool AFXAPI operator==(const CString& s1, const CString& s2);
bool AFXAPI operator==(const CString& s1, LPCTSTR s2);
bool AFXAPI operator==(LPCTSTR s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2);

// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern TCHAR afxChNil;
const CString& AFXAPI AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\snmpmfc\include\snmpmt.h ===
// This is a part of the Microsoft Foundation Classes C++ library.

// Copyright (c) 1992-2001 Microsoft Corporation, All Rights Reserved
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __SNMPMT_H__
#define __SNMPMT_H__

#ifdef UNICODE
#define LPCTSTR wchar_t *
#else
#define LPCTSTR char *
#endif

class CSyncObject;
class CSemaphore;
class CMutex;
class CEvent;
class CCriticalSection;
class CSingleLock;
class CMultiLock;

/////////////////////////////////////////////////////////////////////////////
// Basic synchronization object

class CSyncObject
{
public:

	CSyncObject(LPCTSTR pstrName);

// Attributes
public:
	operator HANDLE() const;
	HANDLE  m_hObject;

// Operations
	virtual BOOL Lock(DWORD dwTimeout = INFINITE);
	virtual BOOL Unlock() = 0;
	virtual BOOL Unlock(LONG /* lCount */, LPLONG /* lpPrevCount=NULL */)
		{ return TRUE; }

// Implementation
public:
	virtual ~CSyncObject();
	friend class CSingleLock;
	friend class CMultiLock;
};

/////////////////////////////////////////////////////////////////////////////
// CSemaphore

class CSemaphore : public CSyncObject
{
// Constructor
public:
	CSemaphore(LONG lInitialCount = 1, LONG lMaxCount = 1,
		LPCTSTR pstrName=NULL, LPSECURITY_ATTRIBUTES lpsaAttributes = NULL);

// Implementation
public:
	virtual ~CSemaphore();
	virtual BOOL Unlock();
	virtual BOOL Unlock(LONG lCount, LPLONG lprevCount = NULL);
};

/////////////////////////////////////////////////////////////////////////////
// CMutex

class CMutex : public CSyncObject
{
// Constructor
public:
	CMutex(BOOL bInitiallyOwn = FALSE, LPCTSTR lpszName = NULL,
		LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Implementation
public:
	virtual ~CMutex();
	BOOL Unlock();
};

/////////////////////////////////////////////////////////////////////////////
// CEvent

class CEvent : public CSyncObject
{
// Constructor
public:
	CEvent(BOOL bInitiallyOwn = FALSE, BOOL bManualReset = FALSE,
		LPCTSTR lpszNAme = NULL, LPSECURITY_ATTRIBUTES lpsaAttribute = NULL);

// Operations
public:
	BOOL SetEvent();
	BOOL PulseEvent();
	BOOL ResetEvent();
	BOOL Unlock();

// Implementation
public:
	virtual ~CEvent();
};

/////////////////////////////////////////////////////////////////////////////
// CCriticalSection

class CCriticalSection : public CSyncObject
{
// Constructor
public:
	CCriticalSection();

// Attributes
public:
	operator CRITICAL_SECTION*();
	CRITICAL_SECTION m_sect;

// Operations
public:
	BOOL Unlock();
	BOOL Lock();
	BOOL Lock(DWORD dwTimeout);

// Implementation
public:
	virtual ~CCriticalSection();
};

/////////////////////////////////////////////////////////////////////////////
// CSingleLock

class CSingleLock
{
// Constructors
public:
	CSingleLock(CSyncObject* pObject, BOOL bInitialLock = FALSE);

// Operations
public:
	BOOL Lock(DWORD dwTimeOut = INFINITE);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked();

// Implementation
public:
	~CSingleLock();

protected:
	CSyncObject* m_pObject;
	HANDLE  m_hObject;
	BOOL    m_bAcquired;
};

/////////////////////////////////////////////////////////////////////////////
// CMultiLock

class CMultiLock
{
// Constructor
public:
	CMultiLock(CSyncObject* ppObjects[], DWORD dwCount, BOOL bInitialLock = FALSE);

// Operations
public:
	DWORD Lock(DWORD dwTimeOut = INFINITE, BOOL bWaitForAll = TRUE,
		DWORD dwWakeMask = 0);
	BOOL Unlock();
	BOOL Unlock(LONG lCount, LPLONG lPrevCount = NULL);
	BOOL IsLocked(DWORD dwItem);

// Implementation
public:
	~CMultiLock();

protected:
	HANDLE  m_hPreallocated[8];
	BOOL    m_bPreallocated[8];

	CSyncObject* const * m_ppObjectArray;
	HANDLE* m_pHandleArray;
	BOOL*   m_bLockedArray;
	DWORD   m_dwCount;
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline CSyncObject::operator HANDLE() const
	{ return m_hObject;}

inline BOOL CSemaphore::Unlock()
	{ return Unlock(1, NULL); }

inline BOOL CEvent::SetEvent()
	{ return ::SetEvent(m_hObject); }
inline BOOL CEvent::PulseEvent()
	{ return ::PulseEvent(m_hObject); }
inline BOOL CEvent::ResetEvent()
	{ return ::ResetEvent(m_hObject); }

inline CSingleLock::~CSingleLock()
	{ Unlock(); }
inline BOOL CSingleLock::IsLocked()
	{ return m_bAcquired; }

inline BOOL CMultiLock::IsLocked(DWORD dwObject)
	{ return m_bLockedArray[dwObject]; }

inline CCriticalSection::CCriticalSection() : CSyncObject(NULL)
	{ ::InitializeCriticalSection(&m_sect); }
inline CCriticalSection::operator CRITICAL_SECTION*()
	{ return (CRITICAL_SECTION*) &m_sect; }
inline CCriticalSection::~CCriticalSection()
	{ ::DeleteCriticalSection(&m_sect); }
inline BOOL CCriticalSection::Lock()
	{ ::EnterCriticalSection(&m_sect); return TRUE; }
inline BOOL CCriticalSection::Lock(DWORD /* dwTimeout */)
	{ return Lock(); }
inline BOOL CCriticalSection::Unlock()
	{ ::LeaveCriticalSection(&m_sect); return TRUE; }


#endif  // __AFXMT_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\maindll.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <process.h>
#include <objbase.h>
#include <snmpcont.h>
#include "snmpevt.h"
#include "snmpthrd.h"
#include "snmplog.h"

extern CRITICAL_SECTION g_SnmpDebugLogMapCriticalSection ;


//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

    HINSTANCE hInstance, 
    ULONG ulReason , 
    LPVOID pvReserved
)
{
    BOOL status = TRUE ;
    SetStructuredExceptionHandler seh;

    try
    {
        if ( DLL_PROCESS_DETACH == ulReason )
        {
            SnmpThreadObject :: ProcessDetach ( TRUE ) ;
            DeleteCriticalSection ( &SnmpDebugLog :: s_CriticalSection ) ;
            DeleteCriticalSection ( &g_SnmpDebugLogMapCriticalSection ) ;
            status = TRUE ;
        }
        else if ( DLL_PROCESS_ATTACH == ulReason )
        {
            InitializeCriticalSection ( &SnmpDebugLog :: s_CriticalSection ) ;
            InitializeCriticalSection ( &g_SnmpDebugLogMapCriticalSection ) ;
            SnmpThreadObject :: ProcessAttach () ;
            status = TRUE ;
			DisableThreadLibraryCalls(hInstance);			// 158024 
        }
        else if ( DLL_THREAD_DETACH == ulReason )
        {
            status = TRUE ;
        }
        else if ( DLL_THREAD_ATTACH == ulReason )
        {
            status = TRUE ;
        }
    }
    catch(Structured_Exception e_SE)
    {
        status = FALSE;
    }
    catch(Heap_Exception e_HE)
    {
        status = FALSE;
    }
    catch(...)
    {
        status = FALSE;
    }

    return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\snmpevt.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <snmpcont.h>
#include "snmpevt.h"
#include "snmpthrd.h"

SnmpEventObject :: SnmpEventObject ( const wchar_t *globalEventName ) : m_event ( NULL )
{
    m_event = CreateEvent (

        NULL ,
        FALSE ,
        FALSE ,
        globalEventName 
    ) ;

    if ( m_event == NULL )
    {
        if ( GetLastError () == ERROR_ALREADY_EXISTS )
        {
            m_event = OpenEvent (

                EVENT_ALL_ACCESS ,
                FALSE , 
                globalEventName
            ) ;
        }
    }
}

SnmpEventObject :: ~SnmpEventObject () 
{
    if ( m_event != NULL )
    {
        CloseHandle ( m_event ) ;
    }
}

HANDLE SnmpEventObject :: GetHandle () 
{
    return m_event ;
}

void SnmpEventObject :: Set () 
{
    SetEvent ( m_event ) ;
}

void SnmpEventObject :: Clear () 
{
    ResetEvent ( m_event ) ;
}

void SnmpEventObject :: Process () 
{
}

BOOL SnmpEventObject :: Wait ()
{
    return WaitForSingleObject ( GetHandle () , INFINITE ) == WAIT_OBJECT_0 ;
}

void SnmpEventObject :: Complete ()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\snmplog.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmpstd.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <string.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <snmpcont.h>
#include <snmplog.h>
#include <snmpevt.h>
#include <snmpthrd.h>

#define LOG_KEY                 _T("Software\\Microsoft\\WBEM\\PROVIDERS\\Logging")
#define LOG_KEY_SLASH           _T("Software\\Microsoft\\WBEM\\PROVIDERS\\Logging\\")
#define LOGGING_ON              _T("Logging")
#define BACKSLASH_STRING        _T("\\")
#define DEFAULT_FILE_EXT        _T(".log")
#define LOGGING_DIR_VALUE       _T("Logging Directory")
#define LOGGING_DIR_KEY         _T("Software\\Microsoft\\WBEM\\CIMOM")
#define DEFAULT_PATH            _T("C:\\")
#define DEFAULT_FILE_SIZE       0x0FFFF
#define MIN_FILE_SIZE           1024
#define MAX_MESSAGE_SIZE		1024
#define HALF_MAX_MESSAGE_SIZE	512

#define LOG_FILE_NAME               _T("File")
#define LOG_LEVEL_NAME              _T("Level")
#define LOG_FILE_SIZE               _T("MaxFileSize")
#define LOG_TYPE_NAME               _T("Type")
#define LOG_TYPE_FILE_STRING        _T("File")
#define LOG_TYPE_DEBUG_STRING       _T("Debugger")

long SnmpDebugLog :: s_ReferenceCount = 0 ;
CRITICAL_SECTION SnmpDebugLog :: s_CriticalSection ;

CMap <SnmpDebugLog *,SnmpDebugLog *,SnmpDebugLog *,SnmpDebugLog *> g_SnmpDebugLogMap ;
CRITICAL_SECTION g_SnmpDebugLogMapCriticalSection ;

class SnmpDebugTaskObject : public SnmpTaskObject
{
private:

    HKEY m_LogKey ;

protected:
public:

    SnmpDebugTaskObject () ;
    ~SnmpDebugTaskObject () ;

    void Process () ;

    void SetRegistryNotification () ;
} ;

SnmpDebugTaskObject :: SnmpDebugTaskObject () : m_LogKey ( NULL )
{
}

SnmpDebugTaskObject :: ~SnmpDebugTaskObject ()
{
    if ( m_LogKey )
        RegCloseKey ( m_LogKey ) ;
}

void SnmpDebugTaskObject :: Process ()
{
    SnmpDebugLog *t_SnmpDebugLog = NULL ;
    EnterCriticalSection ( &g_SnmpDebugLogMapCriticalSection ) ;

    POSITION t_Position = g_SnmpDebugLogMap.GetStartPosition () ;
    while ( t_Position )
    {
        g_SnmpDebugLogMap.GetNextAssoc ( t_Position , t_SnmpDebugLog , t_SnmpDebugLog ) ;
        t_SnmpDebugLog->LoadRegistry () ;
        t_SnmpDebugLog->SetRegistry () ;
    }

    LeaveCriticalSection ( &g_SnmpDebugLogMapCriticalSection ) ;
    SetRegistryNotification () ;

}

void SnmpDebugTaskObject :: SetRegistryNotification ()
{
    if ( m_LogKey )
        RegCloseKey ( m_LogKey ) ;

    LONG t_Status = RegCreateKeyEx (
    
        HKEY_LOCAL_MACHINE, 
        LOG_KEY, 
        0, 
        NULL, 
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
        NULL, 
        &m_LogKey, 
        NULL
    ) ;
            
    if ( t_Status == ERROR_SUCCESS )
    {
        t_Status = RegNotifyChangeKeyValue ( 

            m_LogKey , 
            TRUE , 
            REG_NOTIFY_CHANGE_LAST_SET , 
            GetHandle () , 
            TRUE 
        ) ; 

        if ( t_Status == ERROR_SUCCESS )
        {
        }
    }
}

class SnmpDebugThreadObject : public SnmpThreadObject
{
private:

    SnmpDebugTaskObject *m_SnmpDebugTaskObject ;
    
protected:

    void Uninitialise () { delete this ; }

public:

    SnmpDebugThreadObject ( const char *a_Thread ) ;
    ~SnmpDebugThreadObject () ;

    SnmpDebugTaskObject *GetTaskObject () ;
} ;

SnmpDebugThreadObject *g_SnmpDebugLogThread = NULL ;

SnmpDebugLog *SnmpDebugLog :: s_SnmpDebugLog = NULL ;
BOOL SnmpDebugLog :: s_Initialised = FALSE ;

SnmpDebugThreadObject :: SnmpDebugThreadObject ( const char *a_Thread ) 
: SnmpThreadObject ( a_Thread ) , m_SnmpDebugTaskObject ( NULL )
{
    m_SnmpDebugTaskObject = new SnmpDebugTaskObject ;
    SnmpDebugLog :: s_SnmpDebugLog = new SnmpDebugLog ( _T("WBEMSNMP") ) ;
    ScheduleTask ( *m_SnmpDebugTaskObject ) ;
}

SnmpDebugThreadObject :: ~SnmpDebugThreadObject ()
{
    delete SnmpDebugLog :: s_SnmpDebugLog ;
    SnmpDebugLog :: s_SnmpDebugLog = NULL ;

    if ( m_SnmpDebugTaskObject != NULL )
    {
        ReapTask ( *m_SnmpDebugTaskObject ) ;
        delete m_SnmpDebugTaskObject ;
    }
}

SnmpDebugTaskObject *SnmpDebugThreadObject :: GetTaskObject ()
{
    return m_SnmpDebugTaskObject ;
}

SnmpDebugLog :: SnmpDebugLog ( 

    const TCHAR *a_DebugComponent 

) : m_Logging ( FALSE ) ,
    m_DebugLevel ( 0 ) ,
    m_DebugFileSize ( DEFAULT_FILE_SIZE ),
    m_DebugContext ( SnmpDebugContext :: FILE ) ,
    m_DebugFile ( NULL ) ,
    m_DebugFileUnexpandedName ( NULL ) ,
    m_DebugFileHandle (  INVALID_HANDLE_VALUE ) ,
    m_DebugComponent ( NULL ) 
{
    EnterCriticalSection ( &g_SnmpDebugLogMapCriticalSection ) ;
    m_CriticalSection.Lock () ;

    g_SnmpDebugLogMap [ this ] = this ;

    if ( a_DebugComponent )
    {
        m_DebugComponent = _tcsdup ( a_DebugComponent ) ;
    }

    LoadRegistry () ;
    SetRegistry () ;

    m_CriticalSection.Unlock () ;
    LeaveCriticalSection ( &g_SnmpDebugLogMapCriticalSection ) ;
}

SnmpDebugLog :: ~SnmpDebugLog ()
{
    EnterCriticalSection ( &g_SnmpDebugLogMapCriticalSection ) ;
    m_CriticalSection.Lock () ;

    g_SnmpDebugLogMap.RemoveKey ( this ) ;

    CloseOutput () ;

    if (m_DebugComponent)
    {
        free ( m_DebugComponent ) ;
    }

    if (m_DebugFile)
    {
        free ( m_DebugFile ) ;
    }

    if (m_DebugFileUnexpandedName)
    {
        free ( m_DebugFileUnexpandedName ) ;
    }

    m_CriticalSection.Unlock () ;
    LeaveCriticalSection ( &g_SnmpDebugLogMapCriticalSection ) ;
}

void SnmpDebugLog :: SetDefaultFile ( )
{
    HKEY hkey;

    LONG result =  RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                LOGGING_DIR_KEY, 0, KEY_READ, &hkey);

    if (result == ERROR_SUCCESS)
    {
        TCHAR t_path [MAX_PATH + 1];
        DWORD t_ValueType = REG_SZ;
        DWORD t_ValueLength = MAX_PATH + 1;

        result = RegQueryValueEx( 
            hkey , 
            LOGGING_DIR_VALUE , 
            0, 
            &t_ValueType ,
            ( LPBYTE ) t_path , 
            &t_ValueLength 
        ) ;

        if ((result == ERROR_SUCCESS) && (t_ValueType == REG_SZ))
        {
            _tcscat(t_path, BACKSLASH_STRING);
            _tcscat(t_path, m_DebugComponent);
            _tcscat(t_path, DEFAULT_FILE_EXT);
            SetFile (t_path);
			SetExpandedFile(t_path);
        }

        RegCloseKey(hkey);
    }

    if (m_DebugFileUnexpandedName == NULL)
    {
        TCHAR path[MAX_PATH + 1];
        _stprintf(path, _T("%s%s%s"), DEFAULT_PATH, m_DebugComponent, DEFAULT_FILE_EXT);
        SetFile (path);
		SetExpandedFile(path);
    }
}

void SnmpDebugLog :: SwapFileOver()
{
    Flush();
    CloseOutput();

    //prepend a character to the log file name
    TCHAR* buff = new TCHAR[_tcslen(m_DebugFile) + 2];

    //find the last occurrence of \ for dir
    TCHAR* tmp = _tcsrchr(m_DebugFile, '\\');

    if (tmp != NULL)
    {
        tmp++;
        _tcsncpy(buff, m_DebugFile, _tcslen(m_DebugFile) - _tcslen(tmp));
        buff[_tcslen(m_DebugFile) - _tcslen(tmp)] = _T('\0');
        _tcscat(buff, _T("~"));
        _tcscat(buff, tmp);
    }
    else
    {
        _tcscpy(buff, _T("~"));
        _tcscat(buff, m_DebugFile);
    }

	BOOL bOpen = MoveFileEx(m_DebugFile, buff, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);

    //move the file and reopen...
    if (!bOpen)
    {
#if 0
        DWORD x = GetLastError();
        wchar_t* buff2;

        if (0 == FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL, x, 0, (LPWSTR) &buff2, 80, NULL))
        {
            DWORD dwErr = GetLastError();
        }
        else
        {
            LocalFree(buff2);
        }
#endif
        //try deleting the file and then moving it
        DeleteFile(buff);
        MoveFileEx(m_DebugFile, buff, MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
		bOpen = DeleteFile(m_DebugFile);

    }

	if (bOpen)
	{
		//open file only if move file worked...
		OpenOutput();
	}

    delete [] buff;
}

void SnmpDebugLog :: WriteOutput ( const TCHAR *a_OutputDebugString )
{
    switch ( m_DebugContext )
    {
        case FILE:
        {
            if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
            {
                CloseOutput();
                OpenOutput();
            }

            if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
            {
                DWORD dwToWrite = sizeof ( TCHAR ) * ( _tcslen ( a_OutputDebugString ) );
                LPCVOID thisWrite = ( LPCVOID ) a_OutputDebugString;
                BOOL t_Status = TRUE;

                while ((dwToWrite != 0) && (t_Status))
                {
                    DWORD dwSize;
                    dwSize = SetFilePointer ( m_DebugFileHandle , 0 , NULL , FILE_END ); 

                    //if the file is too big swap it...
#ifdef _UNICODE
                    //only whole (2byte) characters written to file
                    if ((m_DebugFileSize > 0) && (dwSize >= (m_DebugFileSize - 1)))
#else
                    if ((m_DebugFileSize > 0) && (dwSize >= m_DebugFileSize))
#endif
                    {
                        SwapFileOver();

                        if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
                        {
                            break;
                        }

                        if (m_DebugFileSize > 0)
                        {
                            dwSize = SetFilePointer ( m_DebugFileHandle , 0 , NULL , FILE_END );  
                        }
                    }

                    if (dwSize ==  0xFFFFFFFF)
                    {
                        break;
                    }

                    DWORD t_BytesWritten = 0 ;
                    DWORD dwThisWrite;

                    if ((m_DebugFileSize > 0) && (dwToWrite + dwSize > m_DebugFileSize))
                    {
                        dwThisWrite = m_DebugFileSize - dwSize;
#ifdef _UNICODE
                        if ((dwThisWrite > 1) && (dwThisWrite%2))
                        {
                            dwThisWrite--;
                        }
#endif
                    }
                    else
                    {
                        dwThisWrite = dwToWrite;
                    }

                    LockFile(m_DebugFileHandle, dwSize, 0, dwSize + dwThisWrite, 0); 
                    t_Status = WriteFile ( 
            
                        m_DebugFileHandle ,
                        thisWrite ,
                        dwThisWrite ,
                        & t_BytesWritten ,
                        NULL 
                    ) ;
                    UnlockFile(m_DebugFileHandle, dwSize, 0, dwSize + dwThisWrite, 0);

                    //get ready for next write...
                    dwToWrite -= t_BytesWritten;
                    thisWrite = (LPCVOID)((UCHAR*)thisWrite + t_BytesWritten);
                }
            }
        }
        break ;

        case DEBUG:
        {
            OutputDebugString ( a_OutputDebugString ) ;
        }
        break ;

        default:
        {
        }
        break ;
    }

}

void SnmpDebugLog :: OpenFileForOutput ()
{
    if ( m_DebugFile )
    {
        m_DebugFileHandle = CreateFile (
            
            m_DebugFile ,
            GENERIC_WRITE ,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            NULL ,
            OPEN_EXISTING ,
            FILE_ATTRIBUTE_NORMAL ,
            NULL 
        ) ;

        if ( m_DebugFileHandle == INVALID_HANDLE_VALUE )
        {
            m_DebugFileHandle = CreateFile (

                m_DebugFile ,
                GENERIC_WRITE ,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                NULL ,
                OPEN_ALWAYS ,
                FILE_ATTRIBUTE_NORMAL ,
                NULL 
            ) ;

#ifdef _UNICODE 

            if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
            {
                UCHAR t_UnicodeBytes [ 2 ] ;
                t_UnicodeBytes [ 0 ] = 0xFF ;
                t_UnicodeBytes [ 1 ] = 0xFE ;

                DWORD t_BytesWritten = 0 ;

                LockFile(m_DebugFileHandle, 0, 0, 2, 0); 

                WriteFile ( 
            
                    m_DebugFileHandle ,
                    ( LPCVOID ) & t_UnicodeBytes ,
                    sizeof ( t_UnicodeBytes ) ,
                    & t_BytesWritten ,
                    NULL 
                ) ;

                UnlockFile(m_DebugFileHandle, 0, 0, 2, 0); 
            }
#endif

        }
    }
}

void SnmpDebugLog :: OpenOutput ()
{
    switch ( m_DebugContext )
    {
        case FILE:
        {
            OpenFileForOutput () ;
        }
        break ;

        case DEBUG:
        default:
        {
        }
        break ;
    }
}

void SnmpDebugLog :: FlushOutput ()
{
    switch ( m_DebugContext )
    {
        case FILE:
        {
            if ( m_DebugFileHandle != INVALID_HANDLE_VALUE )
            {
                FlushFileBuffers ( m_DebugFileHandle ) ;
            }
        }
        break ;

        case DEBUG:
        default:
        {
        }
        break ;
    }
}

void SnmpDebugLog :: CloseOutput ()
{
    switch ( m_DebugContext )
    {
        case FILE:
        {
            if ( m_DebugFileHandle != INVALID_HANDLE_VALUE ) 
            {
                CloseHandle ( m_DebugFileHandle ) ;
                m_DebugFileHandle =  INVALID_HANDLE_VALUE ;
            }
        }
        break ;

        case DEBUG:
        default:
        {
        }
        break ;
    }
}


void SnmpDebugLog :: Write ( const TCHAR *a_DebugFormatString , ... )
{
    m_CriticalSection.Lock () ;

    if ( m_Logging )
    {
        TCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;
        va_list t_VarArgList ;

        va_start(t_VarArgList,a_DebugFormatString);
        int t_Length = _vsntprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
        t_OutputDebugString [ t_Length ] = ( TCHAR ) 0 ;
        va_end(t_VarArgList);

        WriteOutput ( t_OutputDebugString ) ;
    }

    m_CriticalSection.Unlock () ;
}

void SnmpDebugLog :: WriteFileAndLine ( const char *a_File , const ULONG a_Line , const TCHAR *a_DebugFormatString , ... )
{
    m_CriticalSection.Lock () ;

    if ( m_Logging )
    {
#ifdef BUILD_WITH_FILE_AND_LINE

        TCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;
        char t_FileLineString [ HALF_MAX_MESSAGE_SIZE ] ;

        _snprintf ( t_FileLineString , HALF_MAX_MESSAGE_SIZE , "\r\n(%s):(%lu):" , a_File , a_Line ) ;
        size_t textLength = mbstowcs ( t_OutputDebugString , t_FileLineString , HALF_MAX_MESSAGE_SIZE  ) ;
        if ( textLength != -1 )
        {
            WriteOutput ( t_OutputDebugString ) ;
        }

        va_list t_VarArgList ;
        va_start(t_VarArgList,a_DebugFormatString);
        int t_Length = _vsntprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
        t_OutputDebugString [ t_Length ] = ( TCHAR ) 0 ;
        va_end(t_VarArgList);

        WriteOutput ( t_OutputDebugString ) ;

#else

        TCHAR t_OutputDebugString [ MAX_MESSAGE_SIZE ] ;
        char t_FileLineString [ HALF_MAX_MESSAGE_SIZE ] ;

        _snprintf ( t_FileLineString , HALF_MAX_MESSAGE_SIZE , "\r\n" ) ;
        size_t textLength = mbstowcs ( t_OutputDebugString , t_FileLineString , HALF_MAX_MESSAGE_SIZE  ) ;
        if ( textLength != -1 )
        {
            WriteOutput ( t_OutputDebugString ) ;
        }

        va_list t_VarArgList ;
        va_start(t_VarArgList,a_DebugFormatString);
        int t_Length = _vsntprintf (t_OutputDebugString , MAX_MESSAGE_SIZE-1 , a_DebugFormatString , t_VarArgList );
        t_OutputDebugString [ t_Length ] = ( TCHAR ) 0 ;
        va_end(t_VarArgList);

        WriteOutput ( t_OutputDebugString ) ;

#endif

    }

    m_CriticalSection.Unlock () ;
}

void SnmpDebugLog :: Flush ()
{
    m_CriticalSection.Lock () ;

    FlushOutput () ;

    m_CriticalSection.Unlock () ;
}

void SnmpDebugLog :: SetLogging ( BOOL a_Logging )
{
    m_CriticalSection.Lock () ;

    m_Logging = a_Logging ;

    m_CriticalSection.Lock () ;
}

void SnmpDebugLog :: SetLevel ( const DWORD &a_DebugLevel ) 
{
    m_CriticalSection.Lock () ;

    m_DebugLevel = a_DebugLevel ;

    m_CriticalSection.Unlock () ;
}

void SnmpDebugLog :: SetContext ( const enum SnmpDebugContext &a_DebugContext ) 
{
    m_CriticalSection.Lock () ;

    m_DebugContext = a_DebugContext ;

    m_CriticalSection.Unlock () ;
}

enum SnmpDebugLog :: SnmpDebugContext SnmpDebugLog :: GetContext () 
{
    m_CriticalSection.Lock () ;

    SnmpDebugContext t_Context = m_DebugContext ;

    m_CriticalSection.Unlock () ;

    return t_Context ;
}

void SnmpDebugLog ::CommitContext ()
{
    m_CriticalSection.Lock () ;

    CloseOutput () ;
    OpenOutput () ;

    m_CriticalSection.Unlock () ;
}

void SnmpDebugLog ::SetFile ( const TCHAR *a_File )
{
    m_CriticalSection.Lock () ;

    if (m_DebugFileUnexpandedName)
    {
        free ( m_DebugFileUnexpandedName ) ;
    }

    m_DebugFileUnexpandedName = _tcsdup ( a_File ) ;

    m_CriticalSection.Unlock () ;
}

void SnmpDebugLog::SetExpandedFile( 
    const TCHAR *a_RawFileName)
{
    m_CriticalSection.Lock () ;

    DWORD dwNumChars = ::ExpandEnvironmentStrings(
        a_RawFileName,
        NULL,
        0);
    
    if(dwNumChars > 0)
    {
        try
        {
            m_DebugFile = new TCHAR[dwNumChars + 1];
            if(m_DebugFile)
            {
                m_DebugFile[dwNumChars] = L'\0';

                if(!::ExpandEnvironmentStrings(
                    a_RawFileName,
                    m_DebugFile,
                    dwNumChars))
                {
                    delete m_DebugFile;
                    m_DebugFile = NULL;
                }
            }
        }
        catch(...)
        {
            m_CriticalSection.Unlock () ;
            throw;
        }
    }

    m_CriticalSection.Unlock () ;   
}

void SnmpDebugLog :: LoadRegistry()
{
    m_CriticalSection.Lock () ;

    LoadRegistry_Logging  () ;
    LoadRegistry_Level () ;
    LoadRegistry_File () ;
    LoadRegistry_Type () ;
    LoadRegistry_FileSize ();
    CommitContext () ;

    m_CriticalSection.Unlock () ;
}

void SnmpDebugLog :: LoadRegistry_Logging ()
{
    HKEY t_LogKey = NULL ;

    LONG t_Status = RegCreateKeyEx (
    
        HKEY_LOCAL_MACHINE, 
        LOG_KEY, 
        0, 
        NULL, 
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
        NULL, 
        &t_LogKey, 
        NULL
    ) ;

    if ( t_Status == ERROR_SUCCESS )
    {
        DWORD t_Logging ;
        DWORD t_ValueType = REG_DWORD ;
        DWORD t_ValueLength = sizeof ( DWORD ) ;
        t_Status = RegQueryValueEx ( 

            t_LogKey , 
            LOGGING_ON , 
            0, 
            &t_ValueType ,
            ( LPBYTE ) &t_Logging , 
            &t_ValueLength 
        ) ;

        if ( t_Status == ERROR_SUCCESS )
        {
            m_Logging = ( t_Logging == 1) ? TRUE : FALSE ;
        }

        RegCloseKey ( t_LogKey ) ;
    }
}

void SnmpDebugLog :: LoadRegistry_FileSize ()
{
    if ( m_DebugComponent )
    {
        TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

            ( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
        ) ;

        if (t_ComponentKeyString == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        _tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
        _tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

        HKEY t_LogKey = NULL ;

        LONG t_Status = RegCreateKeyEx (
        
            HKEY_LOCAL_MACHINE, 
            t_ComponentKeyString, 
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL, 
            &t_LogKey, 
            NULL
        ) ;

        if ( t_Status == ERROR_SUCCESS )
        {
            DWORD t_Size ;
            DWORD t_ValueType = REG_DWORD ;
            DWORD t_ValueLength = sizeof ( DWORD ) ;
            t_Status = RegQueryValueEx( 

                t_LogKey , 
                LOG_FILE_SIZE , 
                0, 
                &t_ValueType ,
                ( LPBYTE ) &t_Size , 
                &t_ValueLength 
            ) ;

            if ( t_Status == ERROR_SUCCESS )
            {
                m_DebugFileSize = t_Size ;

                if (m_DebugFileSize < MIN_FILE_SIZE)
                {
                    m_DebugFileSize = MIN_FILE_SIZE ;
                }
            }

            RegCloseKey ( t_LogKey ) ;
        }

        free ( t_ComponentKeyString ) ;
    }
}

void SnmpDebugLog :: LoadRegistry_Level ()
{
    if ( m_DebugComponent )
    {
        TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

            ( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
        ) ;

        if (t_ComponentKeyString == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        _tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
        _tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

        HKEY t_LogKey = NULL ;

        LONG t_Status = RegCreateKeyEx (
        
            HKEY_LOCAL_MACHINE, 
            t_ComponentKeyString, 
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL, 
            &t_LogKey, 
            NULL
        ) ;

        if ( t_Status == ERROR_SUCCESS )
        {
            DWORD t_Level ;
            DWORD t_ValueType = REG_DWORD ;
            DWORD t_ValueLength = sizeof ( DWORD ) ;
            t_Status = RegQueryValueEx( 

                t_LogKey , 
                LOG_LEVEL_NAME , 
                0, 
                &t_ValueType ,
                ( LPBYTE ) &t_Level , 
                &t_ValueLength 
            ) ;

            if ( t_Status == ERROR_SUCCESS )
            {
                m_DebugLevel = t_Level ;
            }

            RegCloseKey ( t_LogKey ) ;
        }

        free ( t_ComponentKeyString ) ;
    }
}

void SnmpDebugLog :: LoadRegistry_File ()
{
    if ( m_DebugComponent )
    {
        TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

            ( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
        ) ;

        if (t_ComponentKeyString == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        _tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
        _tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

        HKEY t_LogKey = NULL ;

        LONG t_Status = RegCreateKeyEx (
        
            HKEY_LOCAL_MACHINE, 
            t_ComponentKeyString, 
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL, 
            &t_LogKey, 
            NULL
        ) ;

        if ( t_Status == ERROR_SUCCESS )
        {
            TCHAR *t_File = NULL ;
            DWORD t_ValueType = REG_SZ ;
            DWORD t_ValueLength = 0 ;

            t_Status = RegQueryValueEx( 

                t_LogKey , 
                LOG_FILE_NAME , 
                0, 
                &t_ValueType ,
                ( LPBYTE ) t_File , 
                &t_ValueLength 
            ) ;

            if ( t_Status == ERROR_SUCCESS )
            {
                t_File = new TCHAR [ t_ValueLength ] ;

                t_Status = RegQueryValueEx( 

                    t_LogKey , 
                    LOG_FILE_NAME , 
                    0, 
                    &t_ValueType ,
                    ( LPBYTE ) t_File , 
                    &t_ValueLength 
                ) ;

                if ( (t_Status == ERROR_SUCCESS) && t_File && (*t_File != _TEXT('\0') ) )
                {
                    // Expand the name and store the expanded
                    // name in m_DebugFile.
                    SetExpandedFile(t_File);

                    // Set the unexpanded name in 
                    // m_tstrDebugFileUnexpandedName...
                    SetFile ( t_File ) ;
                }
                else
                {
                    SetDefaultFile();
                }

                delete [] t_File ;
            }
            else
            {
                SetDefaultFile();
            }

            RegCloseKey ( t_LogKey ) ;
        }

        free ( t_ComponentKeyString ) ;
    }
}

void SnmpDebugLog :: LoadRegistry_Type ()
{
    if ( m_DebugComponent )
    {
        TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

            ( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
        ) ;

        if (t_ComponentKeyString == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        _tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
        _tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

        HKEY t_LogKey = NULL ;

        LONG t_Status = RegCreateKeyEx (
        
            HKEY_LOCAL_MACHINE, 
            t_ComponentKeyString, 
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL, 
            &t_LogKey, 
            NULL
        ) ;

        if ( t_Status == ERROR_SUCCESS )
        {
            TCHAR *t_Type = NULL ;
            DWORD t_ValueType = REG_SZ ;
            DWORD t_ValueLength = 0 ;

            t_Status = RegQueryValueEx( 

                t_LogKey , 
                LOG_TYPE_NAME , 
                0, 
                &t_ValueType ,
                ( LPBYTE ) t_Type , 
                &t_ValueLength 
            ) ;

            if ( t_Status == ERROR_SUCCESS )
            {
                t_Type = new TCHAR [ t_ValueLength ] ;

                t_Status = RegQueryValueEx( 

                    t_LogKey , 
                    LOG_TYPE_NAME , 
                    0, 
                    &t_ValueType ,
                    ( LPBYTE ) t_Type , 
                    &t_ValueLength 
                ) ;

                if ( t_Status == ERROR_SUCCESS )
                {
                    if ( _tcscmp ( t_Type , _T("Debugger") ) == 0 )
                    {
                        SetContext ( DEBUG ) ;
                    }
                    else
                    {
                        SetContext ( FILE ) ;
                    }
                }

                delete [] t_Type;
            }

            RegCloseKey ( t_LogKey ) ;
        }

        free ( t_ComponentKeyString ) ;
    }
}

void SnmpDebugLog :: SetRegistry()
{
    m_CriticalSection.Lock () ;

    SetRegistry_Logging  () ;
    SetRegistry_Level () ;
    SetRegistry_File () ;
    SetRegistry_FileSize () ;
    SetRegistry_Type () ;

    m_CriticalSection.Unlock () ;
}

void SnmpDebugLog :: SetRegistry_Logging ()
{
    HKEY t_LogKey = NULL ;

    LONG t_Status = RegCreateKeyEx (
    
        HKEY_LOCAL_MACHINE, 
        LOG_KEY, 
        0, 
        NULL, 
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
        NULL, 
        &t_LogKey, 
        NULL
    ) ;
            
    if ( t_Status == ERROR_SUCCESS )
    {
        DWORD t_Logging = m_Logging ;
        DWORD t_ValueType = REG_DWORD ;
        DWORD t_ValueLength = sizeof ( DWORD ) ;

        t_Status = RegSetValueEx ( 

            t_LogKey , 
            LOGGING_ON , 
            0, 
            t_ValueType ,
            ( LPBYTE ) &t_Logging , 
            t_ValueLength 
        ) ;

        RegCloseKey ( t_LogKey ) ;
    }
}

void SnmpDebugLog :: SetRegistry_FileSize ()
{
    if ( m_DebugComponent )
    {
        TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

            ( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
        ) ;

        if (t_ComponentKeyString == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        _tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
        _tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

        HKEY t_LogKey = NULL ;

        LONG t_Status = RegCreateKeyEx (
        
            HKEY_LOCAL_MACHINE, 
            t_ComponentKeyString, 
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL, 
            &t_LogKey, 
            NULL
        ) ;

        if ( t_Status == ERROR_SUCCESS )
        {
            DWORD t_Level = m_DebugFileSize ;
            DWORD t_ValueType = REG_DWORD ;
            DWORD t_ValueLength = sizeof ( DWORD ) ;
            t_Status = RegSetValueEx( 

                t_LogKey , 
                LOG_FILE_SIZE , 
                0, 
                t_ValueType ,
                ( LPBYTE ) &t_Level , 
                t_ValueLength 
            ) ;

            RegCloseKey ( t_LogKey ) ;
        }

        free ( t_ComponentKeyString ) ;
    }
}

void SnmpDebugLog :: SetRegistry_Level ()
{
    if ( m_DebugComponent )
    {
        TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

            ( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
        ) ;

        if (t_ComponentKeyString == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        _tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
        _tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

        HKEY t_LogKey = NULL ;

        LONG t_Status = RegCreateKeyEx (
        
            HKEY_LOCAL_MACHINE, 
            t_ComponentKeyString, 
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL, 
            &t_LogKey, 
            NULL
        ) ;

        if ( t_Status == ERROR_SUCCESS )
        {
            DWORD t_Level = m_DebugLevel ;
            DWORD t_ValueType = REG_DWORD ;
            DWORD t_ValueLength = sizeof ( DWORD ) ;
            t_Status = RegSetValueEx( 

                t_LogKey , 
                LOG_LEVEL_NAME , 
                0, 
                t_ValueType ,
                ( LPBYTE ) &t_Level , 
                t_ValueLength 
            ) ;

            RegCloseKey ( t_LogKey ) ;
        }

        free ( t_ComponentKeyString ) ;
    }
}

void SnmpDebugLog :: SetRegistry_File ()
{
    if ( m_DebugComponent )
    {
        TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

            ( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
        ) ;

        if (t_ComponentKeyString == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        _tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
        _tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

        HKEY t_LogKey = NULL ;

        LONG t_Status = RegCreateKeyEx (
        
            HKEY_LOCAL_MACHINE, 
            t_ComponentKeyString, 
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL, 
            &t_LogKey, 
            NULL
        ) ;

        if ( t_Status == ERROR_SUCCESS )
        {
            if ( m_DebugFileUnexpandedName )
            {
                TCHAR *t_File = m_DebugFileUnexpandedName ;
                DWORD t_ValueType = REG_SZ ;
                DWORD t_ValueLength = ( _tcslen ( t_File ) + 1 ) * sizeof ( TCHAR ) ;

                t_Status = RegSetValueEx( 

                    t_LogKey , 
                    LOG_FILE_NAME , 
                    0, 
                    t_ValueType ,
                    ( LPBYTE ) t_File , 
                    t_ValueLength 
                ) ;
            }

            RegCloseKey ( t_LogKey ) ;
        }

        free ( t_ComponentKeyString ) ;
    }
}

void SnmpDebugLog :: SetRegistry_Type ()
{
    if ( m_DebugComponent )
    {
        TCHAR *t_ComponentKeyString = ( TCHAR * ) malloc ( 

            ( _tcslen ( LOG_KEY_SLASH ) + _tcslen ( m_DebugComponent ) + 1 ) * sizeof ( TCHAR ) 
        ) ;

        if (t_ComponentKeyString == NULL)
        {
            throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
        }

        _tcscpy ( t_ComponentKeyString , LOG_KEY_SLASH ) ;
        _tcscat ( t_ComponentKeyString , m_DebugComponent ) ;

        HKEY t_LogKey = NULL ;

        LONG t_Status = RegCreateKeyEx (
        
            HKEY_LOCAL_MACHINE, 
            t_ComponentKeyString, 
            0, 
            NULL, 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 
            NULL, 
            &t_LogKey, 
            NULL
        ) ;

        if ( t_Status == ERROR_SUCCESS )
        {
            TCHAR *t_Debugger = _T("Debugger") ;
            TCHAR *t_File = _T("File") ;
            TCHAR *t_Type = ( m_DebugContext == DEBUG ) ? t_Debugger : t_File ; 
            DWORD t_ValueType = REG_SZ ;
            DWORD t_ValueLength = ( _tcslen ( t_Type ) + 1 ) * sizeof ( TCHAR ) ;

            t_Status = RegSetValueEx( 

                t_LogKey , 
                LOG_TYPE_NAME , 
                0, 
                t_ValueType ,
                ( LPBYTE ) t_Type , 
                t_ValueLength 
            ) ;

            RegCloseKey ( t_LogKey ) ;
        }

        free ( t_ComponentKeyString ) ;
    }
}

void SnmpDebugLog :: SetEventNotification ()
{
    g_SnmpDebugLogThread->GetTaskObject ()->SetRegistryNotification () ;
}

BOOL SnmpDebugLog :: Startup ()
{
    EnterCriticalSection ( &s_CriticalSection ) ;
    s_ReferenceCount++ ;

    if ( ! s_Initialised )
    {
        SnmpThreadObject::Startup();
        g_SnmpDebugLogThread = new SnmpDebugThreadObject ( "SnmpDebugLogThread" ) ;
		g_SnmpDebugLogThread->BeginThread () ;
        g_SnmpDebugLogThread->WaitForStartup () ;
        SetEventNotification () ;
        s_Initialised = TRUE ;
    }

    LeaveCriticalSection ( &s_CriticalSection ) ;

    return TRUE ;
}

void SnmpDebugLog :: Closedown ()
{
    EnterCriticalSection ( &s_CriticalSection ) ;
    s_ReferenceCount--;

    if ( s_ReferenceCount == 0 ) 
    {
        g_SnmpDebugLogThread->SignalThreadShutdown() ;
        s_Initialised = FALSE ;
        SnmpThreadObject::Closedown();
    }

    LeaveCriticalSection ( &s_CriticalSection ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\include\snmplog.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __SNMPLOG_H
#define __SNMPLOG_H

#ifdef SNMPDEBUG_INIT
class __declspec ( dllexport ) SnmpDebugLog
#else
class __declspec ( dllimport ) SnmpDebugLog
#endif
{
public:

	enum SnmpDebugContext
	{
		FILE = 0 ,
		DEBUG = 1 
	} ;

private:

	CCriticalSection m_CriticalSection ;

	static long s_ReferenceCount ;
	enum SnmpDebugContext m_DebugContext ;
	BOOL m_Logging ;
	DWORD m_DebugLevel ;
	DWORD m_DebugFileSize;
	TCHAR *m_DebugComponent ;
	TCHAR *m_DebugFile ;
    TCHAR *m_DebugFileUnexpandedName;
	HANDLE m_DebugFileHandle ;
	static BOOL s_Initialised ;

	static void SetEventNotification () ;

	void LoadRegistry_Logging  () ;
	void LoadRegistry_Level () ;
	void LoadRegistry_File () ;
	void LoadRegistry_FileSize () ;
	void LoadRegistry_Type () ;

	void SetRegistry_Logging  () ;
	void SetRegistry_Level () ;
	void SetRegistry_File () ;
	void SetRegistry_FileSize () ;
	void SetRegistry_Type () ;
	void SetDefaultFile () ;

	void OpenFileForOutput () ;
	void OpenOutput () ;
	void CloseOutput () ;
	void FlushOutput () ;
	void SwapFileOver () ;
	void WriteOutput ( const TCHAR *a_DebugOutput ) ;

protected:
public:

	SnmpDebugLog ( const TCHAR *a_DebugComponent ) ;
	~SnmpDebugLog () ;

	void Write ( const TCHAR *a_DebugFormatString , ... ) ;
	void WriteFileAndLine ( const char *a_File , const ULONG a_Line , const TCHAR *a_DebugFormatString , ... ) ;
	void Flush () ;

	void LoadRegistry () ;
	void SetRegistry () ;

	void SetLevel ( const DWORD &a_DebugLevel ) ;
	DWORD GetLevel () ;

	void SetContext ( const enum SnmpDebugContext &a_DebugContext ) ;
	enum SnmpDebugContext GetContext () ;

	void SetFile ( const TCHAR *a_File ) ;
    void SetExpandedFile( const TCHAR *a_RawFileName);
	TCHAR *GetFile () ;

	void SetLogging ( BOOL a_Logging = TRUE ) ;
	BOOL GetLogging () ;

	void CommitContext () ;

	static SnmpDebugLog *s_SnmpDebugLog ;

	static BOOL Startup () ;
	static void Closedown () ;

public:

	static CRITICAL_SECTION s_CriticalSection ;
} ;

inline DWORD SnmpDebugLog :: GetLevel ()
{
	m_CriticalSection.Lock () ;
	DWORD t_Level = m_DebugLevel ;
	m_CriticalSection.Unlock () ;
	return t_Level ;
}

inline TCHAR *SnmpDebugLog :: GetFile ()
{
	m_CriticalSection.Lock () ;
	TCHAR *t_File = m_DebugFile ;
	m_CriticalSection.Unlock () ;

	return t_File ;
}

inline BOOL SnmpDebugLog :: GetLogging () 
{
	return m_Logging ;
}

#define DebugMacro(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && SnmpDebugLog :: s_SnmpDebugLog->GetLogging () ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro0(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && SnmpDebugLog :: s_SnmpDebugLog->GetLogging () && ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () & 1 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro1(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && SnmpDebugLog :: s_SnmpDebugLog->GetLogging () && ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () & 2 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro2(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && SnmpDebugLog :: s_SnmpDebugLog->GetLogging () && ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () & 4 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro3(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && SnmpDebugLog :: s_SnmpDebugLog->GetLogging () && ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () & 8 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro4(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && SnmpDebugLog :: s_SnmpDebugLog->GetLogging () && ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () & 16 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro5(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && SnmpDebugLog :: s_SnmpDebugLog->GetLogging () && ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () & 32 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro6(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && SnmpDebugLog :: s_SnmpDebugLog->GetLogging () && ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () & 64 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro7(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && ( SnmpDebugLog :: s_SnmpDebugLog->GetLogging () ) && ( ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () ) & 128 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro8(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && ( SnmpDebugLog :: s_SnmpDebugLog->GetLogging () ) && ( ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () ) & 256 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro9(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && ( SnmpDebugLog :: s_SnmpDebugLog->GetLogging () ) && ( ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () ) & 512 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro10(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && ( SnmpDebugLog :: s_SnmpDebugLog->GetLogging () ) && ( ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () ) & 1024 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro11(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && ( SnmpDebugLog :: s_SnmpDebugLog->GetLogging () ) && ( ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () ) & 2048 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro12(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && ( SnmpDebugLog :: s_SnmpDebugLog->GetLogging () ) && ( ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () ) & 4096 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro13(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && ( SnmpDebugLog :: s_SnmpDebugLog->GetLogging () ) && ( ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () ) & 8192 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro14(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && ( SnmpDebugLog :: s_SnmpDebugLog->GetLogging () ) && ( ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () ) & 16384 ) ) \
	{ \
		{a ; } \
	} \
} 

#define DebugMacro15(a) { \
\
	if ( SnmpDebugLog :: s_SnmpDebugLog && ( SnmpDebugLog :: s_SnmpDebugLog->GetLogging () ) && ( ( SnmpDebugLog :: s_SnmpDebugLog->GetLevel () ) & 32768 ) ) \
	{ \
		{a ; } \
	} \
} 

#endif __SNMPLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\include\snmpthrd.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __SNMPTHREAD_SNMPTHRD_H__
#define __SNMPTHREAD_SNMPTHRD_H__

class SnmpAbstractTaskObject ;

#ifdef SNMPTHRD_INIT
class __declspec ( dllexport ) SnmpThreadObject : private SnmpEventObject
#else
class __declspec ( dllimport ) SnmpThreadObject : private SnmpEventObject
#endif
{
friend SnmpAbstractTaskObject ;
friend BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
) ;

private:

	static LONG s_ReferenceCount ;

// Mutual exclusion mechanism

	static CCriticalSection s_Lock ;

	SnmpMap <HANDLE,HANDLE,SnmpEventObject *,SnmpEventObject *> m_ScheduleReapEventContainer ;

// Thread Name

	char *m_ThreadName ;

// Terminate thread event

	SnmpEventObject m_ThreadTerminateEvent ;

// TaskObject created if a PostSignalThreadShutdown is called
	SnmpAbstractTaskObject* m_pShutdownTask ;
	
// thread information

	ULONG m_ThreadId ;
	HANDLE m_ThreadHandle ;
	DWORD m_timeout;

// list of task objects associated with thread object

	SnmpQueue <SnmpAbstractTaskObject *,SnmpAbstractTaskObject *> m_TaskContainer ;

	void RotateTask ( SnmpAbstractTaskObject *a_TaskObject ) ;

// Evict thread from process

	void TerminateThread () ;

// Attach thread to global list of threads

	BOOL RegisterThread () ;

private:

// global list of thread objects keyed on thread identifier

	static SnmpMap <DWORD,DWORD,SnmpThreadObject *,SnmpThreadObject *> s_ThreadContainer ;

	HANDLE *m_EventContainer ;
	ULONG m_EventContainerLength ;

	HANDLE *GetEventHandles () ;
	ULONG GetEventHandlesSize () ;

	void ConstructEventContainer () ;

	void Process () ;
	BOOL Wait () ;

	SnmpAbstractTaskObject *GetTaskObject ( HANDLE &eventHandle ) ;

	BOOL WaitDispatch ( ULONG t_HandleIndex , BOOL &a_Terminated ) ;

private:

// Thread entry point

	static void __cdecl ThreadExecutionProcedure ( void *threadParameter ) ;

// Attach Process

	static void ProcessAttach () ;

// Detach Process

	static void ProcessDetach ( BOOL a_ProcessDetaching = FALSE ) ;

	HANDLE *GetThreadHandleReference () { return &m_ThreadHandle ; }

protected:
public:

	SnmpThreadObject ( const char *a_ThreadName = NULL, DWORD a_timeout = INFINITE ) ;
	virtual ~SnmpThreadObject () ;

	void BeginThread () ;

	void WaitForStartup () ;

	void SignalThreadShutdown () ;
	void PostSignalThreadShutdown () ;

// Get thread information

	ULONG GetThreadId () { return m_ThreadId ; }
	HANDLE GetThreadHandle () { return m_ThreadHandle ; }

	BOOL ScheduleTask ( SnmpAbstractTaskObject &a_TaskObject ) ;
	BOOL ReapTask ( SnmpAbstractTaskObject &a_TaskObject ) ;

	virtual void Initialise () {} ;
	virtual void Uninitialise () {} ;
	virtual void TimedOut() {} ;

// Get Thread object associated with current thread

	static SnmpThreadObject *GetThreadObject () ;

	static BOOL Startup () ;
	static void Closedown() ;

} ;

#ifdef SNMPTHRD_INIT
class __declspec ( dllexport ) SnmpAbstractTaskObject 
#else
class __declspec ( dllimport ) SnmpAbstractTaskObject 
#endif
{
friend SnmpThreadObject ;
private:

// list of thread objects keyed on thread identifier

	SnmpMap <DWORD,DWORD,SnmpThreadObject *,SnmpThreadObject *> m_ThreadContainer ;
	CCriticalSection m_Lock ;

	SnmpEventObject m_CompletionEvent ;
	SnmpEventObject m_AcknowledgementEvent ;
	HANDLE m_ScheduledHandle;
	DWORD m_timeout;

	BOOL WaitDispatch ( SnmpThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed ) ;
	BOOL WaitAcknowledgementDispatch ( SnmpThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed ) ;

	void AttachTaskToThread ( SnmpThreadObject &a_ThreadObject ) ;
	void DetachTaskFromThread ( SnmpThreadObject &a_ThreadObject ) ;

protected:

	SnmpAbstractTaskObject ( 

		const wchar_t *a_GlobalTaskNameComplete = NULL, 
		const wchar_t *a_GlobalTaskNameAcknowledgement = NULL, 
		DWORD a_timeout = INFINITE

	) ;

	virtual HANDLE GetHandle() = 0;

public:

	virtual ~SnmpAbstractTaskObject () ;

	virtual void Process () { Complete () ; }
	virtual void Exec () {} ;
	virtual void Complete () { m_CompletionEvent.Set () ; }
	virtual BOOL Wait ( BOOL a_Dispatch = FALSE ) ;
	virtual void Acknowledge () { m_AcknowledgementEvent.Set () ; } 
	virtual BOOL WaitAcknowledgement ( BOOL a_Dispatch = FALSE ) ;
	virtual void TimedOut() {} ;
} ;

#ifdef SNMPTHRD_INIT
class __declspec ( dllexport ) SnmpTaskObject : public SnmpAbstractTaskObject 
#else
class __declspec ( dllimport ) SnmpTaskObject : public SnmpAbstractTaskObject 
#endif
{
private:
	SnmpEventObject m_Event;
protected:
public:

	SnmpTaskObject ( 

		const wchar_t *a_GlobalTaskNameStart = NULL , 
		const wchar_t *a_GlobalTaskNameComplete = NULL,
		const wchar_t *a_GlobalTaskNameAcknowledgement = NULL, 
		DWORD a_timeout = INFINITE

	) ;

	~SnmpTaskObject () {} ;
	void Exec () { m_Event.Set(); }
	HANDLE GetHandle () { return m_Event.GetHandle() ; }
} ;

#endif //__SNMPTHREAD_SNMPTHRD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\snmpthrd.cpp ===
//***************************************************************************

//

//  File:   

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <snmpcont.h>
#include "snmpevt.h"
#include "snmpthrd.h"
#include "snmplog.h"


CCriticalSection SnmpThreadObject :: s_Lock ;

LONG SnmpThreadObject :: s_ReferenceCount = 0 ;

SnmpMap <DWORD,DWORD,SnmpThreadObject *,SnmpThreadObject *> SnmpThreadObject :: s_ThreadContainer ;

class SnmpShutdownTaskObject : public SnmpTaskObject
{
private:

    SnmpThreadObject* m_ThreadToShutdown ;

protected:
public:

    SnmpShutdownTaskObject (SnmpThreadObject* threadToShutdown) ;

    void Process () ;

} ;

SnmpShutdownTaskObject :: SnmpShutdownTaskObject (SnmpThreadObject* threadToShutdown) 
: m_ThreadToShutdown ( threadToShutdown )
{
}

void SnmpShutdownTaskObject ::Process()
{
    if (m_ThreadToShutdown)
    {
        m_ThreadToShutdown->SignalThreadShutdown();
    }

    Complete();
}


BOOL SnmpThreadObject :: Startup ()
{
    InterlockedIncrement ( & s_ReferenceCount ) ;

    return TRUE ;
}

void SnmpThreadObject :: Closedown()
{
    if ( InterlockedDecrement ( & s_ReferenceCount ) <= 0 )
        ProcessDetach () ;
}

void SnmpThreadObject :: ProcessAttach () 
{ 
}

void SnmpThreadObject :: ProcessDetach ( BOOL a_ProcessDetaching )
{
	// delete all known thread objects 
    s_Lock.Lock () ;

    POSITION t_Position = s_ThreadContainer.GetStartPosition () ;
    while ( t_Position )
    {
        DWORD t_EventId ;
        SnmpThreadObject *t_ThreadObject ;
        s_ThreadContainer.GetNextAssoc ( t_Position , t_EventId , t_ThreadObject ) ;

        s_Lock.Unlock () ;

        t_ThreadObject->SignalThreadShutdown () ;

        s_Lock.Lock () ;

        t_Position = s_ThreadContainer.GetStartPosition () ;
    }

    s_ThreadContainer.RemoveAll () ;
    s_Lock.Unlock () ;
}

void __cdecl SnmpThreadObject :: ThreadExecutionProcedure ( void *a_ThreadParameter )
{
    SetStructuredExceptionHandler seh;

    try
    {
        SnmpThreadObject *t_ThreadObject = ( SnmpThreadObject * ) a_ThreadParameter ;

        t_ThreadObject->RegisterThread () ;
        t_ThreadObject->Initialise () ;

DebugMacro8(

        SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Thread beginning dispatch" ) ;
)

        if ( t_ThreadObject->Wait () )
        {
        }
        else 
        {
        }

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Thread completed dispatch" ) ;
)

        t_ThreadObject->Uninitialise () ;

DebugMacro8(

        SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Thread terminating" ) ;
)
    }
    catch(Structured_Exception e_SE)
    {
        return;
    }
    catch(Heap_Exception e_HE)
    {
        return;
    }
    catch(...)
    {
        return;
    }
}

void SnmpThreadObject :: TerminateThread () 
{
    :: TerminateThread (m_ThreadHandle,0) ;
}

SnmpThreadObject :: SnmpThreadObject (
    
    const char *a_ThreadName,
    DWORD a_timeout
    
) : m_EventContainer ( NULL ) , 
    m_EventContainerLength ( 0 ) , 
    m_ThreadId ( 0 ) , 
    m_ThreadHandle ( 0 ) ,
    m_ThreadName ( NULL ) ,
    m_timeout ( a_timeout ),
    m_pShutdownTask ( NULL )
{
    if ( a_ThreadName )
    {
        m_ThreadName = _strdup ( a_ThreadName ) ;
    }

    ConstructEventContainer () ;

}

void  SnmpThreadObject :: BeginThread()
{
    DWORD t_PseudoHandle = _beginthread ( 

        SnmpThreadObject :: ThreadExecutionProcedure , 
        0 , 
        ( void * ) this
     ) ;
}

void SnmpThreadObject :: WaitForStartup ()
{
    SnmpTaskObject t_TaskObject ;
    ScheduleTask ( t_TaskObject ) ;
    t_TaskObject.Exec () ;
    t_TaskObject.Wait () ;
    ReapTask ( t_TaskObject ) ;
}

SnmpThreadObject :: ~SnmpThreadObject ()
{
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Enter Thread destructor" ) ;
)
    if ( ( m_ThreadId != GetCurrentThreadId () ) && ( m_ThreadId != 0 ))
    {
        SignalThreadShutdown () ;
    }

    free ( m_ThreadName ) ;

    POSITION t_Position = m_TaskContainer.GetHeadPosition () ;
    while ( t_Position )
    {
        SnmpAbstractTaskObject *t_TaskObject = m_TaskContainer.GetNext ( t_Position ) ;

        t_TaskObject->DetachTaskFromThread ( *this ) ;
    }

    m_TaskContainer.RemoveAll () ;

    free ( m_EventContainer ) ;

    if ( m_ThreadHandle )
        CloseHandle ( m_ThreadHandle ) ;

    s_Lock.Lock () ;
    s_ThreadContainer.RemoveKey ( m_ThreadId ) ;
    s_Lock.Unlock () ;

    if (m_pShutdownTask != NULL)
    {
        delete m_pShutdownTask;
    }

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Exit Thread destructor" ) ;
)

}

void SnmpThreadObject :: PostSignalThreadShutdown ()
{
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Posting thread shutdown" ) ;
)

    if (m_pShutdownTask != NULL)
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Thread shutdown previously posted" ) ;
)
    }
    else
    {
        m_pShutdownTask = new SnmpShutdownTaskObject(this);
        ScheduleTask(*m_pShutdownTask);
        m_pShutdownTask->Exec();
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n Thread shutdown posted" ) ;
)
    }
}


void SnmpThreadObject :: SignalThreadShutdown ()
{
    s_Lock.Lock () ;
    BOOL t_bRemoved = s_ThreadContainer.RemoveKey ( m_ThreadId ) ;
    s_Lock.Unlock () ;

    if (t_bRemoved)
    {
        if ( m_ThreadId == GetCurrentThreadId () )
        {
            m_ThreadTerminateEvent.Set () ;
        }
        else
        {
            HANDLE t_ProcessHandle = GetCurrentProcess ();
            HANDLE t_Handle = NULL ;

            BOOL t_Status = DuplicateHandle ( 

                t_ProcessHandle ,
                m_ThreadHandle ,
                t_ProcessHandle ,
                & t_Handle ,
                0 ,
                FALSE ,
                DUPLICATE_SAME_ACCESS
            ) ;

            if ( t_Status ) 
            {
                m_ThreadTerminateEvent.Set () ;

                DWORD t_Event = WaitForSingleObject (

                    t_Handle ,
                    INFINITE 
                ) ;

                CloseHandle ( t_Handle ) ;
            }
        }
    }
}

void SnmpThreadObject :: ConstructEventContainer ()
{
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Constructing Container" , m_ThreadName ) ;
)

    s_Lock.Lock () ;

    if ((m_TaskContainer.GetCount() + 2) <  MAXIMUM_WAIT_OBJECTS)
    {
        m_EventContainerLength = m_TaskContainer.GetCount () + 2;
    }
    else
    {
        m_EventContainerLength = MAXIMUM_WAIT_OBJECTS - 1;
    }

    m_EventContainer = ( HANDLE * ) realloc ( m_EventContainer , sizeof ( HANDLE ) * m_EventContainerLength ) ;

    if (m_EventContainer == NULL)
    {
        s_Lock.Unlock () ;
        throw Heap_Exception(Heap_Exception::HEAP_ERROR::E_ALLOCATION_ERROR);
    }

    m_EventContainer [ 0 ] = GetHandle () ;
    m_EventContainer [ 1 ] = m_ThreadTerminateEvent.GetHandle () ;

    ULONG t_EventIndex = 2 ;
    POSITION t_Position = m_TaskContainer.GetHeadPosition () ;
    while ( t_Position && (t_EventIndex < m_EventContainerLength))
    {
        SnmpAbstractTaskObject *t_TaskObject = m_TaskContainer.GetNext ( t_Position ) ;
        m_EventContainer [ t_EventIndex ] = t_TaskObject->GetHandle () ;
        t_EventIndex ++ ;
    }

    s_Lock.Unlock () ;
}

void SnmpThreadObject :: RotateTask ( SnmpAbstractTaskObject *a_TaskObject )
{
    s_Lock.Lock () ;

    POSITION t_Position = m_TaskContainer.GetHeadPosition () ;
    while ( t_Position )
    {
        POSITION t_LastPosition = t_Position ;
        SnmpAbstractTaskObject *t_TaskObject = m_TaskContainer.GetNext ( t_Position ) ;
        if ( a_TaskObject->GetHandle () == t_TaskObject->GetHandle () ) 
        {
            m_TaskContainer.RemoveAt ( t_LastPosition ) ;
            m_TaskContainer.Add ( t_TaskObject ) ;
            break ;
        }
    }

    s_Lock.Unlock () ;
}

SnmpThreadObject *SnmpThreadObject :: GetThreadObject () 
{
    s_Lock.Lock () ;

    DWORD t_CurrentThreadId = GetCurrentThreadId () ;

    SnmpThreadObject *t_ThreadObject ;
    if ( s_ThreadContainer.Lookup ( GetCurrentThreadId () , t_ThreadObject ) )
    {
    }
    else
    {
        t_ThreadObject = NULL ;
    }

    s_Lock.Unlock () ;

    return t_ThreadObject ;
}

SnmpAbstractTaskObject *SnmpThreadObject :: GetTaskObject ( HANDLE &a_Handle )
{
    s_Lock.Lock () ;

    POSITION t_Position = m_TaskContainer.GetHeadPosition () ;
    while ( t_Position )
    {
        SnmpAbstractTaskObject *t_TaskObject = m_TaskContainer.GetNext ( t_Position ) ;
        if ( t_TaskObject->GetHandle () == a_Handle ) 
        {
            s_Lock.Unlock () ;
            return t_TaskObject ;
        }
    }

    s_Lock.Unlock () ;

    return NULL ;
}

BOOL SnmpThreadObject :: RegisterThread () 
{
    s_Lock.Lock () ;

    m_ThreadId = GetCurrentThreadId () ;
    s_ThreadContainer [ m_ThreadId ] = this ;

    BOOL t_Status = DuplicateHandle ( 

        GetCurrentProcess () ,
        GetCurrentThread ()  ,
        GetCurrentProcess () ,
        GetThreadHandleReference () ,
        0 ,
        TRUE ,
        DUPLICATE_SAME_ACCESS
    ) ;

    s_Lock.Unlock () ;

DebugMacro8(

    wchar_t buffer [ 1025 ] ;
    wsprintf ( buffer , L"\nThread [%S] = %lx, with thread id = %lx" , m_ThreadName , this , m_ThreadId ) ;
    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__, buffer ) ;
)
    return t_Status ;
}

void SnmpThreadObject :: Process () 
{
    s_Lock.Lock () ;

    POSITION t_Position = m_ScheduleReapEventContainer.GetStartPosition () ;
    while ( t_Position )
    {
        HANDLE t_EventId ;
        SnmpEventObject *t_Event ;
        m_ScheduleReapEventContainer.GetNextAssoc ( t_Position , t_EventId , t_Event) ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Thread Process [%lx]" , m_ThreadName , t_EventId);
)

        t_Event->Set () ;
    }

    s_Lock.Unlock () ;
}

BOOL SnmpThreadObject :: WaitDispatch ( ULONG t_HandleIndex , BOOL &a_Terminated )
{
    BOOL t_Status = TRUE ;

    HANDLE t_Handle = m_EventContainer [ t_HandleIndex ] ;
    if ( t_Handle == GetHandle () )
    {
// Task has been scheduled so we must update arrays

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Thread Wait: Refreshing handles" , m_ThreadName );
)

        Process () ;
        ConstructEventContainer () ;
    }
    else if ( t_Handle == m_ThreadTerminateEvent.GetHandle () )
    {
// thread has been told to close down

        a_Terminated = TRUE ;
        m_ThreadTerminateEvent.Process () ;

DebugMacro8(

        SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Someone t_Terminated" , m_ThreadName )  ;
)
    }
    else
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Thread Wait: Processing Task" , m_ThreadName );
)

        SnmpAbstractTaskObject *t_TaskObject = GetTaskObject ( t_Handle ) ;
        if ( t_TaskObject )
        {
            RotateTask ( t_TaskObject ) ;
            ConstructEventContainer () ;
            t_TaskObject->Process () ;
        }
        else
        {
DebugMacro8(

            SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Couldn't Find Task Object" , m_ThreadName ) ;
)
            t_Status = FALSE ;
        }
    }

    return t_Status ;
}

BOOL SnmpThreadObject :: Wait ()
{
    BOOL t_Status = TRUE ;
    BOOL t_Terminated = FALSE ;

    while ( t_Status && ! t_Terminated )
    {
        DWORD t_Event = MsgWaitForMultipleObjects (

            m_EventContainerLength ,
            m_EventContainer ,
            FALSE ,
            m_timeout ,
            QS_ALLINPUT
        ) ;

        ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

        if ( t_Event == 0xFFFFFFFF )
        {
            DWORD t_Error = GetLastError () ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Handle problem" , m_ThreadName ) ;
)

            t_Status = FALSE ;
        }
        else if ( t_Event == WAIT_TIMEOUT)
        {
            TimedOut();
        }
        else if ( t_HandleIndex <= m_EventContainerLength )
        {
// Go into dispatch loop

            if ( t_HandleIndex == m_EventContainerLength )
            {
                BOOL t_DispatchStatus ;
                MSG t_Msg ;

                while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
                {
					int t_Result = 0;
					t_Result = GetMessage ( & t_Msg , NULL , 0 , 0 );

					if ( t_Result != 0 && t_Result != -1 )
                    {
                        TranslateMessage ( & t_Msg ) ;
                        DispatchMessage ( & t_Msg ) ;
                    }

                    BOOL t_Timeout = FALSE ;

                    while ( ! t_Timeout & t_Status & ! t_Terminated )
                    {
                        t_Event = WaitForMultipleObjects (

                            m_EventContainerLength ,
                            m_EventContainer ,
                            FALSE ,
                            0
                        ) ;

                        t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

                        if ( t_Event == 0xFFFFFFFF )
                        {
                            DWORD t_Error = GetLastError () ;
    
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Handle problem" , m_ThreadName ) ;
)
                            t_Status = FALSE ;
                        }
                        else if ( t_Event == WAIT_TIMEOUT)
                        {
                            t_Timeout = TRUE ;
                        }
                        else if ( t_HandleIndex < m_EventContainerLength )
                        {
                            t_Status = WaitDispatch ( t_HandleIndex , t_Terminated ) ;
                        }
                        else
                        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Unknown handle index" , m_ThreadName ) ;
)
                            t_Status = FALSE ;
                        }
                    }
                }
            }
            else if ( t_HandleIndex < m_EventContainerLength )
            {
                t_Status = WaitDispatch ( t_HandleIndex , t_Terminated ) ;
            }
            else
            {

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Unknown handle index" , m_ThreadName ) ;
)
                t_Status = FALSE ;
            }
        }
    }

    return t_Status ;
}

ULONG SnmpThreadObject :: GetEventHandlesSize ()
{
    return m_EventContainerLength ;
}

HANDLE *SnmpThreadObject :: GetEventHandles ()
{
    return m_EventContainer ;
}

BOOL SnmpThreadObject :: ScheduleTask ( SnmpAbstractTaskObject &a_TaskObject ) 
{
    BOOL t_Result = TRUE ;

    s_Lock.Lock () ;

/*
 * Add Synchronous object to worker thread container
 */
    a_TaskObject.m_ScheduledHandle = a_TaskObject.GetHandle ();
    m_TaskContainer.Add ( &a_TaskObject ) ; 

    s_Lock.Unlock () ;

    a_TaskObject.AttachTaskToThread ( *this ) ;

    if ( GetCurrentThreadId () != m_ThreadId ) 
    {
#if 0
        SnmpEventObject t_ScheduledEventObject ;

        s_Lock.Lock () ;

        m_ScheduleReapEventContainer [ t_ScheduledEventObject.GetHandle () ] = &t_ScheduledEventObject ;

        s_Lock.Unlock () ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ScheduleTask: Setting update" , m_ThreadName );
)
        Set () ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ScheduleTask: Beginning Wait" , m_ThreadName );
)

        if ( t_ScheduledEventObject.Wait () )
        {
        }
        else
        {
            t_Result = FALSE ;
        }

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ScheduleTask: Ended Wait" , m_ThreadName );
)

        s_Lock.Lock () ;

        m_ScheduleReapEventContainer.RemoveKey ( t_ScheduledEventObject.GetHandle () ) ;

        s_Lock.Unlock () ;
#else
        Set () ;
#endif
    }
    else
    {
        ConstructEventContainer () ;
    }

    return t_Result ;
}

BOOL SnmpThreadObject :: ReapTask ( SnmpAbstractTaskObject &a_TaskObject ) 
{
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Entering ReapTask [%lx]" , m_ThreadName , a_TaskObject.m_ScheduledHandle );
)

    BOOL t_Result = TRUE ;

    s_Lock.Lock () ;

/*
 *  Remove worker object from worker thread container
 */

    POSITION t_Position = m_TaskContainer.GetHeadPosition () ;
    while ( t_Position )
    {
        POSITION t_LastPosition = t_Position ;
        SnmpAbstractTaskObject *t_TaskObject = m_TaskContainer.GetNext ( t_Position ) ;
        if ( a_TaskObject.m_ScheduledHandle == t_TaskObject->m_ScheduledHandle )    
        {
            m_TaskContainer.RemoveAt ( t_LastPosition ) ;
            break ;
        }
    }

    s_Lock.Unlock () ;

/*
 * Inform worker thread,thread container has been updated.
 */

    if ( GetCurrentThreadId () != m_ThreadId ) 
    {
        SnmpEventObject t_ReapedEventObject ;

        s_Lock.Lock () ;

        m_ScheduleReapEventContainer [ t_ReapedEventObject.GetHandle () ] = &t_ReapedEventObject ;

        s_Lock.Unlock () ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ReapTask: Setting update" , m_ThreadName );
)
        Set () ;

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ReapTask: Beginning Wait on [%lx]" , m_ThreadName , t_ReapedEventObject.GetHandle () );
)

        if ( t_ReapedEventObject.Wait () )
        {
        }
        else
        {
            t_Result = FALSE ;
        }

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ReapTask: Ended Wait" , m_ThreadName );
)

        s_Lock.Lock () ;

        m_ScheduleReapEventContainer.RemoveKey ( t_ReapedEventObject.GetHandle () ) ;

        s_Lock.Unlock () ;

    }
    else
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] ReapTask: ConstructEventContainer" , m_ThreadName );
)
        ConstructEventContainer () ;
    }

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\n[%S] Returning from ReapTask [%lx]" , m_ThreadName , a_TaskObject.m_ScheduledHandle );
)

    a_TaskObject.DetachTaskFromThread ( *this ) ;

    return t_Result ;
}

SnmpAbstractTaskObject :: SnmpAbstractTaskObject ( 

    const wchar_t *a_GlobalTaskNameComplete,
    const wchar_t *a_GlobalTaskNameAcknowledgement,
    DWORD a_timeout

) : m_CompletionEvent ( a_GlobalTaskNameComplete ) , 
    m_AcknowledgementEvent ( a_GlobalTaskNameAcknowledgement ) , 
    m_timeout ( a_timeout ), 
    m_ScheduledHandle (NULL)
{
} 

SnmpAbstractTaskObject :: ~SnmpAbstractTaskObject () 
{
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: ~SnmpAbstractTaskObject () [%lx]" , m_ScheduledHandle ) ;
)
    m_Lock.Lock () ;

    if (NULL != m_ScheduledHandle)
    {
        POSITION t_Position = m_ThreadContainer.GetStartPosition () ;
        while ( t_Position )
        {
            DWORD t_ThreadId ;
            SnmpThreadObject *t_ThreadObject ;
            m_ThreadContainer.GetNextAssoc ( t_Position , t_ThreadId , t_ThreadObject ) ;

            t_ThreadObject->ReapTask ( *this ) ;
        }
    }

    m_ThreadContainer.RemoveAll () ;    

    m_Lock.Unlock () ;
}

void SnmpAbstractTaskObject :: DetachTaskFromThread ( SnmpThreadObject &a_ThreadObject )
{
    m_Lock.Lock () ;
    m_ThreadContainer.RemoveKey ( a_ThreadObject.GetThreadId () ) ;
    m_Lock.Unlock () ;
}

void SnmpAbstractTaskObject :: AttachTaskToThread ( SnmpThreadObject &a_ThreadObject )
{
    m_Lock.Lock () ;
    m_ThreadContainer [ a_ThreadObject.GetThreadId () ] = &a_ThreadObject ;
    m_Lock.Unlock () ;
}

BOOL SnmpAbstractTaskObject :: Wait ( BOOL a_Dispatch )
{
    BOOL t_Status = TRUE ;
    BOOL t_Processed = FALSE ;

    while ( t_Status && ! t_Processed )
    {
        SnmpThreadObject *t_ThreadObject = SnmpThreadObject :: GetThreadObject () ;
        ULONG t_TaskEventArrayLength = 0 ;
        HANDLE *t_TaskEventArray = NULL ;

        if ( t_ThreadObject && a_Dispatch )
        {
            ULONG t_TaskArrayLength = t_ThreadObject->GetEventHandlesSize () ;
            t_TaskEventArrayLength = t_TaskArrayLength + 1 ;
            t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;

            if ( t_TaskEventArray )
            {
	            t_TaskEventArray [ 0 ] = m_CompletionEvent.GetHandle () ;

                memcpy ( 
 
                    & ( t_TaskEventArray [ 1 ] ) ,
                    t_ThreadObject->GetEventHandles () ,
                    t_TaskArrayLength * sizeof ( HANDLE ) 
                ) ;     
            }
			else
			{
				return FALSE;
			}
        }
        else
        {
            t_TaskEventArrayLength = 1 ;
            t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;
            t_TaskEventArray [ 0 ] = m_CompletionEvent.GetHandle () ;
        }

        DWORD t_Event ;

        if ( a_Dispatch ) 
        {
            t_Event = MsgWaitForMultipleObjects (

                t_TaskEventArrayLength ,
                t_TaskEventArray ,
                FALSE ,
                m_timeout ,
                QS_ALLINPUT
            ) ;
        }
        else
        {
            t_Event = WaitForMultipleObjects (

                t_TaskEventArrayLength ,
                t_TaskEventArray ,
                FALSE ,
                m_timeout 
            ) ;
        }

        ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

        if ( t_Event == 0xFFFFFFFF )
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle" ) ;
)

            DWORD t_Error = GetLastError () ;
            t_Status = FALSE ;
        }
        else if ( t_Event == WAIT_TIMEOUT)
        {
            TimedOut();
        }
        else if ( t_HandleIndex == t_TaskEventArrayLength )
        {
            BOOL t_DispatchStatus ;
            MSG t_Msg ;

            while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
            {
				int t_Result = 0;
				t_Result = GetMessage ( & t_Msg , NULL , 0 , 0 );

				if ( t_Result != 0 && t_Result != -1 )
                {
                    TranslateMessage ( & t_Msg ) ;
                    DispatchMessage ( & t_Msg ) ;
                }

                BOOL t_Timeout = FALSE ;

                while ( ! t_Timeout & t_Status & ! t_Processed )
                {
                    t_Event = WaitForMultipleObjects (

                        t_TaskEventArrayLength ,
                        t_TaskEventArray ,
                        FALSE ,
                        0
                    ) ;

                    t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

                    if ( t_Event == 0xFFFFFFFF )
                    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle" ) ;
)

                        DWORD t_Error = GetLastError () ;
                        t_Status = FALSE ;
                    }
                    else if ( t_Event == WAIT_TIMEOUT)
                    {
                        t_Timeout = TRUE ;
                    }
                    else if ( t_HandleIndex < t_TaskEventArrayLength )
                    {
                        HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
                        t_Status = WaitDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
                    }
                    else
                    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle index" ) ;
)
                        t_Status = FALSE ;
                    }
                }
            }
        }
        else if ( t_HandleIndex < t_TaskEventArrayLength )
        {
            HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
            t_Status = WaitDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
        }
        else
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle index" ) ;
)

            t_Status = FALSE ;
        }

        delete [] t_TaskEventArray ;
    }

    return t_Status ;
}

BOOL SnmpAbstractTaskObject :: WaitDispatch ( SnmpThreadObject *a_ThreadObject, HANDLE a_Handle , BOOL &a_Processed )
{
    BOOL t_Status = TRUE ;

    if ( a_Handle == m_CompletionEvent.GetHandle () )
    {

DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nWait: Completed" );
)


        m_CompletionEvent.Process () ;
        a_Processed = TRUE ;
    }
    else if ( a_ThreadObject && ( a_Handle == a_ThreadObject->GetHandle () ) )
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nTask Wait: Refreshing handles" );
)
        a_ThreadObject->Process () ;
        a_ThreadObject->ConstructEventContainer () ;
    }
    else
    {
        SnmpAbstractTaskObject *t_TaskObject = a_ThreadObject->GetTaskObject ( a_Handle ) ;
        if ( t_TaskObject )
        {
            a_ThreadObject->RotateTask ( t_TaskObject ) ;
            a_ThreadObject->ConstructEventContainer () ;
            t_TaskObject->Process () ;
        }
        else
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Task" ) ;
)
            t_Status = FALSE ;
        }
    }

    return t_Status ;
}

BOOL SnmpAbstractTaskObject :: WaitAcknowledgement ( BOOL a_Dispatch )
{
    BOOL t_Status = TRUE ;
    BOOL t_Processed = FALSE ;

    while ( t_Status && ! t_Processed )
    {
        SnmpThreadObject *t_ThreadObject = SnmpThreadObject :: GetThreadObject () ;
        ULONG t_TaskEventArrayLength = 0 ;
        HANDLE *t_TaskEventArray = NULL ;

        if ( t_ThreadObject && a_Dispatch )
        {
            ULONG t_TaskArrayLength = t_ThreadObject->GetEventHandlesSize () ;
            t_TaskEventArrayLength = t_TaskArrayLength + 1 ;
            t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;

            if ( t_TaskArrayLength )
            {
                memcpy ( 
 
                    & ( t_TaskEventArray [ 1 ] ) , 
                    t_ThreadObject->GetEventHandles () ,
                    t_TaskArrayLength * sizeof ( HANDLE ) 
                ) ;     
            }

            t_TaskEventArray [ 0 ] = m_AcknowledgementEvent.GetHandle () ;          
        }
        else
        {
            t_TaskEventArrayLength = 1 ;
            t_TaskEventArray = new HANDLE [ t_TaskEventArrayLength ] ;
            t_TaskEventArray [ 0 ] = m_AcknowledgementEvent.GetHandle () ;
        }

        DWORD t_Event ;

        if ( a_Dispatch ) 
        {
            t_Event = MsgWaitForMultipleObjects (

                t_TaskEventArrayLength ,
                t_TaskEventArray ,
                FALSE ,
                m_timeout ,
                QS_ALLINPUT
            ) ;
        }
        else
        {
            t_Event = WaitForMultipleObjects (

                t_TaskEventArrayLength ,
                t_TaskEventArray ,
                FALSE ,
                m_timeout 
            ) ;
        }

        ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

        if ( t_Event == 0xFFFFFFFF )
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle" ) ;
)

            DWORD t_Error = GetLastError () ;
            t_Status = FALSE ;
        }
        else if ( t_Event == WAIT_TIMEOUT)
        {
            TimedOut();
        }
        if ( t_HandleIndex == t_TaskEventArrayLength )
        {
            BOOL t_DispatchStatus ;
            MSG t_Msg ;

            while ( ( t_DispatchStatus = PeekMessage ( & t_Msg , NULL , 0 , 0 , PM_NOREMOVE ) ) == TRUE ) 
            {
				int t_Result = 0;
				t_Result = GetM