e
	{
		nContigousStart = gnFirstCluster;
	}
	
	//
	// -2 is adjustment value, because cluster value starts at 2
	//
	while ((nContigousStart-2+nClustersRequired) < pDrvInfo->TotalClusters)
	{
		for (ti = 0; ti < nClustersRequired; ti++)
		{
			if (FindNextCluster(pDrvInfo, nContigousStart+ti) != 0)
			{
				break;
			}
		}
		
		if (ti == nClustersRequired)
		{
			return nContigousStart;
		}
		else
		{
			nContigousStart = nContigousStart+ti+1;
		}
			
	}
	return 0;
}

UINT32 OccupyClusters(BPBINFO *pDrvInfo, UINT32 nStartCluster, UINT32 nTotalClusters)
{

	UINT32 ti, nCurrent, nPrevious;
	
	if (!gnContig)
	{
		if (nStartCluster == 0)
		{
			nStartCluster = 2;
		}
		 
		nCurrent = nStartCluster;
		nPrevious = nStartCluster;
		
		//    
		// First locate a free cluster
		//
        while (nCurrent <= pDrvInfo->TotalClusters)
		{
			if (FindNextCluster(pDrvInfo, nCurrent) == 0)
			{
				break;
			}
			nCurrent++;
		}
		nPrevious = nCurrent;
		gnClusterStart = nCurrent;
		nCurrent++;
		// one cluster almost allocated, set ti to 2
		ti = 2;
        while (ti <= nTotalClusters && nCurrent <= pDrvInfo->TotalClusters)
		{
			if (FindNextCluster(pDrvInfo, nCurrent) == 0)
			{
				//
				// occupy this cluster
				//
				UpdateFATLocation(pDrvInfo, nPrevious, nCurrent);
				nPrevious = nCurrent;
				ti++;
			}
			nCurrent++;
		}
		UpdateFATLocation(pDrvInfo, nPrevious, GetFATEOF(pDrvInfo));
        if (ti < nTotalClusters)
        {
            Mes("*** WARNING: Disk full, fewer than required clusters allocated.***\n");
        }
        return ti-1;
	}
	else
	{
		//
		// This is a dangerous area. It trusts nStartCluster and nTotalClusters and
		// allocates a contigous chain.
		//
		ti = 1;
		nCurrent = nStartCluster;
        while (ti < nTotalClusters)
		{
			nPrevious = nCurrent;
			nCurrent++;
			UpdateFATLocation(pDrvInfo, nPrevious, nCurrent);
			ti++;
		}
		UpdateFATLocation(pDrvInfo, nCurrent, GetFATEOF(pDrvInfo));
        return nTotalClusters;
	}
}

//
// Directory related functions
//

UINT16 ReadRootDirSector(BPBINFO *DrvInfo, BYTE *pRootDirBuffer, UINT32 NthSector)
{
	// !#! ReadRootDirSector is requested to return 1 sector. But two consiquitive
	// sectors are returned so that it helps routine which process the file
	// info when an LFN crosses sector boundary

	UINT32	SeekSector;
	UINT16  NthInChain;// Nth cluster 'order' in the root directory FAT chain
	UINT16  ti;
	UINT32	NextCluster;
	BYTE	RetVal;
	UINT16  NthInCluster;
	
	RetVal = 1;	
	switch (DrvInfo->FATType)
	{
		case 12:
		case 16:
			if (NthSector > DrvInfo->TotalRootDirSectors)
			{
				RetVal = 2;
				break;
			}
			SeekSector = (UINT32) DrvInfo->FirstRootDirSector + NthSector - 1;
			RetVal = (BYTE) ReadSector(DrvInfo->Drive, SeekSector, 2, pRootDirBuffer);
			break;
		case 32:
			//
			// Reading a FAT32 root directory sector is handled in a different way. 
			// Find out where the requested sector should be residing in the chain
			//
			NthInChain = (UINT16) (NthSector / (UINT32) DrvInfo->SectorsPerCluster);
			NthInCluster = (UINT16) (NthSector - ((UINT32)NthInChain * (UINT32)DrvInfo->SectorsPerCluster));
			if (!NthInCluster)
			{
				NthInChain--;
				NthInCluster = DrvInfo->SectorsPerCluster;
			}
			// Find the cluster at this order in the FAT chain
			NextCluster = DrvInfo->RootDirCluster;
			ti = 0;
			while (ti < NthInChain)
			{
				if (NextCluster >= (0x0fffffff-7))
				{
					RetVal = 2;
					break;
				}
				NextCluster = FindNextCluster(DrvInfo, NextCluster);
				ti++;
			}
			if (RetVal != 2)
			{
				SeekSector = (UINT32) DrvInfo->ReservedBeforeFAT + 
							DrvInfo->SectorsPerFAT * 
							(UINT32)DrvInfo->FATCount + 
							(UINT32) (NextCluster - 2) * 
							(UINT32) DrvInfo->SectorsPerCluster + 
							NthInCluster-1;
				ReadSector(DrvInfo->Drive, SeekSector, 2, pRootDirBuffer);
				// if this is the last sector OF the cluster get next cluster and 
				// get the first sector
				if (NthInCluster == DrvInfo->SectorsPerCluster)
				{
					NthInCluster = 1;
					NextCluster = FindNextCluster(DrvInfo, NextCluster);
					if (NextCluster < (0x0fffffff-7))
					{
						SeekSector = (UINT32) DrvInfo->ReservedBeforeFAT + 
								DrvInfo->SectorsPerFAT * 
								(UINT32)DrvInfo->FATCount + 
								(UINT32) (NextCluster - 2) * 
								(UINT32) DrvInfo->SectorsPerCluster + 
								NthInCluster-1;
						ReadSector(DrvInfo->Drive, SeekSector, 1, pRootDirBuffer+512); // note the 512 here
					}
					else
					{
						for (ti = 512; ti < 1024; ti++)
						{
							pRootDirBuffer[ti] = 0; // undo the second sector read
						}
					}
				}
			}
			break;
	}
	return RetVal;
}

UINT16 WriteRootDirSector(BPBINFO *DrvInfo, BYTE *pRootDirBuffer, UINT32 NthSector)
{
	UINT32	SeekSector;
	UINT16  NthInChain; // Nth cluster 'order' in the root directory FAT chain
	UINT16	ti;
	UINT32	NextCluster;
	BYTE	RetVal;
	UINT16  NthInCluster;
	
	RetVal = 1;	
	switch (DrvInfo->FATType)
	{
		case 12:	// FAT12 and FAT32 are handled the same way
		case 16:
			if (NthSector > DrvInfo->TotalRootDirSectors)
			{
				RetVal = 2;
				break;
			}
			SeekSector = (UINT32) DrvInfo->FirstRootDirSector + NthSector-1;
			RetVal = (BYTE) WriteSector(DrvInfo->Drive, SeekSector, 1, pRootDirBuffer);
			break;
		case 32:
			
			// Find out where the requested sector should be going in the chain
			NthInChain = (UINT16) (NthSector / (UINT32) DrvInfo->SectorsPerCluster);
			NthInCluster = (UINT16) (NthSector - ((UINT32)NthInChain * (UINT32)DrvInfo->SectorsPerCluster));
			if (!NthInCluster)
			{
				NthInChain--;
				NthInCluster = DrvInfo->SectorsPerCluster;
			}
			// Find the cluster at this order in the FAT chain
			NextCluster = DrvInfo->RootDirCluster;
			ti = 0;
			while (ti < NthInChain)
			{
				if (NextCluster == 0x0fffffff)
				{
					RetVal = 2;
					break;
				}
				NextCluster = FindNextCluster(DrvInfo, NextCluster);
				ti++;
			}
			if (RetVal != 2)
			{
				SeekSector = (UINT32) DrvInfo->ReservedBeforeFAT + 
							DrvInfo->SectorsPerFAT * (UINT32)DrvInfo->FATCount + 
							(UINT32) (NextCluster - 2) * 
							(UINT32) DrvInfo->SectorsPerCluster + NthInCluster-1;
				WriteSector(DrvInfo->Drive, SeekSector, 1, pRootDirBuffer);
			}
			break;
	}
	return RetVal;
}

//
// File related functions
// 
void FindFileLocation(BPBINFO *DrvInfo, BYTE *TraversePath, FILELOC *FileLocation)
{
	// Parameter TraversePath must be a file name(or dir name) with full path
	// The first character must be "\". If the function fails 0 is returned
	// in FILELOC->Found. eg. You can pass \Windows\System32\Program Files 
	// to get "Program Files" location

	FILEINFO FileInfo;
	BYTE Found;
	UINT16 RetVal;
	BYTE DirInfo[300];
	BYTE CheckInfo[300];
	UINT16 ti,tj,n,TraverseCount, Offset;
	BYTE i;
	UINT32 NthRootDirSector, NextCluster, SectorToRead;
	BYTE SectorBuffer[1024];

	Found = 0;
	ti = strlen(TraversePath);
	if (ti < 2)
	{
		FileLocation->Found = 0;
		return;
	}
	TraverseCount = 0;
	// start from next character as the first char is "\" and i value should not change inside while loop
	ti = 1;		
	while (TraversePath[ti] != 0)
	{
		tj = 0;
		for (n = 0; n < 300; n++) DirInfo[n] = 0;
		if (TraverseCount != 0)
		{
			ti++;	// increment only after traversing root directory.
		}
		while (TraversePath[ti] != '\\' && TraversePath[ti] != 0)
		{
			DirInfo[tj] = TraversePath[ti];
			tj++; ti++;
		}
		DirInfo[tj] = 0;
		TraverseCount++;
		if (TraverseCount == 1)	
		{
			//
			// We are in root directory entry if TraverseCount equals 1
			//
			Found = 0;
			NthRootDirSector = 1;
			Offset = 0;
			while (!Found)
			{
				RetVal = ReadRootDirSector(DrvInfo, SectorBuffer, NthRootDirSector);
				if (RetVal == 0 || RetVal == 2)
				{
					break;
				}
				else
				{
					while (SectorBuffer[Offset] != 0)
					{
						if (SectorBuffer[Offset] == 0xe5)
						{
							Offset+=32;
						}
						else
						{
							GetFileInfo(DrvInfo, SectorBuffer, Offset, &FileInfo);
							strcpy(CheckInfo, (char *)FileInfo.LFName);
							if (strcmpi(CheckInfo, DirInfo) == 0)
							{
								FileLocation->InCluster = 1;
								FileLocation->StartCluster = FileInfo.StartCluster;
								FileLocation->NthSector = NthRootDirSector;
								FileLocation->NthEntry = Offset/32 + 1;
								FileLocation->EntriesTakenUp = FileInfo.EntriesTakenUp;
								FileLocation->Size = FileInfo.Size;
								FileLocation->Attribute = FileInfo.Attribute;
								Found = 1;
								break;
							}
							Offset = Offset + FileInfo.EntriesTakenUp * 32;
						}
						if (Offset > 511)
						{
							break;
						}
					}
				}
				if (SectorBuffer[Offset] == 0 || Found)
				{
					break;
				}
				//
				// do not set it to 0 directly
				//
				Offset = Offset - 512;	
				NthRootDirSector++;
			}
			if (!Found)
			{
				FileLocation->Found = 0;
				return;
			}
		}
		else
		{
			NextCluster = FileLocation->StartCluster;
			Offset = 0;
			Found = 0;
			while (NextCluster < (GetFATEOF(DrvInfo) - 7))
			{
				for (i = 0; i < DrvInfo->SectorsPerCluster; i++)
				{
					SectorToRead = (UINT32) ((UINT32)DrvInfo->TotalSystemSectors + (NextCluster - 2) * (UINT32)DrvInfo->SectorsPerCluster + i);
					ReadSector(DrvInfo->Drive, SectorToRead, 2, SectorBuffer);
					if (i == DrvInfo->SectorsPerCluster-1)
					{	
						if (FindNextCluster(DrvInfo, NextCluster) < (GetFATEOF(DrvInfo) - 7))
						{	// Note the +512 carefully
							SectorToRead = (UINT32) ((UINT32)DrvInfo->TotalSystemSectors + 
										(FindNextCluster(DrvInfo, NextCluster) - 2) * 
										(UINT32)DrvInfo->SectorsPerCluster);
							ReadSector(DrvInfo->Drive, SectorToRead, 1, SectorBuffer+512);
						}
					}
					while (1)
					{
						if (Offset > 511 || SectorBuffer[Offset] == 0)
						{
							break;
						}
						if (SectorBuffer[Offset] == 0xe5)
						{
							Offset+=32;
							continue;
						}
						GetFileInfo(DrvInfo, SectorBuffer, Offset, &FileInfo);
						//
						// Refer to GetFileInfo if confused 
						//
						strcpy(CheckInfo, FileInfo.LFName);	
						if (strcmpi(CheckInfo, DirInfo) == 0)
						{
							FileLocation->InCluster = NextCluster;
							FileLocation->StartCluster = FileInfo.StartCluster;
							FileLocation->NthSector = (UINT32) i+1;
							FileLocation->NthEntry = Offset/32 + 1;
							FileLocation->EntriesTakenUp = FileInfo.EntriesTakenUp;
							FileLocation->Size = FileInfo.Size;
							FileLocation->Attribute = FileInfo.Attribute;
							Found = 1;
							break;
						}
						Offset = Offset + FileInfo.EntriesTakenUp * 32;
					}
					if (Found)
					{
						break;
					}
					Offset = Offset - 512; // Should not simply set it to 0
				}
				if (Found)
				{
					break;
				}
				NextCluster = FindNextCluster(DrvInfo, NextCluster);
			}
		}
	}
	FileLocation->Found = Found;
}

void GetFileInfo(BPBINFO *DrvInfo, BYTE *DirBuffer, UINT16 Offset, FILEINFO *FileInfo)
{
	// GetFileInfo gets the file information from DirBuffer at Offset and
	// It supports long file names. Also it stores the number of 
	// entries that are occupied by this file name in FileInfo->EntriesTakenUp
	// !#! If the entry is not a long file name a proper file name is stored
	// in LFName with a dot in between primary and ext names to help routines
	// which compare file names
	UINT16 ti,tj;
	UINT16 TimeDateWord;
	BYTE StrCompare[7];
	UINT32 Temp;
	
	FileInfo->LFName[0] = '\0';
	FileInfo->LFNOrphaned = 0;
	FileInfo->TrashedEntry = 0;
	// Get file attribute
	FileInfo->Attribute = DirBuffer[Offset+11];	
	if ((FileInfo->Attribute & 0x0f) == 0x0f)
	{
		if (DirBuffer[Offset] >= 'A' && DirBuffer[Offset] <= 'T')
		{ // Count of minimum and maximum entries to be an LFN
			FileInfo->EntriesTakenUp = (DirBuffer[Offset] & 0x3f) + 1;
			// Get the real attribute if it is a long file name. EntriesTakenUp > 1 is a long file name
			FileInfo->Attribute = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+11];
		}
		else
		{
			FileInfo->TrashedEntry = 1;
			FileInfo->LFNOrphaned = 1; // Could be
			return;
		}
	}
	else
	{
		FileInfo->EntriesTakenUp = 1;
	}
	// Get Primary name
	for (ti = 0; ti < 8; ti++)
	{
		FileInfo->DOSName[ti] = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+ti];
	}
	// Get extension
	FileInfo->DOSExt[0] = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+8];
	FileInfo->DOSExt[1] = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+9];
	FileInfo->DOSExt[2] = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+10];

	Rx.e.evx = 0;
	Rx.h.vl = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+0x1c]; 
	Rx.h.vh = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+0x1d]; 
	Rx.h.xvl = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+0x1e]; 
	Rx.h.xvh = DirBuffer[(FileInfo->EntriesTakenUp-1)*32+Offset+0x1f];
	FileInfo->Size = Rx.e.evx;
	
	switch (DrvInfo->FATType)
	{
		case 12:
		case 16:
			// Starting Cluster
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x1a]; Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x1b];
			FileInfo->StartCluster = (UINT32) Rx.x.vx;
			// Get File time
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x16]; Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x17];
			TimeDateWord = Rx.x.vx;
			FileInfo->Second = (BYTE) (TimeDateWord & 0x001f);
			FileInfo->Minute = (BYTE) ((TimeDateWord & 0x07e0) >> 5);
			FileInfo->Hour   = (BYTE) ((TimeDateWord & 0xf800) >> 11);
			// Get File date
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x18]; 
			Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x19];
			TimeDateWord = Rx.x.vx;
			FileInfo->Day    = (BYTE) (TimeDateWord & 0x001f);
			FileInfo->Month  = (BYTE) ((TimeDateWord & 0x01e0) >> 5);
			FileInfo->Year   = ((TimeDateWord & 0xfe00) >> 9) + 1980;
			break;
		case 32:
			// Starting Cluster
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x1a]; 
			Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x1b]; 
			Rx.h.xvl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x14]; 
			Rx.h.xvh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x15];
			FileInfo->StartCluster = Rx.e.evx;
			// Get File time
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x16]; 
			Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x17];
			TimeDateWord = Rx.x.vx;
			FileInfo->Second = (BYTE) (TimeDateWord & 0x001f);
			FileInfo->Minute = (BYTE) ((TimeDateWord & 0x07e0) >> 5);
			FileInfo->Hour   = (BYTE) ((TimeDateWord & 0xf800) >> 11);
			// Get File date
			Rx.e.evx = 0;
			Rx.h.vl = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x18]; 
			Rx.h.vh = DirBuffer[Offset+(FileInfo->EntriesTakenUp-1)*32+0x19];
			TimeDateWord = Rx.x.vx;
			FileInfo->Day    = (BYTE) (TimeDateWord & 0x001f);
			FileInfo->Month  = (BYTE) ((TimeDateWord & 0x01e0) >> 5);
			FileInfo->Year   = ((TimeDateWord & 0xfe00) >> 9) + 1980;
			break;
		default:
			break;
	}
	if (FileInfo->EntriesTakenUp < 2)	// copy DOSName and DOSExt as proper file name to LFName
	{
		ti = 0; tj = 0;
		while(1)
		{
			if (FileInfo->DOSName[ti] == ' ' || ti == 8)
			{
				break;
			}
			FileInfo->LFName[tj] = FileInfo->DOSName[ti];
			tj++; ti++;
		}
		if (ti != 0 && FileInfo->DOSExt[0] != ' ') // Avoid empty names and . in case of no extension
		{
			FileInfo->LFName[tj] = '.';
			ti = 0; tj++;
			while (1)
			{
				if (FileInfo->DOSExt[ti] == ' ' || ti == 3)
				{
					break;
				}
				FileInfo->LFName[tj] = FileInfo->DOSExt[ti];
				tj++; ti++;
			}
		}
		FileInfo->LFName[tj] = 0;	// Terminate with NULL Character
	}
	else
	{	// Fetch the Long file name
		ti = 0; tj = FileInfo->EntriesTakenUp - 1;
		while( tj > 0)
		{
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 1];  ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 3];  ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 5];  ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 7];  ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 9];  ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 14]; ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 16]; ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 18]; ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 20]; ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 22]; ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 24]; ti++; FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 28]; ti++;
			FileInfo->LFName[ti] = DirBuffer[Offset + (tj-1)*32 + 30]; ti++;
			tj--;
		}
		FileInfo->LFName[ti] = 0;
	}
	// Check for orphaned LFN
	if (FileInfo->EntriesTakenUp > 1)
	{ // it is a long file name
		// Get the strings from the LFN without space for comparison purpose
		// Example - if LFN is "Very Long name" the corresponding
		// DOS file name would be "VERYLO~?". We extract VeryLo and check
		// against VERYLO.
		ti = 0; tj = 0;
		while (ti < 8 && FileInfo->LFName[tj] != 0 && FileInfo->LFName[tj] != '.')
		{
			if (FileInfo->LFName[tj] != 32 && FileInfo->LFName[tj] != '.')
			{
				StrCompare[ti] = FileInfo->LFName[tj];
				ti++;
			}
			tj++;
		}
		StrCompare[tj] = 0;
		// But when there are to many file starting with name "Very Long name"
		// the dos file name need not be "VERYLO~?" in all the cases. It could
		// be "VERYL~??" or "VERY~???" and so on...
		tj = 0;
		while (FileInfo->DOSName[tj] != '~' && FileInfo->DOSName[tj] != ' ' && tj < 8)
		{
			tj++;
		}
		// *******  This if condition is not efficient
		// it is only modified to avoid false LFN errors.
		// replace the one with tj after getting more info about CRC values
		// *******
		if (strnicmp(StrCompare, FileInfo->DOSName, 1) != 0)
		{
			FileInfo->LFNOrphaned = 1;
		}
	}
	// Check if this file is a trashed entry
	if (DrvInfo->BigTotalSectors)
	{
		Temp = DrvInfo->BigTotalSectors;
	}
	else
	{
		Temp = DrvInfo->TotalSectors;
	}
	if (FileInfo->Year < 1981 || FileInfo->Day > 31 || FileInfo->Month < 1 ||
		FileInfo->Month > 12 || 	FileInfo->Second > 30 || 
		FileInfo->Minute > 60 || FileInfo->Hour > 23 ||
		FileInfo->StartCluster > DrvInfo->TotalClusters ||
		FileInfo->Size/512 > Temp)
	{
		FileInfo->TrashedEntry = 1;
	}
}

BYTE GetAllInfoOfFile(BPBINFO *pDrvInfo, BYTE *FileName, FILELOC *pFileLoc, FILEINFO *pFileInfo)
{
	UINT16	Offset;
	UINT32	SectorToRead;
	BYTE	Sector[1024];
	
	FindFileLocation(pDrvInfo, FileName, pFileLoc);
	if (!pFileLoc->Found)
	{	// need not proceed to find FileInfo
		return 0;
	}
	Offset = (pFileLoc->NthEntry-1) * 32;
	if (pFileLoc->InCluster == 1)
	{	// file in root directory
		ReadRootDirSector(pDrvInfo, Sector, pFileLoc->NthSector);
	}
	else
	{
		SectorToRead = (UINT32) ((UINT32)pDrvInfo->TotalSystemSectors + (pFileLoc->InCluster - 2) * (UINT32)pDrvInfo->SectorsPerCluster + pFileLoc->NthSector-1);
		ReadSector(pDrvInfo->Drive, SectorToRead, 1, Sector);
	}
	GetFileInfo(pDrvInfo, Sector, Offset, pFileInfo);
	return 1;
}


UINT16 SetFileInfo(BPBINFO *pDrvInfo, FILELOC *pFileLoc, FILEINFO *pFileInfo)
{
	// This function loads the entry of a file from its directory sector
	// specified in FileLocation and updates it with the new File Info in FILEINFO
	// At present this function only changes StartCluster, Size

	UINT32	SectorToRead, EmergencySectorToRead;
	UINT16	Offset, Temp;
	BYTE	SectorBuffer[1024];
	
	Offset = (pFileLoc->NthEntry-1)*32;

	if (pFileLoc->InCluster == 1)
	{	// the file is in root directory. Refer to FindFileLocation function for more info
		if (ReadRootDirSector(pDrvInfo, SectorBuffer, pFileLoc->NthSector) != 1)
		{ // The return value of the above function is either 0 or 1 or 2. We only want return value 1
			return 0;
		}
	}
	else
	{
		SectorToRead = (UINT32) ((UINT32)pDrvInfo->TotalSystemSectors + (pFileLoc->InCluster - 2) * (UINT32)pDrvInfo->SectorsPerCluster + pFileLoc->NthSector-1);
		EmergencySectorToRead = SectorToRead + 1;
		if (!ReadSector(pDrvInfo->Drive, SectorToRead, 2, SectorBuffer))
		{
			return 0;
		}
		if (pFileLoc->NthSector == pDrvInfo->SectorsPerCluster)
		{	
			if (FindNextCluster(pDrvInfo, pFileLoc->InCluster) < (GetFATEOF(pDrvInfo) - 7)) // EOF can be FFF8 to FFFF
			{	// Note the +512 carefully
				EmergencySectorToRead = (UINT32) ((UINT32)pDrvInfo->TotalSystemSectors + (FindNextCluster(pDrvInfo, pFileLoc->InCluster) - 2) * (UINT32)pDrvInfo->SectorsPerCluster);
				if (!ReadSector(pDrvInfo->Drive, EmergencySectorToRead, 1, SectorBuffer+512))
				{
					return 0;
				}
			}
		}
	}

	//
	// We have the file entry in SectorBuffer
	// Now update the file info located in the SHORTNAME area
	//

	Temp = (pFileInfo->EntriesTakenUp-1)*32;
    //
	// Change Cluster value
	//
	Rx.e.evx = 0;
	Rx.e.evx = (UINT32) pFileInfo->StartCluster;
	if (pDrvInfo->FATType == 32)
	{
		SectorBuffer[Offset+Temp+0x1a] = Rx.h.vl;
		SectorBuffer[Offset+Temp+0x1b] = Rx.h.vh;
		SectorBuffer[Offset+Temp+0x14] = Rx.h.xvl;
		SectorBuffer[Offset+Temp+0x15] = Rx.h.xvh;
	}
	else
	{
		SectorBuffer[Offset+Temp+0x1a] = Rx.h.vl;
		SectorBuffer[Offset+Temp+0x1b] = Rx.h.vh;
	}

	// Change Size
	Rx.e.evx = pFileInfo->Size;
	SectorBuffer[Offset+Temp+0x1c] = Rx.h.vl; SectorBuffer[Offset+Temp+0x1d] = Rx.h.vh;
	SectorBuffer[Offset+Temp+0x1e] = Rx.h.xvl; SectorBuffer[Offset+Temp+0x1f] = Rx.h.xvh;
	
	if (pFileLoc->InCluster == 1)
	{
		WriteRootDirSector(pDrvInfo, SectorBuffer, pFileLoc->NthSector);
		if (Offset + pFileLoc->EntriesTakenUp * 32 > 512) // Did it cross sector boundary
		{
			WriteRootDirSector(pDrvInfo, SectorBuffer+512, pFileLoc->NthSector+1);
		}
	}
	else
	{
		WriteSector(pDrvInfo->Drive, SectorToRead, 1, SectorBuffer);
		if (Offset + pFileLoc->EntriesTakenUp * 32 > 512) // Did it cross sector boundary
		{
			WriteSector(pDrvInfo->Drive, EmergencySectorToRead, 1, SectorBuffer+512);
		}
	}
	// File entry updated
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\depend.h ===
//
// Include files for messages.
// msg.h is the file generated by the message compiler.
// libmsg.h is the message library header file.
//
#include "msg.h"
#include <libmsg.h>

#define DWORD unsigned long
#define errBAD_ARGUMENTS 1
#define errFILE_NOT_FOUND 2
#define errFILE_LOCKED 3
#define errMISSING_DEPENDENCY 4
#define errOUT_OF_MEMORY 5

#define delete if(false) delete

void GetPath(TCHAR *,TCHAR *);
bool ParseCommandLine(int,TCHAR*[]);
bool SearchPath(TCHAR*,TCHAR*);
File* CreateFile(TCHAR* pszFileName);

extern List* pQueue;
extern List* pDependQueue;
extern List* pSearchPath;
extern List* pMissingFiles;
extern bool bNoisy;
extern DWORD dwERROR;
extern bool bListDependencies;

//
// Global variables required to format message using GetFormattedMessage(..)
// from libmsg.lib
//
extern HMODULE ThisModule;
extern WCHAR Message[4096];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\file32.h ===
// File32.h: interface for the File32 class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILE32_H__228703A1_5E6A_4EE0_9A1F_35385C633FCF__INCLUDED_)
#define AFX_FILE32_H__228703A1_5E6A_4EE0_9A1F_35385C633FCF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "File.h"
#include "List.h"

class File32 : public File
{
public:
	PIMAGE_NT_HEADERS pNthdr;
	void *pImageBase;

	File32(TCHAR *pszFileName);
	virtual ~File32();

	void CheckDependencies();
};

#endif // !defined(AFX_FILE32_H__228703A1_5E6A_4EE0_9A1F_35385C633FCF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\file.h ===
// File.h: interface for the File class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILE_H__708EE68D_A6EE_453B_AA09_C93CB05A626A__INCLUDED_)
#define AFX_FILE_H__708EE68D_A6EE_453B_AA09_C93CB05A626A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include "Object.h"
#include "List.h"
#include "StringNode.h"

class File : public Object
{
public:
	TCHAR* fileName;
	List* owners;
	List* dependencies;
	HANDLE hFile;
	
	File(TCHAR * f);
	virtual ~File();

	void AddDependant(StringNode * s);
	TCHAR* Data();
	virtual void CheckDependencies();
	void CloseFile();
};

#endif // !defined(AFX_FILE_H__708EE68D_A6EE_453B_AA09_C93CB05A626A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\file32.cpp ===
// File32.cpp: implementation of the File32 class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include "File32.h"
#include "depend.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//pszFileName - file to be loaded, including path
File32::File32(TCHAR *pszFileName) : File(pszFileName)
{
    HANDLE hFileMap;

    //open the file
    if ((hFile = CreateFile(pszFileName,GENERIC_READ,0,0,OPEN_EXISTING,0,0)) == INVALID_HANDLE_VALUE) {
        if(bNoisy) {
            _putws( GetFormattedMessage( ThisModule,
                                         FALSE,
                                         Message,
                                         sizeof(Message)/sizeof(Message[0]),
                                         MSG_ERROR_FILE_OPEN,
                                         pszFileName) );
        }
    	dwERROR = errFILE_LOCKED;
    	throw errFILE_LOCKED;
    }

    //create a memory map
    hFileMap = CreateFileMapping(hFile,0,PAGE_READONLY,0,0,0);
    pImageBase = MapViewOfFile(hFileMap,FILE_MAP_READ,0,0,0);


    //try to create an NTHeader structure to give file information
    if (pNthdr = ImageNtHeader(pImageBase)) {
    	 if (pNthdr->FileHeader.Machine == IMAGE_FILE_MACHINE_I386) return;
    	 else { CloseHandle(hFile); hFile = INVALID_HANDLE_VALUE; throw 0; }
    } else { 
    	CloseHandle(hFile); hFile = INVALID_HANDLE_VALUE; throw 0; }
    	 
}

File32::~File32()
{
	delete pImageBase;
	pImageBase = 0;
}

//Checks the dependencies of this file, and adds the dependencies to the queue so 
//their dependencies can be checked later
//If a file comes up missing add it to the MissingFiles queue. Add the file that was looking for it to the missing files'
//list of broken files.

//This function has logic in it to handle the special case of 'ntoskrnl.exe'.  If a file is 
//looking for 'ntoskrnl.exe' and it is missing then the function also looks for 'ntkrnlmp.exe'
void File32::CheckDependencies() {
	char *pszDllName = new char[256];
	TCHAR*pwsDllName = new TCHAR[256],*pszBuf = new TCHAR[256],*pszBufName;
	int temp = 0;
	File* pTempFile;
	DWORD dwOffset;
	
	DWORD dwVA = pNthdr->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
	PIMAGE_SECTION_HEADER pSectHdr = IMAGE_FIRST_SECTION( pNthdr ),pImportHdr = 0;
	PIMAGE_IMPORT_DESCRIPTOR pImportDir;

	//figure out which section the imports table is in
	for ( unsigned i = 0; i < pNthdr->FileHeader.NumberOfSections; i++, pSectHdr++ ) {
		DWORD cbMaxOnDisk = min( pSectHdr->Misc.VirtualSize, pSectHdr->SizeOfRawData );

		DWORD startSectRVA = pSectHdr->VirtualAddress;
		DWORD endSectRVA = startSectRVA + cbMaxOnDisk;
 
		if ( (dwVA >= startSectRVA) && (dwVA < endSectRVA) ) {
			dwOffset =  pSectHdr->PointerToRawData + (dwVA - startSectRVA);
			pImportHdr = pSectHdr;
			i = pNthdr->FileHeader.NumberOfSections;
		}
	}

	//if we found the imports table, create a pointer to it
	if (pImportHdr) {
		pImportDir = (PIMAGE_IMPORT_DESCRIPTOR) (((PBYTE)pImageBase) + (DWORD)dwOffset);

		//go through each import, try and find it, and add it to the queue
		while ((DWORD)(pImportDir->Name)!=0) {
			strcpy(pszDllName,(char*)(pImportDir->Name + ((PBYTE)pImageBase) - pImportHdr->VirtualAddress + pImportHdr->PointerToRawData));
			_strlwr(pszDllName);

			//if the ListDependencies flag is set, add this file to the dependencies list
			if (bListDependencies) {
				MultiByteToWideChar(CP_ACP,0,pszDllName,-1,pwsDllName,256);
				if (!dependencies->Find(pwsDllName)) dependencies->Add(new StringNode(pwsDllName));	
			}

			//if this isn't ntoskrnl.exe
			if (strcmp(pszDllName,"ntoskrnl.exe")) {
				//if the file is already known to be missing
				temp = MultiByteToWideChar(CP_ACP,0,pszDllName,-1,pwsDllName,256);
				if (pTempFile = (File*)pMissingFiles->Find(pwsDllName)) {
					dwERROR = errMISSING_DEPENDENCY;
					//add this file to the list of broken files
					pTempFile->AddDependant(new StringNode(fileName));
				} else { 
					//either search the windows path or the path specified in the command line
					if ( ((!pSearchPath)&&(!(SearchPath(0,pwsDllName,0,256,pszBuf,&pszBufName))))|| ((pSearchPath)&&(!SearchPath(pwsDllName,pszBuf))) ) {
						//if the file is not found, add it to missing files list and throw an error
						pMissingFiles->Add(new File(pwsDllName));
						((File*)(pMissingFiles->head))->AddDependant(new StringNode(fileName));
						dwERROR = errMISSING_DEPENDENCY;
						if (!bNoisy) goto CLEANUP;
					}
					else {
						//if the file is found, add it to the queue	
						_wcslwr(pszBuf);
						if (!(pQueue->Find(pszBuf))) pQueue->Add(new StringNode(pszBuf));	
					}
				}	
			} else {
				//if the file is already known to be missing
				if ((pTempFile = (File*)pMissingFiles->Find(L"ntoskrnl.exe"))) {
					dwERROR = errMISSING_DEPENDENCY;
					pTempFile->AddDependant(new StringNode(fileName));
				} else { 
					//either search the windows path or the path specified in the command line
					if ( (((!pSearchPath)&&(!(SearchPath(0,L"ntoskrnl.exe",0,256,pszBuf,&pszBufName))))||((pSearchPath)&&(!SearchPath(L"ntoskrnl.exe",pszBuf)))) 
						&&(((!pSearchPath)&&(!(SearchPath(0,L"ntkrnlmp.exe",0,256,pszBuf,&pszBufName))))||((pSearchPath)&&(!SearchPath(L"ntkrnlmp.exe",pszBuf))))) {
						//if the file is not found, add it to missing files list and throw an error
						pMissingFiles->Add(new File(L"ntoskrnl.exe"));
						((File*)(pMissingFiles->head))->AddDependant(new StringNode(fileName));
						dwERROR = errMISSING_DEPENDENCY;
						if (!bNoisy) goto CLEANUP;
					}
					else {
						//if the file is found, add it to the queue	
						_wcslwr(pszBuf);
						if (!(pQueue->Find(pszBuf))) pQueue->Add(new StringNode(pszBuf));
					}
				}						
			}
			pImportDir++;
		}
	}

CLEANUP:

	delete [] pszDllName;
	delete [] pszBuf;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\file.cpp ===
// File.cpp: implementation of the File class.
//
//////////////////////////////////////////////////////////////////////

#include "File.h"
#include <string.h>
#include <stdio.h>
#include "list.h"
#include "String.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

File::File(TCHAR * f) : Object()
{
	fileName = new TCHAR[wcslen(f)+1];
	if (f && fileName) wcscpy(fileName,f);
	owners = new List();
	dependencies = new List();

}

File::~File()
{
	delete [] fileName; fileName = 0;
	delete owners;owners = 0;
	delete dependencies;dependencies = 0;
}

//s - the filename of the dependant to be added
void File::AddDependant(StringNode *s) {
	//if it's already there, return
	if (owners->Find(s)!=0) {
		delete s;
		s = 0;
		return;
	}

	//else add it.
	owners->Add(s);

	return;
}

TCHAR* File::Data() {
	return fileName;	
}

void File::CheckDependencies() {

}

void File::CloseFile() {
	if (hFile!=INVALID_HANDLE_VALUE) CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\file64.h ===
// File64.h: interface for the File64 class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILE64_H__A4393119_C187_4044_89A5_FA837C35AB44__INCLUDED_)
#define AFX_FILE64_H__A4393119_C187_4044_89A5_FA837C35AB44__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "File.h"
#include "List.h"

class File64 : public File
{
public:
	PIMAGE_NT_HEADERS pNthdr;
	PIMAGE_NT_HEADERS64 pNthdr64;
	void *pImageBase;

	File64(TCHAR *pszFileName);
	virtual ~File64();

	void CheckDependencies();
};

#endif // !defined(AFX_FILE64_H__A4393119_C187_4044_89A5_FA837C35AB44__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\depend.cpp ===
#include <string.h>
#include <iostream>
#include <io.h>
#include <stdio.h>
#include <windows.h>
#include <new.h>
#include "List.h"
#include "File.h"
#include "File32.h"
#include "File64.h"
#include "Object.h"
#include "depend.h"

List* pQueue;
List* pDependQueue;
List* pSearchPath;
List* pMissingFiles;
bool bNoisy;
bool bListDependencies;
DWORD dwERROR;

//
// Global variables used to get formatted message for this program.
//
HMODULE ThisModule = NULL;
WCHAR   Message[4096];

// Define a function to be called if new fails to allocate memory.
//
int __cdecl MyNewHandler( size_t size )
{
    
    _putws( GetFormattedMessage( ThisModule,
                                 FALSE,
                                 Message,
                                 sizeof(Message)/sizeof(Message[0]),
                                 MSG_MEM_ALLOC_FAILED) );
    // Exit program
    //
    ExitProcess(errOUT_OF_MEMORY);
}



/*
  usage: depend [/s] [/l] /f:filespec;filespec;... [/d:directory;directory;..]
  If directories are not specififed the Windows search path will be used to look for dependencies
  /s Specifies silent mode.
  filespec - file path and name. Can include wildcards.
*/
DWORD _cdecl wmain(int argc,wchar_t *argv[]) {

    // Set the failure handler for new operator.  
    //
    _set_new_handler( MyNewHandler );

    TCHAR *pszFileName = new TCHAR[256];
    File* pTempFile,*pCurrentFile;
    StringNode* pCurFile; 
    char buf[256];

    dwERROR = 0;
    pSearchPath = 0;
    bNoisy = true;
    bListDependencies = false;
    pQueue = new List();
    pDependQueue = new List();
    pMissingFiles = new List();

    ThisModule = GetModuleHandle(NULL);
    
    //Load the initial files into the queue and load the search path
    if (!ParseCommandLine(argc,argv)) goto CLEANUP;

    pCurFile = (StringNode*)pQueue->tail;

    //while the queue isn't empty
    while (pCurFile!=0) {
        WideCharToMultiByte(CP_ACP,0,pCurFile->Data(),-1,buf,256,0,0);
        
        //get a file pointer for the current file
        if (!(pCurrentFile = CreateFile(pCurFile->Data()))) {
            
            if (bListDependencies) {
                StringNode* s;
                if (s = (StringNode*)pDependQueue->Find(pCurFile->Data())) {
                    pDependQueue->Remove(pCurFile->Data());
                }
            }

            //if there was an error and we are running in silent mode, quit
            if (!bNoisy) goto CLEANUP;
        } 
        else {  //if we got a file pointer, proceed

            if (bListDependencies) {
                StringNode* s;
                if (s = (StringNode*)pDependQueue->Find(pCurFile->Data())) {
                    pDependQueue->Remove(pCurFile->Data());
                    pDependQueue->Add(pCurrentFile);
                }
            }

            //Check this files dependencies
            pCurrentFile->CheckDependencies();

            if ((dwERROR)&&(!bNoisy)) goto CLEANUP;

            //Close the file
            pCurrentFile->CloseFile();
        }

        //next file
        pCurFile = (StringNode*)pCurFile->prev;
    }
    StringNode* s;
    //if list dependencies is set, print out all dependencies
    if (bListDependencies) {
        pCurrentFile = (File*)pDependQueue->head;

        //while the queue isn't empty
        while (pCurrentFile!=0) {
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_DEPENDENCY_HEAD,
                                        pCurrentFile->Data()) );
            s = (StringNode*)pCurrentFile->dependencies->head;
            while(s) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_FILE_NAME,
                                            s->Data()) );
                s = (StringNode*)s->next;
            }
            pCurrentFile = (File*)pCurrentFile->next;       
        }
    }

    //print out list of broken files
    pTempFile = (File*)pMissingFiles->head;
    while (pTempFile) {
        if(bNoisy){
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_LIST_OF_BROKEN_FILES,
                                        pTempFile->Data()) );
        }
        s = (StringNode*)pTempFile->owners->head;
        while(s) {
            if(bNoisy) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_FILE_NAME,
                                            s->Data()) );
            }
            s = (StringNode*)s->next;
        }
        pTempFile = (File*)pTempFile->next;
    }

    //Done.  Clean up and go home.
    if(bNoisy) {
        _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_COMPLETED) );
    }
CLEANUP:

    delete [] pszFileName;
    delete pQueue;
    delete pDependQueue;
    delete pMissingFiles;

    pszFileName = 0;pQueue = 0;
    pDependQueue = 0; pMissingFiles = 0;

    return dwERROR;
}

//Given path and filename in 'pathname', fill 'path' with just the path
void GetPath(TCHAR * pathname,TCHAR* path) {

    TCHAR* end,t;
    path[0] = '\0';
    
    //find last \ in the filename
    end = wcsrchr(pathname,'\\');
    if (!end) return;

    //copy just the path
    t = end[1];
    end[1] = '\0';
    wcscpy(path,pathname);
    end[1] = t;

    return;
}

/*Fill queue with the files in the command line and fill searchpath with directories in command line
  usage: depend [/s] /f:filespec;filespec;... [/d:directory;directory;..]
  If directories are not specififed the Windows search path will be used to look for dependencies
  /s Specifies silent mode.
  filespec - file path and name. Can include wildcards.
*/
bool ParseCommandLine(int argc,wchar_t* argv[]){
    HANDLE handle;
    int nArg,nFile = 0;
    TCHAR *pszDirectory = new TCHAR[256],*pszFileName = new TCHAR[256],*ptr;
    WIN32_FIND_DATA fileData;
    bool bReturn;

    if (argc==1) {
    //if there are no arguments, display some kind of help
        if(bNoisy) {
            _putws( GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_PGM_USAGE) );
        }
        bReturn = false;
        dwERROR = errBAD_ARGUMENTS;
        goto CLEANUP;
    }

    for (nArg=1;nArg<argc;nArg++) {
        
        if (argv[nArg][0] == '/') {
            //if this is the files argument
            if (argv[nArg][1] == 'f') {

                do {
                    ptr = wcschr(argv[nArg]+3,';');
                    if (ptr) {
                        *ptr = '\0';
                        wcscpy(pszFileName,ptr+1);
                    } else wcscpy(pszFileName,argv[nArg]+3);

                    //get the first file, put the path in pszDirectory
                    handle = FindFirstFile(pszFileName,&fileData);
                    GetPath(pszFileName,pszDirectory);
                    if (*pszDirectory=='\0') {
                        GetCurrentDirectory(256,pszDirectory);
                        pszDirectory[wcslen(pszDirectory)+1] = '\0';
                        pszDirectory[wcslen(pszDirectory)] = '\\';
                    }


                    //if the file wasn't found, error and quit
                    if (handle == INVALID_HANDLE_VALUE) {
                        if(bNoisy) {
                            _putws( GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_ARG_NOT_FOUND,
                                    argv[nArg]) );
                        }
                        dwERROR = errFILE_NOT_FOUND;
                        bReturn = false;
                        goto CLEANUP;
                    }
                     
                    //put each file into the queue
                    nFile = 1;
                    while (nFile) {
                        //standardize the name:  full path, all lowercase
                        wcscpy(pszFileName,pszDirectory);
                        wcscat(pszFileName,fileData.cFileName);
                        _wcslwr(pszFileName);

                        //add the file to the queue if it's not already there
                        if (!pQueue->Find(pszFileName)) pQueue->Add(new StringNode(pszFileName));

                        //if list all dependencies is set, add to dependQueue
                        if (bListDependencies) 
                            if (!pDependQueue->Find(pszFileName)) 
                                pDependQueue->Add(new StringNode(pszFileName));

                        nFile = FindNextFile(handle,&fileData);
                    }//end while files
                } while (ptr);          
            
            } else if (argv[nArg][1] == 'd') {

                //load directories
                pSearchPath = new List();

                do {
                    ptr = wcschr(argv[nArg]+3,';');
                    if (ptr) {
                        *ptr = '\0';
                        wcscpy(pszDirectory,ptr+1);
                    } else wcscpy(pszDirectory,argv[nArg]+3);
                    if (pszDirectory[wcslen(pszDirectory)-1]!='\\') {
                        pszDirectory[wcslen(pszDirectory)+1] = '\0';
                        pszDirectory[wcslen(pszDirectory)] = '\\';
                    }
                    pSearchPath->Add(new StringNode(pszDirectory));
                } while (ptr);
                
            } else 
                //if silent mode, turn off noisy flag
                if (argv[nArg][1] == 's') bNoisy = false;
              
            else 
                //if you want to list the dependencies of all files
                //turn on this flag
                if (argv[nArg][1] == 'l') bListDependencies = true;
            else 
            {
                //unrecognized flag
                if(bNoisy) {
                    _putws( GetFormattedMessage(ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_BAD_ARGUMENT,
                                                argv[nArg]) );
                }
                dwERROR = errBAD_ARGUMENTS;
                bReturn = false;
                goto CLEANUP;
            }
        } else {
            //didn't start with a /
            if(bNoisy) {
                _putws( GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_BAD_ARGUMENT,
                                            argv[nArg]) );
            }
            dwERROR = errBAD_ARGUMENTS;
            bReturn = false;
            goto CLEANUP;
        }

    }//end for arguments

    bReturn = true;

CLEANUP:

    delete[] pszFileName;
    delete[] pszDirectory;
    pszFileName = pszDirectory = 0;
    
    return bReturn;
}

//Search for the given file in the given path
//Arguments:
//pszFileName - file to look for
//pszPathName - path to look for it in
bool SearchPath(TCHAR* pszFileName,TCHAR* pszPathName) {
    StringNode* s;
    WIN32_FIND_DATA buf;

    if (!pSearchPath) return false;

    s = (StringNode*)pSearchPath->head;

    while (s) {
        wcscpy(pszPathName,s->Data());
        wcscat(pszPathName,pszFileName);
        if (FindFirstFile(pszPathName,&buf)!=INVALID_HANDLE_VALUE) return true;
        s = (StringNode*)s->next;
    }

    pszPathName = 0;
    return false;
}

//Determine what type of file was passed in (16 bit,32,64) and create the appropriate file ptr.
//pszFileName - file to be loaded
    File* CreateFile(TCHAR* pszFileName) {

    try {
        return new File32(pszFileName);
        
    } catch(int x) {
        if (x == errFILE_LOCKED) return 0;
        try {
            return new File64(pszFileName);
        } catch(int x) {
            if (x == errFILE_LOCKED) return 0;
            if (bNoisy) {
                _putws( GetFormattedMessage(ThisModule,
                        FALSE,
                        Message,
                        sizeof(Message)/sizeof(Message[0]),
                        MSG_ERROR_UNRECOGNIZED_FILE_TYPE,
                        pszFileName) );
            }
            return 0;
        }
    }


    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\list.h ===
// List.h: interface for the List class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LIST_H__8579C184_3703_4719_8FCB_5A91A9CA7E4E__INCLUDED_)
#define AFX_LIST_H__8579C184_3703_4719_8FCB_5A91A9CA7E4E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Object.h"
class List  
{
public:
	Object* head,*tail;
	int length;

	List();
	virtual ~List();

	void Add(Object* o);
	void Remove(TCHAR* s);

	Object* Find(Object* o);
	Object* Find(TCHAR* s);

};

#endif // !defined(AFX_LIST_H__8579C184_3703_4719_8FCB_5A91A9CA7E4E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\object.cpp ===
// Object.cpp: implementation of the Object class.
//
//////////////////////////////////////////////////////////////////////

#include "Object.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

Object::Object()
{
	next = prev = 0;
}

TCHAR* Object::Data() { return 0; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\file64.cpp ===
// File64.cpp: implementation of the File64 class.
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include "File64.h"
#include "depend.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//pszFileName - file to be loaded, including path
File64::File64(TCHAR *pszFileName) : File(pszFileName)
{
    HANDLE hFileMap;

    //open the file
    if ((hFile = CreateFile(pszFileName,GENERIC_READ,0,0,OPEN_EXISTING,0,0)) == INVALID_HANDLE_VALUE) {
        if(bNoisy) {
            _putws( GetFormattedMessage( ThisModule,
                                         FALSE,
                                         Message,
                                         sizeof(Message)/sizeof(Message[0]),
                                         MSG_ERROR_FILE_OPEN,
                                         pszFileName) );
        }
    	dwERROR = errFILE_LOCKED;
    	throw errFILE_LOCKED;
    }

    //create a memory map
    hFileMap = CreateFileMapping(hFile,0,PAGE_READONLY,0,0,0);
    pImageBase = MapViewOfFile(hFileMap,FILE_MAP_READ,0,0,0);


    //try to create an NTHeader structure to give file information
    if (pNthdr = ImageNtHeader(pImageBase)) {
    	if ((pNthdr->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) ||
            (pNthdr->FileHeader.Machine == IMAGE_FILE_MACHINE_IA64)) {
    		pNthdr64 = (PIMAGE_NT_HEADERS64)pNthdr;
    		return;
    	}
    	 else { CloseHandle(hFile); hFile = INVALID_HANDLE_VALUE; throw 0; }
    } else { CloseHandle(hFile); hFile = INVALID_HANDLE_VALUE; throw 0; }
		 
}

File64::~File64()
{
	delete pImageBase;
	pImageBase = 0;
}

//Checks the dependencies of this file, and adds the dependencies to the queue so 
//their dependencies can be checked later
//If a file comes up missing add it to the MissingFiles queue. Add the file that was looking for it to the missing files'
//list of broken files.

//This function has logic in it to handle the special case of 'ntoskrnl.exe'.  If a file is 
//looking for 'ntoskrnl.exe' and it is missing then the function also looks for 'ntkrnlmp.exe'
void File64::CheckDependencies() {
	char *pszDllName = new char[256];
	TCHAR*pwsDllName = new TCHAR[256],*pszBuf = new TCHAR[256],*pszBufName;
	int temp = 0;
	File* pTempFile;
	DWORD dwOffset;
	
	DWORD dwVA = pNthdr64->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
	PIMAGE_SECTION_HEADER pSectHdr = IMAGE_FIRST_SECTION( pNthdr64 ),pImportHdr = 0;
	PIMAGE_IMPORT_DESCRIPTOR pImportDir;

	//figure out which section the imports table is in
	for ( unsigned i = 0; i < pNthdr64->FileHeader.NumberOfSections; i++, pSectHdr++ ) {
		DWORD cbMaxOnDisk = min( pSectHdr->Misc.VirtualSize, pSectHdr->SizeOfRawData );

		DWORD startSectRVA = pSectHdr->VirtualAddress;
		DWORD endSectRVA = startSectRVA + cbMaxOnDisk;
 
		if ( (dwVA >= startSectRVA) && (dwVA < endSectRVA) ) {
			dwOffset =  pSectHdr->PointerToRawData + (dwVA - startSectRVA);
			pImportHdr = pSectHdr;
			i = pNthdr64->FileHeader.NumberOfSections;
		}
	}

	//if we found the imports table, create a pointer to it
	if (pImportHdr) {
		pImportDir = (PIMAGE_IMPORT_DESCRIPTOR) (((PBYTE)pImageBase) + (DWORD)dwOffset);

		//go through each import, try and find it, and add it to the queue
		while ((DWORD)(pImportDir->Name)!=0) {
			strcpy(pszDllName,(char*)(pImportDir->Name + ((PBYTE)pImageBase) - pImportHdr->VirtualAddress + pImportHdr->PointerToRawData));
			_strlwr(pszDllName);

			//if the ListDependencies flag is set, add this file to the dependencies list
			if (bListDependencies) {
				MultiByteToWideChar(CP_ACP,0,pszDllName,-1,pwsDllName,256);
				if (!dependencies->Find(pwsDllName)) dependencies->Add(new StringNode(pwsDllName));	
			}

			if (strcmp(pszDllName,"ntoskrnl.exe")) {
				//if the file is already known to be missing
				temp = MultiByteToWideChar(CP_ACP,0,pszDllName,-1,pwsDllName,256);
				if (pTempFile = (File*)pMissingFiles->Find(pwsDllName)) {
					dwERROR = errMISSING_DEPENDENCY;
					//add this file to the list of broken files
					pTempFile->AddDependant(new StringNode(fileName));
				} else { 
					//either search the windows path or the path specified in the command line
					if ( ((!pSearchPath)&&(!(SearchPath(0,pwsDllName,0,256,pszBuf,&pszBufName))))|| ((pSearchPath)&&(!SearchPath(pwsDllName,pszBuf))) ) {
						//if the file is not found, add it to missing files list and throw an error
						pMissingFiles->Add(new File(pwsDllName));
						((File*)(pMissingFiles->head))->AddDependant(new StringNode(fileName));
						dwERROR = errMISSING_DEPENDENCY;
						if (!bNoisy) goto CLEANUP;
					}
					else {
						//if the file is found, add it to the queue	
						_wcslwr(pszBuf);
						if (!(pQueue->Find(pszBuf))) pQueue->Add(new StringNode(pszBuf));	
					}
				}	
			} else {
				//if the file is already known to be missing
				if ((pTempFile = (File*)pMissingFiles->Find(L"ntoskrnl.exe"))) {
					dwERROR = errMISSING_DEPENDENCY;
					pTempFile->AddDependant(new StringNode(fileName));
				} else { 
					//either search the windows path or the path specified in the command line
					if ( (((!pSearchPath)&&(!(SearchPath(0,L"ntoskrnl.exe",0,256,pszBuf,&pszBufName))))||((pSearchPath)&&(!SearchPath(L"ntoskrnl.exe",pszBuf)))) 
						&&(((!pSearchPath)&&(!(SearchPath(0,L"ntkrnlmp.exe",0,256,pszBuf,&pszBufName))))||((pSearchPath)&&(!SearchPath(L"ntkrnlmp.exe",pszBuf))))) {
						//if the file is not found, add it to missing files list and throw an error
						pMissingFiles->Add(new File(L"ntoskrnl.exe"));
						((File*)(pMissingFiles->head))->AddDependant(new StringNode(fileName));
						dwERROR = errMISSING_DEPENDENCY;
						if (!bNoisy) goto CLEANUP;
					}
					else {
						//if the file is found, add it to the queue	
						_wcslwr(pszBuf);
						if (!(pQueue->Find(pszBuf))) pQueue->Add(new StringNode(pszBuf));
					}
				}						
			}
			pImportDir++;
		}
	}

CLEANUP:

	delete [] pszDllName;
	delete [] pszBuf;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\object.h ===
// Object.h: interface for the Object class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_OBJECT_H__21BA586D_FABE_44C0_AED8_D3175686C1F1__INCLUDED_)
#define AFX_OBJECT_H__21BA586D_FABE_44C0_AED8_D3175686C1F1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
class Object  
{
public:
	Object* next,*prev;

	Object();

	virtual TCHAR* Data();

};

#endif // !defined(AFX_OBJECT_H__21BA586D_FABE_44C0_AED8_D3175686C1F1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\stringnode.cpp ===
// String.cpp: implementation of the String class.
//
//////////////////////////////////////////////////////////////////////

#include "StringNode.h"
#include <string.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

StringNode::StringNode(TCHAR* s) : Object()
{
	str = new TCHAR[wcslen(s)+1];
	
    if ( str ) wcscpy(str,s);
}

TCHAR* StringNode::Data() {
	return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\stringnode.h ===
// String.h: interface for the String class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRING_H__A4E3AB51_211E_4A38_827E_E54BC1C30803__INCLUDED_)
#define AFX_STRING_H__A4E3AB51_211E_4A38_827E_E54BC1C30803__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Object.h"

class StringNode : public Object
{
public:
	TCHAR * str;

	StringNode(TCHAR* s);

	TCHAR* Data();

};

#endif // !defined(AFX_STRING_H__A4E3AB51_211E_4A38_827E_E54BC1C30803__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\depend\list.cpp ===
// List.cpp: implementation of the List class.
//
//////////////////////////////////////////////////////////////////////

#include "List.h"
#include "Object.h"
#include <string.h>
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

List::List()
{
	head = tail = 0;
	length = 0;
}

List::~List()
{
	Object* o,*p;
	o = head;
	if (o) p = o->next;
	while (o) {
		delete o; 
		o = p;
		if (o) p = o->next;
	}

}

void List::Add(Object* o) {
	if (o==0) return;

	if (head==0) {
		head = tail = o;
		length = 1;
		return;
	}

	o->next = head;
	head->prev = o;
	head = o;
	length++;

}

void List::Remove(TCHAR* s) {
	if (s==0) return;
	
	Object* ptr = head;
	while(ptr) {
		if (!wcscmp(s,ptr->Data())) {
			if (ptr->prev) ptr->prev->next = ptr->next;
			if (ptr->next) ptr->next->prev = ptr->prev;
			length--;
			if (ptr==head) head = ptr->next;
		}
		ptr = ptr->next;
	}

}

Object* List::Find(TCHAR* s) {
	Object* ptr = head;

	if (s==0) return 0;

	while (ptr!=0) {
		if (wcscmp(ptr->Data(),s)==0) return ptr;
		ptr = ptr->next;
	}

	return 0;
}

Object* List::Find(Object* o) {
	Object* ptr = head;

	if (o==0) return 0;

	while (ptr!=0) {
		if (wcscmp(ptr->Data(),o->Data())==0) return ptr;
		ptr = ptr->next;
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\dskimage\dskimage.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dskimage.cpp

Abstract:

    Tool to create images of floppy disks.

    NOTE: Currently used by WinPE image creation
    script for IA64 ISO CD image

Author:

    Vijay Jayaseelan (vijayj)   12 March 2001

Revision History:

    None.
    
--*/

#include <iostream>
#include <string>
#include <windows.h>
#include "msg.h"
#include <libmsg.h>

//
// Global variables used to get formatted message for this program.
//
HMODULE ThisModule = NULL;
WCHAR Message[4096];

//
// Helper dump operators
//
inline
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fputws(str.c_str(), OutStream);
    return os;
}

inline
std::ostream& operator<<(std::ostream &os, PCTSTR str) {
    return os << std::wstring(str);
}

//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;
        if (GetFormattedMessage(ThisModule,
                                TRUE,
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(MsgBuffer[0]),
                                ErrorCode)){
            std::wstring Msg(MsgBuffer);
            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Invalid arguments
//
struct ProgramUsage : public ProgramException {
    std::wstring PrgUsage;

    ProgramUsage(const std::wstring &Usg) : PrgUsage(Usg) {}
    
    const char *what() const throw() {
        return "Program Usage exception";
    }

    void Dump(std::ostream &os) {
        
        os << PrgUsage << std::endl;
        
    }
};


//
// Argument cracker
//
struct ProgramArguments {
    std::wstring    DriveLetter;
    std::wstring    ImageName;

    ProgramArguments(int Argc, wchar_t *Argv[]) {
        bool ValidArgs = false;
        bool ShowUsage = false;

        for (ULONG Index = 1; !ShowUsage && (Index < Argc); Index++) {
            ShowUsage = !_wcsicmp(Argv[Index], TEXT("/?"));
        }
        
        if (!ShowUsage && (Argc > 2)) {
            DriveLetter = Argv[1];
            ImageName = Argv[2];

            ValidArgs = ((DriveLetter.length() == 2) &&
                         (DriveLetter[1] == TEXT(':')));
        }            

        if (!ValidArgs) {
            throw new ProgramUsage(GetFormattedMessage( ThisModule,
                                                        FALSE,
                                                        Message,
                                                        sizeof(Message)/sizeof(Message[0]),
                                                        MSG_PGM_USAGE));
        }

        DriveLetter = TEXT("\\\\.\\") + DriveLetter;
    }

    friend std::ostream& operator<<(std::ostream &os, const ProgramArguments &Args) {
        os << GetFormattedMessage(  ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_DRVLETTER_AND_IMGNAME,
                                    Args.DriveLetter,
                                    Args.ImageName) << std::endl;
        return os;
    }
};

//
// Prototypes
//
VOID
CreateImage(
    IN const ProgramArguments &Args
    )
{
    DWORD Error = ERROR_SUCCESS;

    //
    // Open the source file
    //
    HANDLE  SourceHandle = CreateFile(Args.DriveLetter.c_str(),
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);


    if (SourceHandle == INVALID_HANDLE_VALUE) {
        throw new W32Error();
    }

    //
    // Open the destination file
    //
    HANDLE  DestHandle = CreateFile(Args.ImageName.c_str(),
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

    if (DestHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();

        CloseHandle(SourceHandle);
        throw new W32Error(Error);
    }

    //
    // Read contents of the source and write it to destination
    //
    LPBYTE   lpBuffer = NULL;
    DWORD    BufferSize = 64 * 1024;
    DWORD    BytesRead = 0, BytesWritten = 0;
    LONGLONG TotalBytesWritten = 0;

    lpBuffer = (LPBYTE) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, BufferSize );
    if ( lpBuffer )
    {
        while (ReadFile(SourceHandle, lpBuffer, BufferSize, &BytesRead, NULL) &&
               BytesRead &&
               WriteFile(DestHandle, lpBuffer, BytesRead, &BytesWritten, NULL) &&
               (BytesRead == BytesWritten)) 
        {
            TotalBytesWritten += BytesWritten;           
            BytesRead = BytesWritten = 0;
        }

        HeapFree( GetProcessHeap(), 0, lpBuffer);
    }

    //
    // Cleanup
    //
    Error = GetLastError();
    CloseHandle(SourceHandle);
    CloseHandle(DestHandle);

    //
    // Check, if the operation was successful ?
    //
    if (!TotalBytesWritten || (BytesRead != BytesWritten)) {
        throw new W32Error(Error);
    }
}

//
// Main entry point
//
INT
__cdecl
wmain(
    IN INT  Argc, 
    IN WCHAR *Argv[]
    )
{
    INT Result = 0;
    ThisModule = GetModuleHandle(NULL);
    
    try {
        ProgramArguments    Args(Argc, Argv);

        CreateImage(Args);
    }
    catch(W32Error *Error) {
        if (Error) {
            Result = (INT)(Error->ErrorCode);
            Error->Dump(std::cout);
            delete Error;
        }                
    }
    catch(ProgramException *Exp) {
        if (Exp) {
            Exp->Dump(std::cout);
            delete Exp;
        }            
    }
    catch(...) {
        Result = 1;
    } 

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\autologon.c ===
#include "factoryp.h"
#include <regstr.h>

// [ComputerSettings]
// AuditAdminAutoLogon=Yes
// AutoLogon=Yes
//
#define REGSTR_PATH_WINNTLOGON  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEFAULT_PWD             TEXT("")
#define DEFAULT_VALUE           TEXT("1")

BOOL AutoLogon(LPSTATEDATA lpStateData)
{
    HKEY    hKey;
    BOOL    fReturn = FALSE;

    // Check the winbom to make sure they want the auto logon set.
    //
    if ( !DisplayAutoLogon(lpStateData) )
    {
        return TRUE;
    }

    // Now open the key and set the required values (see KB article Q253370).
    //
    if ( ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_WINNTLOGON, &hKey) )
    {
        LPTSTR lpszUserName = AllocateString(NULL, ( GetSkuType() == VER_SUITE_PERSONAL ) ? IDS_OWNER : IDS_ADMIN);

        // The following three keys sets the auto admin logon after reboot.  If the
        // password is empty string the AutoAdminLogon will be reset after reboot.
        //
        // 
        if ( ( lpszUserName ) &&
             ( ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("DefaultUserName"), 0, REG_SZ, (LPBYTE) lpszUserName, (lstrlen(lpszUserName)  + 1) * sizeof(TCHAR)) ) &&
             ( ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("DefaultPassword"), 0, REG_SZ, (LPBYTE) DEFAULT_PWD,  (lstrlen(DEFAULT_PWD)   + 1) * sizeof(TCHAR)) ) &&
             ( ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("AutoAdminLogon"),  0, REG_SZ, (LPBYTE) DEFAULT_VALUE,(lstrlen(DEFAULT_VALUE) + 1) * sizeof(TCHAR)) ) &&
             ( ERROR_SUCCESS == RegDeleteValue(hKey, TEXT("AutoLogonCount")) ) )
        {
            fReturn = TRUE;
        }

        // Force so subsequent reboots won't reset AutoAdminLogon because of empty password.
        //
        // We don't need to force autologon for every reboot since the [ComputerSettings] section will be processed for
        // every boot.
        //
        //   ( ERROR_SUCCESS == RegSetValueEx(hKey, TEXT("ForceAutoLogon"),  0, REG_SZ, (LPBYTE) DEFAULT_VALUE, (lstrlen(DEFAULT_VALUE) + 1) * sizeof(TCHAR)) )

        // Free the allocated user name (macro checks for NULL).
        //
        FREE(lpszUserName);

        // Close the registry key.
        //
        RegCloseKey(hKey);
    }

    return fReturn;
}

BOOL DisplayAutoLogon(LPSTATEDATA lpStateData)
{
    return ( IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_AUTOLOGON_OLD, INI_VAL_WBOM_YES) ||
             IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_AUTOLOGON, INI_VAL_WBOM_YES) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\extpart.c ===
/****************************************************************************\

    EXTPART.C / Factory Mode (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file for Factory that contains the extend partition state
    functions.

    05/2001 - Jason Cohen (JCOHEN)

        Added this new source file for factory for extending the system
        partition.

\****************************************************************************/


//
// Include File(s):
//

#include "factoryp.h"


//
// Internal Define(s):
//

#define ENV_SYSTEMDRIVE     _T("%SystemDrive%")


//
// External Function(s):
//

BOOL ExtendPart(LPSTATEDATA lpStateData)
{
    BOOL    bRet = TRUE;
    LPTSTR  lpszDrive;
    ULONG   uSize;

    // Only need to do anything if the key exists.
    //
    if ( DisplayExtendPart(lpStateData) )
    {
        // At this point, if anything doesn't work we
        // should return FALSE.
        //
        bRet = FALSE;

        // Get the size to use for the partition.  If it is one, then just pass
        // zero so it uses all the free space.  We also need to know the drive
        // to extend.
        //
        uSize = (ULONG) GetPrivateProfileInt(INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_EXTENDPART, 0, lpStateData->lpszWinBOMPath);
        if ( ( uSize > 0 ) &&
             ( lpszDrive = AllocateExpand(ENV_SYSTEMDRIVE) ) )
        {
            bRet = SetupExtendPartition(*lpszDrive, (1 == uSize) ? 0 : uSize);
            FREE(lpszDrive);
        }
    }

    return bRet;
}

BOOL DisplayExtendPart(LPSTATEDATA lpStateData)
{
    return ( GetPrivateProfileInt(INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_EXTENDPART, 0, lpStateData->lpszWinBOMPath) > 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\font.c ===
/****************************************************************************\

    FONT.C / Factory / WinBOM (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    State code for customizing the font smoothing and cleartype settings.

    WINBOM.INI
    [ComputerSettings]
    FontSmoothing = ; Default is 'Standard'.

        Standard |  ; Will determine, based on the system speed, if font
                    ; smoothing is turned on or not.

        On |        ; Forces font smoothing on.  Should only be used if the
                    ; performance of the video card is known to give an
                    ; acceptable user experience with this option enabled.

        Off |       ; Forces font smoothing off.

        ClearType   ; Turns clear type and font smoothing on.  Should only be
                    ; used if the monitor is known to be an LCD screen and
                    ; that the system performance is known to be acceptable
                    ; with this option enabled.

    04/2001 - Jason Cohen (JCOHEN)
        Added source file for the state that customizes the font and 
        cleartype settings.

\****************************************************************************/


//
// Includes
//

#include "factoryp.h"


//
// Internal Defined Value(s):
//

#define REG_KEY_FONTSMOOTHING       _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VisualEffects\\FontSmoothing")
#define REG_VAL_DEFAULTBYFONTTEST   _T("DefaultByFontTest")
#define REG_VAL_DEFAULTVALUE        _T("DefaultValue")

#define REG_KEY_CLEARTYPE           _T("Control Panel\\Desktop")
#define REG_VAL_FONTSMOOTHING       _T("FontSmoothing")
#define REG_VAL_FONTSMOOTHINGTYPE   _T("FontSmoothingType")

#define REG_KEY_HORRID_CLASSES      _T("_Classes")
#define REG_KEY_HORRID_CLASSES_LEN  ( AS(REG_KEY_HORRID_CLASSES) - 1 )


//
// Internal Function Prototype(s):
//

static BOOL RegSetAllUsers(LPTSTR lpszSubKey, LPTSTR lpszValue, LPBYTE lpData, DWORD dwType);


//
// Exported Function(s):
//

BOOL SetFontOptions(LPSTATEDATA lpStateData)
{
    LPTSTR  lpszWinBOMPath          = lpStateData->lpszWinBOMPath;
    TCHAR   szFontSmoothing[256]    = NULLSTR,
            szFontSmoothingData[]   = _T("_");
    DWORD   dwDefaultByFontTest,
            dwDefaultValue,
            dwFontSmoothingType;
    BOOL    bRet                    = TRUE;

    // Get the option from the winbom.
    //
    GetPrivateProfileString(INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_FONTSMOOTHING, NULLSTR, szFontSmoothing, AS(szFontSmoothing), lpszWinBOMPath);

    // Figure out what values to write based on the value in the winbom.
    //
    if ( NULLCHR == szFontSmoothing[0] )
    {
        // No key, do nothing and do not touch whatever options already set.
        //
        return TRUE;
    }
    else if ( LSTRCMPI(szFontSmoothing, INI_VAL_WBOM_FONTSMOOTHING_ON) == 0 )
    {
        // Force font smoothing on.
        //
        dwDefaultByFontTest    = 0;
        dwDefaultValue         = 1;
        dwFontSmoothingType    = 1;
        szFontSmoothingData[0] = _T('2');
    }
    else if ( LSTRCMPI(szFontSmoothing, INI_VAL_WBOM_FONTSMOOTHING_OFF) == 0 )
    {
        // Force font smoothing off.
        //
        dwDefaultByFontTest    = 0;
        dwDefaultValue         = 0;
        dwFontSmoothingType    = 0;
        szFontSmoothingData[0] = _T('0');
    }
    else if ( LSTRCMPI(szFontSmoothing, INI_VAL_WBOM_FONTSMOOTHING_CLEARTYPE) == 0 )
    {
        // Force font smoothing and cleartype on.
        //
        dwDefaultByFontTest    = 0;
        dwDefaultValue         = 1;
        dwFontSmoothingType    = 2;
        szFontSmoothingData[0] = _T('2');
    }
    else if ( LSTRCMPI(szFontSmoothing, INI_VAL_WBOM_FONTSMOOTHING_DEFAULT) == 0 )
    {
        // Let system decide if font smoothing should be on or not.
        //
        dwDefaultByFontTest    = 1;
        dwDefaultValue         = 0;
        dwFontSmoothingType    = 0;
        szFontSmoothingData[0] = _T('0');
    }
    else
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_WINBOMVALUE, lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_FONTSMOOTHING, szFontSmoothing);
        bRet = FALSE;
    }

    // Now save the settings if valid option passed in.
    //
    if ( bRet )
    {
        if ( !RegSetDword(HKLM, REG_KEY_FONTSMOOTHING, REG_VAL_DEFAULTBYFONTTEST, dwDefaultByFontTest) )
        {
            bRet = FALSE;
        }
        if ( !RegSetDword(HKLM, REG_KEY_FONTSMOOTHING, REG_VAL_DEFAULTVALUE, dwDefaultValue) )
        {
            bRet = FALSE;
        }
        if ( !RegSetAllUsers(REG_KEY_CLEARTYPE, REG_VAL_FONTSMOOTHINGTYPE, (LPBYTE) &dwFontSmoothingType, REG_DWORD) )
        {
            bRet = FALSE;
        }
        if ( !RegSetAllUsers(REG_KEY_CLEARTYPE, REG_VAL_FONTSMOOTHING, (LPBYTE) szFontSmoothingData, REG_SZ) )
        {
            bRet = FALSE;
        }
        //
        // ISSUE-2002/02/25-acosma,robertko - this is a duplicate of the REG_VAL_FONTSMOOTHINGTYPE set above - should be removed.
        //
        if ( !RegSetAllUsers(REG_KEY_CLEARTYPE, REG_VAL_FONTSMOOTHINGTYPE, (LPBYTE) &dwFontSmoothingType, REG_DWORD) )
        {
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL DisplaySetFontOptions(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_FONTSMOOTHING, NULL);
}


//
// Internal Function(s):
//

static BOOL RegSetAllUsers(LPTSTR lpszSubKey, LPTSTR lpszValue, LPBYTE lpData, DWORD dwType)
{
    BOOL    bRet = TRUE,
            bErr;
    LPTSTR  lpszKeyName;
    HKEY    hkeyEnum,
            hkeySub;
    DWORD   dwIndex     = 0,
            dwSize,
            dwDis,
            dwMaxSize;
    int     iLen;

    // Figure out the max length of any sub key and allocate a buffer for it.
    //
    if ( ( ERROR_SUCCESS == RegQueryInfoKey(HKEY_USERS,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &dwMaxSize,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL) ) &&

         ( lpszKeyName = (LPTSTR) MALLOC((++dwMaxSize) * sizeof(TCHAR)) ) )
    {
        // Now enumerate all the sub keys.
        //
        dwSize = dwMaxSize;
        while ( ERROR_SUCCESS == RegEnumKeyEx(HKEY_USERS,
                                              dwIndex++,
                                              lpszKeyName,
                                              &dwSize,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL) )
        {
            // Iterate over all users ignoring the keys with the "_Classes" suffix
            //
            if ( ( dwSize < REG_KEY_HORRID_CLASSES_LEN ) ||
                 ( 0 != LSTRCMPI(lpszKeyName + (dwSize - REG_KEY_HORRID_CLASSES_LEN), REG_KEY_HORRID_CLASSES) ) )
            {
                // Open up the sub key.
                //
                if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_USERS,
                                                   lpszKeyName,
                                                   0,
                                                   KEY_ALL_ACCESS,
                                                   &hkeyEnum) )
                {
                    // Set the value that was passed in.
                    //
                    switch ( dwType )
                    {
                        case REG_DWORD:
                            bErr = !RegSetDword(hkeyEnum, lpszSubKey, lpszValue, *((LPDWORD) lpData));
                            break;

                        case REG_SZ:
                            bErr = !RegSetString(hkeyEnum, lpszSubKey, lpszValue, (LPTSTR) lpData);
                            break;

                        default:
                            bErr = TRUE;
                            break;
                    }

                    // If anything fails, we keep going but return an error.
                    //
                    if ( bErr )
                    {
                        bRet = FALSE;
                    }

                    // Close the sub key that we enumerated.
                    //
                    RegCloseKey(hkeyEnum);
                }
            }

            // Reset the size for the next call to RegEnumKeyEx().
            //
            dwSize = dwMaxSize;
        }

        // Free the buffer we allocated.
        //
        FREE(lpszKeyName);
    }
    else
    {
        bRet = FALSE;
    }

    // Return TRUE if everything worked okay.
    //
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\homenet.c ===
/****************************************************************************\

    HOMENET.C / Factory Mode (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file for Factory that contains the home net state functions.

    05/2001 - Jason Cohen (JCOHEN)

        Added this new source file for factory for configuring the home
        networking settings.

\****************************************************************************/


//
// Include File(s):
//

#include "factoryp.h"


//
// Internal Define(s):
//

#define FILE_HOMENET_DLL    _T("HNETCFG.DLL")
#define FUNC_HOMENET        "WinBomConfigureHomeNet"


//
// Internal Type Definition(s):
//

/****************************************************************************\

BOOL                        // Returns TRUE if the settings were successfully
                            // read and saved to the system.  Otherwise
                            // returns FALSE to indicate something failed.
 

WinBomConfigureHomeNet(     // Reads home networking settings from the
                            // specified unattend file and saves those in
                            // current system that is already setup and
                            // running.

    LPCWSTR lpszUnattend,   // Points to a string buffer which contains the
                            // full path to the unattend file (winbom.ini in
                            // this case) with all the home network settings.

    LPCWSTR lpszSection     // Points to a string buffer which contains the
                            // name of the section which contains all the home
                            // network settings in the unattend file specified
                            // above.

);

\****************************************************************************/

typedef BOOL (WINAPI * WINBOMCONFIGUREHOMENET)
(
    LPCWSTR lpszUnattend,
    LPCWSTR lpszSection
);


//
// Internal Global(s):
//


//
// Internal Function Prototype(s):
//


//
// External Function(s):
//

BOOL HomeNet(LPSTATEDATA lpStateData)
{
    BOOL                    bRet = FALSE;
    HINSTANCE               hDll;
    WINBOMCONFIGUREHOMENET  pFunc;
    HRESULT                 hr;

    // Load the function from the external dll and call it.
    //
    if ( hDll = LoadLibrary(FILE_HOMENET_DLL) )
    {
        // Need to init the COM library.
        //
        hr = CoInitialize(NULL);
        if ( SUCCEEDED(hr) )
        {
            // Now call the function.
            //
            if ( pFunc = (WINBOMCONFIGUREHOMENET) GetProcAddress(hDll, FUNC_HOMENET) )
            {
                bRet = pFunc(lpStateData->lpszWinBOMPath, INI_SEC_HOMENET);
            }
#ifdef DBG
            else
            {
                FacLogFileStr(3, _T("DEBUG: GetProcAddress(\"WinBomConfigureHomeNet\") failed.  GLE=%d"), GetLastError());
            }
#endif
            CoUninitialize();
        }
#ifdef DBG
        else
        {
            FacLogFileStr(3, _T("DEBUG: HomeNet()::CoInitialize() failed.  HR=%8.8X"), hr);
        }
#endif
        FreeLibrary(hDll);
    }
#ifdef DBG
    else
    {
        FacLogFileStr(3, _T("DEBUG: LoadLibrary(\"%s\") failed.  GLE=%d"), FILE_HOMENET_DLL, GetLastError());
    }
#endif

    return bRet;
}

BOOL DisplayHomeNet(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_HOMENET, NULL, NULL);
}


//
// Internal Function(s):
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\efinvram\efinvram.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    efinvram.cpp

Abstract:

    Tool that allows you to edit/view EFI
    nvram entries.

Author:

    Vijay Jayaseelan (vijayj) 02-Feb-2001

Revision History:

    None

--*/

extern "C" {
#include <efisbent.h>
#include <setupapi.h>
}

#include <iostream>
#include <string>
#include <exception>
#include <windows.h>
#include <tchar.h>
#include <locale>
#include "msg.h"
#include <libmsg.h>

#define DEFAULT_NAME    L"Windows"
#define DEFAULT_TIMEOUT 30

//
// Global variables used to get formatted message for this program.
//
HMODULE ThisModule = NULL;
WCHAR Message[4096];

//
// function prototypes
//
NTSTATUS
QueryCanonicalName(
    IN  PCWSTR  Name,
    IN  ULONG   MaxDepth,
    OUT PWSTR   CanonicalName,
    IN  ULONG   SizeOfBufferInBytes
    );

VOID
GetFriendlyName(
    IN const std::wstring &InfFileName,
    OUT std::wstring &Buffer
    );

void
DeriveNtPathAndSrcPath(   
        IN  const std::wstring &FullPath, 
        OUT std::wstring &DrvDevicePath, 
        OUT std::wstring &DrvSrcPath 
        );
//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fwprintf(OutStream, (PWSTR)str.c_str());
    return os;
}

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, WCHAR *Str) {
    std::wstring WStr = Str;
    os << WStr;
    
    return os;
}

PWSTR GetOptionKey(ULONG MsgId) {
    Message[0] = TEXT('\0');
    
    GetFormattedMessage(ThisModule,
        FALSE,
        Message,
        sizeof(Message)/sizeof(Message[0]),
        MsgId);

    return Message;
}

//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};
          

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;
        if (GetFormattedMessage(ThisModule,
                                TRUE,
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(MsgBuffer[0]),
                                ErrorCode)){                  
            std::wstring Msg(MsgBuffer);
            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Invalid arguments
//
struct InvalidArguments : public ProgramException {
    const char *what() const throw() {
        return "Invalid Arguments";
    }

    void Dump(std::ostream &os) {
        os << what() << std::endl;
    }
};

//
// Invalid arguments
//
struct ProgramUsage : public ProgramException {

    std::wstring PrgUsage;

    ProgramUsage(const std::wstring &Usg) : PrgUsage(Usg) {}
    
    const char *what() const throw() {
        return "Program Usage exception";
    }

    void Dump(std::ostream &os) {
       
        os << PrgUsage << std::endl;
    }
};

//
// Program Arguments abstraction
//
struct ProgramArguments {
    bool ShowUsage;
    bool ListEntries;
    bool AddNewEntry;
    bool DeleteBootEntry;
    bool QuiteMode;
    bool SetActive;
    bool SetOsLoadOptions;
    bool SetTimeout;

    bool ListDrvEntries;
    bool AddDrvEntry;
    bool DelDrvEntry;
    
    std::wstring    LoaderVolumeName;
    std::wstring    LoaderPath;
    std::wstring    BootVolumeName;
    std::wstring    BootPath;
    std::wstring    LoadOptions;
    std::wstring    FriendlyName;
    std::wstring    OsLoadOptions;

    std::wstring    AddOptionKey;
    std::wstring    DeleteOptionKey;
    std::wstring    ListOptionKey;
    std::wstring    OptionsOptionKey;
    std::wstring    SetActiveOptionKey;
    std::wstring    TimeoutOptionKey;
    
    ULONG           Timeout;
    ULONG           EntryId;


    std::wstring    DrvDevicePath;
    std::wstring    FullPath;
    std::wstring    DrvSrcPath;                    
    std::wstring    DrvFriendlyName;
                        
    std::wstring    ListDrvOptionKey;
    std::wstring    AddDrvOptionKey;
    std::wstring    DelDrvOptionKey;

    ULONG           DrvId;

    
    
    ProgramArguments(INT Argc, WCHAR *Argv[]) {
        ShowUsage = false;        
        QuiteMode = false;
        ListEntries = AddNewEntry = DeleteBootEntry = false;
        ListDrvEntries = AddDrvEntry = DelDrvEntry = false;
        SetActive = false;
        EntryId = -1;
        Timeout = DEFAULT_TIMEOUT;
        SetTimeout = false;

        //
        // get all the options
        //
        ListOptionKey = GetOptionKey(MSG_LIST_OPTION);
        AddOptionKey = GetOptionKey(MSG_ADD_OPTION);
        DeleteOptionKey = GetOptionKey(MSG_DELETE_OPTION);
        OptionsOptionKey = GetOptionKey(MSG_OPTIONS_OPTION);
        SetActiveOptionKey = GetOptionKey(MSG_SETACTIVE_OPTION);
        TimeoutOptionKey = GetOptionKey(MSG_TIMEOUT_OPTION);
        ListDrvOptionKey = GetOptionKey(MSG_LISTDRV_OPTION);
        AddDrvOptionKey = GetOptionKey(MSG_ADDDRV_OPTION);
        DelDrvOptionKey = GetOptionKey(MSG_DELDRV_OPTION);        

        //
        // parse the arguments
        //
        for (ULONG Index=1; !ShowUsage && (Index < Argc); Index++) {    
            if (!_wcsicmp(Argv[Index], L"/q")) {
                QuiteMode = true;                
            } else if (!_wcsicmp(Argv[Index], AddOptionKey.c_str())) {  
                std::wstring  LoaderName;
                std::wstring  BootVolName;
                
                AddNewEntry = true;
                ShowUsage = true;

                if (Argc > 3) {
                    Index++;
                    LoaderName = Argv[Index++];
                    BootVolName = Argv[Index++];                    
                    ShowUsage = false;

                    for ( ; (Index < Argc) && (false == ShowUsage); Index++) {
                        if (!_wcsicmp(Argv[Index], SetActiveOptionKey.c_str())) {
                            SetActive = true;
                        } else if (!_wcsicmp(Argv[Index], OptionsOptionKey.c_str())) {
                            SetOsLoadOptions = true;
                            Index++;

                            if (Index < Argc) {
                                OsLoadOptions = Argv[Index];
                            } else {
                                ShowUsage = true;
                            }
                        } else if (!_wcsicmp(Argv[Index], TimeoutOptionKey.c_str())) {
                            SetTimeout = true;
                            Index++;

                            if (Index < Argc) {
                                PWSTR EndChar = NULL;
                                
                                Timeout = wcstoul(Argv[Index], &EndChar, 10);
                                
                                if (errno) {
                                    ShowUsage = true;
                                }
                            }
                        } else {
                            ShowUsage = true;
                        }
                    }
                    
                    //
                    // Verify the arguments
                    //
                    if (!ShowUsage) { 

                        NTSTATUS Status;
                        if (_waccess(LoaderName.c_str(), 0) || 
                            _waccess(BootVolName.c_str(), 0)) {
                            throw new W32Error(::GetLastError());
                        }        
                
                        //
                        // Get the fully qualified NT name for
                        // the the loader volume and boot volume
                        // name
                        //  

                        DeriveNtPathAndSrcPath(LoaderName, 
                                                LoaderVolumeName, 
                                                LoaderPath);

                        DeriveNtPathAndSrcPath(BootVolName, 
                                               BootVolumeName, 
                                               BootPath); 


                        if (BootVolName[BootVolName.length() - 1] != L'\\') {
                            BootVolName += L"\\";
                        }

                        std::wstring LayoutInf = BootVolName + L"inf\\layout.inf";
                                                
                        //
                        // Verify the inf file path
                        //                    
                        if (_waccess(LayoutInf.c_str(), 0)) {
                            throw new W32Error(::GetLastError());
                        }

                        //
                        // Extract the product friendly name for the inf file
                        //
                        GetFriendlyName(LayoutInf, FriendlyName);

                    }
                }

                break;                
            } else if (!_wcsicmp(Argv[Index], ListOptionKey.c_str())) {
                ListEntries = true;
                break;
            } else if (!_wcsicmp(Argv[Index], DeleteOptionKey.c_str())) {                
                DeleteBootEntry = true;
                Index++;
                
                if (Index < Argc) {
                    PWSTR EndChar = NULL;
                    
                    EntryId = wcstoul(Argv[Index], &EndChar, 10);
                } 
                
                break;
            } else if (!_wcsicmp(Argv[Index], L"/?") ||
               !_wcsicmp(Argv[Index], L"-?") ||
               !_wcsicmp(Argv[Index], L"?") ||
               !_wcsicmp(Argv[Index], L"/h") ||
               !_wcsicmp(Argv[Index], L"-h")) {
                    ShowUsage = true;                       
            } else if (!_wcsicmp(Argv[Index], OptionsOptionKey.c_str())) {
                Index++;
                SetOsLoadOptions = true;
                if (Index < Argc) {
                    OsLoadOptions = Argv[Index];
                    Index++;

                    if (Index < Argc) {
                        PWSTR EndChar = NULL;
                        
                        EntryId = wcstoul(Argv[Index], &EndChar, 10);
                    }
                }

                break;
            } else if (!_wcsicmp(Argv[Index], SetActiveOptionKey.c_str())) {
                Index++;
                SetActive = true;
                if (Index < Argc) {
                    PWSTR EndChar = NULL;
                    
                    EntryId = wcstoul(Argv[Index], &EndChar, 10);

                    if (errno) {
                        ShowUsage = true;
                    }
                } else {
                    ShowUsage = true;
                }
                
                break;
            } else if (!_wcsicmp(Argv[Index], TimeoutOptionKey.c_str())) {
                Index++;
                SetTimeout = true;
                if (Index < Argc) {
                    PWSTR EndChar = NULL;
                    
                    Timeout = wcstoul(Argv[Index], &EndChar, 10);

                    if (errno) {
                        ShowUsage = true;
                    }
                } else {
                    ShowUsage = true;
                }
            } else if (!_wcsicmp(Argv[Index], ListDrvOptionKey.c_str())){
                ListDrvEntries = true;
            } else if (!_wcsicmp(Argv[Index], AddDrvOptionKey.c_str())){
                if (Index + 2 < Argc){
                    
                     FullPath = Argv[++Index];

                     if (_waccess(FullPath.c_str(), 0)) {
                            throw new W32Error(::GetLastError());
                     }
                    DeriveNtPathAndSrcPath(FullPath, 
                                  DrvDevicePath, 
                                  DrvSrcPath);

                    DrvFriendlyName = Argv[++Index];
                    ShowUsage = false;    
                    AddDrvEntry = true;    
                }
                break;
            } else if (!_wcsicmp(Argv[Index], DelDrvOptionKey.c_str())){
                if (Index + 1 < Argc){
                    PWSTR EndChar = NULL;
                    
                    DrvId = wcstoul(Argv[++Index], &EndChar, 10);
                    ShowUsage = false;
                    DelDrvEntry = true;
                }
                break;
            } else {
                ShowUsage = true;
            }
        }            

        if (!ShowUsage) {
            ShowUsage = (!ListEntries && !AddNewEntry && !SetActive &&
                         !DeleteBootEntry && !SetOsLoadOptions && !SetTimeout &&
                         !ListDrvEntries && !AddDrvEntry && !DelDrvEntry);
        }                         

        if (ShowUsage) {
            throw new ProgramUsage(GetFormattedMessage( ThisModule,
                                                        FALSE,
                                                        Message,
                                                        sizeof(Message)/sizeof(Message[0]),
                                                        MSG_PGM_USAGE));
        }                        
    }

    friend std::ostream& operator<<(std::ostream &os, ProgramArguments &Args) {
        os << "List Entries : " << Args.ListEntries << std::endl;
        os << "Add Entry    : " << Args.AddNewEntry << std::endl;
        os << "Delete Entry : " << Args.DeleteBootEntry << std::endl;
        os << "QuiteMode    : " << Args.QuiteMode << std::endl;
        os << "Loader Vol   : " << Args.LoaderVolumeName << std::endl;
        os << "Loader Path  : " << Args.LoaderPath << std::endl;
        os << "Boot Vol     : " << Args.BootVolumeName << std::endl;
        os << "Boot Path    : " << Args.BootPath << std::endl;
        os << "Friendly Name: " << Args.FriendlyName << std::endl;
        os << "Load Options : " << Args.OsLoadOptions << std::endl;
        os << "Timeout      : " << std::dec << Args.Timeout << " Secs" << std::endl;
        
        return os;
    }
};

void
DeriveNtPathAndSrcPath(   
        IN  const std::wstring &FullPath, 
        OUT std::wstring &DrvDevicePath, 
        OUT std::wstring &DrvSrcPath 
        )
{
    WCHAR           CanonicalName[MAX_PATH];                        
    std::wstring    NtName;
    std::wstring    DosDevices = L"\\DosDevices\\";
    std::wstring::size_type ColonPos = FullPath.find(L':');    

    if (ColonPos != FullPath.npos) {
        NTSTATUS        Status = STATUS_UNSUCCESSFUL;                        
        
        NtName = DosDevices + FullPath.substr(0, ColonPos + 1);

        Status = QueryCanonicalName(NtName.c_str(),
                    -1,
                    CanonicalName,
                    sizeof(CanonicalName));

        if (NT_SUCCESS(Status)) {
            DrvDevicePath = CanonicalName;
            DrvSrcPath = FullPath.substr(ColonPos + 1);
        } else {
            throw new W32Error(RtlNtStatusToDosError(Status));
        }
    } else {
        throw new W32Error(ERROR_PATH_NOT_FOUND);
    }    
}

VOID
DumpOsBootEntry(
    IN  POS_BOOT_ENTRY  Entry
    )
{
    if (Entry) {
        wprintf(GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_BOOT_ENTRY,
                                        OSBEGetId(Entry),
                                        OSBEGetFriendlyName(Entry),
                                        OSBEGetOsLoaderVolumeName(Entry),
                                        OSBEGetOsLoaderPath(Entry),
                                        OSBEGetBootVolumeName(Entry),
                                        OSBEGetBootPath(Entry),
                                        OSBEGetOsLoadOptions(Entry)));
    }
}

VOID
DumpOsBootOptions(
    IN  POS_BOOT_OPTIONS Options
    )
{
    if (Options) {
        ULONG   Index;
        wprintf(GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_TIMEOUT_AND_BOOT_ORDER, 
                                        OSBOGetTimeOut(Options)));

        for (Index=0; 
            Index < OSBOGetOrderedBootEntryCount(Options);
            Index++) {
            wprintf(GetFormattedMessage(    ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_ORDERED_BOOT_ENTRIES,
                                            OSBOGetBootEntryIdByOrder(Options, Index)));
        }                                            
            
        wprintf(GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_BOOT_ENTRIES));

        POS_BOOT_ENTRY  Entry = OSBOGetFirstBootEntry(Options, &Index);
        
        while (Entry) {
            DumpOsBootEntry(Entry);
            Entry = OSBOGetNextBootEntry(Options, &Index);
        }
        wprintf(GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_ACTIVE_ENTRY));

        DumpOsBootEntry(OSBOGetActiveBootEntry(Options));
    }
}

DWORD
ListDriverEntry(
    IN POS_BOOT_OPTIONS OsOptions
    )
{
    DWORD Result = ERROR_INVALID_PARAMETER;

    if (OsOptions){
        PDRIVER_ENTRY   DrvEntry ;
    
        for (DrvEntry = OSBOGetFirstDriverEntry(OsOptions); 
             DrvEntry != NULL; 
             DrvEntry = OSBOGetNextDriverEntry(OsOptions,DrvEntry)){                  
                wprintf(GetFormattedMessage( ThisModule,
                                             FALSE,
                                             Message,
                                             sizeof(Message)/sizeof(Message[0]),
                                             MSG_DRIVER_ENTRY,
                                             OSDriverGetId(DrvEntry),
                                             OSDriverGetFriendlyName(DrvEntry),
                                             OSDriverGetFileName(DrvEntry),
                                             OSDriverGetDevicePath(DrvEntry),
                                             OSDriverGetFilePath(DrvEntry)));
        }
        Result = ERROR_SUCCESS;
    }
    return Result;
}

DWORD
ListEntries(
    IN POS_BOOT_OPTIONS OsOptions 
    )
{
    DWORD Result = ERROR_INVALID_PARAMETER;

    if (OsOptions) {
        DumpOsBootOptions(OsOptions);
        Result = ERROR_SUCCESS;
    }

    return Result;
}

DWORD
AddNewDriverEntry(
    IN POS_BOOT_OPTIONS OsOptions,
    IN ProgramArguments &Args    
    )
{
    DWORD Result = ERROR_INVALID_PARAMETER;
    if (OsOptions){
        PDRIVER_ENTRY NewDrvEntry =NULL;
        BOOLEAN Status = FALSE;
        
        NewDrvEntry = OSBOAddNewDriverEntry(OsOptions, 
                                            Args.DrvFriendlyName.c_str(), 
                                            Args.DrvDevicePath.c_str(),                                             
                                            Args.DrvSrcPath.c_str());
        if (NewDrvEntry) {            
                Status = OSBOFlush(OsOptions);
        }

        if (Status){
            Result = ERROR_SUCCESS;
        } else {
            Result = ERROR_CAN_NOT_COMPLETE;
        }   
    }
    return Result;
}

DWORD
AddNewEntry(
    IN POS_BOOT_OPTIONS OsOptions,
    IN ProgramArguments &Args
    )
{
    DWORD Result = ERROR_INVALID_PARAMETER;

    if (OsOptions) {
        POS_BOOT_ENTRY NewEntry;
        BOOLEAN Status = TRUE;
        
        NewEntry = OSBOAddNewBootEntry(OsOptions,
                        Args.FriendlyName.c_str(),
                        Args.LoaderVolumeName.c_str(),
                        Args.LoaderPath.c_str(),
                        Args.BootVolumeName.c_str(),
                        Args.BootPath.c_str(),
                        Args.OsLoadOptions.c_str());

        if (NewEntry) {            
            if (Args.SetActive) {
                Status = (OSBOSetActiveBootEntry(OsOptions,
                                NewEntry) != NULL);
            }
            
            if (Status && Args.SetTimeout) {
                OSBOSetTimeOut(OsOptions, Args.Timeout);
            }

            if (Status) {
                Status = OSBOFlush(OsOptions);
            }
        } else {
            Status = FALSE;
        }            

        if (Status) {
            Result = ERROR_SUCCESS;
        } else {
            Result = ERROR_CAN_NOT_COMPLETE;
        }            
    }

    return Result;
}

DWORD
SetBootEntryOptions(
    IN POS_BOOT_OPTIONS OsOptions,
    IN const ProgramArguments &Args
    )
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    if (OsOptions) {
        POS_BOOT_ENTRY  BootEntry;
        BOOLEAN Status = FALSE;

        if (Args.EntryId != -1) {
            BootEntry = OSBOFindBootEntry(OsOptions,
                            Args.EntryId);
        } else {
            BootEntry = OSBOGetActiveBootEntry(OsOptions);
        }            

        if (BootEntry) {
            Status = (OSBESetOsLoadOptions(BootEntry, 
                            Args.OsLoadOptions.c_str()) != NULL);

            if (Status) {
                Status = OSBOFlush(OsOptions);
            }                
        }                

        if (Status) {
            ErrorCode = ERROR_SUCCESS;
        } else {
            ErrorCode = ERROR_CAN_NOT_COMPLETE;
        }            
    }

    return ErrorCode;
}

DWORD
SetBootEntryActive(
    IN POS_BOOT_OPTIONS OsOptions,
    IN ProgramArguments &Args
    )
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    if (OsOptions && (Args.EntryId != -1)) {
        POS_BOOT_ENTRY  BootEntry;
        BOOLEAN Status = FALSE;

        BootEntry = OSBOFindBootEntry(OsOptions,
                        Args.EntryId);

        if (BootEntry) {
            Status = (OSBOSetActiveBootEntry(OsOptions,
                            BootEntry) != NULL);

            if (Status) {
                Status = OSBOFlush(OsOptions);
            }                
        }                

        if (Status) {
            ErrorCode = ERROR_SUCCESS;
        } else {
            ErrorCode = ERROR_CAN_NOT_COMPLETE;
        }            
    }
    
    return ErrorCode;
}

DWORD
DelDriverEntry(
    IN POS_BOOT_OPTIONS OsOptions,
    IN ProgramArguments &Args
    )
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;
    
    if (OsOptions){
        BOOLEAN Status = FALSE;
        
        Status = OSBODeleteDriverEntry(OsOptions, Args.DrvId);
        
        if (Status){
            Status = OSBOFlush(OsOptions);
        }

        if (Status){
            ErrorCode = ERROR_SUCCESS;
        } else {
            ErrorCode = ERROR_CAN_NOT_COMPLETE;
        }               
    }
    return ErrorCode;
}
    
DWORD
DeleteBootEntry(
    IN POS_BOOT_OPTIONS OsOptions,
    IN ProgramArguments &Args
    )
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    if (OsOptions) {
        POS_BOOT_ENTRY  BootEntry;
        BOOLEAN Status = FALSE;

        if (Args.EntryId != -1) {
            BootEntry = OSBOFindBootEntry(OsOptions,
                            Args.EntryId);
        } else {
            BootEntry = OSBOGetActiveBootEntry(OsOptions);
        }            

        if (BootEntry) {
            Status = OSBODeleteBootEntry(OsOptions, BootEntry);

            if (Status) {
                Status = OSBOFlush(OsOptions);
            }                
        }                

        if (Status) {
            ErrorCode = ERROR_SUCCESS;
        } else {
            ErrorCode = ERROR_CAN_NOT_COMPLETE;
        }            
    }
    
    return ErrorCode;
}

DWORD
SetTimeout(
    IN POS_BOOT_OPTIONS OsOptions,
    IN const ProgramArguments &Args
    )
{
    DWORD ErrorCode = ERROR_INVALID_PARAMETER;

    if (OsOptions && Args.SetTimeout) {
        OSBOSetTimeOut(OsOptions, Args.Timeout);
        ErrorCode = OSBOFlush(OsOptions) ? ERROR_SUCCESS : ERROR_CAN_NOT_COMPLETE;
    }
    
    return ErrorCode;
}

    
//
// main() entry point
//
int 
__cdecl
wmain(
    int         Argc,
    wchar_t     *Argv[]
    )
{
    int Result = 0;
    ThisModule = GetModuleHandle(NULL);
    
    try {    
        DWORD ErrorCode = ERROR_INVALID_PARAMETER;
        ProgramArguments    Args(Argc, Argv);        
        POS_BOOT_OPTIONS    BootOptions = NULL;

        //
        // Initialize the library
        //
        if (OSBOLibraryInit((SBEMemAllocateRoutine)malloc, (SBEMemFreeRoutine)free)) {
            BootOptions = EFIOSBOCreate();
        }            

        if (!BootOptions) {
            std::cout << GetFormattedMessage(   ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_ERROR_READING_BOOT_ENTRIES) << std::endl;
            Result = 1;
        } else {
            if (Args.ListEntries) {
                ErrorCode = ListEntries(BootOptions);
            } else if (Args.AddNewEntry) {
                ErrorCode = AddNewEntry(BootOptions, Args);                                
            } else if (Args.DeleteBootEntry) {
                ErrorCode = DeleteBootEntry(BootOptions, Args);
            } else if (Args.SetOsLoadOptions) {
                ErrorCode = SetBootEntryOptions(BootOptions, Args);
            } else if (Args.SetActive) {
                ErrorCode = SetBootEntryActive(BootOptions, Args);
            } else if (Args.SetTimeout) {
                ErrorCode = SetTimeout(BootOptions, Args);
            } else if (Args.ListDrvEntries){
                ErrorCode = ListDriverEntry(BootOptions);
            } else if (Args.AddDrvEntry){
                ErrorCode = AddNewDriverEntry(BootOptions, Args);
            } else if (Args.DelDrvEntry){
                ErrorCode = DelDriverEntry(BootOptions, Args);
            }   

            OSBODelete(BootOptions);
        }            

        if (ErrorCode != ERROR_SUCCESS) {
            throw new W32Error(ErrorCode);
        }        
    }
    catch(ProgramArguments *pArgs) {
        Result = 1;
        std::cout << GetFormattedMessage(   ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_PGM_USAGE) << std::endl;

        if (pArgs) {
            delete pArgs;
        }
    }
    catch(W32Error  *W32Err) {
        if (W32Err) {   // to make prefix happy :(
            W32Err->Dump(std::cout);
            std::cout << GetFormattedMessage(   ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_PGM_USAGE) << std::endl;
            delete W32Err;
        }   

        Result = 1;
    }
    catch(ProgramException *PrgExp) {
        Result = 1;
        PrgExp->Dump(std::cout);
        delete PrgExp;
    } catch (exception *Exp) {
        Result = 1;
        std::cout << Exp->what() << std::endl;
    }

    return Result;
}


NTSTATUS
QueryCanonicalName(
    IN  PCWSTR   Name,
    IN  ULONG   MaxDepth,
    OUT PWSTR   CanonicalName,
    IN  ULONG   SizeOfBufferInBytes
    )
/*++

Routine Description:

    Resolves the symbolic name to the specified depth. To resolve
    a symbolic name completely specify the MaxDepth as -1

Arguments:

    Name        -   Symbolic name to be resolved
    
    MaxDepth    -   The depth till which the resolution needs to
                    be carried out

    CanonicalName   -   The fully resolved name

    SizeOfBufferInBytes -   The size of the CanonicalName buffer in
                            bytes                           

Return Value:

    Appropriate NT status code

--*/    
{
    UNICODE_STRING      name, canonName;
    OBJECT_ATTRIBUTES   oa;
    NTSTATUS            status;
    HANDLE              handle;
    ULONG               CurrentDepth;

    RtlInitUnicodeString(&name, Name);

    canonName.MaximumLength = (USHORT) (SizeOfBufferInBytes - sizeof(WCHAR));
    canonName.Length = 0;
    canonName.Buffer = CanonicalName;

    if (name.Length >= canonName.MaximumLength) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(canonName.Buffer, name.Buffer, name.Length);
    canonName.Length = name.Length;
    canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;

    for (CurrentDepth = 0; CurrentDepth < MaxDepth; CurrentDepth++) {

        InitializeObjectAttributes(&oa, &canonName, OBJ_CASE_INSENSITIVE, 0, 0);

        status = NtOpenSymbolicLinkObject(&handle,
                                          READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                          &oa);
        if (!NT_SUCCESS(status)) {
            break;
        }

        status = NtQuerySymbolicLinkObject(handle, &canonName, NULL);
        NtClose(handle);

        if (!NT_SUCCESS(status)) {
            return status;
        }
        
        canonName.Buffer[canonName.Length/sizeof(WCHAR)] = 0;
    }

    return STATUS_SUCCESS;
}


#define PRODUCT_NAME_KEY  TEXT("productname")

VOID
GetFriendlyName(
    IN const std::wstring &InfFileName,
    OUT std::wstring &FriendlyName
    )
{
    UINT    ErrorLine = 0;
    BOOL    Status = FALSE;
    HINF    InfHandle = ::SetupOpenInfFile(InfFileName.c_str(),
                            NULL,
                            INF_STYLE_WIN4,
                            &ErrorLine);

    if (InfHandle != INVALID_HANDLE_VALUE) {
        INFCONTEXT  InfContext = {0};
        WCHAR       Buffer[MAX_PATH] = {0};

        //
        // get the key
        //
        Status = SetupFindFirstLine(InfHandle,
                            TEXT("Strings"),
                            PRODUCT_NAME_KEY,
                            &InfContext);

        if (Status) {            
            //
            // If we found the key extract the description
            //
            Status = SetupGetStringField(&InfContext,
                        1,
                        Buffer,
                        ARRAY_SIZE(Buffer),
                        NULL);

            if (Status) {               
                FriendlyName = Buffer;
            }
        }
        
        SetupCloseInfFile(InfHandle);
    }        

    //
    // If we didn't find the description use default description
    //
    if (!Status) {        
        FriendlyName = DEFAULT_NAME;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\factory.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    factory.c

Abstract:

    Factory Pre-install application.  This application will be used to perform
    pre-installation task in an OEM factory, or system builder (SB) setting.

    The task performed will be:
        Minimal boot (minimal device and services loaded)
        WinBOM processing
            Download updated device drivers from NET
            Process OOBE info
            Process User/Customer specific settings
            Process OEM user specific customization
            Process Application pre-installations
        PnPDevice enumeration
        Exit to Windows for Audit mode work.

Author:

    Donald McNamara (donaldm) 2/8/2000

Revision History:

--*/


//
// Include File(s):
//

#include "factoryp.h"
#include "shlobj.h"
#include "states.h" // should only ever be included by one c file.


//
// Defined Value(s):
//

#define FILE_WINBOM             _T("winbom")
#define FILE_OOBE               _T("oobe")
#define FILE_BAT                _T(".bat")
#define FILE_CMD                _T(".cmd")

#define REG_VAL_FIRSTPNP        _T("PnPDetection")
#define PNP_INSTALL_TIMEOUT     600000  // 10 minutes

#define SZ_ENV_RESOURCE         _T("ResourceDir")
#define SZ_ENV_RESOURCEL        _T("ResourceDirL")


//
// Defined Macro(s):
//

#define CHECK_PARAM(lpCmdLine, lpOption)    ( LSTRCMPI(lpCmdLine, lpOption) == 0 )


//
// Type Definition(s):
//


//
// External Global Variable(s):
//

// UI stuff...
//
HINSTANCE   g_hInstance                 = NULL;

// Global factory flags.
DWORD       g_dwFactoryFlags            = 0;


// Debug Level - used for logging.
// 
#ifdef DBG
    DWORD   g_dwDebugLevel              = LOG_DEBUG;
#else   
    DWORD   g_dwDebugLevel              = 0;
#endif


// Path to the WinBOM file.
//
TCHAR       g_szWinBOMPath[MAX_PATH]    = NULLSTR;

// Path to the WinBOM log file.
//
TCHAR       g_szLogFile[MAX_PATH]       = NULLSTR;

// Path to FACTORY.EXE.
//
TCHAR       g_szFactoryPath[MAX_PATH]   = NULLSTR;

// Path to the sysprep directory (where factory.exe must be located).
//
TCHAR       g_szSysprepDir[MAX_PATH]    = NULLSTR;


//
// Internal Golbal Variable(s):
//

// This determines the mode that factory will run in and is set based on
// the command line parameters.
//
FACTMODE    g_fm = modeUnknown;


//
// Internal Function Prototype(s):
//

static BOOL ParseCmdLine();
static BOOL IsUserAdmin();
static BOOL RunBatchFile(LPTSTR lpszSysprepFolder, LPTSTR lpszBaseFileName);
static BOOL CheckSetEnv(LPCTSTR lpName, LPCTSTR lpValue);
static void SetupFactoryEnvironment();


/*++
===============================================================================
Routine Description:

    This routine is the main entry point for the program.

    We do a bit of error checking, then, if all goes well, we update the
    registry to enable execution of our second half.

===============================================================================
--*/

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine,
                     int nCmdShow)
{
    HANDLE      hMutex;

    LPTSTR      lpFilePart  = NULL,
                lpMode      = NULL,
                lpBatchFile = NULL;
    DWORD       dwLocate,
                cbStates    = 0;
    LPSTATES    lpStates    = NULL;
    BOOL        bBadCmdLine,
                bOldVersion = FALSE;
                

    // Save the instance handle globally.
    //
    g_hInstance = hInstance;

    // This causes the system not to display the critical-error-handler
    // message box.  Instead, the system sends the error to the calling
    // process.
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);    

    // We need the path to factory.exe and where it is located.
    //
    if ( GetModuleFileName(NULL, g_szFactoryPath, AS ( g_szFactoryPath ) ) && 
            GetFullPathName(g_szFactoryPath, AS(g_szSysprepDir), g_szSysprepDir, &lpFilePart) && g_szSysprepDir[0] && lpFilePart )
    {
        // Chop off the file name.
        //
        *lpFilePart = NULLCHR;
    }

    // If either of those file, we must quit (can't imagine that every happening).
    //
    // ISSUE-2002/02/25-acosma,robertko - why are we checking for g_szFactoryPath here when we already used it above?
    //
    if ( ( g_szFactoryPath[0] == NULLCHR ) || ( g_szSysprepDir[0] == NULLCHR ) )
    {
        // Can we log this failure?
        //
        return 0;
    }

    // This will setup special factory environment variables.
    //
    SetupFactoryEnvironment();

    //
    // Check to see if we are allowed to run on this build of the OS.
    //
    if ( !OpklibCheckVersion( VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE ) )
    {
        bOldVersion = TRUE;
    }

#ifdef DBG
    // In debug builds, lets always try to log right away.  In
    // the retail case we want to wait until after we locate the
    // winbom before we start our logging.
    //
    InitLogging(NULL);
    FacLogFileStr(3, _T("DEBUG: Starting factory (%s)."), GetCommandLine());
#endif

    // Check the command line for options (but don't error
    // till we have the log file up).
    //
    bBadCmdLine = ( !ParseCmdLine() || ( g_fm == modeUnknown ) );

    // Need to find the mode stuff: string, flags, and states.
    //
    dwLocate = LOCATE_NORMAL;
    switch ( g_fm )
    {
        case modeLogon:
            dwLocate = LOCATE_AGAIN;
            SET_FLAG(g_dwFactoryFlags, FLAG_LOGGEDON);
            lpStates = &g_FactoryStates[0];
            cbStates = AS(g_FactoryStates);
            lpMode = INI_VAL_WBOM_TYPE_FACTORY;
            break;

        case modeSetup:
            lpStates = &g_FactoryStates[0];
            cbStates = AS(g_FactoryStates);
            lpMode = INI_VAL_WBOM_TYPE_FACTORY;
            lpBatchFile = FILE_WINBOM;
            break;

        case modeWinPe:
            lpStates = &g_MiniNtStates[0];
            cbStates = AS(g_MiniNtStates);
            // Fall through...
        case modeMiniNt:
            lpMode = INI_VAL_WBOM_TYPE_WINPE;
            break;

        case modeOobe:
            dwLocate = LOCATE_NONET;
            SET_FLAG(g_dwFactoryFlags, FLAG_NOUI);
            SET_FLAG(g_dwFactoryFlags, FLAG_OOBE);
            lpStates = &g_OobeStates[0];
            cbStates = AS(g_OobeStates);
            lpMode = INI_VAL_WBOM_TYPE_OOBE;
            lpBatchFile = FILE_OOBE;
            break;

        default:
            lpMode = NULL;
    }

    // If the mode isn't setup, then pnp is already started.
    // Otherwise if this is the first run of factory, wait
    // for pnp before all else.
    //
    if ( modeSetup != g_fm )
    {
        SET_FLAG(g_dwFactoryFlags, FLAG_PNP_STARTED);
    }
    else if ( !bBadCmdLine && !bOldVersion && !RegCheck(HKLM, REG_FACTORY_STATE, REG_VAL_FIRSTPNP) )
    {
        // Kick off pnp this first time so we can get the winbom
        // off the floppy or cd-rom.
        //
        if ( StartPnP() )
        {
            WaitForPnp(PNP_INSTALL_TIMEOUT);
        }

        // Make sure we don't do this every boot.
        //
        // ISSUE-2002/02/25-acosma,robertko - We should only set this if PNP successfully started. Move into above block?
        //
        RegSetString(HKLM, REG_FACTORY_STATE, REG_VAL_FIRSTPNP, _T("1"));
    }

    // Run the batch file if we are running from the setup key.
    //
    if ( !bBadCmdLine && !bOldVersion && lpBatchFile )
    {
        RunBatchFile(g_szSysprepDir, lpBatchFile);
    }

    // Find the WinBOM (just use the one previously found if we
    // are in the logon mode).
    //
    LocateWinBom(g_szWinBOMPath, AS(g_szWinBOMPath), g_szSysprepDir, lpMode, dwLocate);

    // Find out if we're running on IA64.
    //
    if ( IsIA64() )
        SET_FLAG(g_dwFactoryFlags, FLAG_IA64_MODE);

    // Try to enable logging. This checks the WinBOM.
    //
    // ISSUE-2002/02/25-acosma,robertko - in debug mode we have already done this.  We end up doing this twice. Make sure this is ok.
    //
    InitLogging(g_szWinBOMPath);
    
    // Only let one of this guy run.
    //
    hMutex = CreateMutex(NULL,FALSE,TEXT("FactoryPre Is Running"));
    if ( hMutex == NULL )
    {
        FacLogFile(0 | LOG_ERR, MSG_OUT_OF_MEMORY);
        return 0;
    }

    // Make sure we are the only process with a handle to our named mutex.
    //
    if ( GetLastError() == ERROR_ALREADY_EXISTS )
    {
        FacLogFile(0 | LOG_ERR, MSG_ALREADY_RUNNING);

        // Destroy the mutex and bail.
        //
        CloseHandle(hMutex);
        return 0;
    }

    // Now we can log and return if there was a
    // bad command line passed to factory.
    //
    if ( bBadCmdLine )
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_INVALIDCMDLINE);

        // Destroy the mutex and bail.
        //
        CloseHandle(hMutex);
        return 0;
    }
    
    // 
    // Now we can log and put up an error message if necessary in case the version of tool is too old.
    //
    if ( bOldVersion )
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_NOT_ALLOWED);
        
        CloseHandle(hMutex);
        return 0;
    }
    
    // Make sure we have a WinBOM file.
    //
    if ( g_szWinBOMPath[0] == NULLCHR )
        FacLogFile(( g_fm == modeLogon ) ? (2 | LOG_ERR) : (0 | LOG_ERR), IDS_ERR_MISSINGWINBOM);
    else
        FacLogFile(( g_fm == modeLogon ) ? 2 : 0, IDS_LOG_WINBOMLOCATION, g_szWinBOMPath);

    // Ensure that the user is in the admin group.
    //
    if ( ( g_fm != modeMiniNt ) && ( g_fm != modeWinPe ) && ( !IsUserAdmin() ) )
    {
        FacLogFile(0 | LOG_ERR, MSG_NOT_AN_ADMINISTRATOR);

        // Destroy the mutex and bail.
        //
        CloseHandle(hMutex);
        return 0;
    }

    // We don't do the state thing in MiniNT mode right now (but we could).
    // The modeMiniNt mode is only temporary the real mode in modeWinPe.
    //
    if ( g_fm == modeMiniNt )
    {
        // ISSUE-2002/02/25-acosma,robertko - This function does not check if we are running on WinPE, so users can just run factory -mini on any 
        // machine.
        // 
        if ( !SetupMiniNT() )
        {
            FacLogFileStr(0 | LOG_ERR | LOG_MSG_BOX, L"Failed to install network adapter -- check WINBOM");
        }
    }
    else
    {
        // Make sure factory will always run.
        //
        if ( modeWinPe == g_fm )
        {
            HKEY  hKey;
            
            // Make sure that if we are in "-winpe" mode we only run under WinPE
            //
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\MiniNT"), 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
            {
                RegCloseKey(hKey);
            }
            else 
            {
                FacLogFile(0 | LOG_ERR, IDS_ERR_NOT_WINPE);
                
                // Destroy the mutex and bail.
                CloseHandle(hMutex);
                return 0;
            }
        }
        else if ( modeOobe != g_fm )
        {
            HKEY hKey;

            // Open the key, and set the proper SetupType value.
            //
            // Very important not to ever change this value in OOBE
            // mode!
            //
            if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SYSTEM\\Setup"), 0, KEY_ALL_ACCESS, &hKey ) == ERROR_SUCCESS )
            {
                DWORD dwValue = SETUPTYPE_NOREBOOT;
                RegSetValueEx(hKey, TEXT("SetupType"), 0, REG_DWORD, (CONST LPBYTE) &dwValue, sizeof(DWORD));
            }
        }

        // Now process the winbom.ini file.
        //
        if ( lpStates && cbStates )
        {
            ProcessWinBOM(g_szWinBOMPath, lpStates, cbStates);
        }
#ifdef DBG
        else
        {
            FacLogFileStr(3, _T("DEBUG: ProcessWinBOM() error... lpStates or cbStates not set."));
        }
#endif
    }

    // Close the Mutex.
    //
    CloseHandle(hMutex);

    return 0;
}


//
// Internal Function(s):
//

static BOOL ParseCmdLine()
{
    DWORD   dwArgs;
    LPTSTR  *lpArgs;
    BOOL    bError = FALSE;


    // ISSUE-2002/02/25-acosma,robertko - this is really contorted, we seem to have our own implementation of CommandLineToArgvW inside this 
    // GetCommandLineArgs() function.  Just use the Win32 function.  Should be safer.
    //
    if ( (dwArgs = GetCommandLineArgs(&lpArgs) ) && lpArgs )
    {
        LPTSTR  lpArg;
        DWORD   dwArg;

        // We want to skip over the first argument (it is the path
        // to the command being executed.
        //
        if ( dwArgs > 1 )
        {
            dwArg = 1;
            lpArg = *(lpArgs + dwArg);
        }
        else
            lpArg = NULL;

        // Loop through all the arguments.
        //
        while ( lpArg && !bError )
        {
            // Now we check to see if the first char is a dash or not.
            //
            if ( *lpArg == _T('-') )
            {
                LPTSTR lpOption = CharNext(lpArg);

                // This is where you add command line options that start with a dash (-).
                //
                // ISSUE-2002/02/25-acosma,robertko - We don't validate correct combinations of arguments.  I can run
                // "factory -setup -logon -winpe -oobe" and the last argument would be the one that is
                // picked up.  We should fix this and make it smarter.
                //
                if ( CHECK_PARAM(lpOption, _T("setup")) )
                    g_fm = modeSetup;
                else if ( CHECK_PARAM(lpOption, _T("logon")) )
                    g_fm = modeLogon;
                else if ( CHECK_PARAM(lpOption, _T("minint")) )
                    g_fm = modeMiniNt;
                else if ( CHECK_PARAM(lpOption, _T("winpe")) ) 
                    g_fm = modeWinPe;
                else if ( CHECK_PARAM(lpOption, _T("oobe")) ) 
                    g_fm = modeOobe;
                else
                    bError = TRUE;
            }
            else if ( *lpArg )
            {
                bError = TRUE;
            }

            // Setup the pointer to the next argument in the command line.
            //
            if ( ++dwArg < dwArgs )
                lpArg = *(lpArgs + dwArg);
            else
                lpArg = NULL;
        }

        // Make sure to free the two buffers allocated by the GetCommandLineArgs() function.
        //
        FREE(*lpArgs);
        FREE(lpArgs);
    }

    return !bError;
}

/*++ 

Routine Description: 
    This routine returns TRUE if the caller's process is a 
    member of the Administrators local group. Caller is NOT 
    expected to be impersonating anyone and is expected to 
    be able to open their own process and process token. 

Arguments: 

    None. 

Return Value: 
   
   TRUE - Caller has Administrators local group. 
   FALSE - Caller does not have Administrators local group. --
*/ 

static BOOL IsUserAdmin(VOID) 
{
    BOOL b;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup; 
    
    b = AllocateAndInitializeSid(
        &NtAuthority,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &AdministratorsGroup); 
    
    if(b) 
    {
        if (!CheckTokenMembership( NULL, AdministratorsGroup, &b)) 
        {
             b = FALSE;
        } 
        FreeSid(AdministratorsGroup); 
    }
    
    return(b);
}

/*++

Routine Description:

    This routine ckecks WinBOM setting for logging.  Logging 
    is enabled by default if nothing is specified in the 
    WinBOM.  Disables logging by setting g_szLogFile = NULL.
    
Arguments:

    None.

Return Value:

    None.

--*/

VOID InitLogging(LPTSTR lpszWinBOMPath)
{
    TCHAR   szScratch[MAX_PATH] = NULLSTR;
    LPTSTR  lpszScratch;
    BOOL    bWinbom = ( lpszWinBOMPath && *lpszWinBOMPath );

    // First check if logging is disabled in the WinBOM.
    //
    if ( ( bWinbom ) &&
         ( GetPrivateProfileString(WBOM_FACTORY_SECTION, WBOM_FACTORY_LOGGING, _T("YES"), szScratch, AS(szScratch), lpszWinBOMPath) ) &&
         ( LSTRCMPI(szScratch, _T("NO")) == 0 ) )
    {
        g_szLogFile[0] = NULLCHR;
    }
    else
    {
        // All these checks can only be done if we have a winbom.
        //
        if ( bWinbom )
        {
            // Check for quiet mode.  If we are in quiet mode don't display any MessageBoxes. 
            // This only works for WinPE mode.
            //
            if ( (GetPrivateProfileString(WBOM_WINPE_SECTION, INI_KEY_WBOM_QUIET, NULLSTR, szScratch, AS(szScratch), lpszWinBOMPath) ) &&
                 (0 == LSTRCMPI(szScratch, WBOM_YES))
               )
            {
                SET_FLAG(g_dwFactoryFlags, FLAG_QUIET_MODE);
            }

            // See if they want to turn on perf logging.
            //
            szScratch[0] = NULLCHR;
            if ( ( GetPrivateProfileString(WBOM_FACTORY_SECTION, INI_KEY_WBOM_LOGPERF, NULLSTR, szScratch, AS(szScratch), lpszWinBOMPath) ) &&
                 ( 0 == LSTRCMPI(szScratch, WBOM_YES) ) )
            {
                SET_FLAG(g_dwFactoryFlags, FLAG_LOG_PERF);
            }
        
            // Set the logging level.
            //
            g_dwDebugLevel = (DWORD) GetPrivateProfileInt(WBOM_FACTORY_SECTION, INI_KEY_WBOM_LOGLEVEL, (DWORD) g_dwDebugLevel, lpszWinBOMPath);
        }

        //
        // In non-debug builds we do not want the log level to be set at LOG_DEBUG.  Force it
        // to drop down by one level if set at LOG_DEBUG or higher.
        //
#ifndef DBG
        if ( g_dwDebugLevel >= LOG_DEBUG )
            g_dwDebugLevel = LOG_DEBUG - 1;
#endif
        
        // Check to see if they have a custom log file they want to use.
        //
        if ( ( bWinbom ) &&
             ( lpszScratch = IniGetExpand(lpszWinBOMPath, INI_SEC_WBOM_FACTORY, INI_KEY_WBOM_FACTORY_LOGFILE, NULL) ) )
        {
            TCHAR   szFullPath[MAX_PATH]    = NULLSTR;
            LPTSTR  lpFind                  = NULL;

            // Turn the ini key into a full path.
            //
            lstrcpyn( g_szLogFile, lpszScratch, AS( g_szLogFile ) );
            if (GetFullPathName(g_szLogFile, AS(szFullPath), szFullPath, &lpFind) && szFullPath[0] && lpFind)
            {
                // Copy the full path into the global.
                //
                lstrcpyn(g_szLogFile, szFullPath, AS(g_szLogFile));

                // Chop off the file part so we can create the
                // path if it doesn't exist.
                //
                *lpFind = NULLCHR;

                // If the directory cannot be created or doesn't exist turn off logging.
                //
                if (!CreatePath(szFullPath))
                    g_szLogFile[0] = NULLCHR;
            }

            // Free the original path buffer from the ini file.
            //
            FREE(lpszScratch);
        }
        else  // default case
        {
            // Create it in the current directory (g_szSysprepDir)
            //
            lstrcpyn(g_szLogFile, g_szSysprepDir, AS ( g_szLogFile ) );
            AddPathN(g_szLogFile, WINBOM_LOGFILE, AS ( g_szLogFile ));
        }

        // Check to see if we have write access to the logfile. If we don't, turn off logging.
        // If we're running in WinPE we'll call this function again once the drive becomes
        // writable.
        //
        // Write an FFFE header to the file to identify this as a Unicode text file.
        //
        if ( g_szLogFile[0] )
        {
            HANDLE hFile;
            DWORD dwWritten = 0;
            WCHAR cHeader =  0xFEFF;
     
            SetLastError(ERROR_SUCCESS);
   
            if ( INVALID_HANDLE_VALUE != (hFile = CreateFile(g_szLogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)))
            {   
                // BUBBUG: This should check for an existing header in the file.  There could be an empty
                // file with no header.
                //
                if ( ERROR_ALREADY_EXISTS != GetLastError() )
                    WriteFile(hFile, &cHeader, sizeof(cHeader), &dwWritten, NULL);
                CloseHandle(hFile);
            }
            else
            {   // There was a problem opening the file.  Most of the time this means that the media is not writable.
                // Disable logging in that case.
                //
                g_szLogFile[0] = NULLCHR;
            }
        }
    }
}

static BOOL RunBatchFile(LPTSTR lpszSysprepFolder, LPTSTR lpszBaseFileName)
{
    BOOL    bRet                    = FALSE;
    TCHAR   szCmdLine[]             = NULLSTR,
            szWinbomBat[MAX_PATH];
    LPTSTR  lpExtension;
    DWORD   dwExitCode;

    // First make the fullpath to where the batch file should be.
    //
    lstrcpyn(szWinbomBat, lpszSysprepFolder, AS(szWinbomBat));
    AddPathN(szWinbomBat, lpszBaseFileName, AS(szWinbomBat) );
    lpExtension = szWinbomBat + lstrlen(szWinbomBat);

    // Make sure there is still enough room for the extension.
    //
    if ( ((lpExtension + 4) - szWinbomBat ) >= AS(szWinbomBat) )
    {
        return FALSE;
    }

    // First try winbom.cmd.
    //
    lstrcpyn(lpExtension, FILE_CMD, AS ( szWinbomBat )  - lstrlen ( szWinbomBat ) );
    if ( FileExists(szWinbomBat) )
    {
        bRet = InvokeExternalApplicationEx(szWinbomBat, szCmdLine, &dwExitCode, INFINITE, GET_FLAG(g_dwFactoryFlags, FLAG_NOUI));
    }
    else
    {
        // Also try winbom.bat if that one didn't exist.
        //
        lstrcpyn(lpExtension, FILE_BAT, AS ( szWinbomBat ) - lstrlen ( szWinbomBat ) );
        if ( FileExists(szWinbomBat) )
        {
            bRet = InvokeExternalApplicationEx(szWinbomBat, szCmdLine, &dwExitCode, INFINITE, GET_FLAG(g_dwFactoryFlags, FLAG_NOUI));
        }
    }

    return bRet;
}

static BOOL CheckSetEnv(LPCTSTR lpName, LPCTSTR lpValue)
{
    if ( 0 == GetEnvironmentVariable(lpName, NULL, 0) )
    {
        SetEnvironmentVariable(lpName, lpValue);
        return TRUE;
    }
    return FALSE;
}

static void SetupFactoryEnvironment()
{
    TCHAR szPath[MAX_PATH];

    szPath[0] = NULLCHR;
    if ( SHGetSpecialFolderPath(NULL, szPath, CSIDL_RESOURCES, 0) && szPath[0] )
    {
        CheckSetEnv(SZ_ENV_RESOURCE, szPath);
    }

    szPath[0] = NULLCHR;
    if ( SHGetSpecialFolderPath(NULL, szPath, CSIDL_RESOURCES_LOCALIZED, 0) && szPath[0] )
    {
        CheckSetEnv(SZ_ENV_RESOURCEL, szPath);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\factoryp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    factoryp.h

Abstract:

    Private top-level header file for Factory Pre-install module.

Author:

    Donald McNamara (donaldm) 2/8/2000

Revision History:

    - Added exported prototypes from preinstall.c: Jason Lawrence (t-jasonl) 6/7/2000
    - Added DeleteTree() prototype: Jason Lawrence (t-jasonl) 6/7/2000
    - Added additional prototypes from misc.c and log.c: Jason Lawrence (t-jasonl) 6/14/2000

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpoapi.h>
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <commctrl.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <lmuse.h>
#include <msi.h>
#include <msiquery.h>
#include <regstr.h>
#include <limits.h>
#include <powrprof.h>
#include <syssetup.h>
#include <opklib.h>            // OPK common functions
#include <strsafe.h>
#include <ntverp.h>

#include "msg.h"
#include "res.h"
#include "winbom.h"
#include "status.h"

//
// Defined Value(s):
//

// Flags for Logging
//
// Some of these flags are also defined in opklib.h. ( Planning to use opklib for all logging in the future. )  
// 


#define LOG_DEBUG               0x00000003    // Only log in debug builds if this is specified. (Debug Level for logging.)
#define LOG_LEVEL_MASK          0x0000000F    // Mask to only show the log level bits
#define LOG_MSG_BOX             0x00000010    // Display the message boxes if this is enabled.
#define LOG_ERR                 0x00000020    // Prefix the logged string with "Error:" if the message is level 0,
                                              // or "WARNx" if the message is at level x > 0.
#define LOG_TIME                0x00000040    // Display time if this is enabled
#define LOG_NO_NL               0x00000080    // Don't add new Line to the end of log string if this is set.

// Other factory flags
//
#define FLAG_STOP_ON_ERROR      0x00000001    // Stop on error.  We should not really use this.
#define FLAG_QUIET_MODE         0x00000002    // Quiet mode: do not display any message boxes.
#define FLAG_IA64_MODE          0x00000004    // Set if factory is running on an Itanium machine.
#define FLAG_LOG_PERF           0x00000008    // If set, log how long each state takes to run.
#define FLAG_PNP_DONE           0x00000010    // If set, we know for sure that pnp is done.
#define FLAG_PNP_STARTED        0x00000020    // If set, we have already started pnp.
#define FLAG_LOGGEDON           0x00000040    // Only set when we are logged in.
#define FLAG_NOUI               0x00000080    // Set if we don't want to show any UI in factory.
#define FLAG_OOBE               0x00000100    // Set if we are launched from OOBE.

// Flags for the STATE structure.
//
#define FLAG_STATE_NONE         0x00000000
#define FLAG_STATE_ONETIME      0x00000001  // Set if this state should only be executed once, not for every boot.
#define FLAG_STATE_NOTONSERVER  0x00000002  // Set if this state should not run on server SKUs.
#define FLAG_STATE_QUITONERR    0x00000004  // Set if no other states should run if this state fails.
#define FLAG_STATE_DISPLAYED    0x00000008  // Set only at run time, and only if the item is displayed in the status window.

#define ALWAYS                  DisplayAlways
#define NEVER                   NULL

// Log files.
//
#define WINBOM_LOGFILE          _T("WINBOM.LOG")

// Registry strings.
//
#define REG_FACTORY_STATE       _T("SOFTWARE\\Microsoft\\Factory\\State")   // Registry path for the factory states.

// Extra debug Logging.
//
#ifdef DBG
#define DBGLOG                  FacLogFileStr
#else // DBG
#define DBGLOG           
#endif // DBG

//
// Defined Macro(s):
//


//
// Type Definition(s):
//

typedef enum _FACTMODE
{
    modeUnknown,
    modeSetup,
    modeMiniNt,
    modeWinPe,
    modeLogon,
    modeOobe,
} FACTMODE, *PFACTMODE, *LPFACTMODE;

typedef enum _STATE
{
    stateUnknown,
    stateStart,
    stateComputerName,
    stateSetupNetwork,
    stateUpdateDrivers,
    stateInstallDrivers,
    stateNormalPnP,
    stateWaitPnP,
    stateWaitPnP2,
    stateSetDisplay,
    stateSetDisplay2,
    stateOptShell,
    stateAutoLogon,
    stateLogon,
    stateUserIdent,
    stateInfInstall,
    statePidPopulate,
    stateOCManager,
    stateOemRunOnce,
    stateOemRun,
    stateReseal,
    statePartitionFormat,
    stateCopyFiles,
    stateStartMenuMFU,
    stateSetDefaultApps,
    stateOemData,
    stateSetPowerOptions,
    stateSetFontOptions,
    stateShellSettings,
    stateShellSettings2,
    stateHomeNet,
    stateExtendPart,
    stateResetSource,
    stateTestCert,
    stateSlpFiles,
    stateWinpeReboot,
    stateWinpeNet,
    stateCreatePageFile,
    stateFinish,
} STATE;

typedef struct _STATEDATA
{
    LPTSTR  lpszWinBOMPath;
    STATE   state;
    BOOL    bQuit;
} STATEDATA, *PSTATEDATA, *LPSTATEDATA;

typedef BOOL (WINAPI *STATEFUNC)(LPSTATEDATA);

typedef struct _STATES
{
    STATE       state;          // State number.
    STATEFUNC   statefunc;      // Function to call for this state.
    STATEFUNC   displayfunc;    // Function that decides if this state is displayed or not.
    INT         nFriendlyName;  // Resource ID of the name to be displayed in the log and UI for this state.
    DWORD       dwFlags;        // Any flags for the state.
} STATES, *PSTATES, *LPSTATES;


//
// Function Prototype(s):
//

BOOL    CheckParams(LPSTR lpCmdLine);
INT_PTR FactoryPreinstallDlgProc(HWND, UINT, WPARAM, LPARAM);

// In WINBOM.C:
//
BOOL ProcessWinBOM(LPTSTR lpszWinBOMPath, LPSTATES lpStates, DWORD cbStates);
BOOL DisplayAlways(LPSTATEDATA lpStateData);

// From MISC.C
TCHAR GetDriveLetter(UINT uDriveType);
BOOL ComputerName(LPSTATEDATA lpStateData);
BOOL DisplayComputerName(LPSTATEDATA lpStateData);
BOOL Reseal(LPSTATEDATA lpStateData);
BOOL DisplayReseal(LPSTATEDATA lpStateData);

// From PNPDRIVERS.C:
//
BOOL StartPnP();
BOOL WaitForPnp(DWORD dwTimeOut);
BOOL UpdateDrivers(LPSTATEDATA lpStateData);
BOOL DisplayUpdateDrivers(LPSTATEDATA lpStateData);
BOOL InstallDrivers(LPSTATEDATA lpStateData);
BOOL DisplayInstallDrivers(LPSTATEDATA lpStateData);
BOOL NormalPnP(LPSTATEDATA lpStateData);
BOOL DisplayWaitPnP(LPSTATEDATA lpStateData);
BOOL WaitPnP(LPSTATEDATA lpStateData);
BOOL SetDisplay(LPSTATEDATA lpStateData);

// From Net.c
BOOL     InstallNetworkCard(PWSTR pszWinBOMPath, BOOL bForceIDScan);
BOOL     SetupNetwork(LPSTATEDATA lpStateData);
NTSTATUS ForceNetbtRegistryRead(VOID);

// From mini.c
BOOL SetupMiniNT(VOID);
BOOL PartitionFormat(LPSTATEDATA lpStateData);
BOOL DisplayPartitionFormat(LPSTATEDATA lpStateData);
BOOL CopyFiles(LPSTATEDATA lpStateData);
BOOL DisplayCopyFiles(LPSTATEDATA lpStateData);
BOOL WinpeReboot(LPSTATEDATA lpStateData);

BOOL 
IsRemoteBoot(
    VOID
    );

// From autologon.c
BOOL AutoLogon(LPSTATEDATA lpStateData);
BOOL DisplayAutoLogon(LPSTATEDATA lpStateData);

// From ident.c
BOOL UserIdent(LPSTATEDATA lpStateData);
BOOL DisplayUserIdent(LPSTATEDATA lpStateData);

// From inf.c
BOOL ProcessInfSection(LPTSTR, LPTSTR);
BOOL InfInstall(LPSTATEDATA lpStateData);
BOOL DisplayInfInstall(LPSTATEDATA lpStateData);

// From factory.c
VOID InitLogging(LPTSTR lpszWinBOMPath);

// From log.c
DWORD FacLogFileStr(DWORD dwLogOpt, LPTSTR lpFormat, ...);
DWORD FacLogFile(DWORD dwLogOpt, UINT uFormat, ...);

// From StartMenuMfu.c
BOOL StartMenuMFU(LPSTATEDATA lpStateData);
BOOL DisplayStartMenuMFU(LPSTATEDATA lpStateData);

BOOL SetDefaultApps(LPSTATEDATA lpStateData);


// From OemFolder.c
BOOL OemData(LPSTATEDATA lpStateData);
BOOL DisplayOemData(LPSTATEDATA lpStateData);
void NotifyStartMenu(UINT code);
#define TMFACTORY_OEMLINK       0
#define TMFACTORY_MFU           1

// From oemrun.c
BOOL OemRun(LPSTATEDATA lpStateData);
BOOL DisplayOemRun(LPSTATEDATA lpStateData);
BOOL OemRunOnce(LPSTATEDATA lpStateData);
BOOL DisplayOemRunOnce(LPSTATEDATA lpStateData);

// From winpenet.c
BOOL ConfigureNetwork(LPTSTR lpszWinBOMPath);
BOOL WinpeNet(LPSTATEDATA lpStateData);
BOOL DisplayWinpeNet(LPSTATEDATA lpStateData);
DWORD WaitForServiceStartName(LPTSTR lpszServiceName);
DWORD StartMyService(LPTSTR lpszServiceName, SC_HANDLE schSCManager);

// From power.c
BOOL SetPowerOptions(LPSTATEDATA lpStateData);
BOOL DisplaySetPowerOptions(LPSTATEDATA lpStateData);

// From FONT.C:
//
BOOL SetFontOptions(LPSTATEDATA lpStateData);
BOOL DisplaySetFontOptions(LPSTATEDATA lpStateData);

// From HOMENET.C:
//
BOOL HomeNet(LPSTATEDATA lpStateData);
BOOL DisplayHomeNet(LPSTATEDATA lpStateData);

// From SRCPATH.C:
//
BOOL ResetSource(LPSTATEDATA lpStateData);
BOOL DisplayResetSource(LPSTATEDATA lpStateData);

// From EXTPART.C:
//
BOOL ExtendPart(LPSTATEDATA lpStateData);
BOOL DisplayExtendPart(LPSTATEDATA lpStateData);

// From TESTCERT.C:
//
BOOL TestCert(LPSTATEDATA lpStateData);
BOOL DisplayTestCert(LPSTATEDATA lpStateData);

// From SHELL.C:
//
BOOL OptimizeShell(LPSTATEDATA lpStateData);
BOOL DisplayOptimizeShell(LPSTATEDATA lpStateData);

// From SETSHELL.C:
//
BOOL ShellSettings(LPSTATEDATA lpStateData);
BOOL ShellSettings2(LPSTATEDATA lpStateData);
BOOL DisplayShellSettings(LPSTATEDATA lpStateData);

// From pagefile.c
//
BOOL CreatePageFile(LPSTATEDATA lpStateData);
BOOL DisplayCreatePageFile(LPSTATEDATA lpStateData);

// From OCMGR.C:
//
BOOL OCManager(LPSTATEDATA lpStateData);
BOOL DisplayOCManager(LPSTATEDATA lpStateData);

// From SLPFILES.C:
//
BOOL SlpFiles(LPSTATEDATA lpStateData);
BOOL DisplaySlpFiles(LPSTATEDATA lpStateData);

// From PID.C
//
BOOL PidPopulate(LPSTATEDATA lpStateData);

// External functions
extern BOOL IsUserAdmin(VOID);
//extern BOOL CheckOSVersion(VOID);
//extern BOOL IsDomainMember(VOID);
//extern BOOL IsUserAdmin(VOID);
extern BOOL DoesUserHavePrivilege(PCTSTR);


// ============================================================================
// Global Variables
// ============================================================================
extern HINSTANCE    g_hInstance;
extern DWORD        g_dwFactoryFlags;
extern DWORD        g_dwDebugLevel;
extern TCHAR        g_szWinBOMPath[];
extern TCHAR        g_szLogFile[MAX_PATH];
extern TCHAR        g_szFactoryPath[MAX_PATH];
extern TCHAR        g_szSysprepDir[MAX_PATH];

// ============================================================================
// Global Constants
// ============================================================================
#define MAX_MESSAGE 4096

#define FACTORY_MESSAGE_TYPE_ERROR      1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\ident.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ident.c

Abstract:

    This module contains function for processing the identities section of WINBOM.INI
    
Author:

    Stephen Lodwick (stelo) 7/27/2000

Revision History:
--*/
#include "factoryp.h"

#include <setupapi.h>
#include <syssetup.h>
#include <tchar.h>

//
// Internal Defines
//
#define INF_SEC_IDENTITIES  _T("UserAccounts")
#define INF_SEC_IDENTITY    _T("%s.Account")

#define INF_KEY_ALIAS       _T("Alias")
#define INF_KEY_PASSWORD    _T("Password")
#define INF_KEY_DESCRIPTION _T("Description")

// Typedefs for external functions
typedef BOOL (WINAPI *CreateLocalAdminAccountExW)
(
    PCWSTR UserName,
    PCWSTR Password,
    PCWSTR Description,
    PSID*  PointerToUserSid   OPTIONAL
);


BOOL UserIdent(LPSTATEDATA lpStateData)
{
    LPTSTR                      lpWinbomPath    = lpStateData->lpszWinBOMPath;
    HINF                        hInf            = NULL;
    CreateLocalAdminAccountExW  pCreateAccountW = NULL;
    INFCONTEXT                  InfContext;
    BOOL                        bRet;
    TCHAR                       szIdentity[MAX_PATH],
                                szIdentitySection[MAX_PATH],
                                szPassword[MAX_PATH],
                                szDescription[MAX_PATH];
    HINSTANCE                   hSyssetup   = NULL;
    DWORD                       dwReturn    = 0;

    if ((hInf = SetupOpenInfFile(lpWinbomPath, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL)))
    {
        for ( bRet = SetupFindFirstLine(hInf, INF_SEC_IDENTITIES, NULL, &InfContext);
              bRet;
              bRet = SetupFindNextLine(&InfContext, &InfContext) )
        {
            // Make sure we set the line back to nothing
            //
            szIdentity[0] = NULLCHR;
            szPassword[0] = NULLCHR;

            // Get the name of the identity.
            //
            SetupGetStringField(&InfContext, 1, szIdentity, STRSIZE(szIdentity), NULL);
                  
            // ISSUE-2002/02/25-acosma,robertko - Doing the same thing twice here.  *szIdentity AND szIdentity[0] ARE the same thing!
            //
            if ( *szIdentity && szIdentity[0] )
            {
                // Build the name of the section for this identity
                //
                if ( FAILED ( StringCchPrintf ( szIdentitySection, AS ( szIdentitySection ), INF_SEC_IDENTITY, szIdentity) ) )
                {
                    FacLogFileStr(3, _T("StringCchPrintf failed %s %s" ), INF_SEC_IDENTITY, szIdentity );
                }
                // Get the Alias field
                //
                GetPrivateProfileString(szIdentitySection, INF_KEY_ALIAS, szIdentity, szIdentity, STRSIZE(szIdentity), lpWinbomPath);
                
                // Get the Password field
                //
                // NTRAID#NTBUG9-551766-2002/02/26-acosma, robertko - Clear text password should not exist in winbom.
                //
                GetPrivateProfileString(szIdentitySection, INF_KEY_PASSWORD, NULLSTR, szPassword, STRSIZE(szPassword), lpWinbomPath);

                // Get the Description field
                //
                GetPrivateProfileString(szIdentitySection, INF_KEY_DESCRIPTION, NULLSTR, szDescription, STRSIZE(szDescription), lpWinbomPath);


                // Create the Local User/Admin Account
                //
                // ISSUE-2002/02/25-acosma, robertko - We don't need to LoadLibrary here since we are already linked to syssetup.lib.
                //
                if ( hSyssetup = LoadLibrary(_T("SYSSETUP.DLL")) )
                {   
                    // ISSUE-2002/02/25-acosma,robertko - dwReturn value is not being used. Remove it.
                    //
                    if ( pCreateAccountW = (CreateLocalAdminAccountExW)GetProcAddress(hSyssetup, "CreateLocalAdminAccountEx") )
                        dwReturn = pCreateAccountW(szIdentity, szPassword, szDescription, NULL);
                    FreeLibrary(hSyssetup);
                }
            }
        }
        SetupCloseInfFile(hInf);
    }

    return TRUE;
}

BOOL DisplayUserIdent(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INF_SEC_IDENTITIES, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\log.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    log.c

Abstract:

    This module contains the implementation of factory specific logging functions.

  Author:

    Adrian Cosma (acosma) - 2/14/2001

Revision History:


Details:

  There are 3 logging functions:

    1) DWORD FacLogFile(DWORD dwLogOpt, UINT uFormat, ...)
        - This takes a variable list of arguments and a resource ID for the error message, followed by 
        strings to fill in any fields specified int the resource string.  The format sepcifiers are the
        standard C printf() format specifiers.

    2) DWORD FacLogFileStr(DWORD dwLogOpt, LPTSTR lpFormat, ...)
        - This takes a variable list of arguments and a string for the error message followed by a variable
        number of strings to fill in any fields specified in the error string.  The format sepcifiers are the
        standard C printf() format specifiers.


    3) DWORD FacLogFileLst(LPCTSTR lpFileName, DWORD dwLogOpt, LPTSTR lpFormat, va_list lpArgs)
        - This takes a variable list of arguments as a va_list. Normally you should not call this function directly.



    Logging options in dwLogOpt - these flags are defined in factoryp.h.

        #define LOG_DEBUG               0x00000003    // Only log in debug builds if this is specified. (Debug Level for logging.)
        #define LOG_MSG_BOX             0x00000010    // Also display a message box with the error message if this is enabled.
        #define LOG_ERR                 0x00000020    // Prefix the logged string with "Error:" if the message is level 0,
                                                      // or "WARNx" if the message is at level x > 0.
        #define LOG_TIME                0x00000040    // Log time if this is enabled
        #define LOG_NO_NL               0x00000080    // Don't add new Line to the end of log string if this is set. 
                                                         ( A '\n' is appended by default to all strings logged if there is no
                                                         terminating '\n'.)

    The LogLevel can be set through the winbom through LogLevel=N in the [Factory] section. The default LogLevel in free builds is 0, and the default LogLevel in 
    checked builds is LOG_DEBUG (3).  The maximum log level in free builds is 2. Any message at MessageLogLevel <= LogLevel 
    will be logged.   

    Return value: DWORD - number of bytes written to the log file (this is twice the number of chars in case of UNICODE).

    Examples:  
    
      FacLogFileStr(3 | LOG_TIME, _T("Starting to format %c:."), pCur->cDriveLetter);
         - Only log this in Debug builds (3), log the time along with the error message.


      FacLogFile(0 | LOG_ERR, IDS_ERR_HUGE_ERROR, dwErrorCode);
         - Always log this error.  IDS_ERR_HUGE_ERROR must be defined as a resource in this image.
           IDS_ERR_HUGE_ERROR should look something like this: "Huge Error! Error code: %d".  Note the %d is
           for the dwErrorCode.

--*/

//
// Includes
//

#include "factoryp.h"


//
// Defines
//

#ifdef CHR_NEWLINE
#undef CHR_NEWLINE
#endif // CHR_NEWLINE
#define CHR_NEWLINE              _T('\n')


#ifdef CHR_CR
#undef CHR_CR
#endif // CHR_CR
#define CHR_CR                   _T('\r')


//
// NTRAID#NTBUG9-549770-2002/02/26-acosma - Buffer overruns everywhere in this code.  lstrcpy, lstrcat, wsprintf, etc.
//

//
// Function Implementations
//

DWORD FacLogFileLst(LPCTSTR lpFileName, DWORD dwLogOpt, LPTSTR lpFormat, va_list lpArgs)
{
    LPTSTR lpAppName            = NULL;
    LPTSTR lpPreOut             = NULL;
    LPTSTR lpOut                = NULL;
    DWORD  dwSize               = 1024;
    TCHAR  szPreLog[MAX_PATH]   = NULLSTR;
    HANDLE hFile;
    DWORD  dwWritten            = 0;
    DWORD  cbAppName            = 0;
    DWORD  dwLogLevel           = (DWORD) (dwLogOpt & LOG_LEVEL_MASK);
    
    
    if ( ( dwLogLevel <= g_dwDebugLevel) && lpFormat )
    {    
        // Get the application title from resource.
        //
        lpAppName = AllocateString(g_hInstance, IDS_APPNAME);    
                       
        // Build the output string.
        //
        if ( lpAppName )
        {
            // Create the prefix string
            //
            lstrcpyn(szPreLog, lpAppName, AS ( szPreLog ) );
            if ( FAILED ( StringCchCat ( szPreLog, AS ( szPreLog ), _T("::")) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szPreLog, _T("::") ) ;
            }
        }
        
        // This is for skipping the App Name prefix when printing to the log file
        //
        cbAppName = lstrlen(szPreLog);
        
        if ( GET_FLAG(dwLogOpt, LOG_ERR) )
        {
            if ( 0 == dwLogLevel )
            {
               if ( FAILED ( StringCchCat ( szPreLog, AS ( szPreLog ), _T("ERROR: ")) ) )
               {
                    FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szPreLog, _T("ERROR: ") ) ;
               }
            }
            else
            {
                if ( FAILED ( StringCchPrintfW ( szPreLog + cbAppName, AS ( szPreLog ) - cbAppName, _T("WARN%d: "), dwLogLevel) ) ) 
                {
                    FacLogFileStr(3, _T("StringCchPrintfW failed %s  WARN%d: \n"), szPreLog,  dwLogLevel ) ;
                }
            }
        }
      
        if ( GET_FLAG(dwLogOpt, LOG_TIME) )
        {
            TCHAR  szTime[100] = NULLSTR;

            GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT, NULL, _T("'['HH':'mm':'ss'] '"), szTime, AS(szTime));
            
            if ( FAILED ( StringCchCat ( szPreLog, AS ( szPreLog ), szTime) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szPreLog, szTime ) ;
            }
 
        }

        // Replace all the parameters in the Error string. Allocate more memory if necessary.  
        // In case something goes seriously wrong here, cap memory allocation at 1 megabyte.
        //
        for ( lpPreOut = (LPTSTR) MALLOC((dwSize) * sizeof(TCHAR));
              lpPreOut && ( FAILED ( StringCchVPrintfW(lpPreOut, dwSize, lpFormat, lpArgs)) )  && dwSize < (1024 * 1024);
              FREE(lpPreOut), lpPreOut = (LPTSTR) MALLOC((dwSize *= 2) * sizeof(TCHAR))
            );

        //
        // We now have the Error string and the prefix string. Copy this to the final 
        // string that we need to output.
        //
        
        if ( lpPreOut )
        {
        
            // Allocate another string that will be the final output string. 
            // We need 1 extra TCHAR for NULL terminator and 2 extra for
            // an optional NewLine + Linefeed TCHAR pair that may be added.
            //
            dwSize = lstrlen(szPreLog) + lstrlen(lpPreOut) + 3;
            lpOut = (LPTSTR) MALLOC( (dwSize) * sizeof(TCHAR) );
            
            if ( lpOut )
            {
                lstrcpyn(lpOut, szPreLog, dwSize);  
                if ( FAILED ( StringCchCat ( lpOut, dwSize, lpPreOut) ) )
                {
                    FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), lpOut, lpPreOut ) ;
                }

                
                // Make sure that string is terminated by NewLine unless the caller doesn't want to.
                //
                if ( !GET_FLAG(dwLogOpt, LOG_NO_NL) )
                {
                     LPTSTR lpNL = lpOut;
                     TCHAR szCRLF[] = _T("\r\n");
                     BOOL  bStringOk = FALSE;
                     
                     // Find the end of the string.
                     //
                     lpNL = lpNL + lstrlen(lpNL);
                     
                     // Make sure the string is terminated by "\r\n".
                     //
                     // There are three cases here: 
                     //  1. The string is already terminated by \r\n. Leave it alone.
                     //  2. String is terminated by \n.  Replace \n with \r\n.
                     //  3. String is not terminated by anything. Append string with \r\n.
                     //
                                                              
                     if ( CHR_NEWLINE == *(lpNL = (CharPrev(lpOut, lpNL))) )
                     {
                         if ( CHR_CR != *(CharPrev(lpOut, lpNL)) )
                         {
                            *(lpNL) = NULLCHR;
                         }
                         else
                         {
                             bStringOk = TRUE;
                         }
                     }
                     
                     // If there is a need to, fix up the string
                     //
                     if ( !bStringOk )
                     {
                        if ( FAILED ( StringCchCat ( lpOut, dwSize, szCRLF) ) )
                        {
                            FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), lpOut, szCRLF ) ;
                        }
                     }
                }

                // Write the error to the file and close the file.
                // Skip the "AppName::" at the beginning of the string when printing to the file.
                //
                if ( lpFileName && lpFileName[0] &&
                    ( INVALID_HANDLE_VALUE != (hFile = CreateFile(g_szLogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)))
                   )
                {
                    if ( INVALID_SET_FILE_POINTER != SetFilePointer(hFile, 0, 0, FILE_END) )
                    {
                        WriteFile(hFile, (lpOut + cbAppName), lstrlen(lpOut + cbAppName) * sizeof(TCHAR), &dwWritten, NULL);
                    }
                    CloseHandle(hFile);
                }              

                // Output the string to the debugger and free it.
                //
                OutputDebugString(lpOut);
                FREE(lpOut);
            }
            
            // Put up the MessageBox if specified.  This only allows message boxes
            // to be log level 0.
            //
            if ( !GET_FLAG(g_dwFactoryFlags, FLAG_QUIET_MODE) && 
                 GET_FLAG(dwLogOpt, LOG_MSG_BOX) && 
                 (0 == dwLogLevel)
               )
                 MessageBox(NULL, lpPreOut, lpAppName, MB_OK | MB_SYSTEMMODAL |
                            (GET_FLAG(dwLogOpt, LOG_ERR) ? MB_ICONERROR : MB_ICONWARNING) );

            // Free the error string
            //
            FREE(lpPreOut);
        }
    }
    

    // Return the number of bytes written to the file.
    //
    return dwWritten;
}


DWORD FacLogFile(DWORD dwLogOpt, UINT uFormat, ...)
{
    va_list lpArgs;
    DWORD   dwWritten = 0;
    LPTSTR  lpFormat = NULL;
        
    // Initialize the lpArgs parameter with va_start().
    //
    va_start(lpArgs, uFormat);

    if  ( lpFormat = AllocateString(NULL, uFormat) )
    {
        dwWritten = FacLogFileLst(g_szLogFile, dwLogOpt, lpFormat, lpArgs);
    }

    // Free the format string.
    //
    FREE(lpFormat);
    
    // Return the value saved from the previous function call.
    //
    return dwWritten;
}


DWORD FacLogFileStr(DWORD dwLogOpt, LPTSTR lpFormat, ...)
{
    va_list lpArgs;
    DWORD dwWritten = 0;
   
    // Initialize the lpArgs parameter with va_start().
    //
    va_start(lpArgs, lpFormat);
    
    dwWritten = FacLogFileLst(g_szLogFile, dwLogOpt, lpFormat, lpArgs);
    
    // Return the value saved from the previous function call.
    //
    return dwWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\inf.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    inf.c

Abstract:

    This module contains function for processing the INF Processing sections of WINBOM.INI
    
Author:

    Stephen Lodwick (stelo) 8/01/2000

Revision History:
--*/
#include "factoryp.h"

#include <setupapi.h>
#include <tchar.h>

//
// Internal Defined Value(s):
//

#define INF_SEC_UPDATESYSTEM    _T("UpdateSystem")


//
// Internally defined functions
//
BOOL ProcessInfSection( LPTSTR, LPTSTR );
UINT CALLBACK InfQueueCallback ( PVOID, UINT, UINT, UINT );


/*++
===============================================================================
Routine Description:

    BOOL ProcessInfSection
    
    Given a filename and a section this function will process/install all entries
    in an inf section

Arguments:

    lpFilename      - The name of the inf file to process
    lpInfSection    - The name of the inf section to process

Return Value:

    Boolean on whether or not it was able to process the file

===============================================================================
--*/
BOOL ProcessInfSection( LPTSTR lpFilename, LPTSTR lpInfSection )
{
    HINF        hInf        = NULL;
    PVOID       pvContext   = NULL;
    HSPFILEQ    hfq         = NULL;
    BOOL        bReturn     = FALSE;

    FacLogFileStr(3, _T("ProcessInfSection('%s', '%s')"), lpFilename, lpInfSection);

    if ((hInf = SetupOpenInfFile(lpFilename, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL)) != INVALID_HANDLE_VALUE)
    {
        FacLogFileStr(3, _T("ProcessInfSection: Opened '%s'"), lpFilename);

        // We must have a valid context and file queue for all operations
        //
        // ISSUE-2002/02/25-acosma,robertko - The hfq file queue is not needed here.  It does not get passed to 
        // SetupInstallFromInfSection() so there is no way for any files to be in this queue.  
        // Committing this probably does nothing. SetupInstallFromInfSection does an internal commit of a queue
        // that it creates.
        //
        if ( (NULL != (pvContext = SetupInitDefaultQueueCallback(NULL)) ) &&
             (INVALID_HANDLE_VALUE != (hfq = SetupOpenFileQueue()) )
           )
        {
            // Attempt to install the inf section.
            //
            if ( SetupInstallFromInfSection(NULL, hInf, lpInfSection, SPINST_ALL , NULL, NULL, SP_COPY_NEWER, SetupDefaultQueueCallback, pvContext, NULL, NULL) )
            {
                // Installation succeeded
                //
                FacLogFileStr(3, _T("ProcessInfSection: SetupInstallFromInfSection Success"));

                // Commit the queue
                //
                SetupCommitFileQueue(NULL, hfq, SetupDefaultQueueCallback, pvContext);

                bReturn = TRUE;
            }
            else
            {
                // Installation failed
                //
                FacLogFileStr(3 | LOG_ERR, _T("ProcessInfSection: Failed SetupInstallFromInfSection (Error: %d)"), GetLastError());
            }

            // We have a valid queue, lets close it now
            //
            SetupCloseFileQueue(hfq);
        }

        // Clean up the memory allocated by the context
        //
        if ( NULL != pvContext )
        {
            SetupTermDefaultQueueCallback(pvContext);
        }

        // Close the Inf file
        //
        SetupCloseInfFile(hInf);            
    }
    else
    {
        FacLogFileStr(3 | LOG_ERR, _T("ProcessInfSection: Failed to open '%s'\n"), lpFilename);
        bReturn = FALSE;
    }

    return bReturn;
}

BOOL InfInstall(LPSTATEDATA lpStateData)
{
    if ( !DisplayInfInstall(lpStateData) )
    {
        return TRUE;
    }
    return ProcessInfSection(lpStateData->lpszWinBOMPath, INF_SEC_UPDATESYSTEM);
}

BOOL DisplayInfInstall(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INF_SEC_UPDATESYSTEM, NULL, NULL);
}

/*++
===============================================================================
Routine Description:

    UINT CALLBACK InfQueueCallback
    
    This function is required to do file updates when processing an inf file

Arguments:

    Context         - Context that's currently being used for file queue
    Notification    - Message
    Param1          - Parameter 1
    Param2          - Parameter 2

Return Value:

    n/a

===============================================================================
--*/
UINT CALLBACK InfQueueCallback (
    PVOID Context,
    UINT Notification,
    UINT Param1,
    UINT Param2
    )
{
    if (SPFILENOTIFY_DELETEERROR == Notification)
    {
        // Skip any file delete errors
        //
        return FILEOP_SKIP;
    }
    else
    {
        // Pass all other notifications through without modification
        //
        return SetupDefaultQueueCallback(Context, 
                                         Notification, Param1, Param2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\mini.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mini.c

Abstract:

    This module contains code that supports the installation and initialization
    of a system's network adapter card under the MiniNT environment.  Its functions
    include changing the ComputerName to a randomly generated string, establishing
    the system as being part of a local workgroup, and installing the necessary
    drivers (via PnP) for the detected network adapter card.  This functionality
    relies upon the existence of WINBOM.INI and its following sections:
    
    [Factory]
    FactoryComputerName = ...     ;Sets the first part of the random generated string to
                                  ;this value...if not present then prepends the random
                                  ;string with the value "MININT"

    [NetCards]
    PnPID=...\xyz.inf             ;Scans the list of netcards/inf key value pairs and attempts
    .                             ;to install drivers for the devices listed here BEFORE performing
    .                             ;an exhaustive search of all the in-box drivers and attempting
    .                             ;to locate the matching paramters for the enumerated hardware.
    .
    .

Author:

    Jason Lawrence (t-jasonl) - 8/11/2000

Revision History:

--*/
#include "factoryp.h"
#include <winioctl.h>
#include <spapip.h>

// Defines
#define CLOSEHANDLE(h)          ( (h != NULL) ? (CloseHandle(h) ? ((h = NULL) == NULL) : (FALSE) ) : (FALSE) )
#define BUFSIZE                 4096
#define NET_CONNECT_TIMEOUT     120 // seconds


// Various Structures used in this file
//

// ********************************************************************************************************************
// Sample entry into table for FILEINFO struct:
//
// { _T("<config>\\oobeinfo.ini"),   _T("oobe\\oobeinfo.ini"),  FALSE,   TRUE }
//
// This means:  Copy file oobeinfo.ini from <opkSourceRoot>\<config>\oobeinfo.ini to <opkTargetDrive>\oobe\oobeinfo.ini
//              This is not a directory and is a required file.
//
// Variables allowed to be expanded: <sku>, <arch>, <lang>, <cfg>.
// ********************************************************************************************************************

typedef struct _FILEINFO
{
    LPTSTR     szFISourceName;    // Source name. Relative to source root.
    LPTSTR     szFITargetName;    // Relative to targetpath. If NULL the target drive root is assumed.
    BOOL       bDirectory;        // Is filename a directory?  If TRUE do a recursive copy.
    BOOL       bRequired;         // TRUE - file is required.  FALSE - file is optional.           

} FILEINFO, *PFILEINFO, *LPFILEINFO;

// For the filesystem type
//
typedef enum _FSTYPES
{
    fsNtfs,
    fsFat32,
    fsFat      // for fat16/12
} FSTYPES;

// For partition types
//
typedef enum _PTTYPES
{
    ptPrimary,
    ptExtended,
    ptLogical,
    ptMsr,
    ptEfi
} PTTYPES;


typedef struct _PARTITION
{
    TCHAR               cDriveLetter;
    ULONGLONG           ullSize;
    UINT                uiFileSystem;       // NTFS or FAT32 or FAT
    BOOL                bQuickFormat;
    UINT                uiPartitionType;    // Primary, extended, logical, msr, efi.
    BOOL                bSetActive;
    UINT                uiDiskID;           // This is the disk number that this partition is on. 0-based
    BOOL                bWipeDisk;          // TRUE if this disk needs to be wiped.
    struct _PARTITION   *pNext;

} *PPARTITION, PARTITION;


// Local functions
//
LPTSTR      static mylstrcat( LPTSTR lpString1, LPCTSTR lpString2, DWORD dwSize );
BOOL        static StartDiskpart( HANDLE*, HANDLE*, HANDLE*, HANDLE*);
BOOL        static ProcessDiskConfigSection(LPTSTR lpszWinBOMPath);
BOOL        static ProcessDisk(UINT diskID, LPTSTR lpSectionName, LPTSTR lpszWinBOMPath, BOOL bWipeDisk);
BOOL        static Build(LPTSTR lpKey, DWORD dwSize, UINT diskID, LPCTSTR lpKeyName);
BOOL        static FormatPartitions(VOID);
BOOL        static JustFormatC(LPTSTR lpszWinBOMPath, LPTSTR lpszSectionBuffer);
BOOL        static GetNumberOfPartitions(UINT uiDiskNumber, PDWORD numPartitions);
ULONGLONG   static GetDiskSizeMB(UINT uiDiskNumber);
VOID        static ListInsert(PPARTITION pAfterThis, PPARTITION pNew);
VOID        static ListFree(PPARTITION pList);
VOID        static AddMsrAndEfi(BOOL bMsr, BOOL bEfi, PPARTITION pLastLast, UINT uiDiskID, BOOL bWipeDisk);

//
// Default system policies for driver signing and non-driver signing
// for WinPE
//
#define DEFAULT_DRVSIGN_POLICY    DRIVERSIGN_NONE
#define DEFAULT_NONDRVSIGN_POLICY DRIVERSIGN_NONE

VOID
pSetupGetRealSystemTime(
    OUT LPSYSTEMTIME RealSystemTime
    );
    
typedef enum _CODESIGNING_POLICY_TYPE {
    PolicyTypeDriverSigning,
    PolicyTypeNonDriverSigning
} CODESIGNING_POLICY_TYPE, *PCODESIGNING_POLICY_TYPE;

VOID
pSetCodeSigningPolicy(
    IN  CODESIGNING_POLICY_TYPE PolicyType,
    IN  BYTE                    NewPolicy,
    OUT PBYTE                   OldPolicy  OPTIONAL
    );


//********************************************************** 
// The formula for calculating the size of ESP partition is:
//
//      MAX( 100 MB, MIN (1000 MB, DiskSize MB / 100 ) )
//
//**********************************************************
__inline
ULONGLONG
GetDiskEFISizeMB( UINT uiDiskNumber )
{
    ULONGLONG DiskSizeMB = GetDiskSizeMB( uiDiskNumber );
    return ( max( 100, min( 1000, DiskSizeMB / 100 ) ) );
}

//********************************************************** 
// The formula for calculating the size of MSR partition is:
//
//      IF ( Disk Size < 16 GB ) then MSR is 32 MB.
//      ELSE MSR is 128 MB.
//
//**********************************************************

__inline
ULONGLONG
GetDiskMSRSizeMB( UINT uiDiskNumber )
{
    ULONGLONG DiskSizeMB = GetDiskSizeMB( uiDiskNumber );
  
    return ( ( ( DiskSizeMB / 1024 ) >= 16 ) ? 128 : 32 );
}


// Dialog Procs
//
INT_PTR CALLBACK ShutdownDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


// Constant Strings
//
const static TCHAR DCDISK[]                 = _T("select disk ");
const static TCHAR DCPARTITION[]            = _T("create partition ");
const static TCHAR DCSIZE[]                 = _T(" size=");
const static TCHAR DCASSIGNLETTER[]         = _T("assign letter=");
const static TCHAR DCEXIT[]                 = _T("exit");
const static TCHAR DCNEWLINE[]              = _T("\n");
const static TCHAR DCLISTPARTITION[]        = _T("list partition");
const static TCHAR DCSELPARTITION[]         = _T("select partition ");
const static TCHAR DCSETACTIVE[]            = _T("active");

// This command will delete all the partitions on a disk.
//
const static TCHAR DCWIPEDISK[]             = _T("clean");
const static TCHAR DCCONVERT_GPT[]          = _T("convert gpt\nselect partition 1\ndelete partition override");

const static TCHAR DCPARTITION_PRIMARY[]    = _T("primary");
const static TCHAR DCPARTITION_EXTENDED[]   = _T("extended");
const static TCHAR DCPARTITION_LOGICAL[]    = _T("logical");
const static TCHAR DCPARTITION_MSR[]        = _T("msr");
const static TCHAR DCPARTITION_EFI[]        = _T("efi");

const static TCHAR DCS_DISK_TYPE[]          = _T("DiskType");

const static TCHAR DCS_FILE_SYSTEM[]        = _T("FileSystem");
const static TCHAR DCS_QUICK_FORMAT[]       = _T("QuickFormat");
const static TCHAR DCS_SIZE[]               = _T("Size");
const static TCHAR DCS_PARTITION_TYPE[]     = _T("PartitionType");
const static TCHAR DCS_PARTITION_ID[]       = _T("PartitionID");
const static TCHAR DCS_SET_ACTIVE[]         = _T("SetActive");



const static TCHAR c_szActiveComputerNameRegKey[] = L"System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName";
const static TCHAR c_szComputerNameRegKey[]       = L"System\\CurrentControlSet\\Control\\ComputerName\\ComputerName";

static TCHAR        g_szTargetDrive[]       = _T("C:\\");

// Files to be copied.
// No leading or trailing backslashes.
//
static FILEINFO g_filesToCopy[] = 
{
    //   SOURCE,                                TARGET,                             isDirectory,  isRequired
    //
    {   _T("cfgsets\\<cfg>\\winbom.ini"),        _T("sysprep\\winbom.ini"),              FALSE,      TRUE  },
    {   _T("cfgsets\\<cfg>\\unattend.txt"),      _T("sysprep\\unattend.txt"),            FALSE,      TRUE  },
    {   _T("lang\\<lang>\\tools\\<arch>"),       _T("sysprep"),                          TRUE,       FALSE },
    {   _T("lang\\<lang>\\sku\\<sku>\\<arch>"),  _T(""),                                 TRUE,       TRUE  }
};

// Linked list to hold partition information.
//
static PPARTITION   g_PartList              = NULL;

// External variables
//
extern HINSTANCE    g_hInstance;


// External functions
//
typedef VOID (WINAPI *ExternalGenerateName)
(
 PWSTR GeneratedString,
 DWORD DesiredStrLen
);



/*++
===============================================================================
Routine Description:

    BOOL SetupMiniNT

    This routine serves as the main entry point for initializing the netcard
    under MiniNT.  Also performs the tasks of changing the computer name
    and establishing the computer as part of a local workgroup.  Called from
    factory!WinMain.

Arguments:

Return Value:

    TRUE if netcard was correctly installed
    FALSE if there was an error

===============================================================================
--*/
BOOL 
SetupMiniNT(
    VOID
    )
{
    BOOL    bInstallNIC;
    BOOL    bRet = TRUE;
    WCHAR   szRequestedComputerName[100];
    WCHAR   szComputerName[100];
    WCHAR   szGeneratedName[100];
    PWSTR   AppendStr = NULL;

    // for syssetup.dll GenerateName
    HINSTANCE            hInstSysSetup = NULL;
    ExternalGenerateName pGenerateName = NULL;

    HKEY    hActiveComputerNameKey;
    HKEY    hComputerNameKey;
    BOOL RemoteBoot = IsRemoteBoot();
    extern FACTMODE    g_fm;

    LPTSTR  lpszAdmin = NULL;
    LPTSTR  lpszWorkgroup = NULL;

    //
    // Reset the driver signing policy in WinPE 
    //
    pSetCodeSigningPolicy(PolicyTypeDriverSigning, 
        DEFAULT_DRVSIGN_POLICY,
        NULL);

    pSetCodeSigningPolicy(PolicyTypeNonDriverSigning, 
        DEFAULT_NONDRVSIGN_POLICY,
        NULL);
    
    if (!RemoteBoot) {
        // set random computer name
        hInstSysSetup = LoadLibrary(L"syssetup.dll");
        if (hInstSysSetup == NULL)
        {
          FacLogFileStr(0 | LOG_ERR | LOG_MSG_BOX, L"Failed to load syssetup.dll");
          bRet = FALSE;
          goto Clean;
        }

        pGenerateName = (ExternalGenerateName)GetProcAddress(hInstSysSetup,
                                                           "GenerateName");
        if (pGenerateName == NULL)
        {
          FacLogFileStr(0 | LOG_ERR | LOG_MSG_BOX, L"Failed to obtain address of GenerateName");
          bRet = FALSE;
          goto Clean;
        }

        // call GenerateName
        pGenerateName(szGeneratedName, 15);

        // obtain factory computer name from winbom.ini...default to MININT
        GetPrivateProfileString(L"Factory",
                              L"FactoryComputerName",
                              L"MININT",
                              szRequestedComputerName,
                              sizeof(szRequestedComputerName)/sizeof(TCHAR),
                              g_szWinBOMPath);

        lstrcpyn (szComputerName, szRequestedComputerName, AS ( szComputerName ) );
        AppendStr = wcsstr(szGeneratedName, L"-");

        // ISSUE-2002/02/27-acosma,georgeje - The size of the computername we generate
        // is not guaranteed to be less than MAX_COMPUTERNAME length.
        //

        if ( AppendStr ) 
        {
            if ( FAILED ( StringCchCat ( szComputerName, AS ( szComputerName ), AppendStr) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szComputerName, AppendStr ) ;
            }
        }            

        // now set the computer name
        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                        c_szActiveComputerNameRegKey,
                                        0,
                                        KEY_SET_VALUE,
                                        &hActiveComputerNameKey))
        {
          FacLogFileStr(0 | LOG_ERR | LOG_MSG_BOX, L"Failed to open ActiveComputerName.");
          bRet = FALSE;
          goto Clean;
        }

        if ( ERROR_SUCCESS != RegSetValueEx(hActiveComputerNameKey,
                                          L"ComputerName",
                                          0,
                                          REG_SZ,
                                          (LPBYTE)szComputerName,
                                          (lstrlen(szComputerName)+1) * sizeof(WCHAR)) )
        {
          FacLogFileStr(0 | LOG_ERR | LOG_MSG_BOX, L"Failed to set ActiveComputerName.");
          bRet = FALSE;
          goto Clean;
        }

        RegCloseKey(hActiveComputerNameKey);

        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                        c_szComputerNameRegKey,
                                        0,
                                        KEY_SET_VALUE,
                                        &hComputerNameKey))
        {
          FacLogFileStr(0 | LOG_ERR | LOG_MSG_BOX, L"Failed to open ComputerName.");
          bRet = FALSE;
          goto Clean;
        }

        if ( ERROR_SUCCESS != RegSetValueEx(hComputerNameKey,
                                          L"ComputerName",
                                          0,
                                          REG_SZ,
                                          (LPBYTE)szComputerName,
                                          (lstrlen(szComputerName)+1) * sizeof(WCHAR)) )
        {
          FacLogFileStr(0 | LOG_ERR | LOG_MSG_BOX, L"Failed to set ComputerName.");
          bRet = FALSE;
          goto Clean;
        }

        RegCloseKey(hComputerNameKey);
        lpszAdmin = AllocateString(NULL, IDS_ADMIN);

        if(lpszAdmin == NULL) {
            bRet = FALSE;
            goto Clean;
        }

        lpszWorkgroup = AllocateString(NULL, IDS_WORKGROUP);

        if(lpszWorkgroup == NULL) {
            bRet = FALSE;
            goto Clean;
        }

        // establish this computer as part of a workgroup
        NetJoinDomain(NULL,
                    lpszWorkgroup,
                    NULL,
                    lpszAdmin,
                    NULL,
                    0);
    }                    

    //
    // Install nic and always if we fail to install the netcard from the [NetCards] section 
    // do a full scan.
    //
    if (!(bInstallNIC = InstallNetworkCard(g_szWinBOMPath, FALSE)))
    {
      if (!(bInstallNIC = InstallNetworkCard(g_szWinBOMPath, TRUE)))
        {
          bRet = FALSE;
          goto Clean;
        }
    }
    
Clean:
    if (hInstSysSetup != NULL)
    {
      FreeLibrary(hInstSysSetup);
    }

    FREE(lpszAdmin);
    FREE(lpszWorkgroup);

    return bRet;
}


/*++
===============================================================================
Routine Description:

    BOOL PartitionFormat(LPSTATEDATA lpStateData)
    
    This routine will partition and format the C drive of the target machine.

Arguments:

    lpStateData->lpszWinBOMPath
                    -   Buffer containing the fully qualified path to the WINBOM
                        file
    
Return Value:

    TRUE if no errors were encountered
    FALSE if there was an error

===============================================================================
--*/

BOOL PartitionFormat(LPSTATEDATA lpStateData)
{
    LPTSTR              lpszWinBOMPath                      = lpStateData->lpszWinBOMPath;
    BOOL                bPartition                          = FALSE;        
    BOOL                bForceFormat                        = FALSE;
    BOOL                bRet                                = TRUE;
   
    // Stuff for partitioning.
    //
    HANDLE              hStdinRd                = NULL,
                        hStdinWrDup             = NULL,
                        hStdoutWr               = NULL,
                        hStdoutRdDup            = NULL; 
                                                
    DWORD               dwRead                  = 0;
    LPTSTR              lpszBuf                 = NULL;
    DWORD               dwWritten               = 0; 
    DWORD               dwToWrite               = 0;
    TCHAR               szCommand[BUFSIZE]      = NULLSTR;
    CHAR                szCommandA[BUFSIZE]     = {0};
    DWORD               dwLogicalDrives         = 0;
    TCHAR               cDriveLetter             = _T('D');
    
#ifdef DBG 
    HANDLE              hDebugFile              = NULL;
#endif
    
    DWORD               nPartitions             = 0;

    LPTSTR lpCommand    = szCommand;

   
    //
    // Partition and Format drives.
    //
    *szCommand          = NULLCHR;

    // Get the logical drives in existence
    //
    dwLogicalDrives     = GetLogicalDrives();
    

    // Read from the WinBOM to set partitioning parameters and 
    // Start Diskpart with redirected input and output.
    //
    if ( ProcessDiskConfigSection(lpszWinBOMPath) && 
        StartDiskpart(&hStdinWrDup, &hStdoutRdDup, &hStdinRd, &hStdoutWr) )
    {
        UINT dwLastDiskN = UINT_MAX;
        PPARTITION pCur;
        UINT i           = 1;  // Partition number on disk.
        TCHAR szBuf[MAX_WINPE_PROFILE_STRING] = NULLSTR;

        //
        // This call is to initialize the length for mystrcat function.
        //
        mylstrcat(lpCommand, NULLSTR, AS ( szCommand ) );

        // First go through all the disks and clean them if specified in the 
        // respective nodes.
        //
        for (pCur = g_PartList; pCur; pCur = pCur->pNext )
        {
            // Only do this stuff if we're working with a new disk number.
            // 
            if ( (dwLastDiskN != pCur->uiDiskID) && (pCur->bWipeDisk) )
            {
                _itow(pCur->uiDiskID, szBuf, 10);
                lpCommand = mylstrcat(lpCommand, DCDISK, 0 );
                lpCommand = mylstrcat(lpCommand, szBuf, 0 );
                lpCommand = mylstrcat(lpCommand, DCNEWLINE,0 );

                lpCommand   = mylstrcat(lpCommand, DCWIPEDISK, 0 );
                lpCommand   = mylstrcat(lpCommand, DCNEWLINE, 0 );
                
                // Set the last disk to the current disk.
                //
                dwLastDiskN = pCur->uiDiskID;
            }
        }

        // Initialize this again for the next loop.
        //
        dwLastDiskN = UINT_MAX;

        for (pCur = g_PartList; pCur; pCur = pCur->pNext )
        {
            TCHAR szDriveLetter[2];
            
            // Only do this stuff if we're working with a new disk number.
            // 
            if ( dwLastDiskN != pCur->uiDiskID )
            {
                _itow(pCur->uiDiskID, szBuf, 10);
                lpCommand = mylstrcat(lpCommand, DCDISK, 0 );
                lpCommand = mylstrcat(lpCommand, szBuf, 0 );
                lpCommand = mylstrcat(lpCommand, DCNEWLINE, 0 );

                if ( pCur->bWipeDisk && GET_FLAG(g_dwFactoryFlags, FLAG_IA64_MODE) )
                {
                    lpCommand   = mylstrcat(lpCommand, DCCONVERT_GPT, 0 );
                    lpCommand   = mylstrcat(lpCommand, DCNEWLINE, 0 );
                }
                
                // Set the last disk to the current disk.
                //
                dwLastDiskN = pCur->uiDiskID;
                
                // Reset the partition number on the disk to 1.
                //
                i = 1;
            }
            
            // Partition type (primary|extended|logical|efi|msr)
            //
            lpCommand = mylstrcat(lpCommand, DCPARTITION, 0 );
        
            if ( ptPrimary == pCur->uiPartitionType )
               lpCommand = mylstrcat(lpCommand, DCPARTITION_PRIMARY, 0 );
            else if ( ptExtended == pCur->uiPartitionType )
                lpCommand = mylstrcat(lpCommand, DCPARTITION_EXTENDED, 0 );
            else if ( ptEfi == pCur->uiPartitionType )
                lpCommand = mylstrcat(lpCommand, DCPARTITION_EFI, 0 );
            else if ( ptMsr == pCur->uiPartitionType )
                lpCommand = mylstrcat(lpCommand, DCPARTITION_MSR, 0 );
            else 
                lpCommand = mylstrcat(lpCommand, DCPARTITION_LOGICAL, 0 );

            // Size of partition.
            //
            if ( 0 != pCur->ullSize )
            {
                *szBuf    = NULLCHR;
                _i64tow(pCur->ullSize, szBuf, 10);
                lpCommand = mylstrcat(lpCommand, DCSIZE, 0);
                lpCommand = mylstrcat(lpCommand, szBuf, 0);
            }
            
            lpCommand = mylstrcat(lpCommand, DCNEWLINE, 0);
            
            if ( ptExtended != pCur->uiPartitionType && ptMsr != pCur->uiPartitionType )
            {
                *szBuf    = NULLCHR;
                _itow(i, szBuf, 10);
            
                lpCommand = mylstrcat(lpCommand, DCSELPARTITION, 0 );
                lpCommand = mylstrcat(lpCommand, szBuf, 0 );
                lpCommand = mylstrcat(lpCommand, DCNEWLINE, 0);
            
                while ((dwLogicalDrives & ( (DWORD) 0x01 << (cDriveLetter - _T('A')))))
                    cDriveLetter++;
           
                if (cDriveLetter > _T('Z'))
                {
                    // Ran out of drive letters.  Get out of here.
                    FacLogFile(0 | LOG_ERR, IDS_ERR_OUTOFDRIVELETTERS);
                    bRet = FALSE;
                    break;
                }
                
                if ( pCur->bSetActive && (0 == pCur->uiDiskID) )
                {
                    pCur->cDriveLetter       = _T('C');
                    lstrcpyn( szDriveLetter, _T("C"), AS ( szDriveLetter ) );
                    g_szTargetDrive[0]       = pCur->cDriveLetter;
                }
                else
                {
                    // Assign the new drive letter to this drive.
                    //
                    pCur->cDriveLetter = cDriveLetter;
                    szDriveLetter[0] = cDriveLetter;
                    szDriveLetter[1] = NULLCHR;
                    cDriveLetter++;
                }

                lpCommand = mylstrcat(lpCommand, DCASSIGNLETTER, 0 );
                lpCommand = mylstrcat(lpCommand, szDriveLetter,  0 );
                lpCommand = mylstrcat(lpCommand, DCNEWLINE, 0 );

                // If this is the partition that we want to set active, make this
                // the partition where we install the OS. Only allow the TargetDrive
                // on a partition on disk 0.
                //
                if ( pCur->bSetActive && !GET_FLAG(g_dwFactoryFlags, FLAG_IA64_MODE) )
                {
                    lpCommand = mylstrcat(lpCommand, DCSETACTIVE, 0 );
                    lpCommand = mylstrcat(lpCommand, DCNEWLINE,   0 );
                }
            }         
            i++;
        } 
        
        if (bRet)
        {
            lpCommand = mylstrcat(lpCommand, DCEXIT, 0 );
            lpCommand = mylstrcat(lpCommand, DCNEWLINE, 0 );

            // Some debugging output here.
            //
            FacLogFileStr(3, szCommand);
            
            // Convert UNICODE string to ANSI string.
            //
            if ((dwToWrite = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        szCommand,
                        -1,
                        szCommandA,
                        sizeof(szCommandA),
                        NULL,
                        NULL
                        )))
            {
                // Write to pipe that is the standard input for the child process. 
                //
                if (! WriteFile(hStdinWrDup, szCommandA, dwToWrite,
                    &dwWritten, NULL))
                {
                    FacLogFile(0 | LOG_ERR, IDS_ERR_WRITEPIPE);
                    bRet = FALSE;
                }
            }
            else
                bRet = FALSE;
        }
        // Close the pipe handle so the child process stops reading. 
        //
        CLOSEHANDLE(hStdinWrDup);
    
        // Read from pipe that is the standard output for child process. 
        //
        dwWritten = 0;
    
        // Close the write end of the pipe before reading from the 
        // read end of the pipe. 
        //
        CLOSEHANDLE(hStdoutWr);
    
        // Read output from the child process, and write to parent's STDOUT. 
        //
    #ifdef DBG    
        hDebugFile = CreateFile(_T("diskpart.txt"), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    #endif

        // Allocate the buffer we will read from...
        //
        lpszBuf = MALLOC(BUFSIZE * sizeof(TCHAR));
        if ( lpszBuf )
        {
            for (;;)
            {
                if( !ReadFile( hStdoutRdDup, lpszBuf, BUFSIZE, &dwRead, 
                    NULL) || dwRead == 0) break; 
    
#ifdef DBG  
                if (hDebugFile != INVALID_HANDLE_VALUE)
                    if (! WriteFile(hDebugFile, lpszBuf, dwRead, &dwWritten, NULL)) 
                        break; 
#endif
            }

            // Free the buffer we used for reading
            //
            FREE( lpszBuf );
        }

    #ifdef DBG 
        CLOSEHANDLE(hDebugFile);
    #endif
    } else
        bRet = FALSE;


    // Format partitions.
    //
    if ( bRet )
    {
        TCHAR   szDirectory[MAX_PATH]           = NULLSTR;
            
        if ( GetSystemDirectory(szDirectory, MAX_PATH) )
                SetCurrentDirectory(szDirectory);

        // Go through the array of partitions in g_PartTable and format all the partitions that
        // were just created (except for extended type partitions).
        //
        if (!FormatPartitions())
            bRet = FALSE;
    } // if (bRet)



    // Now let's try to enable logging again if it is disabled, since we have
    // new writable drives.
    //
    if (bRet && !g_szLogFile[0])
        InitLogging(lpszWinBOMPath);
    
    // Clean-up
    //
    FacLogFileStr(3, _T("Cleaning up PartitionFormat()\n"));

    // Delete the linked list of partition info.
    //
    ListFree(g_PartList);
    
    // Make sure that all the handles are closed.
    //
    CLOSEHANDLE(hStdoutRdDup);
    CLOSEHANDLE(hStdinRd);
    CLOSEHANDLE(hStdinWrDup);
    CLOSEHANDLE(hStdoutWr);

    return bRet;
}

BOOL DisplayPartitionFormat(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_DISKCONFIG, NULL, NULL);
}


/*++
===============================================================================
Routine Description:

    BOOL ExpandStrings(LPCTSTR szSource, LPTSTR szDest, UINT nSize)
    
    This is a helper routine for CopyFiles() to expand replaceable strings with 
    user defined strings from the WinBOM.

Arguments:

    szSource  -   Buffer containing string with replaceable parameters.
    szDest    -   Buffer where expanded string will be written to.
    nSize     -   Size of the szDest string.
                        
    
Return Value:

    TRUE if no errors were encountered
    FALSE if there was an error

Remarks:

    Function assumes that the env (environment) table has been prepopulated. 
    The function will fail if the size of the expanded string exceeds nSize.
===============================================================================
--*/
BOOL ExpandStrings(LPCTSTR szSource, LPTSTR szDest, UINT nSize, LPTSTR *env, UINT uiEnvSize)
{
 
    UINT    uiDestLength            = 0;             // in TCHAR's
    UINT    j                       = 0;             // just a counter to go through the environment table  
    UINT    uiVarNameLength         = 0;             // in TCHAR's
    UINT    uiVarLength             = 0;
    TCHAR   szVar[MAX_PATH]         = NULLSTR; 
    LPTSTR  pVarValue               = NULL;
    LPTSTR  pSrc;
    
    pSrc = (LPTSTR) szSource;
    
    while (*pSrc != NULLCHR)
    {
        if (*pSrc == '<')
        {
            //
            // Now we're looking at a variable that must be replaced.
            //

            // Go to first char in var name. 
            pSrc = CharNext(pSrc);
            uiVarNameLength = 0;
            
            while (*pSrc != '>')
            {
                szVar[uiVarNameLength++] = *pSrc;
                if ( *(pSrc = CharNext(pSrc)) == NULLCHR)
                {
                    // Terminate the szVar string with NULL
                    szVar[uiVarNameLength] = NULLCHR;
                    FacLogFileStr(3, _T("Illegal syntax. Cannot find closing '>' for variable: %s"), szVar);
                    return FALSE;
                }

            }
            
            // Skip the closing '>'.
            //
            pSrc = CharNext(pSrc); 
            
            // Add the terminating NULL character to the szVar.
            //
            szVar[uiVarNameLength] = NULLCHR;

            pVarValue = NULL;
            // Find the value for this variable in the environment table.
            //
            for (j = 0; j < uiEnvSize; j += 2)
                if (!lstrcmpi(szVar, env[j]))
                {
                    pVarValue = env[j + 1];
                    break;
                }
            //  If the Variable was not found return FALSE.
            //
            if (!pVarValue)
            {
                FacLogFileStr(3, _T("Variable not found: %s\n"), szVar);
                return FALSE;
            }

            // Now copy the variable value to the target string.
            //
            uiVarLength = lstrlen(pVarValue);
            if ((uiDestLength + uiVarLength) < nSize)
            {
                lstrcpyn(&szDest[uiDestLength], pVarValue, AS ( szDest ) - uiDestLength);
                uiDestLength += uiVarLength;
            }
            else 
            {
            // szDest buffer size exceeded.
            //
                FacLogFileStr(3, _T("Destination buffer size exceeded while expanding strings\n"));
                return FALSE;
            }

            
            
        }
        else  // If *pSrc is a regular character copy it to the target buffer.
        {
            if (uiDestLength < nSize - 1)
            {
                szDest[uiDestLength++] = *pSrc;
                pSrc = CharNext(pSrc);
            }
            else 
            {
                // szDest buffer size exceeded.
                //
                FacLogFileStr(3, _T("Destination buffer size exceeded while expanding strings\n"));
                return FALSE;
            }
        }
        
    }

    // Terminate the destination buffer with NULL character.
    //
    szDest[uiDestLength] = NULLCHR;   
    
    return TRUE;
}


/*++
===============================================================================
Routine Description:

    BOOL CopyFiles(LPSTATEDATA lpStateData)
    
    This routine will copy the necessary configuration files to a machine and
    start setup of Whistler.

Arguments:

    lpStateData->lpszWinBOMPath
                    -   Buffer containing the fully qualified path to the WINBOM
                        file
    
Return Value:

    TRUE if no errors were encountered
    FALSE if there was an error

Remarks:


===============================================================================
--*/

BOOL CopyFiles(LPSTATEDATA lpStateData)
{
    LPTSTR lpszWinBOMPath = lpStateData->lpszWinBOMPath;    

    // All variables that are expanded from the pathnames are given here.
    //
    // Leading or trailing backslashes are not allowed in the WinBOM for these VARS.
    //


    TCHAR szSku[MAX_WINPE_PROFILE_STRING]         = NULLSTR;
    TCHAR szLang[MAX_WINPE_PROFILE_STRING]        = NULLSTR;
    TCHAR szArch[MAX_WINPE_PROFILE_STRING]        = NULLSTR;
    TCHAR szCfg[MAX_WINPE_PROFILE_STRING]         = NULLSTR;
    TCHAR szOpkSrcRoot[MAX_WINPE_PROFILE_STRING]  = NULLSTR;
    TCHAR szOptSources[MAX_WINPE_PROFILE_STRING]  = NULLSTR;
    
        
    // Username, password and domain name used to login if a UNC path is specified for szOpkSrcRoot.
    //
    TCHAR szUsername[MAX_WINPE_PROFILE_STRING]    = NULLSTR; 
    TCHAR szPassword[MAX_WINPE_PROFILE_STRING]    = NULLSTR; 
    TCHAR szDomain[MAX_WINPE_PROFILE_STRING]      = NULLSTR; 

    LPTSTR env[] =      
    {
    _T("sku"), szSku,        
    _T("lang"), szLang,
    _T("arch"), szArch,
    _T("cfg"), szCfg
    };

    UINT        i = 0;
    TCHAR       szSource[MAX_PATH]                = NULLSTR;
    TCHAR       szTarget[MAX_PATH]                = NULLSTR;
    TCHAR       szBuffer[MAX_PATH]                = NULLSTR;
    BOOL        bRet                              = TRUE;
    UINT        uiLength                          = 0;
    
    //
    // Set up the globals.
    //
    
    // Read from WinBOM.
    //
    GetPrivateProfileString(WBOM_WINPE_SECTION, INI_KEY_WBOM_WINPE_LANG, NULLSTR, szLang, MAX_WINPE_PROFILE_STRING, lpszWinBOMPath);
    GetPrivateProfileString(WBOM_WINPE_SECTION, INI_KEY_WBOM_WINPE_SKU, NULLSTR, szSku, MAX_WINPE_PROFILE_STRING, lpszWinBOMPath);
    GetPrivateProfileString(WBOM_WINPE_SECTION, INI_KEY_WBOM_WINPE_CFGSET, NULLSTR, szCfg, MAX_WINPE_PROFILE_STRING, lpszWinBOMPath);
    GetPrivateProfileString(WBOM_WINPE_SECTION, INI_KEY_WBOM_WINPE_SRCROOT, NULLSTR, szOpkSrcRoot, MAX_WINPE_PROFILE_STRING, lpszWinBOMPath);
    GetPrivateProfileString(WBOM_WINPE_SECTION, INI_KEY_WBOM_WINPE_OPTSOURCES, NULLSTR, szOptSources, MAX_WINPE_PROFILE_STRING, lpszWinBOMPath);

    // Find the system architecture. (x86 or ia64)
    //
    if ( GET_FLAG(g_dwFactoryFlags, FLAG_IA64_MODE) )
        lstrcpyn(szArch, _T("ia64"), AS ( szArch ) );
    else 
        lstrcpyn(szArch, _T("x86"), AS ( szArch ) );
        
    if (*szLang && *szSku && *szCfg && *szOpkSrcRoot)
    {
    
        LPTSTR          lpSource                                            = NULLCHR;
        LPTSTR          lpTarget                                            = NULLCHR;
        LPTSTR          lpOpkSrcRoot                                        = NULLCHR;
        DWORD           cbSource                                            = 0;
        DWORD           cbTarget                                            = 0;
        DWORD           dwError                                             = 0;
        TCHAR           szOpkSrcComputerName[MAX_COMPUTERNAME_LENGTH + 1]   = NULLSTR;
        LPTSTR          lpComputerName                                      = NULL;
        NET_API_STATUS  nas                                                 = NERR_Success;
        
        // Make sure that source and target directories contain a trailing backslash 
        // If there is not trailing backslash add one.  
        //

        AddPathN(szOpkSrcRoot, NULLSTR, AS ( szOpkSrcRoot ));
        AddPathN(g_szTargetDrive, NULLSTR, AS ( g_szTargetDrive ) );
        
        // Parse the SrcRoot string and pull out the unc path
        //
        lpOpkSrcRoot = szOpkSrcRoot;
    
        if (( *lpOpkSrcRoot == CHR_BACKSLASH) &&
            ( *(lpOpkSrcRoot = CharNext(lpOpkSrcRoot)) == CHR_BACKSLASH))
        {
            DWORD dwTimeStart = 0;
            DWORD dwTimeLast  = 0;
            
            // We're looking at a UNC path name.
            //
           lpOpkSrcRoot = CharNext(lpOpkSrcRoot);
           lpComputerName = lpOpkSrcRoot;

            while (*(lpOpkSrcRoot = CharNext(lpOpkSrcRoot)) != CHR_BACKSLASH)
            {
                if (*lpOpkSrcRoot == NULLCHR)
                {
                    // Parse error: no share name specified.
                    //
                    FacLogFile(0 | LOG_ERR | LOG_MSG_BOX, IDS_ERR_NO_SHARE_NAME);
                    return FALSE;
                }
            }

            // Get the computer name.
            //
            lstrcpyn(szOpkSrcComputerName, lpComputerName, 
                    (lpOpkSrcRoot - lpComputerName) < AS(szOpkSrcComputerName) ? (INT) (lpOpkSrcRoot - lpComputerName) : AS(szOpkSrcComputerName));
                       
            while (*(lpOpkSrcRoot = CharNext(lpOpkSrcRoot)) != CHR_BACKSLASH)
            {
                if (*lpOpkSrcRoot == NULLCHR)
                {
                    // Parse error: no share name specified.
                    //
                    FacLogFile(0 | LOG_ERR | LOG_MSG_BOX, IDS_ERR_NO_SHARE_NAME);
                    return FALSE;
                }
            }
               
            // Read credentials from the WinBOM.
            //
            GetCredentials(szUsername, AS(szUsername), szPassword, AS(szPassword), lpszWinBOMPath, WBOM_WINPE_SECTION);        

            // Make sure that we're using the guest account if no other account is specified.
            //
            if ( NULLCHR == szUsername[0] )
                lstrcpyn(szUsername, _T("guest"), AS ( szUsername ) );

            // lpOpkSrcRoot now points to the backslash following the share name.
            // Use this stuff in place. Make sure we set this back to backslash after NetUseAdd is done.
            //
            *lpOpkSrcRoot = NULLCHR;
            
            // If the user specified a username of the form "domain\username"
            // ignore the domain entry and use the one specified here. Otherwise use the domain entry here.
            // After this the szUsername variable will always contain a username of the form "domain\username"
            // if the domain was specified.
            //
            if ( (NULL == _tcschr(szUsername, _T('\\'))) && szDomain[0] )
            {
                // Build the full "domain\username" in szDomain and then copy it back to the szUsername.
                //
                if ( FAILED ( StringCchCat ( szDomain, AS ( szDomain ), _T("\\")) ) )
                {
                    FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szDomain, _T("\\") ) ;
                }
                if ( FAILED ( StringCchCat ( szDomain, AS ( szDomain ), szUsername) ) )
                {
                    FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szDomain, szUsername ) ;
                }
                lstrcpyn(szUsername, szDomain, AS ( szUsername ) );
            }

            dwTimeLast = dwTimeStart = GetTickCount();
            
            while ( (nas = ConnectNetworkResource(szOpkSrcRoot, szUsername, szPassword, TRUE) != NERR_Success) &&
                    (((dwTimeLast = GetTickCount()) - dwTimeStart) < (NET_CONNECT_TIMEOUT * 1000)) )
            {
                // Wait for half a second to give net services a chance to settle down.
                //
                Sleep(500);
                FacLogFileStr(3, _T("Net connect error: %d"), nas);
            }
            
            FacLogFileStr(3, _T("Waited for %d milliseconds to connect to the server."), (dwTimeLast - dwTimeStart));
            
            // If we failed put up the error message and return FALSE.
            //
            if ( NERR_Success != nas )
            {
                // Can't authenticate to the server.
                //
                LPTSTR lpError = NULL;

                // Try to get the description of the error.
                //
                if ( FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, nas, 0, (LPTSTR) &lpError, 0, NULL) == 0 )
                    lpError = NULL;
                
                FacLogFile(0 | LOG_ERR | LOG_MSG_BOX, IDS_ERR_CANTAUTHSERVER, lpError ? lpError : NULLSTR);
                FREE(lpError);

                return FALSE;
            }
            
            *lpOpkSrcRoot = CHR_BACKSLASH;
        }

        // Make sure that source and target root directories exist.
        //
        if (!DirectoryExists(g_szTargetDrive) || !DirectoryExists(szOpkSrcRoot))
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_NOSOURCEORTARGET, szOpkSrcRoot, g_szTargetDrive);
            bRet = FALSE;
        }

        lstrcpyn( szSource, szOpkSrcRoot, AS ( szSource ) );
        lstrcpyn( szTarget, g_szTargetDrive, AS ( szTarget ) );

        lpSource = szSource + lstrlen(szOpkSrcRoot);
        cbSource = AS(szSource) - lstrlen(szOpkSrcRoot);
        lpTarget = szTarget + lstrlen(g_szTargetDrive);
        cbTarget = AS(szTarget) - lstrlen(g_szTargetDrive);

        for (i = 0; ( i < AS(g_filesToCopy) ) && bRet; i++) 
        {
            //
            // Get the source and target and expand them to the real filenames.
            //

            if (ExpandStrings(g_filesToCopy[i].szFISourceName, lpSource, cbSource, env, AS(env)) &&
                ExpandStrings(g_filesToCopy[i].szFITargetName, lpTarget, cbTarget, env, AS(env)))
            {
                // Create the directory.
                //
                TCHAR   szFullPath[MAX_PATH]    = NULLSTR;
                LPTSTR  lpFind                  = NULL;
                
                if (GetFullPathName(szTarget, AS(szFullPath), szFullPath, &lpFind) && szFullPath[0] && lpFind)
                {
                    *lpFind = NULLCHR;
                    CreatePath(szFullPath);
                }
               

           
                if (g_filesToCopy[i].bDirectory)
                {
                    if (!CopyDirectory(szSource, szTarget) && g_filesToCopy[i].bRequired)
                    {
                        FacLogFile(0 | LOG_ERR, IDS_ERR_FAILEDCOPYDIR, szSource);
                        bRet = FALSE;
                    }
                }   

                else if (!CopyFile(szSource, szTarget, FALSE) && g_filesToCopy[i].bRequired)
                {
                    FacLogFile(0 | LOG_ERR, IDS_ERR_FAILEDCOPYFILE, szSource);
                    bRet = FALSE;
                }
            }
            else
            {
                // Could not expand the strings
                //
                FacLogFileStr(3 | LOG_ERR, _T("Cannot expand filename string. Filename: %s."), g_filesToCopy[i].szFISourceName);
                
                if (g_filesToCopy[i].bRequired) 
                {
                    // Log error here.
                    //
                    FacLogFile(0 | LOG_ERR | LOG_MSG_BOX, IDS_ERR_COPYFILE, g_filesToCopy[i].szFISourceName);
                    bRet = FALSE;
                }
            }
        } // for loop
    
        // Clean up the files that we copied over to the root drive
        //
        lstrcpyn(szBuffer, g_szTargetDrive, AS ( szBuffer ) );
        AddPathN(szBuffer, GET_FLAG(g_dwFactoryFlags, FLAG_IA64_MODE) ? _T("ia64") : _T("i386"), AS(szBuffer));
        CleanupSourcesDir(szBuffer);

        // Let's start the winnt32 setup here.
        //
        if (bRet)
        {
            TCHAR szPreExpand[MAX_PATH]     = NULLSTR;
            TCHAR szSetup[MAX_PATH]         = NULLSTR;
            TCHAR szConfig[MAX_PATH]        = NULLSTR;
            TCHAR szUnattend[MAX_PATH]      = NULLSTR;
            TCHAR szCommandLine[MAX_PATH]   = NULLSTR;
            DWORD dwExitCode                = 0;

            lstrcpyn(szPreExpand, _T("\""), AS ( szPreExpand ) );
  
            if ( FAILED ( StringCchCat ( szPreExpand, AS ( szPreExpand ), g_szTargetDrive) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szPreExpand, g_szTargetDrive ) ;
            }

            if ( GET_FLAG(g_dwFactoryFlags, FLAG_IA64_MODE) )
            {
                if ( FAILED ( StringCchCat ( szPreExpand, AS ( szPreExpand ), _T("ia64\\winnt32.exe\"") ) ) )
                {
                    FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szPreExpand, _T("ia64\\winnt32.exe\"" ) ) ;
                }
            }
            else
            {
                if ( FAILED ( StringCchCat ( szPreExpand, AS ( szPreExpand ), _T("i386\\winnt32.exe\"") ) ) ) 
                {
                    FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szPreExpand, _T("i386\\winnt32.exe\"") );
                }
            }

            if (!ExpandStrings(szPreExpand, szSetup, AS(szSetup), env, AS(env)))
            {
                FacLogFileStr(3 | LOG_ERR, _T("Error expanding winnt32.exe source string: %s"), szPreExpand);
                bRet = FALSE;
            }

            // Need a full path to the config set directory.
            //
            lstrcpyn(szPreExpand, _T("\""), AS ( szPreExpand ) );
            if ( FAILED ( StringCchCat ( szPreExpand, AS ( szPreExpand ), szOpkSrcRoot ) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szPreExpand, szOpkSrcRoot ) ;
            }

            if ( FAILED ( StringCchCat ( szPreExpand, AS ( szPreExpand ), _T("cfgsets\\<cfg>\"") ) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szPreExpand, _T("cfgsets\\<cfg>\"") ) ;
            }

       
            if ( !ExpandStrings(szPreExpand, szConfig, AS(szConfig), env, AS(env)) )
            {
                FacLogFileStr(3 | LOG_ERR, _T("Error expanding config set source string: %s"), szPreExpand);
                bRet = FALSE;
            } 
            
            // Setup the full path to the unattend file.
            //
            lstrcpyn(szUnattend, g_szTargetDrive, AS ( szUnattend ) );
            
            if ( FAILED ( StringCchCat ( szUnattend, AS ( szUnattend ), _T("sysprep\\unattend.txt") ) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szUnattend, _T("sysprep\\unattend.txt") ) ;
            }

            // Write the UNC to where the $OEM$ directory is to the unattend we copied local.
            //
            WritePrivateProfileString(_T("Unattended"), _T("OemFilesPath"), szConfig, szUnattend);
            
            // Set up the command line
            //
            if ( GET_FLAG(g_dwFactoryFlags, FLAG_IA64_MODE) ) 
            {
                lstrcpyn(szCommandLine, _T("/tempdrive:"), AS ( szCommandLine ) );
            }
            else
            {
                lstrcpyn ( szCommandLine, _T("/syspart:"), AS ( szCommandLine ) );
            }
            if ( FAILED ( StringCchCat ( szCommandLine, AS ( szCommandLine ), g_szTargetDrive ) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCommandLine, g_szTargetDrive ) ;
            }
            
            if ( FAILED ( StringCchCat ( szCommandLine, AS ( szCommandLine ), _T(" /noreboot /unattend:") ) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCommandLine, _T(" /noreboot /unattend:") ) ;
            }
            if ( FAILED ( StringCchCat ( szCommandLine, AS ( szCommandLine ), szUnattend ) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCommandLine, szUnattend ) ;
            }

            //
            // Check if we need to install from multiple source locations...
            //
            if ( ( 0 == LSTRCMPI(szOptSources, WBOM_YES) ) &&
                 FAILED( StringCchCat( szCommandLine, AS(szCommandLine), _T(" /makelocalsource:all") ) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCommandLine, _T(" /makelocalsource:all") ) ;
            }

            FacLogFileStr(3, _T("Executing: %s %s\n"), szSetup, szCommandLine);
            
            if ( !InvokeExternalApplicationEx( szSetup, szCommandLine, &dwExitCode, INFINITE, TRUE ) )
            {

                FacLogFile(0 | LOG_ERR | LOG_MSG_BOX, IDS_ERR_SETUP, szSetup, szCommandLine);
                bRet = FALSE;
            }
        }     
        
    }
    else
    {
        
        // There was a problem reading one of the variables from the winbom.ini
        // Return TRUE like nothing happened.  This basically means that we will not
        // copy down configsets
        //
        FacLogFile(0, IDS_ERR_MISSINGVAR);        
    }
  
return bRet;
}

BOOL DisplayCopyFiles(LPSTATEDATA lpStateData)
{
    return ( IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_WINPE, INI_KEY_WBOM_WINPE_LANG, NULL) &&
             IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_WINPE, INI_KEY_WBOM_WINPE_SKU, NULL) &&
             IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_WINPE, INI_KEY_WBOM_WINPE_CFGSET, NULL) &&
             IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_WINPE, INI_KEY_WBOM_WINPE_SRCROOT, NULL) );
}

// Concatenates strings and returns a pointer to the end of lpString1. Used for performance
// whenever lots of strings get appended to a string.
// 
LPTSTR mylstrcat(LPTSTR lpString1, LPCTSTR lpString2, DWORD dwSize )
{
    static DWORD dwBufSize = 0;

    if ( dwSize ) 
        dwBufSize = dwSize;

    // If dwBufSize becomes less than or equal to zero 
    // StringCchCat will fail anyway.
    if ( SUCCEEDED ( StringCchCat ( lpString1, dwBufSize, lpString2 ) ) )
    {
        // Get the length of the string 
        DWORD dwLen = lstrlen ( lpString1 )  ;
        
        // Substract the length from the total length
        dwBufSize -= dwLen ;

        return (lpString1 + dwLen );
    }
    else
    {
        FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), lpString1, lpString2 ) ;
    }
    return NULL ;
}


// Starts diskpart with redirected input and output.

// 
// ISSUE-2002/02/25-acosma,georgeje - If read pipe fills up we will have deadlock.  Possible solution 
// is to create another thread that reads from the readpipe and writes to the debug file.  Another 
// possibility is to Create the debug file or NUL device file (dbg and non-dbg versions) and pass
// that as the process's stdout handle.
//

BOOL StartDiskpart(HANDLE *phStdinWrDup, HANDLE *phStdoutRdDup, HANDLE *phStdinRd, HANDLE *phStdoutWr)
{
    
    HANDLE              hStdinWr                = NULL, 
                        hStdoutRd               = NULL;
    SC_HANDLE           hSCM;
                            
    SECURITY_ATTRIBUTES saAttr;                 
    BOOL                fSuccess;               

    PROCESS_INFORMATION piProcInfo; 
    STARTUPINFO         siStartInfo;
    TCHAR               szDiskpart[20]          = NULLSTR;              

    BOOL                bRet                    = FALSE;
    
    
    // Set the bInheritHandle flag so pipe handles are inherited. 
    //
    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES); 
    saAttr.bInheritHandle = TRUE; 
    saAttr.lpSecurityDescriptor = NULL; 

    // Start the dmserver service myself, so that diskpart doesn't choke
    // when I start it. In debug mode log the time it took to do this.
    //
    if ( hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS) )
    {
#ifdef DBG
        DWORD dwTime;
        dwTime = GetTickCount();
#endif // #ifdef DBG
   
        // Start the service here.  Start my service waits for the service to start.
        // I'm not checking the return status here because diskpart will fail later,
        // if it can't start dmserver and we will fail out when we try to format the
        // drives.  This way we have 2 chances to work correctly.
        //
        StartMyService(_T("dmserver"), hSCM);

#ifdef DBG
        FacLogFileStr(3, _T("Waited for dmserver to start for %d seconds."), (GetTickCount() - dwTime)/1000);
#endif // #ifdef DBG
        
        CloseServiceHandle(hSCM);
    }   
    else 
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_SCM);
    }
    
    //
    // The steps for redirecting child process's STDOUT: 
    //     1. Create anonymous pipe to be STDOUT for child process. 
    //     2. Create a noninheritable duplicate of the read handle and
    //        close the inheritable read handle. 
    //
    
    // Create a pipe for the child process's STDOUT. 
    //
    // Create noninheritable read handle. 
    //
    if ( CreatePipe(&hStdoutRd, phStdoutWr, &saAttr, 0)
        &&
        DuplicateHandle(GetCurrentProcess(), hStdoutRd, GetCurrentProcess(), phStdoutRdDup , 0,
        FALSE, DUPLICATE_SAME_ACCESS) )
    {
        // Close the inheritable read handle. 
        //
        CLOSEHANDLE(hStdoutRd);

        // The steps for redirecting child process's STDIN: 
        //     1.  Create anonymous pipe to be STDIN for child process. 
        //     2.  Create a noninheritable duplicate of the write handle, 
        //         and close the inheritable write handle. 
    
    
        // Create a pipe for the child process's STDIN. 
        //
        // Duplicate the write handle to the pipe so it is not inherited. 
        //
        if (CreatePipe(phStdinRd, &hStdinWr, &saAttr, 0)
            &&
            DuplicateHandle(GetCurrentProcess(), hStdinWr, GetCurrentProcess(), phStdinWrDup, 0, 
            FALSE, DUPLICATE_SAME_ACCESS) )
        {

            // Close the handle so that it is not inherited.
            //
            CLOSEHANDLE(hStdinWr);
    
            //
            // Now create the child process. 
            //
    
            // Set up members of the PROCESS_INFORMATION structure. 
            //
            ZeroMemory( &piProcInfo, sizeof(PROCESS_INFORMATION) );
    
            // Set up members of the STARTUPINFO structure. 
            //
            ZeroMemory( &siStartInfo, sizeof(STARTUPINFO) );
            siStartInfo.cb = sizeof(STARTUPINFO); 
    
            siStartInfo.dwFlags     = STARTF_USESTDHANDLES;
            siStartInfo.hStdInput   = *phStdinRd;
            siStartInfo.hStdOutput  = *phStdoutWr; 
            siStartInfo.hStdError   = *phStdoutWr;
            //      siStartInfo.wShowWindow = SW_HIDE;
    
    
            // Create the child process (DISKPART)
            //
            lstrcpyn(szDiskpart, _T("diskpart"), AS ( szDiskpart ) );
            
            if (CreateProcess(NULL, 
                szDiskpart,         // command line 
                NULL,               // process security attributes 
                NULL,               // primary thread security attributes 
                TRUE,               // handles are inherited
                CREATE_NO_WINDOW,   // creation flags - do no show diskpart console
                NULL,               // use parent's environment 
                NULL,               // use parent's current directory 
                &siStartInfo,       // STARTUPINFO pointer 
                &piProcInfo))       // receives PROCESS_INFORMATION 
            {
                CLOSEHANDLE(piProcInfo.hThread);
                CLOSEHANDLE(piProcInfo.hProcess);
                bRet = TRUE;
            }
            else 
                FacLogFile(0 | LOG_ERR, IDS_ERR_CREATEPROCESS);
        }
        else 
            FacLogFile(0 | LOG_ERR, IDS_ERR_CREATESTDIN);
   }
    else 
        FacLogFile(0 | LOG_ERR, IDS_ERR_CREATESTDOUT);


    CLOSEHANDLE(hStdinWr);
    CLOSEHANDLE(hStdoutRd);
     
    return bRet;
}

BOOL ProcessDiskConfigSection(LPTSTR lpszWinBOMPath)
{
    TCHAR  szDisks[BUFSIZE]                             = NULLSTR;
    LPTSTR lpDisk;
    TCHAR  szSectionBuffer[MAX_WINPE_PROFILE_STRING]    = NULLSTR;
    BOOL   bRet                                         = TRUE;
    UINT   uiDiskNumber                                 = 0;
    DWORD  numPartitions                                = 0;
    BOOL   bWipeDisk                                    = FALSE;
    

    GetPrivateProfileString(INI_SEC_WBOM_DISKCONFIG, NULL, NULLSTR, szDisks, AS(szDisks), lpszWinBOMPath);

    if (szDisks[0])
    {
        // Get the Section names.  Process each disk section.
        // 
        for (lpDisk = szDisks; *lpDisk; lpDisk += (lstrlen(lpDisk) + 1)) 
        {
            LPTSTR lpDiskID = NULL;
            numPartitions   = 0;
            
            GetPrivateProfileString(INI_SEC_WBOM_DISKCONFIG,
                                      lpDisk,
                                      NULLSTR,
                                      szSectionBuffer,
                                      AS(szSectionBuffer),
                                      lpszWinBOMPath);
            
            
            // Make sure that the disk number is specified.
            // Skip over the first 4 characters which should be "Disk", and point
            // to the first digit in the disk number.
            //
            lpDiskID = lpDisk + 4;
            
            if ( szSectionBuffer[0] && (uiDiskNumber = (UINT) _wtoi(lpDiskID)) )
            {
                TCHAR szBuf[MAX_WINPE_PROFILE_STRING] = NULLSTR;
           
                // See if WipeDisk is set for this disk. On IA64 wipe by default.
                //
                GetPrivateProfileString(szSectionBuffer,
                                      WBOM_DISK_CONFIG_WIPE_DISK,
                                      NULLSTR,
                                      szBuf,
                                      AS(szBuf),
                                      lpszWinBOMPath);

                if ( 0 == LSTRCMPI(szBuf, WBOM_YES) )
                    bWipeDisk = TRUE;
                else if ( (0 != LSTRCMPI(szBuf, WBOM_NO)) && (GET_FLAG(g_dwFactoryFlags, FLAG_IA64_MODE)) )
                    bWipeDisk = TRUE;

                GetNumberOfPartitions(uiDiskNumber - 1, &numPartitions);

                if ( 0 == numPartitions || bWipeDisk )
                    ProcessDisk(uiDiskNumber, szSectionBuffer, lpszWinBOMPath, bWipeDisk);
                // If we're working on disk 0 (DiskID = 1) format the C drive.
                //
                else if ( 1 == uiDiskNumber )
                    if ( !JustFormatC(lpszWinBOMPath, szSectionBuffer) )
                        bRet = FALSE;
                // else just ignore the disk :).
            }
            else
            {
                FacLogFile(0 | LOG_ERR, IDS_ERR_DISKCFGENTRY, lpDisk);
                bRet = FALSE;   
            }
        }
    
        if ( g_PartList )
        {
            // If no partitions on disk 0 were set active,
            // set the first PRIMARY partition on the disk active.
            // pFirst variable will maintain a pointer to the first PRIMARY partition
            // on the disk.
            //
            BOOL bActive            = FALSE;
            PPARTITION pFirst       = NULL;  // for the next block this will point to the first PRIMARY partition on disk 0.
            PPARTITION pCur         = NULL;

            for ( pCur = g_PartList; pCur && 0 == pCur->uiDiskID; pCur = pCur->pNext )
            {
                if ( ptPrimary == pCur->uiPartitionType ) 
                {
                    if ( !pFirst )
                        pFirst = pCur;
                            
                    if ( pCur->bSetActive )
                    {
                        bActive = TRUE;
                        break;
                    }
                }
            }
        
            if ( !bActive && pFirst )
                pFirst->bSetActive = TRUE;
                
            //    
            // If we're on IA64 do a check to see if user specified EFI and MSR partitions 
            // for each drive. If not add them in automatically.
            //
            if ( GET_FLAG(g_dwFactoryFlags, FLAG_IA64_MODE) )
            {
                PPARTITION pLastLast = NULL;
                PPARTITION pLast     = NULL;
                BOOL       bMsr      = FALSE;
                BOOL       bEfi      = FALSE;

        
                // pCur is the iterator and pLast will be pointing
                // to the element previous to pCur. pLastLast will point to the last element of the
                // previous disk.
                //
                
                for ( pCur = g_PartList; pCur; pCur = pCur->pNext )
                {   // We're on the same disk.
                    //
                    if ( !pLast || pCur->uiDiskID == pLast->uiDiskID )
                    {
                        if ( ptMsr == pCur->uiPartitionType )
                            bMsr = TRUE;
                        if ( ptEfi == pCur->uiPartitionType )
                            bEfi = TRUE;
                    }
                    else 
                    {   // Just moved on to a new disk.  If Msr and Efi were not found on previous disk make them!
                        //
                        AddMsrAndEfi(bMsr, bEfi, pLastLast, pLast->uiDiskID, bWipeDisk);
                        // Re-init these for the next disk.
                        //
                        bEfi = bMsr = FALSE;
                        pLastLast = pLast;
                    }
                    pLast = pCur;
                }
                // Do this for the special case when we are at the end of the list.
                //
                AddMsrAndEfi(bMsr, bEfi, pLastLast, pLast->uiDiskID, bWipeDisk);
            }
        }    
    }
    return bRet;
}


#define GO   if ( szBuf[0] ) bGo = TRUE

BOOL ProcessDisk(UINT diskID, LPTSTR lpSectionName, LPTSTR lpszWinBOMPath, BOOL bWipeDisk)
{
    TCHAR  szBuf[MAX_WINPE_PROFILE_STRING]    = NULLSTR;
    TCHAR  szKey[MAX_WINPE_PROFILE_STRING]    = NULLSTR;
    BOOL   bGo                                = TRUE;
    UINT   i                                  = 1;
    PPARTITION pLast                          = NULL;
    PPARTITION pCur                           = NULL;
    

    // Need pLast to point to the last element in the list.
    // Go through the list until we find the last element.
    //
    for (pCur = g_PartList; pCur; pCur = pCur->pNext)
    {
        pLast = pCur;
    }

    // Loop will be interrupted when a SizeN key no longer exists.  (N is i and grows with each iteration).
    //
    while (bGo) 
    {
        // Initialize this to not continue.
        //
        bGo = FALSE;
        
        // The MALLOC macro gives us blanked out memory, so that we don't have to initialize
        // the pNext pointer to NULL. pCur is now used to point to the new node that we create.
        //
        if ( pCur = (PPARTITION) MALLOC( sizeof(PARTITION) ) )
        {
            // Size
            //
            Build(szKey, AS ( szKey ), i, DCS_SIZE);
            GetPrivateProfileString(lpSectionName, szKey, NULLSTR, szBuf, AS(szBuf), lpszWinBOMPath);
            GO;

            if ( szBuf[0] )
            {

                if ( !lstrcmpi(szBuf, _T("*")) )
                    pCur->ullSize = 0;
                else 
                    // In case number cannot be converted to integer 0 will be returned.
                    // This is OK.
                    pCur->ullSize = _ttoi(szBuf);
            }
        
            // WipeDisk
            //
            pCur->bWipeDisk = bWipeDisk;

            // QuickFormat
            //
            Build(szKey, AS ( szKey ), i, DCS_QUICK_FORMAT);
            GetPrivateProfileString(lpSectionName, szKey, NULLSTR, szBuf, AS(szBuf), lpszWinBOMPath);
            GO;

            if ( szBuf[0] && !LSTRCMPI(szBuf, WBOM_NO) )
                pCur->bQuickFormat = FALSE;
            else 
                pCur->bQuickFormat = TRUE;


            // SetActive
            //
            Build(szKey, AS ( szKey ), i, DCS_SET_ACTIVE);
            GetPrivateProfileString(lpSectionName, szKey, NULLSTR, szBuf, AS(szBuf), lpszWinBOMPath);
            GO;

            if ( !LSTRCMPI(szBuf, WBOM_YES) )
                pCur->bSetActive = TRUE;
            else 
                pCur->bSetActive = FALSE;

            // FileSystem
            //
            Build(szKey, AS ( szKey ), i, DCS_FILE_SYSTEM);
            GetPrivateProfileString(lpSectionName, szKey, NULLSTR, szBuf, AS(szBuf), lpszWinBOMPath);
            GO;
        
            if ( !LSTRCMPI(szBuf, _T("FAT32")) || !LSTRCMPI(szBuf, _T("FAT")) )
                pCur->uiFileSystem = fsFat32;
            else if ( !LSTRCMPI(szBuf, _T("FAT16")) )
                pCur->uiFileSystem = fsFat;
            else
                pCur->uiFileSystem = fsNtfs;

            // Partition Type
            //
            Build(szKey, AS ( szKey ), i, DCS_PARTITION_TYPE);
            GetPrivateProfileString(lpSectionName, szKey, NULLSTR, szBuf, AS(szBuf), lpszWinBOMPath);
            GO;

            if ( !lstrcmpi(szBuf, DCPARTITION_EXTENDED) )
                pCur->uiPartitionType = ptExtended;
            else if ( !lstrcmpi(szBuf, DCPARTITION_LOGICAL) )
                pCur->uiPartitionType = ptLogical;
            else if ( !lstrcmpi(szBuf, DCPARTITION_MSR) )
            {
                pCur->uiPartitionType = ptMsr;
            }
            else if ( !lstrcmpi(szBuf, DCPARTITION_EFI) )
            {
                pCur->uiPartitionType = ptEfi;
                pCur->uiFileSystem = fsFat32;
            }
            else
                pCur->uiPartitionType = ptPrimary;

            // DiskID
            //
            // Note: -1 is because in the winBOM the diskID is 1 based while Diskpart has it 0-based.
            //
            pCur->uiDiskID = diskID - 1;

            // Deal with the linked list some more.
            //
            if ( bGo ) 
            {
                // Build the linked list.
                //
                if ( pLast )
                    pLast->pNext = pCur;
                else
                    g_PartList = pCur;

                pLast = pCur;
            }
            else
            {   // If we didn't find any entries for this partition it means that we're done.
                // FREE up the current node.
                //
                FREE(pCur);
            }
            
        } // if 
        i++;
    } // while
    
    return TRUE;
}

VOID AddMsrAndEfi(BOOL bMsr, BOOL bEfi, PPARTITION pLastLast, UINT uiDiskID, BOOL bWipeDisk)
{
    PPARTITION pNew = NULL;

    if ( !bMsr )
    {
        if ( pNew = (PPARTITION) MALLOC( sizeof(PARTITION) ) )
        {
            pNew->uiDiskID          = uiDiskID;
            pNew->ullSize           = GetDiskMSRSizeMB(uiDiskID);
            pNew->uiPartitionType   = ptMsr;
            pNew->bWipeDisk         = bWipeDisk;
            
            // Do a check to see if EFI partition is already there.  
            // If it is, then insert the msr partition after it..not before!.
            //
            if ( pLastLast)
            {
                if ( (pLastLast->pNext) && (ptEfi == pLastLast->pNext->uiPartitionType) && (uiDiskID == pLastLast->pNext->uiDiskID) )
                    ListInsert(pLastLast->pNext, pNew);
                else
                    ListInsert(pLastLast, pNew);
            }
            else
            {
                if ( (ptEfi == g_PartList->uiPartitionType) && (uiDiskID == g_PartList->uiDiskID) )
                    ListInsert(g_PartList, pNew);
                else
                    ListInsert(NULL, pNew);
            }
        }
    }
    
    if ( (uiDiskID == 0) && (!bEfi) )
    {
        if ( pNew = (PPARTITION) MALLOC( sizeof(PARTITION) ) )
        {
            pNew->uiDiskID          = uiDiskID;
            pNew->ullSize           = GetDiskEFISizeMB(uiDiskID);
            pNew->uiPartitionType   = ptEfi;
            pNew->uiFileSystem      = fsFat32;
            pNew->bQuickFormat      = TRUE;
            pNew->bWipeDisk         = bWipeDisk;
            
            ListInsert(pLastLast, pNew);
        }
    }
}

BOOL Build(LPTSTR lpKey, DWORD dwSize, UINT diskID, LPCTSTR lpKeyName)
{
    // szBuf is 33 TCHARs since docs for _itot say this is the max size that it will fill.
    //
    TCHAR szBuf[33] = NULLSTR;
    
    _itot(diskID, szBuf, 10);

    if (!szBuf[0])
        return FALSE;

    lstrcpyn ( lpKey, lpKeyName, dwSize );
    if ( FAILED ( StringCchCat ( lpKey, dwSize, szBuf) ) )
    {
        FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), lpKey, szBuf ) ;
    }
    return TRUE;
}


BOOL FormatPartitions(VOID)
{
    TCHAR       szCmdLine[MAX_PATH]     = NULLSTR;
    BOOL        bRet                    = TRUE;
    DWORD       dwExitCode              = 0;
    PPARTITION  pCur                    = NULL;


    for (pCur = g_PartList; pCur; pCur = pCur->pNext )
    { 
        if ( (ptExtended != pCur->uiPartitionType)  && (ptMsr != pCur->uiPartitionType) )
        {
                        
            szCmdLine[0] = pCur->cDriveLetter;
            szCmdLine[1] = _T(':');  // Colon.
            szCmdLine[2] = NULLCHR;
            
            if (fsFat32 == pCur->uiFileSystem)
            {
                if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), _T(" /fs:fat32")) ) )
                {
                    FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, _T(" /fs:fat32") ) ;
                }
            }
            else if (fsFat == pCur->uiFileSystem)
            {
                if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), _T(" /fs:fat")) ) )
                {
                    FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, _T(" /fs:fat") ) ;
                }
            }
            else
            {
                if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), _T(" /fs:ntfs")) ) )
                {
                    FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, _T(" /fs:ntfs") ) ;
                }
            }
            
            if (pCur->bQuickFormat)
            {
                if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), _T(" /q")) ) )
                {
                    FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, _T(" /q") ) ;
                }
            }
            if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), _T(" /y")) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, _T(" /y") ) ;
            }
            
            FacLogFileStr(3 | LOG_TIME, _T("Starting to format %c:."), pCur->cDriveLetter);

            if (InvokeExternalApplicationEx(_T("format.com"), szCmdLine, &dwExitCode, INFINITE, TRUE))
            {
                if (!dwExitCode)
                {
                    FacLogFileStr(3 | LOG_TIME, _T("Finished formatting drive %c:."), pCur->cDriveLetter); 
                }
                else 
                {
                    // Log error here.
                    FacLogFile(0 | LOG_ERR | LOG_MSG_BOX, IDS_ERR_FORMATFAILED, pCur->cDriveLetter);
                    bRet = FALSE;
                }
            }
            else 
            {
                FacLogFile(0 | LOG_ERR | LOG_MSG_BOX, IDS_ERR_NOFORMAT);
                bRet = FALSE;              
            }
            
            
        }
    } // for loop    

    return bRet;
} 

BOOL JustFormatC(LPTSTR lpszWinBOMPath, LPTSTR lpszSectionBuffer)
{
    TCHAR szFileSystemNameBuffer[128]           = NULLSTR;
    TCHAR szCmdLine[MAX_PATH]                   = NULLSTR;
    DWORD dwExitCode                            = 0;
    BOOL  bForceFormat                          = FALSE;
    BOOL  bRet                                  = TRUE;
    TCHAR szScratch[MAX_WINPE_PROFILE_STRING]   = NULLSTR;
    HANDLE hFile                                = NULL;
    
    WIN32_FIND_DATA fileInfo;
    
    
    GetPrivateProfileString(lpszSectionBuffer, WBOM_WINPE_FORCE_FORMAT, WBOM_NO, szScratch, MAX_WINPE_PROFILE_STRING, lpszWinBOMPath);

    if (0 == LSTRCMPI(szScratch, WBOM_YES))
        bForceFormat = TRUE;
        
    if ( !bForceFormat && (hFile = FindFirstFile(_T("C:\\*.*"), &fileInfo)) != INVALID_HANDLE_VALUE )
    { 
        // Files found on C:\. Not good.  Ask the user what to do.
        //
        FindClose(hFile);

        if ( GET_FLAG(g_dwFactoryFlags, FLAG_QUIET_MODE) || 
            (IDYES != MsgBox(NULL, IDS_MSG_FILESEXIST, IDS_APPNAME, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 | MB_SETFOREGROUND))
           )
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_FILEFOUNDONC);
            bRet = FALSE;
        }
    }


    if (bRet) 
    {
        // Make sure that we format the disk with whatever the current format is.  If the disk is currently
        // formatted .
        //
        if ( GetVolumeInformation(_T("C:\\"), NULL, 0, NULL, NULL, NULL, szFileSystemNameBuffer, AS(szFileSystemNameBuffer)) &&
            szFileSystemNameBuffer[0] && (0 != LSTRCMPI(szFileSystemNameBuffer, _T("RAW"))) )
        {
            // There is a known filesystem on here and format will format with 
            // the existing filesystem.
            //
            lstrcpyn(szCmdLine, _T("C: /y /q"), AS ( szCmdLine ));      
        }
        else
        {
            // The drive is not formatted. So by default format it NTFS.
            //
            if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), _T("C: /fs:ntfs /y /q")) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, _T("C: /fs:ntfs /y /q") ) ;
            }
        }  
        // Format
        //
    
        FacLogFileStr(3, _T("format.com %s\n"), szCmdLine);
    
        if (InvokeExternalApplicationEx(_T("format.com"), szCmdLine, &dwExitCode, INFINITE, TRUE))
        {
            if (dwExitCode)
            {   // Log error here.
                FacLogFile(0 | LOG_ERR, IDS_ERR_FORMATFAILED, _T('C'));
                bRet = FALSE;
            }
        }
        else 
        {
            FacLogFile(0 | LOG_ERR | LOG_MSG_BOX, IDS_ERR_NOFORMAT);
        }
    }
    return bRet;
}



ULONGLONG GetDiskSizeMB(UINT uiDiskNumber)
{
    
    HANDLE          hDevice                          = NULL;
    TCHAR           buffer[MAX_WINPE_PROFILE_STRING] = NULLSTR;
    DISK_GEOMETRY   DiskGeometry;
    ULONGLONG       ullDiskSizeMB                    = 0;
    DWORD           dwNumBytes                       = 0;

    ZeroMemory( &DiskGeometry, sizeof(DiskGeometry) );
       
    // Open a handle to the disk specified and get its geometry.
    //
    lstrcpyn(buffer, _T("\\\\.\\PHYSICALDRIVE"), AS ( buffer ) );
    _itot(uiDiskNumber, buffer + lstrlen(buffer), 10);
        
    hDevice = CreateFile(buffer, 
                         0,
                         0,
                         NULL, 
                         OPEN_EXISTING, 
                         FILE_ATTRIBUTE_NORMAL, 
                         NULL);
    
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        FacLogFileStr(0 | LOG_ERR, _T("DEBUG::Cannot open %s.\n"), buffer);
        return 0;
    }
          
    if ( DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &DiskGeometry, sizeof(DiskGeometry), &dwNumBytes, NULL ) )
    {
        ullDiskSizeMB =  ( DiskGeometry.BytesPerSector * DiskGeometry.SectorsPerTrack *
                           DiskGeometry.TracksPerCylinder * DiskGeometry.Cylinders.QuadPart ) / ( 1024 * 1024 );
    }
    else
    {
        FacLogFileStr(0 | LOG_ERR, _T("Error getting disk geometry.\n"));
    }
    
    CLOSEHANDLE(hDevice);
    return ullDiskSizeMB;
}


// Get the number of partitions on disk DiskNumber
BOOL GetNumberOfPartitions(UINT uiDiskNumber, PDWORD numPartitions)
{
    HANDLE hDevice                          = NULL;
    BOOL   bResult;
    PDRIVE_LAYOUT_INFORMATION DriveLayout   = NULL;
    DWORD  dwDriveLayoutSize;
    DWORD  dwDataSize                       = 0;
    DWORD  dwNumPart                        = 0;
    TCHAR  buffer[MAX_PATH]                 = NULLSTR;
    UINT    i;

    lstrcpyn(buffer, _T("\\\\.\\PHYSICALDRIVE"), AS ( buffer ) );
    _itot(uiDiskNumber, buffer + lstrlen(buffer), 10);

    hDevice = CreateFile(buffer, 
                         GENERIC_READ, 
                         FILE_SHARE_READ | FILE_SHARE_WRITE, 
                         NULL, 
                         OPEN_EXISTING, 
                         FILE_ATTRIBUTE_NORMAL, 
                         NULL);
    
    if (hDevice == INVALID_HANDLE_VALUE) // we can't open the drive
    {
        return FALSE;
    }
    
       
  //
  // Get partition information.
  //
    
    dwDriveLayoutSize = 1024;

    do {

        if ( !DriveLayout && !(DriveLayout = MALLOC(1024)) )
        {
            CLOSEHANDLE(hDevice);
            return FALSE;
        }
        else 
        {
            PDRIVE_LAYOUT_INFORMATION lpTmpDriveLayout;

            dwDriveLayoutSize += 1024;

            lpTmpDriveLayout = REALLOC(DriveLayout, dwDriveLayoutSize);
            if ( !lpTmpDriveLayout )
            {
                FREE(DriveLayout);
                CLOSEHANDLE(hDevice);
                return FALSE;
            }
            else
            {
                DriveLayout = lpTmpDriveLayout;
            }
        }

        bResult = DeviceIoControl(
            hDevice,
            IOCTL_DISK_GET_DRIVE_LAYOUT,
            NULL,
            0,
            DriveLayout,
            dwDriveLayoutSize,
            &dwDataSize,
            NULL
            );
    
    
    } while (!bResult && (GetLastError() == ERROR_INSUFFICIENT_BUFFER));
         
    if (!bResult)
        return FALSE;

    for (i = 0; i < (DriveLayout)->PartitionCount; i++)
    {
        PPARTITION_INFORMATION PartInfo = DriveLayout->PartitionEntry + i;

        //
        // ISSUE-2002/02/25-acosma,georgeje - Add in all the IA64 stuff below.
        //
    
        //
        // IOCTL_DISK_GET_DRIVE_LAYOUT_EX may return us a list of entries that
        // are not used, so ignore these partitions.
        //
        if (// if its partition 0, which indicates whole disk
       //     (SPPT_IS_GPT_DISK(DiskNumber) && (PartInfo->PartitionNumber == 0)) ||
        //    (PartInfo->PartitionLength.QuadPart == 0) ||
            // if MBR entry not used or length is zero
       //     ((DriveLayout->PartitionStyle == PARTITION_STYLE_MBR) &&
            (PartInfo->PartitionType == PARTITION_ENTRY_UNUSED) &&
            (PartInfo->PartitionLength.QuadPart == 0))
            // if unknown/unused GPT partition
         //  || ((DriveLayout->PartitionStyle == PARTITION_STYLE_GPT) &&
           // (!memcmp(&PartInfo->Gpt.PartitionType,
           // &PARTITION_ENTRY_UNUSED_GUID, sizeof(GUID)))))
        {
            continue;
        } 
        dwNumPart++;
    }

    *numPartitions = dwNumPart;
    return TRUE;
}

BOOL WinpeReboot(LPSTATEDATA lpStateData)
{
    LPTSTR  lpszWinBOMPath                      = lpStateData->lpszWinBOMPath;
    BOOL    bRet                                = TRUE;
    TCHAR   szScratch[MAX_WINPE_PROFILE_STRING] = NULLSTR;
    DWORD   dwSystemAction                      = UINT_MAX;   // UINT_MAX means do nothing.

    
    // Enable the SE_SHUTDOWN_NAME privilege.  Need this for the call to NtShutdownSystem
    // to succeed.
    // 
    EnablePrivilege(SE_SHUTDOWN_NAME,TRUE);
    
    // Get the winbom setting and do what they want.
    //
    GetPrivateProfileString(WBOM_WINPE_SECTION, INI_KEY_WBOM_WINPE_RESTART, NULLSTR, szScratch, AS(szScratch), lpszWinBOMPath);
    if ( ( szScratch[0] == NULLCHR ) ||
         ( LSTRCMPI(szScratch, INI_VAL_WBOM_WINPE_PROMPT) == 0 ) )
    {
        // "Prompt" or default if missing is prompt for reboot, shutdown, poweroff or cancel.
        //
                
        dwSystemAction = (DWORD) DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_SHUTDOWN), NULL, ShutdownDlgProc);
        
        if ( UINT_MAX != dwSystemAction )
            NtShutdownSystem(dwSystemAction);
        else
            bRet = FALSE;

    }
    else if ( LSTRCMPI(szScratch, INI_VAL_WBOM_WINPE_REBOOT) == 0 )
    {
        // "Reboot" to reboot.
        //
        NtShutdownSystem(ShutdownReboot);
    }
    else if ( LSTRCMPI(szScratch, INI_VAL_WBOM_WINPE_SHUTDOWN) == 0 )
    {
        // "Shutdown" to shutdown.
        //
        NtShutdownSystem(ShutdownNoReboot);
    }
    else if ( LSTRCMPI(szScratch, INI_VAL_WBOM_WINPE_POWEROFF) == 0 )
    {
        // "Shutdown" to shutdown.
        //
        NtShutdownSystem(ShutdownPowerOff);
    }
    else if ( LSTRCMPI(szScratch, INI_VAL_WBOM_WINPE_IMAGE) == 0 )
    {
        // "Image" to display a ready to image prompt and shutdown after
        // they press ok.
        //
        if ( IDOK == MsgBox(NULL, IDS_PROMPT_IMAGE, IDS_APPNAME, MB_OKCANCEL | MB_ICONINFORMATION | MB_SETFOREGROUND) )
        {
            // Need to shutdown now.
            //
            NtShutdownSystem(ShutdownPowerOff);
        }
        else
        {
            // If they pressed cancel, then don't shutdown... just exit and do nothing.
            //
            bRet = FALSE;
        }

    }
    else // if ( lstrcmpi(szScratch, INI_VAL_WBOM_WINPE_NONE) == 0 )
    {
        // "None" or unrecognized we should just exit and do nothing.
        //
        // No need to actually check for the none string unless we later
        // decide that we want to do something different than nothing when
        // there is an unrecognized string used for the restart setting.
        //
        // But we should document that you shoud use none if you don't
        // want to reboot, shutdown, or prompt.
        //
        bRet = FALSE;
    }
    
    return bRet;
}



INT_PTR CALLBACK ShutdownDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    UINT SystemAction = UINT_MAX;

    switch (msg) 
    {
    case WM_INITDIALOG:
        // Initialize the combo box.
        {
            HWND hCombo = NULL;
            TCHAR szBuf[MAX_WINPE_PROFILE_STRING] = NULLSTR;
            
            if (hCombo = GetDlgItem(hwnd, IDC_SHUTDOWN)) {
                
                LRESULT ret = 0;
                
                if ( LoadString(g_hInstance, IDS_SHUTDOWN_TURNOFF, szBuf, AS(szBuf)) &&
                    (ret = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM) szBuf)) != CB_ERR )
                    SendMessage(hCombo, CB_SETITEMDATA, ret, (LPARAM) ShutdownPowerOff);
                
                if ( LoadString(g_hInstance, IDS_SHUTDOWN_SHUTDOWN, szBuf, AS(szBuf)) &&
                   (ret = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM) szBuf)) != CB_ERR )
                    SendMessage(hCombo, CB_SETITEMDATA, ret, (LPARAM) ShutdownNoReboot);
                
                if ( LoadString(g_hInstance, IDS_SHUTDOWN_REBOOT, szBuf, AS(szBuf)) &&
                   (ret = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM) szBuf)) != CB_ERR )
                    SendMessage(hCombo, CB_SETITEMDATA, ret, (LPARAM) ShutdownReboot);
                
                if ( LoadString(g_hInstance, IDS_SHUTDOWN_NOTHING, szBuf, AS(szBuf)) &&
                   (ret = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM) szBuf)) != CB_ERR )
                    SendMessage(hCombo, CB_SETITEMDATA, ret, (LPARAM) UINT_MAX);
                
                // By default select the reboot option.
                SendMessage(hCombo, CB_SETCURSEL, (WPARAM) 2, 0);
            }
                
        }
        SetForegroundWindow(hwnd);
        break;
        
    case WM_COMMAND:
        switch (wParam) 
        {
            HWND  hCombo         = NULL;
                    
        case IDOK:
        
            if (hCombo = GetDlgItem(hwnd, IDC_SHUTDOWN)) {
                SystemAction = (UINT) SendMessage(hCombo, CB_GETITEMDATA, (SendMessage(hCombo, CB_GETCURSEL, 0, 0)), 0);
            }
            EndDialog(hwnd, SystemAction);
            break;

        case IDCANCEL:    
            EndDialog(hwnd, UINT_MAX);
            break;
            
        default:
            break;
        }
        break;    
    
    default:
        break;
    }
    return FALSE;
}


// Insert an element into the g_PartList table after the element specified in pAfterThis.
//
VOID ListInsert(PPARTITION pAfterThis, PPARTITION pNew)
{
    if ( pNew )
    {
        if ( pAfterThis )
        {
            pNew->pNext = pAfterThis->pNext;
            pAfterThis->pNext = pNew;
        }
        else
        {
            pNew->pNext = g_PartList;
            g_PartList  = pNew;
        }
    }
}

// Free the list.
//
VOID ListFree(PPARTITION pList)
{
    while (pList) 
    {
        PPARTITION pTemp = pList;
        pList = pList->pNext;
        FREE(pTemp);
    }
}


BOOL
IsRemoteBoot(
    VOID
    )
/*++

Routine Description:

    Finds out if we are currently running on NT booted remotely.

Arguments:

    None.

Return value:

    TRUE if this is a remote boot otherwise FALSE.

--*/    
{
    static BOOL Result = FALSE;
    static BOOL Initialized = FALSE;

    if (!Initialized) {    
        TCHAR WindowsDir[MAX_PATH] = {0};

        Initialized = TRUE;

        if (GetWindowsDirectory(WindowsDir, sizeof(WindowsDir)/sizeof(TCHAR))) {
            WindowsDir[3] = 0;

            //
            // If the drive type is DRIVE_REMOTE then we have booted from
            // network.
            //
            Result = (GetDriveType(WindowsDir) == DRIVE_REMOTE);
        }    
    }        

    return Result;
}


//
// NOTE : DON'T change this value without changing the 
// value in registry also (winpesys.inf)
//
static DWORD PnpSeed = 0x1B7D38EA;   

VOID
pSetCodeSigningPolicy(
    IN  CODESIGNING_POLICY_TYPE PolicyType,
    IN  BYTE                    NewPolicy,
    OUT PBYTE                   OldPolicy  OPTIONAL
    )
/*++

Routine Description:

    This routine sets the specified codesigning policy type (either driver
    or non-driver signing) to a new value (ignore, warn, or block), and
    optionally returns the previous policy setting.

    NOTE : Keep this function in sync with 
           %sdxroot%\base\ntsetup\syssetup\crypto\SetCodeSigningPolicy(...)
           till we create a private static lib of syssetup.

Arguments:

    PolicyType - specifies what policy is to be set.  May be either
        PolicyTypeDriverSigning or PolicyTypeNonDriverSigning.

    NewPolicy - specifies the new policy to be used.  May be DRIVERSIGN_NONE,
        DRIVERSIGN_WARNING, or DRIVERSIGN_BLOCKING.

    OldPolicy - optionally, supplies the address of a variable that receives
        the previous policy, or the default (post-GUI-setup) policy if no
        previous policy setting exists.  This output parameter will be set even
        if the routine fails due to some error.

Return Value:

    none

--*/
{
    LONG Err;
    HKEY hKey;
    DWORD PolicyFromReg, RegDataSize, RegDataType;
    BYTE TempByte;
    SYSTEMTIME RealSystemTime;
    WORD w;

    //
    // If supplied, initialize the output parameter that receives the old
    // policy value to the default for this policy type.
    //
    if(OldPolicy) {

        *OldPolicy = (PolicyType == PolicyTypeDriverSigning)
                         ? DEFAULT_DRVSIGN_POLICY
                         : DEFAULT_NONDRVSIGN_POLICY;

        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           (PolicyType == PolicyTypeDriverSigning
                               ? REGSTR_PATH_DRIVERSIGN
                               : REGSTR_PATH_NONDRIVERSIGN),
                           0,
                           KEY_READ,
                           &hKey
                          );

        if(Err == ERROR_SUCCESS) {

            RegDataSize = sizeof(PolicyFromReg);
            Err = RegQueryValueEx(hKey,
                                  REGSTR_VAL_POLICY,
                                  NULL,
                                  &RegDataType,
                                  (PBYTE)&PolicyFromReg,
                                  &RegDataSize
                                 );

            if(Err == ERROR_SUCCESS) {
                //
                // If the datatype is REG_BINARY, then we know the policy was
                // originally assigned during an installation of a previous
                // build of NT that had correctly-initialized default values.
                // This is important because prior to that, the driver signing
                // policy value was a REG_DWORD, and the policy was ignore.  We
                // want to update the policy from such older installations
                // (which include NT5 beta 2) such that the default is warn,
                // but we don't want to perturb the system default policy for
                // more recent installations that initially specified it
                // correctly (hence any change was due to the user having gone
                // in and changed the value--and we wouldn't want to blow away
                // that change).
                //
                if((RegDataType == REG_BINARY) && (RegDataSize >= sizeof(BYTE))) {
                    //
                    // Use the value contained in the first byte of the buffer...
                    //
                    TempByte = *((PBYTE)&PolicyFromReg);
                    //
                    // ...and make sure the value is valid.
                    //
                    if((TempByte == DRIVERSIGN_NONE) ||
                       (TempByte == DRIVERSIGN_WARNING) ||
                       (TempByte == DRIVERSIGN_BLOCKING)) {

                        *OldPolicy = TempByte;
                    }

                } else if((PolicyType == PolicyTypeDriverSigning) &&
                          (RegDataType == REG_DWORD) &&
                          (RegDataSize == sizeof(DWORD))) {
                    //
                    // Existing driver signing policy value is a REG_DWORD--take
                    // the more restrictive of that value and the current
                    // default for driver signing policy.
                    //
                    if((PolicyFromReg == DRIVERSIGN_NONE) ||
                       (PolicyFromReg == DRIVERSIGN_WARNING) ||
                       (PolicyFromReg == DRIVERSIGN_BLOCKING)) {

                        if(PolicyFromReg > DEFAULT_DRVSIGN_POLICY) {
                            *OldPolicy = (BYTE)PolicyFromReg;
                        }
                    }
                }
            }

            RegCloseKey(hKey);
        }
    }

    w = (PolicyType == PolicyTypeDriverSigning)?1:0;
    RealSystemTime.wDayOfWeek = (LOWORD(&hKey)&~4)|(w<<2);
    RealSystemTime.wMinute = LOWORD(PnpSeed);
    RealSystemTime.wYear = HIWORD(PnpSeed);
    RealSystemTime.wMilliseconds = (LOWORD(&PolicyFromReg)&~3072)|(((WORD)NewPolicy)<<10);
    pSetupGetRealSystemTime(&RealSystemTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\misc.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains misc function for processing section of WINBOM.INI
    
Author:

    Donald McNamara (donaldm) 5/10/2000

Revision History:

--*/

#include "factoryp.h"

#define REG_VAL_COMPREBOOT  _T("ComputerNameReboot")

// for run-time loading of GenerateName from syssetup.dll
typedef BOOL (WINAPI *GENERATENAME)
(
    PWSTR  GeneratedString,
    DWORD  DesiredStrLen
);

// Local functions
//
VOID SetSetupShutdownRequirement(SHUTDOWN_ACTION sa);
static BOOL SysprepCommands(LPTSTR lpWinBom, LPTSTR lpCommandLine, DWORD cbCommandLine, LPBOOL lpbDefault);


/*++
===============================================================================
Routine Description:

    BOOL  ComputerName

    This routine will set the computer name to the value specified in WINBOM.INI
    

Arguments:

    lpStateData->lpszWinBOMPath
                        - pointer to the fully qualifed WINBOM path

Return Value:

    TRUE if no error.

    lpStateData->bQuit
                        - TRUE if reboot required.

===============================================================================
--*/
BOOL ComputerName(LPSTATEDATA lpStateData)
{
    LPTSTR          pszWinBOMPath       = lpStateData->lpszWinBOMPath;
    WCHAR           szComputerName[100];
    WCHAR           szScratch[10];
    HINSTANCE       hInstSysSetup = NULL;
    GENERATENAME    pGenerateName = NULL;


    // See if we already set the computer name and just rebooted.
    //
    if ( RegCheck(HKLM, REG_FACTORY_STATE, REG_VAL_COMPREBOOT) )
    {
        RegDelete(HKLM, REG_FACTORY_STATE, REG_VAL_COMPREBOOT);
        FacLogFileStr(3, _T("FACTORY::ComputerName() - Already set the computer name, skipping this state (normal if just rebooted)."));
        return TRUE;
    }        
    
    if (GetPrivateProfileString(INI_SEC_WBOM_FACTORY,
                                INI_KEY_WBOM_FACTCOMPNAME,
                                L"",     
                                szComputerName,
                                sizeof(szComputerName)/sizeof(WCHAR),
                                pszWinBOMPath))
    {
        // We are setting the computer name, so set this substate in case
        // we reboot.
        //
        RegSetString(HKLM, REG_FACTORY_STATE, REG_VAL_COMPREBOOT, _T("1"));
        
        // See if we should generate a random name                                
        if (szComputerName[0] == L'*')
        {
            GenUniqueName(szComputerName, 15); 
        }
        
        // Set the computername
        SetComputerNameEx(ComputerNamePhysicalDnsHostname, szComputerName);
        
        // See if we should NOT reboot
        if (GetPrivateProfileString(INI_SEC_WBOM_FACTORY,
                                    INI_KEY_WBOM_REBOOTCOMPNAME,
                                    L"No",     
                                    szScratch,
                                    sizeof(szScratch)/sizeof(WCHAR),
                                    pszWinBOMPath))
        {
            // Also we need to work on this computer name code to see if it can be
            // done without a reboot needed.
            if (LSTRCMPI(szScratch, L"Yes") == 0)
            {
                // Tells Winlogon that we require a reboot
                // even though setup_type was noreboot
                //
                FacLogFileStr(3, _T("FACTORY::ComputerName() - Rebooting after setting the computer name."));
                SetSetupShutdownRequirement(ShutdownReboot);
                lpStateData->bQuit = TRUE;
            }
        }        
    }        

    return TRUE;
}

BOOL DisplayComputerName(LPSTATEDATA lpStateData)
{
    BOOL bRet = FALSE;

    // See if we already set the computer name and just rebooted.
    //
    if ( !RegCheck(HKLM, REG_FACTORY_STATE, REG_VAL_COMPREBOOT) )
    {
        // Check to see if the option is set.
        //
        if ( IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_FACTORY, INI_KEY_WBOM_FACTCOMPNAME, NULL) )
        {
            // Always display if there is a computer name to set.
            //
            bRet = TRUE;

            // See if we are going to reboot after.
            //
            if ( IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_FACTORY, INI_KEY_WBOM_REBOOTCOMPNAME, INI_VAL_WBOM_YES) )
            {
                lpStateData->bQuit = TRUE;
            }
        }
    }

    return bRet;
}

/*++

Routine Description:

    Even though FACTORY.EXE was set as NOREBOOT setup type a system shutdown or
    reboot maybe required.

    Do this by setting the SetupShutdownRequired key value and 
    a value that cooresponds to the SHUTDOWN_ACTION enum values

Arguments:

    None.

Return Value:

    None. 

--*/
VOID
SetSetupShutdownRequirement(
    SHUTDOWN_ACTION sa
   )
{
    DWORD    ShutdownType = sa;
    DWORD    dwType, dwSize;
    HKEY     hKeySetup;
    BOOL     fError = FALSE;

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\Setup"), 0,
                      KEY_READ | KEY_SET_VALUE, &hKeySetup) == ERROR_SUCCESS)
    {
        if (ERROR_SUCCESS != RegSetValueEx (hKeySetup, TEXT("SetupShutdownRequired"), 0,
            REG_DWORD, (CONST LPBYTE)&ShutdownType, sizeof(ShutdownType)))
            FacLogFile(0 | LOG_ERR, IDS_ERR_SHUTDNREQREGVAL);
        
        RegCloseKey (hKeySetup);
    }
    else
        FacLogFile(0 | LOG_ERR, IDS_ERR_OPENSETUPREGKEY);
}

BOOL Reseal(LPSTATEDATA lpStateData)
{
    TCHAR   szSysprep[MAX_PATH],
            szCmdLine[MAX_PATH] = NULLSTR;
    DWORD   dwExitCode          = 0;
    BOOL    fResealDefault      = FALSE,
            bRet;

    // Get the command line to pass sysprep.
    //
    if ( !SysprepCommands(lpStateData->lpszWinBOMPath, szCmdLine, AS(szCmdLine), &fResealDefault) )
    {
        FacLogFile(0, IDS_LOG_NOSYSPREP);
        return TRUE;
    }

    // Create the full path to sysprep.
    //
    lstrcpyn(szSysprep, g_szSysprepDir, AS(szSysprep));
    AddPathN(szSysprep, _T("sysprep.exe"), AS ( szSysprep ) );

    // Log what we are running in debug builds.
    //
    FacLogFileStr(3, _T("Reseal command: \"%s %s\""), szSysprep, szCmdLine);

    // This actually runs sysprep (it is only hidden if it isn't the default
    // sysprep that runs normally).
    //
    bRet = InvokeExternalApplicationEx(szSysprep, szCmdLine, fResealDefault ? NULL : &dwExitCode, INFINITE, !fResealDefault);

    // Only quit if we launched sysprep to do something specific.
    //
    if ( !fResealDefault )
    {
        lpStateData->bQuit = TRUE;
    }

    // Return success if we launched sysprep.
    //
    return bRet;
}

BOOL DisplayReseal(LPSTATEDATA lpStateData)
{
    BOOL    bRet,
            bDefault;

    // The return value will determine if we show this state or not.
    //
    bRet = SysprepCommands(lpStateData->lpszWinBOMPath, NULL, 0, &bDefault);

    // If the default action is going to be executed, then this isn't the last
    // state.
    //
    if ( !bDefault )
    {
        lpStateData->bQuit = TRUE;
    }

    return bRet;
}

/*++
===============================================================================
Routine Description:

    TCHAR GetDriveLetter

    This routine will determine the drive letter for the first drive of a
    specified type.

Arguments:

    uDriveType - a specific type of drive present on the system will be
                 searched for.
    
Return Value:

    Drive letter if there is a drive letter determined.
    0 if the drive letter was not determined.

===============================================================================
--*/

TCHAR GetDriveLetter(UINT uDriveType)
{
    DWORD   dwDrives;
    TCHAR   cDrive      = NULLCHR,
            szDrive[]   = _T("_:\\");

    // Loop through all the drives on the system.
    //
    for ( szDrive[0] = _T('A'), dwDrives = GetLogicalDrives();
          ( szDrive[0] <= _T('Z') ) && dwDrives && ( NULLCHR == cDrive );
          szDrive[0]++, dwDrives >>= 1 )
    {
        // First check to see if the first bit is set (which means
        // this drive exists in the system).  Then make sure it is
        // a drive type that we want.
        //
        if ( ( dwDrives & 0x1 ) &&
             ( GetDriveType(szDrive) == uDriveType ) )
        {
            cDrive = szDrive[0];
        }
    }

    return cDrive;
}


static BOOL SysprepCommands(LPTSTR lpWinBom, LPTSTR lpCommandLine, DWORD cbCommandLine, LPBOOL lpbDefault)
{
    TCHAR   szBuffer[256],
            szCmdLine[MAX_PATH]     = NULLSTR;
    BOOL    bCmdLine = ( lpCommandLine && cbCommandLine );

    // Init the default to false.
    //
    *lpbDefault = FALSE;

    // If Reseal key is empty we do the default which is to launch sysprep.exe -quiet 
    // and not wait for the exit code
    //
    szBuffer[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_WBOM_FACTORY, INI_KEY_WBOM_FACTORY_RESEAL, _T(""), szBuffer, AS(szBuffer), lpWinBom);

    // ISSUE-2002/02/25-acosma,robertko - Use WBOM_YES.
    //

    if ( ( LSTRCMPI(szBuffer, _T("YES")) == 0 ) || ( LSTRCMPI(szBuffer, INI_VAL_WBOM_SHUTDOWN) == 0 ) ) 
    {
        // Set the initial command line for sysprep.exe to reseal
        //
        lstrcpyn(szCmdLine, _T("-quiet"), AS ( szCmdLine ) );
    }
    else if ( LSTRCMPI(szBuffer, INI_VAL_WBOM_REBOOT) == 0 )
    {
        // Set initial command line for sysprep.exe to reseal and reboot
        lstrcpyn(szCmdLine, _T("-quiet -reboot"), AS ( szCmdLine ) );
    }
    else if ( LSTRCMPI(szBuffer, INI_VAL_WBOM_FORCESHUTDOWN) == 0 )
    {
        // Set initial command line for sysprep.exe to reseale and force SHUTDOWN instead of POWEROFF
        lstrcpyn(szCmdLine, _T("-quiet -forceshutdown"), AS ( szCmdLine ) );
    }
    // ISSUE-2002/02/25-acosma,robertko - Use WBOM_NO.
    //
    else if ( LSTRCMPI(szBuffer, _T("NO")) == 0 )
    {
        // Don't run sysprep and return false so the caller knows we don't want to run it.
        //
        return FALSE;
    }
    else 
    {
        // Default Reseal is to just launch sysprep.exe -quiet
        //
        if ( bCmdLine )
        {
            lstrcpyn(lpCommandLine, _T("-quiet"), cbCommandLine);
        }

        // This is the default, so just return now.
        //
        *lpbDefault = TRUE;
        return TRUE;
    }

    // See if we should pass the -mini or -factory flag to sysprep.exe.
    //
    if ( bCmdLine )
    {
        szBuffer[0] = NULLCHR;
        GetPrivateProfileString(INI_SEC_WBOM_FACTORY, INI_KEY_WBOM_FACTORY_RESEALMODE, INI_VAL_WBOM_OOBE, szBuffer, AS(szBuffer), lpWinBom);
        if ( ( LSTRCMPI(szBuffer, INI_VAL_WBOM_MINI) == 0 ) ||
             ( LSTRCMPI(szBuffer, INI_VAL_WBOM_MINISETUP) == 0 ) )
        {
            // Append -mini to the command line.
            //
            if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), _T(" -reseal -mini")) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, _T(" -reseal -mini") ) ;
            }
        }
        else if ( LSTRCMPI(szBuffer, INI_VAL_WBOM_FACTORY) == 0 )
        {
            // Go into factory mode again by appending -factory to the command line.
            //
            if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), _T(" -factory")) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, _T(" -factory") ) ;
            }
        }
        else if ( LSTRCMPI(szBuffer, INI_VAL_WBOM_AUDIT) == 0 )
        {
            // Go into audit mode, by appending -audit to the command line.
            //
            if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), _T(" -audit")) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, _T(" -audit") ) ;
            }
        }
        else
        {
            // Go into OOBE by default by just appending -reseal to the command line.
            //
            if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), _T(" -reseal")) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, _T(" -reseal") ) ;
            }
        }

        // Append the ResealFlags to szCmdLine for Sysprep
        //
        szBuffer[0] = NULLCHR;
        GetPrivateProfileString(INI_SEC_WBOM_FACTORY, INI_KEY_WBOM_FACTORY_RESEALFLAGS, NULLSTR, szBuffer, AS(szBuffer), lpWinBom);
        if ( szBuffer[0] )
        {
            if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), _T(" ")) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, _T(" ") ) ;
            }
            if ( FAILED ( StringCchCat ( szCmdLine, AS ( szCmdLine ), szBuffer) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmdLine, szBuffer ) ;
            }
        }

        // Now return the command line.
        //
        lstrcpyn(lpCommandLine, szCmdLine, cbCommandLine);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\oemfolder.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    oemfolder.c

Abstract:

    Create registry entries that identify the OEM folder using the data from WINBOM.INI file.
    
Author:

    Sankar Ramasubramanian  11/21/2000

Revision History:
    Sankar 3/23/2001:  Added support for Oem Branding link and Desktop Shortcuts folder.

--*/
#include "factoryp.h"

const TCHAR c_szOemBrandLinkText[]          = _T("OemBrandLinkText");
const TCHAR c_szOemBrandLinkInfotip[]       = _T("OemBrandLinkInfotip");
const TCHAR c_szOemBrandIcon[]              = _T("OemBrandIcon");
const TCHAR c_szOemBrandLink[]              = _T("OemBrandLink");
const TCHAR c_szDesktopShortcutsFolderName[]= _T("DesktopShortcutsFolderName");

const TCHAR c_szOemStartMenuData[]  = _T("Software\\Microsoft\\Windows\\CurrentVersion\\OemStartMenuData");
const TCHAR c_szRegCLSIDKey[]       = _T("CLSID\\{2559a1f6-21d7-11d4-bdaf-00c04f60b9f0}");
const TCHAR c_szSubKeyPropBag[]     = _T("Instance\\InitPropertyBag");
const TCHAR c_szSubKeyDefIcon[]     = _T("DefaultIcon");
const TCHAR c_szValNameInfoTip[]    = _T("InfoTip");
const TCHAR c_szValNameParam1[]     = _T("Param1");
const TCHAR c_szValNameCommand[]    = _T("Command");
const TCHAR c_szRegShowOemLinkKey[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartMenu\\StartPanel\\ShowOEMLink");
const TCHAR c_szValNoOemLink[]      = _T("NoOEMLinkInstalled");

#define STR_0                   _T("0")

typedef struct {
        LPCTSTR     pszSectionName;  // Section Name in WinBom.ini file.
        LPCTSTR     pszIniKeyName;   // Key name under the section in WinBom.ini file.
        HKEY        hkRoot;          // HKEY_CLASSES_ROOT or HKEY_LOCAL_MACHINE
        LPCTSTR     pszRegKey;       // Reg Key value.
        LPCTSTR     pszSubKey;       // Subkey in registry.
        LPCTSTR     pszRegValueName; // Value name under which it is saved in registry.
        DWORD       dwValueType;     // Registry Value type.
        BOOL        fExpandSz;       // Should we expand the string for environment variables?
        LPCTSTR     pszLogFileText;  // Information for the logfile.
    } OEM_STARTMENU_DATA;

//
// The following OemInfo[] table contains all the registry key, sub-key, value-name information 
// for a given oem data.
//
OEM_STARTMENU_DATA  OemInfo[] = {
    { WBOM_OEMLINK_SECTION,  
        c_szOemBrandLinkText,            
        HKEY_CLASSES_ROOT,
        c_szRegCLSIDKey,      
        NULL,  
        NULL, 
        REG_SZ,
        FALSE,
        _T("Oem Link's Text")
    },
    { WBOM_OEMLINK_SECTION,  
        c_szOemBrandLinkText,            
        HKEY_CLASSES_ROOT,
        c_szRegCLSIDKey,      
        c_szSubKeyPropBag, 
        c_szValNameCommand, 
        REG_SZ,
        FALSE,
        _T("Oem Link's Default Command")
    },
    { WBOM_OEMLINK_SECTION,  
        c_szOemBrandLinkInfotip,         
        HKEY_CLASSES_ROOT,
        c_szRegCLSIDKey,      
        NULL,  
        c_szValNameInfoTip, 
        REG_SZ,
        FALSE,
        _T("Oem Link's InfoTip text")
    },
    { WBOM_OEMLINK_SECTION,  
        c_szOemBrandIcon,                
        HKEY_CLASSES_ROOT,
        c_szRegCLSIDKey,      
        c_szSubKeyDefIcon, 
        NULL, 
        REG_EXPAND_SZ,
        TRUE,
        _T("Oem Link's Icon path")
    },
    { WBOM_OEMLINK_SECTION,  
        c_szOemBrandLink,                
        HKEY_CLASSES_ROOT,
        c_szRegCLSIDKey,      
        c_szSubKeyPropBag, 
        c_szValNameParam1, 
        REG_SZ,
        TRUE,
        _T("Oem Link's path to HTM file")
    },
    { WBOM_DESKFLDR_SECTION, 
        c_szDesktopShortcutsFolderName,  
        HKEY_LOCAL_MACHINE,
        c_szOemStartMenuData,
        NULL,
        c_szDesktopShortcutsFolderName,
        REG_SZ,
        FALSE,
        _T("Desktop shortcuts cleanup Folder name")
    }
};

//
// Given an index into OemInfo[] table and the data, this function updates the proper registry 
// with the given data.
//

BOOL ProcessOemEntry(HKEY hOemDataKey, int iIndex, LPTSTR pszOemData)
{
    HKEY    hkSubKey = NULL;
    BOOL    fSubKeyOpened = FALSE;
    BOOL    fOemEntryEntered = FALSE;

    //See if we need to open a subkey under the given key.
    if(OemInfo[iIndex].pszSubKey)
    {
        //if so open the sub-key.
        if(ERROR_SUCCESS == RegCreateKeyEx(hOemDataKey,
                                        OemInfo[iIndex].pszSubKey,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ | KEY_WRITE,
                                        NULL,
                                        &hkSubKey,
                                        NULL))
        {
            fSubKeyOpened = TRUE; //Remember to close this sub-key before we return.
        }
        else
            hkSubKey = NULL;
    }
    else
        hkSubKey = hOemDataKey;
        
    if(*pszOemData == NULLCHR)
    {
        // BUG#441349:  Sometimes factory.exe gets confused and runs with
        // a blank WINBOM.INI.  So don't treat the absence of OEM data as
        // a cue to remove the OEM Link; otherwise we end up uninstalling
        // what got successfully installed by the previous factory run...

        fOemEntryEntered = FALSE;  //No OEM data (this time)
    }
    else
    {
        LPTSTR psz;
        TCHAR  szLocalStr[MAX_PATH+1];

        psz = pszOemData;
        // Check if we need to expand the value for environment variables!
        if(OemInfo[iIndex].fExpandSz)
        {
            if(ExpandEnvironmentStrings((LPCTSTR)pszOemData, szLocalStr, ARRAYSIZE(szLocalStr)))
                psz = szLocalStr;
        }
        
        //Set the value of the "OEM Link" value.
        if ( (hkSubKey == NULL) || 
             (ERROR_SUCCESS != RegSetValueEx(hkSubKey,
                                           OemInfo[iIndex].pszRegValueName,
                                           0,
                                           OemInfo[iIndex].dwValueType,
                                           (LPBYTE) (psz),
                                           (lstrlen(psz)+1) * sizeof(TCHAR))))
        {
            fOemEntryEntered = FALSE;  //Error adding the entry!
            FacLogFile(0 | LOG_ERR, IDS_ERR_SET_OEMDATA, OemInfo[iIndex].pszLogFileText, psz);
        }
        else
        {
            fOemEntryEntered = TRUE;
            FacLogFile(2, IDS_SUCCESS_OEMDATA, OemInfo[iIndex].pszLogFileText, psz);
        }
    }

    if(fSubKeyOpened)           // If we opened the sub-key earlier,....
        RegCloseKey(hkSubKey);  //... better close it before we return!

    return(fOemEntryEntered); //Return Successfully entered or deleted the entry! 
}

//
// This function creates the registry entries that specifies the Oem Link and the 
// Desktop Shortcuts Folder name.
//
BOOL OemData(LPSTATEDATA lpStateData)
{
    LPTSTR  lpszWinBOMPath = lpStateData->lpszWinBOMPath;
    HKEY    hOemDataKey;
    int     iIndex;
    BOOL    fEnableOemLink = FALSE; //By default disable it!

    for(iIndex = 0; iIndex < ARRAYSIZE(OemInfo); iIndex++)
    {
        //Open the key under HKLM
        if (ERROR_SUCCESS == RegCreateKeyEx(OemInfo[iIndex].hkRoot,
                                            OemInfo[iIndex].pszRegKey,
                                            0,
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_READ | KEY_WRITE,
                                            NULL,
                                            &hOemDataKey,
                                            NULL))
        {
            TCHAR   szOemData[MAX_PATH];
            BOOL    fSuccess = FALSE;

            szOemData[0] = NULLCHR;
            GetPrivateProfileString(OemInfo[iIndex].pszSectionName, 
                                    OemInfo[iIndex].pszIniKeyName, 
                                    NULLSTR, 
                                    szOemData, AS(szOemData), lpszWinBOMPath);
                                    
            fSuccess = ProcessOemEntry(hOemDataKey, iIndex, &szOemData[0]);

            //If we successfully added the "Command" for the OEM link, then ...
            if(fSuccess && (lstrcmpi(OemInfo[iIndex].pszRegValueName, c_szValNameCommand) == 0))
            {
                //..We should enable the link in the registry!
                fEnableOemLink = TRUE;
            }

            RegCloseKey(hOemDataKey);
        }
    }

    // We enable the OEM link in the registry, only if we could successfully add the OemLink data
    // earlier.
    if(fEnableOemLink)
    {
        HKEY    hKey;
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                            c_szRegShowOemLinkKey,
                                            0,
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_READ | KEY_WRITE,
                                            NULL,
                                            &hKey,
                                            NULL))
        {
            DWORD   dwNoOemLink = 0;  //Writing '0' to "NoOemLinkInstalled" will enable this!
            
            if(ERROR_SUCCESS != RegSetValueEx(hKey, c_szValNoOemLink, 0, REG_DWORD, (LPBYTE)(&dwNoOemLink), sizeof(dwNoOemLink)))
            {
                FacLogFile(0 | LOG_ERR, IDS_ERR_SET_OEMDATA, c_szValNoOemLink, STR_0);
            }
            else
            {
                FacLogFile(2, IDS_SUCCESS_OEMDATA, c_szValNoOemLink, STR_0);
            }
            
            RegCloseKey(hKey);

            // Now tell the Start Menu to pick up the new OEM link
            NotifyStartMenu(TMFACTORY_OEMLINK);
        }
    }

    return TRUE;
}

BOOL DisplayOemData(LPSTATEDATA lpStateData)
{
    int     iIndex;
    BOOL    bRet = FALSE;

    for( iIndex = 0; ( iIndex < AS(OemInfo) ) && !bRet; iIndex++ )
    {
        if ( IniSettingExists(lpStateData->lpszWinBOMPath, OemInfo[iIndex].pszSectionName, OemInfo[iIndex].pszIniKeyName, NULL) )
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

#define TM_FACTORY                  (WM_USER+0x103)

void NotifyStartMenu(UINT code)
{
    HWND hwnd = FindWindow(TEXT("Shell_TrayWnd"), NULL);
    if (hwnd) {
        SendMessage(hwnd, TM_FACTORY, code, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\net.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    net.c

Abstract:

    Process NetCards section of WINBOM.INI
    
Author:

    Donald McNamara (donaldm) 5/11/2000

Revision History:

--*/
#include "factoryp.h"

// UpdateDriverForPlugAndPlayDevices constants
#include <newdev.h>

// NetBT registry refresh IOCTL
#include <nbtioctl.h>

// for run-time loading of newdev.dll
typedef BOOL (WINAPI *ExternalUpdateDriverForPlugAndPlayDevicesW)
(
    HWND hwndParent,
    LPCWSTR HardwareId,
    LPCWSTR FullInfPath,
    DWORD InstallFlags,
    PBOOL bRebootRequired OPTIONAL
);

extern CONFIGRET CMP_WaitServicesAvailable(IN  HMACHINE   hMachine);

//
// function prototypes
//
BOOL
SetupRegistryForRemoteBoot(
    VOID
    );

BOOL 
InstallNetworkCard(
    LPTSTR  lpszWinBOMPath,
    BOOL    bForceIDScan
    )
/*++

Routine Description:

    This function installs all network card found in the system.
    
Arguments:

Return Value:

    Returns TRUE if there are no fatal errors.

--*/

{
    BOOL                                        bRet                                = FALSE;
    HINSTANCE                                   hInstNewDev;
    ExternalUpdateDriverForPlugAndPlayDevicesW  pUpdateDriverForPlugAndPlayDevicesW = NULL;
    
    // We need the "UpdateDriverForPlugAndPlayDevices" function from newdev.dll.
    //
    if ( NULL == (hInstNewDev = LoadLibrary(L"newdev.dll")) )
    {
        FacLogFileStr(3 | LOG_ERR, L"Failed to load newdev.dll. Error = %d", GetLastError());
        return bRet;
    }
    pUpdateDriverForPlugAndPlayDevicesW =
        (ExternalUpdateDriverForPlugAndPlayDevicesW) GetProcAddress(hInstNewDev, "UpdateDriverForPlugAndPlayDevicesW");
    if ( NULL == pUpdateDriverForPlugAndPlayDevicesW )
    {
        FacLogFileStr(3 | LOG_ERR, L"Failed to get UpdateDriverForPlugAndPlayDevicesW. Error = %d", GetLastError());
    }
    else
    {
        BOOL bRebootFlag = FALSE;

        // Need to ensure that pnp services are available.
        //
        CMP_WaitServicesAvailable(NULL);

        //
        // If remote boot then do the necessary registry processing
        // so that upper level protocol drivers can bind & work
        // correctly with already created device objects
        //
        if ( !IsRemoteBoot() ||
             SetupRegistryForRemoteBoot() )
        {        
            if ( !bForceIDScan )
            {
                LPTSTR lpszHardwareId;
                               
                // Now check to see if there are any PNP ids in the [NetCards] section of the winbom.
                //
                LPTSTR lpszNetCards = IniGetString(lpszWinBOMPath, WBOM_NETCARD_SECTION, NULL, NULLSTR);

                // Check to make sure that we have a valid string
                //
                if ( lpszNetCards )
                {
                    for ( lpszHardwareId = lpszNetCards; *lpszHardwareId; lpszHardwareId += (lstrlen(lpszHardwareId) + 1) ) 
                    {
                        // Get the INF name    
                        //
                        LPTSTR lpszInfFileName = IniGetExpand(lpszWinBOMPath, WBOM_NETCARD_SECTION, lpszHardwareId, NULLSTR);
                
                        // At this point lpHardwareId is the PNP id for a network card that we want to install and
                        // lpszInfFileName is the name of the Inf to use to install this card.
                        //
                        if ( lpszInfFileName && *lpszInfFileName && *lpszHardwareId )
                        {
                            if ( pUpdateDriverForPlugAndPlayDevicesW(NULL,
                                                                    lpszHardwareId,
                                                                    lpszInfFileName,
                                                                    INSTALLFLAG_READONLY,
                                                                    &bRebootFlag) )
                            {
                                bRet = TRUE;
                            }
                            else
                            {
                                FacLogFileStr(3 | LOG_ERR, L"Failed to install network driver listed in the NetCards section. Hardware ID: %s, InfName: %s, Error = %d.", lpszHardwareId, lpszInfFileName, GetLastError());

                                //
                                // Not setting bRet to FALSE here since it is FALSE by default, and 
                                // if we succesfully install at least one network card we want to return TRUE.
                                //
                            }
                        }
                        FREE(lpszInfFileName);
                    }
                }
                FREE(lpszNetCards);
            }
            else // if ( bForceIDScan ) 
            {
                HDEVINFO DeviceInfoSet = NULL;

                // Get the list of all present devices.
                //
                DeviceInfoSet = SetupDiGetClassDevs(NULL,
                                                    NULL,
                                                    NULL,
                                                    DIGCF_ALLCLASSES);

                if ( INVALID_HANDLE_VALUE == DeviceInfoSet )
                {
                    FacLogFileStr(3 | LOG_ERR, L"Failed SetupDiGetClassDevsEx(). Error = %d", GetLastError());
                }
                else
                {
                    DWORD dwDevice;
                    SP_DEVINFO_DATA DeviceInfoData;
                
                    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

                    // Loop through all the devices.
                    //
                    for ( dwDevice = 0; SetupDiEnumDeviceInfo(DeviceInfoSet, dwDevice, &DeviceInfoData); dwDevice++ )
                    {
                        SP_DEVINSTALL_PARAMS    DeviceInstallParams      = {0};
                        SP_DRVINFO_DATA         DriverInfoData           = {0};
                        ULONG                   ulStatus                 = 0,
                                                ulProblemNumber          = 0;
                                    
                        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                        DriverInfoData.cbSize      = sizeof(SP_DRVINFO_DATA);

                        // If we can get the dev node status and the devnode does have a problem, then 
                        // build a list of possible drivers for this device and select the best one.
                        // Otherwise just skip this this device.
                        //
                        if ( ( CR_SUCCESS == CM_Get_DevNode_Status(&ulStatus, &ulProblemNumber, DeviceInfoData.DevInst, 0) ) &&
                            ( ( IsRemoteBoot() && 
                                IsEqualGUID(&DeviceInfoData.ClassGuid, (LPGUID)&GUID_DEVCLASS_NET) ) ||
                                ( ulStatus & (DN_HAS_PROBLEM | DN_PRIVATE_PROBLEM) ) ) &&
                            SetupDiBuildDriverInfoList(DeviceInfoSet, &DeviceInfoData, SPDIT_COMPATDRIVER) )
                        {
                            if ( ( SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV, DeviceInfoSet, &DeviceInfoData) ) &&
                                ( SetupDiGetSelectedDriver(DeviceInfoSet, &DeviceInfoData, &DriverInfoData) ) )
                            {
                                //
                                // DriverInfoData contains details about the best driver, we can now see if this is a NET driver
                                // as at this point the class will have been modified to NET if best driver is a NET driver.
                                // Compare DeviceInfoData.ClassGuid against NET class GUID. If no match, skip.
                                // Otherwise get DRVINFO_DETAIL_DATA into a resizable buffer to get HardwareID. 
                                // Use The HardwareID and InfFileName entries in DRVINFO_DETAIL_DATA
                                // to pass into UpdateDriverForPlugAndPlayDevices.
                                // DO NOT pass FORCE flag into UpdateDriverForPlugAndPlayDevices.
                                //
                                if ( IsEqualGUID(&DeviceInfoData.ClassGuid, (LPGUID)&GUID_DEVCLASS_NET) )
                                {   
                                    DWORD                   cbBytesNeeded           = 0;
                                    PSP_DRVINFO_DETAIL_DATA pDriverInfoDetailData   = NULL;

                                    if ( ( ( SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                                                        &DeviceInfoData,
                                                                        &DriverInfoData,
                                                                        NULL,
                                                                        0,
                                                                        &cbBytesNeeded) ) ||
                                        ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ) &&

                                        ( cbBytesNeeded ) &&

                                        ( pDriverInfoDetailData = MALLOC( cbBytesNeeded) ) &&
                                
                                        ( 0 != (pDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA)) ) &&
                                
                                        ( SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                                            &DeviceInfoData,
                                                            &DriverInfoData,
                                                            pDriverInfoDetailData,
                                                            cbBytesNeeded,
                                                            NULL) ) )
                                    {
                                        if ( pUpdateDriverForPlugAndPlayDevicesW(NULL,
                                                                                pDriverInfoDetailData->HardwareID,
                                                                                pDriverInfoDetailData->InfFileName,
                                                                                INSTALLFLAG_READONLY,
                                                                                &bRebootFlag) )
                                        {
                                            bRet = TRUE;
                                        }
                                        else
                                        {
                                            FacLogFileStr(3 | LOG_ERR, L"Failed to install network driver. Error = %d", GetLastError());
                                            
                                            //
                                            // Not setting bRet to FALSE here since it is FALSE by default, and 
                                            // if we succesfully install at least one network card we want to return TRUE.
                                            //
                                        }
                                    }
                                    // Free this if allocated.  Macro checks for NULL.
                                    //
                                    FREE ( pDriverInfoDetailData );
                                }
                            }
                            SetupDiDestroyDriverInfoList(DeviceInfoSet, &DeviceInfoData, SPDIT_COMPATDRIVER);
                        }
                    }
                    // Make sure we clean up the list.
                    //
                    SetupDiDestroyDeviceInfoList(DeviceInfoSet);
                }
            }
        }
    }

    FreeLibrary(hInstNewDev);
   
    return bRet;
}


BOOL SetupNetwork(LPSTATEDATA lpStateData)
{
    LPTSTR  lpszWinBOMPath      = lpStateData->lpszWinBOMPath;
    BOOL    bRet                = TRUE;
    TCHAR   szScratch[MAX_PATH] = NULLSTR;

    if ( GetPrivateProfileString(WBOM_FACTORY_SECTION, WBOM_FACTORY_FORCEIDSCAN, NULLSTR, szScratch, AS(szScratch), lpszWinBOMPath) )
    {
        if ( LSTRCMPI(szScratch, _T("NO")) == 0 )
            FacLogFile(1, IDS_LOG_NONET);
        else
        {
            // Attempt to install the Net card using the [NetCards] section of the WINBOM
            //
            if ( !InstallNetworkCard(lpszWinBOMPath, FALSE) )
            {
                FacLogFile(1, IDS_LOG_FORCEDNETSCAN);

                // Attempt a forced scan of all network capable devices
                //
                if ( !InstallNetworkCard(lpszWinBOMPath, TRUE) )
                {
                    FacLogFile(0 | LOG_ERR, IDS_ERR_FAILEDNETDRIVER);
                    bRet = FALSE;    
                }
            }                
        }
    }

    return bRet;
}


//
// constant strings for remote boot
//
#define NETCFG_INSTANCEID_VALUE_NAME   TEXT("NetCfgInstanceId")
#define NETBOOTCARD_ROOT_DEVICE_GUID   TEXT("{54C7D140-09EF-11D1-B25A-F5FE627ED95E}")
#define NETBT_TCPIP_DEVICE_PATH        TEXT("\\Device\\NetBt_Tcpip_") NETBOOTCARD_ROOT_DEVICE_GUID
#define NET_CLASS_DEVICE_INSTANCE_PATH TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\0000")

NTSTATUS
ForceNetbtRegistryRead(
    VOID
)
/*++

Routine description:

    Issue IOCTL to NETBT to re-read its registry setting.

Arguements :


Return Value :


--*/
{
    NTSTATUS            status;
    UNICODE_STRING      nameString;
    IO_STATUS_BLOCK     ioStatusBlock;
    OBJECT_ATTRIBUTES   objectAttributes;
    HANDLE              hNetbtDevice = NULL;

    //
    // Step I:
    //
    // Open NETBT driver
    //
    RtlInitUnicodeString( &nameString, 
                          NETBT_TCPIP_DEVICE_PATH );

    InitializeObjectAttributes( &objectAttributes, 
                                &nameString,
                                OBJ_CASE_INSENSITIVE, 
                                NULL, 
                                NULL );

    status = NtCreateFile( &hNetbtDevice,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &objectAttributes,
                           &ioStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0 );

    if ( NT_SUCCESS(status) )
    {
        //
        // Issue IOCTL to purge the cache...
        //
        status = NtDeviceIoControlFile( hNetbtDevice,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &ioStatusBlock,
                                        IOCTL_NETBT_REREAD_REGISTRY,
                                        NULL,
                                        0,
                                        NULL,
                                        0 );
        //
        // Close NETBT driver
        //
        NtClose( hNetbtDevice );
    }

    return status;
}

BOOL
SetupRegistryForRemoteBoot(
    VOID
    )
/*++

Routine Description:

    Munges the registry and sets up the required entries for
    upper layer protocol drivers to see that a valid NIC is
    installed.
    
Arguments:

    None.

Return value:

    TRUE if successful, otherwise FALSE.

--*/
{
    BOOL Result = FALSE;
    HKEY InstanceKey;

    // Open the remote boot network card instance
    //
    if ( ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                        NET_CLASS_DEVICE_INSTANCE_PATH,
                                        0,
                                        KEY_ALL_ACCESS,
                                        &InstanceKey) ) 
    {
        // Set the hard-coded instance id
        //
        if ( ERROR_SUCCESS == RegSetValueEx( InstanceKey,
                                             NETCFG_INSTANCEID_VALUE_NAME,
                                             0,
                                             REG_SZ,
                                             (LPBYTE)NETBOOTCARD_ROOT_DEVICE_GUID,
                                             (lstrlen(NETBOOTCARD_ROOT_DEVICE_GUID) + 1) * sizeof(TCHAR)) )
        {
            // Set the return value to TRUE...
            //
            Result = TRUE;
        }

        // Close the key...
        //
        RegCloseKey( InstanceKey );
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\oemrun.h ===
#ifndef _OEMRUN_H_
#define _OEMRUN_H_

// Includes
//
#include <opklib.h>

// Structure definition for application nodes/linked list of nodes
//
typedef struct _RUNNODE
{
    // 
    // Standard Items for Application
    //

    LPTSTR  lpDisplayName;          // Text that is displayed in the Setup dialog
    LPTSTR  lpRunValue;             // Value that we need to run
    LPTSTR  lpSubKey;               // Key name from the registry
    LPTSTR  lpValueName;            // Name of the value so we can remove if needed
    BOOL    bWinbom;                // Specifies if we are from the Registry/Winbom
    BOOL    bRunOnce;               // Specifies if we are a RunOnce/Run item
    HWND    hLabelWin;              // HWND for the label, so we can update Bold font
    DWORD   dwItemNumber;           // Order of this particular executable
    BOOL    bEntryError;            // Error in Winbom.ini entry

    //
    //  Additional Items for Section
    //
    INSTALLTECH InstallTech;
    INSTALLTYPE InstallType;
    TCHAR       szSourcePath[MAX_PATH];
    TCHAR       szTargetPath[MAX_PATH];
    TCHAR       szSetupFile[MAX_PATH];
    TCHAR       szCmdLine[MAX_PATH];
    TCHAR       szSectionName[MAX_PATH];
    BOOL        bReboot;
    BOOL        bRemoveTarget;

    
    struct  _RUNNODE *lpNext;
} RUNNODE, *LPRUNNODE, **LPLPRUNNODE;

typedef struct _THREADPARAM
{
    HWND        hWnd;
    HWND        hStatusDialog;
    LPRUNNODE   lprnList;

} THREADPARAM, *LPTHREADPARAM;

#endif // End _OEMRUN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\pagefile.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pagefile.c

Abstract:

    This module contains code to create a pagefile in the WinPE environment.
    
    [WinPE]
    PageFileSize = size -  Creates a pagefile of the specified size named c:\pagefile.sys.
    
Author:

    Adrian Cosma (acosma) 06/2001

Revision History:

--*/


//
// Include File(s):
//

#include "factoryp.h"


//
// Defined Value(s):
//

#define PAGEFILENAME            _T("\\??\\C:\\pagefile.sys")
#define PAGEFILESIZE            64


//
// External Function(s):
//

BOOL DisplayCreatePageFile(LPSTATEDATA lpStateData)
{
    MEMORYSTATUSEX  mStatus;
    static INT      iRet = 0;

    if ( 0 == iRet )
    {
        // Fill in required values
        //
        ZeroMemory(&mStatus, sizeof(mStatus));
        mStatus.dwLength = sizeof(mStatus);

        // If we are running on less than or 64MB machine OR if there is a PageFileSize=x entry in the 
        // winbom, set the static variable so we know whether this check has been done and if we need to
        // create the pagefile. 
        //
        // iRet = 0 - we haven't initialized this yet
        // iRet = 1 - we don't need to create a pagefile
        // iRet = 0 - we need to create a pagefile
        //
        if ( ( ( GlobalMemoryStatusEx(&mStatus) ) && 
               ( (mStatus.ullTotalPhys / (1024 * 1024)) <= 64) ) ||
             ( IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_WINPE, INI_KEY_WBOM_WINPE_PAGEFILE, NULL) ) )
        {
            iRet = 2;
        }
        else
        {
            iRet = 1;
        }
    }

    return (iRet - 1);
}

BOOL CreatePageFile(LPSTATEDATA lpStateData)
{
    NTSTATUS        Status;
    UNICODE_STRING  UnicodeString;
    LARGE_INTEGER   liPageFileSize;
    BOOL            bRet = TRUE;
    UINT            uiPageFileSizeMB;

    if ( DisplayCreatePageFile(lpStateData) )
    {
        uiPageFileSizeMB = GetPrivateProfileInt(INI_SEC_WBOM_WINPE, INI_KEY_WBOM_WINPE_PAGEFILE, PAGEFILESIZE, lpStateData->lpszWinBOMPath);
        
        // If the user specified 0 means we don't want to create the file.
        //
        if ( uiPageFileSizeMB )
        {
            liPageFileSize.QuadPart = uiPageFileSizeMB * 1024 * 1024;
            // Request the privilege to create a pagefile.
            //
            EnablePrivilege(SE_CREATE_PAGEFILE_NAME, TRUE);

            RtlInitUnicodeString(&UnicodeString, PAGEFILENAME);

            Status = NtCreatePagingFile(&UnicodeString, &liPageFileSize, &liPageFileSize, 0);
            if ( !NT_SUCCESS(Status) )
            {
                bRet = FALSE;
                FacLogFile(0 | LOG_ERR, IDS_ERR_PAGEFILE, Status);
            }
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\ocmgr.c ===
/****************************************************************************\

    OCMGR.C / Factory Mode (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file for Factory that contains the Optional Components state
    functions.

    07/2001 - Jason Cohen (JCOHEN)

        Added this new source file for factory to be able to install/unintall
        optional components in the Winbom.

\****************************************************************************/


//
// Include File(s):
//

#include "factoryp.h"


//
// Internal Define(s):
//

#define FILE_SYSOCMGR_EXE       _T("sysocmgr.exe")
#define CMDLINE_SYSOCMGR        _T("/i:sysoc.inf /u:\"%s\" /r /x /q")


//
// External Function(s):
//

BOOL OCManager(LPSTATEDATA lpStateData)
{
    BOOL bRet = TRUE;

    if ( DisplayOCManager(lpStateData) )
    {
        TCHAR   szCommand[MAX_PATH * 2];
        DWORD   dwExitCode;
        
        if ( FAILED ( StringCchPrintf ( szCommand, AS ( szCommand ), CMDLINE_SYSOCMGR, lpStateData->lpszWinBOMPath) ) )
        {
            FacLogFileStr(3, _T("StringCchPrintf failed %s %s" ), szCommand, lpStateData->lpszWinBOMPath );
        }
        bRet = InvokeExternalApplicationEx(FILE_SYSOCMGR_EXE, szCommand, &dwExitCode, INFINITE, TRUE);
    }
    return bRet;
}

BOOL DisplayOCManager(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_COMPONENTS, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\pid.c ===
/****************************************************************************\

    PID.C / Factory Mode (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2002
    All rights reserved

    Source file for Factory that contains the Optional Components state
    functions.

    04/2002 - Stephen Lodwick (STELO)

        Added this new source file for factory to be able to repopulate product
        id and digital id if one is supplied in winbom.ini

\****************************************************************************/


//
// Include File(s):
//

#include "factoryp.h"
#include <licdll.h>
#include <licdll_i.c>


//
// Internal Define(s):
//


//
// External Function(s):
//

BOOL PidPopulate(LPSTATEDATA lpStateData)
{
    BOOL                bRet = TRUE;
    TCHAR               szBuffer[50] = NULLSTR;
    ICOMLicenseAgent*   pLicenseAgent;
    
    // Check to see if the ProductKey key exists in the winbom
    //
    if ( GetPrivateProfileString( INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_PRODKEY, NULLSTR, szBuffer, AS(szBuffer), lpStateData->lpszWinBOMPath) &&
         szBuffer[0] )
    {
        FacLogFileStr(3, _T("Attempting to reset Product Key: %s\n"), szBuffer);

        if ( (SUCCEEDED(CoInitialize(NULL))) &&
             (SUCCEEDED(CoCreateInstance(&CLSID_COMLicenseAgent, NULL, CLSCTX_INPROC_SERVER, &IID_ICOMLicenseAgent, (LPVOID *) &pLicenseAgent)))
           ) 
        {
            if ( SUCCEEDED(pLicenseAgent->lpVtbl->SetProductKey(pLicenseAgent, szBuffer)) )
            {
                FacLogFileStr(3, _T("Successfully reset Product Key: %s\n"), szBuffer);
            }
            else
            {
                FacLogFileStr(3, _T("Failed to reset Product Key: %s\n"), szBuffer);
                bRet = FALSE;
            }

            pLicenseAgent->lpVtbl->Release(pLicenseAgent);            

        }
        else
        {
            FacLogFileStr(3, _T("Failed to reset Product Key: %s\n"), szBuffer);
            bRet = FALSE;
        }

        CoUninitialize();
    } 
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\pnpdrivers.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    pnpdrivers.c

Abstract:

    Process Update PnP Drivers section of WINBOM.INI
    
    Task performed will be:
    

Author:

    Donald McNamara (donaldm) 5/11/2000

Revision History:

--*/
#include "factoryp.h"
#include <newdev.h>     // UpdateDriverForPlugAndPlayDevices constants


#define PNP_CREATE_PIPE_EVENT   _T("PNP_Create_Pipe_Event")
#define PNP_NO_INSTALL_EVENTS   _T("PnP_No_Pending_Install_Events")
#define PNP_EVENT_TIMEOUT       120000  // 2 minutes
#define PNP_INSTALL_TIMEOUT     450000  // 7 1/2 minutes

#define DIR_DEFAULT_ROOT        _T("%SystemRoot%\\drivers")
#define STR_FLOPPY              _T("FLOPPY:\\")
#define LEN_STR_FLOPPY          ( AS(STR_FLOPPY) - 1 )
#define STR_CDROM               _T("CDROM:\\")
#define LEN_STR_CDROM           ( AS(STR_CDROM) - 1 )

static HANDLE WaitForOpenEvent(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName, DWORD dwMilliseconds);


BOOL StartPnP()
{
    HANDLE  hEvent;
    BOOL    bRet = FALSE;

    // If we have already start PnP once, should not try to signal it again.
    //
    if ( GET_FLAG(g_dwFactoryFlags, FLAG_PNP_STARTED) )
        return TRUE;

    //
    // Signal the PNP_CREATE_PIPE_EVENT, with the UMPNPMGR is waiting on, so that
    // it can start processing installed devices.
    //

    // First we must wait till we can open the event, because if it doesn't already exist
    // then the PnP wont be listening to it when we signal it.
    //
    if ( hEvent = WaitForOpenEvent(EVENT_MODIFY_STATE, FALSE, PNP_CREATE_PIPE_EVENT, PNP_EVENT_TIMEOUT) )
    {
        // Signal the event now so that pnp starts up.
        //
        if ( !SetEvent(hEvent) )
        {
            // Unable to signal the event to tell pnp to start for some reason.
            //
            FacLogFile(0 | LOG_ERR, IDS_ERR_PNPSIGNALEVENT, GetLastError());
        }
        else
        {
            SET_FLAG(g_dwFactoryFlags, FLAG_PNP_STARTED);
            bRet = TRUE;
        }

        // We are done with this event.
        //
        CloseHandle(hEvent);
    }
    else
    {
        // Couldn't open up the event to tell pnp to get going.
        //
        FacLogFile(0 | LOG_ERR, IDS_ERR_PNPSTARTEVENT, GetLastError());
    }

    return bRet;
}

BOOL WaitForPnp(DWORD dwTimeOut)
{
    HANDLE  hEvent;
    BOOL    bRet = TRUE;

    // If we have already waited once, should have to wait again
    // (at least I think that is right).
    //
    if ( GET_FLAG(g_dwFactoryFlags, FLAG_PNP_DONE) )
        return TRUE;

    //
    // Wait for the PnP_No_Pending_Install_Events event, with the UMPNPMGR signals when it is done.
    //

    // Try to open the pnp finished install event.
    //
    if ( hEvent = WaitForOpenEvent(SYNCHRONIZE, FALSE, PNP_NO_INSTALL_EVENTS, PNP_EVENT_TIMEOUT) )
    {
        DWORD dwError;
        
        // Lets wait for the event to be signaled that pnp is all done.
        //
        dwError = WaitForSingleObject(hEvent, dwTimeOut);
        if ( WAIT_OBJECT_0 != dwError )
        {
            // Waiting on the event failed for some reason.
            //
            FacLogFile(0 | LOG_ERR, IDS_ERR_PNPWAITFINISH, ( WAIT_FAILED == dwError ) ? GetLastError() : dwError);
        }
        else
        {
            // Woo hoo, looks like everything worked.
            //
            SET_FLAG(g_dwFactoryFlags, FLAG_PNP_DONE);
            bRet = TRUE;
        }

        // Make sure we close the event handle.
        //
        CloseHandle(hEvent);
    }
    else
    {
        // Couldn't open up the event to wait on.
        //
        FacLogFile(0 | LOG_ERR, IDS_ERR_PNPFINISHEVENT, GetLastError());
    }

    return bRet;
}

/*++
===============================================================================
Routine Description:

    BOOL UpdateDrivers
    
    This routine will walk through the list of updated drivers presented in
    the WINBOM, and then copy all of the driver files for each one

Arguments:

    lpStateData->lpszWinBOMPath
                    -   Path to the WinBOM file.
    
Return Value:

    TRUE if all drivers files where copied
    FALSE if there was an error

===============================================================================
--*/

BOOL UpdateDrivers(LPSTATEDATA lpStateData)
{
    BOOL            bRet            = TRUE;
    LPTSTR          lpszWinBOMPath  = lpStateData->lpszWinBOMPath,
                    lpszDevicePath,
                    lpszRootPath,
                    lpszDefRoot,
                    lpszDst,
                    lpszSrc,
                    lpszBuffer,
                    lpszKey,
                    lpszDontCare;
    TCHAR           szDstPath[MAX_PATH],
                    szSrcPath[MAX_PATH],
                    szPathBuffer[MAX_PATH],
                    szNetShare[MAX_PATH],
                    cDriveLetter;
    DWORD           dwKeyLen,
                    cbDevicePath,
                    dwDevicePathLen,
                    dwOldSize;
    NET_API_STATUS  nErr;

    // Get a buffer for the device paths.  It will be either empty if they
    // don't have the optional additional paths key in the winbom.
    //
    if ( NULL == (lpszDevicePath = IniGetStringEx(lpszWinBOMPath, INI_SEC_WBOM_DRIVERUPDATE, INI_VAL_WBOM_DEVICEPATH, NULL, &cbDevicePath)) )
    {
        // We must have a buffer for the device path we will update in the registry.
        //
        cbDevicePath = 256;
        dwDevicePathLen = 0;
        if ( NULL == (lpszDevicePath = (LPTSTR) MALLOC(cbDevicePath * sizeof(TCHAR))) )
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_MEMORY, GetLastError());
            return FALSE;
        }
    }
    else
    {
        dwDevicePathLen = lstrlen(lpszDevicePath);
    }

    // Now get the optional root path for the drivers to be copied down.
    //
    lpszRootPath = IniGetString(lpszWinBOMPath, INI_SEC_WBOM_DRIVERUPDATE, INI_VAL_WBOM_PNP_DIR, NULL);

    // We have to have something for the root path even if the key isn't there.
    //
    lpszDefRoot = lpszRootPath ? lpszRootPath : DIR_DEFAULT_ROOT;

    // Try to get the whole driver section in the winbom.
    //
    lpszBuffer = IniGetSection(lpszWinBOMPath, INI_SEC_WBOM_DRIVERS);
    if ( lpszBuffer )
    {
        // Process all lines in this section. The format of the section is:
        //
        // source=destination
        //
        // The source can be any valid source path. If this path is a
        // UNC path, then we will connect to it.  It can also start with
        // FLOPPY:\ or CDROM:\, with will be replace with the right drive
        // letter.
        //
        // The destination is the directory relative to target root that
        // we will use to copy the updated drivers into.  It will be added,
        // along with any subdirs, to the device path in the registry.
        //
        for ( lpszKey = lpszBuffer; *lpszKey; lpszKey += dwKeyLen )
        {
            // Save the length of this string so we know where
            // the next key starts.
            //
            dwKeyLen = lstrlen(lpszKey) + 1;

            // Look for the value of the key after the = sign.
            //
            if ( lpszDst = StrChr(lpszKey, _T('=')) )
            {
                // Terminate the source where the = is, and then
                // make sure there is something after it for the
                // destination.
                //
                *lpszDst++ = NULLCHR;
                if ( NULLCHR == *lpszDst )
                {
                    lpszDst = NULL;
                }
            }

            // We have to have a value to copy the driver.
            //
            if ( lpszDst )
            {
                //
                // At this level in the code (until a little bit later), set the destination
                // pointer to NULL to indicate an error.  That will make it so we don't add
                // the path to the device path in the registry.  It will also return a failure
                // for this state, but we will keep on going with the next key.
                //

                // Set the source root as the key name.
                //
                lpszSrc = lpszKey;

                // Create the expanded full path for the destination.
                //
                lstrcpyn(szDstPath, lpszDefRoot, AS(szDstPath));
                AddPathN(szDstPath, lpszDst, AS(szDstPath));
                ExpandFullPath(NULL, szDstPath, AS(szDstPath));

                // Make sure we have a destination to copy to before we continue.
                //
                if ( NULLCHR == szDstPath[0] )
                {
                    // Log an error and set the destination pointer to NULL.
                    //
                    FacLogFile(0 | LOG_ERR, IDS_ERR_DSTBAD, lpszDst, GetLastError());
                    lpszDst = NULL;
                }
                else
                {
                    //
                    // At this level in the code (disregard the above comment), set the
                    // source pointer to NULL to indicate an error.  That will make it so
                    // we don't add the destination path to the device path in the registry
                    // or try and copy any files to it.  It will also return a failure for
                    // this state, but we will keep on going with the next key.
                    //

                    // Determine if this is a UNC path.  If it is not, then it is
                    // assumed to be a local path.
                    //
                    szNetShare[0] = NULLCHR;
                    if ( GetUncShare(lpszSrc, szNetShare, AS(szNetShare)) && szNetShare[0] )
                    {
                        // Connect to the UNC , using the supplied credentials.
                        // 
                        if ( NERR_Success != (nErr = FactoryNetworkConnect(szNetShare, lpszWinBOMPath, INI_SEC_WBOM_DRIVERUPDATE, TRUE)) )
                        {
                            // Log an error and set the source pointer to NULL.
                            //
                            FacLogFile(0 | LOG_ERR, IDS_ERR_NETCONNECT, szNetShare, nErr);
                            szNetShare[0] = NULLCHR;
                            lpszSrc = NULL;
                        }
                    }
                    else if ( ( lstrlen(lpszSrc) >= LEN_STR_FLOPPY ) &&
                              ( CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpszSrc, LEN_STR_FLOPPY, STR_FLOPPY, LEN_STR_FLOPPY) == CSTR_EQUAL ) )
                    {
                        // Make sure there is a floppy drive in the system.
                        //
                        if ( NULLCHR == (cDriveLetter = GetDriveLetter(DRIVE_REMOVABLE)) )
                        {
                            // Log an error and set the source pointer to NULL.
                            //
                            FacLogFile(0 | LOG_ERR, IDS_ERR_FLOPPYNOTFOUND, lpszSrc);
                            lpszSrc = NULL;
                        }
                        else
                        {
                            // Advance the source pointer to the character before the :\ and then
                            // set that character to the driver letter returned for the floppy.
                            //
                            lpszSrc += LEN_STR_FLOPPY - 3;
                            *lpszSrc = cDriveLetter;
                        }
                    }
                    else if ( ( lstrlen(lpszSrc) >= LEN_STR_CDROM ) &&
                              ( CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpszSrc, LEN_STR_CDROM, STR_CDROM, LEN_STR_CDROM) == CSTR_EQUAL ) )
                    {
                        // Make sure there is a CD-ROM drive in the system.
                        //
                        if ( NULLCHR == (cDriveLetter = GetDriveLetter(DRIVE_CDROM)) )
                        {
                            // Log an error and set the source pointer to NULL.
                            //
                            FacLogFile(0 | LOG_ERR, IDS_ERR_CDROMNOTFOUND, lpszSrc);
                            lpszSrc = NULL;
                        }
                        else
                        {
                            // Advance the source pointer to the character before the :\ and then
                            // set that character to the driver letter returned for the CD-ROM.
                            //
                            lpszSrc += LEN_STR_CDROM - 3;
                            *lpszSrc = cDriveLetter;
                        }
                    }

                    // If there is a source, expand it out.
                    //
                    if ( lpszSrc )
                    {
                        // Create the expanded full path for the source.
                        //
                        ExpandFullPath(lpszSrc, szSrcPath, AS(szSrcPath));

                        // Make sure we have a source to copy to before we continue.
                        //
                        if ( NULLCHR == szSrcPath[0] )
                        {
                            // Log an error and set the source pointer to NULL.
                            //
                            FacLogFile(0 | LOG_ERR, IDS_ERR_SRCBAD, lpszSrc, GetLastError());
                            lpszSrc = NULL;
                        }
                        else if ( !DirectoryExists(szSrcPath) || !CopyDirectory(szSrcPath, szDstPath) )
                        {
                            // Log an error and set the source pointer to NULL.
                            //
                            FacLogFile(0 | LOG_ERR, IDS_ERR_DRVCOPYFAILED, szSrcPath, szDstPath);
                            lpszSrc = NULL;
                        }
                    }

                    // Source will only be valid if we actually copied some drivers.
                    //
                    if ( NULL == lpszSrc )
                    {
                        // Set this so we don't add this path to the registry.
                        //
                        lpszDst = NULL;
                    }

                    // Clean up and drive mappings we may have done to a remote Server/Share.
                    //
                    if ( ( szNetShare[0] ) &&
                         ( NERR_Success != (nErr = FactoryNetworkConnect(szNetShare, lpszWinBOMPath, NULL, FALSE)) ) )
                    {
                        // Log a warning.
                        //
                        FacLogFile(2, IDS_WRN_NETDISCONNECT, szNetShare, nErr);
                    }
                }

                // Now if the destination pointer is NULL, we know we need to
                // return an error for this state.
                //
                if ( NULL == lpszDst )
                {
                    bRet = FALSE;
                }
            }
            else
            {
                // If there was no =, then just use the key part
                // as the dest and add it to the device path.
                //
                lpszDst = lpszKey;
            }

            // Now if we have something to add to our device path,
            // add it now.
            //
            if ( lpszDst )
            {
                // Make sure our buffer is still big enough.
                // The two extra are for the possible semi-colon
                // we might add and one more to be safe.  We
                // don't have to worry about the null terminator
                // because we do less than or equal to our current
                // buffer size.
                //
                dwOldSize = cbDevicePath;
                dwDevicePathLen += lstrlen(lpszDst);
                while ( cbDevicePath <= (dwDevicePathLen + 2) )
                {
                    cbDevicePath *= 2;
                }

                // Make sure we still have a buffer.
                //
                if ( cbDevicePath > dwOldSize ) 
                {
                    LPTSTR lpszTmpDevicePath = (LPTSTR) REALLOC(lpszDevicePath, cbDevicePath * sizeof(TCHAR));

                    if ( NULL == lpszTmpDevicePath )
                    {
                        // If this realloc fails, we just need to bail.
                        //
                        FREE(lpszDevicePath);
                        FREE(lpszRootPath);
                        FREE(lpszBuffer);
                        FacLogFile(0 | LOG_ERR, IDS_ERR_MEMORY, GetLastError());
                        return FALSE;
                    }
                    else
                    {
                        lpszDevicePath = lpszTmpDevicePath;
                    }
                }

                // If we already have added a path, tack on a semicolon.
                //
                if ( *lpszDevicePath )
                {
                    if ( FAILED ( StringCchCat ( lpszDevicePath, cbDevicePath, _T(";") ) ) )
                    {
                        FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), lpszDevicePath, _T(";") );
                    }
    
                    dwDevicePathLen++;
                }

                // Now add our path.
                //
                if ( FAILED ( StringCchCat ( lpszDevicePath, cbDevicePath, lpszDst) ) )
                {
                    FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), lpszDevicePath, lpszDst ) ;
                }

            }
        }

        FREE(lpszBuffer);
    }

    // If we are saving this list to the registry, then
    // we need to add to our buffer.
    //
    if ( *lpszDevicePath &&
         !UpdateDevicePath(lpszDevicePath, lpszDefRoot, TRUE) )
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_UPDATEDEVICEPATH, lpszDevicePath);
        bRet = FALSE;
    }

    // Clean up any memory (macro checks for NULL).
    //
    FREE(lpszRootPath);
    FREE(lpszDevicePath);

    return bRet;
}

BOOL DisplayUpdateDrivers(LPSTATEDATA lpStateData)
{
    return ( IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_DRIVERS, NULL, NULL) ||
             IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_DRIVERUPDATE, INI_VAL_WBOM_DEVICEPATH, NULL) );
}

BOOL InstallDrivers(LPSTATEDATA lpStateData)
{
    // Should always let normal pnp finish before we start
    // enumerating all the devices checking for updated drivers.
    //
    WaitForPnp(PNP_INSTALL_TIMEOUT);

    // Make sure we want to do this.
    //
    if ( !DisplayInstallDrivers(lpStateData) )
    {
        return TRUE;
    }

    return UpdatePnpDeviceDrivers();
}

BOOL DisplayInstallDrivers(LPSTATEDATA lpStateData)
{
    return ( ( IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_DRIVERUPDATE, INI_KEY_WBOM_INSTALLDRIVERS, INI_VAL_WBOM_YES) ) ||
             ( !GET_FLAG(g_dwFactoryFlags, FLAG_OOBE) &&
               IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_DRIVERS, NULL, NULL) ) );
}

BOOL NormalPnP(LPSTATEDATA lpStateData)
{
    return StartPnP();
}

BOOL WaitPnP(LPSTATEDATA lpStateData)
{
    // If this is the extra wait state, we only
    // do it if there is a certain key in the winbom.
    //
    if ( DisplayWaitPnP(lpStateData) )
    {
        return WaitForPnp(PNP_INSTALL_TIMEOUT);
    }

    return TRUE;
}

BOOL DisplayWaitPnP(LPSTATEDATA lpStateData)
{
    BOOL bRet = IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_DRIVERUPDATE, INI_KEY_WBOM_PNPWAIT, INI_VAL_WBOM_YES);

    if ( stateWaitPnP == lpStateData->state )
    {
        bRet = !bRet;
    }

    return bRet;
}

BOOL SetDisplay(LPSTATEDATA lpStateData)
{
    // If this is the second set display, only bother if we
    // re-enumerated the installed drivers.
    //
    if ( ( stateSetDisplay2 == lpStateData->state ) &&
         ( !DisplayInstallDrivers(lpStateData) ) )
    {
        return TRUE;
    }

    // Call the syssetup function to reset the display.
    //
    return SetupSetDisplay(lpStateData->lpszWinBOMPath,
                           WBOM_SETTINGS_SECTION,
                           WBOM_SETTINGS_DISPLAY,
                           WBOM_SETTINGS_REFRESH,
                           WBOM_SETTINGS_DISPLAY_MINWIDTH,
                           WBOM_SETTINGS_DISPLAY_MINHEIGHT,
                           WBOM_SETTINGS_DISPLAY_MINDEPTH);
}


static HANDLE WaitForOpenEvent(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName, DWORD dwMilliseconds)
{
    HANDLE  hEvent;
    DWORD   dwTime  = 0,
            dwSleep = 100;
    BOOL    bBail   = (0 == dwMilliseconds);

    // Keep looping until we get an event handle or we time out.
    //
    while ( ( NULL == (hEvent = OpenEvent(dwDesiredAccess, bInheritHandle, lpName)) ) && !bBail )
    {
        // Only bother to test for the time out if they didn't
        // pass in infinite.
        //
        if ( INFINITE != dwMilliseconds )
        {
            // Add our sleep interval and make sure we will not
            // go over out limit.
            //
            dwTime += dwSleep;
            if ( dwTime >= dwMilliseconds )
            {
                // If we will go over, caclculate how much
                // time we have left to sleep (it must be less
                // than our normal interval) and set the flag
                // so we stop trying after the next try.
                //
                dwSleep = dwMilliseconds - (dwTime - dwSleep);
                bBail = TRUE;
            }
        }

        // Now sleep for our interval or less (should never
        // be zero, but doesn't really matter if it is).
        //
        Sleep(dwSleep);
    }

    // If we are failing and we timed out, we need to set
    // the last error (if we didn't time out the error will
    // already be set by OpenEvent).
    //
    if ( ( NULL == hEvent ) && bBail )
        SetLastError(WAIT_TIMEOUT);

    // Return the event handle.
    //
    return hEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\oemrun.c ===
// **************************************************************************
//
// OEMRun.C
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999-2001
//  All rights reserved
//
//  OEM Run wrapper. This application allows the OEM to Run appliations on every audit
//  boot.  It also allows them to specify applications that should only be run on the
//  first audit reboot.
//
//  9/20/1999   Stephen Lodwick
//                  Project started
//
//  6/22/2000   Stephen Lodwick (stelo)
//                  Ported to NT
//
//  1/07/2001   Stephen Lodwick (stelo)
//                  Merged with factory.exe
//
//  4/01/2001   Stephen Lodwick (stelo)
//                  Added StatusDialog Support
//
// *************************************************************************/
//
#include "factoryp.h"

#include "oemrun.h"
#include "res.h"


//
// Internal Defines
//
#define STR_REG_OEMRUNONCE      _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\OemRunOnce")  // Registry path for RunOnce apps
#define STR_REG_OEMRUN          _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\OemRun")      // Registry path for Run apps
#define STR_REG_CURRENTVER      _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")              // Registry path for CurrentVersion
#define STR_VAL_OEMRESETSILENT  _T("OemReset_Silent")                                           // Registry Value that is set if you don't want OemReset to display Exit dialog
#define STR_VAL_WINBOMRO        _T("OemRunOnce")

#define INF_SEC_OEMRUNONCE      _T("OemRunOnce")
#define INF_SEC_OEMRUN          _T("OemRun")

#define RUN_APPS_ASYNC          0   // This flag is used to run the applications asynchronasly
#define RUN_APPS_SYNC           1   // This flag is used to run the applications sychronasly

#define CHR_UNDERSCORE          _T('_')
#define CHR_QUOTE               _T('\"')
#define NULLCHR                 _T('\0')

#define STR_REBOOT              _T("REBOOT")
#define STR_INSTALLTECH_MSI     _T("MSI")
#define STR_MSI_ATTACH          _T(" FASTOEM=1 ALLUSERS=1 DISABLEROLLBACK=1 ")
#define STR_MSI_STAGE           _T(" ACTION=ADMIN TARGETDIR=\"%s\" ")
//
// Internal Functions
//
static  LPRUNNODE   BuildAppList(LPTSTR, BOOL);
static  HWND        DisplayAppList(HWND, LPRUNNODE);
static  void        RunAppList(HWND, LPRUNNODE, DWORD);
static  void        RunAppThread(LPTHREADPARAM);
static  void        DeleteAppList(LPRUNNODE);
static  void        OemReboot();
static  VOID        SetRunOnceState(DWORD);
static  DWORD       GetRunOnceState(VOID);

//
// Global Defines
//
INSTALLTYPES g_InstallTypes[] =
{
    { installtypeStage,     INI_VAL_WBOM_STAGE    },
    { installtypeDetach,    INI_VAL_WBOM_DETACH   },
    { installtypeAttach,    INI_VAL_WBOM_ATTACH   },
    { installtypeStandard,  INI_VAL_WBOM_STANDARD },
};

INSTALLTECHS g_InstallTechs[] =
{
    { installtechMSI,       INI_VAL_WBOM_MSI },
    { installtechApp,       INI_VAL_WBOM_APP },
    { installtechINF,       INI_VAL_WBOM_INF },
};

//
// Main external function
//
BOOL ProcessSection(BOOL bOemRunOnce)
{
    LPRUNNODE   lprnAppList     = NULL;

    // Build the Application list for the OemRun key
    //
    lprnAppList = BuildAppList(bOemRunOnce ? STR_REG_OEMRUNONCE : STR_REG_OEMRUN, bOemRunOnce);

    // If there are applications in the list, launch the RunOnce dialog or run the applist if in OemRun mode
    //
    if(lprnAppList)
    {
        if ( bOemRunOnce )
        {
            HWND hStatusDialog   = NULL;

            // Display the application list
            //
            if ( hStatusDialog = DisplayAppList(NULL, lprnAppList) )
            {
                RunAppList(hStatusDialog, lprnAppList, RUN_APPS_SYNC);

                StatusEndDialog(hStatusDialog);
            }
        }
        else
        {
            // Launch the Application list asynchronously without the oemrunce UI
            //
            RunAppList(NULL, lprnAppList, RUN_APPS_ASYNC);
        }
    }

    // Need a better way to determine if this fails or not.
    //
    return TRUE;
}

static void RunAppThread(LPTHREADPARAM lpThreadParam)
{
    RunAppList(lpThreadParam->hWnd, lpThreadParam->lprnList, RUN_APPS_SYNC);
    FREE(lpThreadParam);
}

static LPRUNNODE BuildAppList(LPTSTR lpListKey, BOOL bRunOnceKey)
{
    HKEY                    hkPath,
                            hkSubKey;
    TCHAR                   szField[MAX_PATH]   = NULLSTR,
                            szName[MAX_PATH]    = NULLSTR,
                            szValue[MAX_PATH]   = NULLSTR,
                            szSecType[MAX_PATH] = NULLSTR,
                            szKeyPath[MAX_PATH] = NULLSTR,
                            szBuffer[MAX_PATH]  = NULLSTR;
    DWORD                   dwRegIndex          = 0,
                            dwRegKeyIndex       = 0,
                            dwNameSize          = sizeof(szName)/sizeof(TCHAR), // size of name in TCHARS
                            dwValueSize         = sizeof(szValue),              // size of value in bytes
                            dwItemNumber        = 1,
                            dwTempIndex         = 0,
                            dwCurrentState      = bRunOnceKey ? GetRunOnceState() : 0;
    LPRUNNODE               lprnHead            = NULL,
                            lprnNode            = NULL;
    LPLPRUNNODE             lplprnNext          = &lprnHead;
    HINF                    hInf                = NULL;
    INFCONTEXT              InfContext;
    BOOL                    bRet,
                            bWinbom,
                            bCleanupNode        = FALSE,
                            bAllocFailed        = FALSE,
                            bReboot;
    LPTSTR                  lpReboot            = NULL;

    // This section will build the Application list from the winbom.ini
    //
    if ((hInf = SetupOpenInfFile(g_szWinBOMPath, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL)) != INVALID_HANDLE_VALUE)
    {
        // Determine if we're looking at the Run or RunOnce section and find the first line in the section
        //
        for ( bRet = SetupFindFirstLine(hInf, bRunOnceKey ? INF_SEC_OEMRUNONCE : INF_SEC_OEMRUN, NULL, &InfContext);
              bRet;
              bRet = SetupFindNextLine(&InfContext, &InfContext), dwItemNumber++ )
              {
                // Get the AppName.
                //
                szName[0] = NULLCHR;
                szField[0] = NULLCHR;
                SetupGetStringField(&InfContext, 1, szField, STRSIZE(szField), NULL);
                ExpandEnvironmentStrings(szField, szName, sizeof(szName)/sizeof(TCHAR));

                // Get the AppPath or Section name
                //
                szValue[0] = NULLCHR;
                szField[0] = NULLCHR;
                SetupGetStringField(&InfContext, 2, szField, STRSIZE(szField), NULL);
                ExpandEnvironmentStrings(szField, szValue, sizeof(szValue)/sizeof(TCHAR));

                // Get field to determine what type of section we are getting, if any
                //
                szSecType[0] = NULLCHR;
                SetupGetStringField(&InfContext, 3, szSecType, STRSIZE(szSecType), NULL);


                // Special Case the reboot key
                //
                bReboot = FALSE;
                szBuffer[0] = NULLCHR;
                SetupGetLineText(&InfContext, NULL, NULL, NULL, szBuffer, STRSIZE(szBuffer), NULL);
                StrTrm(szBuffer, CHR_QUOTE);
                
                if ( !LSTRCMPI(szBuffer, STR_REBOOT) )
                {
                    // Reset the values so it looks nice in the dialog
                    //
                    lpReboot = AllocateString(NULL, IDS_REBOOT_FRIENDLY);

                    // Set the default values
                    //
                    lstrcpyn(szName, lpReboot, AS ( szName ) );
                    szValue[0] = NULLCHR;
                    szSecType[0] = NULLCHR;
                    bReboot = TRUE;

                    // Clean up the allocated memory
                    //
                    FREE(lpReboot);
                }

                // Make sure we have a valid app before adding it to the list
                //
                if ( szName[0]  && ( szValue[0] || bReboot ) && (dwItemNumber > dwCurrentState))
                {
                    if( (lprnNode) = (LPRUNNODE)MALLOC(sizeof(RUNNODE)))
                    {
                        // Allocate the memory for the data elements in the new node
                        //
                        int nDisplayNameLen = ( lstrlen(szName) + 1    ) * sizeof( TCHAR ) ;
                        int nRunValueLen    = ( lstrlen(szValue) + 1   ) * sizeof( TCHAR ) ;
                        int nKeyPathLen     = ( lstrlen(szKeyPath) + 1 ) * sizeof( TCHAR ) ;

                        if ( ( lprnNode->lpDisplayName = MALLOC( nDisplayNameLen ) )  &&
                             ( lprnNode->lpValueName   = MALLOC( nDisplayNameLen ) )  &&
                             ( lprnNode->lpRunValue    = MALLOC( nRunValueLen    ) )  &&
                             ( lprnNode->lpSubKey      = MALLOC( nKeyPathLen     ) ) )
                        {

                            // Copy in the standard exe information into RUNNODE structure
                            //
                            lstrcpyn((LPTSTR)(lprnNode)->lpDisplayName,szName, nDisplayNameLen);
                            lstrcpyn((LPTSTR)(lprnNode)->lpValueName,szName, nDisplayNameLen);
                            lstrcpyn((LPTSTR)(lprnNode)->lpRunValue,szValue, nRunValueLen );
                            lstrcpyn((LPTSTR)(lprnNode)->lpSubKey, szKeyPath, nKeyPathLen);
                            (lprnNode)->bWinbom      = TRUE;
                            (lprnNode)->bRunOnce     = bRunOnceKey;
                            (lprnNode)->dwItemNumber = dwItemNumber;
                            (lprnNode)->lpNext       = NULL;
                            (lprnNode)->bReboot      = bReboot;
                            (lprnNode)->InstallTech  = installtechUndefined;
                            (lprnNode)->InstallType  = installtypeUndefined;

                            // If this is a section, copy in additional structure information
                            //
                            if ( szSecType[0] )
                            {
                                // Log that we have found an application preinstall section
                                //
                                FacLogFile(1, IDS_PROC_APPSECTION, szValue, szName);

                                // Loop through all of the install techs and determine the one that we are installing
                                //
                                for (dwTempIndex = 0; dwTempIndex < AS(g_InstallTechs); dwTempIndex++)
                                {
                                    if ( !lstrcmpi(szSecType, g_InstallTechs[dwTempIndex].lpszDescription) )
                                        (lprnNode)->InstallTech = g_InstallTechs[dwTempIndex].InstallTech;
                                }

                                // Determine the InstallType
                                //
                                szBuffer[0] = NULLCHR;
                                GetPrivateProfileString(szValue, INI_KEY_WBOM_INSTALLTYPE, szBuffer, szBuffer, STRSIZE(szBuffer), g_szWinBOMPath);

                                // If no InstallType is used, assume standard
                                //
                                if ( szBuffer[0] == NULLCHR )
                                    (lprnNode)->InstallType = installtypeStandard;

                                // Loop through all of the install types and determine the one that we are installing
                                //
                                for (dwTempIndex = 0; dwTempIndex < AS(g_InstallTypes); dwTempIndex++)
                                {
                                    if ( !lstrcmpi(szBuffer, g_InstallTypes[dwTempIndex].lpszDescription) )
                                        (lprnNode)->InstallType = g_InstallTypes[dwTempIndex].InstallType;
                                }

                                //
                                // READ IN ALL OTHER SECTION KEYS
                                //

                                // SourcePath
                                //
                                szField[0] = NULLCHR;
                                GetPrivateProfileString(szValue, INI_KEY_WBOM_SOURCEPATH, szField, szField, STRSIZE(szField), g_szWinBOMPath);    
                                ExpandEnvironmentStrings(szField, (lprnNode)->szSourcePath, STRSIZE((lprnNode)->szSourcePath));
                                
                                // TargetPath
                                //
                                szField[0] = NULLCHR;
                                GetPrivateProfileString(szValue, INI_KEY_WBOM_TARGETPATH, szField, szField, STRSIZE(szField), g_szWinBOMPath);    
                                ExpandEnvironmentStrings(szField, (lprnNode)->szTargetPath, STRSIZE((lprnNode)->szTargetPath));

                                // SetupFile
                                //
                                (lprnNode)->szSetupFile[0] = NULLCHR;
                                GetPrivateProfileString(szValue, INI_KEY_WBOM_SETUPFILE, (lprnNode)->szSetupFile, (lprnNode)->szSetupFile, STRSIZE((lprnNode)->szSetupFile), g_szWinBOMPath);

                                // Command Line
                                //
                                (lprnNode)->szCmdLine[0] = NULLCHR;
                                GetPrivateProfileString(szValue, INI_KEY_WBOM_CMDLINE, (lprnNode)->szCmdLine, (lprnNode)->szCmdLine, STRSIZE((lprnNode)->szCmdLine), g_szWinBOMPath);

                                // Section Name for INF file
                                //
                                (lprnNode)->szSectionName[0] = NULLCHR;
                                GetPrivateProfileString(szValue, INI_KEY_WBOM_SECTIONNAME, (lprnNode)->szSectionName, (lprnNode)->szSectionName, STRSIZE((lprnNode)->szSectionName), g_szWinBOMPath);

                                // Reboot Command
                                //
                                szBuffer[0] = NULLCHR;
                                GetPrivateProfileString(szValue, INI_KEY_WBOM_REBOOT, szBuffer, szBuffer, STRSIZE(szBuffer), g_szWinBOMPath);

                                if (!LSTRCMPI(szBuffer, _T("YES")))
                                    (lprnNode)->bReboot = TRUE;

                                // RemoveTargetPath Key
                                //
                                szBuffer[0] = NULLCHR;
                                GetPrivateProfileString(szValue, INI_KEY_WBOM_REMOVETARGET, szBuffer, szBuffer, STRSIZE(szBuffer), g_szWinBOMPath);
                                
                                // Get the RemoveTargetPath
                                //
                                if (!LSTRCMPI(szBuffer, _T("NO")))
                                    (lprnNode)->bRemoveTarget = FALSE;
                                else
                                    (lprnNode)->bRemoveTarget = TRUE;
                                

                                // The install tech was invalid, error out
                                //
                                if ((lprnNode)->InstallTech == installtechUndefined )
                                {
                                    
                                    FacLogFile(0|LOG_ERR, IDS_ERR_UNDEFTECH, szName);
                                    
                                    bCleanupNode = TRUE;
                                }

                                // The install type was set to or still is undefine, error out
                                //
                                if ( (lprnNode)->InstallType == installtypeUndefined )
                                {
                                    // The Install type is unknown, let the user know with the log file
                                    //
                                    FacLogFile(0|LOG_ERR, IDS_ERR_UNDEFINSTALL, szName);
                                    
                                    bCleanupNode = TRUE;
                                }
                                
                                // If we have a valid Install Technology and Install Type, continue on
                                //
                                if ( !bCleanupNode )
                                {

                                    // First determine the install type
                                    //
                                    switch ( (lprnNode)->InstallType )
                                    {

                                        // If we are doing a Staged Install, do the following
                                        //
                                        case installtypeStage:
                                            {
                                                // Check to make sure that the SourcePath exists, as we need it in Staging
                                                //
                                                if ( (lprnNode)->szSourcePath[0] == NULLCHR )
                                                {
                                                    FacLogFile(0|LOG_ERR, IDS_ERR_NOSOURCE, szName);
                                                    bCleanupNode = TRUE;
                                                }

                                                // Removing the TargetPath is not an option for Staging
                                                //
                                                (lprnNode)->bRemoveTarget = FALSE;

                                                // Determine what install technology we are using
                                                //
                                                switch ( (lprnNode)->InstallTech ) 
                                                {
                                                    // We are performing an Staged/MSI install
                                                    //
                                                    case installtechMSI:

                                                        // Both SetupFile and Stagepath are required for MSI Stage
                                                        //
                                                        if ( (lprnNode)->szSetupFile[0] == NULLCHR || (lprnNode)->szTargetPath[0] == NULLCHR)
                                                        {
                                                            FacLogFile(0|LOG_ERR, IDS_ERR_NOSTAGESETUPFILE, szName);
                                                            bCleanupNode = TRUE;
                                                        }
                                                        break;

                                                    // We are performing a Staged/Generic install
                                                    //
                                                    case installtechApp:
                                                    case installtechINF:
                                                        // Check to make sure that if there is no StagePath we have a SetupFile
                                                        //
                                                        if ( (lprnNode)->szTargetPath[0] == NULLCHR && (lprnNode)->szSetupFile[0] == NULLCHR)
                                                        {
                                                            FacLogFile(0|LOG_ERR, IDS_ERR_NOSTAGEPATH, szName);
                                                            bCleanupNode = TRUE;

                                                        }

                                                        // If we are doing an INF install, NULL out the SetupFile
                                                        //
                                                        if ( (lprnNode)->InstallTech == installtechINF )
                                                            (lprnNode)->szSetupFile[0] = NULLCHR;

                                                        break;
                                                }
                                            }
                                            break;

                                        // If we are Attaching an application or doing a Standard Install, do the following
                                        //
                                        case installtypeAttach:
                                        case installtypeStandard:
                                            {

                                                // SourcePath is used for Standard install/RemoveStagePath is ignored
                                                //
                                                if ((lprnNode)->InstallType == installtypeStandard )
                                                {
                                                    
                                                    (lprnNode)->szTargetPath[0] = NULLCHR;

                                                    // Check to make sure we have SourcePath
                                                    //
                                                    if ( (lprnNode)->szSourcePath[0] == NULLCHR)
                                                    {
                                                        FacLogFile(0|LOG_ERR, IDS_ERR_NOSOURCE, szName);
                                                        bCleanupNode = TRUE;
                                                    }

                                                    // We are just going to use the SourcePath as the TargetPath
                                                    //
                                                    lstrcpyn((lprnNode)->szTargetPath, (lprnNode)->szSourcePath, AS ( (lprnNode)->szTargetPath ) );

                                                    // Can't remove the Target for standard install
                                                    //
                                                    (lprnNode)->bRemoveTarget = FALSE;
                                                }
                                                else
                                                {
                                                    // SourcePath is ignored for Attach
                                                    //
                                                    (lprnNode)->szSourcePath[0] = NULLCHR;

                                                    // Make sure we have TargetPath for Attach
                                                    //
                                                    if ( (lprnNode)->szTargetPath[0] == NULLCHR)
                                                    {
                                                        FacLogFile(0|LOG_ERR, IDS_ERR_NOTARGETPATH, szName);
                                                        bCleanupNode = TRUE;    
                                                    }
                                                }

                                                // If Attaching an application, the SetupFile is required
                                                //
                                                if ( (lprnNode)->szSetupFile[0] == NULLCHR )
                                                {
                                                    FacLogFile(0|LOG_ERR, IDS_ERR_NOSETUPFILE, szName);
                                                    bCleanupNode = TRUE;
                                                }

                                                // Determine what install technology we are using
                                                //
                                                switch ( (lprnNode)->InstallTech ) 
                                                {
                                                    // We are performing an Attach/MSI install
                                                    //
                                                    case installtechMSI:
                                                        break;

                                                    // We are performing an Attach/Generic install
                                                    //
                                                    case installtechApp:
                                                        break;

                                                    // We are performing an Attach/INF install
                                                    //
                                                    case installtechINF:
                                                        // We are required to have a SectionName in this case
                                                        //
                                                        if ( (lprnNode)->szSectionName[0] == NULLCHR)
                                                        {
                                                            FacLogFile(0|LOG_ERR, IDS_ERR_NOSECTIONNAME, szName);
                                                            bCleanupNode = TRUE;    
                                                        }
                                                        break;
                                                }
                                            }
                                            break;

                                        // If we are Detaching an application, do the following
                                        //
                                        case installtypeDetach:
                                            {
                                                // SourcePath is ignored if Detaching
                                                //
                                                (lprnNode)->szSourcePath[0] = NULLCHR;

                                                // Removing the TargetPath is not an option for Detaching (it's already implied)
                                                //
                                                (lprnNode)->bRemoveTarget = FALSE;

                                                // StagePath is required for Detach
                                                //
                                                if ( (lprnNode)->szTargetPath[0] == NULLCHR )
                                                {
                                                    FacLogFile(0|LOG_ERR, IDS_ERR_NOTARGETPATH, szName);
                                                    bCleanupNode = TRUE;
                                                }

                                                // Determine what install technology we are using
                                                //
                                                switch ( (lprnNode)->InstallTech ) 
                                                {
                                                    // We are performing an Detach/MSI install
                                                    //
                                                    case installtechMSI:
                                                        break;

                                                    // We are performing a Detach/Generic install
                                                    //
                                                    case installtechApp:
                                                        break;

                                                    // We are performing a Detach/INF install
                                                    //
                                                    case installtechINF:
                                                        break;
                                                }
                                            }
                                            break;

                                           
                                            
                                    }

                                    
                                    // If we are Installing an application and a Command Line exists while the SetupFile does not, let the user know
                                    //
                                    if ( (lprnNode)->szCmdLine[0] && (lprnNode)->szSetupFile[0] == NULLCHR )
                                    {
                                            // Set the Command Line back to the default
                                            //
                                            (lprnNode)->szCmdLine[0] = NULLCHR;

                                            // This is non-fatal, we will log the error and contine
                                            //
                                            FacLogFile(0|LOG_ERR, IDS_ERR_IGNORECMDLINE, szName);
                                    }
                                }
                            }


                            // If there was no error, move to the next node in the list
                            //
                            if ( !bCleanupNode )
                            {
                                // Debug information
                                //
                                DBGLOG(3, _T("Successfully Added '%s' to Application List.\n"), (lprnNode)->lpDisplayName);
                            }

                            // Make sure the new node points to the next node
                            //
                            lprnNode->lpNext = (*lplprnNext);

                            // Make sure the previous node points to the new node
                            //
                            *lplprnNext = lprnNode;

                            // Move to the next node in the list
                            //
                            lplprnNext=&((*lplprnNext)->lpNext);
                        }
                        else 
                        {
                            // Memory allocation failed, clean up
                            //
                            bAllocFailed = TRUE;
                        }
                        
                        // There was an error, clean up the runnode
                        //
                        if ( bAllocFailed || bCleanupNode) 
                        {
                            // Free the memory because we failed the allocation or we have an invalid install type
                            //
                            if ( bAllocFailed ) 
                            {
                                // Debug information
                                //
                                DBGLOG(3, _T("Failed to Add '%s' to Application List.\n"), (lprnNode)->lpDisplayName);

                                FREE(lprnNode->lpDisplayName);
                                FREE(lprnNode->lpValueName);
                                FREE(lprnNode->lpRunValue);
                                FREE(lprnNode->lpSubKey);
                                FREE(lprnNode);
                            }
                            else if ( bCleanupNode )
                            {
                                // Debug information
                                //
                                DBGLOG(3, _T("Invalid entry '%s' will not be processed.\n"), (lprnNode)->lpDisplayName);

                                // We will display the invalid entry with a failure in runapplist
                                //
                                lprnNode->bEntryError = TRUE;
                            }

                            // Clear the error flags
                            //
                            bCleanupNode = FALSE;
                            bAllocFailed = FALSE;
                        }

                    }
                }
              }

        SetupCloseInfFile(hInf);
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpListKey, 0, KEY_ALL_ACCESS, &hkPath) == ERROR_SUCCESS)
    {

        // Enumerate each of the sub keys using a do..while
        //
        do
        {
            dwRegIndex = 0;
            // Open each of the sub keys
            //
            if (RegOpenKeyEx(hkPath, szKeyPath, 0, KEY_ALL_ACCESS, &hkSubKey) == ERROR_SUCCESS)
            {
                // Enumerate each value of the registry
                //
                while (RegEnumValue(hkSubKey, dwRegIndex, szName, &dwNameSize, NULL, NULL, (LPBYTE)szValue, &dwValueSize ) == ERROR_SUCCESS)
                {
                    // Allocate the memory for the next node
                    //
                    if( (lprnNode) = (LPRUNNODE)MALLOC(sizeof(RUNNODE)))
                    {
                        int nDisplayNameLen = (lstrlen(szName) + 1) * sizeof(TCHAR );
                        int nRunValueLen    = (lstrlen(szValue) + 1) * sizeof(TCHAR );
                        int nKeyPathLen     = (lstrlen(szKeyPath) + 1) * sizeof(TCHAR);

                        // Allocate the memory for the data elements in the new node
                        //
                        if ( ( lprnNode->lpDisplayName = MALLOC( nDisplayNameLen ) ) &&
                             ( lprnNode->lpValueName   = MALLOC( nDisplayNameLen ) ) &&
                             ( lprnNode->lpRunValue    = MALLOC( nRunValueLen ) )    &&
                             ( lprnNode->lpSubKey      = MALLOC(nKeyPathLen ) ) )
                        {
                            // Copy the key name and value into the node buffers
                            //
                            lstrcpyn((LPTSTR)(lprnNode)->lpDisplayName, szName, nDisplayNameLen);
                            lstrcpyn((LPTSTR)(lprnNode)->lpValueName,szName, nDisplayNameLen);
                            lstrcpyn((LPTSTR)(lprnNode)->lpRunValue,szValue, nRunValueLen);
                            lstrcpyn((LPTSTR)(lprnNode)->lpSubKey, szKeyPath, nKeyPathLen);
                            (lprnNode)->bWinbom  = FALSE;
                            (lprnNode)->bRunOnce = bRunOnceKey;
                            (lprnNode)->lpNext   = NULL;


                            // Run through the linked list to determine where to add the new node
                            for(lplprnNext=&lprnHead;;(lplprnNext=&((*lplprnNext)->lpNext)))
                            {
                                // If we are at the head node or the CompareString functions return true,
                                // then that's where we want to place the new node
                                //
                                if ( (*lplprnNext==NULL) ||
                                     ((CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,(*lplprnNext)->lpSubKey, -1, lprnNode->lpSubKey, -1) == CSTR_GREATER_THAN) && ((*lplprnNext)->bWinbom != TRUE)) ||
                                     ((CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, (*lplprnNext)->lpDisplayName, -1, lprnNode->lpDisplayName, -1) == CSTR_GREATER_THAN ) &&
                                     (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lprnNode->lpSubKey, -1, (*lplprnNext)->lpSubKey, -1) != CSTR_GREATER_THAN) &&
                                     ((*lplprnNext)->bWinbom != TRUE) )
                                   )
                                {
                                    // Make sure the new node points to the next node
                                    //
                                    lprnNode->lpNext = (*lplprnNext);

                                    // Make sure the previous node points to the new node
                                    //
                                    *lplprnNext = lprnNode;

                                    // Break, because we've inserted the node
                                    //
                                    break;
                                }
                            }
                        }
                        else
                        {
                            // Free the memory because we failed the allocation
                            //
                            FREE(lprnNode->lpDisplayName);
                            FREE(lprnNode->lpValueName);
                            FREE(lprnNode->lpRunValue);
                            FREE(lprnNode->lpSubKey);
                            FREE(lplprnNext);
                        }
                    }


                    // Reset the size of the Name and value variables
                    //
                    dwNameSize = sizeof(szName)/sizeof(TCHAR);
                    dwValueSize = sizeof(szValue);

                    dwRegIndex++;
                }

                // Close the Subkey
                //
                RegCloseKey(hkSubKey);

            } // End the RegOpenKeyEx - Subkey

            if (*szKeyPath)
                dwRegKeyIndex++;

        } while( RegEnumKey(hkPath, dwRegKeyIndex, szKeyPath, sizeof(szKeyPath)/sizeof(TCHAR)) == ERROR_SUCCESS );

        RegCloseKey(hkPath);

    } // End the RegOpenKey - Mainkey

    return lprnHead;
}

static HWND DisplayAppList(HWND hWnd, LPRUNNODE lprnAppList)
{
    STATUSWINDOW    swAppList;
    LPSTATUSNODE    lpsnTemp        = NULL;
    HWND            hAppList        = NULL;
    LPTSTR          lpAppName       = NULL;

    ZeroMemory(&swAppList, sizeof(swAppList));

    swAppList.X = 10;
    swAppList.Y = 10;

    // Get the title for OEMRUN from the resource
    //
    if ( (lpAppName = AllocateString(NULL, IDS_APPTITLE_OEMRUN)) && *lpAppName )
    {
        lstrcpyn(swAppList.szWindowText, lpAppName, AS ( swAppList.szWindowText ) );

        FREE(lpAppName);
    }

    if(lprnAppList)
    {
        // Walk the list and create our node list
        //
        while ( lprnAppList )
        {
            StatusAddNode(lprnAppList->lpDisplayName, &lpsnTemp);
            lprnAppList = lprnAppList->lpNext;
        }
    }

    // Create the dialog
    //
    hAppList = StatusCreateDialog(&swAppList, lpsnTemp);

    // Delete the node list as we don't need it anymore
    //
    StatusDeleteNodes(lpsnTemp);

    return ( hAppList );
}

static void RunAppList(HWND hWnd, LPRUNNODE lprnAppList, DWORD dwAction)
{
    PROCESS_INFORMATION     pi;
    STARTUPINFO             startup;
    LPRUNNODE               lprnHead                = lprnAppList;
    LPLPRUNNODE             lplprnNext              = &lprnHead;
    TCHAR                   szRegPath[MAX_PATH]     = NULLSTR,
                            szApplication[MAX_PATH] = NULLSTR,
                            szBuffer[MAX_PATH]      = NULLSTR;
    HKEY                    hkPath                  = NULL;
    BOOL                    bReturn                 = FALSE;
    UINT                    uRet;

    if(lprnHead)
    {
        // Walk the list and execute each of the programs
        //
        for(lplprnNext=&lprnHead; *lplprnNext;(lplprnNext=&((*lplprnNext)->lpNext)))
        {
            // Set up the default startupinfo
            //
            ZeroMemory(&startup, sizeof(startup));
            startup.cb          = sizeof(startup);

            // Set the default value for the handle to the process
            //
            pi.hProcess = NULL;

            // Default return value for section
            //
            bReturn = TRUE;

            // First check if this node had an invalid entry
            //
            if ( (*lplprnNext)->bEntryError )
            {
                bReturn = FALSE;
            }
            else 
            {
                // Determine if we are a RUNONCE App and whether we are running from the Registry or Winbom
                //      If we are running from:
                //          Registry - Delete value
                //          Winbom   - Update current state, current state + 1
                if ( (*lplprnNext)->bRunOnce )
                {
                    // If we are running from the Winbom.ini, increment the state index, otherwise, delete the value
                    // 
                    //
                    if ( (*lplprnNext)->bWinbom )
                        SetRunOnceState((*lplprnNext)->dwItemNumber);
                    else
                    {
                        // Create the path in the registry
                        //
                        lstrcpyn(szRegPath, STR_REG_OEMRUNONCE, AS ( szRegPath ) );

                        // There's a subkey, append that to path
                        //
                        if ( (*lplprnNext)->lpSubKey[0] )
                            AddPathN(szRegPath, (*lplprnNext)->lpSubKey, AS ( szRegPath ) );

                        // Delete value from registry
                        //
                        if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_ALL_ACCESS, &hkPath) == ERROR_SUCCESS )
                        {
                            RegDeleteValue(hkPath, (*lplprnNext)->lpValueName);
                        }
                    }

                }

                // Determine if we are not a section and launch the program
                //
                if ( (*lplprnNext)->InstallTech == installtechUndefined )
                {
                    if ( (*lplprnNext)->lpRunValue )
                    {
                        // Lets attempt to connect to any supplied network resources
                        //
                        FactoryNetworkConnect((*lplprnNext)->lpRunValue, g_szWinBOMPath, NULLSTR, TRUE);

                        bReturn = CreateProcess(NULL, (*lplprnNext)->lpRunValue, NULL, NULL, FALSE, CREATE_NEW_PROCESS_GROUP, NULL, NULL, &startup, &pi);

                        // Log whether the detach was successful
                        //
                        FacLogFile(bReturn ? 1 : 0|LOG_ERR, 
                                   bReturn ? IDS_ERR_CREATEPROCESSSUCCESS : IDS_ERR_CREATEPROCESSFAILED, (*lplprnNext)->lpRunValue);
                    }
                }
                else
                {
                
                    // Lets attempt to connect to any supplied network resources
                    //
                    FactoryNetworkConnect((*lplprnNext)->szSourcePath, g_szWinBOMPath, (*lplprnNext)->lpRunValue, TRUE);
                    FactoryNetworkConnect((*lplprnNext)->szCmdLine, g_szWinBOMPath, (*lplprnNext)->lpRunValue, TRUE);
                    FactoryNetworkConnect((*lplprnNext)->szTargetPath, g_szWinBOMPath, (*lplprnNext)->lpRunValue, TRUE);

                    // We are a section, first determine the installtype
                    //
                    switch ((*lplprnNext)->InstallType)
                    {
                        case installtypeStage:
                            {
                                INSTALLUILEVEL  oldUILevel;     // Used for an MSI Attach

                                // There is a setupfile
                                //
                                if ( (*lplprnNext)->szSetupFile[0] )
                                {
                                    if ( (*lplprnNext)->InstallTech == installtechMSI )
                                    {
                                        // Just some logging, telling the user what we are doing
                                        //
                                        FacLogFile(1, IDS_ERR_INITMSIATTACH, (*lplprnNext)->lpDisplayName);

                                        // Set the old MSIInteralUI Level
                                        //
                                        oldUILevel = MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                                        // Create the new command line
                                        //
                                        if ( FAILED ( StringCchPrintf ( szBuffer, AS ( szBuffer ), STR_MSI_STAGE,(*lplprnNext)->szTargetPath) ) )
                                        {
                                            FacLogFileStr(3, _T("StringCchPrintf failed %s %s" ), szBuffer, (*lplprnNext)->szTargetPath);
                                        }
                                        if ( FAILED ( StringCchCat ( (*lplprnNext)->szCmdLine, AS ( (*lplprnNext)->szCmdLine ), szBuffer ) ) )
                                        {
                                            FacLogFileStr(3, _T("StringCchCat failed %s %s" ), (*lplprnNext)->szCmdLine, szBuffer );
                                        }

                                        // Create the full path to the Application
                                        //
                                        lstrcpyn( szApplication, (*lplprnNext)->szSourcePath, AS ( szApplication ) );
                                        AddPathN( szApplication, (*lplprnNext)->szSetupFile, AS ( szApplication ) );

                                        // Initiate the installation
                                        //
                                        uRet = MsiInstallProduct(szApplication, (*lplprnNext)->szCmdLine);

                                        // Default return value to true for staged install
                                        //
                                        bReturn = TRUE;

                                        if ( ( uRet == ERROR_SUCCESS_REBOOT_REQUIRED ) ||
                                             ( uRet == ERROR_SUCCESS_REBOOT_INITIATED ) )
                                        {
                                            // We have some code that we need to determine if we do a mini-wipe so we will just fall through
                                            //
                                            (*lplprnNext)->bReboot = TRUE;
                                        }
                                        else if ( uRet != ERROR_SUCCESS )
                                        {
                                            bReturn = FALSE;
                                            FacLogFile(0|LOG_ERR, IDS_MSI_FAILURE, uRet, (*lplprnNext)->lpDisplayName);
                                        }

                                        // Restore internal UI level of MSI installer.
                                        //
                                        MsiSetInternalUI(oldUILevel, NULL);
                                    }

                                    // Determine if there is a sourcepath, and execute the application
                                    //
                                    else if ( (*lplprnNext)->szSourcePath[0] )
                                    {
                                        // Create the path to the application
                                        //
                                        lstrcpyn( szApplication, (*lplprnNext)->szSourcePath, AS(szApplication) );
                                        AddPathN( szApplication, (*lplprnNext)->szSetupFile, AS ( szApplication ) );
                                        StrCatBuff( szApplication, _T(" "), AS(szApplication) );
                                        StrCatBuff( szApplication, (*lplprnNext)->szCmdLine, AS(szApplication) );

                                        // Launch the program
                                        //
                                        bReturn = CreateProcess(NULL, szApplication, NULL, NULL, FALSE, CREATE_NEW_PROCESS_GROUP, NULL, NULL, &startup, &pi);      
                                    }
                                    else
                                        bReturn = FALSE;
                                }
                                else
                                {
                                    // There is no setup file, just copy the files from SOURCEPATH -> TARGETPATH
                                    //
                                    if ( (*lplprnNext)->szSourcePath[0] && (*lplprnNext)->szTargetPath[0] )
                                        bReturn = CopyDirectoryProgress(NULL, (*lplprnNext)->szSourcePath, (*lplprnNext)->szTargetPath );
                                    else
                                        FacLogFile(0|LOG_ERR, IDS_ERR_NOSOURCETARGET, (*lplprnNext)->lpDisplayName);

                                }

                                // Log to the user whether the stage was successful
                                //
                                FacLogFile(bReturn ? 1 : 0|LOG_ERR, bReturn ? IDS_ERR_STAGESUCCESS : IDS_ERR_STAGEFAILED, (*lplprnNext)->lpDisplayName);    

                                break;
                            }

                        case installtypeDetach:
                            {
                                // If we have a setup file launch it, otherwise, removed the targetPath
                                //
                                if ( (*lplprnNext)->szSetupFile[0] )
                                {
                                    // Create the path to the application
                                    //
                                    lstrcpyn( szApplication, (*lplprnNext)->szSourcePath, AS(szApplication) );
                                    AddPathN( szApplication, (*lplprnNext)->szSetupFile, AS (szApplication )  );
                                    StrCatBuff( szApplication, _T(" "), AS(szApplication) );
                                    StrCatBuff( szApplication, (*lplprnNext)->szCmdLine, AS(szApplication) );

                                    // Launch the program
                                    //
                                    bReturn = CreateProcess(NULL, szApplication, NULL, NULL, FALSE, CREATE_NEW_PROCESS_GROUP, NULL, NULL, &startup, &pi);          
                                }
                                else
                                    bReturn = DeletePath( (*lplprnNext)->szTargetPath );

                                // Log whether the detach was successful
                                //
                                FacLogFile(bReturn ? 1 : 0|LOG_ERR, bReturn ? IDS_ERR_DETACHSUCCESS : IDS_ERR_DETACHFAILED, (*lplprnNext)->lpDisplayName);

                                break;
                            }

                        case installtypeAttach:
                        case installtypeStandard:
                            {
                                INSTALLUILEVEL  oldUILevel;     // Used for an MSI Attach

                                // TargetPath and SetupFile are required to continue attach
                                //
                                if ( (*lplprnNext)->szTargetPath[0] && (*lplprnNext)->szSetupFile[0] )
                                {
                                    switch ( (*lplprnNext)->InstallTech )
                                    {
                                        // We are attaching an MSI application
                                        //
                                        case installtechMSI:
                                           {
                                                // Just some logging, telling the user what we are doing
                                                //
                                                FacLogFile(1, IDS_ERR_INITMSIATTACH, (*lplprnNext)->lpDisplayName);

                                                // Set the old MSIInteralUI Level
                                                //
                                                oldUILevel = MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);

                                                // Create the new command line
                                                //
                                                if ( FAILED ( StringCchCat ( (*lplprnNext)->szCmdLine, AS ( (*lplprnNext)->szCmdLine ), STR_MSI_ATTACH ) ) )
                                                {
                                                    FacLogFileStr(3, _T("StringCchCat failed %s %s" ), (*lplprnNext)->szCmdLine, STR_MSI_ATTACH );
                                                }

                                                // Create the full path to the Application
                                                //
                                                lstrcpyn( szApplication, (*lplprnNext)->szTargetPath, AS(szApplication) );
                                                
                                                AddPathN( szApplication, (*lplprnNext)->szSetupFile, AS ( szApplication ) );

                                                // Initiate the installation
                                                //
                                                uRet = MsiInstallProduct(szApplication, (*lplprnNext)->szCmdLine);

                                                // Set the default return for attaching application
                                                //
                                                bReturn = TRUE;

                                                if ( ( uRet == ERROR_SUCCESS_REBOOT_REQUIRED ) ||
                                                     ( uRet == ERROR_SUCCESS_REBOOT_INITIATED ) )
                                                {
                                                    // We have some code that we need to determine if we do a mini-wipe so we will just fall through
                                                    //
                                                    (*lplprnNext)->bReboot = TRUE;
                                                }
                                                else if ( uRet != ERROR_SUCCESS )
                                                {
                                                    bReturn = FALSE;
                                                    FacLogFile(0|LOG_ERR, IDS_MSI_FAILURE, uRet, (*lplprnNext)->lpDisplayName);
                                                }

                                                // Restore internal UI level of MSI installer.
                                                //
                                                MsiSetInternalUI(oldUILevel, NULL);
                                            }
                                            break;

                                        case installtechApp:
                                        case installtechINF:
                                            // Attaching Generic/INF Application
                                            //
                                            {
                                                // Create the path to the application
                                                //
                                                lstrcpyn( szApplication, (*lplprnNext)->szTargetPath, AS(szApplication) );
                                                AddPathN( szApplication, (*lplprnNext)->szSetupFile, AS ( szApplication ) );

                                                // If Installing Generic Application, add the CmdLine and execute script
                                                //
                                                if ((*lplprnNext)->InstallTech == installtechApp )
                                                {
                                                    StrCatBuff( szApplication, _T(" "), AS(szApplication) );
                                                    StrCatBuff( szApplication, (*lplprnNext)->szCmdLine, AS(szApplication) );

                                                    // Launch the program
                                                    //
                                                    bReturn = CreateProcess(NULL, szApplication, NULL, NULL, FALSE, CREATE_NEW_PROCESS_GROUP, NULL, NULL, &startup, &pi);
                                                }
                                                else
                                                {
                                                    // This is an INF that we are processing, process it
                                                    //
                                                    bReturn = ProcessInfSection(szApplication, (*lplprnNext)->szSectionName);
                                                }
                                            }
                                            break;

                                        default:
                                            bReturn = FALSE;
                                    }
                                }
                                else
                                    bReturn = FALSE;

                                // Log whether the attach succeeded.
                                //
                                FacLogFile(bReturn ? 1 : 0|LOG_ERR, bReturn ? IDS_ERR_ATTACHSUCCESS : IDS_ERR_ATTACHFAILED, (*lplprnNext)->lpDisplayName);
                                break;
                            }
                        default:

                            FacLogFile(0|LOG_ERR, IDS_ERR_UNDEFINSTALL, (*lplprnNext)->lpDisplayName);
                            break;
                    }

                }

                // If we were successful at creating the process, wait on it and then close any open handles
                //
                if ( bReturn && pi.hProcess)
                {
                    // If this is synchronous, then wait for the process
                    //
                    if (dwAction)
                    {
                        DWORD dwExitCode = 0;

                        WaitForSingleObjectEx(pi.hProcess, INFINITE, TRUE);
                    
                        // Need to log the exit code.
                        //
                        if ( GetExitCodeProcess(pi.hProcess, &dwExitCode) )
                        {
                            FacLogFile(0, IDS_LOG_APPEXITCODE, (*lplprnNext)->lpDisplayName, dwExitCode);
                        }
                        else
                        {
                            FacLogFile(0 | LOG_ERR, IDS_LOG_APPEXITCODENONE, (*lplprnNext)->lpDisplayName);
                        }
                    }

                    // Clean up the handles
                    //
                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);
                }

                // We must do some post application stuff after the process is complete
                //
                if ( (*lplprnNext)->InstallTech != installtechUndefined )
                {
                    // In the attach case we may need to do a mini-wipe, do that here
                    //
                    if ( (*lplprnNext)->InstallType == installtypeAttach && (*lplprnNext)->bRemoveTarget)
                    {
                        if (!DeletePath( (*lplprnNext)->szTargetPath ))
                        {
                            FacLogFile(0 | LOG_ERR, IDS_LOG_APPEXITCODENONE, (*lplprnNext)->lpDisplayName);
                        }
                    }
                }

                // Check to see if we need to reboot
                //
                if ( (*lplprnNext)->bReboot )
                {
                    OemReboot();
                    return;
                }


                // Disconnect any network connections that were opened by factory
                //
                if ( (*lplprnNext)->InstallTech == installtechUndefined )
                {
                    // Disconnect to any resources in the RunValue
                    //
                    FactoryNetworkConnect((*lplprnNext)->lpRunValue, g_szWinBOMPath, NULLSTR, FALSE);
                }
                else
                {
                    // Disconnect from any resources in the SourcePath, CommandLine, or StagePath
                    FactoryNetworkConnect((*lplprnNext)->szSourcePath, g_szWinBOMPath, NULLSTR, FALSE);
                    FactoryNetworkConnect((*lplprnNext)->szCmdLine, g_szWinBOMPath, NULLSTR, FALSE);
                    FactoryNetworkConnect((*lplprnNext)->szTargetPath, g_szWinBOMPath, NULLSTR, FALSE);
                }
            }

            // If the dialog is visible, then progress to the next item in the list
            //
            if ( hWnd )
                StatusIncrement(hWnd, bReturn);
        }
    }

    // Delete the applist from memory
    //
    DeleteAppList(lprnAppList);
}


/*++
===============================================================================
Routine Description:

    VOID DeleteAppList
    
    Deletes all the apps in a given list and frees the memory associated with
    the list

Arguments:

    lprnCurrent - current head of the list
    
Return Value:

    None

===============================================================================
--*/
static void DeleteAppList(LPRUNNODE lprnCurrent)
{
    if (lprnCurrent->lpNext!=NULL)
        DeleteAppList(lprnCurrent->lpNext);

    FREE(lprnCurrent);
}


/*++
===============================================================================
Routine Description:

    VOID OemReboot
    
    Sets the OEMRESET key and reboots the machine if necessary during the preinstall
    process.  The OEMRESET key is there so the user does not see the OEMRESET Reboot
    dialog.

Arguments:

    None
    
Return Value:

    None

===============================================================================
--*/
static void OemReboot()
{
    HKEY    hkPath;
    DWORD   dwRegValue = 1;

    // Set the reboot flag for OEMReset
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, STR_REG_CURRENTVER, 0, KEY_ALL_ACCESS, &hkPath) == ERROR_SUCCESS)
    {
        // Setthe reboot value for OEMReset in the registry
        //
        RegSetValueEx(hkPath, STR_VAL_OEMRESETSILENT, 0, REG_DWORD, (LPBYTE)&dwRegValue, sizeof(dwRegValue));

        // Do a little bit of cleaning up
        //
        RegCloseKey(hkPath);

        // Set the necessary system privileges to reboot
        //
        EnablePrivilege(SE_SHUTDOWN_NAME,TRUE);

        // Let's reboot the machine
        //
        ExitWindowsEx(EWX_REBOOT, 0);
    }
}


/*++
===============================================================================
Routine Description:

    BOOL SetRunOnceState
    
    This routine sets the current application we are on for the OemRunOnce section
    of the winbom.ini.  This allows us to pick up where we left off if there is a
    reboot during the process

Arguments:

    dwState - State number to set
    
Return Value:

    None

===============================================================================
--*/
static VOID SetRunOnceState(DWORD dwState)
{
    HKEY    hkPath;

    // Open the currentversion key
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_FACTORY_STATE, 0, KEY_ALL_ACCESS, &hkPath) == ERROR_SUCCESS)
    {
        // Setthe OemRunOnce flag in the registry so we don't run the winbom.ini RunOnce section again
        //
        RegSetValueEx(hkPath, STR_VAL_WINBOMRO, 0, REG_DWORD, (LPBYTE)&dwState, sizeof(dwState));

        RegCloseKey(hkPath);
    }
}


/*++
===============================================================================
Routine Description:

    DWORD GetRunOnceState
    
    This routine gets current (last run) state that we successfully executed

Arguments:

    None
    
Return Value:

    Last successful state

===============================================================================
--*/
static DWORD GetRunOnceState(VOID)
{
    HKEY    hkPath;
    DWORD   dwState     = 0,
            dwStateSize = sizeof(dwState);

    // Open the currentversion key
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_FACTORY_STATE, 0, KEY_ALL_ACCESS, &hkPath) == ERROR_SUCCESS)
    {
        // Setthe OemRunOnce flag in the registry so we don't run the winbom.ini RunOnce section again
        //
        RegQueryValueEx(hkPath, STR_VAL_WINBOMRO, NULL, NULL, (LPBYTE)&dwState, &dwStateSize);
        
        RegCloseKey(hkPath);
    }

    return dwState;
}

/*++
===============================================================================
Routine Description:

    BOOL OemRun
    
    This routine is a wrapper for the ProcessSection function and will process the 
    OemRun section of the winbom.ini

Arguments:

    Standard state structure
    
Return Value:

    TRUE if no error
    FALSE if error

===============================================================================
--*/
BOOL OemRun(LPSTATEDATA lpStateData)
{
    return ProcessSection(FALSE);

}

BOOL DisplayOemRun(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INF_SEC_OEMRUN, NULL, NULL);
}

/*++
===============================================================================
Routine Description:

    BOOL OemRunOnce
    
    This routine is a wrapper for the ProcessSection function and will process the 
    OemRunOnce section of the winbom.ini

Arguments:

    Standard state structure
    
Return Value:

    TRUE if no error
    FALSE if error

===============================================================================
--*/
BOOL OemRunOnce(LPSTATEDATA lpStateData)
{
    return ProcessSection(TRUE);
}

BOOL DisplayOemRunOnce(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INF_SEC_OEMRUNONCE, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\power.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    power.c

Abstract:

    This module contains code to set the default power scheme and hibernation settings in Windows.
    
    [ComputerSettings]     
    Hibernation = YES | NO        - Specifies whether we want hibernation.
    PowerScheme = Desktop |		  - These are the standard power schemes in Whistler.	
				  Laptop |
				  Presentation |
				  AlwaysOn | Always On |
				  Minimal |
				  MaxBattery | Max Battery

    

Author:

    Adrian Cosma (acosma) - 1/31/2001

Revision History:

--*/


//
// Includes
//

#include "factoryp.h"
// For setting default power scheme


#define REG_KEY_WINLOGON                            _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define REG_VALUE_HIBERNATION_PREVIOUSLY_ENABLED    _T("HibernationPreviouslyEnabled")

//
// Function implementations
//


/*

  Returns: TRUE on success, FALSE if there is some failure.

*/
BOOL SetPowerOptions(LPSTATEDATA lpStateData)
{
    LPTSTR                      lpszWinBOMPath               = lpStateData->lpszWinBOMPath;
    TCHAR                       szBuf[MAX_INF_STRING_LENGTH] = NULLSTR;
    
    // BOOLEAN is 1 byte, bEnable has to be BOOLEAN, not BOOL (which is 4 bytes).
    BOOLEAN                     bEnable;                    
    UINT                        uiPwrPol                     = UINT_MAX;
    BOOL                        bRet                         = TRUE;
    BOOL                        bHiber                       = FALSE;
        
    //
    // Is Hibernation specified?
    //
    if ( GetPrivateProfileString( WBOM_SETTINGS_SECTION, INI_KEY_WBOM_HIBERNATION, NULLSTR, szBuf, AS(szBuf), lpszWinBOMPath) &&
         szBuf[0] 
       )
    {
        if ( 0 == LSTRCMPI(szBuf, WBOM_NO) )
        {
            bEnable = FALSE;
            bHiber  = TRUE;
        }
        else if ( 0 == LSTRCMPI(szBuf, WBOM_YES) )
        {
            bEnable = TRUE; 
            bHiber  = TRUE;
        }
        else
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_WINBOMVALUE, lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_HIBERNATION, szBuf);
            bRet = FALSE;
        }
        if ( bHiber )
        {
            NTSTATUS Status;

            // Request the privilege to create a pagefile.  Oddly enough this is needed
            // to disable hibernation.
            //
            EnablePrivilege(SE_CREATE_PAGEFILE_NAME, TRUE);
                
            Status = NtPowerInformation ( SystemReserveHiberFile, &bEnable, sizeof (bEnable), NULL, 0 );
            
            if ( Status != STATUS_SUCCESS )
               FacLogFile(0 | LOG_ERR, IDS_ERR_NTPOWERINFO, Status );
            else
            {
                // Do this so winlogon doesn't decide to re-enable hibernation for us if we disabled it.
                //
                RegSetDword(NULL, REG_KEY_WINLOGON, REG_VALUE_HIBERNATION_PREVIOUSLY_ENABLED, 1);
            }
        }
    }

    //
    // Set Power Scheme
    //
    if ( GetPrivateProfileString( WBOM_SETTINGS_SECTION, INI_KEY_WBOM_PWRSCHEME, NULLSTR, szBuf, AS(szBuf), lpszWinBOMPath) &&
         szBuf[0]
       )
    {
        if      ( 0 == LSTRCMPI(szBuf, INI_VAL_WBOM_PWR_DESKTOP) )
            uiPwrPol = 0;
        else if ( 0 == LSTRCMPI(szBuf, INI_VAL_WBOM_PWR_LAPTOP) )
            uiPwrPol = 1;
        else if ( 0 == LSTRCMPI(szBuf, INI_VAL_WBOM_PWR_PRESENTATION) )
            uiPwrPol = 2;
        else if ( 0 == LSTRCMPI(szBuf, INI_VAL_WBOM_PWR_ALWAYSON)   || 0 == LSTRCMPI(szBuf, INI_VAL_WBOM_PWR_ALWAYS_ON) )
            uiPwrPol = 3;
        else if ( 0 == LSTRCMPI(szBuf, INI_VAL_WBOM_PWR_MINIMAL) )
            uiPwrPol = 4;
        else if ( 0 == LSTRCMPI(szBuf, INI_VAL_WBOM_PWR_MAXBATTERY) || 0 == LSTRCMPI(szBuf, INI_VAL_WBOM_PWR_MAX_BATTERY) )
            uiPwrPol = 5;


        // If something valid was specified set it.
        //
        if ( UINT_MAX != uiPwrPol )
        {
            if ( !SetActivePwrScheme(uiPwrPol, NULL, NULL) )     
            {
                FacLogFile(0 | LOG_ERR, IDS_ERR_SETPWRSCHEME, GetLastError());
                bRet = FALSE;
            }
        }
        else 
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_WINBOMVALUE, lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_PWRSCHEME, szBuf);
            bRet = FALSE;
        }
    }
    return bRet;
}

BOOL DisplaySetPowerOptions(LPSTATEDATA lpStateData)
{
    return ( IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_HIBERNATION, NULL) ||
             IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_PWRSCHEME, NULL) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\setshell.c ===
/****************************************************************************\

    SHELL.C / Factory Mode (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file for Factory that contains the shell settings state functions.

    06/2001 - Jason Cohen (JCOHEN)

        Added this new source file for factory for setting shell settings in
        the Winbom.

\****************************************************************************/


//
// Include File(s):
//

#include "factoryp.h"
#include <shlobj.h>
#include <shlobjp.h>
#include <uxthemep.h>


//
// Internal Define(s):
//

#define REG_KEY_THEMEMGR                _T("Software\\Microsoft\\Windows\\CurrentVersion\\ThemeManager")
#define REG_VAL_THEMEPROP_DLLNAME       _T("DllName")
//#define REG_VAL_THEMEPROP_THEMEACTIVE   _T("ThemeActive")

#define REG_KEY_LASTTHEME               _T("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\LastTheme")
#define REG_VAL_THEMEFILE               _T("ThemeFile")

#define INI_SEC_STYLES                  _T("VisualStyles")
#define INI_KEY_STYLES_PATH             _T("Path")
#define INI_KEY_STYLES_COLOR            _T("ColorStyle")
#define INI_KEY_STYLES_SIZE             _T("Size")

#define REG_KEY_DOCLEANUP               _T("Software\\Microsoft\\Windows\\CurrentVersion\\OemStartMenuData")
#define REG_VAL_DOCLEANUP               _T("DoDesktopCleanup")

#define REG_KEY_STARTMESSENGER          _T("Software\\Policies\\Microsoft\\Messenger\\Client")
#define REG_VAL_STARTMESSENGERAUTO      _T("PreventAutoRun")

#define REG_KEY_USEMSNEXPLORER          _T("Software\\Microsoft\\MSN6\\Setup\\MSN\\Codes")
#define REG_VAL_USEMSNEXPLORER          _T("IAOnly")


//
// External Function(s):
//

BOOL ShellSettings(LPSTATEDATA lpStateData)
{
    LPTSTR  lpszIniVal  = NULL;
    BOOL    bIniVal     = FALSE,
            bError      = FALSE,
            bReturn     = TRUE;

    // Determine if the DoDesktopCleanup value is in the winbom, if nothing is there don't make any changes.
    //
    if ( lpszIniVal = IniGetString(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, INI_KEY_WBOM_SHELL_DOCLEANUP, NULL) )
    {
        if ( LSTRCMPI(lpszIniVal, INI_VAL_WBOM_YES) == 0 )
        {
            // Do desktop cleanup.
            //
            bIniVal = TRUE;

        }
        else if ( LSTRCMPI(lpszIniVal, INI_VAL_WBOM_NO) == 0 )
        {
            // Delay desktop cleanup.
            //
            bIniVal = FALSE;
        }
        else
        {
            // Error processing value, user did not choose valid value (Yes/No)
            //
            bError = TRUE;
            bReturn = FALSE;
            FacLogFile(0 | LOG_ERR, IDS_ERR_WINBOMVALUE, lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, INI_KEY_WBOM_SHELL_DOCLEANUP, lpszIniVal);
        }

        // If there was not an error, set the proper value in the registry
        //
        if ( !bError )
        {
            RegSetDword(HKLM, REG_KEY_DOCLEANUP, REG_VAL_DOCLEANUP, bIniVal ? 1 : 0);
        }

        // Free up the used memory
        //
        FREE(lpszIniVal);
    }

    // Reset the error value
    //
    bError = FALSE;

    // Determine if the StartMessenger value is in the winbom, if nothing is there, don't make any changes
    //
    if ( lpszIniVal = IniGetString(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, INI_KEY_WBOM_SHELL_STARTMESSENGER, NULL) )
    {

        if ( LSTRCMPI(lpszIniVal, INI_VAL_WBOM_YES) == 0 )
        {
            // User not starting messenger
            bIniVal = TRUE;

        }
        else if ( LSTRCMPI(lpszIniVal, INI_VAL_WBOM_NO) == 0 )
        {
            // User starting messenger
            //
            bIniVal = FALSE;

        }
        else
        {
            // Error processing value, user did not choose valid value (Yes/No)
            //
            bError = TRUE;
            bReturn = FALSE;
            FacLogFile(0 | LOG_ERR, IDS_ERR_WINBOMVALUE, lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, INI_KEY_WBOM_SHELL_STARTMESSENGER, lpszIniVal);
        }

        // If there was not an error, set the proper values in the registry
        //
        if ( !bError )
        {
            RegSetDword(HKLM, REG_KEY_STARTMESSENGER, REG_VAL_STARTMESSENGERAUTO, bIniVal ? 0 : 1);
        }

        // Free up the used memory
        //
        FREE(lpszIniVal);
    }


    // Reset the error value
    //
    bError = FALSE;

    // Determine if the UseMSNSignup value is in the winbom, if nothing is there, don't make any changes
    //
    if ( lpszIniVal = IniGetString(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, INI_KEY_WBOM_SHELL_USEMSNEXPLORER, NULL) )
    {

        if ( LSTRCMPI(lpszIniVal, INI_VAL_WBOM_YES) == 0 )
        {
            // User is using MSNExplorer
            //
            bIniVal = TRUE;

        }
        else if ( LSTRCMPI(lpszIniVal, INI_VAL_WBOM_NO) == 0 )
        {
            // User is not using MSNExplorer
            //
            bIniVal = FALSE;

        }
        else
        {
            // Error processing value, user did not choose valid value (Yes/No)
            //
            bError = TRUE;
            bReturn = FALSE;
            FacLogFile(0 | LOG_ERR, IDS_ERR_WINBOMVALUE, lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, INI_KEY_WBOM_SHELL_USEMSNEXPLORER, lpszIniVal);
        }

        // If there was not an error, set the proper values in the registry
        //
        if ( !bError )
        {
            TCHAR   szFilePath1[MAX_PATH]   = NULLSTR,
                    szFilePath2[MAX_PATH]   = NULLSTR;
            LPTSTR  lpMSNExplorer           = NULL,
                    lpMSNOnline             = NULL;

            // Set the proper string in the registry
            //
            RegSetString(HKLM, REG_KEY_USEMSNEXPLORER, REG_VAL_USEMSNEXPLORER, bIniVal ? _T("NO") : _T("YES"));

            // Attempt to rename the file in the program menu
            //
            if ( SHGetSpecialFolderPath( NULL, szFilePath1, CSIDL_COMMON_PROGRAMS, FALSE ) &&
                 lstrcpyn( szFilePath2, szFilePath1, AS ( szFilePath2 ) ) &&
                 (lpMSNExplorer = AllocateString(NULL, IDS_MSN_EXPLORER)) && 
                 (lpMSNOnline = AllocateString(NULL, IDS_GET_ONLINE_MSN)) && 
                 AddPathN(szFilePath1, bIniVal ? lpMSNOnline : lpMSNExplorer, AS(szFilePath1)) &&
                 AddPathN(szFilePath2, bIniVal ? lpMSNExplorer: lpMSNOnline, AS(szFilePath2)) 
               )
            {
                if ( !MoveFile(szFilePath1, szFilePath2) )
                {
                    FacLogFileStr(3 | LOG_ERR, _T("DEBUG: MoveFile('%s','%s') - Failed (Error: %d)\n"), szFilePath1, szFilePath2, GetLastError());
                    bReturn = FALSE;
                }
                else
                {
                    FacLogFileStr(3, _T("DEBUG: MoveFile('%s','%s') - Succeeded\n"), szFilePath1, szFilePath2);
                }
            }

            // Free up the used memory
            //
            FREE(lpMSNExplorer);
            FREE(lpMSNOnline);
        }

        // Free up the used memory
        //
        FREE(lpszIniVal);
    }

    // This only sets these settings for new users created.  ShellSettings2() will
    // fix it up so the current factory user will also get the right settings.
    //
    return ( SetupShellSettings(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL) && bReturn );
}

BOOL ShellSettings2(LPSTATEDATA lpStateData)
{
    BOOL    bRet            = TRUE,
            bNewTheme       = FALSE,
            bWantThemeOn,
            bIsThemeOn,
            bStartPanel,
            bIniSetting;
    LPTSTR  lpszVisualStyle       = NULL,
            lpszVisualStyleColor  = NULL,
            lpszVisualStyleSize   = NULL,
            lpszIniSetting;

    // Now see if they want to turn the theme on or off.
    //
    bIniSetting = FALSE;
    if ( lpszIniSetting = IniGetExpand(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, INI_KEY_WBOM_SHELL_THEMEOFF, NULL) )
    {
        // See if it is a value we recognize.
        //
        if ( LSTRCMPI(lpszIniSetting, INI_VAL_WBOM_YES) == 0 )
        {
            bWantThemeOn = FALSE;
            bIniSetting = TRUE;
        }
        else if ( LSTRCMPI(lpszIniSetting, INI_VAL_WBOM_NO) == 0 )
        {
            bWantThemeOn = TRUE;
            bIniSetting = TRUE;
        }
        else
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_WINBOMVALUE, lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, INI_KEY_WBOM_SHELL_THEMEOFF, lpszIniSetting);
            bRet = FALSE;
        }

        FREE(lpszIniSetting);
    }

    // See if they have a custom theme they want to use.
    //
    if ( lpszIniSetting = IniGetExpand(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, INI_KEY_WBOM_SHELL_THEMEFILE, NULL) )
    {
        // The file has to exist so we can look for the visual style
        // of the theme.
        //
        if ( FileExists(lpszIniSetting) )
        {
            BOOL bVisualStyle;

            // Check for the visual style in the theme file.  If missing, we just use the
            // classic one.
            //
            lpszVisualStyle = IniGetExpand(lpszIniSetting, INI_SEC_STYLES, INI_KEY_STYLES_PATH, NULL);
            bVisualStyle = ( NULL != lpszVisualStyle );
            if ( bVisualStyle )
            {
                // If they want styles on, get what the settings are for the color and size.
                //
                lpszVisualStyleColor = IniGetExpand(lpszIniSetting, INI_SEC_STYLES, INI_KEY_STYLES_COLOR, NULL);
                lpszVisualStyleSize = IniGetExpand(lpszIniSetting, INI_SEC_STYLES, INI_KEY_STYLES_SIZE, NULL);
            }

            // We override what they may have specified above for "want themes on" based
            // on if there is a visual style in this them or not.  May also need to warn
            // them if there default themes off key conflicts with the theme specified.
            //
            if ( ( bIniSetting ) &&
                 ( bVisualStyle != bWantThemeOn ) )
            {
                // May not want to actually return failure here, but really one of the settings they
                // put in the winbom is not going to be used because the other one is overriding
                // it.
                //
                FacLogFile(0, bVisualStyle ? IDS_ERR_THEME_CONFLICT_ON : IDS_ERR_THEME_CONFLICT_OFF, lpszIniSetting);
            }
            bWantThemeOn = bVisualStyle;

            // If the file exists, means we want to change the visual style even
            // if the theme doesn't contain one.  Also set the ini setting flag so
            // we know we have a vallid setting to change.
            //
            bNewTheme = TRUE;
            bIniSetting = TRUE;
        }
        else
        {
            // File is not there, so log error and ignore this key.
            //
            FacLogFile(0 | LOG_ERR, IDS_ERR_THEME_MISSING, lpszIniSetting);
            bRet = FALSE;
        }

        FREE(lpszIniSetting);
    }

    // Only need to do anything if there is a new theme to use
    // or they wanted to change the default theme to on/off.
    //
    if ( bIniSetting )
    {
        HRESULT hr;

        // We need COM to do the theme stuff.
        //
        hr = CoInitialize(NULL);
        if ( SUCCEEDED(hr) )
        {
            TCHAR szPath[MAX_PATH] = NULLSTR;

            // Check to see if the themes are turned on or not.
            //
            hr = GetCurrentThemeName(szPath, AS(szPath), NULL, 0, NULL, 0);
            bIsThemeOn = ( SUCCEEDED(hr) && szPath[0] );

            // Now find out if we really need to do anything.  Only if they have
            // an new theme to use or they want to switch themes on/off.
            //
            if ( ( bNewTheme && bWantThemeOn ) ||
                 ( bWantThemeOn != bIsThemeOn ) )
            {
                // See if we need to turn the themes on, or set a new
                // theme.
                //
                if ( bWantThemeOn )
                {
                    // If they didn't specify a new theme, we need to get the default
                    // visual style from the registry.
                    //
                    if ( NULL == lpszVisualStyle )
                    {
                        lpszVisualStyle = RegGetExpand(HKLM, REG_KEY_THEMEMGR, REG_VAL_THEMEPROP_DLLNAME);
                    }

                    // We should have some theme to apply at this point.
                    //
                    if ( lpszVisualStyle && *lpszVisualStyle )
                    {
                        // apply the theme.
                        hr = SetSystemVisualStyle(lpszVisualStyle, lpszVisualStyleColor, lpszVisualStyleSize, AT_LOAD_SYSMETRICS);
                        if ( SUCCEEDED(hr) )
                        {
                            // Woo hoo, successfully applied the theme.
                            //
                            FacLogFile(1, IDS_LOG_THEME_CHANGED, lpszVisualStyle);
                            bIsThemeOn = TRUE;

                            // This is a cheap hack so that if you go into
                            // control panel it shows "Modified Theme" instead of
                            // whatever one you last had selected.  We do this
                            // rather than set the name because we are only appling
                            // the visual effects, not other stuff in the theme
                            // like wallpaper.
                            //
                            RegDelete(HKCU, REG_KEY_LASTTHEME, REG_VAL_THEMEFILE);
                        }
                        else
                        {
                            // Do'h, apply failed for some reason.
                            //
                            FacLogFile(0 | LOG_ERR, IDS_ERR_THEME_APPLY, lpszVisualStyle, hr);
                            bRet = FALSE;
                        }
                    }
                    else
                    {
                        // Strange, no default theme file to use to enable
                        // the new themes.
                        //
                        FacLogFile(0 | LOG_ERR, IDS_ERR_THEME_NODEFAULT);
                        bRet = FALSE;
                    }
                }
                else
                {
                    // Disable the new theme styles and use the clasic windows
                    // styles since they have one current selected.
                    //
                    hr = ApplyTheme(NULL, 0, NULL);
                    if ( SUCCEEDED(hr) )
                    {
                        // Woo hoo, we disabled the new themes.
                        //
                        FacLogFile(1, IDS_LOG_THEME_DISABLED);
                        bIsThemeOn = FALSE;

                        // This is a cheap hack so that if you go into
                        // control panel it shows "Modified Theme" instead of
                        // whatever one you last had selected.  We do this
                        // rather than set the name because we are only appling
                        // the visual effects, not other stuff in the theme
                        // like wallpaper.
                        //
                        RegDelete(HKCU, REG_KEY_LASTTHEME, REG_VAL_THEMEFILE);
                    }
                    else
                    {
                        // Do'h, couldn't remove the current theme for some reason.
                        //
                        FacLogFile(0 | LOG_ERR, IDS_ERR_THEME_DISABLE, hr);
                        bRet = FALSE;
                    }
                }
            }
            else
            {
                // Theme already disabled or enabled, just log a high level warning
                // since the key they are setting is really doing nothing.
                //
                FacLogFile(2, bIsThemeOn ? IDS_LOG_THEME_ALREADYENABLED : IDS_LOG_THEME_ALREADYDISABLED);
            }

            // Free up COM since we don't need it any more.
            //
            CoUninitialize();
        }
        else
        {
            // COM error, this is bad.
            //
            FacLogFile(0 | LOG_ERR, IDS_ERR_COMINIT, hr);
            bRet = FALSE;
        }

        // Free these guys (macro checks for NULL).
        //
        FREE(lpszVisualStyle);
        FREE(lpszVisualStyleColor);
        FREE(lpszVisualStyleSize);
    }

    // Get the new start panel setting from the winbom.
    //
    bIniSetting = FALSE;
    if ( lpszIniSetting = IniGetExpand(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, INI_KEY_WBOM_SHELL_STARTPANELOFF, NULL) )
    {
        // See if it is a value we recognize.
        //
        if ( LSTRCMPI(lpszIniSetting, INI_VAL_WBOM_YES) == 0 )
        {
            bStartPanel = FALSE;
            bIniSetting = TRUE;
        }
        else if ( LSTRCMPI(lpszIniSetting, INI_VAL_WBOM_NO) == 0 )
        {
            bStartPanel = TRUE;
            bIniSetting = TRUE;
        }
        else
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_WINBOMVALUE, lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, INI_KEY_WBOM_SHELL_STARTPANELOFF, lpszIniSetting);
            bRet = FALSE;
        }

        FREE(lpszIniSetting);
    }

    // See if they had a recognized value for the start panel key.
    //
    if ( bIniSetting )
    {
        SHELLSTATE ss = {0};

        // Get the current start panel setting.
        //
        SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);

        // I think that fStartPanelOn is set to -1, not TRUE
        // if enabled, so we have to do this rather than a !=.
        // It would be nice to have an exclusive or here.
        //
        if ( ( bStartPanel && !ss.fStartPanelOn ) ||
             ( !bStartPanel && ss.fStartPanelOn ) )
        {
            // This will disable or enable the new start panel depending
            // on what was in the winbom.
            //
            FacLogFile(1, bStartPanel ? IDS_LOG_STARTPANEL_ENABLE : IDS_LOG_STARTPANEL_DISABLE);
            ss.fStartPanelOn = bStartPanel;
            SHGetSetSettings(&ss, SSF_STARTPANELON, TRUE);
        }
        else
        {
            // Start panel already disabled or enabled, just log a high level warning
            // since the key they are setting is really doing nothing.
            //
            FacLogFile(2, bStartPanel ? IDS_LOG_STARTPANEL_ALREADYENABLED : IDS_LOG_STARTPANEL_ALREADYDISABLED);
        }
    }

    return bRet;
}

BOOL DisplayShellSettings(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SHELL, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\shell.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    shell.c

Abstract:

    This module contains code to set the shell optimizations based on the system's physical memory
    
    [ComputerSettings]     
    OptimizeShell = YES | NO - Overides the default optimization.  The default is based on the amount of
                               physical memory on the system.  If the system has less than MIN_MEMORY MB of memory
                               the default for this key will be NO, otherwise, it will be YES.
    

Author:

    Stephen Lodwick (stelo) 05/2001

Revision History:

--*/


//
// Include File(s):
//
#include "factoryp.h"


//
// Defined Value(s):
//
#define MIN_MEMORY  84      // Used 84MB because system may have 96MB but the memory function reports less (video memory)

#define REG_KEY_FASTUSERS   _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define REG_VAL_MULTISES    _T("AllowMultipleTSSessions")


BOOL OptimizeShell(LPSTATEDATA lpStateData)
{
    BOOL            bRet        = TRUE;
    MEMORYSTATUSEX  mStatus;
    DWORD           dwSetting   = 0;


    // Do not continue if the user did not want to optimize the shell (optimize if there is no setting)
    //
    if ( !IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_OPT_SHELL, INI_VAL_WBOM_NO) )
    {
        // Zero out the memory
        //
        ZeroMemory(&mStatus, sizeof(mStatus));

        // Fill in required values
        //
        mStatus.dwLength = sizeof(mStatus);

        // Determine the default value for shell optimization
        //
        if ( GlobalMemoryStatusEx(&mStatus) )
        {
            // Determine if the amount of memory on the system is enough
            //
            if ( (mStatus.ullTotalPhys / (1024 * 1024)) >= MIN_MEMORY )
            {
                dwSetting = 1;
            }

            // Set the value based on the memory
            //
            bRet = RegSetDword(HKLM, REG_KEY_FASTUSERS, REG_VAL_MULTISES, dwSetting);
        }
        else
        {
            // There was an error retrieving the memory status
            //
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL DisplayOptimizeShell(LPSTATEDATA lpStateData)
{
    return ( !IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_OPT_SHELL, INI_VAL_WBOM_NO) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\slpfiles.c ===
/****************************************************************************\

    SLPFILES.C / Factory Mode (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file for Factory that contains the update SLP files state
    functions.

    07/2001 - Jason Cohen (JCOHEN)

        Added this new source file for factory for updating the SLP files and
        reinstalling the catalog file.

\****************************************************************************/


//
// Include File(s):
//

#include "factoryp.h"


//
// Internal Define(s):
//

#define REG_KEY_WINLOGON    _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define REG_VAL_DLLCACHE    _T("SFCDllCacheDir")

#define DIR_SYSTEM          _T("system32")
#define DIR_DLLCACHE        _T("dllcache")


//
// Internal Global(s):
//

static LPTSTR s_lpszSlpFiles[] =
{
    _T("OEMBIOS.CAT"),  // Catalog file needs to be the first in the list.
    _T("OEMBIOS.BIN"),
    _T("OEMBIOS.DAT"),
    _T("OEMBIOS.SIG"),
};


//
// Internal Function Prototype(s):
//

static void GetDestFolder(LPTSTR lpszDest, DWORD cbDest, BOOL bDllCache);
static BOOL CopySlpFile(LPTSTR lpszSrc, LPTSTR lpszDst);


//
// External Function(s):
//

BOOL SlpFiles(LPSTATEDATA lpStateData)
{
    BOOL    bRet = TRUE;
#if 0
    DWORD   dwErr;
    TCHAR   szSrcFile[MAX_PATH];
    LPTSTR  lpszSourcePath;

    if ( lpszSourcePath = IniGetExpand(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_SLPSOURCE, NULL) )
    {
        // Should support getting the files from the network.
        //
        FactoryNetworkConnect(lpszSourcePath, lpStateData->lpszWinBOMPath, NULL, TRUE);

        // The source should point to a directory that contains all the SLP files.
        //
        if ( DirectoryExists(lpszSourcePath) )
        {
            LPTSTR  lpszEndSrc;
            DWORD   x;

            // Copy the root source folder into our buffer.
            //
            lstrcpyn(szSrcFile, lpszSourcePath, AS(szSrcFile));
            lpszEndSrc = szSrcFile + lstrlen(szSrcFile);

            // Make sure all the files are in the folder as well.
            //
            for ( x = 0; x < AS(s_lpszSlpFiles); x++ )
            {
                // Setup the full path to this slp file.
                //
                AddPathN(szSrcFile, s_lpszSlpFiles[x], AS(szSrcFile));

                // Make sure this slp file exists.
                //
                if ( !FileExists(szSrcFile) )
                {
                    // NEEDLOG: Log that this file doesn't exist.
                    //
                    bRet = FALSE;
                }

                // Don't leave the file name on there for the next guy.
                //
                *lpszEndSrc = NULLCHR;
            }

            // If there were no errors, lets try to update the files.
            //
            if ( bRet )
            {
                // Call the syssetup function to update the catalog before
                // we copy any of the files (the catalog is always the first file).
                //
                AddPathN(szSrcFile, s_lpszSlpFiles[0], AS(szSrcFile));
                if ( NO_ERROR == (dwErr = SetupInstallCatalog(szSrcFile)) )
                {
                    TCHAR   szDstCache[MAX_PATH],
                            szDstSystem[MAX_PATH];
                    LPTSTR  lpszEndCache,
                            lpszEndSystem;

                    // Setup the destination folders.
                    //
                    GetDestFolder(szDstCache, AS(szDstCache), TRUE);
                    GetDestFolder(szDstSystem, AS(szDstSystem), FALSE);
                    lpszEndCache = szDstCache + lstrlen(szDstCache);
                    lpszEndSystem = szDstSystem + lstrlen(szDstSystem);

                    // Now copy all the files.
                    //
                    for ( x = 0; x < AS(s_lpszSlpFiles); x++ )
                    {
                        // First create the path to the source first (it stil has
                        // the previous file on it, so chop it off first).
                        //
                        *lpszEndSrc = NULLCHR;
                        AddPathN(szSrcFile, s_lpszSlpFiles[x], AS(szSrcFile));

                        // Now copy it to the dll cache folder.
                        //
                        AddPathN(szDstCache, s_lpszSlpFiles[x], AS(szDstCache));
                        if ( !CopySlpFile(szSrcFile, szDstCache) )
                        {
                            // No need to log, the copy function will do that for us.
                            //
                            bRet = FALSE;
                        }
                        *lpszEndCache = NULLCHR;

                        // The cat file (which is the first one) does not get copied
                        // to the system32 folder.
                        //
                        if ( x )
                        {
                            // Now copy it to the system folder.
                            //
                            AddPathN(szDstSystem, s_lpszSlpFiles[x], AS(szDstSystem));
                            if ( !CopySlpFile(szSrcFile, szDstSystem) )
                            {
                                // No need to log, the copy function will do that for us.
                                //
                                bRet = FALSE;
                            }
                            *lpszEndSystem = NULLCHR;
                        }
                    }
                }
                else
                {
                    // NEEDLOG: Log that the catalog could not be installed (error code is in dwErr).
                    //
                    bRet = FALSE;
                }
            }
        }
        else
        {
            // NEEDLOG: Log that the directory doesn't exist.
            //
            bRet = FALSE;
        }

        // Remove the network connection if we made one.
        //
        FactoryNetworkConnect(lpszSourcePath, lpStateData->lpszWinBOMPath, NULL, FALSE);

        // Free up the key read from the ini file.
        //
        FREE(lpszSourcePath);
    }
    else
    {
        // If the key isn't present, we still want to reinstall the cat file
        // in case they replaced the SLP files offline.
        //
        GetDestFolder(szSrcFile, AS(szSrcFile), TRUE);
        AddPathN(szSrcFile, s_lpszSlpFiles[0], AS(szSrcFile));
        if ( ( FileExists(szSrcFile) ) &&
             ( NO_ERROR != (dwErr = SetupInstallCatalog(szSrcFile)) ) )
        {
            // NEEDLOG: Log that the catalog could not be installed (error code is in dwErr).
            //
            bRet = FALSE;
        }
    }
#endif

    return bRet;
}

BOOL DisplaySlpFiles(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_SLPSOURCE, NULL);
}


//
// Internal Function(s):
//

static void GetDestFolder(LPTSTR lpszDest, DWORD cbDest, BOOL bDllCache)
{
    LPTSTR lpszData;

    // See if we want the dll cache folder, and check the registry key if we do.
    //
    if ( ( bDllCache ) &&
         ( lpszData = RegGetExpand(HKLM, REG_KEY_WINLOGON, REG_VAL_DLLCACHE) ) )
    {
        // Return the registry key.
        //
        lstrcpyn(lpszDest, lpszData, cbDest);
        FREE(lpszData);
    }
    else
    {
        // Get the main system directory and tack on the dll cache folder.
        //
        GetSystemWindowsDirectory(lpszDest, cbDest);
        AddPathN(lpszDest, DIR_SYSTEM, cbDest);
        if ( bDllCache )
        {
            AddPathN(lpszDest, DIR_DLLCACHE, cbDest);
        }
    }
}

static BOOL CopySlpFile(LPTSTR lpszSrc, LPTSTR lpszDst)
{
    BOOL bRet = TRUE;

    // We make sure the source and destination are not the
    // same because the OEM might do something crazy like put
    // them in the dllcache folder.
    //
    if ( ( 0 != lstrcmpi(lpszSrc, lpszDst) ) &&
         ( !CopyFile(lpszSrc, lpszDst, FALSE) ) )
    {
        // NEEDLOG: Log the file that fails.
        //
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#define IDS_APPTITLE                    101
#define IDS_APPNAME                     102
#define IDI_FACTORYPRE                  105
#define IDS_MSG_FILESEXIST              107
#define IDS_ERR_NOTFIXED                108
#define IDS_ERR_NOFORMAT                109
#define IDS_ERR_FORMATFAILED            110
#define IDS_ERR_COPYFILE                111
#define IDS_ERR_NO_SHARE_NAME           113
#define IDS_ERR_SETUP                   114
#define IDS_ERR_NOT_WINPE               115
#define IDS_ERR_SET_OEMDATA             116
#define IDS_SUCCESS_OEMDATA             117
#define IDS_LINK_AND_TARGET             118
#define IDS_ERR_BAD_LINK                119
#define IDS_ERR_VERSION_IE              120
#define IDS_ERR_VERSION_SHELL           121
#define IDS_ERR_SHELL_COUNT             122
#define IDS_SHORTCUT_INFO               123
#define IDS_TARGET_INFO                 124
#define IDS_SHELL_DEL_VALUES            125
#define IDS_ERR_SPECIALFOLDER           126
#define IDS_IE_DEL_VALUES               127
#define IDS_ERR_MISSINGWINBOM           128
#define IDS_LOG_WINBOMLOCATION          129
#define IDS_PROMPT_IMAGE                130
#define IDD_RUN                         132
#define IDS_PROC_APPSECTION             132
#define IDI_SETUP                       133
#define IDD_SHUTDOWN                    134
#define IDS_SHUTDOWN_TURNOFF            135
#define IDS_SHUTDOWN_REBOOT             136
#define IDS_SHUTDOWN_SHUTDOWN           137
#define IDS_SHUTDOWN_NOTHING            138
#define IDS_ERR_UNDEFINSTALL            139
#define IDS_ERR_NOSOURCE                140
#define IDS_ERR_NOSETUPFILE             141
#define IDS_ERR_IGNORECMDLINE           142
#define IDS_ERR_NOTARGETPATH            144
#define IDS_ERR_NOSOURCETARGET          145
#define IDS_ERR_STAGEFAILED             146
#define IDS_ERR_DETACHFAILED            147
#define IDS_ERR_ATTACHFAILED            148
#define IDS_MSI_FAILURE                 149
#define IDS_ERR_INITMSIATTACH           150
#define IDS_ERR_STAGESUCCESS            151
#define IDS_ERR_ATTACHSUCCESS           152
#define IDS_ERR_DETACHSUCCESS           153
#define IDS_ERR_UNDEFTECH               154
#define IDS_REBOOT_FRIENDLY             155
#define IDS_ERR_NOSTAGESETUPFILE        156
#define IDS_ERR_NOSTAGEPATH             157
#define IDS_ERR_NOSECTIONNAME           158
#define IDS_ERR_OUTOFDRIVELETTERS       159
#define IDS_ERR_INVALIDCMDLINE          160
#define IDS_ERR_WRITEPIPE               161
#define IDS_ERR_CANTAUTHSERVER          162
#define IDS_ERR_NOSOURCEORTARGET        163
#define IDS_ERR_FAILEDCOPYDIR           164
#define IDS_ERR_FAILEDCOPYFILE          165
#define IDS_ERR_MISSINGVAR              167
#define IDS_ERR_CREATEPROCESS           168
#define IDS_ERR_CREATESTDIN             169
#define IDS_ERR_CREATESTDOUT            170
#define IDS_ERR_DISKCFGENTRY            171
#define IDS_ERR_FILEFOUNDONC            172
#define IDS_ERR_NETWORKCOMP             173
#define IDS_ERR_REGISTERNETCFG          174
#define IDS_ERR_NETSERVICES             175
#define IDS_ERR_SCM                     176
#define IDS_ERR_SETUPNETWORK            177
#define IDS_ERR_INVALIDIP               178
#define IDS_ERR_INVALIDMASK             179
#define IDS_ERR_NOMASK                  180
#define IDS_ERR_IPREGISTRY              181
#define IDS_ERR_INVALIDGW               182
#define IDS_ERR_GWREGISTRY              183
#define IDS_LOG_STARTINGSTATE           184
#define IDS_LOG_FINISHINGSTATE          185
#define IDS_STATE_SETDISPLAY            186
#define IDS_ERR_FINISHINGSTATE          187
#define IDS_STATE_COMPUTERNAME          188
#define IDS_STATE_UPDATEDRIVERS         189
#define IDS_STATE_INSTALLDRIVERS        190
#define IDS_STATE_NORMALPNP             191
#define IDS_STATE_SETPOWEROPTIONS       192
#define IDS_STATE_AUTOLOGON             193
#define IDS_STATE_USERIDENT             194
#define IDS_STATE_INFINSTALL            195
#define IDS_STATE_OEMRUNONCE            196
#define IDS_STATE_OEMRUN                197
#define IDS_STATE_STARTMENUMFU          198
#define IDS_STATE_OEMFOLDER             199
#define IDS_STATE_RESEAL                200
#define IDS_STATE_WINPENET              201
#define IDS_STATE_PARTITIONFORMAT       202
#define IDS_STATE_COPYFILES             203
#define IDS_STATE_WINPEREBOOT           204
#define IDS_STATE_SETUPNETWORK          205
#define IDS_LOG_STATEPERF               206
#define IDS_STATE_LOGON                 207
#define IDS_ERR_PNPSIGNALEVENT          208
#define IDS_ERR_PNPWAITFINISH           209
#define IDS_ERR_PNPFINISHEVENT          210
#define IDS_ERR_PNPSTARTEVENT           211
#define IDS_STATE_WAITPNP               212
#define IDS_LOG_APPEXITCODE             213
#define IDS_LOG_APPEXITCODENONE         214
#define IDI_STATUSERROR                 215
#define IDI_STATUSSUCCESS               216
#define IDS_APPTITLE_OEMRUN             217
#define IDS_ERR_CREATEPROCESSSUCCESS    218
#define IDS_ERR_CREATEPROCESSFAILED     219
#define IDS_STATE_SETFONTOPTIONS        220
#define IDS_ERR_WINBOMVALUE             221
#define IDS_STATE_HOMENET               222
#define IDS_STATUS_DESC                 223
#define IDC_STATUS_ICON                 224
#define IDS_LOG_NOSYSPREP               224
#define IDS_ERR_SHUTDNREQREGVAL         225
#define IDS_ERR_OPENSETUPREGKEY         226
#define IDS_LOG_NONET                   228
#define IDS_LOG_FORCEDNETSCAN           229
#define IDS_ERR_FAILEDNETDRIVER         230
#define IDS_ERR_NTPOWERINFO             232
#define IDS_ERR_SETPWRSCHEME            233
#define IDS_ERR_FLOPPYNOTFOUND          234
#define IDS_ERR_CDROMNOTFOUND           235
#define IDS_ERR_NETCONNECT              236
#define IDS_ERR_DSTBAD                  237
#define IDS_ERR_SRCBAD                  238
#define IDS_ERR_DRVCOPYFAILED           239
#define IDS_WRN_NETDISCONNECT           240
#define IDS_ERR_UPDATEDEVICEPATH        241
#define IDS_ERR_MEMORY                  242
#define IDS_STATE_RESETSOURCE           243
#define IDS_STATE_EXTENDPART            244
#define IDS_STATE_TESTCERT              245
#define IDS_ERR_NOTESTCERT              246
#define IDS_ERR_ADDTESTCERT             247
#define IDS_STATE_SHELLSETTINGS         248
#define IDS_LOG_STARTPANEL_ENABLE       249
#define IDS_LOG_STARTPANEL_DISABLE      250
#define IDS_ERR_THEME_APPLY             251
#define IDS_ERR_THEME_OPEN              252
#define IDS_ERR_THEME_NODEFAULT         253
#define IDS_ERR_THEME_DISABLE           254
#define IDS_LOG_THEME_ALREADYDISABLED   255
#define IDS_ERR_COMINIT                 256
#define IDS_LOG_THEME_CHANGED           257
#define IDS_LOG_THEME_DISABLED          258
#define IDS_LOG_THEME_ALREADYENABLED    259
#define IDS_ERR_THEME_MISSING           260
#define IDS_LOG_STARTPANEL_ALREADYENABLED 261
#define IDS_LOG_STARTPANEL_ALREADYDISABLED 262
#define IDS_STATE_OPTSHELL              263
#define IDS_ERR_THEME_CONFLICT_ON       264
#define IDS_ERR_THEME_CONFLICT_OFF      265
#define IDS_STATE_CREATEPAGEFILE        266
#define IDS_ERR_PAGEFILE                267
#define IDS_ERR_SERVICE                 268
#define IDS_ADMIN                       269
#define IDS_OWNER                       270
#define IDS_STATE_OCMGR                 271
#define IDS_MSN_EXPLORER                272
#define IDS_GET_ONLINE_MSN              273
#define IDS_WORKGROUP                   274
#define IDS_STATE_SETDEFAULTAPPS        275
#define IDS_ERR_SETDEFAULTS_NOTFOUND    276
#define IDS_ERR_NOT_ALLOWED             277
#define IDC_TITLE                       1000
#define IDC_SSHUTDOWN                   1001
#define IDC_SHUTDOWN                    1010
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        249
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\srcpath.c ===
/****************************************************************************\

    SRCPATH.C / Factory Mode (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file for Factory that contains the reset source path state
    functions.

    05/2001 - Jason Cohen (JCOHEN)

        Added this new source file for factory for configuring the source path
        in the registry.

\****************************************************************************/


//
// Include File(s):
//

#include "factoryp.h"


//
// Internal Define(s):
//

#define FILE_DOSNET_INF         _T("dosnet.inf")
#define DIR_I386                _T("i386")
#define DIR_IA64                _T("ia64")

#define INI_SEC_DIRS            _T("Directories")
#define INI_KEY_DIR             _T("d%d")
#define NUM_FIRST_SOURCE_DX     1


//
// Internal Function Prototypes:
//

static BOOL MoveSourceFiles(LPTSTR lpszSrc, LPTSTR lpszDst, LPTSTR lpszInfFile, BOOL bCheckOnly);


//
// External Function(s):
//

BOOL ResetSource(LPSTATEDATA lpStateData)
{
    BOOL    bRet = TRUE;
    LPTSTR  lpszSourcePath;

    if ( lpszSourcePath = IniGetExpand(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_RESETSOURCE, NULL) )
    {
        TCHAR   szPath[MAX_PATH]    = NULLSTR,
                szSrcPath[MAX_PATH];
        LPTSTR  lpszDirName         = NULL,
                lpszCabs            = GET_FLAG(g_dwFactoryFlags, FLAG_IA64_MODE) ? DIR_IA64 : DIR_I386,
                lpszEnd;

        //
        // The source path needs to point to the folder that has the i386 directory in it,
        // so lets do some checking and make sure they knew this when they specified the key.
        //

        // First make sure there is no trailing backslash (even if it is the root folder).
        //
        if ( _T('\\') == *(lpszEnd = CharPrev(lpszSourcePath, lpszSourcePath + lstrlen(lpszSourcePath))) )
        {
            *lpszEnd = NULLCHR;
        }

        // Now get the full path and a pointer to the last folder name.
        //
        GetFullPathName(lpszSourcePath, AS(szPath), szPath, &lpszDirName);
        if ( szPath[0] && lpszDirName )
        {
            // See if the directory name is i386/ia64.
            //
            lpszEnd = szPath + lstrlen(szPath);
            if ( lstrcmpi(lpszDirName, lpszCabs) == 0 )
            {
                // Double check that there actually isn't an i386\i386 / ia64\ia64 folder.
                //
                AddPathN(szPath, lpszCabs, AS(szPath));
                if ( !DirectoryExists(szPath) )
                {
                    // Remove the i386/ia64 because they should not have specified it.
                    //
                    *CharPrev(szPath, lpszDirName) = NULLCHR;
                }
                else
                {
                    // The i386\i386 / ia64\ia64 folder really does exist, so put the path
                    // back the way it was and use it.
                    //
                    *lpszEnd = NULLCHR;
                }
            }
            else if ( DirectoryExists(szPath) )
            {
                // Lets double check that they didn't put the i386/ia64 files in a folder
                // with another name.
                //
                AddPathN(szPath, FILE_DOSNET_INF, AS(szPath));
                if ( FileExists(szPath) )
                {
                    // Well this is kind of bad.  We can either log an error warning them that
                    // this really won't work, or we could automatically rename the folder.  The
                    // only possible problem would be on ia64 if they didn't also have the i386 folder.
                    // But maybe that isn't really that big of a deal, so I think that I might just rename
                    // the folder.
                    //
                    *lpszEnd = NULLCHR;
                    lstrcpyn(szSrcPath, szPath, AS(szSrcPath));
                    lstrcpyn(lpszDirName, lpszCabs, AS(szPath) - (int) (lpszDirName - szPath));

                    // ISSUE-2002/02/26-acosma,robertko - There is no check for success here and this code is really confusing! 
                    // Where are we moving to?
                    //
                    MoveFile(szSrcPath, szPath);
                }
                else
                {
                    // If the source doesn't exist there, then maybe they haven't copied it yet.  So we
                    // will just have to assume that they know what they are doing and put the path back
                    // the way we got it.
                    //
                    *lpszEnd = NULLCHR;
                }
            }
        }


        //
        // Now set the path in the registry.
        //

        bRet = UpdateSourcePath(szPath[0] ? szPath : lpszSourcePath);
        
        // Don't need this guy anymore.
        //
        FREE(lpszSourcePath);


        //
        // Now see if we have the sources in the root of the drive, which is where we put
        // them on a default config set install.
        //

        // We can check to see if we need to move the sources from the root if we have a 
        // full path (that is more than just the root) so we know what drive to check the
        // root of (which must be a fixed drive).
        //
        lstrcpyn(szSrcPath, szPath, 4);
        if ( ( lstrlen(szPath) > 3 ) && 
             ( _T(':') == szPath[1] ) &&
             ( GetDriveType(szSrcPath) == DRIVE_FIXED ) )
        {
            TCHAR szDosNetInf[MAX_PATH];

            // Now use that source and the i386/ia64 folder to find the dos net inf
            // file.
            //
            lstrcpyn(szDosNetInf, szSrcPath, AS(szDosNetInf));
            AddPathN(szDosNetInf, lpszCabs, AS(szDosNetInf));
            AddPathN(szDosNetInf, FILE_DOSNET_INF, AS(szDosNetInf));
        
            //
            // If it is all good, go ahead and move the sources.
            //
            if ( !MoveSourceFiles(szSrcPath, szPath, szDosNetInf, FALSE) )
            {
                // We should log an error here, but we can do it for the
                // next release.
                //
                // ISSUE-2002/02/25-acosma,robertko - Should we really set this to false to fail the state if something 
                // went wrong during the copy? Or we just go on like nothing ever happened?
                //
                //bRet = FALSE;
            }
        }
    }

    return bRet;
}

BOOL DisplayResetSource(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_RESETSOURCE, NULL);
}


//
// Internal Function(s):
//

static BOOL MoveSourceFiles(LPTSTR lpszSrc, LPTSTR lpszDst, LPTSTR lpszInfFile, BOOL bCheckOnly)
{
    TCHAR   szInf[MAX_PATH],
            szSrc[MAX_PATH],
            szDst[MAX_PATH];
    LPTSTR  lpszEndSrc,
            lpszEndDst;
    DWORD   dwLoop      = NUM_FIRST_SOURCE_DX;
    BOOL    bRet        = FALSE,
            bMore;
    TCHAR   szDirKey[32],
            szDir[MAX_PATH];

    // We have to have the dos net file.
    //
    if ( !FileExists(lpszInfFile) )
    {
        return FALSE;
    }

    // Make our local copies of the inf, source, and destination buffers.
    //
    lstrcpyn(szInf, lpszInfFile, AS(szInf));
    lstrcpyn(szSrc, lpszSrc, AS(szSrc));
    lstrcpyn(szDst, lpszDst, AS(szDst));
    lpszEndSrc = szSrc + lstrlen(szSrc);
    lpszEndDst = szDst + lstrlen(szDst);

    // Loop through all the directories listed in the dos net file.
    //
    do
    {
        // Create the key we want to look for in the inf file.
        //
        if ( FAILED ( StringCchPrintf ( szDirKey, AS ( szDirKey ), INI_KEY_DIR, dwLoop++) ) )
        {
            FacLogFileStr(3, _T("StringCchPrintf failed %s %d" ), szDirKey, dwLoop );
        }

        // Now see if that key exists.
        //
        szDir[0] = NULLCHR;
        if ( bMore = ( GetPrivateProfileString(INI_SEC_DIRS, szDirKey, NULLSTR, szDir, AS(szDir), szInf) && szDir[0] ) )
        {
            // If we copy at least one folder, then return TRUE by default.
            //
            bRet = TRUE;

            // We may need to reset our root destination and source paths.
            //
            *lpszEndSrc = NULLCHR;
            *lpszEndDst = NULLCHR;

            // Now setup the destination and source paths.
            //
            AddPathN(szSrc, szDir, AS(szSrc));
            AddPathN(szDst, szDir, AS(szDst));

            // Move the directory (or see if it can be moved), if it fails we
            // should error and bail.
            //
            if ( bCheckOnly )
            {
                // If we are just checking, then make sure the destination
                // directory doesn't already exist.
                //
                bRet = bMore = ( DirectoryExists(szSrc) && !DirectoryExists(szDst) );
            }
            else
            {
                // If parent directory does not exists then we must create it, otherwise the MoveFile will fail
                //
                if ( !DirectoryExists(lpszDst) )
                {
                    CreatePath(lpszDst);
                }

                // If the move failed, stop.
                //
                bRet = bMore = MoveFile(szSrc, szDst);

                // We might have moved the inf file.
                //
                if ( bRet )
                {
                    int iLen = lstrlen(szSrc);

                    if ( CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szSrc, iLen, szInf, iLen) == CSTR_EQUAL )
                    {
                        TCHAR szInfName[MAX_PATH];

                        lstrcpyn(szInfName, szInf + iLen, AS(szInfName));
                        lstrcpyn(szInf, szDst, AS(szInf));
                        AddPathN(szInf, szInfName, AS(szInf));
                    }
                }
            }
        }
    }
    while ( bMore );

    // Return if it is okay to copy (if check only is set) or if there was an error.
    //
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\status.h ===
//
// Type Definition(s):
//
typedef struct _STATUSNODE
{
    TCHAR       szStatusText[MAX_PATH];
    HWND        hLabelWin;
    HWND        hIconWin;
    struct  _STATUSNODE*lpNext;
} STATUSNODE, *LPSTATUSNODE, **LPLPSTATUSNODE;

typedef struct _STATUSWINDOW
{
    TCHAR           szWindowText[MAX_PATH];
    LPTSTR          lpszDescription;
    int             X;
    int             Y;
    HICON           hMainIcon;
    BOOL            bShowIcons;
} STATUSWINDOW, *LPSTATUSWINDOW, **LPLPSTATUSWINDOW;

//
// Function Prototype(s):
//

// Main function that creates Status dialog
//
HWND StatusCreateDialog(
    LPSTATUSWINDOW lpswStatus,  // structure that contains information about the window
    LPSTATUSNODE lpsnStatus     // head node for status text
);

// Increments the Status dialog, if the status is incremented past the last item, the dialog will end
//
BOOL StatusIncrement(
    HWND hStatusDialog, // handle to status dialog
    BOOL bLastResult
);

// Manually ends the dialog
//
BOOL StatusEndDialog(
    HWND hStatusDialog  // handle to status dialog
);

// Adds a text string to the end of a list
//
BOOL StatusAddNode(
    LPTSTR lpszNodeText,    // Text that you would like to add to the current list
    LPLPSTATUSNODE lpsnHead     // List that we will be adding status node to
);

// Deletes all the Nodes in a given list
//
VOID StatusDeleteNodes(
    LPSTATUSNODE lpsnHead
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\states.h ===
/****************************************************************************\

    STATES.H / Factory Mode (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Header file that contains all the states Factory uses.

    05/2001 - Jason Cohen (JCOHEN)

        Added this new header file for factory.  Moved states from WINBOM.C
        and now these are included in FACTORY.C.

        Adding in OOBE states at this time as well.

\****************************************************************************/


//
// Global Variable(s):
//

STATES g_FactoryStates[] =
{
    // This must always be the first state.
    //
    { stateStart,           NULL,               NEVER,                  0,                          FLAG_STATE_NONE                             },

    // All these following states happen before the logon.
    //

    // ISSUE-2002/02/26-acosma - Remove this state.  It doesn't do anything.  Calling some very empty functions.
    //
    { stateSlpFiles,        SlpFiles,           NEVER,                  0,                          FLAG_STATE_ONETIME                          },
    { stateExtendPart,      ExtendPart,         DisplayExtendPart,      IDS_STATE_EXTENDPART,       FLAG_STATE_ONETIME                          },
    { stateResetSource,     ResetSource,        DisplayResetSource,     IDS_STATE_RESETSOURCE,      FLAG_STATE_ONETIME                          },
    { stateTestCert,        TestCert,           DisplayTestCert,        IDS_STATE_TESTCERT,         FLAG_STATE_ONETIME                          },
    { stateComputerName,    ComputerName,       DisplayComputerName,    IDS_STATE_COMPUTERNAME,     FLAG_STATE_ONETIME                          },
    { stateUpdateDrivers,   UpdateDrivers,      DisplayUpdateDrivers,   IDS_STATE_UPDATEDRIVERS,    FLAG_STATE_ONETIME                          },
    { stateNormalPnP,       NormalPnP,          ALWAYS,                 IDS_STATE_NORMALPNP,        FLAG_STATE_NONE                             },
    { stateSetDisplay,      SetDisplay,         ALWAYS,                 IDS_STATE_SETDISPLAY,       FLAG_STATE_NONE                             },
    { stateShellSettings,   ShellSettings,      DisplayShellSettings,   IDS_STATE_SHELLSETTINGS,    FLAG_STATE_ONETIME                          },
    { stateAutoLogon,       AutoLogon,          DisplayAutoLogon,       IDS_STATE_AUTOLOGON,        FLAG_STATE_NONE                             },

    // This must be the first state after logon.
    //
    { stateLogon,           NULL,               ALWAYS,                 IDS_STATE_LOGON,            FLAG_STATE_NONE                             },

    // All these following states happen after the logon.
    //
    { stateWaitPnP2,        WaitPnP,            DisplayWaitPnP,         IDS_STATE_WAITPNP,          FLAG_STATE_NONE                             },
    { stateInstallDrivers,  InstallDrivers,     DisplayInstallDrivers,  IDS_STATE_INSTALLDRIVERS,   FLAG_STATE_ONETIME                          },
    { stateSetDisplay2,     SetDisplay,         NEVER,                  IDS_STATE_SETDISPLAY,       FLAG_STATE_ONETIME                          },
    { stateOptShell,        OptimizeShell,      DisplayOptimizeShell,   IDS_STATE_OPTSHELL,         FLAG_STATE_NONE                             },
    { stateSetFontOptions,  SetFontOptions,     DisplaySetFontOptions,  IDS_STATE_SETFONTOPTIONS,   FLAG_STATE_ONETIME                          },
    { stateShellSettings2,  ShellSettings2,     DisplayShellSettings,   IDS_STATE_SHELLSETTINGS,    FLAG_STATE_ONETIME                          },
    { stateSetPowerOptions, SetPowerOptions,    DisplaySetPowerOptions, IDS_STATE_SETPOWEROPTIONS,  FLAG_STATE_ONETIME                          },
    { stateHomeNet,         HomeNet,            DisplayHomeNet,         IDS_STATE_HOMENET,          FLAG_STATE_ONETIME                          },
    { stateUserIdent,       UserIdent,          DisplayUserIdent,       IDS_STATE_USERIDENT,        FLAG_STATE_ONETIME | FLAG_STATE_NOTONSERVER },
    { stateInfInstall,      InfInstall,         DisplayInfInstall,      IDS_STATE_INFINSTALL,       FLAG_STATE_ONETIME                          },
    { statePidPopulate,     PidPopulate,        NEVER,                  0,                          FLAG_STATE_ONETIME                          },
    { stateOCManager,       OCManager,          DisplayOCManager,       IDS_STATE_OCMGR,            FLAG_STATE_ONETIME                          },
    { stateOemRunOnce,      OemRunOnce,         DisplayOemRunOnce,      IDS_STATE_OEMRUNONCE,       FLAG_STATE_NONE                             },
    { stateStartMenuMFU,    StartMenuMFU,       DisplayStartMenuMFU,    IDS_STATE_STARTMENUMFU,     FLAG_STATE_ONETIME                          },
    { stateSetDefaultApps,  SetDefaultApps,     ALWAYS,                 IDS_STATE_SETDEFAULTAPPS,   FLAG_STATE_NOTONSERVER                      },
    { stateOemData,         OemData,            DisplayOemData,         IDS_STATE_OEMFOLDER,        FLAG_STATE_ONETIME                          },
    { stateOemRun,          OemRun,             DisplayOemRun,          IDS_STATE_OEMRUN,           FLAG_STATE_NONE                             },
    { stateWaitPnP,         WaitPnP,            DisplayWaitPnP,         IDS_STATE_WAITPNP,          FLAG_STATE_NONE                             },
    { stateReseal,          Reseal,             DisplayReseal,          IDS_STATE_RESEAL,           FLAG_STATE_NONE                             },

    // This must be the last state.
    //
    { stateFinish,          NULL,               NEVER,                  0,                          FLAG_STATE_NONE                             },
};

STATES g_MiniNtStates[] =
{
    // This must always be the first state.
    //
    { stateStart,           NULL,               NEVER,                  0,                          FLAG_STATE_NONE                             },

    { stateSetDisplay,      SetDisplay,         ALWAYS,                 IDS_STATE_SETDISPLAY,       FLAG_STATE_NONE                             },
    { statePartitionFormat, PartitionFormat,    DisplayPartitionFormat, IDS_STATE_PARTITIONFORMAT,  FLAG_STATE_NONE                             },
    { stateCreatePageFile,  CreatePageFile,     DisplayCreatePageFile,  IDS_STATE_CREATEPAGEFILE,   FLAG_STATE_NONE                             },
    { stateWinpeNet,        WinpeNet,           DisplayWinpeNet,        IDS_STATE_WINPENET,         FLAG_STATE_NONE                             },
    { stateOemRunOnce,      OemRunOnce,         DisplayOemRunOnce,      IDS_STATE_OEMRUNONCE,       FLAG_STATE_NONE                             },
    { stateOemRun,          OemRun,             DisplayOemRun,          IDS_STATE_OEMRUN,           FLAG_STATE_NONE                             },
    { stateCopyFiles,       CopyFiles,          DisplayCopyFiles,       IDS_STATE_COPYFILES,        FLAG_STATE_NONE                             },
    { stateInfInstall,      InfInstall,         DisplayInfInstall,      IDS_STATE_INFINSTALL,       FLAG_STATE_NONE                             },
    { stateWinpeReboot,     WinpeReboot,        ALWAYS,                 IDS_STATE_WINPEREBOOT,      FLAG_STATE_NONE                             },
    
    // This must be the last state.
    //
    { stateFinish,          NULL,               NEVER,                  0,                          FLAG_STATE_NONE                             },
};

STATES g_OobeStates[] =
{
    // This must always be the first state.
    //
    { stateStart,           NULL,               NEVER,                  0,                          FLAG_STATE_NONE                             },

    { stateExtendPart,      ExtendPart,         NEVER,                  IDS_STATE_EXTENDPART,       FLAG_STATE_ONETIME                          },
    { stateResetSource,     ResetSource,        NEVER,                  IDS_STATE_RESETSOURCE,      FLAG_STATE_ONETIME                          },
    { stateTestCert,        TestCert,           NEVER,                  IDS_STATE_TESTCERT,         FLAG_STATE_ONETIME                          },
    { stateInstallDrivers,  InstallDrivers,     NEVER,                  IDS_STATE_INSTALLDRIVERS,   FLAG_STATE_ONETIME                          },
    { stateSetDisplay,      SetDisplay,         NEVER,                  IDS_STATE_SETDISPLAY,       FLAG_STATE_ONETIME                          },
    { stateOptShell,        OptimizeShell,      NEVER,                  IDS_STATE_OPTSHELL,         FLAG_STATE_NONE                             },
    { stateShellSettings,   ShellSettings,      NEVER,                  IDS_STATE_SHELLSETTINGS,    FLAG_STATE_ONETIME                          },
    { stateSetPowerOptions, SetPowerOptions,    NEVER,                  IDS_STATE_SETPOWEROPTIONS,  FLAG_STATE_ONETIME                          },
    { statePidPopulate,     PidPopulate,        NEVER,                  0,                          FLAG_STATE_ONETIME                          },
    { stateOCManager,       OCManager,          NEVER,                  IDS_STATE_OCMGR,            FLAG_STATE_ONETIME                          },
    
    // This must be the last state.
    //
    { stateFinish,          NULL,               NEVER,                  0,                          FLAG_STATE_NONE                             },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\startmenumfu.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    startmenumfu.c

Abstract:

    Migrate usage date for apps to be pre-populated in startpanel MFU list using data from
    WINBOM.INI file.

    Also sets default middleware applications for ARP's "Restore computer
    manufacturer configuration" button.

Author:

    Sankar Ramasubramanian  11/21/2000

Revision History:

--*/
#include "factoryp.h"
#include <shlobj.h>

#define MAX_OEM_LINKS_ALLOWED    4

//The following are defined in OPKWIZ also!
#define INI_KEY_MFULINK         _T("Link%d")
#define INI_SEC_MFULIST         _T("StartMenuMFUlist")

// The following are defined in explorer also!
#define REGSTR_PATH_DEFAULTMFU _T("Software\\Microsoft\\Windows\\CurrentVersion\\SMDEn")

//The possible values under REGSTR_PATH_MFU
#define VAL_LINKMSFT        _T("Link%d")
#define VAL_LINKOEM         _T("OEM%d")

//Value under REGSTR_PATH_EXPLORER\Advanced
#define VAL_STARTMENUINIT   _T("StartMenuInit")

//
// This function processes the OEM MFU section of the WinBOM.INI file and adds those entries into 
// the REGSTR_PATH_DEFAULTMFU database in HKLM.  Explorer's per-user install will consult
// this list to determine the correct MFU to show each user the first time they log on.
//
// Furthermore, for some reason, per-user install does NOT run if you preset
// the profiles with factory.exe, so we need to set a flag for Explorer so
// it can "undo" all the gunk the factory left behind so each user gets a
// fresh start.

BOOL StartMenuMFU(LPSTATEDATA lpStateData)
{
    LPTSTR  lpszWinBOMPath = lpStateData->lpszWinBOMPath;
    int     iIndex;
    TCHAR   szIniKeyName[20];
    TCHAR   szRegKeyName[20];
    TCHAR   szPath[MAX_PATH];
    TCHAR   szExpanded[MAX_PATH];

    // For each OEM entry, copy it to HKLM
    for(iIndex = 0; iIndex < MAX_OEM_LINKS_ALLOWED; iIndex++)
    {
        if ( FAILED ( StringCchPrintf ( szIniKeyName, AS ( szIniKeyName ), INI_KEY_MFULINK, iIndex) ) )
        {
            FacLogFileStr(3, _T("StringCchPrintf failed %s %d" ), szIniKeyName, iIndex );
        }
        if ( FAILED ( StringCchPrintf ( szRegKeyName, AS ( szRegKeyName ), VAL_LINKOEM, iIndex) ) )
        {
            FacLogFileStr(3, _T("StringCchPrintf failed %s %d"), szRegKeyName, iIndex ) ;
        }
        if (GetPrivateProfileString(INI_SEC_MFULIST, szIniKeyName, NULLSTR, szExpanded, ARRAYSIZE(szExpanded), lpszWinBOMPath))
        {
            if (!PathUnExpandEnvStrings(szExpanded, szPath, STRSIZE(szPath)))
            {
                lstrcpyn(szPath, szExpanded, STRSIZE(szPath));
            }

            SHSetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_DEFAULTMFU, szRegKeyName, REG_EXPAND_SZ, szPath, (lstrlen(szPath) + 1) * sizeof(TCHAR));
        }
    }

    // Now clear the "I have built the initial MFU" flag since we want it to
    // rebuild the next time each user logs on.
    SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER _T("\\Advanced"),
                  VAL_STARTMENUINIT);

    // And tell the Start Menu to show off the new MFU
    NotifyStartMenu(TMFACTORY_MFU);

    return TRUE;
}

BOOL DisplayStartMenuMFU(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_MFULIST, NULL, NULL);
}

/***************************************************************************
 *
 *  Setting default middleware applications
 *
 *  We do it here here merely to give the OEM a warm fuzzy feeling.
 *  The "official" setting of default middleware applications happens
 *  in sysprep during reseal.
 *
 ***************************************************************************/

void ReportSetDefaultOEMAppsError(LPCTSTR pszAppName, LPCTSTR pszIniVar)
{
    FacLogFile(0 | LOG_ERR, IDS_ERR_SETDEFAULTS_NOTFOUND, pszAppName, pszIniVar);
}

BOOL SetDefaultApps(LPSTATEDATA lpStateData)
{
    return SetDefaultOEMApps(lpStateData->lpszWinBOMPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\testcert.c ===
/****************************************************************************\

    TESTCERT.C / Factory Mode (FACTORY.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file for Factory that contains the test certificate state
    functions.

    05/2001 - Jason Cohen (JCOHEN)

        Added this new source file for factory for install a test
        certificate.

\****************************************************************************/


//
// Include File(s):
//

#include "factoryp.h"


//
// External Function(s):
//

BOOL TestCert(LPSTATEDATA lpStateData)
{
    BOOL    bRet = TRUE;
    DWORD   dwErr;
    LPTSTR  lpszIniVal;
    TCHAR   szTestCert[MAX_PATH];

    if ( lpszIniVal = IniGetString(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_TESTCERT, NULL) )
    {
        ExpandFullPath(lpszIniVal, szTestCert, AS(szTestCert));

        if ( szTestCert[0] && FileExists(szTestCert) )
        {
            if ( NO_ERROR != (dwErr = SetupAddOrRemoveTestCertificate(szTestCert, INVALID_HANDLE_VALUE)) )
            {
                FacLogFile(0 | LOG_ERR, IDS_ERR_ADDTESTCERT, szTestCert, dwErr);
                bRet = FALSE;
            }
        }
        else
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_NOTESTCERT, szTestCert);
            bRet = FALSE;
        }
        FREE(lpszIniVal);
    }

    return bRet;
}

BOOL DisplayTestCert(LPSTATEDATA lpStateData)
{
    return IniSettingExists(lpStateData->lpszWinBOMPath, INI_SEC_WBOM_SETTINGS, INI_KEY_WBOM_TESTCERT, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\status.c ===
// **************************************************************************
//
// Status.C
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1999-2001
//  All rights reserved
//
//  This application implements a common status dialog for factory functions.
//
//  04/01/2001   Stephen Lodwick
//                  Project started
//
//
// *************************************************************************/

//
// Includes
//
#include "factoryp.h"


typedef struct _STATUSWINDOWS
{
    HWND            hStatusWindow;
    LPSTATUSNODE    lpCurrent;
    struct  _STATUSWINDOWS*lpNext;
} STATUSWINDOWS, *LPSTATUSWINDOWS, **LPLPSTATUSWINDOWS;

typedef struct _DIALOGPARAM
{
    LPSTATUSWINDOW lpswParam;
    LPSTATUSNODE   lpsnParam;
    HWND           hStatusWindow;
    HANDLE         hEvent;
} DIALOGPARAM, *LPDIALOGPARAM, **LPLPDIALOGPARAM;

//
// Internal Function Prototype(s):
//
LRESULT CALLBACK StatusDlgProc(HWND, UINT, WPARAM, LPARAM);
DWORD   StatusDisplayList(HWND, LPSTATUSNODE);
BOOL    StatusAddWindow(HWND, LPLPSTATUSWINDOWS, LPSTATUSNODE, BOOL);
VOID    StatusCreateDialogThread(LPDIALOGPARAM);

//
// Internal Define(s):
//
#define FIRST_SPACING   7   // Spacing (pixel) between the title and the first app
#define LINE_SPACING    7   // Spacing (pixel) between additional applcations

#define WM_FINISHED     (WM_USER + 0x0001)  // User defined message to indicate the dialog should be destroyed
#define WM_PROGRESS     (WM_USER + 0x0002)  // User defined message to indicate that we are progressing to the next app


/*++

Routine:
    StatusAddNode

Routine Description:

    This routine takes a string and adds that string onto the end of our
    linked list.

Arguments:

    lpszNodeText - Pointer to string of text that you would like to add to list
    lplpsnHead   - Pointer to a LPSTATUSNODE list

Return Value:

    TRUE  - Node was added to list
    FALSE - If the Node was not added to list

--*/
BOOL StatusAddNode(
    LPTSTR lpszNodeText,        // Text that you would like to add to the current list
    LPLPSTATUSNODE lplpsnHead   // List that we will be adding status node to
)
{
    LPSTATUSNODE   lpsnTemp = NULL;
    
    if ( lpszNodeText && *lpszNodeText == NULLCHR )
        return FALSE;

    // Go to the end of the list
    //
    while ( lplpsnHead && *lplpsnHead )
        lplpsnHead=&((*lplpsnHead)->lpNext);
    
    if  ( (lpsnTemp = (LPSTATUSNODE)MALLOC(sizeof(STATUSNODE)) ) && lpszNodeText ) 
    {
        lstrcpyn(lpsnTemp->szStatusText, lpszNodeText, AS( lpsnTemp->szStatusText ) );
        lpsnTemp->lpNext = NULL;

        // Make sure the previous node points to the new node
        //
        if ( lplpsnHead ) 
            *lplpsnHead = lpsnTemp;

        return TRUE;
    }
    else
        return FALSE;
}


/*++

Routine:
    StatusIncrement

Routine Description:

    This routine increments the status to the next node in the list

Arguments:

    hStatusDialog - Handle of the StatusDialog
    bLastResult   - Result of the last node (whether it succeeded or failed)

Return Value:

    TRUE  - Message sent to status dialog
    FALSE - Message was not sent to status dialog

--*/
BOOL StatusIncrement(
    HWND hStatusDialog,
    BOOL bLastResult
)
{
    // We must have a valid handle to the status dialog
    //
    if ( IsWindow(hStatusDialog) )
    {   
        // Send a message to the dialog proc to go to the next caption
        //
        SendMessage(hStatusDialog, WM_PROGRESS,(WPARAM) NULL,(LPARAM) bLastResult);
        return TRUE;
    }

    return FALSE;
}

/*++

Routine:
    StatusEndDialog

Routine Description:

    This routine sends a message to a status dialog to end.

Arguments:

    hStatusDialog - Handle of the StatusDialog

Return Value:

    TRUE  - Message sent to status dialog
    FALSE - Message was not sent to status dialog

--*/
BOOL StatusEndDialog(
    HWND hStatusDialog  // handle to status dialog
)
{
    // We must have a valid handle to the status dialog
    //
    if ( IsWindow(hStatusDialog) )
    {
        // Send a message to the dialog proc to end the dialog
        //
        SendMessage(hStatusDialog, WM_FINISHED,(WPARAM) NULL,(LPARAM) NULL);
        return TRUE;
    }

    return FALSE;
}

/*++

Routine:
    StatusCreateDialogThread

Routine Description:

    This routine creates the dialog for the status window and processes until the window is ended.

Arguments:

    lpDialog - Pointer to structure that contains information to create thread/dialog

Return Value:

    None.

--*/
VOID StatusCreateDialogThread(LPDIALOGPARAM lpDialog)
{
    MSG     msg;
    HWND    hWnd;
    HANDLE  hEvent = lpDialog->hEvent;
    
    hWnd = CreateDialogParam(g_hInstance, MAKEINTRESOURCE(IDD_RUN), NULL, StatusDlgProc, (LPARAM) lpDialog);

    while (GetMessage(&msg, hWnd, 0, 0) != 0) 
    { 
        TranslateMessage(&msg); 
        DispatchMessage(&msg); 
    } 
   
    // Event has not been been signaled, null out the hwnd and signal event
    //
    if ( WaitForSingleObject(hEvent, 0) == WAIT_TIMEOUT )
    {
        // Reset the status window handle to null, and set the event
        //
        lpDialog->hStatusWindow = NULL;
        SetEvent(lpDialog->hEvent);
    }
    else
    {
        // Close the event handle
        //
        CloseHandle(hEvent);
    }
}


/*++

Routine:
    StatusCreateDialog

Routine Description:

    Main function that creates the status dialog

Arguments:

    lpswStatus - Pointer to structure that contains information about Status Window
    lpsnStatus - Pointer to struction that contains head node for status labels

Return Value:

    HWND - Handle to window that was created, NULL if window was not created.

--*/
HWND StatusCreateDialog(
    LPSTATUSWINDOW lpswStatus,  // structure that contains information about the window
    LPSTATUSNODE   lpsnStatus   // head node for status text
)
{
    DIALOGPARAM dpStatus;
    DWORD       dwThread;
    HANDLE      hThread;
    HANDLE      hEvent;

    // Determine if we have the required structures to continue, an hInstance, and some status text
    //
    if ( !lpswStatus || !lpsnStatus || !lpsnStatus->szStatusText[0])
        return NULL;

    // Zero out memory
    //
    ZeroMemory(&dpStatus, sizeof(dpStatus));

    // Create an event, non-signaled to determine if dialog is initialized
    //
    if ( hEvent = CreateEvent(NULL, TRUE, FALSE, NULL) )
    {
        // Need a single variable for the dialog box parameter
        //
        dpStatus.lpswParam      = lpswStatus;
        dpStatus.lpsnParam      = lpsnStatus;
        dpStatus.hStatusWindow  = NULL;
        dpStatus.hEvent         = hEvent;


        // Create the thread to initialize the dialog
        //
        if (hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) StatusCreateDialogThread, (LPVOID) &dpStatus, 0, &dwThread) )
        {
            MSG msg;

            // Wait for the event from WM_INITDIALOG
            //
            WaitForSingleObject(hEvent, INFINITE);

            // Close the handle to the thread
            //
            CloseHandle(hThread);
        }
        
        // Reset and close the event only if we failed to create window, otherwise, StatusCreateDialogThread will close handle
        //
        if ( !dpStatus.hStatusWindow )
            CloseHandle(hEvent);
    }

    // Return the handle to the StatusDialog
    //
    return ( dpStatus.hStatusWindow );
}


/*++

Routine:
    StatusDlgProc

Routine Description:

    Main dialog procedure for StatusCreateDialog.

Arguments:

    hWnd    - Handle to window
    uMsg    - Message being sent to window
    uParam  - Upper parameter being sent
    lParam  - Lower parameter being sent

Return Value:

    LRESULT - Result of message that was processed

--*/
LRESULT CALLBACK StatusDlgProc(HWND hWnd, UINT uMsg, WPARAM uParam, LPARAM lParam)
{
    static HFONT hNormFont      = NULL;
    static HFONT hBoldFont      = NULL;
    static HANDLE hIconSuccess  = NULL;
    static HANDLE hIconError    = NULL;
    static LPSTATUSWINDOWS lpStatusWindows;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            {
                LPSTATUSWINDOW  lpswWindow = NULL;
                LPSTATUSNODE    lpHead     = NULL,
                                lpWindowHead = NULL;
                HANDLE          hEvent     = NULL;

                if ( lParam )
                {
                    // Determine the window, and current node
                    //
                    lpswWindow = ((LPDIALOGPARAM)lParam)->lpswParam;
                    lpHead = ((LPDIALOGPARAM)lParam)->lpsnParam;
                    hEvent = ((LPDIALOGPARAM)lParam)->hEvent;

                    // Check to make sure that we have pointers to the required structures
                    //
                    if ( !lpswWindow || !lpHead || !hEvent)
                    {
                        PostMessage(hWnd, WM_FINISHED,(WPARAM) NULL,(LPARAM) NULL);
                        return FALSE;
                    }

                    // Copy the list that was passed in, to our own buffer
                    //
                    while ( lpHead )
                    {
                        StatusAddNode(lpHead->szStatusText, &lpWindowHead);
                        lpHead = lpHead->lpNext;
                    }

                    // Add this window to our list of windows
                    //
                    StatusAddWindow(hWnd, &lpStatusWindows, lpWindowHead, FALSE);

                    // Set the status window if there is one specified
                    //
                    if (lpswWindow->szWindowText[0] )
                        SetWindowText(hWnd, lpswWindow->szWindowText);

                    // Set the status window description if there is one specified.
                    //
                    if ( lpswWindow->lpszDescription )
                    {
                        SetDlgItemText(hWnd, IDC_TITLE, lpswWindow->lpszDescription);
                    }

                    // Set the status window description if there is one specified.
                    //
                    if ( lpswWindow->hMainIcon )
                    {
                        SendDlgItemMessage(hWnd, IDC_STATUS_ICON, STM_SETICON, (WPARAM) lpswWindow->hMainIcon, 0L);
                    }
                
                    // Display the list
                    //
                    StatusDisplayList(hWnd, lpWindowHead);

                    // Move the window if a position was given
                    //
                    if ( lpswWindow->X || lpswWindow->Y )
                    {
                        // See if either coordinate is relative to the other
                        // side of the screen.
                        //
                        if ( ( lpswWindow->X < 0 ) || 
                             ( lpswWindow->Y < 0 ) )
                        {
                            RECT rc;

                            // Need to get the size of our work area on the main monitor.
                            //
                            if ( SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0) )
                            {
                                RECT    rcHwnd;
                                POINT   point;

                                // This code will get the current window size/position,
                                // set the point structure to the upper left coordinate
                                // for the window if we wanted the lower right part of
                                // window to touch the lower right part of the desktop.
                                //
                                GetWindowRect(hWnd, &rcHwnd);
                                point.x = rc.right - (rcHwnd.right - rcHwnd.left);
                                point.y = rc.bottom - (rcHwnd.bottom - rcHwnd.top);
                                MapWindowPoints(NULL, hWnd, &point, 1);

                                // Now if they passed in negative coordinates, add those
                                // to our point structure so the window moves away from
                                // the bottom or right part of the screen by the number
                                // of units they specifed.
                                //
                                if ( lpswWindow->X < 0 )
                                {
                                    lpswWindow->X += point.x;
                                }
                                if ( lpswWindow->Y < 0 )
                                {
                                    lpswWindow->Y += point.y;
                                }
                            }
                        }

                        // Now move the window.
                        //
                        SetWindowPos(hWnd, 0, lpswWindow->X, lpswWindow->Y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
                    }

                    // Build the new fonts
                    //
                    if(!hNormFont)
                        hNormFont = GetFont((HWND) GetDlgItem(hWnd, IDC_TITLE), NULL, 0, FW_NORMAL, FALSE);

                    if(!hBoldFont)
                        hBoldFont = GetFont((HWND) GetDlgItem(hWnd, IDC_TITLE), NULL, 0, FW_BOLD, FALSE);

                    // Bold the first item in the list
                    //
                    if ( lpWindowHead && hBoldFont)
                        SendMessage((HWND)lpWindowHead->hLabelWin, WM_SETFONT, (WPARAM) hBoldFont, MAKELPARAM(TRUE, 0));

                    // Now make sure we show the window now.
                    //
                    ShowWindow(hWnd, SW_SHOW);

                    ((LPDIALOGPARAM)lParam)->hStatusWindow = hWnd;

                    // Set event stating that dialog is initialized
                    //
                    SetEvent(hEvent);
                }
                else
                    PostMessage(hWnd, WM_FINISHED,(WPARAM) NULL,(LPARAM) NULL);
            }
            break;

        case WM_PROGRESS:
            {
                // Progress to the next item, if there are no items, end the dialog
                //
                LPSTATUSWINDOWS lpswNext = lpStatusWindows;
                BOOL            bFound   = FALSE;
                LPSTATUSNODE    lpsnTemp = NULL;


                // Locate the current node given a window handle
                //
                while ( lpswNext && !bFound)
                {
                    if ( lpswNext->hStatusWindow == hWnd )
                        bFound = TRUE;
                    else
                        lpswNext = lpswNext->lpNext;
                }

                // If there is a current node, lets unbold it, increment and bold the next item
                //
                if ( bFound && lpswNext && lpswNext->lpCurrent )
                {
                    if ( hNormFont )
                        SendMessage((HWND)lpswNext->lpCurrent->hLabelWin, WM_SETFONT, (WPARAM) hNormFont, MAKELPARAM(TRUE, 0));

                    if ( !hIconSuccess )
                        hIconSuccess = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_STATUSSUCCESS), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);

                    if ( !hIconError )
                        hIconError = LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_STATUSERROR), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
                    
                    if ( hIconSuccess && hIconError )
                        SendMessage(lpswNext->lpCurrent->hIconWin,STM_SETIMAGE, (WPARAM)IMAGE_ICON, (BOOL)lParam ? (LPARAM)hIconSuccess : (LPARAM)hIconError );

                    // Increment to the next node in the list
                    //
                    lpsnTemp = lpswNext->lpCurrent;
                    lpswNext->lpCurrent = lpswNext->lpCurrent->lpNext;

                    // Free this memory since we allocated it
                    //
                    FREE(lpsnTemp);

                    // If there is not a current node, end the dialog, otherwise, bold the item
                    //
                    if ( lpswNext->lpCurrent && hBoldFont)
                        SendMessage(lpswNext->lpCurrent->hLabelWin, WM_SETFONT, (WPARAM) hBoldFont, MAKELPARAM(TRUE, 0));    
                }
            }
            break;
        case WM_FINISHED:
            {
                // Destroy the dialog
                //
                if ( hWnd )
                {
                    // If there are status windows, let's remove the one that we are ending
                    //
                    if ( lpStatusWindows )
                        StatusAddWindow(hWnd, &lpStatusWindows, NULL, TRUE);

                    // Check to see if there are any windows left, if not, do some clean up
                    //
                    if ( !lpStatusWindows )
                    {
                        // Delete fonts static to dlgproc
                        //
                        if (hNormFont)
                        {
                            DeleteObject(hNormFont);
                            hNormFont = NULL;
                        }
            
                        if (hBoldFont)
                        {
                            DeleteObject(hBoldFont);
                            hBoldFont = NULL;
                        }
                    }


                    // Quit and end the dialog
                    //
                    EndDialog(hWnd, 1);
                }

                return FALSE;
            }
            break;
        default:
            return FALSE;
    }

    return FALSE;
}


/*++

Routine:
    StatusDisplayList

Routine Description:

    Function that displays list to user interface

Arguments:

    hWnd     - Handle to Status window
    lpsnList - List to head Status Node

Return Value:

    DWORD - Number of entries that were added to the dialog

--*/
DWORD StatusDisplayList(HWND hWnd, LPSTATUSNODE lpsnList)
{
    LPSTATUSNODE    lpsnTempList = lpsnList;
    HWND            hWndLabel,
                    hWndIcon;
    RECT            Rect,
                    WindowRect;
    POINT           Point;
    DWORD           dwEntries = 0;
    HFONT           hNormFont = NULL;
    LPTSTR          lpTempRunName;
    HDC             hdc;
    SIZE            size = { 0, 0 };
    LONG            nWidestControl;

    GetWindowRect(GetDlgItem(hWnd, IDC_TITLE), &Rect);

    Rect.right -= Rect.left;    // The width of the control.
    Rect.bottom -= Rect.top;    // The height of the control.

    Point.x = Rect.left;
    Point.y = Rect.top;

    nWidestControl = Rect.right;

    MapWindowPoints(NULL, hWnd, &Point, 1);

    Point.y += FIRST_SPACING;

    while(lpsnTempList)
    {

        // Calculate the point of the first label window
        //
        Point.y += Rect.bottom + LINE_SPACING;

        // Get the size of the text in pixels
        //
        if (hdc = GetWindowDC(hWnd))
        {
            GetTextExtentPoint32(hdc, lpsnTempList->szStatusText, lstrlen(lpsnTempList->szStatusText), &size);

            if (size.cx > nWidestControl)
                nWidestControl = size.cx;

            ReleaseDC(hWnd, hdc);
        }

        // Create the label window
        //
        hWndIcon = CreateWindow(_T("STATIC"), _T(""), WS_CHILD | WS_VISIBLE | SS_ICON | SS_CENTERIMAGE, Point.x - 16, Point.y - 2, 16, 16, hWnd, NULL, g_hInstance, NULL);
        hWndLabel = CreateWindow(_T("STATIC"), _T(""), WS_CHILD | WS_VISIBLE | SS_CENTERIMAGE, Point.x, Point.y, (Rect.right > size.cx ? Rect.right : size.cx) , Rect.bottom, hWnd, NULL, g_hInstance, NULL);

        // If the font is NULL, get a font
        //
        if ( hNormFont == NULL )
            hNormFont = (HFONT) SendDlgItemMessage(hWnd, IDC_TITLE, WM_GETFONT, 0, 0L);

        // Set the font to the same font as the title
        //
        SendMessage(hWndLabel, WM_SETFONT, (WPARAM) hNormFont, MAKELPARAM(FALSE, 0));

        // Set the Window text to the name of the program
        //
        SetWindowText(hWndLabel, lpsnTempList->szStatusText);

        // Set the hWndTemp (created from CreateWindow) in the list
        //
        lpsnTempList->hLabelWin = hWndLabel;
        lpsnTempList->hIconWin = hWndIcon;

        // Goto the next item in the list
        //
        lpsnTempList = lpsnTempList->lpNext;

        // Increment for each of the applications in the list
        //
        dwEntries++;
    }

    GetWindowRect(hWnd, &WindowRect);

    WindowRect.right = WindowRect.right - WindowRect.left + nWidestControl - Rect.right;    // The width of the winodw.
    WindowRect.bottom -= WindowRect.top;    // The height of the window.

    // Resize the dialog to fit the label text.
    //
    SetWindowPos(hWnd, 0, 0, 0, WindowRect.right, WindowRect.bottom + ((Rect.bottom + LINE_SPACING)*dwEntries), SWP_NOMOVE | SWP_SHOWWINDOW | SWP_NOZORDER );

    return dwEntries;
}


/*++
===============================================================================
Routine Description:

    StatusAddWindow
    
    Adds a new window to the list.  This function is used internally for the status
    dialog.

Arguments:

    hStatusWindow - Handle to Status Window
    lplpswHead    - Head of the Windows list
    lpsnHead      - Current head node for Status Window
    bRemove       - Indicates wheter we add or remove the window from the list
    
Return Value:

    None

===============================================================================
--*/
BOOL StatusAddWindow(
    HWND hStatusWindow,             // Text that you would like to add to the current list
    LPLPSTATUSWINDOWS lplpswHead,   // List that we will be adding status window to
    LPSTATUSNODE lpsnHead,          // Head of the STATUSNODE structure
    BOOL bRemove                    // Indicates if we are removing the window from our list
)
{
    LPLPSTATUSWINDOWS   lplpswNext = lplpswHead;
    LPSTATUSWINDOWS     lpswTemp = NULL;
    LPSTATUSNODE        lpsnTemp = NULL;
    BOOL                bFound   = FALSE;

    // If there is no status window we have nothing to add
    //
    if ( !hStatusWindow )
        return FALSE;

    // Attempt to find the window passed in, if not, we are at the end of the list
    //
    while ( *lplpswNext && !bFound)
    {
        if ( (*lplpswNext)->hStatusWindow == hStatusWindow )
            bFound = TRUE;
        else
            lplpswNext=&((*lplpswNext)->lpNext);

    }

    // If we are adding it and we didn't find it in the list go ahead an add the new node
    //
    if ( !bRemove && !bFound)
    {
        
        if ( lpswTemp = (LPSTATUSWINDOWS)MALLOC(sizeof(STATUSWINDOWS)) )
        {
            lpswTemp->hStatusWindow = hStatusWindow;
            lpswTemp->lpNext = NULL;
            lpswTemp->lpCurrent = lpsnHead;

            // Make sure the previous node points to the new node
            //
            *lplpswNext = lpswTemp;
        }
        else
            return FALSE;
    }
    else if ( bRemove && bFound && *lplpswNext)
    {
        // If there are nodes left in for the window, lets clean them up
        //
        if ( (*lplpswNext)->lpCurrent )
            StatusDeleteNodes((*lplpswNext)->lpCurrent);

        // Free the window node
        //
        lpswTemp = (*lplpswNext);
        (*lplpswNext) = (*lplpswNext)->lpNext;
        FREE(lpswTemp);
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}


/*++
===============================================================================
Routine Description:

    VOID StatusDeleteNodes
    
    Deletes all the Nodes in a STATUSNODE list

Arguments:

    lpsnHead - current head of the list
    
Return Value:

    None

===============================================================================
--*/
VOID StatusDeleteNodes(
    LPSTATUSNODE lpsnHead
)
{
    LPSTATUSNODE lpsnTemp = NULL;

    while ( lpsnHead )
    {
        lpsnTemp = lpsnHead;
        lpsnHead = lpsnHead->lpNext;
        FREE(lpsnTemp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\winbom.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    winbom.c

Abstract:

    Process the WinBOM (Windows Bill-of-Materials) file during OEM/SB pre-installation.
    
    Task performed will be:
        Download updated device drivers from NET
        Process OOBE info
        Process User/Customer specific settings
        Process OEM user specific customization
        Process Application pre-installations
    

Author:

    Donald McNamara (donaldm) 2/8/2000

Revision History:

    - Added preinstall support to ProcessWinBOM: Jason Lawrence (t-jasonl) 6/7/2000

--*/
#include "factoryp.h"


//
// Defined Value(s):
//

// Time out in milliseconds to wait for the dialog thread to finish.
//
#define DIALOG_WAIT_TIMEOUT     2000


//
// Internal Function Prototype(s):
//

static BOOL SetRunKey(BOOL bSet, LPDWORD lpdwTickCount);


/*++
===============================================================================
Routine Description:

    BOOL ProcessWinBOM
    
    This routine will process all sections of the WinBOM

Arguments:

    lpszWinBOMPath  -   Buffer containing the fully qualified path to the WINBOM
                        file
    lpStates        -   Array of states that will be processed.
    cbStates        -   Number of states in the states array.
    
Return Value:

    TRUE if no errors were encountered
    FALSE if there was an error

===============================================================================
--*/

BOOL ProcessWinBOM(LPTSTR lpszWinBOMPath, LPSTATES lpStates, DWORD cbStates)
{
    STATE           stateCurrent,
                    stateStart      = stateUnknown;
    LPSTATES        lpState;
    STATEDATA       stateData;
    BOOL            bQuit,
                    bErr            = FALSE,
                    bLoggedOn       = GET_FLAG(g_dwFactoryFlags, FLAG_LOGGEDON),
                    bServer         = IsServer(),
                    bPerf           = GET_FLAG(g_dwFactoryFlags, FLAG_LOG_PERF),
                    bStatus         = !GET_FLAG(g_dwFactoryFlags, FLAG_NOUI),
                    bInit;
    HKEY            hKey;
    HWND            hwndStatus      = NULL;
    DWORD           dwForReal,
                    dwStates,
                    dwStatus        = 0;
    LPSTATUSNODE    lpsnTemp        = NULL;

    // Get the current state from the registry.
    //
    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_FACTORY_STATE, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS )
    {
        DWORD   dwType  = REG_DWORD,
                dwValue = 0,
                cbValue = sizeof(DWORD);

        if ( RegQueryValueEx(hKey, _T("CurrentState"), NULL, &dwType, (LPBYTE) &dwValue, &cbValue) == ERROR_SUCCESS )
        {
            stateStart = (STATE) dwValue;
        }
    
        RegCloseKey(hKey);
    }

    // Set the static state data.
    //
    stateData.lpszWinBOMPath = lpszWinBOMPath;

    // We loop through the states twice.  The first time is just
    // a quick run through to see what states to add to the status
    // dialog.  The second time is the "real" time when we actually
    // run each state.
    //
    for ( dwForReal = 0; dwForReal < 2; dwForReal++ )
    {
        // Reset these guys every time.
        //
        bInit           = TRUE;
        bQuit           = FALSE,
        dwStates        = cbStates;
        lpState         = lpStates;
        stateCurrent    = stateStart;

        // If this is the real thing we need to handle the status dialog stuff.
        //
        if ( dwForReal )
        {
            // Create the dialog if we want to display the UI.
            //
            if ( bStatus && dwStatus )
            {
                STATUSWINDOW swAppList;

                // Start by zeroing out the structure.
                //
                ZeroMemory(&swAppList, sizeof(swAppList));

                // Now copy the title into the structure.
                //
                if ( swAppList.lpszDescription = AllocateString(NULL, IDS_APPTITLE) )
                {
                    lstrcpyn(swAppList.szWindowText, swAppList.lpszDescription, AS(swAppList.szWindowText));
                    FREE(swAppList.lpszDescription);
                }

                // Get the description string.
                //
                swAppList.lpszDescription = AllocateString(NULL, IDS_STATUS_DESC);

                // Load the main icon for the status window.
                //
                swAppList.hMainIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_FACTORYPRE));

                // Set the screen cordinates for the status window.
                //
                swAppList.X = -10;
                swAppList.Y = 10;

                // Now actually create the status window.
                //
                hwndStatus = StatusCreateDialog(&swAppList, lpsnTemp);

                // Clean up any allocated memory.
                //
                FREE(swAppList.lpszDescription);
            }

            // Delete the node list as we don't need it anymore
            // because the status window is already displayed.
            //
            if ( lpsnTemp )
            {
                StatusDeleteNodes(lpsnTemp);
            }
        }

        // Process WINBOM states, until we reach the finished state.
        //
        do
        {
            // Set or advance to the next state.
            //
            if ( bInit )
            {
                // Now if we are logged on, we need to advance to that state.
                //
                if ( bLoggedOn )
                {
                    while ( dwStates && ( lpState->state != stateLogon ) )
                    {
                        lpState++;
                        dwStates--;
                    }
                }

                // If we don't know the current state, set it to the first one.
                //
                if ( stateCurrent == stateUnknown )
                {
                    stateCurrent = lpState->state;
                }

                // Make sure we don't do the init code again.
                //
                bInit = FALSE;
            }
            else
            {
                if ( stateCurrent == lpState->state )
                {
                    // Advance and save the current state.
                    //
                    stateCurrent = (++lpState)->state;

                    // Set the current state in the registry (only if doing this for real).
                    //
                    if ( dwForReal && ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_FACTORY_STATE, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS ) )
                    {
                        RegSetValueEx(hKey, _T("CurrentState"), 0, REG_DWORD, (LPBYTE) &stateCurrent, sizeof(DWORD));
                        RegCloseKey(hKey);
                    }
                }
                else
                {
                    // Just advanced to the next state.
                    //
                    lpState++;
                }
            }

            // Decrement our size counter to make sure we don't go past
            // the end of our array.
            //
            dwStates--;

            // Only execute this state if it isn't a one time only state or
            // our current state is the same one we are about to execute.
            //
            // Also don't execute this state if we are running on server and
            // it should not be.
            //
            if ( ( !GET_FLAG(lpState->dwFlags, FLAG_STATE_ONETIME) || ( stateCurrent == lpState->state ) ) &&
                 ( !GET_FLAG(lpState->dwFlags, FLAG_STATE_NOTONSERVER) || ( !bServer ) ) )
            {
                // First reset any state data in the structure
                // that might be left over from a previous state call.
                //
                stateData.state = lpState->state;
                stateData.bQuit = FALSE;

                // If this is for real, then do the state stuff.
                //
                if ( dwForReal )
                {
                    LPTSTR  lpStateText;
                    BOOL    bStateErr       = FALSE,
                            bSwitchCode     = TRUE;
                    DWORD   dwTickStart     = 0,
                            dwTickFinish    = 0;

                    // Get the friendly name for the state if there is one.
                    //
                    lpStateText = lpState->nFriendlyName ? AllocateString(NULL, lpState->nFriendlyName) : NULL;

                    // Log that we are starting this state (special case the log on case becase
                    // we don't want to log that we are starting it twice.
                    //
                    if ( ( lpStateText ) && 
                         ( !bLoggedOn || ( stateLogon != lpState->state ) ) )
                    {
                        FacLogFile(2, IDS_LOG_STARTINGSTATE, lpStateText);
                    }

                    // Get the starting tick count.
                    //
                    dwTickStart = GetTickCount();

                    // See if the state has a function.
                    //
                    if ( lpState->statefunc )
                    {                
                        // Run the state function.
                        //
                        bStateErr = !lpState->statefunc(&stateData);

                        // Get the finish tick count.
                        //
                        dwTickFinish = GetTickCount();
                    }

                    // Jump to the code for this state if there is one.  We should avoid
                    // putting code here.  For now just the logon and finish states are
                    // in the switch statement because they are very simple and crucial
                    // to how the state loop works.  All the other states just do some
                    // work that we don't care about or need to have any knowledge of.
                    //
                    switch ( lpState->state )
                    {
                        case stateLogon:

                            // If we haven't logged on yet, we need to quit when we get to this state.
                            //
                            if ( !bLoggedOn )
                            {
                                // Set the run key so we get kicked off again after we log on.
                                //
                                bStateErr = !SetRunKey(TRUE, &dwTickStart);
                                bQuit = TRUE;

                                // Don't want to log the perf yet, so set these to FALSE and zero.
                                //
                                bSwitchCode = FALSE;
                                dwTickFinish = 0;
                            }
                            else
                            {
                                // Clear the run keys and get the original tick count.
                                //
                                if ( ( bStateErr = !SetRunKey(FALSE, &dwTickStart) ) &&
                                     ( 0 == dwTickStart ) )
                                {
                                    // If for some reason we were not able to get the tick count
                                    // from the registry, just set these to FALSE and zero so
                                    // we don't try to log the perf.
                                    //
                                    bSwitchCode = FALSE;
                                    dwTickFinish = 0;
                                }
                            }
                            break;

                        case stateFinish:

                            // Nothing should ever really go in the finished state.  We just
                            // set bQuit to true so we exit out.
                            //
                            bQuit = TRUE;
                            break;

                        default:
                            bSwitchCode = FALSE;
                    }

                    // Check if code in the switch statement was run.
                    //
                    if ( bSwitchCode )
                    {
                        // Get the finish tick count again.
                        //
                        dwTickFinish = GetTickCount();
                    }

                    // Log that we are finished with this state.
                    //
                    if ( lpStateText )
                    {
                        // Write out that we have finished this state (unless this is the
                        // first time for the logon state, we don't want to log that it finished
                        // twice unless there is an error the first time).
                        //
                        if ( bStateErr )
                        {
                            FacLogFile(0 | LOG_ERR, IDS_ERR_FINISHINGSTATE, lpStateText);
                        }
                        else if ( bLoggedOn || ( stateLogon != lpState->state ) )
                        {
                            FacLogFile(2, IDS_LOG_FINISHINGSTATE, lpStateText);
                        }

                        // See if we actually ran any code.
                        //
                        if ( dwTickFinish && bPerf )
                        {
                            // Calculate the difference in milleseconds.
                            //
                            if ( dwTickFinish >= dwTickStart )
                            {
                                dwTickFinish -= dwTickStart;
                            }
                            else
                            {
                                dwTickFinish += ( 0xFFFFFFFF - dwTickStart );
                            }

                            // Write out to the log the time this state took.
                            //
                            FacLogFile(0, IDS_LOG_STATEPERF, lpStateText, dwTickFinish / 1000, dwTickFinish - ((dwTickFinish / 1000) * 1000));
                        }

                        // Free the friendly name.
                        //
                        FREE(lpStateText);
                    }

                    // If there is status text, we should increment past it.
                    //
                    if ( hwndStatus && GET_FLAG(lpState->dwFlags, FLAG_STATE_DISPLAYED) )
                    {
                        StatusIncrement(hwndStatus, !bStateErr);
                    }

                    // Check to see if the state failed.
                    //
                    if ( bStateErr )
                    {
                        // State function failed, set the error var and see if we need
                        // to quit proccessing states.
                        //
                        bErr = TRUE;
                        if ( GET_FLAG(lpState->dwFlags, FLAG_STATE_QUITONERR) ||
                             GET_FLAG(g_dwFactoryFlags, FLAG_STOP_ON_ERROR) )
                        {
                            bQuit = TRUE;
                        }
                    }
                }
                else
                {
                    // Always reset the displayed flag first.
                    //
                    RESET_FLAG(lpState->dwFlags, FLAG_STATE_DISPLAYED);

                    // Only need to do more if we want to display the UI.
                    //
                    if ( bStatus )
                    {
                        LPTSTR lpszDisplay;

                        // Only if there is a friendly name can we display it.
                        //
                        if ( lpState->nFriendlyName && ( lpszDisplay = AllocateString(NULL, lpState->nFriendlyName) ) )
                        {
                            BOOL bDisplay;

                            // First use the state display function (if there is one) to figure out
                            // if this item is to be displayed or not.
                            //
                            // The function can set bQuit in the state structure just like when it actually
                            // runs.  We will catch this below and make this the last item in the list.
                            //
                            bDisplay = lpState->displayfunc ? lpState->displayfunc(&stateData) : FALSE;

                            // Jump to the display code for this state to see if it is really displayed
                            // or should be the last item in the list.  We should avoid putting code
                            // here.  For now just the logon and finish states are in the switch
                            // statement because they are very simple and crucial to how the state
                            // loop works for the display dialog.  All the other states make their own
                            // determination if they should be displayed or not.
                            //
                            switch ( lpState->state )
                            {
                                case stateLogon:

                                    // If we haven't logged on yet, we need to quit when we get to this state.
                                    //
                                    if ( !bLoggedOn )
                                    {
                                        // Set the quit so this is the last item listed before logon.
                                        //
                                        bQuit = TRUE;
                                    }
                                    else
                                    {
                                        // Not going to show this state after logon, only before.  We can change
                                        // this if we think we should show it as the first item after logon, but
                                        // it doesn't really matter.
                                        //
                                        bDisplay = FALSE;
                                    }
                                    break;

                                case stateFinish:

                                    // We just set the quit so we make sure and exit out.
                                    //
                                    bQuit = TRUE;
                                    break;
                            }

                            // Now check to see if we really want to display this state.
                            //
                            if ( bDisplay )
                            {
                                StatusAddNode(lpszDisplay, &lpsnTemp);
                                SET_FLAG(lpState->dwFlags, FLAG_STATE_DISPLAYED);
                                dwStatus++;
                            }

                            // Free the friendly name.
                            //
                            FREE(lpszDisplay);
                        }
                    }
                }

                // If they want to quit, set bQuit.
                //
                if ( stateData.bQuit )
                {
                    bQuit = TRUE;
                }
            }
        }
        while ( !bQuit && dwStates );
    }

    // If we created the status window, end it now.
    //
    if ( hwndStatus )
    {
        StatusEndDialog(hwndStatus);
    }

    return !bErr;
}

BOOL DisplayAlways(LPSTATEDATA lpStateData)
{
    return TRUE;
}

static BOOL SetRunKey(BOOL bSet, LPDWORD lpdwTickCount)
{
    HKEY    hKey;
    BOOL    bRet = FALSE;
    DWORD   dwDis;

    // First need to open the key either way.
    //
    if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDis) == ERROR_SUCCESS )
    {
        if ( bSet )
        {
            TCHAR szCmd[MAX_PATH + 32];

            // Set us to run after we get logged on.
            //
            lstrcpyn(szCmd, g_szFactoryPath, AS ( szCmd ) );

            if ( FAILED ( StringCchCat ( szCmd, AS ( szCmd ), _T(" -logon") ) ) )
            {
                FacLogFileStr(3, _T("StringCchCat failed %s  %s\n"), szCmd, _T(" -logon") );
            }
            if ( RegSetValueEx(hKey, _T("AuditMode"), 0, REG_SZ, (CONST LPBYTE) szCmd, ( lstrlen(szCmd) + 1 ) * sizeof(TCHAR)) == ERROR_SUCCESS )
                bRet = TRUE;
        }
        else
        {
            // Delete the run key so we aren't left there.
            //
            if ( RegDeleteValue(hKey, _T("AuditMode")) == ERROR_SUCCESS )
                bRet = TRUE;
        }
        RegCloseKey(hKey);
    }

    // Open the key where we save some state info.
    //
    if ( RegCreateKeyEx(HKEY_LOCAL_MACHINE, REG_FACTORY_STATE, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDis) == ERROR_SUCCESS )
    {
        if ( bSet )
        {
            // Set the tick count so we know how long the logon takes.
            //
            if ( RegSetValueEx(hKey, _T("TickCount"), 0, REG_DWORD, (CONST LPBYTE) lpdwTickCount, sizeof(DWORD)) != ERROR_SUCCESS )
                bRet = FALSE;
        }
        else
        {
            DWORD   dwType,
                    cbValue = sizeof(DWORD);

            // Read and delete the run key so it isn't left there.
            //
            if ( ( RegQueryValueEx(hKey, _T("TickCount"), NULL, &dwType, (LPBYTE) lpdwTickCount, &cbValue) != ERROR_SUCCESS ) ||
                 ( REG_DWORD != dwType ) )
            {
                *lpdwTickCount = 0;
                bRet = FALSE;
            }
            else
                RegDeleteValue(hKey, _T("TickCount"));
        }
        RegCloseKey(hKey);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\factory\winpenet.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    winpenet.c

Abstract:

    This module contains code to control the startup of the network in the WinPE environment.
    It relies upon the existence of WINBOM.INI and the following sections:
    
    [WinPE.net]     
    Startnet   = YES | NO         - Specifies whether to start networking.
    Ipconfig   = DHCP | x.x.x.x   - Specifies DHCP or a static IP address.
    SubnetMask = x.x.x.x          - SubnetMask for the static IP.
    Gateway    = x.x.x.x          - Default gateway for the static IP.

Author:

    Adrian Cosma (acosma) - 1/18/2001

Revision History:

--*/

//
// Includes
//

#include "factoryp.h"
#include <winsock2.h>


//
// Defines
//

typedef HRESULT (PASCAL *PRegisterServer)(VOID);

//
// Static strings
//
const static TCHAR DEF_GATEWAY_METRIC[] = _T("1\0");   // Need to NULLCHRs at the end since this goes into a REG_MULTI_SZ. 
const static TCHAR REGSTR_TCPIP[]       = _T("SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\");

// 
// Local function declarations
//
static BOOL  InstallNetComponents(VOID);
static BOOL  RegisterDll(VOID);

//
// Function implementations
//

static BOOL InstallNetComponents(VOID)
{
    TCHAR szCmdLine[MAX_PATH] = NULLSTR;
    DWORD dwExitCode          = 0;
    BOOL bRet                 = TRUE;

    lstrcpyn(szCmdLine, _T("-winpe"), AS ( szCmdLine ) ) ;

    if ( !InvokeExternalApplicationEx(_T("netcfg"), szCmdLine, &dwExitCode, INFINITE, TRUE) )
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_NETWORKCOMP);
        bRet = FALSE;
    }
    return bRet;
}


static BOOL RegisterDll(VOID)
{
   
    HMODULE hDll = NULL;
    BOOL    bRet = FALSE;

    PRegisterServer pRegisterServer = NULL;
        
    if ( (hDll = LoadLibrary(_T("netcfgx.dll"))) &&
         (pRegisterServer = (PRegisterServer) GetProcAddress(hDll, "DllRegisterServer")) &&
         (S_OK == pRegisterServer()) )
    {
         FacLogFileStr(3, _T("Succesfully registered netcfg.dll.\n"));
         bRet = TRUE;
    }
    else
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_REGISTERNETCFG);
    }

    if (hDll)
        FreeLibrary(hDll);
    
    return bRet;
}

BOOL WinpeNet(LPSTATEDATA lpStateData)
{
    LPTSTR      lpszWinBOMPath                      = lpStateData->lpszWinBOMPath;
    SC_HANDLE   hSCM                                = NULL;
    TCHAR       szBuf[MAX_WINPE_PROFILE_STRING]     = NULLSTR;
    BOOL        bRet                                = TRUE;
    
    // Make sure that the user wants us to do networking.
    //
    GetPrivateProfileString(INI_KEY_WBOM_WINPE_NET, INI_KEY_WBOM_WINPE_NET_STARTNET, NULLSTR, szBuf, AS(szBuf), lpszWinBOMPath);

    // If user does not want to start networking just return success.
    //
    if ( 0 == LSTRCMPI(szBuf, WBOM_NO) )
        return TRUE;

    
    // Register dll.
    // Run netcfg -winpe.
    // Install network card.
    // See if the user wants to use a static IP.
    //
    if ( RegisterDll() && 
         SetupMiniNT() &&
         InstallNetComponents() &&
         ConfigureNetwork(g_szWinBOMPath)
       )
    {
        //
        // Start Services for networking.
        //
        if ( hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS) )
        {
            // DHCP also starts tcpip and netbt.
            // The workstation service should already be started by the installer.
            //
            if ( (StartMyService(_T("dhcp"), hSCM) != NO_ERROR) || 
                 (StartMyService(_T("nla"), hSCM) != NO_ERROR) 
                )
            {
                FacLogFile(0 | LOG_ERR, IDS_ERR_NETSERVICES);
                bRet = FALSE;
            }
            else if ( IsRemoteBoot() )
            {
                // If this was a remote boot, tell NetBT to reload the WINS addresses...
                // ISSUE-2002/09/26-acosma,brucegr - Can DHCP say its started before we get an address?
                //
                ForceNetbtRegistryRead();
            }

            CloseServiceHandle(hSCM);
        }   
        else 
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_SCM);
            bRet = FALSE;
        }
    }
    else 
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_SETUPNETWORK);
        bRet = FALSE;
    }
    return bRet;
}

BOOL DisplayWinpeNet(LPSTATEDATA lpStateData)
{
    return ( !IniSettingExists(lpStateData->lpszWinBOMPath, INI_KEY_WBOM_WINPE_NET, INI_KEY_WBOM_WINPE_NET_STARTNET, INI_VAL_WBOM_NO) );
}

BOOL ConfigureNetwork(LPTSTR lpszWinBOMPath)
{
    TCHAR   szBuf[MAX_WINPE_PROFILE_STRING]        = NULLSTR;
    CHAR    szBufA[MAX_WINPE_PROFILE_STRING]       = { 0 };
    TCHAR   szReg[MAX_WINPE_PROFILE_STRING]        = NULLSTR;
    TCHAR   szIpAddress[MAX_WINPE_PROFILE_STRING]  = NULLSTR; 
    TCHAR   szSubnetMask[MAX_WINPE_PROFILE_STRING] = NULLSTR;
    HKEY    hKey                                   = NULL;    // Reg Key to interfaces.
    HKEY    hKeyI                                  = NULL;    // Reg Key to specific network interface.
    DWORD   dwDis                                  = 0;
    TCHAR   szRegKey[MAX_PATH]                     = NULLSTR;
    DWORD   dwEnableDHCP                           = 0;
    BOOL    fErr                                   = FALSE; 

    szBuf[0] = NULLCHR;
    GetPrivateProfileString(INI_KEY_WBOM_WINPE_NET, WBOM_WINPE_NET_IPADDRESS, NULLSTR, szBuf, MAX_WINPE_PROFILE_STRING, lpszWinBOMPath);
    
    // Convert the string to ANSI
    //
    if ( szBuf[0] &&
         WideCharToMultiByte(CP_ACP, 0, szBuf, -1, szBufA, AS(szBufA), NULL, NULL) )
    {
        // If it's DHCP don't do anything.  Just return TRUE.
        //
        if ( 0 == LSTRCMPI(szBuf, _T("DHCP")) )
            return TRUE;
        
        if ( INADDR_NONE == inet_addr(szBufA) )
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_INVALIDIP , szBuf);
            return FALSE;
        }
    }
    else // if there is no IpConfig entry return success (same as DHCP)
        return TRUE;

    // Save the IpAddress.
    lstrcpyn(szIpAddress, szBuf, AS ( szIpAddress ) );

    szBuf[0] = NULLCHR;
    GetPrivateProfileString(INI_KEY_WBOM_WINPE_NET, WBOM_WINPE_NET_SUBNETMASK, NULLSTR, szBuf, MAX_WINPE_PROFILE_STRING, lpszWinBOMPath);
    
    // Convert the string to ANSI
    //
    if ( szBuf[0]  &&
         WideCharToMultiByte(CP_ACP,0, szBuf, -1, szBufA, AS(szBufA), NULL, NULL) )
    {
        if ( INADDR_NONE == inet_addr(szBufA) )
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_INVALIDMASK , szBuf);
            return FALSE;
        }
    }
    else // If we got this far we need to have a subnet mask
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_NOMASK);
        return FALSE;
    }

    // Save the SubnetMask.
    lstrcpyn(szSubnetMask, szBuf, AS ( szSubnetMask ) );
    
    //
    // Write the settings to the registry.
    //
            
    // Make sure that the strings are terminated by two NULLCHRs.
    //
    szIpAddress[lstrlen(szIpAddress) + 1] = NULLCHR;
    szSubnetMask[lstrlen(szSubnetMask) + 1] = NULLCHR;

    // Assuming that there is only one interface in the system.
    //
    if ( (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_TCPIP, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDis) == ERROR_SUCCESS)  &&
         (RegEnumKey(hKey, 0, szRegKey, AS(szRegKey)) == ERROR_SUCCESS) && 
          szRegKey[0] &&
         (RegCreateKeyEx(hKey, szRegKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKeyI, &dwDis) == ERROR_SUCCESS) )
    {
        if ( ERROR_SUCCESS != (RegSetValueEx(hKeyI, _T("IPAddress"), 0, REG_MULTI_SZ, (CONST LPBYTE) szIpAddress, ( lstrlen(szIpAddress) + 2 ) * sizeof(TCHAR))) ||
             ERROR_SUCCESS != (RegSetValueEx(hKeyI, _T("SubnetMask"), 0, REG_MULTI_SZ, (CONST LPBYTE) szSubnetMask, ( lstrlen(szSubnetMask) + 2 ) * sizeof(TCHAR))) ||
             ERROR_SUCCESS != (RegSetValueEx(hKeyI, _T("EnableDHCP"), 0, REG_DWORD, (CONST LPBYTE) &dwEnableDHCP, sizeof(dwEnableDHCP))) )
        {
            FacLogFile(0 | LOG_ERR, IDS_ERR_IPREGISTRY);
            fErr = TRUE;
        }
        else 
        {
            //
            // If the gateway is not specified we don't care. We're just not going to add this 
            // if it's not there.
            //
            szBuf[0] = NULLCHR;
            GetPrivateProfileString(INI_KEY_WBOM_WINPE_NET, WBOM_WINPE_NET_GATEWAY, NULLSTR, szBuf, MAX_WINPE_PROFILE_STRING, lpszWinBOMPath);

            if ( szBuf[0] &&
                WideCharToMultiByte(CP_ACP,0, szBuf, -1, szBufA, AS(szBufA), NULL, NULL) )
            {
                if ( INADDR_NONE == inet_addr(szBufA) )
                {
                    FacLogFile(0 | LOG_ERR, IDS_ERR_INVALIDGW, szBuf);
                    fErr = TRUE;
                }
                else
                {
                    szBuf[lstrlen(szBuf) + 1] = NULLCHR;

                    if ( (RegSetValueEx(hKeyI, _T("DefaultGateway"), 0, REG_MULTI_SZ, (CONST LPBYTE) szBuf, ( lstrlen(szBuf) + 2 ) * sizeof(TCHAR)) != ERROR_SUCCESS) ||
                         (RegSetValueEx(hKeyI, _T("DefaultGatewayMetric"), 0, REG_MULTI_SZ, (CONST LPBYTE) DEF_GATEWAY_METRIC, ( lstrlen(DEF_GATEWAY_METRIC) + 2 ) * sizeof(TCHAR)) != ERROR_SUCCESS) )
                    {
                        FacLogFile(0 | LOG_ERR, IDS_ERR_GWREGISTRY);
                        fErr = TRUE;
                    }
                }
            }
        }    
        RegCloseKey(hKeyI);
    }
    else
    {
        FacLogFile(0 | LOG_ERR, IDS_ERR_IPREGISTRY);
    }
    
    // It is possible that the subkey failed to open so this takes care of a possible leak.
    //       
    if (hKey)
        RegCloseKey(hKey);

    return (!fErr);
}

static DWORD WaitForServiceStart(SC_HANDLE schService)
{
    SERVICE_STATUS  ssStatus; 
    DWORD           dwOldCheckPoint; 
    DWORD           dwStartTickCount;
    DWORD           dwWaitTime;
    DWORD           dwStatus = NO_ERROR;
    
    if ( schService )
    {
        //
        // Service start is now pending.
        // Check the status until the service is no longer start pending. 
        // 
        if ( QueryServiceStatus( schService, &ssStatus) )
        {        
            // Save the tick count and initial checkpoint.
            //
            dwStartTickCount = GetTickCount();
            dwOldCheckPoint = ssStatus.dwCheckPoint;

            while (ssStatus.dwCurrentState == SERVICE_START_PENDING)
            {
                // Do not wait longer than the wait hint. A good interval is 
                // one tenth the wait hint, but no less than 1 second and no 
                // more than 10 seconds. 
                //
                dwWaitTime = ssStatus.dwWaitHint / 10;

                if( dwWaitTime < 1000 )
                    dwWaitTime = 1000;
                else if ( dwWaitTime > 10000 )
                    dwWaitTime = 10000;

                Sleep( dwWaitTime );

                // Check the status again. 
                //
                if (!QueryServiceStatus( 
                        schService,   // handle to service 
                        &ssStatus) )  // address of structure
                    break; 
 
                if ( ssStatus.dwCheckPoint > dwOldCheckPoint )
                {
                    // The service is making progress.
                    //
                    dwStartTickCount = GetTickCount();
                    dwOldCheckPoint = ssStatus.dwCheckPoint;
                }
                else
                {
                    if(GetTickCount()-dwStartTickCount > ssStatus.dwWaitHint)
                    {
                        // No progress made within the wait hint
                        //
                        break;
                    }
                }
            } 

            if (ssStatus.dwCurrentState == SERVICE_RUNNING) 
            {
                dwStatus = NO_ERROR;
            }
            else 
            { 
                // Set the return value to the last error.
                //
                dwStatus = GetLastError();
            }
        }
    }
     
    return dwStatus;
}


DWORD WaitForServiceStartName(LPTSTR lpszServiceName)
{
    SC_HANDLE   hSCM        = NULL;
    SC_HANDLE   schService  = NULL;
    DWORD       dwStatus    = NO_ERROR;

    if ( lpszServiceName )
    {
        if ( hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS) )
        {
            if ( schService = OpenService(hSCM, lpszServiceName, SERVICE_ALL_ACCESS) )
            {
                dwStatus = WaitForServiceStart(schService);
                CloseServiceHandle(schService);
            }
            else
            {
               dwStatus = GetLastError();
               FacLogFile(0 | LOG_ERR, IDS_ERR_SERVICE, lpszServiceName);
            }
        
            CloseServiceHandle(hSCM);
        }   
        else 
        {
            dwStatus = GetLastError();
            FacLogFile(0 | LOG_ERR, IDS_ERR_SCM);
        }
    }
    else
    {
        dwStatus = E_INVALIDARG;
    }
    return dwStatus;
}


// Start a service.
//
DWORD StartMyService(LPTSTR lpszServiceName, SC_HANDLE schSCManager) 
{ 
    SC_HANDLE       schService;
    DWORD           dwStatus = NO_ERROR;

    FacLogFileStr(3, _T("Starting service: %s\n"), lpszServiceName);
 
    if ( NULL != (schService = OpenService(schSCManager, lpszServiceName, SERVICE_ALL_ACCESS)) &&
         StartService(schService, 0, NULL) )
    {
       dwStatus = WaitForServiceStart(schService);
    }
    
    if ( schService ) 
        CloseServiceHandle(schService); 

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\inc\msdinst.h ===
/****************************************************************************\

    MSDINST.H / Mass Storage Device Installer (MSDINST.LIB)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Public (to the OPK) header file that contains all the external data needed
    to use the MSD Installation library.

    07/2001 - Jason Cohen (JCOHEN)

        Added this new OPK header file for the new MSD Installation project.

\****************************************************************************/


#ifndef _MSDINST_H_
#define _MSDINST_H_


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


//
// Function Prototype(s):
//

//
// From SETUPCDD.CPP:
//

BOOL
SetupCriticalDevices(
    LPTSTR lpszInfFile,
    HKEY   hkeySoftware,
    HKEY   hkeyLM,
    LPTSTR lpszWindows
    );

//
// From OFFLINE.CPP;
//
#define INSTALL_FLAG_FORCE      0x00000001

VOID
SetOfflineInstallFlags(
    IN DWORD
    );

DWORD
GetOfflineInstallFlags(
    VOID
    );

BOOL
UpdateOfflineDevicePath( 
    IN LPTSTR lpszInfPath, 
    IN HKEY   hKeySoftware 
    );

//
// From LOADHIVE.CPP:
//

BOOL
RegLoadOfflineImage(
    LPTSTR  lpszWindows,
    PHKEY   phkeySoftware,
    PHKEY   phkeySystem
    );

BOOL
RegUnloadOfflineImage(
    HKEY hkeySoftware,
    HKEY hkeySystem
    );


#ifdef __cplusplus
}
#endif // __cplusplus


#endif // _MSDINST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\inc\msdres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#define IDS_ERR_OPEN_INF                2001
#define IDS_ERR_OPEN_OFFLINECDD         2002
#define IDS_ERR_CREATE_DEVNODE          2003
#define IDS_ERR_GET_INF_NAME            2004
#define IDS_ERR_OPEN_FILE_QUEUE         2005
#define IDS_ERR_COMMIT_OFFLINE_QUEUE    2006
#define IDS_ERR_CLASS_GUID              2007
#define IDS_ERR_UPPER_FILTERS           2008
#define IDS_ERR_LOWER_FILTERS           2009
#define IDS_ERR_DEVICE_SERVICE          2010
#define IDS_ERR_SELECT_COMPAT           2011
#define IDS_ERR_ENUM_COMPAT_DRIVER      2012
#define IDS_ERR_BUILD_COMPAT_DRIVER     2013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\langinst\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by main.rc
//
#define IDS_ERR_FILECOPY                1
#define IDS_APPNAME                     2
#define IDS_ASK_INSTALL                 3
#define IDS_ENG                         4
#define IDS_GER                         5
#define IDS_ARA                         6
#define IDS_CHT                         7
#define IDS_CHS                         8
#define IDS_HEB                         9
#define IDS_JPN                         10
#define IDS_KOR                         11
#define IDS_BRZ                         12
#define IDS_CAT                         13
#define IDS_CZE                         14
#define IDS_DAN                         15
#define IDS_DUT                         16
#define IDS_FIN                         17
#define IDS_FRN                         18
#define IDS_GRK                         19
#define IDS_HUN                         20
#define IDS_ITN                         21
#define IDS_NOR                         22
#define IDS_POL                         23
#define IDS_POR                         24
#define IDS_RUS                         25
#define IDS_SPA                         26
#define IDS_SWE                         27
#define IDS_TRK                         28
#define IDS_CHH                         29
#define IDI_MAIN                        101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\lfn\lfn.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    lfn.c

Abstract:

Author:

    Ted Miller (tedm) Apr 1996

--*/

#include "lfn.h"
#pragma hdrstop


//
// Define result codes.
//
#define SUCCESS 0
#define FAILURE 1

//
// Define routine type for callbacks from EnumerateDrives()
//
typedef
BOOLEAN
(*PDRIVEENUM_ROUTINE) (
    IN PCWSTR DriveRootPath
    );

BOOLEAN
EnumerateDrives(
    IN PDRIVEENUM_ROUTINE Callback
    );

BOOLEAN
RestoreLfns(
    IN PCWSTR DriveRootPath
    );

BOOLEAN
Message(
    IN ULONG MessageId,
    IN ULONG DotCount,
    ...
    );

BOOLEAN
RenameToLfn(
    IN PCWSTR Directory,
    IN PCWSTR ExistingFilename,
    IN PCWSTR NewFilename
    );

VOID
DeleteRenameFile(
    IN PCWSTR DriveRootPath
    );

VOID
RemoveFromBootExecute(
    IN PCWSTR Cmd
    );

int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )

/*++

Routine Description:

    Entry point for this program.

    The $$RENAME.TXT at the root of each drive is read and
    rename operations contained therein are performed.

Arguments:

    Ignored.

Return Value:

    None.

--*/

{
    int i;

    i = EnumerateDrives(RestoreLfns) ? SUCCESS : FAILURE;

    RemoveFromBootExecute(L"autolfn");

    return(i);
}


BOOLEAN
EnumerateDrives(
    IN PDRIVEENUM_ROUTINE Callback
    )
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE DosDevicesDir;
    CHAR DirInfoBuffer[512];
    CHAR LinkTargetBuffer[512];
    UNICODE_STRING LinkTarget;
    UNICODE_STRING DesiredPrefix;
    UNICODE_STRING DesiredPrefix2;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    ULONG Context,Length;
    UNICODE_STRING LinkTypeName;
    NTSTATUS Status;
    HANDLE Handle;
    BOOLEAN b;

    //
    // Open \DosDevices
    //
    RtlInitUnicodeString(&UnicodeString,L"\\DosDevices");
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_PERMANENT,
        NULL,
        NULL
        );

    Status = NtOpenDirectoryObject(&DosDevicesDir,DIRECTORY_QUERY,&ObjectAttributes);
    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    LinkTarget.Buffer = (PVOID)LinkTargetBuffer;
    RtlInitUnicodeString(&LinkTypeName,L"SymbolicLink");
    RtlInitUnicodeString(&DesiredPrefix,L"\\Device\\Harddisk");
    RtlInitUnicodeString(&DesiredPrefix2,L"\\Device\\Volume");

    DirInfo = (POBJECT_DIRECTORY_INFORMATION)DirInfoBuffer;

    b = TRUE;

    //
    // Query first object in \DosDevices directory
    //
    Status = NtQueryDirectoryObject(
                DosDevicesDir,
                DirInfo,
                sizeof(DirInfoBuffer),
                TRUE,
                TRUE,
                &Context,
                &Length
                );

    while(NT_SUCCESS(Status)) {

        //
        // Make sure item is a symbolic link
        //
        if(RtlEqualUnicodeString(&LinkTypeName,&DirInfo->TypeName,TRUE)) {

            InitializeObjectAttributes(
                &ObjectAttributes,
                &DirInfo->Name,
                OBJ_CASE_INSENSITIVE,
                DosDevicesDir,
                NULL
                );

            Status = NtOpenSymbolicLinkObject(&Handle,SYMBOLIC_LINK_ALL_ACCESS,&ObjectAttributes);
            if(NT_SUCCESS(Status)) {

                LinkTarget.Length = 0;
                LinkTarget.MaximumLength = sizeof(LinkTargetBuffer);

                Status = NtQuerySymbolicLinkObject(Handle,&LinkTarget,NULL);
                NtClose(Handle);
                if(NT_SUCCESS(Status)
                && (RtlPrefixUnicodeString(&DesiredPrefix,&LinkTarget,TRUE) ||
                    RtlPrefixUnicodeString(&DesiredPrefix2,&LinkTarget,TRUE))) {

                    //
                    // OK, this is a symbolic link to a hard drive.
                    // Make sure it's 0-terminated and call the callback
                    // the the name.
                    //
                    LinkTarget.Buffer[LinkTarget.Length/sizeof(WCHAR)] = 0;

                    if(!Callback(LinkTarget.Buffer)) {
                        b = FALSE;
                    }
                }
            }
        }

        //
        // Query next object in \DosDevices directory
        //
        Status = NtQueryDirectoryObject(
                    DosDevicesDir,
                    DirInfo,
                    sizeof(DirInfoBuffer),
                    TRUE,
                    FALSE,
                    &Context,
                    &Length
                    );
    }

    NtClose(DosDevicesDir);
    return(b);
}


BOOLEAN
RestoreLfns(
    IN PCWSTR DriveRootPath
    )
{
    PMYTEXTFILE TextFile;
    BOOLEAN b;
    WCHAR Directory[NTMAXPATH];
    WCHAR Line[3*NTMAXPATH];
    ULONG d;
    PWCHAR p,n;
    PWSTR Sfn,Lfn;

    b = FALSE;

    //
    // Load the rename file list.
    //
    if(TextFile = LoadRenameFile(DriveRootPath)) {

        //
        // Process each directory that is in the rename list file.
        //
        for(d=0; d<TextFile->SectionCount; d++) {

            //
            // Form the directory path.
            //
            wcscpy(Directory,DriveRootPath);
            ConcatenatePaths(Directory,TextFile->Sections[d].Name,NTMAXPATH);

            //
            // Process each line in the section.
            //
            p = TextFile->Sections[d].Data;
            while(GetLineInSection(p,Line,sizeof(Line)/sizeof(WCHAR),&n)) {

                if(ParseLine(Line,&Sfn,&Lfn)) {

                    RenameToLfn(Directory,Sfn,Lfn);
                }

                p = n;
            }
        }

        UnloadRenameFile(&TextFile);

        //
        // Upon success, delete the rename file.
        //
        DeleteRenameFile(DriveRootPath);

        b = TRUE;
    }

    return(b);
}


BOOLEAN
Message(
    IN ULONG MessageId,
    IN ULONG DotCount,
    ...
    )

/*++

Routine Description:

    Format and display a message, which is retreived from
    the image's message resources.

Arguments:

    MessageId - Supplies the message id of the message resource.

    DotCount - Supplies number of trailing dots to be appended to
        the message text prior to display. If this value is non-0,
        then the message shouldn't have a trailing cr/lf!

    Additional arguments specify message-specific inserts.

Return Value:

    Boolean value indicating whether the message was displayed.

--*/

{
    PVOID ImageBase;
    NTSTATUS Status;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    va_list arglist;
    WCHAR Buffer[1024];
    ULONG u;

    //
    // Get our image base address
    //
    ImageBase = NtCurrentPeb()->ImageBaseAddress;
    if(!ImageBase) {
        return(FALSE);
    }

    //
    // Find the message.
    // For DBCS codepages we will use English resources instead of
    // default resource because we can only display ASCII characters onto
    // blue Screen via HalDisplayString()
    //
    Status = RtlFindMessage(
                ImageBase,
                11,
                NLS_MB_CODE_PAGE_TAG ? MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US) : 0,
                MessageId,
                &MessageEntry
                );

    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // If the message is not unicode, convert to unicode.
    // Let the conversion routine allocate the buffer.
    //
    if(!(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE)) {

        RtlInitAnsiString(&AnsiString,MessageEntry->Text);
        Status = RtlAnsiStringToUnicodeString(&UnicodeString,&AnsiString,TRUE);
        if(!NT_SUCCESS(Status)) {
            return(FALSE);
        }

    } else {
        //
        // Message is already unicode. Make a copy.
        //
        if(!RtlCreateUnicodeString(&UnicodeString,(PWSTR)MessageEntry->Text)) {
            return(FALSE);
        }
    }

    //
    // Format the message.
    //
    va_start(arglist,DotCount);

    Status = RtlFormatMessage(
                UnicodeString.Buffer,
                0,                      // max width
                FALSE,                  // don't ignore inserts
                FALSE,                  // args are not ansi
                FALSE,                  // args are not an array
                &arglist,
                Buffer,
                sizeof(Buffer)/sizeof(Buffer[0]),
                NULL
                );

    va_end(arglist);

    //
    // We don't need the message source any more. Free it.
    //
    RtlFreeUnicodeString(&UnicodeString);

    //
    // Add dots and cr.
    //
    for(u=0; u<DotCount; u++) {
        wcscat(Buffer,L".");
    }
    wcscat(Buffer,L"\r");

    //
    // Print out the message
    //
    RtlInitUnicodeString(&UnicodeString,Buffer);
    Status = NtDisplayString(&UnicodeString);

    return(NT_SUCCESS(Status));
}


VOID
ConcatenatePaths(
    IN OUT PWSTR  Target,
    IN     PCWSTR Path,
    IN     ULONG  TargetBufferSize
    )

/*++

Routine Description:

    Concatenate 2 paths, ensuring that one, and only one,
    path separator character is introduced at the junction point.

Arguments:

    Target - supplies first part of path. Path is appended to this.

    Path - supplies path to be concatenated to Target.

    TargetBufferSize - supplies the size of the Target buffer,
        in characters.

// ISSUE-2002/03/06-robertko This function returns VOID.  Should probably be changed to reflect the
// comment below since the funtion truncates to prevent buffer overflow.
Return Value:

    TRUE if the full path fit in Target buffer. Otherwise the path
    will have been truncated.

--*/

{
    ULONG TargetLength,PathLength;
    BOOL TrailingBackslash,LeadingBackslash;
    ULONG EndingLength;
    ULONG n;

    TargetLength = wcslen(Target);
    PathLength = wcslen(Path);

    //
    // See whether the target has a trailing backslash.
    //
    if(TargetLength && (Target[TargetLength-1] == L'\\')) {
        TrailingBackslash = TRUE;
        TargetLength--;
    } else {
        TrailingBackslash = FALSE;
    }

    //
    // See whether the path has a leading backshash.
    //
    if(Path[0] == L'\\') {
        LeadingBackslash = TRUE;
        PathLength--;
    } else {
        LeadingBackslash = FALSE;
    }

    //
    // Calculate the ending length, which is equal to the sum of
    // the length of the two strings modulo leading/trailing
    // backslashes, plus one path separator, plus a nul.
    //
    EndingLength = TargetLength + PathLength + 2;

    if(!LeadingBackslash && (TargetLength < TargetBufferSize)) {
        Target[TargetLength++] = L'\\';
    }

    if(TargetBufferSize > TargetLength) {
        n = wcslen(Path);
        if(n > TargetBufferSize-TargetLength) {
            n = TargetBufferSize-TargetLength;
        }
        RtlCopyMemory(Target+TargetLength,Path,n*sizeof(WCHAR));
        Target[TargetLength+n] = 0;
    }

    //
    // Make sure the buffer is nul terminated in all cases.
    //
    if(TargetBufferSize) {
        Target[TargetBufferSize-1] = 0;
    }
}


BOOLEAN
RenameToLfn(
    IN PCWSTR Directory,
    IN PCWSTR ExistingFilename,
    IN PCWSTR NewFilename
    )
{
    WCHAR Buffer[2*NTMAXPATH] = {0};
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE Handle;
    PFILE_RENAME_INFORMATION RenameInfo;

    //
    // Open the existing file for delete access.
    //
    wcsncpy(Buffer,Directory,sizeof(Buffer)/sizeof(Buffer[0]) - 1);
    ConcatenatePaths(Buffer,ExistingFilename,sizeof(Buffer)/sizeof(WCHAR));
    INIT_OBJA(&ObjectAttributes,&UnicodeString,Buffer);

    Status = NtOpenFile(
                &Handle,
                DELETE | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("LFN: Unable to open %ws for renaming (%x)\n",Buffer,Status));
        return(FALSE);
    }

    //
    // Rename to temporary intermediate file. This allows the filesystem to
    // generate a short filename later, that doesn't collide with the name
    // currently in use.
    //
    RenameInfo = (PFILE_RENAME_INFORMATION)Buffer;

    wcscpy(RenameInfo->FileName,Directory);
    ConcatenatePaths(RenameInfo->FileName,L"$$!!$$!!.~~~",NTMAXPATH);

    RenameInfo->ReplaceIfExists = TRUE;
    RenameInfo->RootDirectory = NULL;
    RenameInfo->FileNameLength = wcslen(RenameInfo->FileName)*sizeof(WCHAR);

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                RenameInfo,
                sizeof(FILE_RENAME_INFORMATION) + RenameInfo->FileNameLength,
                FileRenameInformation
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("LFN: Rename of %ws to intermediate temp filename failed (%x)\n",ExistingFilename,Status));
        NtClose(Handle);
        return(FALSE);
    }

    //
    // Rename to actual target file.
    //
    wcscpy(RenameInfo->FileName,Directory);
    ConcatenatePaths(RenameInfo->FileName,NewFilename,NTMAXPATH);

    RenameInfo->ReplaceIfExists = FALSE;
    RenameInfo->RootDirectory = NULL;
    RenameInfo->FileNameLength = wcslen(RenameInfo->FileName)*sizeof(WCHAR);

    Status = NtSetInformationFile(
                Handle,
                &IoStatusBlock,
                RenameInfo,
                sizeof(FILE_RENAME_INFORMATION) + RenameInfo->FileNameLength,
                FileRenameInformation
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("LFN: Rename of file to %ws failed (%x)\n",NewFilename,Status));
        NtClose(Handle);
        return(FALSE);
    }

    NtClose(Handle);
    return(TRUE);
}


VOID
DeleteRenameFile(
    IN PCWSTR DriveRootPath
    )
{
    WCHAR Filename[NTMAXPATH] = {0};
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE Handle;
    NTSTATUS Status;
    FILE_DISPOSITION_INFORMATION DispositionInfo;

    wcsncpy(Filename,DriveRootPath,sizeof(Filename)/sizeof(Filename[0]) - 1);
    ConcatenatePaths(Filename,WINNT_OEM_LFNLIST_W,NTMAXPATH);

    INIT_OBJA(&ObjectAttributes,&UnicodeString,Filename);

    Status = NtOpenFile(
                &Handle,
                DELETE,
                &ObjectAttributes,
                &IoStatusBlock,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if(NT_SUCCESS(Status)) {

        DispositionInfo.DeleteFile = TRUE;

        Status = NtSetInformationFile(
                    Handle,
                    &IoStatusBlock,
                    &DispositionInfo,
                    sizeof(DispositionInfo),
                    FileDispositionInformation
                    );


        if(!NT_SUCCESS(Status)) {
            KdPrint(("LFN: Unable to delete %ws (%x)\n",Filename,Status));
        }

        NtClose(Handle);

    } else {
        KdPrint(("LFN: Unable to open %ws for delete (%x)\n",Filename,Status));
        return;
    }

}


VOID
RemoveFromBootExecute(
    IN PCWSTR Cmd
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    HANDLE hKey;
    PKEY_VALUE_PARTIAL_INFORMATION ValueInfo;
    ULONG Length;
    PWCHAR NewValue;
    PWSTR SourceString,TargetString;

    //
    // Open the registry key we want.
    // [\registry\machine\system\CurrentControlSet\control\Session Manager]
    //
    INIT_OBJA(
        &ObjectAttributes,
        &UnicodeString,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager"
        );

    Status = NtOpenKey(
                &hKey,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &ObjectAttributes
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("LFN: Unable to open session manager key (%x)\n",Status));
        goto c0;
    }

    //
    // Query the current value of the BootExecute value.
    //
    RtlInitUnicodeString(&UnicodeString,L"BootExecute");

    Status = NtQueryValueKey(
                hKey,
                &UnicodeString,
                KeyValuePartialInformation,
                NULL,
                0,
                &Length
                );

    if(Status != STATUS_BUFFER_TOO_SMALL) {
        KdPrint(("LFN: Unable to query BootExecute value size (%x)\n",Status));
        goto c1;
    }

    ValueInfo = RtlAllocateHeap(RtlProcessHeap(),0,Length);
    if(!ValueInfo) {
        KdPrint(("LFN: Unable to allocate %u bytes of memory\n",Length));
        goto c1;
    }

    Status = NtQueryValueKey(
                hKey,
                &UnicodeString,
                KeyValuePartialInformation,
                ValueInfo,
                Length,
                &Length
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("LFN: Unable to allocate %u bytes of memory\n",Length));
        goto c2;
    }

    //
    // Check data type.
    //
    if(ValueInfo->Type != REG_MULTI_SZ) {
        KdPrint(("LFN: BootExecute is wrong data type (%u)\n",ValueInfo->Type));
    }

    //
    // Allocate space for a new multi_sz we will build up.
    //
    NewValue = RtlAllocateHeap(RtlProcessHeap(),0,ValueInfo->DataLength);
    if(!NewValue) {
        KdPrint(("LFN: Unable to allocate %u bytes of memory\n",ValueInfo->DataLength));
        goto c2;
    }

    //
    // Process each string in the multi_sz. Copy to the new value
    // we're building up; filter out any strings containing the given Cmd.
    //
    for(SourceString=(PWSTR)ValueInfo->Data,TargetString=NewValue;
        *SourceString;
        SourceString+=Length) {

        Length = wcslen(SourceString)+1;

        wcscpy(TargetString,SourceString);
        _wcslwr(TargetString);

        if(!wcsstr(TargetString,Cmd)) {
            //
            // Don't want to filter this string out of the multi_sz
            // we're building up. Recopy from source to preserve case
            // and advance the target string pointer.
            //
            wcscpy(TargetString,SourceString);
            TargetString += Length;
        }
    }

    //
    // Extra nul-terminator for multi_sz termination.
    //
    *TargetString++ = 0;

    //
    // Write the new value out into the registry.
    //
    Status = NtSetValueKey(
                hKey,
                &UnicodeString,
                0,
                REG_MULTI_SZ,
                NewValue,
                (ULONG)((TargetString-NewValue)*sizeof(WCHAR))
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("LFN: Unable to set BootExecute value (%x)\n",Status));
    }

    RtlFreeHeap(RtlProcessHeap(),0,NewValue);
c2:
    RtlFreeHeap(RtlProcessHeap(),0,ValueInfo);
c1:
    NtClose(hKey);
c0:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\lfn\lfn.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <setupbat.h>

#include <stdlib.h>
#include <string.h>

#include "msg.h"


//
// Define helper macro to deal with subtleties of NT-level programming.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

//
// Memory routines
//
#define MALLOC(size)    RtlAllocateHeap(RtlProcessHeap(),0,(size))
#define FREE(block)     RtlFreeHeap(RtlProcessHeap(),0,(block))
#define REALLOC(b,s)    RtlReAllocateHeap(RtlProcessHeap(),0,(b),(s))

//
// Resonable approximation based on max win32 path len plus
// \device\harddisk0\partition1 prefix
//
#define NTMAXPATH  MAX_PATH+64


//
// Structures used to store info about $$RENAME.TXT
//
typedef struct _MYSECTION {
    PWSTR Name;
    PWCHAR Data;
} MYSECTION, *PMYSECTION;

typedef struct _MYTEXTFILE {
    PWCHAR Text;
    ULONG SectionCount;
    ULONG SectionArraySize;
    PMYSECTION Sections;
} MYTEXTFILE, *PMYTEXTFILE;




PMYTEXTFILE
LoadRenameFile(
    IN PCWSTR DriveRootPath
    );

VOID
UnloadRenameFile(
    IN OUT PMYTEXTFILE *TextFile
    );

BOOLEAN
GetLineInSection(
    IN  PWCHAR  StartOfLine,
    OUT PWSTR   LineBuffer,
    IN  ULONG   BufferSizeChars,
    OUT PWCHAR *StartOfNextLine
    );

BOOLEAN
ParseLine(
    IN OUT PWSTR  Line,
       OUT PWSTR *LHS,
       OUT PWSTR *RHS
    );

VOID
ConcatenatePaths(
    IN OUT PWSTR  Target,
    IN     PCWSTR Path,
    IN     ULONG  TargetBufferSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\lfn\makefile.inc ===
$(O)\res.res: res.rc msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\inc\winbom.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    winbom.h

Abstract:

    Header file that contains declarations for the WINBOM file

Author:

    Donald McNamara (donaldm) 2/8/2000

Revision History:

    - Added defines for app preinstall: Jason Lawrence (t-jasonl) 6/7/2000
    - Added defines for winpe section: Adrian Cosma (acosma) 10/23/2000

--*/

//
// WINBOM.INI section headers, and key names.
//

#define FILE_WINBOM_INI                         _T("WINBOM.INI")

#define INI_VAL_WBOM_YES                        _T("Yes")
#define WBOM_YES                                INI_VAL_WBOM_YES
#define INI_VAL_WBOM_NO                         _T("No")
#define WBOM_NO                                 INI_VAL_WBOM_NO

// Factory Section:
//
#define INI_SEC_WBOM_FACTORY                    _T("factory")
#define WBOM_FACTORY_SECTION                    INI_SEC_WBOM_FACTORY
#define INI_KEY_WBOM_FACTORY_NEWWINBOM          _T("NewWinBOM")
#define WBOM_FACTORY_FORCEIDSCAN                _T("AutoDetectNetwork")
#define INI_KEY_WBOM_FACTCOMPNAME               _T("FactoryComputerName")
#define WBOM_FACTORY_ENDUSERCOMPUTERNAME        _T("EndUserComputerName")
#define INI_KEY_WBOM_REBOOTCOMPNAME             _T("RebootAfterComputeRName")
#define WBOM_FACTORY_LOGGING                    _T("Logging")
#define INI_KEY_WBOM_FACTORY_LOGFILE            _T("LogFile")
#define INI_KEY_WBOM_LOGPERF                    _T("LogPerf")
#define INI_KEY_WBOM_LOGLEVEL                   _T("LogLevel")
#define INI_KEY_WBOM_FACTORY_TYPE               _T("WinBOMType")
#define INI_VAL_WBOM_TYPE_WINPE                 _T("WinPE")
#define INI_VAL_WBOM_TYPE_FACTORY               _T("Factory")
#define INI_VAL_WBOM_TYPE_OOBE                  _T("OOBE")

#define INI_KEY_WBOM_FACTORY_RESEAL             _T("Reseal")
#define INI_KEY_WBOM_FACTORY_RESEALFLAGS        _T("ResealFlags")
#define INI_VAL_WBOM_SHUTDOWN                   _T("Shutdown")
#define INI_VAL_WBOM_REBOOT                     _T("Reboot")
#define INI_VAL_WBOM_FORCESHUTDOWN              _T("ForceShutdown")
#define INI_KEY_WBOM_FACTORY_RESEALMODE         _T("ResealMode")
#define INI_VAL_WBOM_FACTORY                    _T("Factory")
#define INI_VAL_WBOM_OOBE                       _T("Oobe")
#define INI_VAL_WBOM_MINI                       _T("Mini")
#define INI_VAL_WBOM_MINISETUP                  _T("MiniSetup")
#define INI_VAL_WBOM_AUDIT                      _T("Audit")

// Multiple Sections:
//
#define INI_VAL_WBOM_USERNAME                   _T("Username")
#define INI_VAL_WBOM_PASSWORD                   _T("Password")
#define INI_VAL_WBOM_DOMAIN                     _T("Domain")


// Settings for Application Preinstall
//
#define INI_SEC_WBOM_PREINSTALL                 _T("OemRunOnce")
#define INI_VAL_WBOM_STAGE                      _T("Stage")
#define INI_VAL_WBOM_DETACH                     _T("Detach")
#define INI_VAL_WBOM_ATTACH                     _T("Attach")
#define INI_VAL_WBOM_STANDARD                   _T("Standard")
#define INI_VAL_WBOM_MSI                        _T("MSI")
#define INI_VAL_WBOM_APP                        _T("APP")
#define INI_VAL_WBOM_INF                        _T("INF")

#define INI_KEY_WBOM_INSTALLTYPE                _T("InstallType")
#define INI_KEY_WBOM_SOURCEPATH                 _T("SourcePath")
#define INI_KEY_WBOM_TARGETPATH                 _T("StagePath")
#define INI_KEY_WBOM_SETUPFILE                  _T("SetupFile")
#define INI_KEY_WBOM_CMDLINE                    _T("CmdLine")
#define INI_KEY_WBOM_REBOOT                     _T("Reboot")
#define INI_KEY_WBOM_REMOVETARGET               _T("RemoveStagePath")
#define INI_KEY_WBOM_SECTIONNAME                _T("SectionName")

#define INI_SEC_WBOM_DRIVERUPDATE               _T("pnpdriverupdate")
#define WBOM_DRIVERUPDATE_USERNAME              _T("username")
#define WBOM_DRIVERUPDATE_PASSWORD              _T("password")
#define WBOM_DRIVERUPDATE_DOMAIN                _T("domain")
#define INI_VAL_WBOM_PNP_DIR                    _T("TargetRoot")
#define INI_KEY_WBOM_PNPWAIT                    _T("WaitForPnP")
#define INI_KEY_WBOM_INSTALLDRIVERS             _T("UpdateInstalledDrivers")
#define INI_VAL_WBOM_DEVICEPATH                 _T("DevicePath")

#define INI_SEC_WBOM_SETTINGS                   _T("ComputerSettings")
#define WBOM_SETTINGS_SECTION                   INI_SEC_WBOM_SETTINGS
#define WBOM_SETTINGS_DISPLAY                   _T("DisplayResolution")
#define WBOM_SETTINGS_REFRESH                   _T("DisplayRefresh")
#define WBOM_SETTINGS_DISPLAY_MINWIDTH          800
#define WBOM_SETTINGS_DISPLAY_MINHEIGHT         600
#define WBOM_SETTINGS_DISPLAY_MINDEPTH          16
#define INI_KEY_WBOM_HIBERNATION                _T("Hibernation")
#define INI_KEY_WBOM_PWRSCHEME                  _T("PowerScheme")
#define INI_VAL_WBOM_PWR_ALWAYSON               _T("AlwaysOn")
#define INI_VAL_WBOM_PWR_ALWAYS_ON              _T("Always On")
#define INI_VAL_WBOM_PWR_DESKTOP                _T("Desktop")
#define INI_VAL_WBOM_PWR_LAPTOP                 _T("Laptop")
#define INI_VAL_WBOM_PWR_PRESENTATION           _T("Presentation")
#define INI_VAL_WBOM_PWR_MINIMAL                _T("Minimal")
#define INI_VAL_WBOM_PWR_MAXBATTERY             _T("MaxBattery")
#define INI_VAL_WBOM_PWR_MAX_BATTERY            _T("Max Battery")
#define INI_KEY_WBOM_FONTSMOOTHING              _T("FontSmoothing")
#define INI_VAL_WBOM_FONTSMOOTHING_DEFAULT      _T("Standard")
#define INI_VAL_WBOM_FONTSMOOTHING_ON           _T("On")
#define INI_VAL_WBOM_FONTSMOOTHING_OFF          _T("Off")
#define INI_VAL_WBOM_FONTSMOOTHING_CLEARTYPE    _T("ClearType")
#define INI_KEY_WBOM_RESETSOURCE                _T("SourcePath")
#define INI_KEY_WBOM_TESTCERT                   _T("TestCert")
#define INI_KEY_WBOM_EXTENDPART                 _T("ExtendPartition")
#define INI_KEY_WBOM_SLPSOURCE                  _T("SlpFiles")
#define INI_KEY_WBOM_PRODKEY                    _T("ProductKey")

#define INI_KEY_WBOM_AUTOLOGON_OLD              _T("AuditAdminAutoLogon")
#define INI_KEY_WBOM_AUTOLOGON                  _T("AutoLogon")

#define INI_SEC_WBOM_DRIVERS                    _T("PnPDrivers")

#define WBOM_NETCARD_SECTION                    _T("netcards")

// Shell Settings:
//
#define INI_SEC_WBOM_SHELL                      _T("Shell")
#define INI_KEY_WBOM_SHELL_STARTPANELOFF        _T("DefaultStartPanelOff")
#define INI_KEY_WBOM_SHELL_THEMEOFF             _T("DefaultThemesOff")
#define INI_KEY_WBOM_SHELL_THEMEFILE            _T("CustomDefaultThemeFile")
#define INI_KEY_WBOM_SHELL_DOCLEANUP            _T("DoDesktopCleanup")
#define INI_KEY_WBOM_SHELL_STARTMESSENGER       _T("StartMessenger")
#define INI_KEY_WBOM_SHELL_USEMSNEXPLORER       _T("MSNExplorer")
#define INI_KEY_WBOM_SHELL_DEFWEB               _T("DefaultClientStartMenuInternet")
#define INI_KEY_WBOM_SHELL_DEFMAIL              _T("DefaultClientMail")
#define INI_KEY_WBOM_SHELL_DEFMEDIA             _T("DefaultClientMedia")
#define INI_KEY_WBOM_SHELL_DEFIM                _T("DefaultClientIM")
#define INI_KEY_WBOM_SHELL_DEFJAVAVM            _T("DefaultClientJavaVM")

// OC Components Settings:
//
#define INI_SEC_WBOM_COMPONENTS                 _T("Components")

// app preinstall
#define WBOM_APPPREINSTALL_SECTION              _T("AppPreInstall")
#define WBOM_APPPREINSTALL_TYPE                 _T("InstallType")
#define WBOM_APPPREINSTALL_TECH                 _T("InstallTechnology")
#define WBOM_APPPREINSTALL_SETUPFILE            _T("SetupFile")
#define WBOM_APPPREINSTALL_IMAGE                _T("Image")
#define WBOM_APPPREINSTALL_DEST                 _T("Destination")
#define WBOM_APPPREINSTALL_LOG                  _T("Log")
#define WBOM_APPPREINSTALL_CMDLINE              _T("CmdLine")
#define WBOM_APPPREINSTALL_TRANSFORM            _T("Transform")

#define WBOM_MAX_APPPRESECTION_NAME             256
#define WBOM_MAX_APPPRESECTION_LINE             1024

// Home Networking Section:
//
#define INI_SEC_HOMENET                         _T("SetupHomeNet")

// Sysprep Sections:
//
#define INI_SEC_WBOM_SYSPREP_MSD                _T("SysprepMassStorage")
#define INI_SEC_WBOM_SYSPREP_CLEAN              _T("SysprepCleanup")

// WinPE section
//
#define INI_SEC_WBOM_WINPE                      _T("WinPE")
#define WBOM_WINPE_SECTION                      INI_SEC_WBOM_WINPE
#define INI_KEY_WBOM_WINPE_LANG                 _T("Lang")
#define INI_KEY_WBOM_WINPE_SKU                  _T("Sku")
#define INI_KEY_WBOM_WINPE_CFGSET               _T("Configset")
#define INI_KEY_WBOM_WINPE_SRCROOT              _T("Sourceroot")
#define INI_KEY_WBOM_WINPE_OPTSOURCES           _T("OptionalSources")
#define WBOM_WINPE_OPK_TARGET_DRIVE             _T("Targetdrive")
#define WBOM_WINPE_FORCE_FORMAT                 _T("ForceFormat")
#define WBOM_WINPE_SRC_USERNAME                 _T("Username")
#define WBOM_WINPE_SRC_PASSWORD                 _T("Password")
#define WBOM_WINPE_SRC_DOMAIN                   _T("Domain")
#define INI_KEY_WBOM_WINPE_PAGEFILE             _T("PageFileSize")

#define INI_KEY_WBOM_WINPE_RESTART              _T("Restart")
#define INI_VAL_WBOM_WINPE_REBOOT               _T("Reboot")
#define INI_VAL_WBOM_WINPE_SHUTDOWN             _T("Shutdown")
#define INI_VAL_WBOM_WINPE_POWEROFF             _T("Poweroff")
#define INI_VAL_WBOM_WINPE_PROMPT               _T("Prompt")
#define INI_VAL_WBOM_WINPE_IMAGE                _T("Image")
#define INI_VAL_WBOM_WINPE_NONE                 _T("None")

#define INI_KEY_WBOM_QUIET                      _T("Quiet")

// WinPE.net section
#define INI_KEY_WBOM_WINPE_NET                  _T("WinPE.net")
#define INI_KEY_WBOM_WINPE_NET_STARTNET         _T("Startnet")
#define WBOM_WINPE_NET_SUBNETMASK               _T("SubnetMask")
#define WBOM_WINPE_NET_IPADDRESS                _T("IpConfig")
#define WBOM_WINPE_NET_GATEWAY                  _T("Gateway")

// DiskConfig Section
#define INI_SEC_WBOM_DISKCONFIG                 _T("DiskConfig")
#define WBOM_DISK_CONFIG_WIPE_DISK              _T("WipeDisk")

// Shell Optimizations
//
#define INI_KEY_WBOM_OPT_SHELL                  _T("OptimizeShell")

// Maximum length of string to be read from winbom.ini for this section
//
#define MAX_WINPE_PROFILE_STRING 256

// OemData Section.
#define WBOM_OEMLINK_SECTION                    _T("OemLink")
#define WBOM_DESKFLDR_SECTION                   _T("DesktopShortcutsFolder")

// Application Preinstallation Structures
//
typedef enum _INSTALLTYPE
{
    installtypeUndefined,
    installtypeStage,
    installtypeDetach,
    installtypeAttach,
    installtypeStandard

} INSTALLTYPE;

typedef enum _INSTALLTECH
{
    installtechUndefined,
    installtechMSI,
    installtechApp,
    installtechINF

} INSTALLTECH;

typedef struct _INSTALLTYPES
{
    INSTALLTYPE InstallType;
    LPCTSTR     lpszDescription;

} INSTALLTYPES, *PINSTALLTYPES, *LPINSTALLTYPES;

typedef struct _INSTALLTECHS
{
    INSTALLTECH InstallTech;
    LPCTSTR     lpszDescription;
} INSTALLTECHS, *PINSTALLTECHS, *LPINSTALLTECHS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\inc\opklib.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    opk.h

Abstract:

    Common functions for OPK Tools.

Author:

    Donald McNamara (donaldm) 02/08/2000
    Brian Ku	    (briank)  06/21/2000

Revision History:

--*/
#ifndef OPKLIB_H
#define OPKLIB_H

#ifndef STRICT
#define STRICT
#endif 

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shlwapi.h>
#include <regstr.h>
#include <tchar.h>
#include <lm.h>

#include <devguid.h>
#include <setupapi.h>
#include <spsyslib.h>
#include <sysprep_.h>

// ============================================================================
// JCOHEN.H - Brought over from Windows Millennium Edition
// ============================================================================

#ifdef NULLSTR
#undef NULLSTR
#endif // NULLSTR
#define NULLSTR _T("\0")

#ifdef NULLCHR
#undef NULLCHR
#endif // NULLCHR
#define NULLCHR _T('\0')

#ifdef CHR_BACKSLASH
#undef CHR_BACKSLASH
#endif // CHR_BACKSLASH
#define CHR_BACKSLASH           _T('\\')

#ifdef CHR_SPACE
#undef CHR_SPACE
#endif // CHR_SPACE
#define CHR_SPACE               _T(' ')

//
// Macros.
//

// String macros.
//
#ifndef LSTRCMPI
#define LSTRCMPI(x, y)        ( ( CompareString( LOCALE_INVARIANT, NORM_IGNORECASE, x, -1, y, -1 ) - CSTR_EQUAL ) )
#endif // LSTRCMPI

// Memory managing macros.
//
#ifdef MALLOC
#undef MALLOC
#endif // MALLOC
#define MALLOC(cb)          HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)

#ifdef REALLOC
#undef REALLOC
#endif // REALLOC
#define REALLOC(lp, cb)     HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lp, cb)

#ifdef FREE
#undef FREE
#endif // FREE
#define FREE(lp)            ( (lp != NULL) ? ( (HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, (LPVOID) lp)) ? ((lp = NULL) == NULL) : (FALSE) ) : (FALSE) )

#ifdef NETFREE
#undef NETFREE
#endif // NETFREE
#define NETFREE(lp)         ( (lp != NULL) ? ( (NetApiBufferFree((LPVOID) lp)) ? ((lp = NULL) == NULL) : (FALSE) ) : (FALSE) )

// Misc. macros.
//
#ifdef EXIST
#undef EXIST
#endif // EXIST
#define EXIST(lpFileName)   ( (GetFileAttributes(lpFileName) == 0xFFFFFFFF) ? (FALSE) : (TRUE) )

#ifdef ISNUM
#undef ISNUM
#endif // ISNUM
#define ISNUM(cChar)        ( ( ( cChar >= _T('0') ) && ( cChar <= _T('9') ) ) ? (TRUE) : (FALSE) )

#ifdef ISLET
#undef ISLET
#endif // ISLET
#define ISLET(cChar)        ( ( ( ( cChar >= _T('a') ) && ( cChar <= _T('z') ) ) || ( ( cChar >= _T('A') ) && ( cChar <= _T('Z') ) ) ) ? (TRUE) : (FALSE) )

#ifdef UPPER
#undef UPPER
#endif // UPPER
#define UPPER(x)            ( ( (x >= _T('a')) && (x <= _T('z')) ) ? (x + _T('A') - _T('a')) : (x) )

#ifdef RANDOM
#undef RANDOM
#endif // RANDOM
#define RANDOM(low, high)   ( (high - low + 1) ? (rand() % (high - low + 1) + low) : (0) )

#ifdef COMP
#undef COMP
#endif // COMP
#define COMP(x, y)          ( (UPPER(x) == UPPER(y)) ? (TRUE) : (FALSE) )

#ifdef STRSIZE
#undef STRSIZE
#endif // STRSIZE
#define STRSIZE(sz)         ( sizeof(sz) / sizeof(TCHAR) )

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif // ARRAYSIZE
#define ARRAYSIZE(a)         ( sizeof(a) / sizeof(a[0]) )

#ifdef AS
#undef AS
#endif // AS
#define AS(a)               ARRAYSIZE(a)

#ifdef GETBIT
#undef GETBIT
#endif // GETBIT
#define GETBIT(dw, b)       ( dw & b )

#ifdef SETBIT
#undef SETBIT
#endif // SETBIT
#define SETBIT(dw, b, f)    ( (f) ? (dw |= b) : (dw &= ~b) )

#ifndef GET_FLAG
#define GET_FLAG(f, b)          ( f & b )
#endif // GET_FLAG

#ifndef SET_FLAG
#define SET_FLAG(f, b)          ( f |= b )
#endif // SET_FLAG

#ifndef RESET_FLAG
#define RESET_FLAG(f, b)        ( f &= ~b )
#endif // RESET_FLAG


//
// Logging constants and definitions.
//
#define LOG_DEBUG               0x00000003    // Only log in debug builds if this is specified. (Debug Level for logging.)
#define LOG_LEVEL_MASK          0x0000000F    // Mask to only show the log level bits
#define LOG_MSG_BOX             0x00000010    // Display the message boxes if this is enabled.
#define LOG_ERR                 0x00000020    // Prefix the logged string with "Error:" if the message is level 0,
                                              // or "WARNx" if the message is at level x > 0.
#define LOG_TIME                0x00000040    // Display time if this is enabled
#define LOG_NO_NL               0x00000080    // Don't add new Line to the end of log string if this is set.

#define LOG_FLAG_QUIET_MODE     0x00000001    // Quiet mode - don't display message boxes.


typedef struct _LOG_INFO
{
    DWORD  dwLogFlags;
    DWORD  dwLogLevel;
    TCHAR  szLogFile[MAX_PATH];
    LPTSTR lpAppName;
} LOG_INFO, *PLOG_INFO;



#define INI_SEC_LOGGING             _T("Logging")
#define INI_KEY_LOGGING             INI_SEC_LOGGING
#define INI_VAL_YES                 _T("Yes")
#define INI_VAL_NO                  _T("No")
#define INI_KEY_LOGLEVEL            _T("LogLevel")
#define INI_KEY_QUIET               _T("QuietMode")
#define INI_KEY_LOGFILE             _T("LogFile")
// ============================================================================
// MISCAPI.H - Brought over from Windows Millennium Edition
// ============================================================================


//
// Defined Value(s):
//

#define MB_ERRORBOX             MB_ICONSTOP | MB_OK | MB_APPLMODAL


//
// Type Definition(s):
//

// Use this simple struture to create a table that
// maps a constant string to a localizable resource id.
//
typedef struct _STRRES
{
    LPTSTR  lpStr;
    UINT    uId;
} STRRES, *PLSTRRES, *LPSTRRES;


//
// External Function Prototype(s):
//

LPTSTR AllocateString(HINSTANCE, UINT);
LPTSTR AllocateExpand(LPTSTR lpszBuffer);
LPTSTR AllocateStrRes(HINSTANCE hInstance, LPSTRRES lpsrTable, DWORD cbTable, LPTSTR lpString, LPTSTR * lplpReturn);
int MsgBoxLst(HWND, LPTSTR, LPTSTR, UINT, va_list);
int MsgBoxStr(HWND, LPTSTR, LPTSTR, UINT, ...);
int MsgBox(HWND, UINT, UINT, UINT, ...);
void CenterDialog(HWND hwnd);
void CenterDialogEx(HWND hParent, HWND hChild);
INT_PTR CALLBACK SimpleDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR SimpleDialogBox(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent);
HFONT GetFont(HWND, LPTSTR, DWORD, LONG, BOOL);
void ShowEnableWindow(HWND, BOOL);
extern BOOL IsServer(VOID);
extern BOOL IsIA64(VOID);
BOOL ValidDosName(LPCTSTR);
DWORD GetLineArgs(LPTSTR lpSrc, LPTSTR ** lplplpArgs, LPTSTR * lplpAllArgs);
DWORD GetCommandLineArgs(LPTSTR ** lplplpArgs);

//
// Generic singularly linked list 
//

typedef struct _GENERIC_LIST {
    void*                   pvItem;     // points to your structure
    struct _GENERIC_LIST*   pNext;
}GENERIC_LIST, *PGENERIC_LIST;

BOOL FAddListItem(PGENERIC_LIST*, PGENERIC_LIST**, PVOID pvItem);
void FreeList(PGENERIC_LIST);

// ============================================================================
BOOL FGetFactoryPath(LPTSTR pszFactoryPath);
BOOL FGetSysprepPath(LPTSTR pszSysprepPath);

// ============================================================================
// DISKAPI.H - Brought over from Windows Millennium Edition
// ============================================================================
BOOL DirectoryExists(LPCTSTR);
BOOL FileExists(LPCTSTR);
BOOL CopyResetFile(LPCTSTR, LPCTSTR);
DWORD IfGetLongPathName(LPCTSTR lpszShortPath, LPTSTR lpszLongPath, DWORD cchBuffer);
BOOL CreatePath(LPCTSTR);
BOOL DeletePath(LPCTSTR);
BOOL DeleteFilesEx(LPCTSTR lpDirectory, LPCTSTR lpFileSpec);
LPTSTR AddPathN(LPTSTR lpPath, LPCTSTR lpName, DWORD cbPath);
LPTSTR AddPath(LPTSTR, LPCTSTR);
DWORD ExpandFullPath(LPTSTR lpszPath, LPTSTR lpszReturn, DWORD cbReturn);
BOOL CopyDirectory(LPCTSTR, LPCTSTR);
BOOL CopyDirectoryProgress(HWND, LPCTSTR, LPCTSTR);
BOOL CopyDirectoryProgressCancel(HWND hwnd, HANDLE hEvent, LPCTSTR lpSrc, LPCTSTR lpDst);
DWORD FileCount(LPCTSTR);
BOOL BrowseForFolder(HWND, INT, LPTSTR, DWORD);
BOOL BrowseForFile(HWND hwnd, INT, INT, INT, LPTSTR, DWORD, LPTSTR, DWORD);
ULONG CrcFile(LPCTSTR); // In CRC32.C
BOOL CreateUnicodeFile(LPCTSTR);

// ============================================================================
// STRAPI.H - Brought over from Windows Millennium Edition
// ============================================================================
#ifndef _INC_SHLWAPI
LPTSTR StrChr(LPCTSTR, TCHAR);
LPTSTR StrRChr(LPCTSTR, TCHAR);
#endif // _INC_SHLWAPI

LPTSTR StrRem(LPTSTR, TCHAR);
LPTSTR StrRTrm(LPTSTR, TCHAR);
LPTSTR StrTrm(LPTSTR, TCHAR);
LPTSTR StrMov(LPTSTR, LPTSTR, INT);

// Exported Function(s) in LOG.C:
//
INT LogFileLst(LPCTSTR lpFileName, LPTSTR lpFormat, va_list lpArgs);
INT LogFileStr(LPCTSTR lpFileName, LPTSTR lpFormat, ...);
INT LogFile(LPCTSTR lpFileName, UINT uFormat, ...);


DWORD OpkLogFileLst(PLOG_INFO pLogInfo, DWORD dwLogOpt, LPTSTR lpFormat, va_list lpArgs);
DWORD OpkLogFile(DWORD dwLogOpt, UINT uFormat, ...);
DWORD OpkLogFileStr(DWORD dwLogOpt, LPTSTR lpFormat, ...);
BOOL  OpkInitLogging(LPTSTR lpszIniPath, LPTSTR lpAppName);



/****************************************************************************\

    From REGAPI.C

    Registry API function prototypes and defined values.

\****************************************************************************/


//
// Defined Root Key(s):
//

#define HKCR    HKEY_CLASSES_ROOT
#define HKCU    HKEY_CURRENT_USER
#define HKLM    HKEY_LOCAL_MACHINE
#define HKU     HKEY_USERS


//
// Type Definition(s):
//

typedef BOOL (CALLBACK * REGENUMKEYPROC) (HKEY, LPTSTR, LPARAM);
typedef BOOL (CALLBACK * REGENUMVALPROC) (LPTSTR, LPTSTR, LPARAM);


//
// External Function Prototype(s):
//

BOOL RegExists(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue);
BOOL RegDelete(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue);
LPTSTR RegGetStringEx(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue, BOOL bExpand);
LPTSTR RegGetString(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue);
LPTSTR RegGetExpand(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue);
LPVOID RegGetBin(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue);
DWORD RegGetDword(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue);
BOOL RegSetStringEx(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, LPTSTR lpData, BOOL bExpand);
BOOL RegSetString(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, LPTSTR lpData);
BOOL RegSetExpand(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, LPTSTR lpData);
BOOL RegSetDword(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, DWORD dwData);
BOOL RegCheck(HKEY hKeyRoot, LPTSTR lpKey, LPTSTR lpValue);
BOOL RegEnumKeys(HKEY hKey, LPTSTR lpRegKey, REGENUMKEYPROC hCallBack, LPARAM lParam, BOOL bDelKeys);
BOOL RegEnumValues(HKEY hKey, LPTSTR lpRegKey, REGENUMVALPROC hCallBack, LPARAM lParam, BOOL bDelValues);



/****************************************************************************\

    From INIAPI.C

    INI API function prototypes and defined values.

\****************************************************************************/


//
// External Function Prototype(s):
//

LPTSTR IniGetExpand(LPTSTR lpszIniFile, LPTSTR lpszSection, LPTSTR lpszKey, LPTSTR lpszDefault);
LPTSTR IniGetString(LPTSTR lpszIniFile, LPTSTR lpszSection, LPTSTR lpszKey, LPTSTR lpszDefault);
LPTSTR IniGetSection(LPTSTR lpszIniFile, LPTSTR lpszSection);
LPTSTR IniGetStringEx(LPTSTR lpszIniFile, LPTSTR lpszSection, LPTSTR lpszKey, LPTSTR lpszDefault, LPDWORD lpdwSize);
LPTSTR IniGetSectionEx(LPTSTR lpszIniFile, LPTSTR lpszSection, LPDWORD lpdwSize);
BOOL IniSettingExists(LPCTSTR lpszFile, LPCTSTR lpszSection, LPCTSTR lpszKey, LPCTSTR lpszValue);



/****************************************************************************\

    From OPKFAC.C

    Factory API function prototypes and defined values.

\****************************************************************************/


//
// Defined Value(s):
//

// Flags for LocateWinBom():
//
#define LOCATE_NORMAL   0x00000000
#define LOCATE_AGAIN    0x00000001
#define LOCATE_NONET    0x00000002


//
// External Function Prototype(s):
//

BOOL EnablePrivilege(IN PCTSTR,IN BOOL);
extern BOOL GetCredentials(LPTSTR lpszUsername, DWORD dwUsernameSize, LPTSTR lpszPassword, DWORD dwPasswordSize, LPTSTR lpFileName, LPTSTR lpAlternateSection);
extern NET_API_STATUS FactoryNetworkConnect(LPTSTR lpszPath, LPTSTR lpszWinBOMPath, LPTSTR lpAlternateSection, BOOL bState);
extern BOOL LocateWinBom(LPTSTR lpWinBOMPath, DWORD cbWinbBOMPath, LPTSTR lpFactoryPath, LPTSTR lpFactoryMode, DWORD dwFlags);
void CleanupRegistry(VOID);
VOID GenUniqueName(OUT PWSTR GeneratedString, IN  DWORD DesiredStrLen);
NET_API_STATUS ConnectNetworkResource(LPTSTR, LPTSTR, LPTSTR, BOOL);
BOOL GetUncShare(LPCTSTR lpszPath, LPTSTR lpszShare, DWORD cbShare);
DWORD GetSkuType();
BOOL SetFactoryStartup(LPCTSTR lpFactory);
BOOL UpdateDevicePathEx(HKEY hKeyRoot, LPTSTR lpszSubKey, LPTSTR lpszNewPath, LPTSTR lpszRoot, BOOL bRecursive);
BOOL UpdateDevicePath(LPTSTR lpszNewPath, LPTSTR lpszRoot, BOOL bRecursive);
BOOL UpdateSourcePath(LPTSTR lpszSourcePath);
VOID CleanupSourcesDir(LPTSTR lpszSourcesPath);
BOOL SetDefaultOEMApps(LPCTSTR pszWinBOMPath);
BOOL OpklibCheckVersion(DWORD dwMajorVersion, DWORD dwQFEVersion);

//  If app uses setDefaultOEMApps, it must implement the following function
//  which is used for error reporting.

void ReportSetDefaultOEMAppsError(LPCTSTR pszMissingApp, LPCTSTR pszCategory);

//
// Sysprep_c.w
//
// ============================================================================
// USEFUL STRINGS
// ============================================================================

#define SYSCLONE_PART2              "setupcl.exe"
#define IDS_ADMINISTRATOR           1

// ============================================================================
// USEFUL CONSTANTS
// ============================================================================

#define SETUPTYPE                   1        // from winlogon\setup.h
#define SETUPTYPE_NOREBOOT          2
#define REGISTRY_QUOTA_BUMP         (10* (1024 * 1024))
#define DEFAULT_REGISTRY_QUOTA      (32 * (1024 * 1024))
#define SFC_DISABLE_NOPOPUPS        4        // from sfc.h
#define FILE_SRCLIENT_DLL           L"SRCLIENT.DLL"

// ============================================================================
// FUNCTION DECLARATIONS
// ============================================================================

BOOL
IsDomainMember(
    VOID
    );

BOOL
ResetRegistryKey(
    IN HKEY   Rootkey,
    IN PCWSTR Subkey,
    IN PCWSTR Delkey
    );

BOOL
DeleteWinlogonDefaults(
    VOID
    );

VOID
FixDevicePaths(
    VOID
    );

BOOL
NukeMruList(
    VOID
    );

BOOL
RemoveNetworkSettings(
    LPTSTR  lpszSysprepINFPath
    );

VOID
RunExternalUniqueness(
    VOID
    );

BOOL
IsSetupClPresent(
    VOID
    );

//
// from spapip.h
//
BOOL
pSetupIsUserAdmin(
    VOID
    );

BOOL
pSetupDoesUserHavePrivilege(
    PCTSTR
    );

BOOL
EnablePrivilege(
    IN PCTSTR,
    IN BOOL
    );

BOOL
ValidateAndChecksumFile(
    IN  PCTSTR   Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    );

VOID
LogRepairInfo(
    IN  PWSTR  Source,
    IN  PWSTR  Target,
    IN  PWSTR  DirectoryOnSourceDevice,
    IN  PWSTR  DiskDescription,
    IN  PWSTR  DiskTag
    );

BOOL
ChangeBootTimeout(
    IN UINT
    );

VOID 
DisableSR(
    VOID
    );

VOID 
EnableSR(
    VOID
    );

#endif // OPKLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\langinst\main.c ===
/****************************************************************************\

    MAIN.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    Main source file for the OPK Wizard.  Contains WinMain() and global
    variable declarations.

    4/99 - Jason Cohen (JCOHEN)
        Added this new main source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include <tchar.h>
#include "opklib.h"
#include "resource.h"  


//
// Global Variable(s):
//

TCHAR   g_szSource[MAX_PATH]    = NULLSTR;
BOOL    g_bQuiet                = FALSE;

STRRES  g_srLangs[] =
{
    { _T("ENG"),    IDS_ENG },
    { _T("GER"),    IDS_GER },
    { _T("ARA"),    IDS_ARA },
    { _T("CHH"),    IDS_CHH },
    { _T("CHT"),    IDS_CHT },
    { _T("CHS"),    IDS_CHS },
    { _T("HEB"),    IDS_HEB },
    { _T("JPN"),    IDS_JPN },
    { _T("KOR"),    IDS_KOR },
    { _T("BRZ"),    IDS_BRZ },
    { _T("CAT"),    IDS_CAT },
    { _T("CZE"),    IDS_CZE },
    { _T("DAN"),    IDS_DAN },
    { _T("DUT"),    IDS_DUT },
    { _T("FIN"),    IDS_FIN },
    { _T("FRN"),    IDS_FRN },
    { _T("GRK"),    IDS_GRK },
    { _T("HUN"),    IDS_HUN },
    { _T("ITN"),    IDS_ITN },
    { _T("NOR"),    IDS_NOR },
    { _T("POL"),    IDS_POL },
    { _T("POR"),    IDS_POR },
    { _T("RUS"),    IDS_RUS },
    { _T("SPA"),    IDS_SPA },
    { _T("SWE"),    IDS_SWE },
    { _T("TRK"),    IDS_TRK },
    { NULL,         0 },
};


//
// Internal Defined Value(s):
//

#define FILE_INF                _T("langinst.inf")
#define DIR_LANG                _T("lang")
#define INF_SEC_FILES           _T("files")
#define INF_SEC_LANG            _T("strings")
#define INF_KEY_LANG            _T("lang")

#define COPYFILE_FLAG_RENAME    0x00000001

#define REG_KEY_OPK             _T("SOFTWARE\\Microsoft\\OPK")
#define REG_KEY_OPK_LANGS       REG_KEY_OPK _T("\\Langs")
#define REG_VAL_PATH            _T("Path")

#define STR_OPT_QUIET           _T("quiet")


//
// Internal Function Prototype(s):
//

static DWORD InstallLang(LPTSTR lpszInfFile, LPTSTR lpszSrcRoot, LPTSTR lpszDstRoot);
static BOOL ParseCmdLine();


//
// Main Function:
//

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    int nReturn = 0;

    if ( ParseCmdLine() && g_szSource[0] )
    {
        TCHAR   szInfFile[MAX_PATH],
                szDestination[MAX_PATH] = NULLSTR,
                szLang[32]              = NULLSTR;
        LPTSTR  lpLang;
        HKEY    hKey;

        // Figure out our destination is based on the OPK tools install path.
        //
        if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_OPK, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS )
        {
            DWORD   dwType,
                    dwSize  = AS(szDestination);

            if ( ( RegQueryValueEx(hKey, REG_VAL_PATH, NULL, &dwType, (LPBYTE) szDestination, &dwSize) != ERROR_SUCCESS ) ||
                 ( dwType != REG_SZ ) )
            {
                szDestination[0] = NULLCHR;
            }

            RegCloseKey(hKey);
        }

        // Create the path to the inf file we need on the source.
        //
        lstrcpyn(szInfFile, g_szSource,AS(szInfFile));
        AddPathN(szInfFile, FILE_INF,AS(szInfFile));

        // Make sure we have the source file and destination directory and lang.
        //
        if ( ( szDestination[0] ) &&
             ( DirectoryExists(szDestination) ) &&
             ( FileExists(szInfFile) ) &&
             ( GetPrivateProfileString(INF_SEC_LANG, INF_KEY_LANG, NULLSTR, szLang, AS(szLang), szInfFile) ) &&
             ( szLang[0] ) &&
             ( lpLang = AllocateStrRes(NULL, g_srLangs, AS(g_srLangs), szLang, NULL) ) )
        {
            // Now make sure the actually want to instlall it.
            //
            if ( g_bQuiet || ( MsgBox(NULL, IDS_ASK_INSTALL, IDS_APPNAME, MB_ICONQUESTION | MB_YESNO, lpLang) == IDYES ) )
            {
                // Now finish creating the root destination path.
                //
                AddPathN(szDestination, DIR_LANG,AS(szDestination));
                AddPathN(szDestination, szLang,AS(szDestination));

                // Now actually copy the files.
                //
                if ( nReturn = InstallLang(szInfFile, g_szSource, szDestination) )
                {
                    // Just return 1 for success.
                    //
                    nReturn = 1;

                    // Set a registry key so we know that the tools for this lang are installed.
                    //
                    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_KEY_OPK_LANGS, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS )
                    {
                        DWORD dwVal = 1;

                        RegSetValueEx(hKey, szLang, 0, REG_DWORD, (LPBYTE) &dwVal, sizeof(DWORD));
                        RegCloseKey(hKey);
                    }
                }
                else
                {
                    // Error copying files.
                    //
                    MsgBox(NULL, IDS_ERR_FILECOPY, IDS_APPNAME, MB_ERRORBOX, UPPER(szDestination[0]));
                }
            }

            FREE(lpLang);
        }
    }

    return nReturn;
}

//
// Internal Function(s):
//

static DWORD InstallLang(LPTSTR lpszInfFile, LPTSTR lpszSrcRoot, LPTSTR lpszDstRoot)
{
    HINF        hInf;
    DWORD       dwErr,
                dwRet   = 0;
    BOOL        bRet    = TRUE;

    // Open our inf that has all the data we need.
    //
    if ( (hInf = SetupOpenInfFile(lpszInfFile, NULL, INF_STYLE_WIN4, &dwErr)) != INVALID_HANDLE_VALUE )
    {
        BOOL        bLoop;
        INFCONTEXT  InfContext;

        // Loop thru each line in the section we are searching.
        //
        for ( bLoop = SetupFindFirstLine(hInf, INF_SEC_FILES, NULL, &InfContext);
              bLoop && bRet;
              bLoop = SetupFindNextLine(&InfContext, &InfContext) )
        {
            DWORD   dwFlags             = 0;
            LPTSTR  lpszSrcName         = NULL,
                    lpszDstName         = NULL;
            TCHAR   szSrcFile[MAX_PATH] = NULLSTR,
                    szDstFile[MAX_PATH] = NULLSTR,
                    szSrcFull[MAX_PATH] = NULLSTR,
                    szDstFull[MAX_PATH] = NULLSTR,
                    szSrcPath[MAX_PATH],
                    szDstPath[MAX_PATH];

            // Get the source path and filename.
            //
            if ( !SetupGetStringField(&InfContext, 1, szSrcFile, AS(szSrcFile), NULL) )
                szSrcFile[0] = NULLCHR;

            // Get the destination path.
            //
            if ( !SetupGetStringField(&InfContext, 2, szDstFile, AS(szDstFile), NULL) )
                szDstFile[0] = NULLCHR;

            // Get any flags passed in.
            //
            if ( !SetupGetIntField(&InfContext, 3, &dwFlags) )
                dwFlags = 0;

            // Make sure we have the required data in this line.
            //
            if ( szSrcFile[0] && szDstFile[0] )
            {
                // Create the full path of the source file.
                //
                lstrcpyn(szSrcPath, lpszSrcRoot, AS(szSrcPath));
                AddPathN(szSrcPath, szSrcFile,AS(szSrcPath));
                if ( GetFullPathName(szSrcPath, AS(szSrcFull), szSrcFull, &lpszSrcName) &&
                     szSrcFull[0] &&
                     lpszSrcName &&
                     FileExists(szSrcFull) )
                {
                    // If the destination is NULL or empty, we just want a file count.
                    //
                    if ( lpszDstRoot && *lpszDstRoot )
                    {
                        // Create the full path of the destination directory.
                        //
                        lstrcpyn(szDstPath, lpszDstRoot,AS(szDstPath));
                        AddPathN(szDstPath, szDstFile,AS(szDstPath));
                        if ( !(dwFlags & COPYFILE_FLAG_RENAME) )
                            AddPathN(szDstPath, lpszSrcName,AS(szDstPath));
                        if ( GetFullPathName(szDstPath, AS(szDstFull), szDstFull, &lpszDstName) &&
                             szDstFull[0] &&
                             lpszDstName )
                        {
                            // We want just the path part of the destination file name.
                            //
                            lstrcpyn(szDstPath, szDstFull, (int)(lpszDstName - szDstFull));

                            // Now make sure the path exists and actually copy the file.
                            //
                            if ( ( DirectoryExists(szDstPath) || CreatePath(szDstPath) ) &&
                                 ( CopyResetFile(szSrcFull, szDstFull) ) )
                            {
                                dwRet++;
                            }
                            else
                                bRet = FALSE;
                        }
                    }
                    else
                        dwRet++;
                }
            }
        }

        // We are done, so close the INF file.
        //
        SetupCloseInfFile(hInf);
    }

    return bRet ? dwRet : 0;
}

static BOOL ParseCmdLine()
{
    DWORD   dwArgs;
    LPTSTR  *lpArgs;
    BOOL    bError = FALSE;

    if ( (dwArgs = GetCommandLineArgs(&lpArgs) ) && lpArgs )
    {
        LPTSTR  lpArg;
        DWORD   dwArg;

        // We want to skip over the first argument (it is the path
        // to the command being executed.
        //
        if ( dwArgs > 1 )
        {
            dwArg = 1;
            lpArg = *(lpArgs + dwArg);
        }
        else
            lpArg = NULL;

        // Loop through all the arguments.
        //
        while ( lpArg && !bError )
        {
            // Now we check to see if the first char is a dash or not.
            //
            if ( ( *lpArg == _T('-') ) ||
                 ( *lpArg == _T('/') ) )
            {
                LPTSTR lpOption = CharNext(lpArg);

                //
                // This is where you add command line options that start with a dash (-).
                //
                // Set bError if you don't recognize the command line option (unless you
                // want to just ignore it and continue).
                //
               
                if ( LSTRCMPI(lpOption, STR_OPT_QUIET) == 0 )
                    g_bQuiet = TRUE;
                else
                    bError = TRUE;
            }
            else if ( *lpArg )
            {
                //
                // This is where you would read any command line parameters that are just passed
                // in on the command line w/o any proceeding characters (like - or /).
                //
                // Set bError if you don't have any of these types of parameters (unless you
                // want to just ignore it and continue).
                //

                if ( g_szSource[0] == NULLCHR )
                    lstrcpy(g_szSource, lpArg);
                else
                    bError = TRUE;
            }

            // Setup the pointer to the next argument in the command line.
            //
            if ( ++dwArg < dwArgs )
                lpArg = *(lpArgs + dwArg);
            else
                lpArg = NULL;
        }

        // Make sure to free the two buffers allocated by the GetCommandLineArgs() function.
        //
        FREE(*lpArgs);
        FREE(lpArgs);
    }

    return !bError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\lfn\textfile.c ===
#include "lfn.h"
#pragma hdrstop



PMYTEXTFILE
ReadRenameFile(
    IN PCWSTR DriveRootPath
    );

BOOLEAN
FindSections(
    IN PMYTEXTFILE TextFile
    );

BOOLEAN
GetLine(
    IN  PWCHAR  StartOfLine,
    OUT PWSTR   LineBuffer,
    IN  ULONG   BufferSizeChars,
    OUT PWCHAR *StartOfNextLine
    );

int
__cdecl
ComparePaths(
    const void *p1,
    const void *p2
    );


PMYTEXTFILE
LoadRenameFile(
    IN PCWSTR DriveRootPath
    )
{
    PMYTEXTFILE TextFile;
    BOOLEAN b;

    //
    // Read in the file.
    //
    if(TextFile = ReadRenameFile(DriveRootPath)) {

        if(b = FindSections(TextFile)) {

            return(TextFile);
        }

        UnloadRenameFile(&TextFile);
    }

    return(FALSE);
}


VOID
UnloadRenameFile(
    IN OUT PMYTEXTFILE *TextFile
    )
{
    PMYTEXTFILE textFile;
    ULONG u;

    textFile = *TextFile;
    *TextFile = NULL;

    if(textFile->Sections) {

        for(u=0; u<textFile->SectionCount; u++) {
            FREE(textFile->Sections[u].Name);
        }

        FREE(textFile->Sections);
    }

    FREE(textFile);
}


PMYTEXTFILE
ReadRenameFile(
    IN PCWSTR DriveRootPath
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    IO_STATUS_BLOCK IoStatusBlock;
    WCHAR FullPath[NTMAXPATH] = {0};
    HANDLE Handle;
    FILE_STANDARD_INFORMATION FileInfo;
    PVOID Buffer;
    PWCHAR UnicodeBuffer;
    ULONG u;
    PMYTEXTFILE p = NULL;
    ULONG CharCount;

    wcsncpy(FullPath,DriveRootPath,sizeof(FullPath)/sizeof(FullPath[0]) - 1);
    ConcatenatePaths(FullPath,WINNT_OEM_LFNLIST_W,NTMAXPATH);

    //
    // Open the file.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,FullPath);
    Status = NtCreateFile(
                &Handle,
                FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                0,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_ALERT | FILE_NON_DIRECTORY_FILE,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("LFN: Unable to open %ws (%x)\n",FullPath,Status));
        goto c0;
    }

    //
    // Determine the size of the file.
    //
    Status = NtQueryInformationFile(
                Handle,
                &IoStatusBlock,
                &FileInfo,
                sizeof(FileInfo),
                FileStandardInformation
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("LFN: Unable to determine size of %ws (%x)\n",FullPath,Status));
        goto c1;
    }

    //
    // Allocate a chunk of memory and read the file in.
    //
    Buffer = MALLOC(FileInfo.EndOfFile.LowPart);
    if(!Buffer) {
        KdPrint(("LFN: malloc failed\n"));
        goto c1;
    }

    Status = NtReadFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                Buffer,
                FileInfo.EndOfFile.LowPart,
                NULL,
                NULL
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint((
            "LFN: Unable to read %u bytes from file %ws (%x)\n",
            FileInfo.EndOfFile.LowPart,
            FullPath,
            Status
            ));
        goto c2;
    }

    //
    // Allocate a buffer for unicode conversion.
    // Leave room for a terminating NUL.
    //
    UnicodeBuffer = MALLOC((FileInfo.EndOfFile.LowPart+1)*sizeof(WCHAR));
    if(!UnicodeBuffer) {
        KdPrint(("LFN: malloc failed\n"));
        goto c2;
    }

    //
    // Convert to unicode.
    //
    Status = RtlOemToUnicodeN(
                UnicodeBuffer,
                FileInfo.EndOfFile.LowPart*sizeof(WCHAR),
                &CharCount,
                Buffer,
                FileInfo.EndOfFile.LowPart
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("LFN: Unable to convert file data to unicode (%x)\n",Status));
        goto c3;
    }

    CharCount /= sizeof(WCHAR);

    //
    // Nul-terminate the buffer and change instances of CR and control-z
    // to spaces. Also make sure there are no 0 chars in the buffer.
    //
    for(u=0; u<CharCount; u++) {
        if((UnicodeBuffer[u] == 26) || (UnicodeBuffer[u] == L'\r') || !UnicodeBuffer[u]) {
            UnicodeBuffer[u] = L' ';
        }
    }

    //
    // Allocate a text file structure.
    //
    p = MALLOC(sizeof(MYTEXTFILE));
    if(!p) {
        KdPrint(("LFN: malloc failed\n"));
        goto c3;
    }

    RtlZeroMemory(p,sizeof(MYTEXTFILE));
    p->Text = UnicodeBuffer;
    UnicodeBuffer[CharCount] = 0;

c3:
    if(!NT_SUCCESS(Status)) {
        FREE(UnicodeBuffer);
    }
c2:
    FREE(Buffer);
c1:
    NtClose(Handle);
c0:
    return(NT_SUCCESS(Status) ? p : NULL);
}


BOOLEAN
FindSections(
    IN PMYTEXTFILE TextFile
    )
{
    PWCHAR p,n;
    WCHAR Line[2*NTMAXPATH];
    PWCHAR e;
    PVOID NewArray;
    PWCHAR s;
    PWSTR SectionName;

    for(p=TextFile->Text; GetLine(p,Line,sizeof(Line)/sizeof(WCHAR),&n); p=n) {

        //
        // If this is a section save it away in a table of section names.
        //
        if(Line[0] == L'[') {

            s = Line+1;
            while((*s == L' ') || (*s == L'\t')) {
                s++;
            }
            if(*s == L'\\') {
                s++;
            }

            //
            // Find the end, which is either the ] or a nul.
            // Strip off trailing spaces.
            //
            if(e = wcschr(s,L']')) {
                *e = 0;
            } else {
                e = wcschr(s,0);
            }
            while((*(e-1) == L' ') || (*(e-1) == L'\t')) {
                e--;
                *e = 0;
            }

            if(SectionName = MALLOC((wcslen(s)+1)*sizeof(WCHAR))) {

                wcscpy(SectionName,s);

                if(TextFile->SectionCount == TextFile->SectionArraySize) {

                    if(TextFile->SectionCount) {
                        NewArray = REALLOC(TextFile->Sections,(TextFile->SectionCount+10)*sizeof(MYSECTION));
                    } else {
                        NewArray = MALLOC(10*sizeof(MYSECTION));
                    }

                    if(NewArray) {
                        TextFile->Sections = NewArray;
                        TextFile->SectionArraySize += 10;
                    } else {
                        FREE(SectionName);
                        KdPrint(("LFN: malloc failed\n"));
                        return(FALSE);
                    }
                }

                TextFile->Sections[TextFile->SectionCount].Name = SectionName;
                TextFile->Sections[TextFile->SectionCount].Data = n;

                TextFile->SectionCount++;

            } else {
                KdPrint(("LFN: malloc failed\n"));
                return(FALSE);
            }
        }
    }

    //
    // Now sort the sections by name.
    //
    qsort(TextFile->Sections,TextFile->SectionCount,sizeof(MYSECTION),ComparePaths);

    return(TRUE);
}


BOOLEAN
GetLineInSection(
    IN  PWCHAR  StartOfLine,
    OUT PWSTR   LineBuffer,
    IN  ULONG   BufferSizeChars,
    OUT PWCHAR *StartOfNextLine
    )
{
    //
    // Get the line and check if we've reached the end of the section.
    //
    if(!GetLine(StartOfLine,LineBuffer,BufferSizeChars,StartOfNextLine)
    || (LineBuffer[0] == L'[')) {

        return(FALSE);
    }

    return(TRUE);
}


BOOLEAN
GetLine(
    IN  PWCHAR  StartOfLine,
    OUT PWSTR   LineBuffer,
    IN  ULONG   BufferSizeChars,
    OUT PWCHAR *StartOfNextLine
    )
{
    PWCHAR LineEnd;
    SIZE_T Count;

    while(1) {
        //
        // Skip space chars.
        //
        while(*StartOfLine && ((*StartOfLine == L' ') || (*StartOfLine == L'\t'))) {
            StartOfLine++;
        }
        if(*StartOfLine == 0) {
            //
            // Nothing left.
            //
            return(FALSE);
        }

        //
        // Find the end of the line, which is either the newline or nul.
        //
        if(LineEnd = wcschr(StartOfLine,L'\n')) {
            *StartOfNextLine = LineEnd+1;
        } else {
            LineEnd = wcschr(StartOfLine,0);
            *StartOfNextLine = LineEnd;
        }

        //
        // Ignore this line if it's a comment or empty.
        // Otherwise return it.
        //
        if((*StartOfLine != L';') && (*StartOfLine != L' ')) {
            Count = LineEnd - StartOfLine;
            if(Count >= BufferSizeChars) {
                Count = BufferSizeChars-1;
            }

            RtlCopyMemory(LineBuffer,StartOfLine,Count*sizeof(WCHAR));
            LineBuffer[Count] = 0;
            return(TRUE);
        }

        StartOfLine = *StartOfNextLine;
    }
}


int
__cdecl
ComparePaths(
    const void *p1,
    const void *p2
    )
{
    unsigned u1,u2;
    PWCHAR s1,s2;

    //
    // Count \'s in each. The one with fewer is 'greater'.
    //
    s1 = ((PMYSECTION)p1)->Name;
    s2 = ((PMYSECTION)p2)->Name;

    u1 = 0;
    u2 = 0;

    while(*s1) {
        if(*s1 == L'\\') {
            u1++;
        }
        s1++;
    }

    while(*s2) {
        if(*s2 == L'\\') {
            u2++;
        }
        s2++;
    }

    if(u1 == u2) {
        return(0);
    }

    return((u1 < u2) ? 1 : -1);
}


BOOLEAN
ParseLine(
    IN OUT PWSTR  Line,
       OUT PWSTR *LHS,
       OUT PWSTR *RHS
    )
{
    PWCHAR p,q;

    //
    // We rely on the routines abive to have stripped out
    // leading spaces.
    //
    *LHS = Line;

    //
    // Find the equals. The LHS isn't allowed to be quoted.
    // Strip trailing space off the LHS.
    //
    p = wcschr(Line,L'=');
    if(!p || (p == Line)) {
        return(FALSE);
    }
    q = p+1;
    *p-- = 0;

    while((*p == L' ') || (*p == L'\t')) {
        *p-- = 0;
    }

    while(*q && ((*q == L' ') || (*q == L'\t'))) {
        q++;
    }
    if(*q == 0) {
        return(FALSE);
    }
    if(*q == L'\"') {
        q++;
    }

    *RHS = q;
    p = q + wcslen(q);
    p--;
    while((*p == L' ') || (*p == L'\t')) {
        *p-- = 0;
    }
    if(*p == L'\"') {
        *p = 0;
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\lib\msdinst\addsvc.c ===
/****************************************************************************\

    SYSPREP.C / Mass Storage Service Installer (MSDINST.LIB)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file the MSD Installation library which contains the sysprep
    releated code taken from the published sysprep code.

    07/2001 - Brian Ku (BRIANK)

        Added this new source file for the new MSD Isntallation project.

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"


//
// Used by SetupDiInstallDevice to specify the service parameters passed
// to the Service Control Manager to create/modify a service.
//
#define INFSTR_KEY_DISPLAYNAME          TEXT("DisplayName")
#define INFSTR_KEY_SERVICETYPE          TEXT("ServiceType")     // Type
#define INFSTR_KEY_STARTTYPE            TEXT("StartType")       // Start
#define INFSTR_KEY_ERRORCONTROL         TEXT("ErrorControl")
#define INFSTR_KEY_SERVICEBINARY        TEXT("ServiceBinary")   // ImagePath
#define INFSTR_KEY_LOADORDERGROUP       TEXT("LoadOrderGroup")
#define INFSTR_KEY_DEPENDENCIES         TEXT("Dependencies")
#define INFSTR_KEY_STARTNAME            TEXT("StartName")
#define INFSTR_KEY_SECURITY             TEXT("Security")
#define INFSTR_KEY_DESCRIPTION          TEXT("Description")
#define INFSTR_KEY_TAG                  TEXT("Tag")

CONST TCHAR pszDisplayName[]    = INFSTR_KEY_DISPLAYNAME,
            pszServiceType[]    = INFSTR_KEY_SERVICETYPE,
            pszStartType[]      = INFSTR_KEY_STARTTYPE,
            pszErrorControl[]   = INFSTR_KEY_ERRORCONTROL,
            pszServiceBinary[]  = INFSTR_KEY_SERVICEBINARY,
            pszLoadOrderGroup[] = INFSTR_KEY_LOADORDERGROUP,
            pszDependencies[]   = INFSTR_KEY_DEPENDENCIES,
            pszStartName[]      = INFSTR_KEY_STARTNAME,
            pszSystemRoot[]     = TEXT("%SystemRoot%\\"),
            pszSecurity[]       = INFSTR_KEY_SECURITY,
            pszDescription[]    = INFSTR_KEY_DESCRIPTION,
            pszTag[]            = INFSTR_KEY_TAG;


BOOL IsAddServiceInSection(HINF hInf, LPTSTR pszServiceName, LPTSTR pszServiceSection, LPTSTR pszServiceInstallSection)
{
    INFCONTEXT context;
    BOOL       fReturn = FALSE;
    TCHAR      szService[MAX_PATH],
               szServiceSection[MAX_PATH];

    if (!hInf || !pszServiceName || !pszServiceSection || !pszServiceInstallSection)
        return FALSE;

    //
    // Get the xxxx_Service_Inst from the xxxx_.Service section.
    //
    if ( SetupFindFirstLine(hInf, pszServiceSection, _T("AddService"), &context) ) {
        if( SetupGetStringField(&context,1,szService,MAX_PATH,NULL) && !lstrcmpi(szService, pszServiceName) ) {
            if( SetupGetStringField(&context,3,szServiceSection,MAX_PATH,NULL) ) {
                lstrcpy(pszServiceInstallSection, szServiceSection);
                return (fReturn = TRUE);            
            }                
        }
    }    
    return fReturn;
}

BOOL LocateServiceInstallSection(HINF hInf, LPTSTR pszServiceName, LPTSTR pszServiceSection)
{
    BOOL fFound = FALSE,
         fReturn = FALSE;

    if (hInf && pszServiceName && pszServiceSection) 
    {
#if 1
        INFCONTEXT ctxManufacturer;
        //
        // Walk [Manufacturer], for each manufacturer, get the install-section-name.
        // Check if install-section-name.Services first field is our ServiceName.  If
        // so then get the third field which is the Service install section.
        // NOTE: The first device install that uses a service will be found.  
        //
        if ( !SetupFindFirstLine(hInf, _T("Manufacturer"), NULL, &ctxManufacturer) ) 
            return (fReturn = FALSE);
        
        //
        // Walk each [Manufacturer] to get the model.
        //
        do {
            INFCONTEXT ctxModel;
            TCHAR      szModel[MAX_PATH];
            
            if(!SetupGetStringField(&ctxManufacturer,1,szModel,MAX_PATH,NULL) || !szModel[0]) {
                continue;
            }

            if ( !SetupFindFirstLine(hInf, szModel, NULL, &ctxModel) ) 
                return (fReturn = FALSE);

            //
            // Walk each Model to get the install sections.
            //
            do {
                TCHAR szInstallSection[MAX_PATH],
                      szServicesSection[MAX_PATH],
                      szServiceInstallSection[MAX_PATH];
                
                if(!SetupGetStringField(&ctxModel,1,szInstallSection,MAX_PATH,NULL) || !szInstallSection[0]) {
                    continue;
                }
                
                //
                // For each install section check if they have/use any services.
                //
                lstrcpy(szServicesSection, szInstallSection);
                lstrcat(szServicesSection, _T(".Services"));
                if ( IsAddServiceInSection(hInf, pszServiceName, szServicesSection, szServiceInstallSection) ) {
                    // 
                    // Found the a device which uses this service and we found the service install
                    // section. Everyone using this service should be using the same service install 
                    // section.
                    //
                    lstrcpy(pszServiceSection, szServiceInstallSection);
                    fReturn = fFound = TRUE;
                }
                
            } while(SetupFindNextLine(&ctxModel,&ctxModel) && !fFound);
            
        } while(SetupFindNextLine(&ctxManufacturer,&ctxManufacturer) && !fFound);
        
#else
        //
        // Quick hack to get the service install section.  All infs MS builds should be in this standard
        // anyways.
        //
        lstrcpy(pszServiceSection, pszServiceName);
        lstrcat(pszServiceSection, _T("_Service_Inst"));
        fReturn = TRUE;
#endif
    }

    return fReturn;
}

BOOL FixupServiceBinaryPath(LPTSTR pszServiceBinary, DWORD ServiceType)
{
    TCHAR szWindowsPath[MAX_PATH] = _T(""), 
          szTempPath[MAX_PATH] = _T("");
    int   len;
    BOOL  fReturn = FALSE;

    //
    // Check for the C:\WINDOWS path if so remove it.
    //
    if ( GetWindowsDirectory(szWindowsPath, AS(szWindowsPath)) && *szWindowsPath )
    {
        len = lstrlen(szWindowsPath);

        if ( pszServiceBinary && (0 == _tcsncmp(szWindowsPath, pszServiceBinary, len)) )
        {
            //
            // Service type use %systemroot% so service can start
            //
            if (ServiceType & SERVICE_WIN32) 
            {
                lstrcpy(szTempPath, pszSystemRoot);
                lstrcat(szTempPath, pszServiceBinary + len + 1); // + 1 for the backslash
            }
            else 
            {
                lstrcpy(szTempPath, pszServiceBinary + len + 1); // + 1 for the backslash
            }

            lstrcpy(pszServiceBinary, szTempPath);
            fReturn = TRUE;
        }
        else 
        {
            //
            // We should never end up here. If we do then the INF has an incorrect ServiceBinary.
            //
        }
    }
    else
    {
        //
        // We should never end up here. If we do then GetWindowsDirectory failed.
        //
    }

    return fReturn;
}


DWORD PopulateServiceKeys(
    HINF hInf,                  // Handle to the inf the service section will be in.
    LPTSTR lpszServiceSection,  // Section in the inf that has the info about the service.
    LPTSTR lpszServiceName,     // Name of the service (as it appears under HKLM,System\CCS\Services).
    HKEY hkeyService,           // Handle to the offline service key.
    BOOL bServiceExists         // TRUE if the service already exists in the registry
    )
/*++

Routine Description:

    This function adds the service and registry settings to offline hive.

Arguments:

    hInf - Handle to the inf the service section will be in.

    lpszServiceSection - Section in the inf that has the info about the service.

    lpszServiceName - Name of the service (as it appears under HKLM,System\CCS\Services).

    hkeyService - Handle to the offline hive key to use as the service key.

    bServiceExists - TRUE if the service already exists in the registry. FALSE if we need to add the service.

Return Value:

    ERROR_SUCCESS - Successfully populated the service keys.

--*/
{
    PCTSTR ServiceName;
    DWORD ServiceType, 
          StartType, 
          ErrorControl,
          TagId;
    TCHAR szDisplayName[MAX_PATH]       = _T(""), 
          szLoadOrderGroup[MAX_PATH]    = _T(""), 
          szSecurity[MAX_PATH]          = _T(""), 
          szDescription[MAX_PATH]       = _T(""),
          szServiceBinary[MAX_PATH]     = _T(""),
          szStartName[MAX_PATH]         = _T("");
    INFCONTEXT InstallSectionContext;
    DWORD  dwLength, 
           dwReturn = ERROR_SUCCESS;
    BOOL   fServiceHasTag = FALSE;

    //
    // Check valid arguments.
    //
    if (!hInf || !lpszServiceSection || !lpszServiceName || !hkeyService)
        return ERROR_INVALID_PARAMETER;

    //
    // Retrieve the required values from this section.  
    //
    if(!SetupFindFirstLine(hInf, lpszServiceSection, pszServiceType, &InstallSectionContext) ||
       !SetupGetIntField(&InstallSectionContext, 1, (PINT)&ServiceType)) {
        return ERROR_BAD_SERVICE_INSTALLSECT;
    }
    if(!SetupFindFirstLine(hInf, lpszServiceSection, pszStartType, &InstallSectionContext) ||
       !SetupGetIntField(&InstallSectionContext, 1, (PINT)&StartType)) {
        return ERROR_BAD_SERVICE_INSTALLSECT;
    }
    if(!SetupFindFirstLine(hInf, lpszServiceSection, pszErrorControl, &InstallSectionContext) ||
       !SetupGetIntField(&InstallSectionContext, 1, (PINT)&ErrorControl)) {
        return ERROR_BAD_SERVICE_INSTALLSECT;
    }
    if(SetupFindFirstLine(hInf, lpszServiceSection, pszServiceBinary, &InstallSectionContext)) {
       if ( !(SetupGetStringField(&InstallSectionContext, 1, szServiceBinary, sizeof(szServiceBinary)/sizeof(szServiceBinary[0]), &dwLength)) ) {
            return ERROR_BAD_SERVICE_INSTALLSECT;
       }
    }

    //
    // Fixup the ServiceBinary path, if driver use relative path or if service use %systemroot% so service can load. 
    //
    if ( !FixupServiceBinaryPath(szServiceBinary, ServiceType) )
            return ERROR_BAD_SERVICE_INSTALLSECT;

    //
    // Now check for the other, optional, parameters.
    //
    if(SetupFindFirstLine(hInf, lpszServiceSection, pszDisplayName, &InstallSectionContext)) {
        if( !(SetupGetStringField(&InstallSectionContext, 1, szDisplayName, sizeof(szDisplayName)/sizeof(szDisplayName[0]), &dwLength)) ) {
            lstrcpy(szDisplayName, _T(""));
        }
    }
    if(SetupFindFirstLine(hInf, lpszServiceSection, pszLoadOrderGroup, &InstallSectionContext)) {
        if( !(SetupGetStringField(&InstallSectionContext, 1, szLoadOrderGroup, sizeof(szLoadOrderGroup)/sizeof(szLoadOrderGroup[0]), &dwLength)) ) {
            lstrcpy(szLoadOrderGroup, _T(""));
        }
    }
    if(SetupFindFirstLine(hInf, lpszServiceSection, pszSecurity, &InstallSectionContext)) {
        if( !(SetupGetStringField(&InstallSectionContext, 1, szSecurity, sizeof(szSecurity)/sizeof(szSecurity[0]), &dwLength)) ) {
            lstrcpy(szSecurity, _T(""));
        }
    }
    if(SetupFindFirstLine(hInf, lpszServiceSection, pszDescription, &InstallSectionContext)) {
        if( !(SetupGetStringField(&InstallSectionContext, 1, szDescription, sizeof(szDescription)/sizeof(szDescription[0]), &dwLength)) ) {
            lstrcpy(szDescription, _T(""));
        }
    }

    //
    // Only retrieve the StartName parameter for kernel-mode drivers and win32 services.  The StartName is only used for CreateService, we may 
    // not use it but I'm getting it anyways.
    //
    if(ServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER | SERVICE_WIN32)) {
        if(SetupFindFirstLine(hInf, lpszServiceSection, pszStartName, &InstallSectionContext))  {
            if( !(SetupGetStringField(&InstallSectionContext, 1, szStartName, sizeof(szStartName)/sizeof(szStartName[0]), &dwLength)) ) {
                lstrcpy(szStartName, _T(""));
            }
        }
    }

    //
    // Unique tag value for this service in the group. A value of 0 indicates that the service has not been assigned a tag. 
    // A tag can be used for ordering service startup within a load order group by specifying a tag order vector in the registry 
    // located at: HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\GroupOrderList. Tags are only evaluated for Kernel Driver 
    // and File System Driver start type services that have Boot or System start modes. 
    //
    if ( fServiceHasTag = (lstrlen(szLoadOrderGroup) &&
                     (ServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER))) )
        TagId = 0; 

    
    if ( !bServiceExists )
    {
        //
        // Now write the required service key entries.  
        //
        if ( (ERROR_SUCCESS != RegSetValueEx(hkeyService, _T("Type"), 0, REG_DWORD, (LPBYTE)&ServiceType, sizeof(ServiceType)))          ||
             (ERROR_SUCCESS != RegSetValueEx(hkeyService, _T("Start"), 0, REG_DWORD, (LPBYTE)&StartType, sizeof(StartType)))                ||
             (fServiceHasTag ? (ERROR_SUCCESS != RegSetValueEx(hkeyService, pszTag, 0, REG_DWORD, (CONST LPBYTE)&TagId, sizeof(TagId))) : TRUE)    || 
             (ERROR_SUCCESS != RegSetValueEx(hkeyService, pszErrorControl, 0, REG_DWORD, (CONST LPBYTE)&ErrorControl, sizeof(ErrorControl))) 
           )
           return ERROR_CANTWRITE;

    
        //
        // Now write the optional service key entries.
        //
        if ( (ERROR_SUCCESS != RegSetValueEx(hkeyService, pszDisplayName, 0, REG_SZ, (CONST LPBYTE)szDisplayName, sizeof(szDisplayName)/sizeof(szDisplayName[0]) + sizeof(TCHAR))) ||
             (ERROR_SUCCESS != RegSetValueEx(hkeyService, pszLoadOrderGroup, 0, REG_SZ, (CONST LPBYTE)szLoadOrderGroup, sizeof(szLoadOrderGroup)/sizeof(szLoadOrderGroup[0]) + sizeof(TCHAR)))  ||
             (ERROR_SUCCESS != RegSetValueEx(hkeyService, pszSecurity, 0, REG_SZ, (CONST LPBYTE)szSecurity, sizeof(szSecurity)/sizeof(szSecurity[0]) + sizeof(TCHAR))) ||
             (ERROR_SUCCESS != RegSetValueEx(hkeyService, pszDescription, 0, REG_SZ, (CONST LPBYTE)szDescription, sizeof(szDescription)/sizeof(szDescription[0]) + sizeof(TCHAR))) ||
             (ERROR_SUCCESS != RegSetValueEx(hkeyService, _T("ImagePath"), 0, REG_SZ, (CONST LPBYTE)szServiceBinary, sizeof(szServiceBinary)/sizeof(szServiceBinary[0]) + sizeof(TCHAR)))
           )
           return ERROR_CANTWRITE;
    }
    else // Service is already installed.
    {
        //
        // Set the service's start type to what is in the INF.
        //
        if ( ERROR_SUCCESS != RegSetValueEx(hkeyService, _T("Start"), 0, REG_DWORD, (LPBYTE)&StartType, sizeof(StartType)) )
            return ERROR_CANTWRITE;
    }

    return dwReturn;
}


DWORD AddService(
    LPTSTR   lpszServiceName,            // Name of the service (as it appears under HKLM\System\CCS\Services).
    LPTSTR   lpszServiceSection,         // Name of the .Service section.
    LPTSTR   lpszServiceInfInstallFile,  // Name of the service inf file.
    HKEY     hkeyRoot                    // Handle to the offline hive key to use as HKLM when checking for and installing the service.
    )
/*++

Routine Description:

    This function checks if service exists, if not adds the service and registry settings to offline hive.

Arguments:

    hServiceInf - Handle to the inf the service section will be in.

    lpszServiceName - Name of the service (as it appears under HKLM,System\CCS\Services).

    lpszServiceSection - xxxx.Service section in the inf that has the AddService.

    lpszServiceInfInstallFile -  Name of the service inf file.

    hkeyRoot - Handle to the offline hive key to use as HKLM\System when checking for and installing the service.

Return Value:

    ERROR_SUCCESS - Successfully added the service keys or service already exists.

--*/
{
    HKEY  hKeyServices                  = NULL;
    TCHAR szServicesKeyPath[MAX_PATH]   = _T("ControlSet001\\Services\\");
    DWORD dwAction, 
          dwReturn                      = ERROR_SUCCESS;
    BOOL  bServiceExists                = FALSE;

    //
    // Check valid arguments.
    //
    if (!lpszServiceName || !lpszServiceSection || !lpszServiceInfInstallFile || !hkeyRoot)
        return ERROR_INVALID_PARAMETER;

    //
    // Build the path to the specific service key.
    //
    lstrcat(szServicesKeyPath, lpszServiceName);

    // 
    // Check if lpszServiceName already exists.
    //
    if ( ERROR_SUCCESS == ( dwReturn = RegOpenKeyEx(hkeyRoot, szServicesKeyPath, 0l, KEY_READ | KEY_WRITE, &hKeyServices) ) )
    {
        // We need to figure out the service start type and put change that.
        // This is to fix the case where the service is already installed and it is disabled. We need to enable it.
        //
        bServiceExists = TRUE;
    }
    else if ( ERROR_SUCCESS == (dwReturn = RegCreateKeyEx(hkeyRoot, 
                       szServicesKeyPath, 
                       0, 
                       NULL, 
                       REG_OPTION_NON_VOLATILE, 
                       KEY_ALL_ACCESS,
                       NULL,
                       &hKeyServices,
                       &dwAction) ) ) 
    {
        bServiceExists = FALSE;
    }
    
    //
    // If we opened or created the services key try to add the service, or modify the start type of the currently installed service.
    //

    if ( hKeyServices ) 
    {
        HINF  hInf = NULL;
        UINT  uError = 0;
        
        //
        // Reinitialize this in case it was set to something else above.
        //
        dwReturn = ERROR_SUCCESS;
    
        if ( INVALID_HANDLE_VALUE != ( hInf = SetupOpenInfFile(lpszServiceInfInstallFile, NULL, INF_STYLE_WIN4|INF_STYLE_OLDNT, &uError) ) )
        {     
            BOOL bRet;
            BOOL bFound = FALSE;
            INFCONTEXT InfContext;
            TCHAR szServiceBuffer[MAX_PATH];

            //
            // Find the section appropriate to the passed in service name.
            //
            bRet = SetupFindFirstLine(hInf, lpszServiceSection, _T("AddService"), &InfContext);
            while (bRet && !bFound)
            {
                //
                // Initialize the buffer that gets the service name so we can see if it's the one we want
                //
                ZeroMemory(szServiceBuffer, sizeof(szServiceBuffer));

                //
                // Call SetupGetStringField to get the service name for this AddService entry.
                // May have more than one AddService.
                //
                bRet = SetupGetStringField(&InfContext, 1, szServiceBuffer, sizeof(szServiceBuffer)/sizeof(szServiceBuffer[0]), NULL);
                if ( bRet && *szServiceBuffer && !lstrcmpi(szServiceBuffer, lpszServiceName) )
                {
                    //
                    // Initialize the buffer that gets the real service section for this service
                    //
                    ZeroMemory(szServiceBuffer, sizeof(szServiceBuffer));

                    //
                    // Call SetupGetStringField to get the real service section for our service
                    //
                    bRet = SetupGetStringField(&InfContext, 3, szServiceBuffer, sizeof(szServiceBuffer)/sizeof(szServiceBuffer[0]), NULL);
                    if (bRet && *szServiceBuffer)
                    {
                        //
                        // Populate this service's registry keys.
                        //
                        dwReturn = PopulateServiceKeys(hInf, szServiceBuffer, lpszServiceName, hKeyServices, bServiceExists);
                    }

                    bFound = TRUE;
                }

                //
                // We didn't find it, so keep looking!
                //
                if (!bFound)
                {
                    bRet = SetupFindNextLine(&InfContext, &InfContext);
                }
            }

            SetupCloseInfFile(hInf);
        }
        else
        {
            dwReturn = GetLastError();
        }
        
        // Close the key we created/opened.
        //               
        RegCloseKey(hKeyServices);
    }
    
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\lib\msdinst\main.h ===
/****************************************************************************\

    MAIN.H / Mass Storage Device Installer (MSDINST.LIB)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Main internal header file for the MSD Installation library.

    08/2001 - Jason Cohen (JCOHEN)

        Added this new header file for the new MSD Isntallation project.
        Contains all the prototypes and other defines that are needed
        internally.

\****************************************************************************/


#ifndef _MAIN_H_
#define _MAIN_H_


//
// Private Exported Function Prototype(s):
//


// From OFFLINE.C:
//
BOOL OfflineCommitFileQueue(HSPFILEQ hFileQueue, LPTSTR lpInfPath, LPTSTR lpSourcePath, LPTSTR lpOfflineWindowsDirectory );

// From ADDSVC.C:
//
DWORD AddService(
    LPTSTR   lpszServiceName,            // Name of the service (as it appears under HKLM\System\CCS\Services).
    LPTSTR   lpszServiceInstallSection,  // Name of the service install section.
    LPTSTR   lpszServiceInfInstallFile,  // Name of the service inf file.
    HKEY     hkeyRoot                    // Handle to the offline hive key to use as HKLM when checking for and installing the service.
    );


#endif // _MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\lib\msdinst\makefile.inc ===
# Copy the generated lib to our lib folder so people can include it.
#
$(OPK_LIB_PATH)\$(TARGETNAME).lib: $(O)\$(TARGETNAME).lib
    if not exist $(OPK_LIB_PATH)\nul md $(OPK_LIB_PATH)
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\lib\msdinst\pch.h ===
/****************************************************************************\

    PCH.H / Mass Storage Device Installer (MSDINST.LIB)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Precompiled Header file for the MSD Installation library.

    07/2001 - Jason Cohen (JCOHEN)

        Added this new header file for the new MSD Isntallation project.

\****************************************************************************/


#ifndef _PCH_H_
#define _PCH_H_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//#include <ntsam.h>
//#include <ntlsa.h>
#include <windows.h>

#include <tchar.h>
#include <shlwapi.h>

//#include <stdlib.h>
//#include <stdio.h>
//#include <string.h>

#include <setupapi.h>
//#include <syssetup.h>

#include <opklib.h>
#include <msdres.h>
#include <msdinst.h>

#endif // _PCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\lib\msdinst\loadhive.c ===
/****************************************************************************\

    LOADHIVE.C / Mass Storage Device Installer (MSDINST.LIB)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file the MSD Installation library which contains the functions
    used to manipulate the offline registry hives.

    07/2001 - Jason Cohen (JCOHEN)

        Added this new source file for the new MSD Installation project.

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"


//
// Local Define(s):
//

#define FILE_BOOT_INI           _T("boot.ini")
#define INI_SEC_BOOTLDR         _T("boot loader")
#define INI_KEY_BOOTDEFAULT     _T("default")

#define HIVE_SOFTWARE           _T("{dcc62fd6-8739-4d15-9d47-3dbe9d86dbfe}")
#define HIVE_SYSTEM             _T("{7ebc3661-e661-4943-95a5-412378cb16d1}")

#define FILE_SOFTWARE           _T("SOFTWARE")
#define FILE_SYSTEM             _T("SYSTEM")

#define DIR_REGISTRY            _T("config")
#define DIR_SYSTEM              _T("system32")
#define DIR_SYSTEM_REGISTRY     DIR_SYSTEM _T("\\") DIR_REGISTRY
#define REG_KEY_OFFLINE         _T("SOFTWARE\\")

#define LIST_SOFTWARE           0
#define LIST_SYSTEM             1


//
// Local Type Define(s):
//

typedef struct _HIVELIST
{
    PHKEY   phkey;
    LPTSTR  lpszHiveName;
    LPTSTR  lpszHiveFile;
}
HIVELIST, *PHIVELIST, *LPHIVELIST;


//
// Local Global(s):
//

static HIVELIST s_HiveList[] =
{
    { NULL, HIVE_SOFTWARE,  FILE_SOFTWARE   },
    { NULL, HIVE_SYSTEM,    FILE_SYSTEM     },
};


//
// Local Prototype(s):
//

static BOOL MyEnablePrivilege(LPTSTR lpszPrivilege, BOOL bEnable);

static BOOL
RegDoOneHive(
    LPTSTR lpszHiveName,
    LPTSTR lpszHiveFile,
    BOOL bCheckOnly,
    PHKEY phkey
    );

static BOOL
RegDoAllHives(
    LPTSTR  lpszWindows
    );

static BOOL CheckSystem(LPTSTR lpszSysDir, DWORD cbSysDir, BOOL bLoadHive);
static BOOL FindSystem(LPTSTR lpszSysDir, DWORD cbSysDir, DWORD dwIndex, BOOL bLoadHive);


//
// Exported Funtion(s):
//

BOOL
RegLoadOfflineImage(
    LPTSTR  lpszWindows,
    PHKEY   phkeySoftware,
    PHKEY   phkeySystem
    )
{
    HKEY    hkeyLM = NULL;
    DWORD   dwDis;
    BOOL    bRet = FALSE;

    // We need to init all the key pointers passed in.
    //
    if ( phkeySoftware )
    {
        *phkeySoftware = NULL;
        bRet = TRUE;
    }
    if ( phkeySystem )
    {
        *phkeySystem = NULL;
        bRet = TRUE;
    }

    // Make sure they wanted at least one key loaded.
    //
    if ( !bRet )
    {
        return FALSE;
    }

    // We need this privilege to load the hives.
    // 
    if ( !MyEnablePrivilege(SE_RESTORE_NAME, TRUE) )
    {
        return FALSE;
    }

    // Now try to load all the hives they wanted.
    //
    s_HiveList[LIST_SOFTWARE].phkey = phkeySoftware;
    s_HiveList[LIST_SYSTEM].phkey = phkeySystem;
    bRet = RegDoAllHives(lpszWindows);

    // Set the privilege back to the default.
    //
    MyEnablePrivilege(SE_RESTORE_NAME, FALSE);

    // Return TRUE if everything worked out okay.
    //
    return bRet;
}

BOOL
RegUnloadOfflineImage(
    HKEY hkeySoftware,
    HKEY hkeySystem
    )
{
    BOOL bRet = TRUE;

    // If there is nothing to unload, just return.
    //
    if ( !( hkeySoftware || hkeySystem ) )
    {
        return TRUE;
    }

    // We need this privilege to unload the hives.
    //
    if ( !MyEnablePrivilege(SE_RESTORE_NAME, TRUE) )
    {
        return FALSE;
    }

    // Try to unload the hives in the key passed in.
    //
    s_HiveList[LIST_SOFTWARE].phkey = hkeySoftware ? &hkeySoftware : NULL;
    s_HiveList[LIST_SYSTEM].phkey = hkeySystem ? &hkeySystem : NULL;
    bRet = RegDoAllHives(NULL);

    // Set the privilege back to the default.
    //
    MyEnablePrivilege(SE_RESTORE_NAME, FALSE);

    // Return TRUE if everything worked out okay.
    //
    return bRet;
}


//
// Local Function(s):
//

static BOOL MyEnablePrivilege(LPTSTR lpszPrivilege, BOOL bEnable)
{
    HANDLE              hToken;
    TOKEN_PRIVILEGES    tp;
    BOOL                bRet = FALSE;

    // First obtain the processes token.
    // 
    if ( OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken) )
    {
        // Get the luid
        // 
        if ( LookupPrivilegeValue(NULL, lpszPrivilege, &tp.Privileges[0].Luid) )
        {
            tp.PrivilegeCount = 1;
            tp.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;

            // Enable or disable the privilege.
            // 
            bRet = AdjustTokenPrivileges(hToken, FALSE, &tp, 0, (PTOKEN_PRIVILEGES) NULL, 0);

            //
            // The return value of AdjustTokenPrivileges() can be true even though we didn't set all
            // the privileges that we asked for.  We need to call GetLastError() to make sure the call succeeded.
            //
            bRet = bRet && ( ERROR_SUCCESS == GetLastError() );
        }

        CloseHandle(hToken);
    }

    return bRet;

}

static BOOL
RegDoOneHive(
    LPTSTR lpszHiveName,
    LPTSTR lpszHiveFile,
    BOOL bCheckOnly,
    PHKEY phkey
    )
{
    BOOL bRet = TRUE;

    // Hive name can not be NULL.
    //
    if ( NULL == lpszHiveName )
    {
        return FALSE;
    }

    // If there is a file to load, we are loading, otherwise we are
    // unloading the key.
    //
    if ( lpszHiveFile )
    {
        // Try to load up the key.
        //
        if ( ( FileExists(lpszHiveFile) ) &&
             ( ERROR_SUCCESS == RegLoadKey(HKEY_LOCAL_MACHINE, lpszHiveName, lpszHiveFile) ) )
        {
            // See if we are just checking to make sure the hive
            // exists and we can load it.
            //
            if ( bCheckOnly )
            {
                // NULL these out so we unload the key.
                //
                lpszHiveFile = NULL;
                phkey = NULL;
            }
            else if ( ( phkey ) &&
                      ( ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszHiveName, 0, KEY_ALL_ACCESS, phkey) ) )
            {
                // Have to return an error if we couldn't open the key.
                //
                bRet = FALSE;

                // Also have to NULL out these values so we unload
                // the key.
                //
                lpszHiveFile = NULL;
                phkey = NULL;
            }
        }
        else
        {
            // Do'h, that sucks.  Return FALSE.
            //
            bRet = FALSE;
        }
    }

    // Now check to see if we need to unload the key.
    //
    if ( NULL == lpszHiveFile )
    {
        // First close the key if there is one they passed
        // in.
        //
        if ( phkey && *phkey )
        {
            RegCloseKey(*phkey);
            *phkey = NULL;
        }

        // Now try to unload the key.
        //
        if ( ERROR_SUCCESS != RegUnLoadKey(HKEY_LOCAL_MACHINE, lpszHiveName) )
        {
            bRet = FALSE;
        }
    }

    // Return TRUE if there were no errors.
    //
    return bRet;
}

static BOOL
RegDoAllHives(
    LPTSTR  lpszWindows
    )
{
    BOOL    bRet    = TRUE,
            bLoad   = FALSE,
            bUndo   = FALSE;
    TCHAR   szHiveFile[MAX_PATH];
    LPTSTR  lpszEnd;
    DWORD   dwIndex;

    // See if we need to load the files.
    //
    if ( lpszWindows )
    {
        // If we are loading, init our file buffers.
        //
        bLoad = TRUE;
        lstrcpyn(szHiveFile, lpszWindows, AS(szHiveFile));
        AddPathN(szHiveFile, DIR_SYSTEM_REGISTRY, AS(szHiveFile));
        lpszEnd = szHiveFile + lstrlen(szHiveFile);
    }

    // Loop through all the hives we might have to load/unload.
    //
    for ( dwIndex = 0; dwIndex < AS(s_HiveList); dwIndex++ )
    {
        // Now, we only do anything if there is a pointer to the registry key.  Then
        // only if we are loading or we are unloading and there is something in that pointer.
        //
        if ( ( s_HiveList[dwIndex].phkey ) &&
             ( bLoad || *(s_HiveList[dwIndex].phkey) ) )
        {
            // If we are loading, setup the full path to the file.
            //
            if ( bLoad )
            {
                AddPathN(szHiveFile, s_HiveList[dwIndex].lpszHiveFile, AS(szHiveFile));
            }

            // Try to load/unload the hive.
            //
            if ( !RegDoOneHive(s_HiveList[dwIndex].lpszHiveName, bLoad ? szHiveFile : NULL, FALSE, s_HiveList[dwIndex].phkey) )
            {
                // Failure, so set the return to FALSE.  We also have to do
                // some other stuff if we are doing a load.
                //
                bRet = FALSE;
                if ( bLoad )
                {
                    // See if we have already loaded anything.
                    //
                    if ( bUndo )
                    {
                        // We did, so we have to clean up what we loaded.
                        //
                        RegDoAllHives(NULL);
                    }

                    // Now get out of the loop because we quit once one load fails.
                    //
                    break;
                }
            }
            else
            {
                // We have loaded something, so in case of an error
                // we need to know if there is anything to cleanup.
                //
                bUndo = TRUE;
            }

            // Chop off the file name if we added it.
            //
            if ( bLoad )
            {
                *lpszEnd = NULLCHR;
            }
        }
    }

    // Return TRUE if everything went okay.
    //
    return bRet;
}

#if 0
static BOOL CheckSystem(LPTSTR lpszSysDir, DWORD cbSysDir, BOOL bLoadHive)
{
    BOOL    bRet            = FALSE;
    TCHAR   szSystem[MAX_PATH],
            szValue[256];
    LPTSTR  lpszBootIni,
            lpszFolder,
            lpszNewSysDir   = lpszSysDir;

    // If they gave us room to return something, we can look for a BOOT.INI and
    // search for the where the system drive is.
    //
    if ( cbSysDir )
    {
        // See if there is a BOOT.INI file on the drive.
        //
        lstrcpyn(szSystem, lpszSysDir, AS(szSystem));
        lpszBootIni = szSystem + lstrlen(szSystem);
        AddPathN(szSystem, FILE_BOOT_INI, AS(szSystem));
        if ( FileExists(szSystem) )
        {
            // Need the name of the folder out of the boot.ini.
            //
            szValue[0] = NULLCHR;
            GetPrivateProfileString(INI_SEC_BOOTLDR, INI_KEY_BOOTDEFAULT, NULLSTR, szValue, AS(szValue), szSystem);
            if ( lpszFolder = StrChr(szValue, _T('\\')) )
            {
                // Add our system folder we found to the path passed in.
                //
                *lpszBootIni = NULLCHR;
                AddPathN(szSystem, lpszFolder, AS(szSystem));

                // Make sure there is enough room to return the path we found.
                //
                if ( (DWORD) lstrlen(szSystem) < cbSysDir )
                {
                    lpszNewSysDir = szSystem;
                }
            }
        }
    }

    // Make sure the folder and hives exist.
    //
    if ( DirectoryExists(lpszNewSysDir) &&
         HiveEngine(lpszNewSysDir, bLoadHive) )
    {
        bRet = TRUE;
        if ( lpszNewSysDir != lpszSysDir )
        {
            lstrcpy(lpszSysDir, lpszNewSysDir);
        }
    }

    return bRet;
}

static BOOL FindSystem(LPTSTR lpszSysDir, DWORD cbSysDir, DWORD dwIndex, BOOL bLoadHive)
{
    DWORD   dwDrives;
    TCHAR   szSystem[MAX_PATH],
            szDrive[]           = _T("_:\\");
    BOOL    bFound              = FALSE;

    // Loop through all the drives on the system.
    //
    for ( szDrive[0] = _T('A'), dwDrives = GetLogicalDrives();
          ( szDrive[0] <= _T('Z') ) && dwDrives && !bFound;
          szDrive[0]++, dwDrives >>= 1 )
    {
        // First check to see if the first bit is set (which means
        // this drive exists in the system).  Then make sure it is
        // a fixed drive.
        //
        if ( ( dwDrives & 0x1 ) &&
             ( GetDriveType(szDrive) == DRIVE_FIXED ) )
        {
            lstrcpy(szSystem, szDrive);
            if ( CheckSystem(szSystem, AS(szSystem), bLoadHive) )
            {
                // Only stop if this the nth system they wanted
                // returned.  Used so you can enumerate all the systems
                // on all the drives.
                //
                if ( 0 == dwIndex )
                {
                    // Return the path to the system directory in the
                    // supplied buffer.
                    //
                    lstrcpyn(lpszSysDir, szSystem, cbSysDir);
                    bFound = TRUE;
                }
                else
                {
                    // If we are skipping this system because of the index,
                    // make sure we unload the hives if we loaded them.
                    //
                    if ( bLoadHive )
                    {
                        //UnloadHives();
                    }
                    dwIndex--;
                }
            }
        }
    }

    return bFound;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\msdinst\pch.h ===
/****************************************************************************\

    PCH.H / Mass Storage Device Installer (MSDINST.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Precompiled Header file for the MSD Installation tool.

    07/2001 - Jason Cohen (JCOHEN)

        Added this new header file for the new MSD Installation project.

\****************************************************************************/


#ifndef _PCH_H_
#define _PCH_H_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//#include <ntsam.h>
//#include <ntlsa.h>
#include <windows.h>

#include <tchar.h>
#include <shlwapi.h>

//#include <stdlib.h>
//#include <stdio.h>
//#include <string.h>

//#include <setupapi.h>

#include <opklib.h>


#endif // _PCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\msdinst\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#define IDS_ARGS                        1
#define IDS_ERR_LOADIMAGE               2
#define IDS_ERR_MISSING_INF_FILE        3
#define IDS_ERR_MISSING_INF_SECTION     4
#define IDS_ERR_CDD                     5
#define IDS_ERR_NOWINDOWS               6
#define IDS_ERR_WINPE                   7
#define IDS_ERR_ONEONLY                 8
#define IDS_ERR_SUCCESS                 9
#define IDI_MAIN                        102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\lib\msdinst\offline.c ===
#include "pch.h"
#ifndef FileExists
#undef FileExists
#endif
#include <setupntp.h>
#include "winbom.h"

//
// Context for file queues in the offline installer.
//
typedef struct _OFFLINE_QUEUE_CONTEXT {
    PVOID   DefaultContext;
    PWSTR   InfPath;
    PWSTR   OfflineWindowsDirectory;
    PWSTR   OfflineSourcePath;
    PWSTR   TemporaryFilePath;
} OFFLINE_QUEUE_CONTEXT, *POFFLINE_QUEUE_CONTEXT;

//
// Context for Cosma's SetupIterateCabinet calls
//
typedef struct _COSMA_CONTEXT
{
    TCHAR   szSourceFile[MAX_PATH];
    TCHAR   szDestination[MAX_PATH];
} COSMA_CONTEXT, *PCOSMA_CONTEXT;

// 
// Local function declarations
//
static BOOL
ValidateAndChecksumFile(
    IN  PCWSTR   Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    );

static VOID
MungeNode( 
    IN PSP_FILE_QUEUE Queue,  
    IN PSP_FILE_QUEUE_NODE QueueNode, 
    IN LPTSTR lpWindowsDirectory, 
    IN LPTSTR lpOfflineWindowsDirectory);

static VOID 
MungeQueuePaths(
    IN HSPFILEQ hFileQueue, 
    IN LPTSTR lpWindowsDirectory, 
    IN LPTSTR lpOfflineWindowsDirectory);

static UINT
CosmaMsgHandler(
    IN PVOID    Context,
    IN UINT     Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

static UINT
FixCopyQueueStuff(
    IN POFFLINE_QUEUE_CONTEXT OfflineContext,
    IN LPTSTR                 lpszSourceFile,
    IN OUT LPTSTR             lpszDestination
    );

static UINT
OfflineQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

static VOID
FreeOfflineContext(
    IN PVOID Context
    );

static PVOID
InitOfflineQueueCallback(
    VOID
    );

//
// Exported functions:
//

BOOL OfflineCommitFileQueue(HSPFILEQ hFileQueue, LPTSTR lpInfPath, LPTSTR lpSourcePath, LPTSTR lpOfflineWindowsDirectory )
{

    POFFLINE_QUEUE_CONTEXT  pOfflineContext;
    DWORD                   dwSize;
    TCHAR                   szWindowsDirectory[MAX_PATH]        = NULLSTR;
    BOOL                    bRet                                = FALSE;
        
    if (INVALID_HANDLE_VALUE != hFileQueue && GetWindowsDirectory(szWindowsDirectory, AS(szWindowsDirectory)))
    {
        DWORD dwResult = 0;

        // If we're not doing an offline install this will be NULL so we won't do any funky
        // stuff.
        //
        if ( lpOfflineWindowsDirectory )
        {
            pSetupSetGlobalFlags(pSetupGetGlobalFlags() | PSPGF_NO_VERIFY_INF | PSPGF_NO_BACKUP);

            // Redirect the target directories to the offline image
            //
            MungeQueuePaths(hFileQueue, szWindowsDirectory, lpOfflineWindowsDirectory);
        }

        // Init our special Callback and context. 
        //
        if ( pOfflineContext = (POFFLINE_QUEUE_CONTEXT) InitOfflineQueueCallback() )
        {   
            TCHAR szInfPath[MAX_PATH] = NULLSTR;

            if ( lpInfPath )
            {
                lstrcpy(szInfPath, lpInfPath);
            }
            
            //
            // Set the OfflineWindowsDirectory member of the Context structure
            //
            pOfflineContext->OfflineWindowsDirectory = lpOfflineWindowsDirectory;
            pOfflineContext->InfPath                 = szInfPath;
            pOfflineContext->OfflineSourcePath       = lpSourcePath;

            //
            // Commit the file queue
            //
            if ( SetupCommitFileQueue(NULL, hFileQueue, OfflineQueueCallback, pOfflineContext)) 
            {
                bRet = TRUE;
            }
        
            FreeOfflineContext(pOfflineContext);
        }
    }
    
    return bRet;
}


//
// Internal functions:
//

static BOOL
ValidateAndChecksumFile(
    IN  PCWSTR   Filename,
    OUT PBOOLEAN IsNtImage,
    OUT PULONG   Checksum,
    OUT PBOOLEAN Valid
    )

/*++
===============================================================================

Routine Description:

    Calculate a checksum value for a file using the standard
    nt image checksum method.  If the file is an nt image, validate
    the image using the partial checksum in the image header.  If the
    file is not an nt image, it is simply defined as valid.

    If we encounter an i/o error while checksumming, then the file
    is declared invalid.

Arguments:

    Filename - supplies full NT path of file to check.

    IsNtImage - Receives flag indicating whether the file is an
                NT image file.

    Checksum - receives 32-bit checksum value.

    Valid - receives flag indicating whether the file is a valid
            image (for nt images) and that we can read the image.

Return Value:

    BOOL - Returns TRUE if the file was validated, and in this case,
           IsNtImage, Checksum, and Valid will contain the result of
           the validation.
           This function will return FALSE, if the file could not be
           validated, and in this case, the caller should call GetLastError()
           to find out why this function failed.

===============================================================================
--*/

{
DWORD           Error;
PVOID           BaseAddress;
ULONG           FileSize;
HANDLE          hFile;
HANDLE          hSection;
PIMAGE_NT_HEADERS NtHeaders;
ULONG           HeaderSum;


    //
    // Assume not an image and failure.
    //
    *IsNtImage = FALSE;
    *Checksum = 0;
    *Valid = FALSE;

    //
    // Open and map the file for read access.
    //

    Error = pSetupOpenAndMapFileForRead( Filename,
                                        &FileSize,
                                        &hFile,
                                        &hSection,
                                        &BaseAddress );

    if( Error != ERROR_SUCCESS ) {
        SetLastError( Error );
        return(FALSE);
    }

    if( FileSize == 0 ) {
        *IsNtImage = FALSE;
        *Checksum = 0;
        *Valid = TRUE;
        CloseHandle( hFile );
        return(TRUE);
    }


    try {
        NtHeaders = CheckSumMappedFile(BaseAddress,FileSize,&HeaderSum,Checksum);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        *Checksum = 0;
        NtHeaders = NULL;
    }

    //
    // If the file is not an image and we got this far (as opposed to encountering
    // an i/o error) then the checksum is declared valid.  If the file is an image,
    // then its checksum may or may not be valid.
    //

    if(NtHeaders) {
        *IsNtImage = TRUE;
        *Valid = HeaderSum ? (*Checksum == HeaderSum) : TRUE;
    } else {
        *Valid = TRUE;
    }

    pSetupUnmapAndCloseFile( hFile, hSection, BaseAddress );
    return( TRUE );
}

/*
VOID
LogRepairInfo(
    IN  PWSTR  Source,
    IN  PWSTR  Target,
    IN  PWSTR  DirectoryOnSourceDevice,
    IN  PWSTR  DiskDescription,
    IN  PWSTR  DiskTag
    )
++
===============================================================================
Routine Description:

    This function will log the fact that a file was installed into the
    machine.  This will enable Windows repair functionality to be alerted
    that in case of a repair, this file will need to be restored.

Arguments:


Return Value:


===============================================================================
--
{
WCHAR           RepairLog[MAX_PATH];
BOOLEAN         IsNtImage;
ULONG           Checksum;
BOOLEAN         Valid;
WCHAR           Filename[MAX_PATH];
WCHAR           SourceName[MAX_PATH];
DWORD           LastSourceChar, LastTargetChar;
DWORD           LastSourcePeriod, LastTargetPeriod;
WCHAR           Line[MAX_PATH];
WCHAR           tmp[MAX_PATH];


    if (!GetWindowsDirectory( RepairLog, MAX_PATH ))
        return;

    wcscat( RepairLog, L"\\repair\\setup.log" );

    if( ValidateAndChecksumFile( Target, &IsNtImage, &Checksum, &Valid )) {

        //
        // Strip off drive letter.
        //
        swprintf(
            Filename,
            L"\"%s\"",
            Target+2
            );

        //
        // Convert source name to uncompressed form.
        //
        wcscpy( SourceName, wcsrchr( Source, (WCHAR)'\\' ) + 1 );

        if(!SourceName) {
            return;
        }
        LastSourceChar = wcslen (SourceName) - 1;

        if(SourceName[LastSourceChar] == L'_') {
            LastSourcePeriod = (DWORD)(wcsrchr( SourceName, (WCHAR)'.' ) - SourceName);

            if(LastSourceChar - LastSourcePeriod == 1) {
                //
                // No extension - just truncate the "._"
                //
                SourceName[LastSourceChar-1] = NULLCHR;
            } else {
                //
                // Make sure the extensions on source and target match.
                // If this fails, we can't log the file copy
                //
                LastTargetChar = wcslen (Target) - 1;
                LastTargetPeriod = (ULONG)(wcsrchr( Target, (WCHAR)'.' ) - Target);

                if( _wcsnicmp(
                    SourceName + LastSourcePeriod,
                    Target + LastTargetPeriod,
                    LastSourceChar - LastSourcePeriod - 1 )) {
                    return;
                }

                if(LastTargetChar - LastTargetPeriod < 3) {
                    //
                    // Short extension - just truncate the "_"
                    //
                    SourceName[LastSourceChar] = NULLCHR;
                } else {
                    //
                    // Need to replace "_" with last character from target
                    //
                    SourceName[LastSourceChar] = Target[LastTargetChar];
                }
            }
        }

        //
        // Write the line.
        //
        if( (DirectoryOnSourceDevice) &&
            (DiskDescription) &&
            (DiskTag) ) {

            //
            // Treat this as an OEM file.
            //
            swprintf( Line,
                      L"\"%s\",\"%x\",\"%s\",\"%s\",\"%s\"",
                      SourceName,
                      Checksum,
                      DirectoryOnSourceDevice,
                      DiskDescription,
                      DiskTag );

        } else {

            //
            // Treat this as an "in the box" file.
            //
            swprintf( Line,
                      L"\"%s\",\"%x\"",
                      SourceName,
                      Checksum );
        }

        if (GetPrivateProfileString(L"Files.WinNt",Filename,L"",tmp,sizeof(tmp)/sizeof(tmp[0]),RepairLog)) {
            //
            // there is already an entry for this file present (presumably
            // from textmode phase of setup.) Favor this entry over what we
            // are about to add
            //
        } else {
            WritePrivateProfileString(
                L"Files.WinNt",
                Filename,
                Line,
                RepairLog);
        }

    }
}
*/

static VOID
MungeNode( 
    IN PSP_FILE_QUEUE Queue,  
    IN PSP_FILE_QUEUE_NODE QueueNode, 
    IN LPTSTR lpWindowsDirectory, 
    IN LPTSTR lpOfflineWindowsDirectory)
{
    LONG                lNewId = 0;
    TCHAR               szTempTarget[MAX_PATH];
    PTSTR               pOldTarget = pSetupStringTableStringFromId(Queue->StringTable, QueueNode->TargetDirectory);

#ifdef DBG
    // These are here for debugging purposes.  We can look at 
    //
    PTSTR pSourcePath       = pSetupStringTableStringFromId(Queue->StringTable, QueueNode->SourcePath);
    PTSTR pSourceFilename   = pSetupStringTableStringFromId(Queue->StringTable, QueueNode->SourceFilename);
    PTSTR pTargetFilename   = pSetupStringTableStringFromId(Queue->StringTable, QueueNode->TargetFilename);
#endif

    if ( pOldTarget ) 
    {
        // See if the WindowsDirectory is part of the target.  If so replace it 
        // with the OfflineWindowsDirectory.
        //
        if ( StrStrI(pOldTarget, lpWindowsDirectory) )
        {
            // We found the windows directory in the name. Replace it with our own.
            //
            lstrcpyn(szTempTarget, lpOfflineWindowsDirectory, MAX_PATH);
            StrCatBuff(szTempTarget, pOldTarget + lstrlen(lpWindowsDirectory), MAX_PATH);
        }
            // If the target is not a subdir of the windows directory just redirect the 
            // drive to the offline drive.
            // Look at the first letter to see if it's the same letter as the
            // current WindowsDirectory drive letter.
            //
        else if( *pOldTarget == *lpWindowsDirectory )
        {
    
            // Strip off the windows directory from the offline directory name,
            // use the buffer and then put the windows directory back on.
            // I am assuming here that the windows directory is at the root of 
            // a drive (this is pretty reasonable).
            //
            LPTSTR lpWhack = _tcsrchr(lpOfflineWindowsDirectory, _T('\\')); 
            
            if ( lpWhack )
            {
                *lpWhack = NULLCHR;
                lstrcpyn(szTempTarget, lpOfflineWindowsDirectory, MAX_PATH);
                *lpWhack = _T('\\');
                
                // Now copy every thing past the drive letter and : to the buffer
                // and we will have a good path.
                //
                StrCatBuff(szTempTarget, pOldTarget + 2, MAX_PATH);  // Skip the drive letter and the :.
            } 
        }
            // Add the new target string to the StringTable and
            // set the TargetDirectory to the new string ID.
            // 
            lNewId = pSetupStringTableAddString(Queue->StringTable, szTempTarget, 0);
            QueueNode->TargetDirectory = lNewId;
    }    
}


static VOID 
MungeQueuePaths(
    IN HSPFILEQ hFileQueue, 
    IN LPTSTR   lpWindowsDirectory, 
    IN LPTSTR   lpOfflineWindowsDirectory)
{
    PSP_FILE_QUEUE      Queue;
    PSOURCE_MEDIA_INFO  SourceMedia;
    PSP_FILE_QUEUE_NODE QueueNode;
        
    // The queue handle is nothing more than a pointer to the queue.
    //
    Queue = (PSP_FILE_QUEUE)hFileQueue;
    
    // Lie to setupapi: tell it that the queue catalogs have already been verified succesfuly.
    //
    Queue->Flags &= ~FQF_DID_CATALOGS_FAILED;
    Queue->Flags |= FQF_DID_CATALOGS_OK;
    Queue->DriverSigningPolicy = DRIVERSIGN_NONE;

    // Go through all SourceMediaLists and through each CopyQueue withing those.
    //
    for ( SourceMedia=Queue->SourceMediaList; SourceMedia; SourceMedia=SourceMedia->Next ) 
    {
        QueueNode = SourceMedia->CopyQueue;

        while ( QueueNode )
        {
            MungeNode(Queue, QueueNode, lpWindowsDirectory, lpOfflineWindowsDirectory); 

            // Advance to the next node.
            //
            QueueNode = QueueNode->Next;
        }
    }
    
    // Go through the backup queue.
    //
    for ( QueueNode=Queue->BackupQueue; QueueNode; QueueNode=QueueNode->Next ) 
    {
        MungeNode(Queue, QueueNode, lpWindowsDirectory, lpOfflineWindowsDirectory); 
    }
    
    // Go through the delete queue.
    //
    for ( QueueNode=Queue->DeleteQueue; QueueNode; QueueNode=QueueNode->Next ) 
    {
        MungeNode(Queue, QueueNode, lpWindowsDirectory, lpOfflineWindowsDirectory); 
    }
    
    // Go through the rename queue.
    //
    for ( QueueNode=Queue->RenameQueue; QueueNode; QueueNode=QueueNode->Next ) 
    {
        MungeNode(Queue, QueueNode, lpWindowsDirectory, lpOfflineWindowsDirectory); 
    }
}

static UINT
CosmaMsgHandler(
    IN PVOID    Context,
    IN UINT     Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT uRet = NO_ERROR;
    PCOSMA_CONTEXT CosmaContext = (PCOSMA_CONTEXT) Context;

    switch (Notification)
    {
        case SPFILENOTIFY_FILEEXTRACTED:
            {
                PFILEPATHS FilePaths = (PFILEPATHS) Param1;
                
                if (FilePaths)
                {
#if DBG
                    MessageBox(NULL, FilePaths->Source, TEXT("Extracted: Source"), MB_OK);
                    MessageBox(NULL, FilePaths->Target, TEXT("Extracted: Target"), MB_OK);
#endif

                    uRet = NO_ERROR;
                }
            }
            break;

        case SPFILENOTIFY_FILEINCABINET:
            {
                PFILE_IN_CABINET_INFO FileInfo = (PFILE_IN_CABINET_INFO) Param1;

                if (FileInfo)
                {
                    //
                    // If this is the file we want, then we want to extract it!
                    //
                    if ( !lstrcmpi(FileInfo->NameInCabinet, CosmaContext->szSourceFile) )
                    {
                        lstrcpy(FileInfo->FullTargetName, CosmaContext->szDestination);

#if DBG
                        MessageBox(NULL, FileInfo->NameInCabinet,  TEXT("InCabinet: NameInCabinet"),  MB_OK);
                        MessageBox(NULL, FileInfo->FullTargetName, TEXT("InCabinet: FullTargetName"), MB_OK);
#endif

                        uRet = FILEOP_DOIT;
                    }
                    else
                    {
                        uRet = FILEOP_SKIP;
                    }
                }
            }
            break;

        case SPFILENOTIFY_NEEDNEWCABINET:
            {
#if DBG
                MessageBox(NULL, TEXT("Doh!"), TEXT("Need New Cabinet"), MB_OK);
#endif

                uRet = NO_ERROR;
            }
            break;

        default:
            break;
    }

    return uRet;
}

BOOL
ExtractFileFromCabinet(
    IN LPTSTR lpszCabinetPath,
    IN LPTSTR lpszSourceFile,
    IN LPTSTR lpszDestinationPath
    )
{
    BOOL bRet = FALSE;
    COSMA_CONTEXT CosmaContext;

    //
    // Initialize the CosmaContext structure with the paths we need
    //
    ZeroMemory(&CosmaContext, sizeof(CosmaContext));
    lstrcpy(CosmaContext.szSourceFile,  lpszSourceFile);
    lstrcpy(CosmaContext.szDestination, lpszDestinationPath);
    AddPath(CosmaContext.szDestination, lpszSourceFile);

    //
    // Create the directory where we will extract the file
    //
    CreateDirectory(lpszDestinationPath, NULL);

    //
    // Call SetupIterateCabinet to extract a file from the CAB
    //
    if ( SetupIterateCabinet(lpszCabinetPath, 
                             0,
                             (PSP_FILE_CALLBACK) CosmaMsgHandler,
                             (LPVOID) &CosmaContext) && 
         EXIST(CosmaContext.szDestination) )
    {
        //
        // We only return true if we successfully extracted the file
        //
        bRet = TRUE;
    }

    return bRet;
}


static BOOL
IsFileInDrvIndex(
    IN POFFLINE_QUEUE_CONTEXT OfflineContext,
    IN LPTSTR                 lpszSourceFile
    )      
{
    LPTSTR  lpszDrvIndexFile    = TEXT("inf\\drvindex.inf");
    HINF    hInf                = NULL;
    UINT    uError              = 0;
    BOOL    bFound              = FALSE;
    TCHAR   szDrvIndexPath[MAX_PATH];
    

    //
    // Build a path to the offline image's %WINDIR%\\inf\\drvindex.inf
    // We're going to search for this file in the drvindex.inf. If it is there
    // then look for it in the driver.cab in the offline image driver cache and
    // if driver.cab is not found there we look for driver.cab in the sourcepath
    // specified in the offline registry.
    //
    lstrcpy(szDrvIndexPath, OfflineContext->OfflineWindowsDirectory);
    AddPath(szDrvIndexPath, lpszDrvIndexFile);
       

    if ( INVALID_HANDLE_VALUE != ( hInf = SetupOpenInfFile(szDrvIndexPath, NULL, INF_STYLE_WIN4|INF_STYLE_OLDNT, &uError) ) )
    {
        BOOL        bRet                = FALSE;
        INFCONTEXT  InfContext;
        TCHAR       szFileNameBuffer[MAX_PATH];
    
        //
        // Find the section appropriate to the passed in service name.
        //
        bRet = SetupFindFirstLine(hInf, TEXT("driver"), NULL, &InfContext);
    
        while (bRet && !bFound)
        {
            //
            // Initialize the buffer that gets the service name so we can see if it's the one we want
            //
            szFileNameBuffer[0] = NULLCHR;

            //
            // Call SetupGetStringField to get the service name for this AddService entry
            //
            bRet = SetupGetStringField(&InfContext, 0, szFileNameBuffer, AS(szFileNameBuffer), NULL);
            
            if ( bRet && *szFileNameBuffer && !lstrcmpi(szFileNameBuffer, lpszSourceFile) )
            {
                bFound = TRUE;
            }
            else
            {
                bRet = SetupFindNextLine(&InfContext, &InfContext);
            }
        }
    }

    return bFound;

}


static UINT
FixCopyQueueStuff(
    IN POFFLINE_QUEUE_CONTEXT OfflineContext,
    IN LPTSTR                 lpszSourceFile,
    IN OUT LPTSTR             lpszDestination
    )
{
    UINT    uRet = NO_ERROR;
    TCHAR   szNewPath[MAX_PATH];
    
    if ( OfflineContext->InfPath && *OfflineContext->InfPath )
    {
        LPTSTR lpFilePart = NULL;

        // Check wether InfPath is a full path or just an INF name.
        //
        if ( GetFullPathName(OfflineContext->InfPath, AS(szNewPath), szNewPath, &lpFilePart) &&
             lpFilePart && *lpFilePart && lstrcmpi(OfflineContext->InfPath, lpFilePart) )
        {
            // Build a new path to the file inside InfPath.
            //
            *lpFilePart = NULLCHR;
            AddPath(szNewPath, lpszSourceFile);

            //
            // Make sure there is a valid string to play with...
            //
            if ( szNewPath[0] )
            {
                // If the file exists there, return FILEOP_NEWPATH.
                //
                if ( EXIST(szNewPath) )
                {
                    uRet = FILEOP_NEWPATH;
                }
                else
                {
                    // Look for the compressed version of the file as well.
                    //
                    szNewPath[lstrlen(szNewPath) - 1] = TEXT('_');
                    if ( EXIST(szNewPath) )
                    {
                        uRet = FILEOP_NEWPATH;
                    }
                }

                if ( uRet == FILEOP_NEWPATH )
                {
#if DBG
                    MessageBox(NULL, szNewPath, TEXT("INFPATH: WooHoo!!"), MB_OK);
#endif
            
                    if (lpszDestination)
                    {
                        // Cut off the filename.
                        //
                        *lpFilePart = NULLCHR;
                    
                        // Save this in the buffer.
                        //
                        lstrcpy((LPTSTR)lpszDestination, szNewPath);
                    }

                    return uRet;
                }
#if DBG
                else
                {
                    MessageBox(NULL, szNewPath, TEXT("INFPATH: File Not Found!!"), MB_OK);
                }
#endif
            }
        }
    }

    //
    // Doh!  It wasn't found in the InfPath path!
    // Let's try the OfflineWindowsDirectory
    //
    if (OfflineContext->OfflineWindowsDirectory && *OfflineContext->OfflineWindowsDirectory)
    {
        if ( IsFileInDrvIndex(OfflineContext, lpszSourceFile) )
        {
            LPTSTR  lpszDriverCache     = TEXT("Driver Cache");
            LPTSTR  lpszDriverCabFile   = TEXT("DRIVER.CAB");
            LPTSTR  lpszTempPath        = TEXT("TEMP");

            //
            // Build a path to the offline image's %WINDIR%\\Driver Cache\\i386\\DRIVER.CAB
            //
            lstrcpyn(szNewPath, OfflineContext->OfflineWindowsDirectory, AS(szNewPath));
            AddPath(szNewPath, lpszDriverCache);
            AddPath(szNewPath, IsIA64() ? TEXT("ia64") : TEXT("i386"));
            AddPath(szNewPath, lpszDriverCabFile);

            if ( ( EXIST(szNewPath) ) ||
                 ( ( lstrcpyn(szNewPath, OfflineContext->OfflineSourcePath, AS(szNewPath)) ) &&
                   ( AddPath(szNewPath, lpszDriverCabFile) ) && 
                   ( EXIST(szNewPath) ) ) )
            {
                TCHAR   szOfflineTemp[MAX_PATH];
            
                //
                // Build a path to the Offline image's %WINDIR%\\TEMP directory
                //
                lstrcpyn(szOfflineTemp, OfflineContext->OfflineWindowsDirectory, AS(szOfflineTemp));
                AddPath(szOfflineTemp, lpszTempPath);

                if ( ExtractFileFromCabinet(szNewPath,
                                        lpszSourceFile,
                                        szOfflineTemp) )
                {
#if DBG
                    MessageBox(NULL, TEXT("Succeeded!"), TEXT("ExtractFileFromCabinet"), MB_OK);
#endif
                    //
                    // If the file exists, fill in the caller's buffer with the new location
                    //
                    if (lpszDestination)
                        lstrcpy((LPTSTR)lpszDestination, szOfflineTemp);

                    //
                    // Fill in the TemporaryFilePath variable so we delete this file on ENDCOPY event
                    //
                    if (OfflineContext->TemporaryFilePath)
                    {
                        lstrcpy(OfflineContext->TemporaryFilePath, szOfflineTemp);
                        AddPath(OfflineContext->TemporaryFilePath, lpszSourceFile);
                    }

                    //
                    // We found the file, so want to return FILEOP_NEWPATH
                    //
                    uRet = FILEOP_NEWPATH;
                }
#if DBG
                else
                {
                    MessageBox(NULL, TEXT("Failed!"), TEXT("ExtractFileFromCabinet"), MB_OK);
                }
#endif
            }
#if DBG
            else
            {
                MessageBox(NULL, szNewPath, TEXT("DRVCAB: File Not Found!!"), MB_OK);
            }
#endif
        }
        else
        {
#if DBG
            MessageBox(NULL, lpszSourceFile, TEXT("File is not in drvindex.inf"), MB_OK);
#endif
            // Search for it in the OfflineSourcePath
            //
            if ( OfflineContext->OfflineSourcePath && *OfflineContext->OfflineSourcePath )
            {
                // Build a new path to the file inside OfflineSourcePath
                //
                lstrcpyn(szNewPath, OfflineContext->OfflineSourcePath, AS(szNewPath));
                AddPath(szNewPath, lpszSourceFile);

                // If the file exists there, return FILEOP_NEWPATH.
                //
                if ( EXIST(szNewPath) )
                {
                    uRet = FILEOP_NEWPATH;
                }
                else
                {
                    // Look for the compressed version of the file as well.
                    //
                    szNewPath[lstrlen(szNewPath) - 1] = TEXT('_');
                    if ( EXIST(szNewPath) )
                    {
                        uRet = FILEOP_NEWPATH;
                    }
                }

                if ( uRet == FILEOP_NEWPATH )
                {
#if DBG
                    MessageBox(NULL, szNewPath, TEXT("SOURCEPATH: WooHoo!!"), MB_OK);
#endif
                    if (lpszDestination)
                    {
                        // Save this in the buffer.
                        //
                        lstrcpy((LPTSTR)lpszDestination, OfflineContext->OfflineSourcePath);
                    }

                    return uRet;
                }
#if DBG
                else
                {
                    MessageBox(NULL, szNewPath, TEXT("SOURCEPATH: File Not Found!!"), MB_OK);
                }
#endif
    
            }
        }
    }

    return uRet;
}


static UINT
OfflineQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
/*++
===============================================================================
Routine Description:

    Callback function for setupapi to use as he's copying files.

    We'll use this to ensure that the files we copy get appended to
    setup.log, which in turn may get used when/if the user ever tries to
    use Windows repair capabilities.

Arguments:


Return Value:


===============================================================================
--*/
{
    UINT                    Status = FILEOP_ABORT;
    POFFLINE_QUEUE_CONTEXT  OfflineContext = Context;

    // 
    // Make sure that if we get these notification to check Param1.
    //
    switch (Notification) {
        case SPFILENOTIFY_COPYERROR:
            {
                PFILEPATHS  FilePaths = (PFILEPATHS)Param1;

                if (FilePaths)
                {
                    TCHAR   szDestination[MAX_PATH];
                    TCHAR   szFullPathBuffer[MAX_PATH];
                    LPTSTR  lpszFilePart = NULL;

                    //
                    // Initialize the Destination buffer for the FILEOP_NEWPATH case
                    //
                    ZeroMemory(szDestination, sizeof(szDestination));
                    
                    //
                    // Call GetFullPathName to strip the file name away from FilePaths->Source
                    //
                    if ( GetFullPathName((LPTSTR)FilePaths->Source, 
                                         AS(szFullPathBuffer), 
                                         szFullPathBuffer, 
                                         &lpszFilePart) && lpszFilePart && *lpszFilePart )
                    {
                        //
                        // Call FixCopyQueueStuff to find the missing file in some magic locations...
                        //
                        Status = FixCopyQueueStuff(OfflineContext, lpszFilePart, szDestination);
                    }

                    //
                    // If the force flag is set and the target exists, delete the destination file...
                    //
                    if ( ( GetOfflineInstallFlags() & INSTALL_FLAG_FORCE ) &&
                         ( SetFileAttributes( (LPTSTR)FilePaths->Target, FILE_ATTRIBUTE_NORMAL ) ) )
                    {
#ifdef DBG
                        MessageBox(NULL, (LPTSTR)FilePaths->Target, TEXT("Deleting existing file"), MB_OK);
#endif
                        DeleteFile( (LPTSTR)FilePaths->Target );
                    }

                    //
                    // If we got back FILEOP_NEWPATH, we want to fix up Param2 and let SetupAPI copy from there...
                    //
                    if ( (Status == FILEOP_NEWPATH) && *szDestination )
                    {
                        lstrcpy((LPTSTR)Param2, szDestination);
                    }
                    else
                    {
#if DBG
                        MessageBox(NULL, (LPTSTR)FilePaths->Source, TEXT("CopyError: Skipping!"), MB_OK);
#endif

                        Status = FILEOP_SKIP;
                    }

                    return Status;
                }
                else
                {
                    //
                    // Bad Times!
                    //
                }
            }
            break;

        case SPFILENOTIFY_NEEDMEDIA:
            {
                PSOURCE_MEDIA pSourceMedia = (PSOURCE_MEDIA) Param1;

                if (pSourceMedia) 
                {
                    TCHAR   szDestination[MAX_PATH];

                    //
                    // Initialize the Destination buffer for the FILEOP_NEWPATH case
                    //
                    ZeroMemory(szDestination, sizeof(szDestination));

                    //
                    // Call FixCopyQueueStuff to find the missing file in some magic locations...
                    //
                    Status = FixCopyQueueStuff(OfflineContext, (LPTSTR)pSourceMedia->SourceFile, szDestination);

                    //
                    // If we got back FILEOP_NEWPATH, we want to fix up Param2 and let SetupAPI copy from there...
                    //
                    if ( (Status == FILEOP_NEWPATH) && *szDestination )
                    {
                        lstrcpy((LPTSTR)Param2, szDestination);
                    }
                    else
                    {
#if DBG
                        MessageBox(NULL, pSourceMedia->SourceFile, TEXT("NeedMedia: Skipping!"), MB_OK);
#endif

                        Status = FILEOP_SKIP;
                    }
                    
                    return Status;
               }
               else
               {
                   //
                   // Bad Times!
                   //
               }

            }
            break;

        case SPFILENOTIFY_ENDCOPY:
            {
                //
                // If we extracted a file out to the TemporaryFilePath, we want to delete it now!
                //
                if (OfflineContext->TemporaryFilePath && *OfflineContext->TemporaryFilePath)
                {
                    //
                    // Do we care if this fails???
                    //
                    DeleteFile(OfflineContext->TemporaryFilePath);

                    //
                    // Re-initialize the TemporaryFilePath for the next file in the queue...
                    //
                    *(OfflineContext->TemporaryFilePath) = NULLCHR;
                }
            }
            break;

        default:
            //
            // If the caller passed in the "force" switch, then silently overwrite...
            // Note: The SPFILENOTIFY_TARGETEXISTS is a bit flag, which is why we check it here
            //
            if ( ( Notification & (SPFILENOTIFY_LANGMISMATCH | SPFILENOTIFY_TARGETNEWER | SPFILENOTIFY_TARGETEXISTS) ) &&
                 ( GetOfflineInstallFlags() & INSTALL_FLAG_FORCE ) )
            {
                return ( FILEOP_DOIT );
            }
            break;
    }

    //
    // Use default processing, then check for errors.
    //
    Status = SetupDefaultQueueCallback( OfflineContext->DefaultContext,
                                        Notification,
                                        Param1,
                                        Param2 );

    return Status;

}

static VOID
FreeOfflineContext(
    IN PVOID Context
    )
{
    POFFLINE_QUEUE_CONTEXT OfflineContext = Context;

    try 
    {
        if (OfflineContext->DefaultContext) 
        {
            SetupTermDefaultQueueCallback(OfflineContext->DefaultContext);
        }

        //
        // Free the TemporaryFilePath buffer that we allocated
        //
        if (OfflineContext->TemporaryFilePath)
            FREE(OfflineContext->TemporaryFilePath);

        FREE(OfflineContext);
    } 
    except(EXCEPTION_EXECUTE_HANDLER) 
    {
        ;
    }
}


static PVOID
InitOfflineQueueCallback(
    VOID
    )
/*++
===============================================================================
Routine Description:

    Initialize the data structure used for the callback that fires when
    we commit the file copy queue.

Arguments:


Return Value:


===============================================================================
--*/
{
    POFFLINE_QUEUE_CONTEXT OfflineContext;

    OfflineContext = MALLOC(sizeof(OFFLINE_QUEUE_CONTEXT));

    if( OfflineContext )
    {
        OfflineContext->InfPath             = NULL;
        OfflineContext->OfflineSourcePath  = NULL;
        OfflineContext->TemporaryFilePath   = MALLOC(MAX_PATH * sizeof(TCHAR));
        OfflineContext->DefaultContext      = SetupInitDefaultQueueCallbackEx( NULL,
                                                                           INVALID_HANDLE_VALUE,
                                                                           0,
                                                                           0,
                                                                           NULL );
    }

    return OfflineContext;
}

static
DWORD GetSetOfflineInstallFlags(
    IN BOOL  bSet,
    IN DWORD dwFlags
    )
{
    static DWORD dwOfflineFlags = 0;
    DWORD  dwRet = 0;

    if ( bSet )
    {
        dwOfflineFlags = dwFlags;
    }
    else
    {
        dwRet = dwOfflineFlags;
    }

    return dwRet;
}

VOID
SetOfflineInstallFlags(
    IN DWORD dwFlags
    )
{
    GetSetOfflineInstallFlags( TRUE, dwFlags );
}

DWORD
GetOfflineInstallFlags(
    VOID
    )
{
    return ( GetSetOfflineInstallFlags( FALSE, 0 ) );
}

BOOL
UpdateOfflineDevicePath( 
    IN LPTSTR lpszInfPath,
    IN HKEY   hKeySoftware 
    )
{
    BOOL   fRet = FALSE;
    LPTSTR lpszDevicePath;
    DWORD  cbDevicePath;

    // Get a buffer for the device paths.  It will be either empty if they
    // don't have the optional additional paths key in the winbom.
    //
    if ( NULL != (lpszDevicePath = IniGetStringEx(lpszInfPath, INI_SEC_WBOM_DRIVERUPDATE, INI_VAL_WBOM_DEVICEPATH, NULL, &cbDevicePath)) )
    {
        // If we are saving this list to the registry, then
        // we need to add to our buffer.
        //
        if ( *lpszDevicePath )
        {
            fRet = UpdateDevicePathEx( hKeySoftware, 
                                       TEXT("Microsoft\\Windows\\CurrentVersion"),
                                       lpszDevicePath, 
                                       NULL, 
                                       FALSE );
        }

        // Clean up any memory (macro checks for NULL).
        //
        FREE(lpszDevicePath);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\lib\msdinst\setupcdd.c ===
/****************************************************************************\

    SYSPREP.C / Mass Storage Device Installer (MSDINST.LIB)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Source file the MSD Installation library which contains the sysprep
    releated code taken from the published sysprep code.

    07/2001 - Jason Cohen (JCOHEN)

        Added this new source file for the new MSD Installation project.

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include <winbom.h>
#include "main.h"


//
// Local Define(s):
//

#define SYSPREP_DEVNODE             _T("SYSPREP_TEMPORARY")

#define STR_SERVICE_MAIN            _T("Service")
#define STR_SERVICE_UPPER           _T("UpperFilter")
#define STR_SERVICE_LOWER           _T("LowerFilter")

#define STR_SERVICES_SECTION        _T(".Services")

#define NUM_SERVICE_MAIN            0
#define NUM_SERVICE_UPPER           1
#define NUM_SERVICE_LOWER           2

#define DIR_I386                    _T("i386")
#define DIR_IA64                    _T("ia64")

#define REG_KEY_HIVE_CDD            _T("ControlSet001\\Control\\CriticalDeviceDatabase")
#define REG_KEY_HIVE_SETUP_SETUP    _T("Microsoft\\Windows\\CurrentVersion\\Setup")
#define REG_KEY_SETUP_SETUP         REGSTR_PATH_SETUP REGSTR_KEY_SETUP


#define STR_SYSPREP_INF             _T("sysprep\\sysprep.inf")


//
// Local Type Define(s):
//

typedef struct _CLEANUP_NODE
{
    LPTSTR                  lpszService;
    DWORD                   dwType;
    struct _CLEANUP_NODE *  lpNext;
}
CLEANUP_NODE, *PCLEANUP_NODE, *LPCLEANUP_NODE;


//
// Local Global(s):
//

static LPTSTR s_lpszServiceType[] =
{
    STR_SERVICE_MAIN,
    STR_SERVICE_UPPER,
    STR_SERVICE_LOWER,
};


//
// Local Prototype(s):
//

static BOOL SysprepDevnode(HDEVINFO * phDevInfo, SP_DEVINFO_DATA * pDeviceInfoData, BOOL bCreate);

static BOOL
GetDeviceInstallSection(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA pDriverInfoData,
    OUT LPTSTR          lpszSection,
    IN DWORD            cbSection
    );

static BOOL
GetDeviceServicesSection(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA pDriverInfoData,
    OUT LPTSTR          lpszSection,
    IN DWORD            cbSection
    );

static BOOL
ProcessDeviceProperty(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN LPCLEANUP_NODE * lplpcnList,
    IN HKEY             hkeyDevice,
    IN HKEY             hkeySystem,
    IN LPTSTR           lpszInfPath,
    IN LPTSTR           lpszServiceSection,
    IN DWORD            dwProperty
    );

static BOOL AddCleanup(LPCLEANUP_NODE * lplpcnHead, LPTSTR lpszService, DWORD dwType);
static LPCLEANUP_NODE OpenCleanup(LPTSTR lpszInfFile);
static BOOL SaveCleanup(LPTSTR lpszInfFile, LPCLEANUP_NODE lpcnHead);
static void CloseCleanup(LPCLEANUP_NODE lpcnHead);
static BOOL AddStrToSect(LPTSTR * lplpmszSect, DWORD * lpcbSect, LPTSTR * lplpmszEnd, DWORD * lpdwSize, LPTSTR lpszStr);

static BOOL
OfflineSourcePath(
    HKEY    hkeySoftware,
    LPTSTR  lpszWindows,
    LPTSTR  lpszSourcePath,
    DWORD   cbSourcePath
    );


//
// Exported Funtion(s):
//

BOOL
SetupCriticalDevices(
    LPTSTR lpszInfFile,
    HKEY   hkeySoftware,
    HKEY   hkeySystem,
    LPTSTR lpszWindows
    )

/*++
===============================================================================

  Routine Description:

    Parse the [SysprepMassStorage] section in the sysprep.inf file and
    populate the critical device database with the specified devices to ensure
    that we can boot into the miniwizard when moving the image to a target
    system with different boot storage devices.

    The installed services/upperfilters/lowerfilters will be recorded, so
    that on the next boot into the mini-wizard those without an associated
    device will be disabled (the cleanup stage) in order not to unnecessarily
    degrade Windows start time.

Arguments:

    None.

Return Value:

    TRUE if everything is OK, FALSE otherwise.

Assumptions:

    1. No HardwareID exceeds MAX_PATH characters.

    2. No field on a line in the [SysprepMassStorage] section exceeds MAX_PATH
       characters.

    3. No service's/upperfilter's/lowerfilter's name exceeds MAX_PATH characters.

    4. DirectoryOnSourceDevice, source DiskDescription, or source DiskTag
       (applying to vendor-supplied drivers) cannot exceed MAX_PATH characters.

===============================================================================
--*/

{
    TCHAR                   szSysprepInfFile[MAX_PATH]  = NULLSTR,
                            szDevice[MAX_PATH],
                            szSection[MAX_PATH],
                            szPath[MAX_PATH],
                            szSourcePath[MAX_PATH];
    DWORD                   dwSize,
                            dwDis;
    LPTSTR                  lpszCleanupInfFile,
                            lpszReplace,
                            lpszSourcePath              = NULL;
    BOOL                    bDevnode                    = TRUE,
                            bAllOK                      = TRUE,
                            bLineExists,                
                            b2ndTry;                    
    HKEY                    hkeyCDD                     = NULL,
                            hkeyDevice                  = NULL;
    LPCLEANUP_NODE          lpcnCleanupList;            
    HINF                    hInf;                       
    INFCONTEXT              InfContext;                 
    HDEVINFO                hDevInfo                    = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA         DeviceInfoData;             
    SP_DEVINSTALL_PARAMS    DevInstallParams;           
    SP_DRVINFO_DATA         DriverInfoData;             
    HSPFILEQ                QueueHandle                 = INVALID_HANDLE_VALUE;

 
    
    // Do a little parameter validation.
    //
    if ( ( NULL == hkeySoftware ) ||
         ( NULL == hkeySystem ) ||
         ( NULL == lpszWindows ) )
    {
        // If any of these parameters are NULL, then they
        // all must be.
        //
        hkeySoftware = NULL;
        hkeySystem = NULL;
        lpszWindows = NULL;
    }

    // Open the inf file with the mass storage list.
    //
    hInf = SetupOpenInfFile(lpszInfFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if ( INVALID_HANDLE_VALUE == hInf )
    {
        OpkLogFile(0 | LOG_ERR, IDS_ERR_OPEN_INF, lpszInfFile);
        return FALSE;
    }

    // If this is offline, we write the cleanup section to the sysprep inf
    // that is in the image.
    //
    
    if ( lpszWindows )
    {
        LPTSTR lpFound;
        
        // Strip the windows directory off the offline path so we can build a path to the sysprep.inf.
        //
        lstrcpy(szSysprepInfFile, lpszWindows);
        lpFound = _tcsrchr(szSysprepInfFile, _T('\\'));
        
        // Just in case the lpszWindows folder has a trailing backslash handle that here.
        // If this is the case, the character after the backslash is a NULL.  Remove the trailing backslash,
        // and do the search for the last backslash again.  This will be the one we actually want to 
        // get rid of.
        //
        if ( !(*(lpFound + 1)) )
        {
            *lpFound = NULLCHR;
            lpFound = _tcsrchr(szSysprepInfFile, _T('\\'));
        }

        // Cut off the path in front of the windows directory name.
        // Add the sysprep.inf path part.
        // Set our cleanup file to point to the path we just built.
        //
        *lpFound = NULLCHR;
        AddPathN(szSysprepInfFile, STR_SYSPREP_INF, AS(szSysprepInfFile));
        lpszCleanupInfFile = szSysprepInfFile;
    }
    else
    {
        lpszCleanupInfFile = lpszInfFile;
    }

    // If this is an offline install, then we need to get the source path
    // to our image.
    //
    if ( hkeySoftware && lpszWindows &&
         OfflineSourcePath(hkeySoftware, lpszWindows, szSourcePath, AS(szSourcePath)) )
    {
        lpszSourcePath = szSourcePath;
    }

    // We need a handle to the critical device database registry key if we
    // are doing an offline install.
    //
    if ( ( hkeySystem ) &&
         ( ERROR_SUCCESS != RegCreateKeyEx(hkeySystem,
                                           REG_KEY_HIVE_CDD,
                                           0,
                                           NULL,
                                           REG_OPTION_NON_VOLATILE,
                                           KEY_ALL_ACCESS,
                                           NULL,
                                           &hkeyCDD,
                                           &dwDis) ) )
    {
        SetupCloseInfFile(hInf);
        OpkLogFile(0 | LOG_ERR, IDS_ERR_OPEN_OFFLINECDD);
        return FALSE;
    }

    // Create a dummy devnode.
    //
    if ( !SysprepDevnode(&hDevInfo, &DeviceInfoData, TRUE) )
    {
        if ( hkeyCDD )
        {
            RegCloseKey(hkeyCDD);
        }
        SetupCloseInfFile(hInf);
        OpkLogFile(0 | LOG_ERR, IDS_ERR_CREATE_DEVNODE);
        return FALSE;
    }

    // Init the driver info data structure.
    //
    ZeroMemory(&DriverInfoData, sizeof(SP_DRVINFO_DATA));
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);

    // Read the current cleanup section in the inf file.
    //
    lpcnCleanupList = OpenCleanup(lpszCleanupInfFile);

    // Process each line in our section.  Each line should look like:
    // <hardware-id>=<inf pathname>
    //
    // Or in the case of drivers that aren't on the product CD:
    // <hardware-id>=<inf pathname>,<directory on recovery floppy>,<description of recovery floppy>,<disk tag of recovery floppy>
    //
    // If we see an entry like this, we'll know that in the case of system recovery, the
    // file should be retrived from a floppy, and not the Windows CD.
    //
    for ( bLineExists = SetupFindFirstLine(hInf, INI_SEC_WBOM_SYSPREP_MSD, NULL, &InfContext);
          bLineExists;
          bLineExists = SetupFindNextLine(&InfContext, &InfContext) )
    {
        // Retrieve the hardwareID from the line.
        //
        dwSize = AS(szDevice);
        if ( !SetupGetStringField(&InfContext, 0, szDevice, dwSize, &dwSize) )
        {
            bAllOK = FALSE;
            continue;
        }

        // We do this in a loop because we might try twice.
        //
        b2ndTry = FALSE;
        do
        {
            // And then set it to the devnode.
            //
            if ( !SetupDiSetDeviceRegistryProperty(hDevInfo,
                                                   &DeviceInfoData,
                                                   SPDRP_HARDWAREID,
                                                   (LPBYTE) szDevice,
                                                   (lstrlen(szDevice)+1) * sizeof(TCHAR)) )
            {
                // If someone removed the devnode, we need to re-create it and repeat this set.
                //
                if ( ( !b2ndTry ) &&
                     ( ERROR_NO_SUCH_DEVINST == GetLastError() ) )
                {
                    // Sometimes devices remove the devnode after we install, so we should
                    // try once to recreate.
                    //
                    if ( SysprepDevnode(&hDevInfo, &DeviceInfoData, TRUE) )
                    {
                        // If we were able to recreate it, then we should try this again.
                        //
                        b2ndTry = TRUE;
                    }
                    else
                    {
                        // We are really screwed if we have no devnode.
                        //
                        bDevnode = FALSE;
                    }
                }
                else
                {
                    // Either we tried again already, or there is another error.
                    //
                    bAllOK = b2ndTry = FALSE;
                }
            }
            else
            {
                // It worked, so make sure we don't loop again in case this is the second time
                // through.
                //
                b2ndTry = FALSE;
            }
        }
        while ( b2ndTry );

        // If we the devnode was lost and unable to be recreated, then we just have
        // to bail out.
        //
        if ( !bDevnode )
        {
            OpkLogFile(0 | LOG_ERR, IDS_ERR_CREATE_DEVNODE);
            break;
        }

        // Build the SP_DEVINSTALL_PARAMS for this node.
        //
        DevInstallParams.cbSize = sizeof(DevInstallParams);
        if ( !SetupDiGetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams) )
        {
            bAllOK = FALSE;
            continue;
        }

        // Set the Flags field: only search the INF file specified in DriverPath field;
        // don't create a copy queue, use the provided one in FileQueue; don't call the
        // Configuration Manager while populating the CriticalDeviceDatabase.
        //
        DevInstallParams.Flags |= ( DI_ENUMSINGLEINF |
                                    DI_NOVCP |
                                    DI_DONOTCALLCONFIGMG );

        // Set the device's inf pathname
        //
        dwSize = AS(szPath);
        if ( !SetupGetStringField(&InfContext, 1, szPath, dwSize, &dwSize) )
        {
            OpkLogFile(0 | LOG_ERR, IDS_ERR_GET_INF_NAME);
            bAllOK = FALSE;
            continue;
        }
        ExpandEnvironmentStrings(szPath, DevInstallParams.DriverPath, AS(DevInstallParams.DriverPath));
        lstrcpyn(szPath, DevInstallParams.DriverPath, AS(szPath));

        // Replace the backslashes with pounds in the pnp id so we can use it for the registry key.
        //
        for ( lpszReplace = szDevice; *lpszReplace; lpszReplace = CharNext(lpszReplace) )
        {
            if ( _T('\\') == *lpszReplace )
            {
                *lpszReplace = _T('#');
            }
        }

        // Set the file queue field
        //
        QueueHandle = SetupOpenFileQueue();
        if ( INVALID_HANDLE_VALUE == QueueHandle )
        {
            OpkLogFile(0 | LOG_ERR, IDS_ERR_OPEN_FILE_QUEUE);
            bAllOK = FALSE;
            continue;
        }
        DevInstallParams.FileQueue = QueueHandle;

        // 1. Save the parameters we have set.
        // 2. Register the newly created device instance with the PnP Manager.
        // 3. Perform a compatible driver search.
        //
        if ( ( SetupDiSetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams) ) &&
             ( SetupDiCallClassInstaller(DIF_REGISTERDEVICE, hDevInfo, &DeviceInfoData) ) &&
             ( SetupDiBuildDriverInfoList(hDevInfo, &DeviceInfoData, SPDIT_COMPATDRIVER) ) )
        {
            // Make sure there is at least 1 compat driver for this device.
            // If there is not, and then we just process the next one in the list.
            //
            if ( SetupDiEnumDriverInfo(hDevInfo,
                                       &DeviceInfoData,
                                       SPDIT_COMPATDRIVER,
                                       0,
                                       &DriverInfoData) )
            {
                // 1. Select the best compatible driver.
                // 2. Install the driver files.
                // 3. Make sure we are able to create the drivers key in the CDD if
                //    we are doing an offline install (otherwise the CDD key will be
                //    NULL and we don't have to worry about creating the key).
                //
                if ( ( SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV, hDevInfo, &DeviceInfoData) ) &&
                     ( SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, hDevInfo, &DeviceInfoData) ) &&
                     ( ( NULL == hkeyCDD ) ||
                       ( ERROR_SUCCESS == RegCreateKeyEx(hkeyCDD, szDevice, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyDevice, &dwDis) ) ) )
                {
                    // Need to commit the file queue here, so the later steps can properly
                    // be executed in case the device doesn't use the already existing
                    // coinstaller(s).
                    //

                    // ACOSMA code here...
                    //
                    if ( !OfflineCommitFileQueue(QueueHandle, szPath, lpszSourcePath, lpszWindows) )
                    {
                        OpkLogFile(0 | LOG_ERR, IDS_ERR_COMMIT_OFFLINE_QUEUE);
                        bAllOK = FALSE;
                    }

                    // Install the device (do we really need to do this for the offline case).
                    //
#if 0
                    if ( SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                                   hDevInfo,
                                                   &DeviceInfoData) )
#else
                    SetupDiInstallDevice(hDevInfo,
                                         &DeviceInfoData);
#endif
                    {
                        //
                        // Retrieve class guid (if offline) upper filters, lower filters,
                        // and controlling service, save them back to the inf file and put
                        // them in the hive (if offline).
                        //

                        // Retrieve the device class GUID (only needed for offline install).
                        //
                        if ( ( hkeyDevice ) &&
                             ( !ProcessDeviceProperty(hDevInfo,
                                                      &DeviceInfoData,
                                                      &lpcnCleanupList,
                                                      hkeyDevice,
                                                      hkeySystem,
                                                      szPath,
                                                      NULL,
                                                      SPDRP_CLASSGUID) ) )
                        {
                            OpkLogFile(0 | LOG_ERR, IDS_ERR_CLASS_GUID);
                            bAllOK = FALSE;
                        }

                        if ( !GetDeviceServicesSection(hDevInfo, &DeviceInfoData, &DriverInfoData, szSection, AS(szSection)) )
                        {
                            szSection[0] = NULLCHR;
                            bAllOK = FALSE;
                        }

                        // Retrieve device upper filters (REG_MULTI_SZ).
                        //
                        if ( !ProcessDeviceProperty(hDevInfo,
                                                    &DeviceInfoData,
                                                    &lpcnCleanupList,
                                                    hkeyDevice,
                                                    hkeySystem,
                                                    szPath,
                                                    szSection[0] ? szSection : NULL,
                                                    SPDRP_UPPERFILTERS) )
                        {
                            OpkLogFile(0 | LOG_ERR, IDS_ERR_UPPER_FILTERS);
                            bAllOK = FALSE;
                        }

                        // Retrieve device lower filters (REG_MULTI_SZ).
                        //
                        if ( !ProcessDeviceProperty(hDevInfo,
                                                    &DeviceInfoData,
                                                    &lpcnCleanupList,
                                                    hkeyDevice,
                                                    hkeySystem,
                                                    szPath,
                                                    szSection[0] ? szSection : NULL,
                                                    SPDRP_LOWERFILTERS) )
                        {
                            OpkLogFile(0 | LOG_ERR, IDS_ERR_LOWER_FILTERS);
                            bAllOK = FALSE;
                        }

                        // Retrieve device its controlling service (REG_SZ).
                        //
                        if ( !ProcessDeviceProperty(hDevInfo,
                                                    &DeviceInfoData,
                                                    &lpcnCleanupList,
                                                    hkeyDevice,
                                                    hkeySystem,
                                                    szPath,
                                                    szSection[0] ? szSection : NULL,
                                                    SPDRP_SERVICE) )
                        {
                            OpkLogFile(0 | LOG_ERR, IDS_ERR_DEVICE_SERVICE);
                            bAllOK = FALSE;
                        }
                    }
                    
                    // Close the device registry key in the CDD.
                    //
                    if ( hkeyDevice )
                    {
                        RegCloseKey(hkeyDevice);
                        hkeyDevice = NULL;
                    }
                }
                else
                {
                    OpkLogFile(0 | LOG_ERR, IDS_ERR_SELECT_COMPAT);
                    bAllOK = FALSE;
                }
            }
            else
            {
                // Check to see what the error was.  Any error other than ERROR_NO_MORE_ITEMS
                // will be flaged, by setting the bAllOK return value to FALSE.
                //
                if ( ERROR_NO_MORE_ITEMS != GetLastError() )
                {
                    OpkLogFile(0 | LOG_ERR, IDS_ERR_ENUM_COMPAT_DRIVER);
                    bAllOK = FALSE;
                }
            }

            // Make sure that there's no existing compatible list, since we're reusing
            // the dummy devnode.
            //
            if ( !SetupDiDestroyDriverInfoList(hDevInfo, &DeviceInfoData, SPDIT_COMPATDRIVER) )
            {
                bAllOK = FALSE;
            }
        }
        else
        {
            OpkLogFile(0 | LOG_ERR, IDS_ERR_BUILD_COMPAT_DRIVER);
            bAllOK = FALSE;
        }

        // Dis-associate file copy queue before we close the queue.
        //
        DevInstallParams.cbSize = sizeof(DevInstallParams);
        if ( SetupDiGetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams) )
        {
            // Remove the DI_NOVCP flag and NULL out the FileQueue.
            //
            DevInstallParams.Flags &= ~DI_NOVCP;
            DevInstallParams.FileQueue = NULL;
            if ( !SetupDiSetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams) )
            {
                bAllOK = FALSE;
            }
        }
        else
        {
            bAllOK = FALSE;
        }

        // Close the file queue.
        //
        SetupCloseFileQueue(QueueHandle);
    }

    // See if we still have the devnode.
    //
    if ( bDevnode )
    {
        // Remove the SYSPREP_TEMPORARY node under Root.
        //
        SysprepDevnode(&hDevInfo, &DeviceInfoData, FALSE);
    }
    else
    {
        // If the devnode is lost, we need to make sure we return an error.
        //
        bAllOK = FALSE;
    }

    // If an offline install, we need to close this key.
    //
    if ( hkeyCDD )
    {
        RegCloseKey(hkeyCDD);
    }

    // Close the handles to our inf files.
    //
    SetupCloseInfFile(hInf);

    //
    // Check if the caller wants us to update the offline device path...
    //
    UpdateOfflineDevicePath( lpszInfFile, hkeySoftware );

    // We need to save our cleanup list back to the inf file.
    //
    SaveCleanup(lpszCleanupInfFile, lpcnCleanupList);
    CloseCleanup(lpcnCleanupList);

    return bAllOK;
}


//
// Local Function(s):
//

static BOOL SysprepDevnode(HDEVINFO * phDevInfo, SP_DEVINFO_DATA * pDeviceInfoData, BOOL bCreate)
{
    BOOL bRet = TRUE;

    if ( ( NULL == phDevInfo ) ||
         ( NULL == pDeviceInfoData ) )
    {
        return FALSE;
    }

    if ( bCreate )
    {
        // Create a dummy devnode.
        //
        *phDevInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
        if ( INVALID_HANDLE_VALUE == *phDevInfo )
        {
            return FALSE;
        }

        // Initialize the DriverInfoData struct.
        //
        ZeroMemory(pDeviceInfoData, sizeof(SP_DEVINFO_DATA));
        pDeviceInfoData->cbSize = sizeof(SP_DEVINFO_DATA);

        // Create the devnode.
        //
        if ( !SetupDiCreateDeviceInfo(*phDevInfo,
                                      SYSPREP_DEVNODE,
                                      (LPGUID) &GUID_NULL,
                                      NULL,
                                      NULL,
                                      DICD_GENERATE_ID,
                                      pDeviceInfoData) )
        {
            bRet = FALSE;
        }
    }
    else
    {
        // Remove the dummy devnode.
        //
        SetupDiCallClassInstaller(DIF_REMOVE, *phDevInfo, pDeviceInfoData);
    }
    
    if ( ( !bCreate || !bRet ) &&
         ( INVALID_HANDLE_VALUE != *phDevInfo ) )
    {
        // Free up the dev info list (if we are removing the node or there
        // was an error).
        //
        SetupDiDestroyDeviceInfoList(*phDevInfo);
        *phDevInfo = INVALID_HANDLE_VALUE;
    }

    return bRet;
}

static BOOL
GetDeviceInstallSection(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA pDriverInfoData,
    OUT LPTSTR          lpszSection,
    IN DWORD            cbSection
    )
{
    BOOL                    bRet = FALSE;
    PSP_DRVINFO_DETAIL_DATA pDriverInfoDetailData;
    DWORD                   cbBytesNeeded;

    // Must have a buffer to return the data or else
    // there is no point.
    //
    if ( ( NULL == lpszSection ) ||
         ( 0 == cbSection ) )
    {
        return FALSE;
    }

    // Call the api once to get the size.  We expect this
    // to return a failure.
    //
    SetLastError(ERROR_SUCCESS);
    SetupDiGetDriverInfoDetail(hDevInfo,
                               pDeviceInfoData,
                               pDriverInfoData,
                               NULL,
                               0,
                               &cbBytesNeeded);

    // Check for the error, it should be insufficient buffer.  Then
    // try and allocate the memory needed.
    //
    if ( ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) &&
         ( cbBytesNeeded ) &&
         ( pDriverInfoDetailData = (PSP_DRVINFO_DETAIL_DATA) MALLOC(cbBytesNeeded) ) )
    {
        // Zero out the memory (although the MALLOC guy should be doing that) and
        // set the size of the structure.
        //
        ZeroMemory(pDriverInfoDetailData, cbBytesNeeded);
        pDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

        // Now call the function again to get data now that we have our buffer.
        //
        if ( SetupDiGetDriverInfoDetail(hDevInfo,
                                        pDeviceInfoData,
                                        pDriverInfoData,
                                        pDriverInfoDetailData,
                                        cbBytesNeeded,
                                        NULL) )
        {
            HINF hDeviceInf;

            hDeviceInf = SetupOpenInfFile( pDriverInfoDetailData->InfFileName, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
            if ( INVALID_HANDLE_VALUE != hDeviceInf )
            {
                DWORD dwInfSectionWithExtLength = 0;

                //
                // Use SetupDiGetActualSectionToInstall to figure out the decorated driver section...
                //
                bRet = SetupDiGetActualSectionToInstall( hDeviceInf,
                                                         pDriverInfoDetailData->SectionName,
                                                         lpszSection,
                                                         cbSection,
                                                         &dwInfSectionWithExtLength,
                                                         NULL );

                SetupCloseInfFile( hDeviceInf );
            }
        }

        // Always free the memory now that we have the data we need.
        //
        FREE(pDriverInfoDetailData);
    }

    // Only return TRUE if we returned something in their buffer.
    //
    return bRet;
}

static BOOL
GetDeviceServicesSection(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN PSP_DRVINFO_DATA pDriverInfoData,
    OUT LPTSTR          lpszSection,
    IN DWORD            cbSection
    )
{
    BOOL bRet;

    // Call our other function to get the device's install section.
    //
    bRet = GetDeviceInstallSection(hDevInfo,
                                   pDeviceInfoData,
                                   pDriverInfoData,
                                   lpszSection,
                                   cbSection);

    // If it worked, add on the part that makes in the service.
    // section.
    //
    if ( bRet )
    {
        // Make sure there is enough room to add on our string.
        //
        if ( AS(STR_SERVICES_SECTION) + lstrlen(lpszSection) <= cbSection )
        {
            // Woo hoo, add it.
            //
            lstrcat(lpszSection, STR_SERVICES_SECTION);
        }
        else
        {
            // Not enough room, so return an error and null out
            // the caller's buffer.
            //
            *lpszSection = NULLCHR;
            bRet = FALSE;
        }
    }

    // Return TRUE only if something valid in the buffer.
    //
    return bRet;
}

static BOOL
ProcessDeviceProperty(
    IN HDEVINFO         hDevInfo,
    IN PSP_DEVINFO_DATA pDeviceInfoData,
    IN LPCLEANUP_NODE * lplpcnList,
    IN HKEY             hkeyDevice,
    IN HKEY             hkeySystem,
    IN LPTSTR           lpszInfPath,
    IN LPTSTR           lpszServiceSection,
    IN DWORD            dwProperty
    )
{
    BOOL    bRet = TRUE;
    DWORD   dwServiceType,
            dwRegType,
            dwRegSize;
    LPTSTR  lpszRegKey,
            lpszBuffer,
            lpszService;

    // Figure out the other data we need based on
    // the property.
    //
    switch ( dwProperty )
    {
        case SPDRP_CLASSGUID:
            lpszRegKey = REGSTR_VAL_CLASSGUID;
            dwServiceType = 0xFFFFFFFF;
            break;

        case SPDRP_UPPERFILTERS:
            lpszRegKey = REGSTR_VAL_UPPERFILTERS;
            dwServiceType = NUM_SERVICE_UPPER;
            break;

        case SPDRP_LOWERFILTERS:
            lpszRegKey = REGSTR_VAL_LOWERFILTERS;
            dwServiceType = NUM_SERVICE_LOWER;
            break;

        case SPDRP_SERVICE:
            lpszRegKey = REGSTR_VAL_SERVICE;
            dwServiceType = NUM_SERVICE_MAIN;
            break;

        default:
            return FALSE;
    }

    // Call the registry property api to figure out the size of buffer
    // we need.
    //
    SetLastError(ERROR_SUCCESS);
    SetupDiGetDeviceRegistryProperty(hDevInfo,
                                     pDeviceInfoData,
                                     dwProperty,
                                     &dwRegType,
                                     NULL,
                                     0,
                                     &dwRegSize);

    // If we get any other error then the one we are expecting, then just
    // return TRUE.
    //
    if ( ERROR_INSUFFICIENT_BUFFER != GetLastError() )
    {
        return TRUE;
    }

    // Make sure reg type is a string.
    //
    switch ( dwRegType )
    {
        // We support both REG_SZ and REG_MULTI_SZ.
        //
        case REG_SZ:
        case REG_MULTI_SZ:
        
        // Don't really support this, but if the key happens to be
        // this type it should still work fine.
        //
        case REG_EXPAND_SZ:

            break;

        // Any other type and there must be some kind of
        // error.
        //
        default:

            return FALSE;
    }

    // Now allocate the buffer we need.  This must succeed.
    //
    lpszBuffer = (LPTSTR) MALLOC(dwRegSize);
    if ( NULL == lpszBuffer )
    {
        return FALSE;
    }

    // Retrieve device information.
    //
    if ( SetupDiGetDeviceRegistryProperty(hDevInfo,
                                          pDeviceInfoData,
                                          dwProperty,
                                          &dwRegType,
                                          (LPBYTE) lpszBuffer,
                                          dwRegSize,
                                          &dwRegSize) )
    {
        // If this is a service, save it to our cleanup list.
        //
        if ( 0xFFFFFFFF != dwServiceType )
        {
            // Go through all the services (or just one if not multi sz).
            //
            for ( lpszService = lpszBuffer; *lpszService; lpszService += (lstrlen(lpszService) + 1) )
            {
                // Need to make sure this service is installed (only needed for offline install).
                //
                if ( hkeySystem )
                {
                    // BRIANK code here...
                    //
                    AddService(lpszService, lpszServiceSection, lpszInfPath, hkeySystem);
                }

                // Add to our cleanup list.
                //
                AddCleanup(lplpcnList, lpszService, dwServiceType);

                // If this isn't a multi sz string, break out so we don't
                // try to do anymore.
                //
                if ( REG_MULTI_SZ != dwRegType )
                {
                    break;
                }
            }
        }

        // Write it to the CDD (only needed for offline install).
        //
        if ( ( hkeyDevice ) &&
             ( ERROR_SUCCESS != RegSetValueEx(hkeyDevice,
                                              lpszRegKey,
                                              0,
                                              dwRegType,
                                              (CONST LPBYTE) lpszBuffer,
                                              dwRegSize) ) )
        {
            // If a set value fails, we need to return an error.
            //
            bRet = FALSE;
        }
    }

    // Make sure we free the buffer we allocated.
    //
    FREE(lpszBuffer);

    return bRet;
}

static BOOL AddCleanup(LPCLEANUP_NODE * lplpcnHead, LPTSTR lpszService, DWORD dwType)
{
    LPCLEANUP_NODE lpcnAdd = *lplpcnHead;

    // Loop through our list looking for the a duplicate node.
    //
    while ( lpcnAdd )
    {
        // See if the node we want to add is the same as this one.
        //
        if ( 0 == lstrcmpi(lpcnAdd->lpszService, lpszService) )
        {
            // Already in the list, just return TRUE.
            //
            return TRUE;
        }

        // Advance to the next item in the list.
        //
        lplpcnHead = &(lpcnAdd->lpNext);
        lpcnAdd = lpcnAdd->lpNext;
    }

    // If we didn't find a duplicate node then we need to add ours.
    //
    if ( lpcnAdd = (LPCLEANUP_NODE) MALLOC(sizeof(CLEANUP_NODE)) )
    {
        // Okay, now if all that worked, we just need to alloc the memory for the string
        // that contains the name of the service.
        //
        if ( lpcnAdd->lpszService = (LPTSTR) MALLOC((lstrlen(lpszService) + 1) * sizeof(TCHAR)) )
        {
            // Already, copy the service string into the buffer we just allocated.
            //
            lstrcpy(lpcnAdd->lpszService, lpszService);

            // Save the type in our node.
            //
            lpcnAdd->dwType = dwType;

            // NULL out the next pointer since this is always the last item in
            // the list (shouldn't have to do this because my malloc macro is
            // supposed to zero memory, but for some reason it isn't working right.
            //
            lpcnAdd->lpNext = NULL;

            // We should now have a pointer to the address of the next pointer
            // in the last node (or the head pointer).  Just add our node there.
            //
            *lplpcnHead = lpcnAdd;

            // At this point we are all done.
            //
            return TRUE;
        }
        else
        {
            // Failed, so free our node that we were going to add.
            //
            FREE(lpcnAdd);
        }
    }

    // Now if we ended up here, some memory allocation must have failed.
    //
    return FALSE;
}

static LPCLEANUP_NODE OpenCleanup(LPTSTR lpszInfFile)
{
    LPCLEANUP_NODE  lpcnHead = NULL,
                    lpcnNew,
                    *lplpcnAdd = &lpcnHead;
    HINF            hInf;
    BOOL            bLoop;
    INFCONTEXT      InfContext;
    TCHAR           szService[MAX_PATH];
    DWORD           dwType;

    // First open up the inf.  If it failes, there is no need to do anything
    // because there is nothing to read.  Just return NULL.
    //
    hInf = SetupOpenInfFile(lpszInfFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if ( INVALID_HANDLE_VALUE == hInf )
    {
        return NULL;
    }

    // Loop through all the lines in the sysprep cleanup section.
    //
    for ( bLoop = SetupFindFirstLine(hInf, INI_SEC_WBOM_SYSPREP_CLEAN, NULL, &InfContext);
          bLoop;
          bLoop = SetupFindNextLine(&InfContext, &InfContext) )
    {
        // First get the service type (which is before the =).
        //
        if ( SetupGetStringField(&InfContext, 0, szService, AS(szService), NULL) )
        {
            // Now make sure it is a reconized type (either service, upperfilter,
            // or lowerfilter).
            //
            for ( dwType = 0; ( dwType <= AS(s_lpszServiceType) ); dwType++ )
            {
                if ( 0 == lstrcmpi(s_lpszServiceType[dwType], szService) )
                {
                    // If they match, break out and the dwType will be the index
                    // to the string.
                    //
                    break;
                }
            }

            // Make sure we found the string in our array.  If we did (dwType isn't too
            // big) then get what is in the first field (after the =).  This will be the
            // name of the service.  If we get that, then alloc the memory for the struture
            // we are going to add to our cleanup list.
            //
            if ( ( dwType < AS(s_lpszServiceType) ) &&
                 ( SetupGetStringField(&InfContext, 1, szService, AS(szService), NULL) ) &&
                 ( AddCleanup(lplpcnAdd, szService, dwType) ) &&
                 ( lpcnNew = *lplpcnAdd ) )
            {
                // Set the end pointer to the address of the next pointer in the node we
                // just added.  This is done so we don't rewalk the list every time we
                // add another node.
                //
                lplpcnAdd = &(lpcnNew->lpNext);
            }
        }
    }

    // Close our inf file now that we are done.
    //
    SetupCloseInfFile(hInf);

    // Return a pointer to the head of the list we just allocated.
    //
    return lpcnHead;
}

static BOOL SaveCleanup(LPTSTR lpszInfFile, LPCLEANUP_NODE lpcnHead)
{
    DWORD   cbSection   = 8192,
            dwSize      = 0;
    LPTSTR  lpmszSection,
            lpmszEnd;

    // Need a buffer for the section we are creating.
    //
    lpmszSection = lpmszEnd = (LPTSTR) MALLOC(cbSection * sizeof(TCHAR));
    if ( NULL == lpmszSection )
    {
        return FALSE;
    }

    // Loop through our whole list.
    //
    while ( lpcnHead )
    {
        // Add this line to our section in the form of:  ServiceType=ServiceName\0
        //
        if ( !( AddStrToSect(&lpmszSection, &cbSection, &lpmszEnd, &dwSize, s_lpszServiceType[lpcnHead->dwType]) &&
                AddStrToSect(&lpmszSection, &cbSection, &lpmszEnd, &dwSize, _T("=")) &&
                AddStrToSect(&lpmszSection, &cbSection, &lpmszEnd, &dwSize, lpcnHead->lpszService) ) )
        {
            // Memory allocation error, must return.
            //
            return FALSE;
        }

        // Finished with this line, advance the pointer past the NULL.
        //
        lpmszEnd++;
        dwSize++;

        // Go to the next item in the list.
        //
        lpcnHead = lpcnHead->lpNext;
    }

    // Add another NULL after the last item because the section has to be
    // double NULL terminated.
    //
    *lpmszEnd = NULLCHR;

    // If we are going to write anything...
    //
    if ( *lpmszSection )
    {
        // Clear out the section that might already exist.  We shouldn't have
        // to do this because when we write out the new section it should replace
        // the old one, but I don't trust these private profile APIs.
        //
        WritePrivateProfileSection(INI_SEC_WBOM_SYSPREP_CLEAN, NULLSTR, lpszInfFile);
    }

    // Now write out our new data.
    //
    WritePrivateProfileSection(INI_SEC_WBOM_SYSPREP_CLEAN, lpmszSection, lpszInfFile);

    // Now we are done with our buffer and we can free it (macro checks for NULL).
    //
    FREE(lpmszSection);

    // If we havent' returned yet, then everything must have worked.
    //
    return TRUE;
}

static void CloseCleanup(LPCLEANUP_NODE lpcnHead)
{
    LPCLEANUP_NODE  lpcnFree;

    // Loop through the list until they are all gone.
    //
    while ( lpcnHead )
    {
        // Save a pointer to the node we are going to free
        // (which is the first node in the list).
        //
        lpcnFree = lpcnHead;

        // Now advance the head pointer past the node we are
        // about to free.
        //
        lpcnHead = lpcnHead->lpNext;

        // Now we can free the data in the node.
        //
        FREE(lpcnFree->lpszService);

        // Now we can free the node itself.
        //
        FREE(lpcnFree);
    }
}

static BOOL AddStrToSect(LPTSTR * lplpmszSect, DWORD * lpcbSect, LPTSTR * lplpmszEnd, DWORD * lpdwSize, LPTSTR lpszStr)
{
    DWORD   dwStrLen = lstrlen(lpszStr),
            dwSizeNeeded;

    // Make sure our string will fit in the buffer that is
    // currently allocated.  We leave room for at least two
    // NULL terminators because we allways double terminate
    // in case this is the last string in the section.
    //
    dwSizeNeeded = *lpdwSize + dwStrLen + 2;
    if ( dwSizeNeeded >= *lpcbSect )
    {
        DWORD   cbNewSect = *lpcbSect;
        LPTSTR  lpmszNewSect;

        // Double the buffer size until we have enough room.
        //
        do
        {
            cbNewSect *= 2;
        }
        while ( ( cbNewSect <= dwSizeNeeded ) &&
                ( cbNewSect > *lpcbSect ) );

        // Make sure we didn't wrap around with our size
        // buffer (not likely, but doesn't hurt to check) and
        // that our realloc works.
        //
        if ( !( ( cbNewSect > *lpcbSect ) &&
                ( lpmszNewSect = (LPTSTR) REALLOC(*lplpmszSect, cbNewSect * sizeof(TCHAR)) ) ) )
        {
            // This is bad.  Free the buffer (the macro will NULL it out
            // so the caller can't use it).
            //
            FREE(*lplpmszSect);

            // Zero and NULL out all these other things so the caller
            // can't rely on them.
            //
            *lpcbSect = 0;
            *lplpmszEnd = NULL;
            *lpdwSize = 0;

            // Return now so we don't try to do anything else.
            //
            return FALSE;
        }

        // Woo hoo, we should be all good now.
        //
        *lplpmszEnd = lpmszNewSect + (*lplpmszEnd - *lplpmszSect);
        *lplpmszSect = lpmszNewSect;
        *lpcbSect = cbNewSect;
    }

    // At this point we must have room for our string, so copy it already.
    //
    lstrcpy(*lplpmszEnd, lpszStr);
    *lpdwSize += dwStrLen;
    *lplpmszEnd += dwStrLen;

    return TRUE;
}

static BOOL
OfflineSourcePath(
    HKEY    hkeySoftware,
    LPTSTR  lpszWindows,
    LPTSTR  lpszSourcePath,
    DWORD   cbSourcePath
    )
{
    BOOL    bRet                        = FALSE;
    LPTSTR  lpszOfflineSrc,
            lpszName                    = NULL;
    TCHAR   szWinPEDir[MAX_PATH]        = NULLSTR,
            szNewOfflineSrc[MAX_PATH]   = NULLSTR;
    UINT    uLen;

    // Get the offline source path from the offline hive.
    //
    if ( lpszOfflineSrc = RegGetExpand(hkeySoftware, REG_KEY_HIVE_SETUP_SETUP, REGSTR_VAL_SRCPATH) )
    {
        // In case the offline source path had the %systemroot% or %windir% environment variable in it,
        // we have to make sure the source path we got doesn't point to the WinPE system root.
        //
        // First get the current windows directory.
        //
        if ( ( uLen = GetSystemWindowsDirectory(szWinPEDir, AS(szWinPEDir)) ) &&
             ( szWinPEDir[0] ) )
        {
            // Now check to see if the source path we got starts with the WinPE directory.
            //
            if ( ( uLen <= (UINT) lstrlen(lpszOfflineSrc) ) &&
                 ( CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szWinPEDir, uLen, lpszOfflineSrc, uLen) == CSTR_EQUAL ) )
            {
                // Okay, it does.  So we want to construct a new buffer with the offline windows
                // directory passed in, and then with whatever was after the system root (if
                // anything).
                //
                lstrcpyn(szNewOfflineSrc, lpszWindows, AS(szNewOfflineSrc));
                if ( *(lpszOfflineSrc + uLen) )
                {
                    AddPathN(szNewOfflineSrc, lpszOfflineSrc + uLen, AS(szNewOfflineSrc));
                }
            }
        }

        // If we didn't make a new path, we should at least make sure
        // the drive leter is correct.
        //
        if ( NULLCHR == szNewOfflineSrc[0] )
        {
            // We need to make the offline source path based on the windows directory passed in and the
            // on in the offline registry.
            //
            if ( GetFullPathName(lpszWindows, AS(szNewOfflineSrc), szNewOfflineSrc, &lpszName) && szNewOfflineSrc[0] && lpszName )
            {
                // This should chop off the windows folder from the offline windows directory.
                //
                *lpszName = NULLCHR;

                // Now we should have the root of the system drive of the image, now add on what
                // was in the registry (passed the drive letter).
                //
                if ( lstrlen(lpszOfflineSrc) > 3 )
                {
                    AddPathN(szNewOfflineSrc, lpszOfflineSrc + 3, AS(szNewOfflineSrc));
                }
            }
            else
            {
                // That failed (shouldn't though) so just use the one from the offline registry, but change
                // the drive letter in case the image is on a different drive then it normally would be on.
                //
                lstrcpyn(szNewOfflineSrc, lpszOfflineSrc, AS(szNewOfflineSrc));
                szNewOfflineSrc[0] = *lpszWindows;
            }
        }

        // Now add on the arch folder.
        //
        if ( IsIA64() )
        {
            AddPathN(szNewOfflineSrc, DIR_IA64, AS(szNewOfflineSrc));
        }
        else
        {
            AddPathN(szNewOfflineSrc, DIR_I386, AS(szNewOfflineSrc));
        }

        // Make sure the folder exists.
        //
        if ( DirectoryExists(szNewOfflineSrc) )
        {
            bRet = TRUE;
            lstrcpyn(lpszSourcePath, szNewOfflineSrc, cbSourcePath);
        }

        // Free the buffer allocated.
        //
        FREE(lpszOfflineSrc);
    }

    // Return TRUE only if we reset the buffer.
    //
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\netcfg\implinc.cpp ===
#include "pch.h"
#pragma hdrstop
#include "idls_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\msdinst\main.c ===
/****************************************************************************\

    MAIN.C / Mass Storage Device Installer Tool (MSDINST.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Main source file for the MSD Installation stand alone tool.

    07/2001 - Jason Cohen (JCOHEN)

        Added this new source file for the new MSD Isntallation project.

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "res.h"
#include <winbom.h>
#include <msdinst.h>
#include <spapip.h>

//
// Local Define(s):
//

#define REG_KEY_WINPE       _T("SYSTEM\\CurrentControlSet\\Control\\MiniNT")
#define STR_MUTEX_MSDINST   _T("{97e6e509-16e5-40b8-91fd-c767306853a9}")

//
// Local Type Definition(s):
//
typedef struct _GAPP
{
    TCHAR   szInfPath[MAX_PATH];
    TCHAR   szWinDir[MAX_PATH];
}
GAPP, *LPGAPP;

//
// Internal Global Variable(s):
//
GAPP    g_App = {0};

//
// Local Prototype(s):
//

static BOOL
ParseCmdLine(
    LPGAPP lpgApp
    );

//
// Internal function(s):
//

static BOOL
ParseCmdLine(
    LPGAPP lpgApp
    )
{
    BOOL    bRet        = TRUE;
    DWORD   dwArgs,
            dwArg,
            dwOption,
            dwOther     = 0;
    LPTSTR  *lpArgs,
            lpArg,
            lpOption,
            lpOptions[] =
    {
        _T("FORCE")     // 0
    };

    // Call our function to process the command line and put it
    // into a nice list we can go through.
    //
    if ( (dwArgs = GetCommandLineArgs(&lpArgs) ) && lpArgs )
    {
        // We want to skip over the first argument (it is the path
        // to the command being executed).
        //
        if ( dwArgs > 1 )
        {
            dwArg = 1;
            lpArg = *(lpArgs + dwArg);
        }
        else
        {
            lpArg = NULL;
        }

        // Loop through all the arguments.
        //
        while ( lpArg && bRet )
        {
            // Now we check to see if the first char is a dash/slash or not.
            //
            if ( ( _T('-') == *lpArg ) ||
                 ( _T('/') == *lpArg ) )
            {
                lpOption = CharNext(lpArg);
                for ( dwOption = 0;
                      ( ( dwOption < AS(lpOptions) ) &&
                        ( 0 != lstrcmpi(lpOption, lpOptions[dwOption]) ) );
                      dwOption++ );

                // This is where you add command line options that start
                // with a dash (-) or a slash (/).  You add them in the static
                // array of pointers at the top of the function declaration and
                // you case off the index it is in the array (0 for the first one,
                // 1 for the second and so on).
                //
                switch ( dwOption )
                {
                    case 0: // -FORCE
                        //
                        // If the force switch is specified... set the flag.
                        //
                        SetOfflineInstallFlags( GetOfflineInstallFlags() | INSTALL_FLAG_FORCE );
                        break;

                    default:
                        bRet = FALSE;
                }
            }
            // Otherwise if there is something there it is just another argument.
            //
            else if ( *lpArg )
            {
                // This is where you add any command line options that don't
                // start with anything special.  We keep track of how many of
                // these guys we find, so just add a case for each one you want
                // to handle starting with 0.
                //
                switch ( dwOther++ )
                {
                    case 0:
                        
                        lstrcpyn(lpgApp->szInfPath, lpArg, AS(lpgApp->szInfPath));
                        break;

                    case 1:

                        lstrcpyn(lpgApp->szWinDir, lpArg, AS(lpgApp->szWinDir));
                        break;

                    default:
                        bRet = FALSE;
                }
            }

            // Setup the pointer to the next argument in the command line.
            //
            if ( ++dwArg < dwArgs )
            {
                lpArg = *(lpArgs + dwArg);
            }
            else
            {
                lpArg = NULL;
            }
        }

        // Make sure to free the two buffers allocated by the GetCommandLineArgs() function.
        //
        FREE(*lpArgs);
        FREE(lpArgs);
    }

    // If there were no unrecognized arguments, then we return TRUE.  Otherwise
    // we return FALSE.
    //
    return bRet;
}


//
// Main Fuction:
//

int __cdecl wmain(DWORD dwArgs, LPTSTR lpszArgs[])
{
    int     nErr = 0;
    HANDLE  hMutex;
    TCHAR   szInfFile[MAX_PATH] = NULLSTR,
            szWindows[MAX_PATH] = NULLSTR;
    LPTSTR  lpDontCare,
            lpszErr;
    HKEY    hkeySoftware,
            hkeySystem;
    DWORD   dwRet;
    
    // Initialize logging library.
    //
    OpkInitLogging(NULL, _T("MSDINST") );
    
    // Allways start with a line feed.
    //
    _tprintf(_T("\n"));

    // This tool is current only supported on WinPE.
    //
    if ( !RegExists(HKLM, REG_KEY_WINPE, NULL) )
    {
        if ( lpszErr = AllocateString(NULL, IDS_ERR_WINPE) )
        {
            _putts(lpszErr);
            _tprintf(_T("\n\n"));
            FREE(lpszErr);
        }

        return 1;
    }

    // Need to have two args, the full path to the inf file
    // with the controlers to install, and the path to the
    // windows direcotry of the offline image.
    //
    if ( (dwArgs < 3) || !ParseCmdLine( &g_App) )
    {
        if ( lpszErr = AllocateString(NULL, IDS_ARGS) )
        {
            _putts(lpszErr);
            _tprintf(_T("\n\n"));
            FREE(lpszErr);
        }

        return 1;
    }

    // Copy the command line parameters to our own buffers.
    //
    if ( !( GetFullPathName(g_App.szInfPath, AS(szInfFile), szInfFile, &lpDontCare) && szInfFile[0] ) ||
         !( GetFullPathName(g_App.szWinDir,  AS(szWindows), szWindows, &lpDontCare) && szWindows[0] ) )
    {
        //
        // Get the system text for "The specified path is invalid."
        //
        lpszErr = NULL;
        dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                               NULL,
                               ERROR_BAD_PATHNAME,
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                               (LPTSTR) &lpszErr,
                               0,
                               NULL );

        //
        // If the string was formatted, then let the user know something went wrong...
        //
        if ( dwRet && lpszErr )
        {
            _putts( lpszErr );
            _tprintf(_T("\n\n"));
            LocalFree( lpszErr );
            lpszErr = NULL;
        }

        return 1;   
    }

    // Make sure the inf file exists.
    //
    if ( !FileExists(szInfFile) )
    {
        if ( lpszErr = AllocateString(NULL, IDS_ERR_MISSING_INF_FILE) )
        {
            _tprintf(lpszErr, szInfFile);
            _tprintf(_T("\n\n"));
            FREE(lpszErr);
        }

        return 1;
    }

    // Make sure the inf file contains the section we need.
    //
    if ( !IniSettingExists(szInfFile, INI_SEC_WBOM_SYSPREP_MSD, NULL, NULL) )
    {
        if ( lpszErr = AllocateString(NULL, IDS_ERR_MISSING_INF_SECTION) )
        {
            _tprintf(lpszErr, szInfFile, INI_SEC_WBOM_SYSPREP_MSD);
            _tprintf(_T("\n\n"));
            FREE(lpszErr);
        }

        return 1;
    }

    // Make sure the image directory exists.
    //
    if ( !DirectoryExists(szWindows) )
    {
        if ( lpszErr = AllocateString(NULL, IDS_ERR_NOWINDOWS) )
        {
            _tprintf(lpszErr, szWindows);
            _tprintf(_T("\n\n"));
            FREE(lpszErr);
        }

        return 1;
    }

    // Only let one of this guy run.
    //
    hMutex = CreateMutex(NULL, FALSE, STR_MUTEX_MSDINST);
    if ( hMutex == NULL )
    {
        if ( lpszErr = AllocateString(NULL, IDS_ERR_ONEONLY) )
        {
            _putts(lpszErr);
            _tprintf(_T("\n\n"));
            FREE(lpszErr);
        }

        return 1;
    }

    // We have to be able to load the offline image to do anything.
    //
    if ( !RegLoadOfflineImage(szWindows, &hkeySoftware, &hkeySystem) )
    {
        if ( lpszErr = AllocateString(NULL, IDS_ERR_LOADIMAGE) )
        {
            _tprintf(lpszErr, szWindows);
            _tprintf(_T("\n\n"));
            FREE(lpszErr);
        }

        CloseHandle(hMutex);
        return 1;
    }

    // Now try to install the MSD into the offline image.
    //
    if ( !SetupCriticalDevices(szInfFile, hkeySoftware, hkeySystem, szWindows) )
    {
        if ( lpszErr = AllocateString(NULL, IDS_ERR_CDD) )
        {
            _putts(lpszErr);
            _tprintf(_T("\n\n"));
            FREE(lpszErr);
        }

        nErr = 1;
    }

    // Unload the offline image.
    //
    RegUnloadOfflineImage(hkeySoftware, hkeySystem);

    
    // Release the mutex.
    //
    CloseHandle(hMutex);

    
    if ( 0 == nErr )
    {
        if ( lpszErr = AllocateString(NULL, IDS_ERR_SUCCESS) )
        {
            _putts(lpszErr);
            _tprintf(_T("\n\n"));
            FREE(lpszErr);
        }
    }
    
    return nErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\netcfg\main.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M A I N . C P P
//
//  Contents:   Code to provide a simple cmdline interface to
//              the sample code functions
//
//  Notes:      The code in this file is not required to access any
//              netcfg functionality. It merely provides a simple cmdline
//              interface to the sample code functions provided in
//              file netcfg.cpp.
//
//  Author:     kumarp    28-September-98
//
//              vijayj    12-November-2000 
//                  - Adapt it for WinPE network installation
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "netcfg.h"
#include <string>
#include "msg.h"
#include <libmsg.h>

// ----------------------------------------------------------------------
// Global vars
//
BOOL g_fVerbose=FALSE;
BOOL MiniNTMode = FALSE;
static WCHAR* optarg;

//
// Global variables used to get formatted message for this program.
//
HMODULE ThisModule = NULL;
WCHAR Message[4096];

// ----------------------------------------------------------------------
void ShowUsage();
WCHAR getopt(ULONG Argc, WCHAR* Argv[], WCHAR* Opts);
enum NetClass MapToNetClass(WCHAR ch);

INT
MainEntry(
    IN INT      argc,
    IN WCHAR    *argv[]
    );

DWORD
InstallWinPENetworkComponents(
    IN INT      Argc,
    IN WCHAR    *Argv[]
    );


// ----------------------------------------------------------------------
//
// Function:  wmain
//
// Purpose:   The main function
//
// Arguments: standard main args
//
// Returns:   0 on success, non-zero otherwise
//
// Author:    kumarp 25-December-97
//
// Notes:
//
EXTERN_C int __cdecl wmain(int argc, WCHAR* argv[])
{
    INT Result = 0;
    ThisModule = GetModuleHandle(NULL);
    
    if ((argc > 1) && (argc < 4)) {
        Result = (INT)InstallWinPENetworkComponents(argc, argv);

        if (Result == ERROR_INVALID_DATA) {
            Result = MainEntry(argc, argv);
        }            
    } else {
        Result = MainEntry(argc, argv);
    }        

    return Result;
}

INT
MainEntry(
    IN INT      argc,
    IN WCHAR    *argv[]
    )
{    
    HRESULT hr=S_OK;
    WCHAR ch;
    enum NetClass nc=NC_Unknown;

    // use simple cmd line parsing to get parameters for actions
    // we want to perform. the order of parameters supplied is significant.

    static const WCHAR c_szValidOptions[] =
        L"hH?c:C:l:L:i:I:u:U:vVp:P:s:S:b:B:q:Q:";
    WCHAR szFileFullPath[MAX_PATH+1];
    PWSTR szFileComponent;

    MiniNTMode = IsMiniNTMode();

    while (_istprint(ch = getopt(argc, argv, (WCHAR*) c_szValidOptions)))
    {
        switch (tolower(ch))
        {
        case 'q':
            FindIfComponentInstalled(optarg);
            break;

        case 'b':
            hr = HrShowBindingPathsOfComponent(optarg);
            break;

        case 'c':
            nc = MapToNetClass(optarg[0]);
            break;

        case 'l':
            wcscpy(szFileFullPath, optarg);
            break;

        case 'i':
            if (nc != NC_Unknown)
            {
                hr = HrInstallNetComponent(optarg, nc, szFileFullPath);
            }
            else
            {
                ShowUsage();
                exit(-1);
            }
            break;

        case 'u':
            hr = HrUninstallNetComponent(optarg);
            break;

        case 's':
            switch(tolower(optarg[0]))
            {
            case 'a':
                hr = HrShowNetAdapters();
                break;

            case 'n':
                hr = HrShowNetComponents();
                break;

            default:
                ShowUsage();
                exit(-1);
                break;
            }
            break;

        case 'v':
            g_fVerbose = TRUE;
            break;

        case EOF:
            break;

        default:
        case 'h':
        case '?':
            ShowUsage();
            exit(0);
            break;
        }
    }

    return hr;
}    


//+---------------------------------------------------------------------------
//
// Function:  MapToNetClass
//
// Purpose:   Map a character to the corresponding net class enum
//
// Arguments:
//    ch [in]  char to map
//
// Returns:   enum for net class
//
// Author:    kumarp 06-October-98
//
// Notes:
//
enum NetClass MapToNetClass(WCHAR ch)
{
    switch(tolower(ch))
    {
    case 'a':
        return NC_NetAdapter;

    case 'p':
        return NC_NetProtocol;

    case 's':
        return NC_NetService;

    case 'c':
        return NC_NetClient;

    default:
        return NC_Unknown;
    }
}
// ----------------------------------------------------------------------
//
// Function:  ShowUsage
//
// Purpose:   Display program usage help
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 24-December-97
//
// Notes:
//
void ShowUsage()
{
    _putts( GetFormattedMessage( ThisModule,
                                  FALSE,
                                  Message,
                                  sizeof(Message)/sizeof(Message[0]),
                                  MSG_PGM_USAGE ) );
}



//+---------------------------------------------------------------------------
//
// Function:  getopt
//
// Purpose:   Parse cmdline and return one argument each time
//            this function is called.
//
// Arguments:
//    Argc [in]  standard main argc
//    Argv [in]  standard main argv
//    Opts [in]  valid options
//
// Returns:
//
// Author:    kumarp 06-October-98
//
// Notes:
//
WCHAR getopt (ULONG Argc, WCHAR* Argv[], WCHAR* Opts)
{
    static ULONG  optind=1;
    static ULONG  optcharind;
    static ULONG  hyphen=0;

    WCHAR  ch;
    WCHAR* indx;

    do {
        if (optind >= Argc) {
            return EOF;
        }

        ch = Argv[optind][optcharind++];
        if (ch == '\0') {
            optind++; optcharind=0;
            hyphen = 0;
            continue;
        }

        if ( hyphen || (ch == '-') || (ch == '/')) {
            if (!hyphen) {
                ch = Argv[optind][optcharind++];
                if (ch == '\0') {
                    optind++;
                    return EOF;
                }
            } else if (ch == '\0') {
                optind++;
                optcharind = 0;
                continue;
            }
            indx = wcschr(Opts, ch);
            if (indx == NULL) {
                continue;
            }
            if (*(indx+1) == ':') {
                if (Argv[optind][optcharind] != '\0'){
                    optarg = &Argv[optind][optcharind];
                } else {
                    if ((optind + 1) >= Argc ||
                        (Argv[optind+1][0] == '-' ||
                         Argv[optind+1][0] == '/' )) {
                        return 0;
                    }
                    optarg = Argv[++optind];
                }
                optind++;
                hyphen = optcharind = 0;
                return ch;
            }
            hyphen = 1;
            return ch;
        } else {
            return EOF;
        }
    } while (1);
}


BOOL
IsMiniNTMode(
    VOID
    )
/*++

Routine Description:

    Finds out if we are running under MiniNT environment

Arguments:

    none

Return value:

    TRUE if we are running under MiniNT environment
    otherwise FALSE

--*/
{
    BOOL    Result = FALSE;
    TCHAR   *MiniNTKeyName = TEXT("SYSTEM\\CurrentControlSet\\Control\\MiniNT");
    HKEY    MiniNTKey = NULL;
    LONG    RegResult;
    
    RegResult = RegOpenKey(HKEY_LOCAL_MACHINE,
                            MiniNTKeyName,
                            &MiniNTKey);

    if (RegResult == ERROR_SUCCESS) {
        Result = TRUE;
        RegCloseKey(MiniNTKey);
    }        

    return Result;
}


DWORD
InstallWinPENetworkComponents(
    IN INT      Argc,
    IN WCHAR    *Argv[]
    )
/*++

Routine Description:

    Installs the required network components for
    WinPE environment
        -   TCP/IP Stack
        -   NETBIOS Stack
        -   MS Client

    Note : This basically calls into MainEntry(...)
           manipulating the arguments as though user had
           entered them.

Arguments:

    Argc    -   Argument Count
    Argv    -   Arguments

Return value:

    Win32 Error code

--*/
{
    DWORD   Result = ERROR_INVALID_DATA;
    WCHAR   *NetArgs[] = { 
                TEXT("-l"),
                TEXT("\\inf\\nettcpip.inf"),
                TEXT("-c"),
                TEXT("p"),
                TEXT("-i"),
                TEXT("ms_tcpip"),
                TEXT("-l"),
                TEXT("\\inf\\netnb.inf"),
                TEXT("-c"),
                TEXT("s"),
                TEXT("-i"),
                TEXT("ms_netbios"),
                TEXT("-l"),
                TEXT("\\inf\\netmscli.inf"),
                TEXT("-c"),
                TEXT("c"),
                TEXT("-i"),
                TEXT("ms_msclient") };
    ULONG   TcpIpInfIdx = 1;
    ULONG   NetNbInfIdx = 7;
    ULONG   MsCliInfIdx = 13;

    if (Argc && Argv) {
        bool IsWinPE = false;
        bool VerboseInstall = false;

        for (ULONG Index = 1; Argv[Index]; Index++) {
            if (!_wcsicmp(Argv[Index], TEXT("-winpe"))) {
                IsWinPE = true;
            } else if (!_wcsicmp(Argv[Index], TEXT("-v"))) {
                VerboseInstall = true;
            }                
        }

        
        if (IsWinPE) {
            WCHAR   WinDir[MAX_PATH] = {0};
            PWSTR   VerboseArg = TEXT("-v");

            if (GetWindowsDirectory(WinDir, sizeof(WinDir)/sizeof(WinDir[0]))) {
                std::wstring  TcpIpFullPath = WinDir;
                std::wstring  NetNbFullPath = WinDir;
                std::wstring  MsClientFullPath = WinDir;

                TcpIpFullPath += NetArgs[TcpIpInfIdx];
                NetArgs[TcpIpInfIdx] = (PWSTR)TcpIpFullPath.c_str();

                NetNbFullPath += NetArgs[NetNbInfIdx];
                NetArgs[NetNbInfIdx] = (PWSTR)NetNbFullPath.c_str();

                MsClientFullPath += NetArgs[MsCliInfIdx];
                NetArgs[MsCliInfIdx] = (PWSTR)MsClientFullPath.c_str();

                ULONG   ArgsSize = (sizeof(NetArgs) + (sizeof(PWSTR) * 3));
                PWSTR   *Args = (PWSTR *)(new char[ArgsSize]);
                ULONG   NumArgs = ArgsSize / sizeof(PWSTR);

                
                if (Args) {                   
                    Index = 0;
                    Args[Index++] = Argv[0];


                    if (VerboseInstall) {
                        Args[Index++] = VerboseArg;
                    }                    


                    for (ULONG TempIndex = 0; 
                        (TempIndex < (sizeof(NetArgs)/sizeof(PWSTR)));
                        TempIndex++) {
                        Args[Index++] = NetArgs[TempIndex];
                    }                    

                    ULONG ArgCount = Index;

                    Args[Index++] = NULL;

                    Result = MainEntry(ArgCount, Args);

                    delete [](PSTR)Args;
                } else {
                    Result = GetLastError();
                }

            } else {
                Result = GetLastError();
            }                
        }
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\netcfg\pch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P C H . H
//
//  Contents:   Pre-compiled header file
//
//  Notes:
//
//  Author:     kumarp 28-September-98
//
//----------------------------------------------------------------------------

#pragma once

// Turns off "string too long - truncated to 255 characters in the debug
// information, debugger cannot evaluate symbol."
//
#pragma warning (disable: 4786)

#include <windows.h>
#include <netcfgx.h>
#include <netcfgn.h>

#include <setupapi.h>
#include <devguid.h>
#include <tchar.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\netcfg\netcfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S N E T C F G . H
//
//  Contents:   Sample code that demonstrates how to:
//              - find out if a component is installed
//              - install a net component
//              - install an OEM net component
//              - uninstall a net component
//              - enumerate net components
//              - enumerate net adapters using Setup API
//              - enumerate binding paths of a component
//
//  Notes:
//
//  Author:     kumarp 26-March-98
//
//----------------------------------------------------------------------------

#pragma once

enum NetClass
{
    NC_NetAdapter=0,
    NC_NetProtocol,
    NC_NetService,
    NC_NetClient,
    NC_Unknown
};

void FindIfComponentInstalled(IN PCWSTR szComponentId);

HRESULT HrInstallNetComponent(IN PCWSTR szComponentId,
                              IN enum NetClass nc,
                              IN PCWSTR szSrcDir);

HRESULT HrUninstallNetComponent(IN PCWSTR szComponentId);


HRESULT HrShowNetAdapters();
HRESULT HrShowNetComponents();
HRESULT HrShowBindingPathsOfComponent(IN PCWSTR szComponentId);

extern BOOL MiniNTMode;

//
// Global variables required to format message using GetFormattedMessage(..)
// from libmsg.lib
//
extern HMODULE ThisModule;
extern WCHAR Message[4096];

BOOL
IsMiniNTMode(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oemmint\oemmint.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    oemmint.cpp

Abstract:

    Simple tool to create a Mini NT image
    from a regular NT image

Author:

    Vijay Jayaseelan (vijayj) Apr-23-2000

Revision History:

    Aug-08-2000 - Major rewrite using setupapi wrapper
                  class library.

    Nov-10-2000 - Made the utility work with actual
                  distribution CD.

    Jan-23-2001 - Add support for version checking.

    Feb-09-2002 - Add support for multiple driver cab
                  file extraction.

    Apr-15-2002 - Modify tool to work on both layouts (placement)
                  of SxS assemblies on release share. It used to be in 
                  ASMS folder but now is in asms*.cab file.

    NOTE:         This tool needs to be updated on changes to 
                  entries to the disk ordinals for WOW64 files.!!!!
                  Change needs to go in IsWow64File(..)
--*/

#include <oemmint.h>
#include <iostream>
#include <io.h>
#include <sxsapi.h>
#include "msg.h"
#include <libmsg.h>
using namespace std;



//
// static constant data members
//
const std::basic_string<TCHAR> DriverIndexInfFile<TCHAR>::VersionSectionName = TEXT("version");
const std::basic_string<TCHAR> DriverIndexInfFile<TCHAR>::CabsSectionName = TEXT("cabs");
const std::basic_string<TCHAR> DriverIndexInfFile<TCHAR>::CabsSearchOrderKeyName = TEXT("cabfiles");

//
// Constants
//
const std::wstring REGIONAL_SECTION_NAME = TEXT("regionalsettings");
const std::wstring LANGUAGE_GROUP_KEY = TEXT("languagegroup");
const std::wstring LANGUAGE_KEY = TEXT("language");
const std::wstring LANGGROUP_SECTION_PREFIX = TEXT("lg_install_");
const std::wstring DEFAULT_LANGGROUP_NAME = TEXT("lg_install_1");
const std::wstring LOCALES_SECTION_NAME = TEXT("locales");
const std::wstring FONT_CP_REGSECTION_FMT_STR = TEXT("font.cp%s.%d");
const std::wstring X86_PLATFORM_DIR = TEXT("i386");
const std::wstring IA64_PLATFORM_DIR = TEXT("ia64");
const std::wstring INFCHANGES_SECTION_NAME = TEXT("infchanges");


const DWORD LANG_GROUP1_INDEX = 2;
const DWORD OEM_CP_INDEX = 1;
const DWORD DEFAULT_FONT_SIZE = 96;

//
// Global variables used to get formatted message for this program.
//
HMODULE ThisModule = NULL;
WCHAR Message[4096];

//
// Main entry point
//
int 
__cdecl
wmain(int Argc, wchar_t* Argv[])
{
  int Result = 0;
  ThisModule = GetModuleHandle(NULL);

  try{        
    //
    // parse the arguments
    //
    UnicodeArgs Args(Argc, Argv);

    //
    // Check to see if we are using this utility to check the version
    //
    if (!Args.CheckVersion) {

        if (Args.Verbose) {
            cout << GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_CREATING_WINPE_FILE_LIST) << endl;
        }        
        
        //
        // open the config.inf file
        //
        if (Args.Verbose) {
            cout << GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_PARSING_FILE,
                                        Args.ConfigInfFileName.c_str()) << endl;
        }        
        
        InfFileW  ConfigInfFile(Args.ConfigInfFileName);
        
        //
        // open the layout.inf file
        //
        if (Args.Verbose) {
            cout << GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_PARSING_FILE,
                                        Args.LayoutName.c_str()) << endl;
        }        
        
        InfFileW  InputFile(Args.LayoutName);

        //
        // open the drvindex.inf file
        //
        if (Args.Verbose) {
    	    cout << GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_PARSING_FILE,
                                        Args.DriverIndexName.c_str()) << endl;
        }        

        DriverIndexInfFile<WCHAR> DriverIdxFile(Args.DriverIndexName);

        //
        // open the intl.inf file
        //
        if (Args.Verbose) {
            cout << GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_PARSING_FILE,
                                        Args.IntlInfFileName.c_str()) << endl;
        }        
        
        InfFileW  IntlInfFile(Args.IntlInfFileName);

        //
        // open the font.inf file
        //
        if (Args.Verbose) {
    	    cout << GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_PARSING_FILE,
                                        Args.FontInfFileName.c_str()) << endl;
        }        
        
        InfFileW  FontInfFile(Args.FontInfFileName);
        
        
        map<std::basic_string<wchar_t>, Section<wchar_t>* >  Sections;

        //
        // get hold of the sections in the layout file
        //
        InputFile.GetSections(Sections);
        
        //
        // get hold of "[SourceDisksFiles] section
        //
        map<basic_string<wchar_t>, Section<wchar_t> * >::iterator iter = Sections.find(L"sourcedisksfiles");

        Section<wchar_t> *SDSection = 0;
        Section<wchar_t> *DirSection = 0;
        Section<wchar_t> *PlatSection = 0;

        if (iter != Sections.end()) {
            SDSection = (*iter).second;
        }

        //
        // get hold of the [WinntDirectories] section
        //
        iter = Sections.find(L"winntdirectories");

        if (iter != Sections.end()) {
            DirSection = (*iter).second;
        }

        //
        // get hold of the platform specific source files section
        //
        basic_string<wchar_t> PlatformSection = SDSection->GetName() + L"." + Args.PlatformSuffix;

        iter = Sections.find(PlatformSection);

        if (iter != Sections.end()) {
            PlatSection = (*iter).second;
        }

        //
        // Merge the platform and common source files section
        //
        if (PlatSection) {
            if (Args.Verbose) {
                 cout << GetFormattedMessage(   ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_MERGING_PLATFORM_AND_COMMON_SRC_FILES,
                                                PlatSection->GetName().c_str(),
                                                SDSection->GetName().c_str()) << endl;
            }               

            *SDSection += *PlatSection;
        }        


        //
        // Iterate through each file in the common merged section
        // creating a file list of minint image
        //
        FileListCreatorContext<wchar_t> fl(Args, SDSection, 
                                           DirSection, ConfigInfFile,
                                           IntlInfFile, FontInfFile,
                                           DriverIdxFile);
        
        //
        // Create the list of files to be copied
        //
        SDSection->DoForEach(FileListCreator, &fl);

        //
        // Process Nls files
        //
        ULONG NlsFileCount = fl.ProcessNlsFiles();
        
        if (Args.Verbose) {
            std::cout << GetFormattedMessage(   ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_DUMP_PROCESSED_NLS_FILE_COUNT,
                                                NlsFileCount) << std::endl;
        }                 

        //
        // Process WinSxS files
        //
        ULONG SxSFileCount = ProcessWinSxSFiles(fl);

        if (Args.Verbose) {
    	    std::cout << GetFormattedMessage(   ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_DUMP_PROCESSED_SXS_FILE_COUNT,
                                                SxSFileCount) << std::endl;
        }                 
        

        //
        // If there are extra files specified then process them  and
        // add to the file list for minint image
        //
        if (Args.ExtraFileName.length() > 0) {
            ULONG ExtraFiles = ProcessExtraFiles(fl);

            if (Args.Verbose) {
    	        cout << GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_DUMP_PROCESSED_EXTRA_FILES,
                                            ExtraFiles,
            	                            fl.Args.ExtraFileName.c_str()) << endl;
            }                 
        }

        //
        // Create all the required destination directories
        //
        ULONG   DirsCreated = PreCreateDirs(fl);
        
        //
        // Ok, now copy the list of files
        //
        ULONG FilesToCopy = fl.GetSourceCount();
        
        if (FilesToCopy) {        
            ULONG   Count = CopyFileList(fl);

            Result = FilesToCopy - Count;
            
            if (Result || Args.Verbose) {
    	        cout << GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_NUMBER_OF_FILES_COPIED,
                                            Count, 
            	                            FilesToCopy ) << endl;
            }                 
        }      

        //
        // Now process the required inf changes
        //
        wstring ControlInf = Args.CurrentDirectory + L"config.inf";

        if (!IsFilePresent(ControlInf)) {
            throw new W32Exception<wchar_t>(ERROR_FILE_NOT_FOUND);
        }        

        ProcessInfChanges(Args, ControlInf);
    } else {
        //
        // Check the version of the current OS and the install media
        // to make sure that they match
        //
        Result = CheckMediaVersion(Args) ? 0 : 1;
    }
  } 
  catch (InvalidArguments *InvArgs) {
    cerr << GetFormattedMessage(ThisModule,
                                FALSE,
                                Message,
                                sizeof(Message)/sizeof(Message[0]),
                                MSG_PGM_USAGE) << endl;
        
    delete InvArgs;
    Result = 1;
  }
  catch (BaseException<wchar_t> *Exp) {
    Exp->Dump(std::cout);
    delete Exp;
    Result = 1;
  }
  catch (...) {
    Result = 1;
  }
   
  return Result;
}


//
// Processes all the inf files and adds them to the copy list
// to copy to the destination\inf directory
// NOTE : This routine only processes net*.inf file automatically.
// Other inf needs to be marked specifically 
//
template <class T>
BOOLEAN
InfFileListCreator(
    SectionValues<T> &Values,
    FileListCreatorContext<T> &Context
    )
{    
    //
    // Note : All the inf files in layout always end with ".inf"
    // lowercase characters
    //
    basic_string<T>             Key = Values.GetName(); 
    basic_string<T>::size_type  InfIdx = Key.find(L".inf");    
    BOOLEAN                     Result = FALSE;
    static bool                 DirAdded = false;
    basic_string<T>::size_type  NetIdx = Key.find(L"net");

    if (!Context.SkipInfFiles && (InfIdx != basic_string<T>::npos) && (NetIdx == 0)) {
        Result = TRUE;        

        if (sizeof(T) == sizeof(CHAR)) {
            _strlwr((PSTR)Key.c_str());
        } else {
            _wcslwr((PWSTR)Key.c_str());
        }

        basic_string<T> SrcFile = Context.Args.SourceDirectory + Key;
        basic_string<T> DestFile;
        bool DestDirPresent = false;

        if (Values.Count() > 12) {
            basic_string<T> DestDir = Values.GetValue(12);

            //
            // remove trailing white spaces
            //            
            unsigned int DestDirLength = DestDir.length();

            while (DestDirLength) {
                if (DestDir[DestDirLength] != L' ') {
                    break;
                }        

                DestDir[DestDirLength] = 0;
                DestDirLength--;
            }            

            //
            // if the destination directory ID is 0 then skip
            // the file
            //
            if (DestDir == L"0") {
                return TRUE;
            }

            if (DestDir.length()) {
                basic_string<T> DestDirCode = DestDir;
                DestDir = Context.DirsSection->GetValue(DestDir).GetValue(0);
                
                if (DestDir.length()) {
                    if (DestDir[DestDir.length() - 1] != L'\\') {
                        DestDir += L"\\";
                    }   

                    DestDir = Context.Args.DestinationDirectory + DestDir;
                    
                    //
                    // Cache the directory, if not already done
                    //
                    if (Context.DestDirs.find(DestDirCode) == 
                            Context.DestDirs.end()) {
                        Context.DestDirs[DestDirCode] = DestDir;
                    }         

                    DestDirPresent = true;
                    DestFile = DestDir;
                }                        
            }
        }

        if (!DestDirPresent) {
            DestFile = Context.Args.DestinationDirectory + L"Inf\\"; 

            if (!DirAdded) {
                //
                // Inf directory's code is 20
                //
                basic_string<T> DestDirCode(L"20");

                //
                // Cache the directory, if not already done
                //
                if (Context.DestDirs.find(DestDirCode) == 
                        Context.DestDirs.end()) {
                    Context.DestDirs[DestDirCode] = DestFile;
                }                

                DirAdded = true;
            }                
        }                

        if (Values.Count() > 10) {
            const basic_string<T> &DestName = Values.GetValue(10);

            if (DestName.length()) {
                DestFile += DestName;
            } else {                    
                DestFile += Key;
            }                
        } else {
            DestFile += Key;
        }            

        bool  AlternateFound = false;

        if (Context.Args.OptionalSrcDirectory.length()) {
            basic_string<T> OptionalSrcFile = Context.Args.OptionalSrcDirectory + Key;

            if (IsFilePresent(OptionalSrcFile)) {
                SrcFile = OptionalSrcFile;
                AlternateFound = true;
            }
        } 

        const basic_string<T> &DriverCabFileName = Context.GetDriverCabFileName(Key);

        if (!AlternateFound && DriverCabFileName.length()) {
            SrcFile = Key;
        }            

        if (DriverCabFileName.length()) {            
            Context.AddFileToCabFileList(DriverCabFileName, SrcFile, DestFile);        
        } else if (Context.ProcessingExtraFiles) {
            Context.ExtraFileList[SrcFile] = DestFile;
        } else {                    
            Context.FileList[SrcFile] = DestFile;                
        }            
    }

    return Result;
}

//
// Parses the value to determine, if this file needs
// to be in minint and adds the file to the file list
// if this file is needed
//
template <class T>
void
FileListCreator(SectionValues<T> &Values, void *Context) {        
    FileListCreatorContext<T>  *FlContext = (FileListCreatorContext<T> *)(Context);
    unsigned int Count = Values.Count() ;
    bool Compressed = false;

    if (FlContext && !IsFileSkipped(Values, *FlContext) && 
        !InfFileListCreator(Values, *FlContext) && (Count > 12)) {
        
        basic_string<T>  SrcDir = Values.GetValue(11);
        basic_string<T>  DestDir = Values.GetValue(12);
        basic_string<T>  Key = Values.GetName();

        if (sizeof(T) == sizeof(CHAR)) {
            _strlwr((PSTR)Key.c_str());
        } else {
            _wcslwr((PWSTR)Key.c_str());
        }                

        //
        // remove trailing white spaces
        //            
        unsigned int DestDirLength = DestDir.length();

        while (DestDirLength) {
            if (DestDir[DestDirLength] != L' ') {
                break;
            }        

            DestDir[DestDirLength] = 0;
            DestDirLength--;
        }            

        //
        // if the destination directory ID is 0 then skip
        // the file
        //
        if (DestDir == L"0") {
            return;
        }
        
        basic_string<T> SrcSubDir = FlContext->DirsSection->GetValue(SrcDir).GetValue(0);
        basic_string<T> DestSubDir = FlContext->DirsSection->GetValue(DestDir).GetValue(0);
        basic_string<T> DestDirCode = DestDir;

        //
        // Fix up diretory names
        //
        if (SrcSubDir.length() && (SrcSubDir[SrcSubDir.length() - 1] != L'\\')) {
            SrcSubDir += L"\\";
        }

        if (DestSubDir.length() && (DestSubDir[DestSubDir.length() - 1] != L'\\')) {
            DestSubDir += L"\\";
        }

        basic_string<T> OptSrcDir = FlContext->Args.OptionalSrcDirectory;

        SrcDir = FlContext->Args.SourceDirectory;

        if (SrcSubDir != L"\\") {
            SrcDir += SrcSubDir;

            if (OptSrcDir.length()) {
                OptSrcDir += SrcSubDir;
            }
        }        
        
        DestDir = FlContext->Args.DestinationDirectory;

        if (DestSubDir != L"\\") {
            DestDir += DestSubDir;
        }

        //
        // Cache the directory, if not already done
        //
        if (FlContext->DestDirs.find(DestDirCode) == 
                FlContext->DestDirs.end()) {
            FlContext->DestDirs[DestDirCode] = DestDir;
        }                

        basic_string<T> SrcFile, DestFile;
        bool AltSrcDir = false;

        if (OptSrcDir.length()) {
            SrcFile = OptSrcDir + Key;
            AltSrcDir = IsFilePresent(SrcFile);
        }            

        const basic_string<T> &DriverCabFileName = FlContext->GetDriverCabFileName(Key);
        bool DriverCabFile = false;        

        if (!AltSrcDir) {
            SrcFile = SrcDir + Key;            
            basic_string<T> CompressedSrcName = SrcFile;

            CompressedSrcName[CompressedSrcName.length() - 1] = TEXT('_');
            
            if (!IsFilePresent(SrcFile) && !IsFilePresent(CompressedSrcName)) {
                if (DriverCabFileName.length()) {
                    SrcFile = Key;
                    DriverCabFile = true;
                }                    
            }                
        }
        
        DestFile = Values.GetValue(10);

        if (!DestFile.length()) {
            DestFile = Key;
        }

        DestFile = DestDir + DestFile;

        if (DriverCabFile) {
            FlContext->AddFileToCabFileList(DriverCabFileName, SrcFile, DestFile);
        } else if (FlContext->ProcessingExtraFiles) {
            FlContext->ExtraFileList[SrcFile] = DestFile;
        } else {
            FlContext->FileList[SrcFile] = DestFile;
        }            
    }
}


//
// CAB file callback routine, which does the actual
// check of whether to extract the file or skip the
// file
//
template <class T>
UINT
CabinetCallback(
    PVOID       Context,
    UINT        Notification,
    UINT_PTR    Param1,
    UINT_PTR    Param2
    )
{
    UINT    ReturnCode = NO_ERROR;
    FileListCreatorContext<T> *FlContext = (FileListCreatorContext<T> *)Context;
    PFILE_IN_CABINET_INFO   FileInfo = NULL;                    
    PFILEPATHS              FilePaths = NULL;
    basic_string<T>         &FileName = FlContext->CurrentFileName;

   
    map<basic_string<T>, basic_string<T> >::iterator Iter;
    map<basic_string<T>, basic_string<T> >::iterator FlIter;
    
    switch (Notification) {
        case SPFILENOTIFY_FILEINCABINET:
            {
                ReturnCode = FILEOP_SKIP;
                FileInfo = (PFILE_IN_CABINET_INFO)Param1;

                if (sizeof(T) == sizeof(CHAR)) {
                    FileName = (const T *)(FileInfo->NameInCabinet);
                    _strlwr((PSTR)(FileName.c_str()));
                } else {
                    FileName = (const T *)(FileInfo->NameInCabinet);
                    _wcslwr((PWSTR)(FileName.c_str()));
                }                
                
                Iter = FlContext->CabFileListMap[FlContext->CurrentCabFileIdx]->find(FileName);                


                if (Iter != FlContext->CabFileListMap[FlContext->CurrentCabFileIdx]->end()) {
                    if (!FlContext->Args.SkipFileCopy) {
                        if (sizeof(T) == sizeof(CHAR)) {
                            (VOID)StringCchCopyA((PSTR)(FileInfo->FullTargetName),
                                                    ARRAY_SIZE(FileInfo->FullTargetName),
                                                    (PCSTR)((*Iter).second).c_str());                          
                        } else {                                
                            (VOID)StringCchCopyW((PWSTR)(FileInfo->FullTargetName),
                                                    ARRAY_SIZE(FileInfo->FullTargetName),
                                                    (PCWSTR)((*Iter).second).c_str());                                
                        }                 
                        
                        ReturnCode = FILEOP_DOIT;                                        
                    } else {                
                        ReturnCode = FILEOP_SKIP;
                        FlContext->FileCount++;
                        
                        if (FlContext->Args.Verbose) {
         	                std::cout << GetFormattedMessage(ThisModule,
                                                            FALSE,
                                                            Message,
                                                            sizeof(Message)/sizeof(Message[0]),
                                                            MSG_EXTRACT_FILES_FROM_CAB_NOTIFICATION,
                                                            FlContext->CurrentCabFileIdx.c_str(),
                                                            FileName.c_str(),
                                                            (*Iter).second.c_str()) << std::endl;
                        }                                      
                    }
                }                                 
            } 
            break;

        case SPFILENOTIFY_FILEEXTRACTED:
            FilePaths = (PFILEPATHS)Param1;

            if (FilePaths->Win32Error) {  
    	        std::cout << GetFormattedMessage(ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_ERROR_EXTRACTING_FILES,
                                                FilePaths->Win32Error,
                                                FilePaths->Source,
                                                FileName.c_str(), 
                                                FilePaths->Target) << std::endl;
    	        
         
            } else {
                FlContext->FileCount++;

                if (FlContext->Args.Verbose) {
                    std::cout << GetFormattedMessage(ThisModule,
                                                    FALSE,
                                                    Message,
                                                    sizeof(Message)/sizeof(Message[0]),
                                                    MSG_EXTRACTED_FILES_FROM_CAB_NOTIFICATION,
                                                    FilePaths->Source,
                                                    FileName.c_str(),
                                                    FilePaths->Target) << std::endl;
                }
            }                
            
            break;
            
        default:
            break;
    }

    return ReturnCode;
}   


//
// Copies all the required files in given CAB file to the specified
// destination directory
//
template <class T>
ULONG
CopyCabFileList(
    FileListCreatorContext<T>   &Context,
    const std::basic_string<T>  &CabFileName
    )
{
    ULONG   Count = Context.FileCount;

    
    if (Context.CabFileListMap.size()) {
        BOOL Result = FALSE;
        
        if (sizeof(T) == sizeof(CHAR)) {
            Result = SetupIterateCabinetA((PCSTR)CabFileName.c_str(),
                            NULL,
                            (PSP_FILE_CALLBACK_A)CabinetCallback<char>,
                            &Context);
        } else {
            Result = SetupIterateCabinetW((PCWSTR)CabFileName.c_str(),
                            NULL,
                            (PSP_FILE_CALLBACK_W)CabinetCallback<wchar_t>,
                            &Context);                                
        }                        

        if (!Result) {
            
            cout << GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_ERROR_ITERATING_CAB_FILE,
                                        GetLastError(),
                                        CabFileName.c_str()) << endl;
        }
    }        

    return Context.FileCount - Count;
}

template <class T>
ULONG
CopySingleFileList(
    FileListCreatorContext<T> &Context,
    map<basic_string<T>, basic_string<T> > &FileList
    )
{  
    ULONG   Count = 0;

    map<basic_string<T>, basic_string<T> >::iterator Iter = FileList.begin();
        
    while (Iter != FileList.end()) {
        DWORD   ErrorCode = 0;
        if (!Context.Args.SkipFileCopy) {
            if (sizeof(T) == sizeof(CHAR)) {
                ErrorCode = SetupDecompressOrCopyFileA(
                                (PCSTR)((*Iter).first.c_str()),
                                (PCSTR)((*Iter).second.c_str()),
                                NULL);
            } else {
                ErrorCode = SetupDecompressOrCopyFileW(
                                (PCWSTR)((*Iter).first.c_str()),
                                (PCWSTR)((*Iter).second.c_str()),
                                NULL);
            }
        }            

        if (!ErrorCode) {
            Count++;

            if (sizeof(T) == sizeof(CHAR)) {
                ErrorCode = SetFileAttributesA((LPCSTR)((*Iter).second.c_str()),
                                FILE_ATTRIBUTE_NORMAL);
            } else {
                ErrorCode = SetFileAttributesW((LPCWSTR)((*Iter).second.c_str()),
                                FILE_ATTRIBUTE_NORMAL);
            }
            
            if (Context.Args.SkipFileCopy) {
                std::cout << GetFormattedMessage(ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_WILL_COPY) ;
            
            }

            if (Context.Args.Verbose) {
                std::cout << GetFormattedMessage(ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_FILE_NAME,
            	                                (*Iter).first.c_str(),
            	                                (*Iter).second.c_str()) << std::endl;
            }
        } else {
    	    std::cout << GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_ERROR_COPYING_FILES,
                                            ErrorCode,
                                            (*Iter).first.c_str(),
                                            (*Iter).second.c_str()) << std::endl;
        }

        Iter++;
    }        

    return Count;
}            

//
// Iterates through a file list  and copies the files
// from the specified source directory to the destination
// directory
//
template <class T>
ULONG
CopyFileList(
  FileListCreatorContext<T> &Context
  )
{
    ULONG Count = 0;

    std::map<std::basic_string<T>, 
        std::map<std::basic_string<T>, std::basic_string<T> > * >::iterator Iter;

    for (Iter = Context.CabFileListMap.begin(); 
        Iter != Context.CabFileListMap.end();
        Iter++) {
        basic_string<T> FullCabFileName = Context.Args.SourceDirectory + (*Iter).first;
        Context.CurrentCabFileIdx = (*Iter).first;                
        Count += CopyCabFileList(Context, FullCabFileName);            
    }   

    Count += CopySingleFileList(Context, Context.FileList);
    Context.FileCount += Count;

    Count += CopySingleFileList(Context, Context.NlsFileMap);
    Context.FileCount += Count;

    Count += CopySingleFileList(Context, Context.WinSxSFileList);
    Context.FileCount += Count;
    
    Count += CopySingleFileList(Context, Context.ExtraFileList);
    Context.FileCount += Count;

    return Count;
}

//
// Processes the extra files from the specified file name
// other than those present in the layout.inf file.
// Adds the files to the file list for MiniNT image
//
template <class T>
ULONG
ProcessExtraFiles(FileListCreatorContext<T> &Context) {   
    ULONG       Count = 0;
    InfFile<T>  ExtraFile(Context.Args.ExtraFileName);

    basic_string<T> ExtraSecName = TEXT("extrafiles");
    basic_string<T> PlatExtraSecName = ExtraSecName + TEXT(".") + Context.Args.PlatformSuffix;
    Section<T>   *ExtraFilesSec = ExtraFile.GetSection(ExtraSecName.c_str());    
    Section<T>   *PlatExtraFilesSec = ExtraFile.GetSection(PlatExtraSecName.c_str());

    if (ExtraFilesSec) {    
        Context.ProcessingExtraFiles = true;
        ExtraFilesSec->DoForEach(FileListCreator, &Context);
        Context.ProcessingExtraFiles = false;
        Count += Context.ExtraFileList.size();
    }

    if (PlatExtraFilesSec) {
        Context.ProcessingExtraFiles = true;
        PlatExtraFilesSec->DoForEach(FileListCreator, &Context);
        Context.ProcessingExtraFiles = false;
        Count += (Context.ExtraFileList.size() - Count);
    }        
        
    return Count;
}

//
// Goes through the list of desination directories and precreates
// them
//
template <class T>
ULONG
PreCreateDirs(
  FileListCreatorContext<T> &Context
  )
{
    ULONG   Count = 0;

    std::map< std::basic_string<T>, std::basic_string<T> >::iterator
            Iter = Context.DestDirs.begin();

    while (Iter != Context.DestDirs.end()) {
        if (CreateDirectories((*Iter).second, NULL)) {
            if (Context.Args.Verbose) {
    	        std::cout << GetFormattedMessage(ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_CREATING_DIRECTORIES,
                                                (*Iter).second.c_str()) << std::endl;
            }                                
            
            Count++;
        }
        
        Iter++;
    }

    return Count;
}

//
// Creates the directory (including subdirectories)
//
template <class T>
bool 
CreateDirectories(const basic_string<T> &DirName,
    LPSECURITY_ATTRIBUTES SecurityAttrs) {
    
    bool Result = false;
    std::vector<std::basic_string<T> > Dirs;
    std::basic_string<T> Delimiters((T *)TEXT("\\"));
    std::basic_string<T> NextDir;

    if (Tokenize(DirName, Delimiters, Dirs)) {
        std::vector<std::basic_string<T> >::iterator Iter = Dirs.begin();

        while (Iter != Dirs.end()) {
            NextDir += (*Iter);

            if (sizeof(T) == sizeof(CHAR)) {
                if (_access((PCSTR)NextDir.c_str(), 0)) {
                    Result = (CreateDirectoryA((PCSTR)NextDir.c_str(),
                                    SecurityAttrs) == TRUE);
                }                                    
            } else {
                if (_waccess((PCWSTR)NextDir.c_str(), 0)) {
                    Result = (CreateDirectoryW((PCWSTR)NextDir.c_str(),
                                    SecurityAttrs) == TRUE);
                }                                    
            }

            Iter++;
            NextDir += (T *)TEXT("\\");            
        }
    }

    return Result;
}

//
// Determines if the given file (or directory) is present
//
template <class T>
bool
IsFilePresent(const basic_string<T> &FileName) {
    bool Result = false;

    if (sizeof(T) == sizeof(CHAR)) {
        Result = (::_access((PCSTR)FileName.c_str(), 0) == 0);
    } else {
        Result = (::_waccess((PCWSTR)FileName.c_str(), 0) == 0);
    }

    return Result;
}


//
// Determines if the file is Wow64 file (only valid in IA64) case
//
template <class T>
bool 
IsWow64File(
    SectionValues<T> &Values,
    FileListCreatorContext<T>   &Context
    )
{
    bool Result = false;

    if (Values.Count() > 0) {        
        //
        // NOTE : DiskID == 55 for wowfiles. In XPSP1 it is 155.
        //
        Result = ((Values.GetValue(0) == L"55")||
                  (Values.GetValue(0) == L"155"));
    }            
       
    return Result;
}

//
// Determines if the record (file) needs to be skipped or not
//
template <class T>
bool
IsFileSkipped(
    SectionValues<T>            &Values,
    FileListCreatorContext<T>   &Context
    )
{
    bool Result = false;

    if (Context.Args.WowFilesPresent && Context.Args.SkipWowFiles) {
        Result = IsWow64File(Values, Context);
    }

    return Result;
}

//
// InfProcessing context
//
template <class T>
struct InfProcessingErrors {
    vector<basic_string<T> >    FileList;
    Arguments<T>                &Args;

    InfProcessingErrors(Arguments<T> &TempArgs) : Args(TempArgs){}
};               


//
// Inf processing worker routine
//
template <class T>
VOID
InfFileChangeWorker(
    SectionValues<T> &Values, 
    PVOID CallbackContext
    )
{
    InfProcessingErrors<T> *ProcessingContext =
                (InfProcessingErrors<T> *)CallbackContext;

    if (ProcessingContext) {
        InfProcessingErrors<T> &Context = *ProcessingContext;
        T       Buffer[4096] = {0};
        DWORD   CharsCopied = 0;
        BOOL    WriteResult = FALSE;
        basic_string<T> FileName;

        FileName = Context.Args.DestinationDirectory;
        FileName += Values.GetValue(0);
       
        basic_string<T> Value = Values.GetValue(2);

        if (Value.find(L' ') != Value.npos) {
            Value = L"\"" + Value + L"\"";
        }                
    
        if (sizeof(T) == sizeof(CHAR)) {                
            WriteResult = WritePrivateProfileStringA((PCSTR)Values.GetValue(1).c_str(),
                            (PCSTR)Values.GetName().c_str(),
                            (PCSTR)Value.c_str(),
                            (PCSTR)FileName.c_str());
        } else {        
            WriteResult = WritePrivateProfileStringW((PCWSTR)Values.GetValue(1).c_str(),
                            (PCWSTR)Values.GetName().c_str(),
                            (PCWSTR)Value.c_str(),
                            (PCWSTR)FileName.c_str());
        }                                   

        if (!WriteResult) {
            Context.FileList.push_back(Values.GetName());
        }
    }
}

//
// Given the control inf, reads the [infchanges] section
// and changes each of the specified value of the specified
// inf in destination directory to given value
//
// The format for the [infchanges] section is
// <[sub-directory]\><inf-name>=<section-name>,<key-name>,<new-value>
//
template <class T>
bool
ProcessInfChanges(
    Arguments<T>            &Args,
    const basic_string<T>   &InfName
    )
{
    bool Result = false;


    try{
        InfFile<T>  ControlInf(InfName);
        
        Section<T>  *ChangeSection = ControlInf.GetSection(INFCHANGES_SECTION_NAME);
        
        T SectionStringBuffer[16] = {0};
        
        if (sizeof(T) == sizeof(CHAR)) {
            (VOID)StringCchPrintfA((PSTR)SectionStringBuffer, 
                                   ARRAY_SIZE(SectionStringBuffer),
                                   "%d",
                                   Args.MajorBuildNumber);
        } else {
            (VOID)StringCchPrintfW((PWSTR)SectionStringBuffer, 
                                   ARRAY_SIZE(SectionStringBuffer),
                                   TEXT("%d"),
                                   Args.MajorBuildNumber);
        }
        
        basic_string<T> BuildSpecificInfChangeSecName = INFCHANGES_SECTION_NAME + 
                                                        TEXT(".") + 
                                                        SectionStringBuffer;
        Section<T>  *BuildSpecificInfChangeSection    = ControlInf.GetSection(BuildSpecificInfChangeSecName.c_str());

        InfProcessingErrors<T> ProcessingErrors(Args);        
        //
        // There needs to be atleast one entry with "/minint" load option change
        // for txtsetup.sif
        //
        if (!ChangeSection) {
            throw new InvalidInfSection<T>(L"infchanges", InfName);
        }
        else {
            ChangeSection->DoForEach(InfFileChangeWorker, &ProcessingErrors);

            if (BuildSpecificInfChangeSection){
                BuildSpecificInfChangeSection->DoForEach(InfFileChangeWorker, &ProcessingErrors);
            }
        }

        if (ProcessingErrors.FileList.size()) {
            vector<basic_string<T> >::iterator Iter = ProcessingErrors.FileList.begin();

            cout << GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_ERROR_PROCESSING_INF_FILES) << endl;

            while (Iter != ProcessingErrors.FileList.end()) {
                cout << GetFormattedMessage(ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_FILE, 
                                            (*Iter).c_str()) << endl;
                Iter++;
            }
        } else {
            Result = true;
        }            
    }
    catch (BaseException<wchar_t> *Exp) {
        Exp->Dump(std::cout);
        delete Exp;
        Result = false;
    }
    catch(...) {
        Result = false;
    }

    return Result;
}


//
// Arguments (constructor)
//
template <class T>
Arguments<T>::Arguments(int Argc, T *Argv[]) : Verbose(false) {
    bool ValidArguments = false;

    SkipWowFiles = true;
    WowFilesPresent = false;
    SkipFileCopy = false;
    CheckVersion = false;
    IA64Image = false;
    MajorBuildNumber   = 0;
    MajorVersionNumber = 0;
    MinorVersionNumber = 0;

    T       Buffer[MAX_PATH] = {0};
    DWORD   CharsCopied = 0;

    if (sizeof(T) == sizeof(CHAR)) {
        CharsCopied = GetCurrentDirectoryA(sizeof(Buffer)/sizeof(T),
                            (PSTR)Buffer);
    } else {
        CharsCopied = GetCurrentDirectoryW(sizeof(Buffer)/sizeof(T),
                            (PWSTR)Buffer);
    }

    if (!CharsCopied) {
        throw new W32Exception<T>();
    }            

    if (Buffer[CharsCopied - 1] != L'\\') {
        Buffer[CharsCopied] = L'\\';
        Buffer[CharsCopied + 1] = NULL;
    }            

    CurrentDirectory = Buffer;

    if (Argc >= 2) {
      for (int Index = 0; Index < Argc; Index++) {
        if (wcsstr(Argv[Index], L"/s:")) {
            SourceDirectory = Argv[Index] + 3;
        } else if (wcsstr(Argv[Index], L"/d:")) {
            DestinationDirectory = Argv[Index] + 3;
        } else if (wcsstr(Argv[Index], L"/m:")) {
            OptionalSrcDirectory = Argv[Index] + 3;
        } else if (wcsstr(Argv[Index], L"/e:")) {
            ExtraFileName = Argv[Index] + 3;
        } else if (wcsstr(Argv[Index], L"/l:")) {
            LayoutName = Argv[Index] + 3;
        } else if (wcsstr(Argv[Index], L"/p:")) {
            PlatformSuffix = Argv[Index] + 3;
        } else if (wcsstr(Argv[Index], L"/v")) {
            Verbose = true;
        } else if (!_wcsicmp(Argv[Index], L"/#u:nocopy")) {
            SkipFileCopy = true;
        } else if (!_wcsicmp(Argv[Index], L"/#u:checkversion")) {
            CheckVersion = true;
        }
      }

      if (SourceDirectory.length() && 
          SourceDirectory[SourceDirectory.length() - 1] != L'\\') {
        SourceDirectory += L"\\";
        SourceDirectoryRoot = SourceDirectory;

        std::basic_string<T>    ia64Dir = SourceDirectory + L"ia64";
        std::basic_string<T>    x86Dir = SourceDirectory + L"i386";
        
        if (IsFilePresent(ia64Dir)) {
            PlatformSuffix = L"ia64";
            SourceDirectory += L"ia64\\";
            WowFilesPresent = true;
            IA64Image = true;
        } else if (IsFilePresent(x86Dir)) {
            PlatformSuffix = L"x86";
            SourceDirectory += L"i386\\";
        }
      }                        

      if (DestinationDirectory.length() && 
          DestinationDirectory[DestinationDirectory.length() - 1] != L'\\') {
        DestinationDirectory += L'\\';
      }

      if (!LayoutName.length()) {
        LayoutName = SourceDirectory + L"layout.inf";
      }

      if (OptionalSrcDirectory.length() && 
          OptionalSrcDirectory[OptionalSrcDirectory.length() - 1] != L'\\') {
        OptionalSrcDirectory += L"\\";
      }

      DriverIndexName = SourceDirectory + L"drvindex.inf";

      if (OptionalSrcDirectory.length()) {
        IntlInfFileName = OptionalSrcDirectory + L"intl.inf";
        FontInfFileName = OptionalSrcDirectory + L"font.inf";
        ConfigInfFileName = OptionalSrcDirectory + L"config.inf";
      } else {
        IntlInfFileName = SourceDirectory + L"intl.inf";
        FontInfFileName = SourceDirectory + L"font.inf";
        ConfigInfFileName = SourceDirectory + L"config.inf";        
      }

      DosNetFileName = SourceDirectory + L"dosnet.inf";          

      //
      // Get the SxS assembly layout (in ASMS directory or CAB).
      //
      IdentifySxSLayout();      

      if (!CheckVersion) {
          ValidArguments = SourceDirectory.length() && DestinationDirectory.length() &&
                           LayoutName.length() && 
                           ((PlatformSuffix == L"x86") || (PlatformSuffix == L"ia64"));
      } else {
          ValidArguments = (SourceDirectory.length() > 0) && 
                           IsFilePresent(DosNetFileName);
      }
    } 
    
    if (!ValidArguments) {
      throw new InvalidArguments();
    }
        
}


template <class T>
VOID
Arguments<T>::IdentifySxSLayout( 
    VOID
    )
/*++
Routine Description:

    This routine determines the file layout for SXS files.
    
Arguments:

    None.

Return Value:    

    None.
    
--*/
{
    WCHAR   DriverVer[MAX_PATH] = {0};

    WinSxSLayout = SXS_LAYOUT_TYPE_CAB;    // by default assumes latest layout      
    
    if (GetPrivateProfileString(L"Version",
            L"DriverVer",
            NULLSTR,
            DriverVer,
            sizeof(DriverVer)/sizeof(DriverVer[0]),
            DosNetFileName.c_str())){

        basic_string<T> DriverVerStr = DriverVer;
        basic_string<T>::size_type VerStartPos = DriverVerStr.find(L',');
        basic_string<T> VersionStr = DriverVerStr.substr(VerStartPos + 1);                                                                        
        vector<basic_string<T> > VersionTokens;

        if (Tokenize(VersionStr, basic_string<T>(L"."), VersionTokens) > 2) {
            T     *EndChar;
            MajorVersionNumber = wcstoul(VersionTokens[0].c_str(),
                                         &EndChar, 10);
            MinorVersionNumber = wcstoul(VersionTokens[1].c_str(),
                                         &EndChar, 10);
            MajorBuildNumber   = wcstoul(VersionTokens[2].c_str(),
                                         &EndChar, 10);              
            
            //
            // This can be expanded in future for more products.
            //                
            if ((MajorVersionNumber == 5) && (MajorBuildNumber < SXS_CAB_LAYOUT_BUILD_NUMBER)) {
                WinSxSLayout = SXS_LAYOUT_TYPE_DIRECTORY;
            }
        } else {
            throw new InvalidInfSection<T>(L"Version", DosNetFileName.c_str());
        }
    } else {
        throw new W32Exception<T>();
    }
}

//
// Checks the media version against the current OS version
//
template <class T>
bool
CheckMediaVersion(
    Arguments<T>    &Args
    )
{
    bool    Result = false;

#ifdef _IA64_
    bool    IA64Build = true;
#else
    bool    IA64Build = false;
#endif    

    try {        
        WCHAR   DriverVer[MAX_PATH] = {0};
        WCHAR   ProductType[MAX_PATH] = {0};

        if (GetPrivateProfileString(L"Version",
                L"DriverVer",
                NULLSTR,
                DriverVer,
                sizeof(DriverVer)/sizeof(DriverVer[0]),
                Args.DosNetFileName.c_str()) &&
            GetPrivateProfileString(L"Miscellaneous",
                L"ProductType",
                NULLSTR,
                ProductType,
                sizeof(ProductType)/sizeof(ProductType[0]),
                Args.DosNetFileName.c_str())) {
                
            basic_string<T> DriverVerStr = DriverVer;
            basic_string<T> ProductTypeStr = ProductType;
            basic_string<T>::size_type VerStartPos = DriverVerStr.find(L',');
            T       *EndPtr;
            DWORD   ProductType = wcstoul(ProductTypeStr.c_str(), &EndPtr, 10);

            //
            // For the time being only worry about CD type
            // Allow only from Pro, Server, Blade and ADS SKU's.
            //
            Result = ((0 == ProductType) ||
                      (1 == ProductType) || 
                      (5 == ProductType) || 
                      (2 == ProductType));

            
            /*
            //
            // make sure that the CD is pro CD and the version is the same
            // version as we are running from
            //
            if ((ProductType == 0) && (VerStartPos != basic_string<T>::npos)) {
                basic_string<T> VersionStr = DriverVerStr.substr(VerStartPos + 1);                                                                        
                vector<basic_string<T> > VersionTokens;

                if (Tokenize(VersionStr, basic_string<T>(L"."), VersionTokens) >= 3) {
                    T     *EndChar;
                    DWORD MajorVer = wcstoul(VersionTokens[0].c_str(),
                                        &EndChar, 10);
                    DWORD MinorVer = wcstoul(VersionTokens[1].c_str(),
                                        &EndChar, 10);
                    DWORD BuildNumber = wcstoul(VersionTokens[2].c_str(),
                                            &EndChar, 10);
                    OSVERSIONINFO   VersionInfo;

                    ZeroMemory(&VersionInfo, sizeof(OSVERSIONINFO));
                    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

                    if (MajorVer && MinorVer && BuildNumber &&
                        ::GetVersionEx(&VersionInfo)) {                        

                        Result = (VersionInfo.dwMajorVersion == MajorVer) &&
                                 (VersionInfo.dwMinorVersion == MinorVer) &&
                                 (VersionInfo.dwBuildNumber == BuildNumber);
                    }
                }
            }
            */
        }
    } catch (...) {
        Result = false;
    }

    return Result;
}


//
// Computes a SxS string hash, used in creating assembly identity
//
template <class T>
bool
ComputeStringHash(
    const std::basic_string<T> &String,
    ULONG &HashValue
    )
{
    bool Result = false;
    ULONG TmpHashValue = 0;

    if (String.length()) {
        std::basic_string<T>::const_iterator Iter = String.begin();

        while (Iter != String.end()) {
            TmpHashValue = (TmpHashValue * 65599) + toupper(*Iter);
            Iter++;
        }

        HashValue = TmpHashValue;
        Result = true;
    }

    return Result;
}    

//
// Computes an assembly identity hash for the specified
// Name and attribute pairs
//
template <class T>
bool
ComputeWinSxSHash(
    IN std::map<std::basic_string<T>, std::basic_string<T> > &Attributes,
    ULONG &Hash
    )
{
    bool Result = false;
    std::map<std::basic_string<T>, std::basic_string<T> >::iterator Iter = Attributes.begin();

    Hash = 0;

    while (Iter != Attributes.end()) {
        ULONG NameHash = 0;
        ULONG ValueHash = 0;
        ULONG AttrHash = 0;

        if (ComputeStringHash((*Iter).first, NameHash) &&
            ComputeStringHash((*Iter).second, ValueHash)) {
            Result = true;
            AttrHash = (NameHash * 65599) + ValueHash;      
            Hash = (Hash * 65599) + AttrHash;            
        }    

        Iter++;
    }

    return Result;
}
    

//
// Given a manifest file name generates a unique
// assmebly name (with ID) to be used as destination
// directory for the assembly
//
template <class T>
bool
GenerateWinSxSName(
    IN std::basic_string<T>  &ManifestName,
    IN ULONG FileSize,
    OUT std::basic_string<T> &SxSName
    )
{
    bool Result = false;
    
    if (FileSize) {
        bool    Read = false;
        PUCHAR  Buffer = new UCHAR[FileSize + 1];
        PWSTR   UnicodeBuffer = new WCHAR[FileSize + 1];
        std::wstring FileContent;

        if (Buffer && UnicodeBuffer) {            
            HANDLE FileHandle;

            //
            // Open the manifest file
            //
            FileHandle = CreateFile(ManifestName.c_str(),
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

            if (FileHandle != INVALID_HANDLE_VALUE) {
                DWORD   BytesRead = 0;

                //
                // Read the entire contents of the file
                //
                if (ReadFile(FileHandle, 
                        Buffer,
                        FileSize,
                        &BytesRead,
                        NULL)) {
                    Read = (BytesRead == FileSize);                        
                }                        

                CloseHandle(FileHandle);
            }                            

            if (Read) {
                //
                // null terminate the buffer
                //
                Buffer[FileSize] = NULL; 

                //
                // Convert the string to unicode string
                //
                if (MultiByteToWideChar(CP_UTF8,
                        0,
                        (LPCSTR)Buffer,
                        FileSize + 1,
                        UnicodeBuffer,
                        FileSize + 1)) {
                    FileContent = UnicodeBuffer;                        
                }                        
            }

            delete []Buffer;
            delete []UnicodeBuffer;
        } else {
            if (Buffer) {
                delete []Buffer;
            }

            if (UnicodeBuffer)
                delete []UnicodeBuffer;
        }                

        if (FileContent.length()) {             
            std::wstring IdentityKey = L"<" SXS_ASSEMBLY_MANIFEST_STD_ELEMENT_NAME_ASSEMBLY_IDENTITY;
            std::wstring::size_type IdentityStartPos = FileContent.find(IdentityKey);
            std::wstring::size_type IdentityEndPos = FileContent.find(L"/>", IdentityStartPos);

            //
            // Create name, value pairs for all the identity attributes specified
            // in the manifest
            //
            if ((IdentityStartPos != IdentityKey.npos) &&
                (IdentityEndPos != IdentityKey.npos)) {
                std::map<std::wstring, std::wstring> IdentityPairs;

                WCHAR   *KeyNames[] = { SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
                                        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION,
                                        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE,
                                        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN,
                                        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
                                        SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_TYPE,
                                        NULL };               

                for (ULONG Index = 0; KeyNames[Index]; Index++) {
                    std::wstring::size_type ValueStartPos;
                    std::wstring::size_type ValueEndPos;
                    std::wstring KeyName = KeyNames[Index];

                    KeyName += L"=\"";

                    ValueStartPos = FileContent.find(KeyName, IdentityStartPos);

                    if (ValueStartPos != std::wstring::npos) {
                        ValueStartPos += KeyName.length();
                        ValueEndPos = FileContent.find(L"\"", ValueStartPos);

                        if ((ValueEndPos != std::wstring::npos) &&
                            (ValueEndPos > ValueStartPos) &&
                            (ValueEndPos <= IdentityEndPos)) {                            
                            IdentityPairs[KeyNames[Index]] = FileContent.substr(ValueStartPos,
                                                                ValueEndPos - ValueStartPos);
                        }
                    }
                }

                ULONG Hash = 0;

                //
                // Compute the assembly identity hash
                //
                if (ComputeWinSxSHash(IdentityPairs, Hash)) {                    
                    WCHAR   *KeyValues[] = {    
                                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PROCESSOR_ARCHITECTURE,
                                NULL,
                                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_NAME,
                                NULL,
                                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_PUBLIC_KEY_TOKEN,
                                NULL,                                
                                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_VERSION,
                                NULL,
                                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_NAME_LANGUAGE,
                                SXS_ASSEMBLY_IDENTITY_STD_ATTRIBUTE_LANGUAGE_MISSING_VALUE,
                                NULL};               

                    std::wstring  Name;

                    Result = true;

                    //
                    // Generate the unique assembly name based on
                    // its identity attribute name, value pairs
                    //
                    for (Index = 0; KeyValues[Index]; Index += 2) {
                        std::wstring    Key(KeyValues[Index]);
                        std::wstring    Value(IdentityPairs[Key]);

                        //
                        // Use default value, if none specified
                        //
                        if ((Value.length() == 0) && KeyValues[Index + 1]) {
                            Value = KeyValues[Index + 1];
                        } 

                        if (Value.length()) {
                            Name += Value;

                            if (KeyValues[Index + 2]) {
                                Name += TEXT("_");
                            }
                        } else {
                            Result = false;

                            break;  // required value is missing
                        }                            
                    }

                    if (Result) {                         
                        WCHAR   Buffer[32] = {0};

                        (VOID)StringCchPrintfW(Buffer, 
                                               ARRAY_SIZE(Buffer), 
                                               L"%x", 
                                               Hash);

                        SxSName = Name + TEXT("_") + Buffer;
                    }                        
                }                    
            }
        }            
    }                

    return Result;
}

//
// Processes the fusion assembly in the specified directory
// 
template <class T>
ULONG
ProcessWinSxSFilesInDirectory(
    IN FileListCreatorContext<T> &Context,
    IN std::basic_string<T> &DirName
    )
{
    //
    // persistent state
    //
    static basic_string<T> WinSxSDirCode = TEXT("124");
    static basic_string<T> WinSxSManifestDirCode = TEXT("125");
    static basic_string<T> WinSxSDir = Context.DirsSection->GetValue(WinSxSDirCode).GetValue(0);
    static basic_string<T> WinSxSManifestDir = Context.DirsSection->GetValue(WinSxSManifestDirCode).GetValue(0);
    static ULONG NextDirIndex = 123456; // some random number not used in layout.inx
    
    ULONG   FileCount = 0;
    WIN32_FIND_DATA FindData = {0};
    std::basic_string<T> SearchName = DirName + TEXT("\\*.MAN");
    HANDLE SearchHandle;

    //
    // Search for the *.man file in the specfied directory
    //
    SearchHandle = FindFirstFile(SearchName.c_str(), &FindData);

    if (SearchHandle != INVALID_HANDLE_VALUE) {
        std::basic_string<T> ManifestName = DirName + TEXT("\\") + FindData.cFileName;        
        std::basic_string<T> WinSxSName;
        bool NameGenerated = false;

        //
        // Generate the WinSxS destination name for the manifest
        //
        NameGenerated = GenerateWinSxSName(ManifestName, 
                            FindData.nFileSizeLow,
                            WinSxSName);

        FindClose(SearchHandle);                        

        if (NameGenerated) {
            T   NextDirCode[64] = {0};
            std::basic_string<T> SxSDirName = Context.Args.DestinationDirectory + WinSxSDir + TEXT("\\");
            std::basic_string<T> ManifestDirName = Context.Args.DestinationDirectory + WinSxSManifestDir + TEXT("\\");
            
            //
            // Cache the directory, if not already done
            //
            if (Context.DestDirs.find(WinSxSDirCode) == Context.DestDirs.end()) {
                Context.DestDirs[WinSxSDirCode] = SxSDirName;
            }                

            if (Context.DestDirs.find(WinSxSManifestDirCode) == Context.DestDirs.end()) {
                Context.DestDirs[WinSxSManifestDirCode] = ManifestDirName;
            }                

            ZeroMemory(&FindData, sizeof(WIN32_FIND_DATA));

            //
            // Search for all the files in the specified directory
            //
            SearchName = DirName + TEXT("\\*");            
            SearchHandle = FindFirstFile(SearchName.c_str(), &FindData);

            if (SearchHandle != INVALID_HANDLE_VALUE) {                        
                std::basic_string<T> SrcFileName, DestFileName;  
                std::basic_string<T> ManifestDirCode;
                
                if (sizeof(T) == sizeof(CHAR)) {
                    (VOID)StringCchPrintfA((PSTR)NextDirCode, 
                                           ARRAY_SIZE(NextDirCode),
                                           "%d",
                                           NextDirIndex++);
                } else {
                    (VOID)StringCchPrintfW((PWSTR)NextDirCode, 
                                           ARRAY_SIZE(NextDirCode),
                                           TEXT("%d"),
                                           NextDirIndex++);
                }

                ManifestDirCode = NextDirCode;
                
                do {
                    if (!(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                        SrcFileName = DirName + TEXT("\\") + FindData.cFileName;
                        DestFileName = SxSDirName;
                        
                        std::basic_string<T> FileName(FindData.cFileName);
                        std::basic_string<T>::size_type DotPos = FileName.find(TEXT("."));
                        std::basic_string<T> Extension;                                                                   

                        if (DotPos != FileName.npos) {
                            Extension = FileName.substr(DotPos + 1);
                        }                            

                        //
                        // *.man and *.cat go to the WinSxS\Manifest directory
                        //
                        if ((Extension == TEXT("man")) ||
                            (Extension == TEXT("MAN")) ||
                            (Extension == TEXT("cat")) ||
                            (Extension == TEXT("CAT"))) {
                            DestFileName = ManifestDirName;
                            DestFileName += WinSxSName;

                            if ((Extension == TEXT("man")) ||
                                (Extension == TEXT("MAN"))) {
                                DestFileName += TEXT(".Manifest");                                
                            } else {
                                DestFileName += TEXT(".");
                                DestFileName += Extension;
                            }                                
                        } else {                        
                            //
                            // Cache the directory, if not already done
                            //
                            if (Context.DestDirs.find(ManifestDirCode) == Context.DestDirs.end()) {
                                Context.DestDirs[ManifestDirCode] = SxSDirName + WinSxSName;
                            }                

                            //
                            // Each file other than *.man & *.cat go the unique
                            // assembly directory created
                            //
                            DestFileName += WinSxSName;
                            DestFileName += TEXT("\\");
                            DestFileName += FileName;
                        }                        

                        //
                        // Queue this file for copying
                        //
                        Context.WinSxSFileList[SrcFileName] = DestFileName;
                        FileCount++;
                    }
                }
                while (FindNextFile(SearchHandle, &FindData));
                
                FindClose(SearchHandle);
            }
        }            
    }

    return FileCount;
}

template<class T>
bool
WinSxsExtractVersionInfo(
    IN basic_string<T> ManifestName,
    OUT basic_string<T> &Version
    )
/*++

Routine Description:

    Extracts the version information string (like 1.0.0.1) from
    the given manifest name.

    NOTE: Assumes that version information is the third-last (third 
    from the last) value in the assembly Id.
    
Arguments:

    ManifestName - full manifest name

    Version - placeholder for extracted version information

Return Value:

    true on success, otherwise false
    
--*/
{
    bool Result = false;
    basic_string<T>::size_type VersionEnd = ManifestName.rfind((T)TEXT('_'));

    if (VersionEnd != ManifestName.npos) {
        VersionEnd = ManifestName.rfind((T)TEXT('_'), VersionEnd - 1);

        if (VersionEnd != ManifestName.npos) {
            basic_string<T>::size_type  VersionStart = ManifestName.rfind((T)TEXT('_'), VersionEnd - 1);
            VersionEnd--;

            if (VersionStart != ManifestName.npos) {
                Version = ManifestName.substr(VersionStart + 1, VersionEnd - VersionStart);
                Result = (Version.length() > 0);
            }
        }
    }        
                
    return Result;
}

template <class T>
bool
WinSxsFixFilePaths(
  IN FileListCreatorContext<T> &Context,
  IN OUT FILE_IN_CABINET_INFO &FileInfo,
  OUT bool &rSkipFile
  )
/*++

Routine Description:

    This routine fixes the destination path in the 
    FileInfo argument.  The new format of this cabinet (build 364?+) is
    that it contains direct paths underneath winsxs, no wierd finding-and-
    placing files into different directories required.  All that has to
    happen is the winsxs root gets prepended to the cab path name.    
    
Arguments:

    Context - FileListCreatorContext instance as PVOID.

    FileInfo - Cab file iteration FileInfo instance

Return Value:

    true if the destination name was fixed otherwise false.
    
--*/
{
    bool Result = true;
    basic_string<T> SourceName;
    static basic_string<T> SetupPoliciesPrefix = (T*)TEXT("setuppolicies");
    static basic_string<T> WinSxSDirCode((T *)TEXT("124"));
    static basic_string<T> WinSxSDir = Context.Args.DestinationDirectory + 
                                        Context.DirsSection->GetValue(WinSxSDirCode).GetValue(0) 
                                        + (T *)TEXT("\\") ;
    basic_string<T> DestinationName;

    rSkipFile = false;

    if (sizeof(T) == sizeof(CHAR)) {
        SourceName = (T *)(_strlwr((PSTR)(FileInfo.NameInCabinet)));
    } else {
        SourceName = (T *)(_wcslwr((PWSTR)(FileInfo.NameInCabinet)));
    }

    //
    // Cab contains "setuppolicies" files that should not appear on winpe cds.
    // Skip them with abandon.
    //
    if (sizeof(T) == sizeof(CHAR)) {
        if (_strnicmp((PCSTR)SourceName.c_str(), (PCSTR)SetupPoliciesPrefix.c_str(), SetupPoliciesPrefix.length()) == 0) {
            rSkipFile = true;
            return true;
        }        
    }
    else {
        if (_wcsnicmp((PCWSTR)SourceName.c_str(), (PCWSTR)SetupPoliciesPrefix.c_str(), SetupPoliciesPrefix.length()) == 0) {
            rSkipFile = true;
            return true;
        }        
    }

    DestinationName = WinSxSDir;
    DestinationName += TEXT('\\');
    DestinationName += SourceName;
    
    if (sizeof(T) == sizeof(CHAR)) {
         
        Result = SUCCEEDED(StringCchCopyA((PSTR)(FileInfo.FullTargetName), 
                             ARRAY_SIZE(FileInfo.FullTargetName),
                             (PCSTR)DestinationName.c_str()));
    } else {
        Result = SUCCEEDED(StringCchCopyW((PWSTR)(FileInfo.FullTargetName), 
                             ARRAY_SIZE(FileInfo.FullTargetName),
                             (PCWSTR)DestinationName.c_str()));
    }


    if (Result) {
        
        if (sizeof(T) == sizeof(CHAR)) {
             
            (VOID)StringCchCopyA((PSTR)(FileInfo.FullTargetName), 
                                 ARRAY_SIZE(FileInfo.FullTargetName),
                                 (PCSTR)DestinationName.c_str());
        } else {
            (VOID)StringCchCopyW((PWSTR)(FileInfo.FullTargetName), 
                                 ARRAY_SIZE(FileInfo.FullTargetName),
                                 (PCWSTR)DestinationName.c_str());
        }        
    }


    return Result;
}

template <class T>
UINT
WinSxsCabinetCallback(
    IN PVOID       Context,
    IN UINT        Notification,
    IN UINT_PTR    Param1,
    IN UINT_PTR    Param2
    )
/*++

Routine Description:

    This routine processes WinSxS files in Cabinet.

Arguments:

    Context - FileListCreatorContext instance as PVOID.

    Notification - CAB Iteration Code

    Param1 - First parameter for Notification.

    Param2 - Second parameter for Notification.

Return Value:

    Appropriate return code to continue iterating, copy the file or skip
    the file in cab.
    
--*/
{
    UINT    ReturnCode = NO_ERROR;
    FileListCreatorContext<T> *FlContext = (FileListCreatorContext<T> *)Context;
    PFILE_IN_CABINET_INFO   FileInfo = NULL;                    
    PFILEPATHS              FilePaths = NULL;
    basic_string<T>         &FileName = FlContext->CurrentFileName;
    bool                    fSkipFile = false;
       
    switch (Notification) {
        case SPFILENOTIFY_FILEINCABINET:
            ReturnCode = FILEOP_SKIP;
            FileInfo = (PFILE_IN_CABINET_INFO)Param1;
            
            if (WinSxsFixFilePaths(*FlContext, *FileInfo, fSkipFile)) { 
                if (sizeof(T) == sizeof(CHAR)) {
                    FileName = (const T *)(FileInfo->NameInCabinet);
                } else {
                    FileName = (const T *)(FileInfo->NameInCabinet);
                }

                if (!FlContext->Args.SkipFileCopy && !fSkipFile) {
                    //
                    // create the destination directory if it doesnot exist
                    //
                    basic_string<T> DestinationName = (T *)(FileInfo->FullTargetName);
                    basic_string<T> DestinationDir = DestinationName.substr(0, DestinationName.rfind((T *)TEXT("\\")));

                    if (sizeof(T) == sizeof(CHAR)) {
                        if (_access((PCSTR)(DestinationDir.c_str()), 0)) {
                            CreateDirectories(DestinationDir, NULL);
                        }
                    } else {
                        if (_waccess((PCWSTR)(DestinationDir.c_str()), 0)) {
                            CreateDirectories(DestinationDir, NULL);
                        }
                    }
                    
                    ReturnCode = FILEOP_DOIT;                                        
                } else {                
                    ReturnCode = FILEOP_SKIP;
                    FlContext->FileCount++;
                    
                    if (FlContext->Args.Verbose) {
     	                std::cout << GetFormattedMessage(ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_EXTRACT_FILES_FROM_CAB_NOTIFICATION,
                                        FlContext->WinSxsCabinetFileName.c_str(),
                                        FileInfo->NameInCabinet,
                                        FileInfo->FullTargetName) << std::endl;
                    }                                      
                }
            } else {
                ReturnCode = FILEOP_ABORT;
            }
            
            break;

        case SPFILENOTIFY_FILEEXTRACTED:
            FilePaths = (PFILEPATHS)Param1;

            if (FilePaths->Win32Error) {  
    	        std::cout << GetFormattedMessage(ThisModule,
                                FALSE,
                                Message,
                                sizeof(Message)/sizeof(Message[0]),
                                MSG_ERROR_EXTRACTING_FILES,
                                FilePaths->Win32Error,
                                FilePaths->Source,
                                FileName.c_str(), 
                                FilePaths->Target) << std::endl;    	                 
            } else {
                FlContext->FileCount++;

                if (FlContext->Args.Verbose) {
                    std::cout << GetFormattedMessage(ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_EXTRACTED_FILES_FROM_CAB_NOTIFICATION,
                                    FilePaths->Source,
                                    FileName.c_str(),
                                    FilePaths->Target) << std::endl;
                }
            }                
            
            break;
            
        default:
            break;
    }

    return ReturnCode;
}   


//
// Copies all the required files in given CAB file to the specified
// destination directory
//
template <class T>
ULONG
ProcessWinSxsCabFiles(
    IN FileListCreatorContext<T>   &Context,
    IN const std::basic_string<T>  &CabFileName
    )
/*++

Routine Description:

    This routine processes the given CAB file for WinSxS. It extracts
    the required manifest, catalog and policy files and installs them
    to the the appropriate assembly on the destination.

Arguments:

    Context - FileListCreatorContext instance as PVOID.

    CabFileName - Fully qualitifed cab file name that needs to be processed.

Return Value:

    Number of files processed.
    
--*/
{
    ULONG   Count = Context.FileCount;
    
    BOOL Result = FALSE;

    Context.WinSxsCabinetFileName = CabFileName;
    if (sizeof(T) == sizeof(CHAR)) {
        Result = SetupIterateCabinetA((PCSTR)CabFileName.c_str(),
                        NULL,
                        (PSP_FILE_CALLBACK_A)WinSxsCabinetCallback<char>,
                        &Context);
    } else {
        Result = SetupIterateCabinetW((PCWSTR)CabFileName.c_str(),
                        NULL,
                        (PSP_FILE_CALLBACK_W)WinSxsCabinetCallback<wchar_t>,
                        &Context);                                
    }                        

    if (!Result) {        
        cout << GetFormattedMessage(ThisModule,
                    FALSE,
                    Message,
                    sizeof(Message)/sizeof(Message[0]),
                    MSG_ERROR_ITERATING_CAB_FILE,
                    GetLastError(),
                    CabFileName.c_str()) << endl;
    }

    return Context.FileCount - Count;
}

template <class T>
ULONG    
ProcessWinSxSFilesForCabLayout( 
    IN FileListCreatorContext<T> &Context,
    IN std::basic_string<T> &SearchPattern
    )
/*++

Routine Description:

    Processes Win SXS files for CAB layout.
    
Arguments:

    Context : Current Processing Context.
    
    SearchPattern : The search pattern for cab files.
    
Return Value:    

    The number of files which were processed.
   
--*/                               
{
    ULONG FileCount = 0; 
    WIN32_FIND_DATA FindData = {0};
    std::basic_string<T> SearchName = Context.Args.SourceDirectory + SearchPattern;  
    HANDLE SearchHandle;

    SearchHandle = FindFirstFile(SearchName.c_str(), &FindData);

    if (SearchHandle != INVALID_HANDLE_VALUE) {
        do {
            if (!(FindData.dwFileAttributes &  FILE_ATTRIBUTE_DIRECTORY)) {
                basic_string<T> FullCabFileName = Context.Args.SourceDirectory + FindData.cFileName;
                
                //
                // Process any manifests present in the current directory
                //
                FileCount += ProcessWinSxsCabFiles(Context, FullCabFileName);
            }     
        }
        while (FindNextFile(SearchHandle, &FindData));

        FindClose(SearchHandle);
    }
    
    return FileCount;
}

template <class T>
ULONG
ProcessWinSxSFilesForDirectoryLayout( 
    IN FileListCreatorContext<T> &Context,
    IN std::basic_string<T> &DirName
    )
/*++

Routine Description:

    Processes Win SXS files for flat/directory layout.
    
Arguments:

    Context: Current Processing context.
    
    DirName: Current directory to be processed.
    
Return Value:    

    The number of files which were processed.
    
--*/                          
{
    WIN32_FIND_DATA FindData = {0};
    std::basic_string<T> SearchName;
    static std::basic_string<T> CurrDir = TEXT(".");
    static std::basic_string<T> ParentDir = TEXT("..");
    ULONG FileCount = 0; 
    HANDLE SearchHandle;

    SearchName = DirName + TEXT("\\*");
    SearchHandle = FindFirstFile(SearchName.c_str(), &FindData);

    if (SearchHandle != INVALID_HANDLE_VALUE) {   
        do {
            if ((CurrDir != FindData.cFileName) && (ParentDir != FindData.cFileName)) {
                //
                // If we hit a directory then search again in that directory
                //
                if (FindData.dwFileAttributes &  FILE_ATTRIBUTE_DIRECTORY) {
                    std::basic_string<T> NewDirName = DirName + TEXT("\\") +  FindData.cFileName;

                    FileCount += ProcessWinSxSFilesForDirectoryLayout(Context, NewDirName);
                } else {
                    //
                    // Process any manifests present in the current directory
                    //
                    FileCount += ProcessWinSxSFilesInDirectory(Context, DirName);

                    //
                    // done with this directory and sub-directories
                    //
                    break;
                }
            }            
        }
        while (FindNextFile(SearchHandle, &FindData));

        FindClose(SearchHandle);
    }

    return FileCount;
}

//
// Processes the asms directory and installs fusion assemblies in an
// offline fashion
//
template <class T>
ULONG
ProcessWinSxSFiles(
    IN FileListCreatorContext<T> &Context
    )
{
    ULONG   FileCount = 0;

    if (Context.Args.WinSxSLayout == SXS_LAYOUT_TYPE_DIRECTORY) {
        basic_string<T> AsmsDir = Context.Args.SourceDirectory + TEXT("asms");

        FileCount = ProcessWinSxSFilesForDirectoryLayout(Context, AsmsDir);
    } else {        
        basic_string<T> SearchPattern = TEXT("asms*.cab");
        
        FileCount =  ProcessWinSxSFilesForCabLayout(Context, SearchPattern);    
    }

    return FileCount;
}


//
// Process NLS specific files
//
template <class T>
FileListCreatorContext<T>::FileListCreatorContext(
        Arguments<T> &PrgArgs, 
        Section<T> *Curr, 
        Section<T> *Dirs,
        InfFile<T> &ConfigInf,
        InfFile<T> &IntlInf,
        InfFile<T> &FontInf,
        DriverIndexInfFile<T> &DrvIdxFile        
        ):  Args(PrgArgs), 
            ConfigInfFile(ConfigInf), 
            IntlInfFile(IntlInf), 
            FontInfFile(FontInf),
            DriverIdxFile(DrvIdxFile)
/*++

Routine Description:

    Constructor

Arguments:

    Bunch of them.

Return Value:

    FileListCreatorContext object instance.

--*/
{            
    CurrentSection = Curr;
    DirsSection = Dirs;
    SkipInfFiles = false;
    FileCount = 0;
    ProcessingExtraFiles = false;
    DummyDirectoryId = 50000;   // we start with 50000 and count upwards

    //
    // get hold of the windows directory which we need to prune the NLS
    // copy file list
    //
    DWORD   Length;
    T       WindowsDirBuffer[MAX_PATH] = {0};

    if (sizeof(T) == sizeof(CHAR)) {
        Length = GetWindowsDirectoryA((PSTR)WindowsDirBuffer, sizeof(WindowsDirBuffer)/sizeof(T));

        if (Length){
            if (((PSTR)WindowsDirBuffer)[Length] != '\\') {
                (VOID)StringCchCatA((PSTR)WindowsDirBuffer, 
                                    ARRAY_SIZE(WindowsDirBuffer),
                                    "\\");

            }
            
            _strlwr((PSTR)WindowsDirBuffer);
            WindowsDirectory = basic_string<T>((const T*)WindowsDirBuffer);                
        }
    } else {
        Length = GetWindowsDirectoryW((PWSTR)WindowsDirBuffer, sizeof(WindowsDirBuffer)/sizeof(T));

        if (Length) {
            if (((PWSTR)WindowsDirBuffer)[Length] != L'\\') {
                (VOID)StringCchCatW((PWSTR)WindowsDirBuffer, 
                                    ARRAY_SIZE(WindowsDirBuffer),
                                    L"\\");

            }
            
            _wcslwr((PWSTR)WindowsDirBuffer);
            WindowsDirectory = basic_string<T>((const T*)WindowsDirBuffer);
        }
    }                    

    if (!WindowsDirBuffer[0]) {
        throw new W32Exception<T>();
    }        
}

template <class T>
ULONG
FileListCreatorContext<T>::ProcessNlsFiles(
    VOID
    )
/*++

Routine Description:

    Does the necessary work to process the NLS files from INTL.INF
    & FONT.INF files.

    NOTE : For all locales language group 1 (LG_INSTALL_1 section) is
    processed.

Arguments:

    None.

Return Value:

    Number of NLS files that were added to the files to copy list.

--*/
{
    ULONG FileCount = 0;


    //
    // get hold of the necessary copy file sections
    //
    Section<T>  *RegionalSection = ConfigInfFile.GetSection(REGIONAL_SECTION_NAME);
    
    if (!RegionalSection) {
        throw new InvalidInfSection<T>(REGIONAL_SECTION_NAME,
                        ConfigInfFile.GetName());
    }

    SectionValues<T> *LangGroups;

    //
    // [LanguageGroup] section is optional
    //
    try {
        LangGroups = &(RegionalSection->GetValue(LANGUAGE_GROUP_KEY));                
    } catch (...) {
        LangGroups = NULL;
    }
    
    SectionValues<T> &Language = RegionalSection->GetValue(LANGUAGE_KEY);
    ULONG LangGroupCount = LangGroups ? LangGroups->Count() : 0;                


    //
    // go through all language group sections and create a list of unique
    // language group sections that need to be processed.
    //
    std::map< std::basic_string<T>, std::basic_string<T> > RegSectionsToProcess;

    for (ULONG Index = 0; Index < LangGroupCount; Index++) {
        //
        // get the language group section
        //
        std::basic_string<T> LangGroupName = LANGGROUP_SECTION_PREFIX;

        LangGroupName += LangGroups->GetValue(Index);

        //std::cout << LangGroupName << std::endl;
        
        if (sizeof(T) == sizeof(CHAR)) {
            _strlwr((PSTR)LangGroupName.c_str());
        } else {
            _wcslwr((PWSTR)LangGroupName.c_str());
        }                

        //
        // if the section is not already there then add it
        //
        if (RegSectionsToProcess.find(LangGroupName) == RegSectionsToProcess.end()) {
            // std::cout << "Adding : " << LangGroupName << std::endl;
            RegSectionsToProcess[LangGroupName] = LangGroupName;
        }            
    }

    //
    // process the language section
    //
    T       LanguageIdStr[64];
    T       *EndPtr;
    DWORD   LanguageId;

    if (sizeof(T) == sizeof(CHAR)) {
        LanguageId = strtoul((PSTR)Language.GetValue(0).c_str(), 
                        (PSTR *)&EndPtr, 
                        16);
        (VOID)StringCchPrintfA((PSTR)LanguageIdStr, 
                                ARRAY_SIZE(LanguageIdStr),
                                "%08x", 
                                LanguageId);

        _strlwr((PSTR)LanguageIdStr);
    } else {            
        LanguageId = wcstoul((PWSTR)Language.GetValue(0).c_str(), 
                        (PWSTR *)&EndPtr, 
                        16);
        (VOID)StringCchPrintfW((PWSTR)LanguageIdStr, 
                                ARRAY_SIZE(LanguageIdStr),
                                L"%08x", 
                                LanguageId);

        _wcslwr((PWSTR)LanguageIdStr);
    }
    

    std::basic_string<T> LangSectionName = LanguageIdStr;        

    RegSectionsToProcess[LangSectionName] = LangSectionName;

    //
    // make sure the required language groups for this
    // language are also processed
    //
    Section<T> *LocaleSection = IntlInfFile.GetSection(LOCALES_SECTION_NAME);

    if (!LocaleSection) {
        throw new InvalidInfSection<T>(LOCALES_SECTION_NAME,
                        IntlInfFile.GetName());
    }

    SectionValues<T> &LocaleValues = LocaleSection->GetValue(LangSectionName);            
    
    std::basic_string<T> NeededLangGroup = LANGGROUP_SECTION_PREFIX + LocaleValues.GetValue(LANG_GROUP1_INDEX);

    RegSectionsToProcess[NeededLangGroup] = NeededLangGroup;

    //
    // add the font registry entries also
    //
    T   FontSectionName[MAX_PATH];

    if (sizeof(T) == sizeof(CHAR)) {
        (VOID)StringCchPrintfA((PSTR)FontSectionName, 
                                ARRAY_SIZE(FontSectionName),
                                (PSTR)FONT_CP_REGSECTION_FMT_STR.c_str(), 
                                (PSTR)LocaleValues.GetValue(OEM_CP_INDEX).c_str(),
                                DEFAULT_FONT_SIZE);
    } else {
          (VOID)StringCchPrintfW((PWSTR)FontSectionName, 
                                ARRAY_SIZE(FontSectionName),
                                (PWSTR)FONT_CP_REGSECTION_FMT_STR.c_str(), 
                                (PWSTR)LocaleValues.GetValue(OEM_CP_INDEX).c_str(),
                                DEFAULT_FONT_SIZE);
    }            

    RegSectionsToProcess[FontSectionName] = FontSectionName;
    
    std::map< std::wstring, std::wstring >::iterator Iter = RegSectionsToProcess.find(DEFAULT_LANGGROUP_NAME);

    if (Iter == RegSectionsToProcess.end()) {
        RegSectionsToProcess[DEFAULT_LANGGROUP_NAME] = DEFAULT_LANGGROUP_NAME;
    }


    //
    // NOTE : Rather than parsing INTL.INF and FONT.INF files manually
    // we use file queue to populate the queue and then later use the file
    // queue to initialize our copy list map data structure.
    //
                
    //
    // Initialize file queue
    //
    HINF  IntlInfHandle = (HINF)IntlInfFile.GetInfHandle();
    HINF  FontInfHandle = (HINF)FontInfFile.GetInfHandle();

    if (sizeof(T) == sizeof(CHAR)) {
        if (!SetupOpenAppendInfFileA((PSTR)Args.LayoutName.c_str(),
                IntlInfHandle,
                NULL)) {
            throw new W32Exception<T>();                
        }                
                
        if (!SetupOpenAppendInfFileA((PSTR)Args.LayoutName.c_str(),
                FontInfHandle,
                NULL)) {
            throw new W32Exception<T>();                
        }                
    } else {
        if (!SetupOpenAppendInfFileW((PWSTR)Args.LayoutName.c_str(),
                IntlInfHandle,
                NULL)) {
            throw new W32Exception<T>();                
        }                
                
        if (!SetupOpenAppendInfFileW((PWSTR)Args.LayoutName.c_str(),
                FontInfHandle,
                NULL)) {
            throw new W32Exception<T>();                
        }                
    }

    HSPFILEQ FileQueueHandle = SetupOpenFileQueue();

    if (FileQueueHandle == INVALID_HANDLE_VALUE) {
        throw new W32Exception<T>();
    }
        
    //
    // add copy file sections to the queue
    //
    BOOL Result;
    Iter = RegSectionsToProcess.begin();

    while (Iter != RegSectionsToProcess.end()) {       
        // cout << (*Iter).first << endl;

        //
        // process each section
        //        
        if (sizeof(T) == sizeof(CHAR)) {
            Result = SetupInstallFilesFromInfSectionA(IntlInfHandle,
                        NULL,
                        FileQueueHandle,
                        (PCSTR)(*Iter).first.c_str(),
                        (PCSTR)Args.SourceDirectoryRoot.c_str(),
                        0);
        } else {                                    
            Result = SetupInstallFilesFromInfSectionW(IntlInfHandle,
                        NULL,
                        FileQueueHandle,
                        (PCWSTR)(*Iter).first.c_str(),
                        (PCWSTR)Args.SourceDirectoryRoot.c_str(),
                        0);
        }                   

        if (!Result) {
            throw new W32Exception<T>();
        }
                    
        Iter++;
    }

    //
    // scan the queue and populate FileListCreatorContext<T> copy list
    // data structure
    //
    DWORD ScanResult = 0;

    if (sizeof(T) == sizeof(CHAR)) {
        Result = SetupScanFileQueueA(FileQueueHandle,
                    SPQ_SCAN_USE_CALLBACKEX,
                    NULL,
                    (PSP_FILE_CALLBACK_A)NlsFileQueueScanWorker,
                    this,
                    &ScanResult);
    } else {
        Result = SetupScanFileQueueW(FileQueueHandle,
                    SPQ_SCAN_USE_CALLBACKEX,
                    NULL,
                    (PSP_FILE_CALLBACK_W)NlsFileQueueScanWorker,
                    this,
                    &ScanResult);
    }

    SetupCloseFileQueue(FileQueueHandle);

    //
    // Add the Nls directory entries to main directory map
    //
    ProcessNlsDirMapEntries();

    //
    // Remove duplicate Nls file entries
    //
    RemoveDuplicateNlsEntries();

    //
    // Move the driver cab files to driver cab list
    //
    MoveDriverCabNlsFiles();

    //
    // After all this work, how many NLS files do we actually
    // want to copy ?
    //
    return NlsFileMap.size();
}


template <class T>
void
FileListCreatorContext<T>::MoveDriverCabNlsFiles(
    void
    ) 
/*++

Routine Description:

    Takes each NLS file entry to be copied and moves it to
    the driver cab file copy list if the file is present
    in driver cab so that we can extract the file from
    driver cab.

Arguments:

    None.

Return Value:

    None.

--*/
{
    std::map<std::basic_string<T>, std::basic_string<T> >::iterator NlsIter, DelIter;
    T Slash;

    if (sizeof(T) == sizeof(CHAR)) {
        Slash = (T)'\\';
    } else {
        Slash = (T)L'\\';
    }


    for (NlsIter = NlsFileMap.begin(); NlsIter != NlsFileMap.end();) {              
        const std::basic_string<T> &Key = (*NlsIter).first;
        std::basic_string<T>::size_type KeyStart = Key.rfind(Slash);
        std::basic_string<T> FileKey;

        DelIter = NlsFileMap.end();

        if (KeyStart != Key.npos) {
            FileKey = Key.substr(Key.rfind(Slash) + 1);
        }            

        if (FileKey.length()) {
            if (sizeof(T) == sizeof(CHAR)) {
                _strlwr((PSTR)FileKey.c_str());
            } else {
                _wcslwr((PWSTR)FileKey.c_str());
            }                        

            const basic_string<T> &DriverCabFileName = GetDriverCabFileName(FileKey);

            if (DriverCabFileName.length()) {
                // std::cout << "Moved to driver cab list : (" << FileKey << ")" << std::endl;
                AddFileToCabFileList(DriverCabFileName, 
                    FileKey, 
                    (*NlsIter).second);
                    

                DelIter = NlsIter;
            } else {
                // std::cout << "Not present in driver cab list : (" << FileKey << ")" << std::endl;
            }
        }

        NlsIter++;

        if (DelIter != NlsFileMap.end()) {
            NlsFileMap.erase(DelIter);
        }
    }
}


template <class T>
UINT 
FileListCreatorContext<T>::NlsFileQueueScanWorker(
    PVOID       Context,
    UINT        Notification,
    UINT_PTR    Param1,
    UINT_PTR    Param2
    )
/*++

Routine Description:

    The callback routine for the file queue scan. Takes each
    node and copies the relevant information to Nls file copy
    list and caches the directory names in Nls directory map.

Arguments:

    Context - FileListCreatorContext in disguise.

    Notification - Type of notification.

    Param1 & Param2 - Polymorphic arguments based on type of
        notification.

Return Value:

    0 to continue the scan or 1 to stop the scan.

--*/
{
    UINT Result = 0;    // continue on

    // cout << "Scanning (" << std::hex << Notification << ")" << endl;

    if (Notification == SPFILENOTIFY_QUEUESCAN_EX) {
        FileListCreatorContext<T>   &fl = *(FileListCreatorContext<T> *)Context;
        std::basic_string<T> SrcFileName, DestFileName, SrcFileKey, DestFileKey;        
        T   TargetFileNameBuffer[MAX_PATH];
        bool ProcessEntry = false;
        
        if (sizeof(T) == sizeof(CHAR)) {    
            PFILEPATHS_A FileNodeInfo = (PFILEPATHS_A)Param1;            

            if (FileNodeInfo) {
                SrcFileName = std::basic_string<T>((const T*)FileNodeInfo->Source);
                DestFileName = std::basic_string<T>((const T*)FileNodeInfo->Target);

                _strlwr((PSTR)SrcFileName.c_str());
                _strlwr((PSTR)DestFileName.c_str());
                
                basic_string<T>::size_type SlashPos = SrcFileName.rfind((T)'\\');

                if (SlashPos != SrcFileName.npos) {
                    SrcFileKey = SrcFileName.substr(SlashPos + 1);
                                        
                    SlashPos = DestFileName.rfind((T)L'\\');

                    if (SlashPos != DestFileName.npos) {                    
                        DestFileKey = DestFileName.substr(SlashPos + 1);
                        DestFileName[fl.WindowsDirectory.length()] = 0;

                        if (_stricmp((PCSTR)DestFileName.c_str(), (PCSTR)fl.WindowsDirectory.c_str()) == 0) {
                            (VOID)StringCchCopyA((PSTR)TargetFileNameBuffer, 
                                                 ARRAY_SIZE(TargetFileNameBuffer),
                                                 (PCSTR)fl.Args.DestinationDirectory.c_str());
                            
                            (VOID)StringCchCatA((PSTR)TargetFileNameBuffer,
                                                ARRAY_SIZE(TargetFileNameBuffer),
                                                ((PCSTR)(FileNodeInfo->Target)) + 
                                                fl.WindowsDirectory.length());

                            DestFileName = (const T *)TargetFileNameBuffer;
                            ProcessEntry = true;
                        }
                    }                        
                }                    
            }
        } else {
            PFILEPATHS_W FileNodeInfo = (PFILEPATHS_W)Param1;

            if (FileNodeInfo) {
                SrcFileName = std::basic_string<T>((const T*)FileNodeInfo->Source);
                DestFileName = std::basic_string<T>((const T*)FileNodeInfo->Target);

                _wcslwr((PWSTR)SrcFileName.c_str());
                _wcslwr((PWSTR)DestFileName.c_str());

                basic_string<T>::size_type SlashPos = SrcFileName.rfind((T)L'\\');

                if (SlashPos != SrcFileName.npos) {
                    SrcFileKey = SrcFileName.substr(SlashPos + 1);

                    SlashPos = DestFileName.rfind((T)L'\\');

                    if (SlashPos != DestFileName.npos) {                    
                        DestFileKey = DestFileName.substr(SlashPos + 1);
                        DestFileName[fl.WindowsDirectory.length()] = 0;

                        if (_wcsicmp((PCWSTR)DestFileName.c_str(), (PCWSTR)fl.WindowsDirectory.c_str()) == 0) {
                            (VOID)StringCchCopyW((PWSTR)TargetFileNameBuffer, 
                                                 ARRAY_SIZE(TargetFileNameBuffer),
                                                 (PCWSTR)fl.Args.DestinationDirectory.c_str());
                            (VOID)StringCchCatW((PWSTR)TargetFileNameBuffer, 
                                                ARRAY_SIZE(TargetFileNameBuffer),
                                                ((PCWSTR)(FileNodeInfo->Target)) + 
                                                fl.WindowsDirectory.length());

                            DestFileName = (const T *)TargetFileNameBuffer;
                            ProcessEntry = true;
                        }
                    }                        
                }                    
            }
        }

        if (ProcessEntry) {
            bool SkipFileEntry = false;
            
            if (fl.CurrentSection && fl.Args.IA64Image) {
                SectionValues<T> *Values = NULL;
                
                try {
                    Values = &(fl.CurrentSection->GetValue(SrcFileKey));
                }
                catch(...) {
                }

                if (Values) {
                    SkipFileEntry = IsWow64File(*Values, fl);
                }

                if (!SkipFileEntry) {
                    if (sizeof(T) == sizeof(CHAR)) {
                        SkipFileEntry = ( 0 == _stricmp((PCSTR)SrcFileKey.c_str() + 1, (PCSTR)DestFileKey.c_str())) &&
                                        (((T)SrcFileKey[0] == (T)'w') || ((T)SrcFileKey[0] == (T)'W'));
                    } else {
                        SkipFileEntry = ( 0 == _wcsicmp((PCWSTR)SrcFileKey.c_str() + 1, (PCWSTR)DestFileKey.c_str())) &&
                                        (((T)SrcFileKey[0] == (T)L'w') || ((T)SrcFileKey[0] == (T)L'W'));
                    }
                }
            }

            if (!SkipFileEntry) {
                if (fl.Args.IA64Image) {
                    basic_string<T>::size_type PlatDirPos = SrcFileName.find(X86_PLATFORM_DIR.c_str());

                    if (PlatDirPos != SrcFileName.npos) {
                        basic_string<T> NewSrcFileName = SrcFileName.substr(0, PlatDirPos);

                        NewSrcFileName += IA64_PLATFORM_DIR;
                        NewSrcFileName += SrcFileName.substr(PlatDirPos + X86_PLATFORM_DIR.length());

                        // std::cout << "Remapping " << SrcFileName << "->" << NewSrcFileName << std::endl;
                        SrcFileName = NewSrcFileName;
                    }
                }                    
                
                fl.NlsFileMap[SrcFileName] = DestFileName;                
                fl.AddDirectoryToNlsDirMap(DestFileName);        
            } else {
                // std::cout << "Skipping " << SrcFileName << " WOW64 file" << std::endl;
            }
        }            
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\netcfg\netcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S N E T C F G . C P P
//
//  Contents:   Sample code that demonstrates how to:
//              - find out if a component is installed
//              - install a net component
//              - install an OEM net component
//              - uninstall a net component
//              - enumerate net components
//              - enumerate net adapters using Setup API
//              - enumerate binding paths of a component
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "netcfg.h"
#include "msg.h"
#include <libmsg.h>

//----------------------------------------------------------------------------
// Globals
//
static const GUID* c_aguidClass[] =
{
    &GUID_DEVCLASS_NET,
    &GUID_DEVCLASS_NETTRANS,
    &GUID_DEVCLASS_NETSERVICE,
    &GUID_DEVCLASS_NETCLIENT
};

//----------------------------------------------------------------------------
// Prototypes of helper functions
//
HRESULT HrInstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId,
                              IN const GUID* pguidClass);
HRESULT HrUninstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId);
HRESULT HrGetINetCfg(IN BOOL fGetWriteLock, INetCfg** ppnc);
HRESULT HrReleaseINetCfg(BOOL fHasWriteLock, INetCfg* pnc);
void ShowHrMessage(IN HRESULT hr);
inline ULONG ReleaseObj(IUnknown* punk)
{
    return (punk) ? punk->Release () : 0;
}


//+---------------------------------------------------------------------------
//
// Function:  HrIsComponentInstalled
//
// Purpose:   Find out if a component is installed
//
// Arguments:
//    szComponentId [in]  id of component to search
//
// Returns:   S_OK    if installed,
//            S_FALSE if not installed,
//            otherwise an error code
//
// Author:    kumarp 11-February-99
//
// Notes:
//
HRESULT HrIsComponentInstalled(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;
    INetCfgComponent* pncc;

    hr = HrGetINetCfg(FALSE, &pnc);
    if (S_OK == hr)
    {
        hr = pnc->FindComponent(szComponentId, &pncc);
        if (S_OK == hr)
        {
            ReleaseObj(pncc);
        }
        (void) HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  FindIfComponentInstalled
//
// Purpose:   Find out if a component is installed
//
// Arguments:
//    szComponentId [in]  id of component to locate
//
// Returns:   None
//
// Author:    kumarp 11-February-99
//
// Notes:
//
void FindIfComponentInstalled(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;

    hr = HrIsComponentInstalled(szComponentId);
    if (S_OK == hr)
    {
        _putts( GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_COMPONENT_INSTALLED,
                                        szComponentId) );
    }
    else if (S_FALSE == hr)
    {
        _putts( GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_COMPONENT_NOT_INSTALLED,
                                        szComponentId) );
    }
    else
    {
        _putts( GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_INSTALLATION_NOT_CONFIRMED,
                                        szComponentId, 
                                        hr) );
    }
}

//+---------------------------------------------------------------------------
//
// Function:  HrInstallNetComponent
//
// Purpose:   Install the specified net component
//
// Arguments:
//    szComponentId [in]  component to install
//    nc            [in]  class of the component
//    szInfFullPath [in]  full path to primary INF file
//                        required if the primary INF and other
//                        associated files are not pre-copied to
//                        the right destination dirs.
//                        Not required when installing MS components
//                        since the files are pre-copied by
//                        Windows NT Setup.
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrInstallNetComponent(IN PCWSTR szComponentId,
                              IN enum NetClass nc,
                              IN PCWSTR szInfFullPath)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;

    // cannot install net adapters this way. they have to be
    // enumerated/detected and installed by PnP

    if ((nc == NC_NetProtocol) ||
        (nc == NC_NetService) ||
        (nc == NC_NetClient))
    {
        _putts( GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_TRYING_TO_INSTALL,
                                        szComponentId) );

        // if full path to INF has been specified, the INF
        // needs to be copied using Setup API to ensure that any other files
        // that the primary INF copies will be correctly found by Setup API
        //
        if (!MiniNTMode && szInfFullPath && wcslen(szInfFullPath))
        {
            WCHAR szInfNameAfterCopy[MAX_PATH+1];

            szInfNameAfterCopy[0] = NULL;
            
            if (SetupCopyOEMInf(
                    szInfFullPath,
                    NULL,               // other files are in the
                                        // same dir. as primary INF
                    SPOST_PATH,         // first param. contains path to INF
                    0,                  // default copy style
                    szInfNameAfterCopy, // receives the name of the INF
                                        // after it is copied to %windir%\inf
                    MAX_PATH,           // max buf. size for the above
                    NULL,               // receives required size if non-null
                    NULL))              // optionally retrieves filename
                                        // component of szInfNameAfterCopy
            {
                _putts( GetFormattedMessage(    ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_COPY_NOTIFICATION,
                                                szInfFullPath, 
                                                szInfNameAfterCopy) );
            }
            else
            {
                DWORD dwError = GetLastError();
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }

        if (S_OK == hr)
        {
            // get INetCfg interface
            hr = HrGetINetCfg(TRUE, &pnc);

            if (SUCCEEDED(hr))
            {
                // install szComponentId
                hr = HrInstallNetComponent(pnc, szComponentId,
                                           c_aguidClass[nc]);
                if (SUCCEEDED(hr))
                {
                    // Apply the changes
                    hr = pnc->Apply();
                }

                // release INetCfg
                (void) HrReleaseINetCfg(TRUE, pnc);
            }
        }

        //
        // Don't show the reboot message in WinPE case
        //
        if (MiniNTMode && (hr == NETCFG_S_REBOOT)) {
            hr = S_OK;
        }
        
        // show success/failure message
        ShowHrMessage(hr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrInstallNetComponent
//
// Purpose:   Install the specified net component
//
// Arguments:
//    pnc           [in]  pointer to INetCfg object
//    szComponentId [in]  component to install
//    pguidClass    [in]  class guid of the component
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrInstallNetComponent(IN INetCfg* pnc,
                              IN PCWSTR szComponentId,
                              IN const GUID* pguidClass)
{
    HRESULT hr=S_OK;
    OBO_TOKEN OboToken;
    INetCfgClassSetup* pncClassSetup;
    INetCfgComponent* pncc;

    // OBO_TOKEN specifies the entity on whose behalf this
    // component is being installed

    // set it to OBO_USER so that szComponentId will be installed
    // On-Behalf-Of "user"
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClassSetup,
                                (void**)&pncClassSetup);
    if (SUCCEEDED(hr))
    {
        hr = pncClassSetup->Install(szComponentId,
                                    &OboToken,
                                    NSF_POSTSYSINSTALL,
                                    0,       // <upgrade-from-build-num>
                                    NULL,    // answerfile name
                                    NULL,    // answerfile section name
                                    &pncc);
        if (S_OK == hr)
        {
            // we dont want to use pncc (INetCfgComponent), release it
            ReleaseObj(pncc);
        }

        ReleaseObj(pncClassSetup);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrUninstallNetComponent
//
// Purpose:   Initialize INetCfg and uninstall a component
//
// Arguments:
//    szComponentId [in]  InfId of component to uninstall (e.g. MS_TCPIP)
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrUninstallNetComponent(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;

    _putts( GetFormattedMessage(    ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_UNINSTALL_NOTIFICATION,
                                    szComponentId) );

    // get INetCfg interface
    hr = HrGetINetCfg(TRUE, &pnc);

    if (SUCCEEDED(hr))
    {
        // uninstall szComponentId
        hr = HrUninstallNetComponent(pnc, szComponentId);

        if (S_OK == hr)
        {
            // Apply the changes
            hr = pnc->Apply();
        }
        else if (S_FALSE == hr)
        {
            _putts( GetFormattedMessage(    ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_NOT_INSTALLED_NOTIFICATION,
                                            szComponentId) );
        }

        // release INetCfg
        (void) HrReleaseINetCfg(TRUE, pnc);
    }

    // show success/failure message
    ShowHrMessage(hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrUninstallNetComponent
//
// Purpose:   Uninstall the specified component.
//
// Arguments:
//    pnc           [in]  pointer to INetCfg object
//    szComponentId [in]  component to uninstall
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrUninstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    OBO_TOKEN OboToken;
    INetCfgComponent* pncc;
    GUID guidClass;
    INetCfgClass* pncClass;
    INetCfgClassSetup* pncClassSetup;

    // OBO_TOKEN specifies the entity on whose behalf this
    // component is being uninstalld

    // set it to OBO_USER so that szComponentId will be uninstalld
    // On-Behalf-Of "user"
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    // see if the component is really installed
    hr = pnc->FindComponent(szComponentId, &pncc);

    if (S_OK == hr)
    {
        // yes, it is installed. obtain INetCfgClassSetup and DeInstall

        hr = pncc->GetClassGuid(&guidClass);

        if (S_OK == hr)
        {
            hr = pnc->QueryNetCfgClass(&guidClass, IID_INetCfgClass,
                                       (void**)&pncClass);
            if (SUCCEEDED(hr))
            {
                hr = pncClass->QueryInterface(IID_INetCfgClassSetup,
                                              (void**)&pncClassSetup);
                    if (SUCCEEDED(hr))
                    {
                        hr = pncClassSetup->DeInstall (pncc, &OboToken, NULL);

                        ReleaseObj (pncClassSetup);
                    }
                ReleaseObj(pncClass);
            }
        }
        ReleaseObj(pncc);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  HrShowNetAdapters
//
// Purpose:   Display all installed net class devices using Setup API
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetAdapters()
{
#define MAX_COMP_INSTID 4096
#define MAX_COMP_DESC   4096

    HRESULT hr=S_OK;
    HDEVINFO hdi;
    DWORD dwIndex=0;
    SP_DEVINFO_DATA deid;
    BOOL fSuccess=FALSE;
    DWORD   cchRequiredSize;
    LPTSTR lpszCompInstanceId;
    LPTSTR lpszCompDescription;
    DWORD dwRegType;
    BOOL fFound=FALSE;

    // get a list of all devices of class 'GUID_DEVCLASS_NET'
    hdi = SetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL, DIGCF_PRESENT);

    // Allocate the buffer for the device instance ID
    //
    lpszCompInstanceId = (LPTSTR) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (MAX_COMP_INSTID * sizeof(WCHAR)) );

    // Allocate the buffer for the device description
    //
    lpszCompDescription = (LPTSTR) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, (MAX_COMP_DESC * sizeof(WCHAR)) );

    if ( (NULL != lpszCompInstanceId)  && 
         (NULL != lpszCompDescription) &&
         (INVALID_HANDLE_VALUE != hdi) )
    {
        // enumerate over each device
        while (deid.cbSize = sizeof(SP_DEVINFO_DATA),
               SetupDiEnumDeviceInfo(hdi, dwIndex, &deid))
        {
            dwIndex++;

            // the right thing to do here would be to call this function
            // to get the size required to hold the instance ID and then
            // to call it second time with a buffer large enough for that size.
            // However, that would tend to obscure the control flow in
            // the sample code. Lets keep things simple by keeping the
            // buffer large enough.
            
            // get the device instance ID
            fSuccess = SetupDiGetDeviceInstanceId(hdi, &deid,
                                                  lpszCompInstanceId,
                                                  MAX_COMP_INSTID, NULL);

            if (fSuccess)
            {
                // get the description for this instance
                fSuccess =
                    SetupDiGetDeviceRegistryProperty(hdi, &deid,
                                                     SPDRP_DEVICEDESC,
                                                     &dwRegType,
                                                     (BYTE*) lpszCompDescription,
                                                     MAX_COMP_DESC,
                                                     NULL);
                if (fSuccess)
                {
                    if (!fFound)
                    {
                        fFound = TRUE;
                        _putts( GetFormattedMessage( ThisModule,
                                                     FALSE,
                                                     Message,
                                                     sizeof(Message)/sizeof(Message[0]),
                                                     MSG_INSTANCE_DESCRIPTION ) );
                    }
                    _putts( GetFormattedMessage( ThisModule,
                                                 FALSE,
                                                 Message,
                                                 sizeof(Message)/sizeof(Message[0]),
                                                 MSG_COMPONENT_DESCRIPTION, 
                                                 lpszCompInstanceId, 
                                                 lpszCompDescription ) );
                }
            }
        }

        // release the device info list
        SetupDiDestroyDeviceInfoList(hdi);
    }

    // Free the device instance buffer
    //
    if ( lpszCompInstanceId )
        HeapFree( GetProcessHeap(), 0, lpszCompInstanceId );

    // Free the device description buffer
    //
    if ( lpszCompDescription )
        HeapFree( GetProcessHeap(), 0, lpszCompDescription );

    if (!fSuccess)
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowNetComponents
//
// Purpose:   Display the list of installed components of the
//            specified class.
//
// Arguments:
//    pnc        [in]  pointer to INetCfg object
//    pguidClass [in]  pointer to class GUID
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetComponents(IN INetCfg* pnc,
                            IN const GUID* pguidClass)
{
    HRESULT hr=S_OK;
    PWSTR szInfId;
    PWSTR szDisplayName;
    DWORD dwcc;
    INetCfgComponent* pncc;
    INetCfgClass* pncclass;
    IEnumNetCfgComponent* pencc;
    ULONG celtFetched;

    hr = pnc->QueryNetCfgClass(pguidClass, IID_INetCfgClass,
                               (void**)&pncclass);
    if (SUCCEEDED(hr))
    {
        // get IEnumNetCfgComponent so that we can enumerate
        hr = pncclass->EnumComponents(&pencc);

        ReleaseObj(pncclass);

        while (SUCCEEDED(hr) &&
               (S_OK == (hr = pencc->Next(1, &pncc, &celtFetched))))
        {
            if (pguidClass == &GUID_DEVCLASS_NET)
            {
                // we are interested only in physical netcards
                //
                hr = pncc->GetCharacteristics(&dwcc);

                if (FAILED(hr) || !(dwcc & NCF_PHYSICAL))
                {
                    hr = S_OK;
                    ReleaseObj(pncc);
                    continue;
                }
            }

            hr = pncc->GetId(&szInfId);

            if (S_OK == hr)
            {
                hr = pncc->GetDisplayName(&szDisplayName);
                if (SUCCEEDED(hr))
                {
                    _putts( GetFormattedMessage(    ThisModule,
                                                    FALSE,
                                                    Message,
                                                    sizeof(Message)/sizeof(Message[0]),
                                                    MSG_DISPLAY_NAME,  
                                                    szInfId, 
                                                    szDisplayName) );

                    CoTaskMemFree(szDisplayName);
                }
                CoTaskMemFree(szInfId);
            }
            // we dont want to stop enumeration just because 1 component
            // failed either GetId or GetDisplayName, therefore reset hr to S_OK
            hr = S_OK;

            ReleaseObj(pncc);
        }
        ReleaseObj(pencc);
    }


    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  HrShowNetComponents
//
// Purpose:   Display installed net components.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetComponents()
{
    HRESULT hr=S_OK;
    PCWSTR szClassName;

    static const PCWSTR c_aszClassNames[] =
    {
        L"Network Adapters",
        L"Network Protocols",
        L"Network Services",
        L"Network Clients"
    };

    INetCfg* pnc;

    // get INetCfg interface
    hr = HrGetINetCfg(FALSE, &pnc);

    if (SUCCEEDED(hr))
    {
        for (int i=0; i<4; i++)
        {
            _putts( GetFormattedMessage(    ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_NET_COMPONENTS,  
                                            c_aszClassNames[i]) );

            (void) HrShowNetComponents(pnc, c_aguidClass[i]);
        }

        // release INetCfg
        hr = HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetNextBindingInterface
//
// Purpose:   Enumerate over binding interfaces that constitute
//            the given binding path
//
// Arguments:
//    pncbp  [in]  pointer to INetCfgBindingPath object
//    ppncbi [out] pointer to pointer to INetCfgBindingInterface object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetNextBindingInterface(IN  INetCfgBindingPath* pncbp,
                                  OUT INetCfgBindingInterface** ppncbi)
{
    HRESULT hr=S_OK;
    INetCfgBindingInterface* pncbi=NULL;

    static IEnumNetCfgBindingInterface* pencbi=NULL;

    *ppncbi = NULL;

    // if this is the first call in the enumeration, obtain
    // the IEnumNetCfgBindingInterface interface
    //
    if (!pencbi)
    {
        hr = pncbp->EnumBindingInterfaces(&pencbi);
    }

    if (S_OK == hr)
    {
        ULONG celtFetched;

        // get next binding interface
        hr = pencbi->Next(1, &pncbi, &celtFetched);
    }

    // on the last call (hr == S_FALSE) or on error, release resources

    if (S_OK == hr)
    {
        *ppncbi = pncbi;
    }
    else
    {
        ReleaseObj(pencbi);
        pencbi = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetNextBindingPath
//
// Purpose:   Enumerate over binding paths that start with
//            the specified component
//
// Arguments:
//    pncc              [in]  pointer to INetCfgComponent object
//    dwBindingPathType [in]  type of binding path to retrieve
//    ppncbp            [out] pointer to INetCfgBindingPath interface
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetNextBindingPath(IN  INetCfgComponent* pncc,
                             IN  DWORD  dwBindingPathType,
                             OUT INetCfgBindingPath** ppncbp)
{
    HRESULT hr=S_OK;
    INetCfgBindingPath* pncbp=NULL;

    static IEnumNetCfgBindingPath* pebp=NULL;

    *ppncbp = NULL;

    // if this is the first call in the enumeration, obtain
    // the IEnumNetCfgBindingPath interface
    if (!pebp)
    {
        INetCfgComponentBindings* pnccb=NULL;

        hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                                  (void**) &pnccb);
        if (S_OK == hr)
        {
            hr = pnccb->EnumBindingPaths(dwBindingPathType, &pebp);
            ReleaseObj(pnccb);
        }
    }

    if (S_OK == hr)
    {
        ULONG celtFetched;

        // get next binding path
        hr = pebp->Next(1, &pncbp, &celtFetched);
    }

    // on the last call (hr == S_FALSE) or on error, release resources

    if (S_OK == hr)
    {
        *ppncbp = pncbp;
    }
    else
    {
        ReleaseObj(pebp);
        pebp = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowBindingPath
//
// Purpose:   Display components of a binding path in the format:
//            foo -> bar -> adapter
//
// Arguments:
//    pncbp [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowBindingPath(IN INetCfgBindingPath* pncbp)
{
    HRESULT hr=S_OK;
    INetCfgBindingInterface* pncbi;
    INetCfgComponent* pncc = NULL;
    BOOL fFirstInterface=TRUE;
    PWSTR szComponentId;

    while (SUCCEEDED(hr) &&
           (S_OK == (hr = HrGetNextBindingInterface(pncbp, &pncbi))))
    {
        // for the first (top) interface we need to get the upper as well as
        // the lower component. for other interfaces we need to get
        // only the lower component.

        if (fFirstInterface)
        {
            fFirstInterface = FALSE;
            hr = pncbi->GetUpperComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                // get id so that we can display it
                //
                // for readability of the output, we have used the GetId
                // function. For non net class components, this
                // does not pose a problem. In case of net class components,
                // there may be more than one net adapters of the same type
                // in which case, GetId will return the same string. This will
                // make it impossible to distinguish between two binding
                // paths that end in two distinct identical cards. In such case,
                // it may be better to use the GetInstanceGuid function because
                // it will return unique GUID for each instance of an adapter.
                //
                hr = pncc->GetId(&szComponentId);
                ReleaseObj(pncc);
                if (SUCCEEDED(hr))
                {
                    _putts( GetFormattedMessage(    ThisModule,
                                                    FALSE,
                                                    Message,
                                                    sizeof(Message)/sizeof(Message[0]),
                                                    MSG_COMPONENT_ID, 
                                                    szComponentId) );
                    CoTaskMemFree(szComponentId);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pncbi->GetLowerComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                hr = pncc->GetId(&szComponentId);
                if (SUCCEEDED(hr))
                {
                    _putts( GetFormattedMessage(    ThisModule,
                                                    FALSE,
                                                    Message,
                                                    sizeof(Message)/sizeof(Message[0]),
                                                    MSG_LOWER_COMPONENTS, 
                                                    szComponentId) );
                    CoTaskMemFree(szComponentId);
                }
                ReleaseObj(pncc);
            }
        }
        ReleaseObj(pncbi);
    }

    _tprintf(L"\n");

    if (hr == S_FALSE)
    {
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowBindingPathsBelowComponent
//
// Purpose:   Display all binding paths that start with
//            the specified component
//
// Arguments:
//    szComponentId [in]  id of given component (e.g. MS_TCPIP)
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowBindingPathsOfComponent(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc=NULL;
    INetCfgComponent* pncc=NULL;
    INetCfgBindingPath* pncbp=NULL;

    // get INetCfg interface
    hr = HrGetINetCfg(FALSE, &pnc);

    if (SUCCEEDED(hr))
    {
        // get INetCfgComponent for szComponentId
        hr = pnc->FindComponent(szComponentId, &pncc);
        if (S_OK == hr)
        {
            _putts( GetFormattedMessage(    ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_BINDING_PATHS_START, 
                                            szComponentId) );

            while (S_OK == (hr = HrGetNextBindingPath(pncc, EBP_BELOW,
                                                      &pncbp)))
            {
                // display the binding path
                hr = HrShowBindingPath(pncbp);
                ReleaseObj(pncbp);
            }

            _putts( GetFormattedMessage(    ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_BINDING_PATHS_END, 
                                            szComponentId) );

            while (S_OK == (hr = HrGetNextBindingPath(pncc, EBP_ABOVE,
                                                      &pncbp)))
            {
                // display the binding path
                hr = HrShowBindingPath(pncbp);
                ReleaseObj(pncbp);
            }

            ReleaseObj(pncc);
        }
        // release INetCfg
        hr = HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetINetCfg
//
// Purpose:   Initialize COM, create and initialize INetCfg.
//            Obtain write lock if indicated.
//
// Arguments:
//    fGetWriteLock [in]  whether to get write lock
//    ppnc          [in]  pointer to pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetINetCfg(IN BOOL fGetWriteLock,
                     INetCfg** ppnc)
{
    HRESULT hr=S_OK;

    // Initialize the output parameters.
    *ppnc = NULL;

    // initialize COM
    hr = CoInitializeEx(NULL,
                        COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, (void**)&pnc);
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pncLock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         (LPVOID *)&pncLock);
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    static const ULONG c_cmsTimeout = 15000;
                    static const WCHAR c_szSampleNetcfgApp[] =
                        L"Sample Netcfg Application (netcfg.exe)";
                    PWSTR szLockedBy;

                    hr = pncLock->AcquireWriteLock(c_cmsTimeout,
                                                   c_szSampleNetcfgApp,
                                                   &szLockedBy);
                    if (S_FALSE == hr)
                    {
                        hr = NETCFG_E_NO_WRITE_LOCK;
                        _putts( GetFormattedMessage(    ThisModule,
                                                        FALSE,
                                                        Message,
                                                        sizeof(Message)/sizeof(Message[0]),
                                                        MSG_NETCFG_ALREADY_LOCKED, 
                                                        szLockedBy) );
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize(NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    pnc->AddRef();
                }
                else
                {
                    // initialize failed, if obtained lock, release it
                    if (pncLock)
                    {
                        pncLock->ReleaseWriteLock();
                    }
                }
            }
            ReleaseObj(pncLock);
            ReleaseObj(pnc);
        }

        if (FAILED(hr))
        {
            CoUninitialize();
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrReleaseINetCfg
//
// Purpose:   Uninitialize INetCfg, release write lock (if present)
//            and uninitialize COM.
//
// Arguments:
//    fHasWriteLock [in]  whether write lock needs to be released.
//    pnc           [in]  pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrReleaseINetCfg(BOOL fHasWriteLock, INetCfg* pnc)
{
    HRESULT hr = S_OK;

    // uninitialize INetCfg
    hr = pnc->Uninitialize();

    // if write lock is present, unlock it
    if (SUCCEEDED(hr) && fHasWriteLock)
    {
        INetCfgLock* pncLock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 (LPVOID *)&pncLock);
        if (SUCCEEDED(hr))
        {
            hr = pncLock->ReleaseWriteLock();
            ReleaseObj(pncLock);
        }
    }

    ReleaseObj(pnc);

    CoUninitialize();

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  ShowHrMessage
//
// Purpose:   Helper function to display the status of the last action
//            as indicated by the given HRESULT
//
// Arguments:
//    hr [in]  status code
//
// Returns:   None
//
// Notes:
//
void ShowHrMessage(IN HRESULT hr)
{
    
    if (SUCCEEDED(hr))
    {
        _putts( GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_DONE) );
        if (NETCFG_S_REBOOT == hr)
        {
            _putts(GetFormattedMessage( ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_MACHINE_REBOOT_REQUIRED) );
        }
    }
    else
    {
        _putts( GetFormattedMessage(    ThisModule,
                                        FALSE,
                                        Message,
                                        sizeof(Message)/sizeof(Message[0]),
                                        MSG_FAILURE_NOTIFICATION) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\filesize.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;----------------------------------------------------------------------------
;
; M026	: B#5794. Updated DOS_SIZE.
;
;----------------------------------------------------------------------------
;

ifdef DOSV
BIOS_SIZE_KB    equ     230
else
BIOS_SIZE_KB    equ     230
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\display.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;

;***************************************************************************
;***************************************************************************
;UTILITY NAME: FORMAT.COM
;
;MODULE NAME: DISPLAY.ASM
;
;
; Change List: AN000 - New code DOS 3.3 spec additions
;              AC000 - Changed code DOS 3.3 spec additions
;***************************************************************************
;***************************************************************************

EXTRN	SwitchMap	:WORD	; Command line sitch map

;***************************************************************************
; Define Segment ordering
;***************************************************************************



.SEQ

PSP     segment public  para    'DUMMY'
PSP     ends

data    segment public para 'DATA'
	Public Test_Data_Start
	Test_Data_Start label byte
data    ends

stack   segment para stack
        db      62 dup ("-Stack!-")	; (362-80h) is the additional IBM ROM
        assume ss:stack
stack   ends

code    segment public para 'CODE'
        assume  cs:code,ds:data
code    ends


End_Of_Memory    segment public para 'BUFFERS'
Public  Test_End
Test_End        label   byte
End_Of_Memory    ends



;***************************************************************************
; INCLUDE FILES
;***************************************************************************


.xlist
INCLUDE FORCHNG.INC
INCLUDE FOREQU.INC
INCLUDE FORMSG.INC
INCLUDE MSGSVR.INC
INCLUDE	FORSWTCH.INC
.list


;***************************************************************************
; Message Services
;***************************************************************************


MSG_UTILNAME  <FORMAT>


data    segment public  para    'DATA'


MSGBUF_SIZE	equ 02000h	    ; 8k buffer
Msg_Services    <MSGDATA>


data    ends

code    segment public  para    'CODE'
Msg_Services    <LOADmsg,DISPLAYmsg,GETmsg,CHARmsg,NUMmsg>      ; (PW)
code    ends

;***************************************************************************
; Public Declarations
;***************************************************************************

        Public  SysDispMsg
        Public  SysLoadMsg
        Public  SysGetMsg

;***************************************************************************
; Message Structures
;***************************************************************************

Message_Table struc

Entry1  dw      0
Entry2  dw      0
Entry3  dw      0
Entry4  dw      0
Entry5  db      0
Entry6  db      0
Entry7  dw      0

Message_Table ends


;***************************************************************************

code    segment public  para    'CODE'

;***************************************************************************

;***************************************************************************
;Routine name&gml Display_Interface
;***************************************************************************
;
;DescriptioN&gml Save all registers, set up registers required for SysDispMsg
;             routine. This information is contained in a message description
;             table pointed to by the DX register. Call SysDispMsg, then
;             restore registers. This routine assumes that the only time an
;             error will be returned is if an extended error message was
;             requested, so it will ignore error returns
;
;Called Procedures: SysDispMsg
;
;Change History&gml Created        4/22/87         MT
;
;Input&gml ES&gmlDX = pointer to message description
;
;Output&gml None
;
;Psuedocode
;----------
;
;       Save all registers
;       Setup registers for SysDispMsg from Message Description Tables
;       CALL SysDispMsg
;       Restore registers
;       ret
;***************************************************************************

Public  Display_Interface
Display_Interface   proc


        push    ds
        push    ax                              ;Save registers
        push    bx
        push    cx
        push    dx
        push    si
        push    di
        mov     di,dx                           ;Change pointer
        mov     dx,data                         ;Point to data segment
        mov     ds,dx

	test	SwitchMap,SWITCH_SELECT
	jnz	DisplayDone

        mov     ax,[di].Entry1                  ;Message number
        mov     bx,[di].Entry2                  ;Handle
        mov     si,[di].Entry3                  ;Sublist
        mov     cx,[di].Entry4                  ;Count
        mov     dh,[di].Entry5                  ;Class
        mov     dl,[di].Entry6                  ;Function
        mov     di,[di].Entry7                  ;Input
        call    SysDispMsg                      ;Display the mes

DisplayDone:
        pop     di                              ;Restore registers
        pop     si
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        pop     ds
        ret                                     ;All done

Display_Interface      endp
code    ends
        end


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\dskfrmt.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;===========================================================================
; 
; FILE: DSKFRMT.ASM
;
;===========================================================================

;===========================================================================
;Declaration of include files
;===========================================================================

debug	 equ	 0
	 .xlist
	 INCLUDE DOSEQUS.INC
	 INCLUDE DOSMAC.INC
	 INCLUDE SYSCALL.INC
	 INCLUDE ERROR.INC
	 INCLUDE BPB.INC
	 INCLUDE FOREQU.INC
	 INCLUDE FORMACRO.INC
	 INCLUDE IOCTL.INC
	 INCLUDE FORSWTCH.INC
	 .list

;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;===========================================================================
; Data segment
;===========================================================================

DATA    SEGMENT PUBLIC PARA 'DATA'

;Bytes
	EXTRN	fBigFat			:BYTE
	EXTRN	fBig32Fat		:BYTE
	EXTRN	ExitStatus		:BYTE
	EXTRN	DblFlg			:BYTE
	EXTRN	DriveToFormat		:BYTE
	EXTRN	msgFormatFailure	:BYTE
	EXTRN	msgDiskUnusable 	:BYTE
	EXTRN	msgNotSystemDisk	:BYTE
	EXTRN	msgParametersNotSupported:BYTE
	EXTRN	msgParametersNotSupportedByDrive:BYTE
	EXTRN	msgHardDiskWarning	:BYTE
        EXTRN   msgDiskWarning          :BYTE
	EXTRN	msgInsertDisk		:BYTE
	EXTRN	msgCrLf			:BYTE
	EXTRN	msgCurrentTrack		:BYTE
	EXTRN	msgFormatComplete	:BYTE
	EXTRN	msgVerify		:BYTE
	EXTRN	msgSetBadClus		:BYTE
	EXTRN	msgSetBadClusDone	:BYTE
	EXTRN	ContinueMsg		:BYTE
	EXTRN	Extended_Error_Msg	:BYTE
	EXTRN	Clustbound_Flag 	:BYTE
	EXTRN	Fatal_Error		:BYTE
	EXTRN	FATNotAllInMem		:BYTE
	EXTRN	msgInsufficientMemory	:BYTE
	EXTRN	msgWriteFat		:BYTE

;Words
	EXTRN	FirstHead		:WORD
	EXTRN	FirstCylinder		:WORD
	EXTRN  	Formatted_Tracks_Low	:WORD
	EXTRN	Formatted_Tracks_High	:WORD
	EXTRN   Paras_Per_Fat		:WORD
	EXTRN	SwitchMap		:WORD
	EXTRN	SwitchMap2		:WORD
	EXTRN	Relative_Sector_Low	:WORD
	EXTRN	Relative_Sector_High	:WORD
	EXTRN	Clustbound_Buffer_Seg 	:WORD
	EXTRN	Clustbound_Adj_Factor	:WORD
	EXTRN	Clustbound_Spt_Count	:WORD

; Dwords
	EXTRN	TracksLeft		:DWORD
	EXTRN	TracksPerDisk		:DWORD
	EXTRN	sector_in_buffer	:DWORD
	EXTRN	sector_to_read		:DWORD
	EXTRN	TotalClusters		:DWORD
	EXTRN	StartSector		:DWORD
	EXTRN	FATSecCntInMem		:DWORD

;Pointers
	EXTRN	SysSiz 			:DWORD
	EXTRN	BioSiz 			:DWORD
	EXTRN	Msg_Allocation_Unit_Val	:DWORD
	EXTRN	FatSpace	  	:DWORD
	EXTRN	FatSector		:DWORD

;Structures
	EXTRN	DeviceParameters	:BYTE
	EXTRN	IsExtRAWIODrv		:BYTE
	EXTRN	FormatPacket		:BYTE
	EXTRN	Read_Write_Relative	:BYTE

RWPacket		a_TrackReadWritePacket	<>

ifdef NEC_98
RW_TRF_Area		db	2048	dup(0)
else
RW_TRF_Area		db	512	dup(0)
endif
fLastChance		db	FALSE	; Flags reinvocation from
					; LastChanceToSaveIt. Used by DskPrm
FormatError		db	0
Format_End		db	FALSE
Track_Action		db	?	; Actual operation performed on disk

odd_entry		db	1	; flag for 12-bit FAT entry alignment

entry_offset		dw	?	; Offset of entry from start of sector

PercentComplete 	dw	0FFFFh	; Init non-zero so msg will display
					; first time
Fat_Init_Value		dw	0	; initializes the Fat
SysTrks 		dd	?
Sectors 		dw	?
CurrentHead		dw	0
CurrentCylinder		dw	0
Tracks_To_Format	dw	?
Track_Count		dw	?

CurrentCluster		dd	?	; holds the cluster currently being checked
					; in QuickFormat
BadClusValue		dd	?	; holds FAT entry value for bad cluster

BadClusBitMap		dd	0

CurrFATInMemStartSec	dd	0
CurrFATInMemSecCnt	dd	0
CurrFATInMemStartClus	dd	0
FATInMemClusCnt 	dd	0

DATA	ENDS

;===========================================================================
; Executable code segment
;===========================================================================

CODE	SEGMENT PUBLIC PARA	'CODE'
	ASSUME	CS:CODE, DS:DATA, ES:DATA

;===========================================================================
;EXTRNs needed in code segment
;===========================================================================

;Labels
	EXTRN	FatalExit		:NEAR
	EXTRN	CrLf			:NEAR

;Functions
	EXTRN	DetermineExistingFormatNoMsg	:NEAR
	EXTRN	SetStartSector		:NEAR
	EXTRN	SetfBigFat		:NEAR
	EXTRN	Phase2Initialization	:NEAR
	EXTRN	GetBioSize 		:NEAR
        EXTRN   GetDosSize              :NEAR
	EXTRN	GetCmdSize 		:NEAR
	EXTRN	LastChanceToSaveIt 	:NEAR
	EXTRN	AccessDisk 		:NEAR
	EXTRN	Yes?  			:NEAR
	EXTRN	ExitProgram 		:NEAR
	EXTRN	User_String 		:NEAR
	EXTRN	Read_Disk		:NEAR
	EXTRN	Seg_Adj 		:NEAR
	EXTRN	IsDblSpaceDisk		:NEAR
	EXTRN	Write_Disk		:NEAR
	EXTRN	ShowFormatSize		:NEAR

;Constants
	EXTRN	EXIT_FATAL		:ABS
	EXTRN	EXIT_NO			:ABS
	EXTRN	EXIT_DRV_NOT_READY	:ABS
	EXTRN	EXIT_WRIT_PROTECT	:ABS
	EXTRN	EXIT_FATAL 		:ABS
	EXTRN	EXIT_NO			:ABS

;===========================================================================
; Declarations for all publics in this module
;===========================================================================

	PUBLIC	Disk_Format_Proc
	PUBLIC	FrmtProb
	PUBLIC	fLastChance
	PUBLIC	CurrentHead
	PUBLIC	CurrentCylinder
	PUBLIC	Multiply_32_Bits
	PUBLIC	SetDeviceParameters
	PUBLIC	PercentComplete
	PUBLIC	Prompt_User_For_Disk

	PUBLIC	calc_sector_and_offset
	PUBLIC	ReadFatSector
	PUBLIC	GetSetFatEntry
	PUBLIC	GetFatSectorEntry
	PUBLIC	DetermineTrackAction
	PUBLIC	QuickFormat
	PUBLIC	FlushFATBuf
	PUBLIC	Fat_Init
	PUBLIC	Get_Bad_Sector_Hard
	PUBLIC	Multiply_32_Bits
	PUBLIC	IsThisClusterBad
	PUBLIC	WrtEOFMrkInRootClus

;========================================================================
;
;  DISK_FORMAT_PROC : 	This procedure is used to call
;			the real DiskFormat procedure.
;  Returns :	NC --> Format successful
;		CY --> Format unsuccessful, go to next disk
;
;========================================================================

Disk_Format_Proc	proc	near

	call	DetermineTrackAction	; Check for safe format, and validity
					; of quick format switch
	call	init_fat_with_header	; setup blank FAT image

	test	SwitchMap,SWITCH_Q	; Check for quick format
	jz	RegularFormat
	test	SwitchMap,SWITCH_Z	; Check for sec/clus override
	jnz	RegularFormat

	call	ShowFormatSize		; size being formatted message

	call	QuickFormat
	jc	FarExit			; procedure exit is too far for direct jump
	Message	msgFormatComplete
FarExit:
	jmp	Exit_Disk_Format_Proc

RegularFormat:
	test	SwitchMap,SWITCH_Z
	jnz	no_load_old_fat		; don't need to load the old FAT
	test	SwitchMap2,Switch2_C
	jnz	no_load_old_fat		; don't need to load the old FAT

	call	SetUpBadClusTransfer
	jnc	no_load_old_fat

	Message msgInsufficientMemory
	stc
	jmp	short FarExit

no_load_old_fat:
	call	ShowFormatSize		; size being formatted message
	call	DiskFormat		; Format the disk
	jnc	GetTrk			; check for problems

FrmtProb:

	test	SwitchMap,Switch_Select	; SELECT option?
	jnz	CheckForMore		; No - display message
	Message msgFormatFailure
	mov	ExitStatus, EXIT_FATAL

CheckForMore:
	stc				; Signal error which will be handled
					; in main routine (by prompting for
					; next disk)
	jmp	Exit_Disk_Format_Proc

    ;Mark any bad Sectors in the Fats
    ;And keep track of how  many bytes there are in bad Sectors
GetTrk:
	call	BadSector		; Do bad track fix-up
	jc	FrmtProb		; Had an error in Fmt - can't recover
	CMP	AX,0			; Are we finished?
	jnz	TrkFnd			; No - check error conditions
	jmp	Exit_Disk_Format_Proc	; Yes

;--------------------------------------------------------------------------
; BUG NOTE:  The two sections in "if ibmcopyright..." here and	below are
;   to	correct	a bug.	If one of the Sectors just above the 32M boundary
;   were bad, it thought they were in the system area,	and hence that the
;   disk was unusable.
;
; PYS: IBMCOPYRIGHT removed
;
;--------------------------------------------------------------------------

TrkFnd:
.386
	mov	EBX,dword ptr Relative_Sector_Low ; get the sector
	cmp	EBX,StartSector 		; Any sec in the sys area bad?
.8086
	jae	ClrTest 			; MZ 2.26 unsigned compare
	Message msgDiskUnusable
	jmp	FrmtProb			; Bad disk -- try again

ClrTest:
	mov	Sectors,AX			; Save # sectors on the track
	test	SwitchMap,SWITCH_S		; If sys requested calc size
	jz	Bad100

	cmp	BYTE PTR DblFlg,0		; Is sys space aready calced?
	jnz	cmpTrks				; Yes - all ready for the compare
	inc	BYTE PTR DblFlg			; No -	set the	flag

	call	GetBioSize			; Get the size	of the Bios
	mov	DX,WORD PTR SysSiz+2
	mov	AX,WORD PTR SysSiz
	mov	WORD PTR BioSiz+2,DX
	mov	WORD PTR BioSiz,AX
        call    GETDOSSIZE
	call	GETCMDSIZE
	mov	DX,WORD PTR BioSiz+2
	mov	AX,WORD PTR BioSiz
	div	DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
    .errnz EDP_BPB NE DP_BPB
.386
	movzx	eax,ax
	add	EAX,StartSector
	mov	SysTrks,EAX			; Space Fat,Dir,and system
						; files require
cmpTrks:
	mov	EBX,dword ptr Relative_Sector_Low ;get the low word of the sector
	cmp	EBX,SysTrks
.8086
	JA	Bad100				; MZ 2.26 unsigned compare
	mov	ExitStatus, EXIT_FATAL
	Message msgNotSystemDisk
	AND	SwitchMap,NOT SWITCH_S		; Turn off system transfer switch
	mov	WORD PTR SysSiz+2,0		; No system to transfer
	mov	WORD PTR SysSiz,0		; No system to transfer

Bad100:
	cmp	DeviceParameters.DP_DeviceType, DEV_HARDDISK ;hard disk?
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	$$IF5				; no
	call	Get_Bad_Sector_Hard		; see if a sector is bad
	jmp	SHORT $$EN5

$$IF5:
	call	Get_Bad_Sector_Floppy		; mark entire track bad

$$EN5:
	jmp	GetTrk

Exit_Disk_Format_Proc:
	ret			

Disk_Format_Proc	ENDP

;==========================================================================
;
; DetermineTrackAction  :	This procedure sets the value of 
;				Track_Action based on the setting of
;				SWITCH_U, the unconditional format switch.
;				Track_Action is the function that is
;				actually performed on each track of the
;				disk to be formatted.
;
;  Inputs  :	SwitchMap
;  Output  :    SWITCH_U set   - Track_Action = Format and Verify
;		SWITCH_U clear - Track_Action = Verify only
;
;==========================================================================

DetermineTrackAction	proc	near

	test	SwitchMap,SWITCH_U
	jz	Verify_Only

Format_And_Verify:
	mov	Track_Action,FORMAT_TRACK		; regular format
	ret

Verify_Only:
	mov	Track_Action,VERIFY_TRACK	     	; safe format
	ret

DetermineTrackAction	endp

; =========================================================================
;    DiskFormat:
;	 Format	the tracks on the disk
;	 Since we do our SetDeviceParameters here, we also need	to
;	 detect	the legality of	/N /T if present and abort with	errors
;	 if not.
;	 This routine stops as soon as it encounters a bad track
;	 Then BadSector	is called to report the	bad track, and it continues
;	 the format
;
;    Algorithm:
;	 current track = first
;	 while not done
;	    if format track fails
;	       DiskFormatErrors	= true
;	       return
;	    next track
; =========================================================================

DiskFormat proc near

	mov	DeviceParameters.DP_SpecialFunctions, (INSTALL_FAKE_BPB or TRACKLAYOUT_IS_GOOD)
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS
	lea	DX, DeviceParameters
	call	SetDeviceParameters
	test	SwitchMap,switch_8	; DCL 5/12/86 avoid Naples AH=18h
	jnz	stdBpB			; lackof support for 8 Secs/track

	; DCL 5/12/86 - Always do the Status_FOR_FORMAT test, as we
	; don't know if the machine has this support.   For 3.2 /N:
	; & /T: were not documented & therefore not fully supported
	; thru the ROM of Aquarius & Naples & Royal Palm


	;	test	SwitchMap, SWITCH_N or SWITCH_T ; IF (/N or /T)
	;	jz	StdBPB
	; THEN check if
	; supported

	; Check to see if device driver can handle specified parameters

	mov	FormatPacket.FP_SpecialFunctions, Status_FOR_FORMAT
	mov	AX, (IOCTL shl	8) or GENERIC_IOCTL
	mov	BL, DriveToFormat
	inc	BL

	mov	CX, (RAWIO shl	8) or FORMAT_TRACK
	cmp	IsEXTRAWIODrv,0
	je	DoFrmt
	mov	CX, (EXTRAWIO shl  8) or FORMAT_TRACK
DoFrmt:
	lea	DX, FormatPacket
	int	21h

;;%out FORQUICK ENABLED!!!!!
;;	  clc	  ;**ARR

	;		switch ( FormatStatusCall)
	;	cmp	FormatPacket.FP_SpecialFunctions, \
	;		Format_No_ROM_Support
	;	jb	NTSupported	; 0 returned from IBMBIO
	;	ja	IllegalComb	; 2 returned - ROM Support
	;		Illegal Combination!

	cmp	FormatPacket.FP_SpecialFunctions,0 ; 0 --> Can support
	je	NTSupported
	cmp	FormatPacket.FP_SpecialFunctions,2 ; 2 --> Cannot support
	jne	$$IF28

	Message msgParametersNotSupportedByDrive
	mov	Fatal_Error,Yes			; Indicate quittin'type	err!
	jmp	SHORT $$EN28

$$IF28:
	cmp	FormatPacket.FP_SpecialFunctions,3 ; 3 --> No disk in drive
	jne	$$IF30
	mov	AX,Error_Not_Ready		; flag not ready
	call	CheckError			; set error level
	jmp	FrmtProb			; exit	program
	jmp	SHORT $$EN30			; DCL No ROM support is okay

$$IF30:
						; except for /N: & /T:
	test	SwitchMap, SWITCH_N or SWITCH_T ; DCL 5/12/86
	jz	$$IF32
	Message msgParametersNotSupported
	mov	Fatal_Error,Yes			; Indicate quittin 'type err!

$$IF32:
$$EN30:
$$EN28:
	cmp	Fatal_Error,Yes
	jne	StdBPB
	jmp	FatalExit
						; We have the support to carry
						; out the FORMAT
NTSupported:
StdBPB:
	mov	FormatPacket.FP_SpecialFunctions, 0
	mov	AX, FirstHead
	mov	FormatPacket.FP_Head, AX
	mov	AX, FirstCylinder
	mov	FormatPacket.FP_Cylinder, AX

;M018 - begin
	mov	AX, word ptr TracksPerDisk
	mov	word ptr TracksLeft, AX
	mov	AX, word ptr TracksPerDisk+2
	mov	word ptr TracksLeft+2, AX
;M018 - end

	mov	Format_End,False		; flag not at end of format
	call	Calc_MAX_Tracks_To_Format	; Max track count for
						; FormatTrack call
FormatLoop:
	call	Format_Loop			; Format until CY occurs
	cmp	Format_End,True			; End of Format?
	jne	$$IF36
	mov	FormatError,0			; signal good format
	clc					; clear CY
	jmp	SHORT $$EN36			; bad format

$$IF36:
	call	CheckError			; determine type of error
	jc	$$IF38
	call	LastChanceToSaveIt		; acceptable error?
	jnc	$$IF39				; yes
	mov	FormatError,1			; signal error type
	clc					; clear CY
	jmp	SHORT $$EN39			; not acceptable error

$$IF39:
	call	SetStartSector			; start from scratch
	call	SetfBigFat
	push	AX
	call	Phase2Initialization
	clc
	pop	AX
	jmp	DiskFormat			; try again

$$EN39:
$$IF38:
$$EN36:
	return

FormatDone:
	mov	FormatError,0
	clc
	return

DiskFormat endp

;=========================================================================
; Fat_INIT:		 This routine initializes the Fat based	on the
;			 number	of paragraphs.
;
; input -  FatSpace
;	   FatSpace+2
;	   paras_per_Fat
;	   Fat_init_value
; output - Fat	space is initialized
;
; Assumes: nothing
;
;=========================================================================

Fat_Init PROC NEAR

	push	ds
	push	ES
	push	DI
	push	AX
	push	BX
	push	CX
	mov	ax,DATA
	mov	ds,ax

	les	di,FatSpace
	mov	BX,Paras_Per_Fat	; Get number of paras
	mov	AX,Fat_init_value
	push	DX
	mov	DX,ES			; Grab ES into DX

$$DO87:
	cmp	BX,0			; do while BX not = 0
	je	$$EN87			; exit if 0
	mov	CX,08h			; Word store of paragraph
	rep	stosw			; Move the data to Fat
	xor	DI,DI			; Offset always init to 0
	inc	DX			; Next paragraph
	mov	ES,DX			; Put next para in ES
	dec	BX			; Loop iteration counter
	jmp	SHORT $$DO87

$$EN87:
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	pop	DI
	pop	ES
	pop	ds
	ret

Fat_Init ENDP

;=========================================================================
;   SetDeviceParameters:
;	Set the	device parameters
;
;   Input:
;	Drive
;	DS:DX - pointer to device parameters
;=========================================================================

SetDeviceParameters proc near

	 mov	 CX, (EXTRAWIO shl 8) or SET_DEVICE_PARAMETERS
	 cmp	 IsEXTRAWIODrv,0
	 jne	 DoIoctl
	 mov	 CX, (RAWIO shl	8) or SET_DEVICE_PARAMETERS
DoIoctl:
	 mov	 AX, (IOCTL shl	8) or GENERIC_IOCTL
	 mov	 bl, DriveToFormat
	 inc	 bl
	 int	 21H
	 return

SetDeviceParameters endp


;=========================================================================
; Prompt_User_For_Disk		 : This	routine	prompts	the user for the
;				   disk	to be formatted.  An appropriate
;				   message is chosen based on the type
;				   of switch entered.  If the /SELECT
;				   switch is entered, the disk prompt is
;				   issued through the int 2fh services
;				   provided by SELECT.
;
;	 Inputs	 : SwitchMap	 - Switches chosen for format
;
;	 Outputs : Message printed as appropriate.
;=========================================================================

Procedure Prompt_User_For_Disk

	push	AX
	test	SwitchMap, (SWITCH_Backup or SWITCH_Select or SWITCH_AUTOTEST)
	jnz	$$IF186
ifdef NEC_98
	test	SwitchMap2,SWITCH2_P
	jnz	$$IF188
endif
	call    DskPrm				; prompt user for disk

$$IF186:
	 test	SwitchMap, (Switch_Select)	; /SELECT requested?
	 jz	$$IF188
	 mov	AL, DriveToFormat			; get drv to access for format
	 call	AccessDisk			; access the disk
	 mov	AX,Select_Disk_Message		; display disk prompt
	 int	2fh				; through int 2fh services

$$IF188:
	 pop	 AX
	 ret

Prompt_User_For_Disk	 ENDP

;==========================================================================
; DiskPrompt:
;
; This routine prompts for the insertion of the correct diskette
; into the Target Drive, UNLESS we are being re-entrantly invoked
; from LastChanceToSaveIt. If the target is a Hardisk we issue a
; warning message.
;
;	 INPUTS:
;		 DeviceParameters.DP_DeviceType
;		 fLastChance
;
;	 OUTPUTS:
;		 Prompt	string
;		 fLastChance	 := FALSE
;
;	 Registers affected:
;				 Flags
;
;==========================================================================

DskPrm PROC NEAR

	cmp	fLastChance,TRUE
	je	PrmptRet

	cmp	DeviceParameters.DP_DeviceType, DEV_HARDDISK
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	GoPrnIt

	; DblSpaced floppies return DEV_HARDDISK to the GetDeviceParameters
	; call.  If this is a DblSpaced drive, go make some additional checks
	; before putting out the hard disk warning.

	mov	al, DriveToFormat
	call	IsDblSpaceDisk		; sets Z flag if NOT dblspaced disk
	jnz	MaybeDblSpace

RealHardDisk:
        test    DeviceParameters.DP_DeviceAttributes, 1
    .errnz EDP_DEVICEATTRIBUTES NE DP_DEVICEATTRIBUTES
        jnz     non_rem
        Message msgDiskWarning
        jmp     short ask_yes
non_rem:
ifndef  OPKBLD
	Message	msgHardDiskWarning
endif   ;OPKBLD
ask_yes:
ifndef  OPKBLD
	call	Yes?

	pushf
	Message	msgCrlf
	popf
else
        clc
endif   ;OPKBLD

	jnc	OkToFormatHardDisk
	mov	ExitStatus, EXIT_NO
	jmp	ExitProgram

OkToFormatHardDisk:
	call	CrLf
	call	CrLf
	return

	; Got a DblSpaced drive--see if it's removable or not.

MaybeDblSpace:
	mov	AX, (IOCTL shl 8) or IOCTL_CHANGEABLE?
	mov	bl, DriveToFormat
	inc	bl
	int	21H
	jc	RealHardDisk		; should not happen, but if it does...

	or	ax, ax			; AX=0 if not removable--quietly exit
	jnz	PrmptRet		;   in this case, later checks will
					;   stop the format process
GoPrnIt:
	mov	AL, DriveToFormat
	call	AccessDisk
	Message msgInsertDisk
	Message ContinueMsg
	call	USER_STRING			; Wait for any key
	call	CrLf
	call	CrLf

PrmptRet:
	mov	fLastChance, FALSE
	ret

DskPrm	ENDP

;=========================================================================
;    CheckError:
;	 Input:
;	    AX - extended error	code
;	 Ouput:
;	    carry set if error is Fatal
;	    Message printed if Not Ready or Write Protect
;=========================================================================

CheckError proc near

	cmp	AX, error_write_protect
	je	WriteProtectError
	cmp	AX, error_not_ready
	je	NotReadyError
	cmp	CurrentCylinder, 0
	jne	CheckRealErrors
	cmp	CurrentHead, 0
	je	BadTrackZero

CheckRealErrors:
	cmp	AX, error_CRC
	je	JustABadTrack
	cmp	AX, error_sector_not_found
	je	JustABadTrack
	cmp	AX, error_write_fault
	je	JustABadTrack
	cmp	AX, error_read_fault
	je	JustABadTrack
	cmp	AX, error_gen_failure
	je	JustABadTrack

	stc
	ret

JustABadTrack:
	clc
	ret

WriteProtectError:
	test	SwitchMap,Switch_SELECT	; SELECT option?
	jnz	$$IF56				; no - display messages

	Message msgCrLf
	Message msgCrLf
	Extended_Message
	jmp	SHORT $$EN56			; yes - set error level

$$IF56:
	mov	ExitStatus,EXIT_WRIT_PROTECT	; signal write protect error

$$EN56:
	 stc					; signal Fatal error
	 ret					; return to caller

NotReadyError:
	test	SwitchMap,Switch_SELECT		; SELECT option?
	jnz	$$IF59				; no - display messages

	Message msgCrLf
	Message msgCrLf
	Extended_Message
	jmp	SHORT $$EN59			; yes - set error level

$$IF59:
	mov	ExitStatus,EXIT_DRV_NOT_READY	;signal Drive not ready

$$EN59:
	stc
	ret

BadTrackZero:
	Message msgDiskUnusable
	stc
	ret

CheckError endp

;=========================================================================
;
; Calc_MAX_Tracks_To_Format	 : This	routine	determines the maximum
;				   number of tracks to format at 1 time.
;
;	 Inputs	 : DeviceParameters - SectorsPerTrack
;				      BytesPerSector
;
;	 Outputs : Track_Count	    - MAX. # of	tracks to format in 1 call
;				      to FormatTrack
;=========================================================================

Procedure Calc_Max_Tracks_To_Format

	push	AX				; Save regs
	push	BX
	push	DX

	mov	AX,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack
	mov	BX,DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
    .errnz EDP_BPB NE DP_BPB
	xor	DX,DX
	mul	BX				; Get total byte count
	mov	BX,AX				; Put count in BX
	mov	ax, 1
	or	dx, dx
	jnz	cmttf_onetrack
	mov	AX,MAX_Format_Size		; Max bytes to format
	div	BX				; Get track count
cmttf_onetrack:
	mov	Track_Count,AX

	pop	DX
	pop	BX
	pop	AX

	ret

Calc_Max_Tracks_To_Format ENDP

;=========================================================================
; Format_Loop			 : This	routine	provides the main template
;				   for the formatting of a disk.  A disk
;				   will	be formatted as	long as	there are
;				   tracks remaining to be formatted.
;				   This	routine	can be exited on a carry
;				   condition; i.e., bad	track, last track, etc.
;
;	 Inputs	 : none
;
;	 Outputs : CY -	Set on exit from this routine
;		   AX -	Possible error condition code
;
;=========================================================================

Procedure Format_Loop

	clc					; Initialize to NC

$$DO173:					; While NC
	jc	$$EN173			   	; Exit on CY
	call	Calc_Current_Head_Cyl		; Head and cylinder calc.
	call	Determine_Format_Type		; Floppy/hard media?
	call	Determine_Track_Count		; How many tracks?
	call	FormatTrack			; Format track(s)
	jnc	$$IF175				; Formattrack failed

	pushf					; Save flags
	cmp	DeviceParameters.DP_DeviceType,Dev_HardDisk ; Harddisk?
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	$$IF176

	popf					; Restore flags
	call	Format_Track_Retry		; Find failing track
	jmp	SHORT $$EN176

$$IF176:
	popf					; Restore flags

$$EN176:
$$IF175:
	jnc	$$IF180				; Format error?
	pushf					; Yes - save flags
	push	AX				; Save return code
	call	CheckRealErrors 		; Check error type
	jc	$$IF181				; If non-Fatal
	call	DisplayCurrentTrack		; Display % formatted

$$IF181:
	pop	AX				; Restore regs
	popf

$$IF180:
	jc	$$EN173				; Exit on CY

	call	DisplayCurrentTrack		; Tell how much formatted
	call	Adj_Track_Count 		; Decrease track counter
	call	NextTrack			; Adjust head and cylinder
	jmp	SHORT $$DO173

$$EN173:
	ret

Format_Loop ENDP

;=========================================================================
; Calc_Current_Head_Cyl : Obtain the current head and cylinder	of the
;			   track being formatted.
;
;	 Inputs: FP_Cylinder	 - Cylinder of track being formatted
;		 FP_Head	 - Head	of track being formatted
;=========================================================================

Procedure Calc_Current_Head_Cyl

	push	CX				; save CX
	mov	CX,FormatPacket.FP_Cylinder	; get current cylinder
	mov	CurrentCylinder,CX		; put into variable
	mov	CX,FormatPacket.FP_Head		; get current head
	mov	CurrentHead,CX			; put into variable
	pop	CX				; restore CX
	ret

Calc_Current_Head_Cyl	 endp

; =========================================================================
; Determine_Format_Type :  This	routine	determines the type of format
;			   that	is to occur based on the media type.
;
;	 Inputs	  : Dev_HardDisk		 - Media type (harddisk)
;		    Multi_Track_Format	 - EQU 02h
;		    Single_Track_Format	 - EQU 00h
;
;	 Outputs  : FP_SpecialFunctions	 - Set appropriately for single
;					   or multi track format
; =========================================================================

Procedure Determine_Format_Type

	cmp	 DeviceParameters.DP_DeviceType,Dev_HardDisk	;harddisk?
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	 $$IF158
					; Set for multi track format
	mov	 FormatPacket.FP_SpecialFunctions,Multi_Track_Format
	jmp	 SHORT $$EN158

$$IF158:				; Set for single track format
	mov	 FormatPacket.FP_SpecialFunctions,Single_Track_Format

$$EN158:
	ret

Determine_Format_Type ENDP

;=========================================================================
;
; Determine_Track_Count	 : This	routine	determines the number of
;				   tracks to be	formatted, based on whether
;				   or not we have a hard disk.	If we have
;				   a hard disk we can use multi-track
;				   format/verify, otherwise we use the
;				   single track	format/verify.
;
;	 Inputs	 : Device_Type			 - Media type
;
;	 Outputs : Tracks_To_Format		 - MAX.	number of tracks
;						   to be formatted in one
;						   call
;=========================================================================

Procedure Determine_Track_Count

						; Harddisk?
	cmp	DeviceParameters.DP_DeviceType,Dev_HardDisk
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	$$IF163
	call	Calc_Track_Count		; Calc Tracks_To_Format
	jmp	SHORT $$EN163			; Removable media

$$IF163:
	mov	Tracks_To_Format,0001h		; Default to 1 track
$$EN163:

	ret

Determine_Track_Count ENDP

;=========================================================================
;
; Calc_Track_Count	 : This	routine	determines if we have enough tracks
;			   remaining to	use the	Max. number of tracks
;			   in the FormatTrack call.  If	the tracks remaining
;			   to be formatted is less that	the mAX. number	of
;			   allowable tracks for	the call, the mAX. number
;			   of allowable	tracks is set to the remaining track
;			   count.
;
;	 Inputs	 : Track_Count - MAX. number of	allowable tracks to be
;				 formatted in 1	FormatTrack call.
;		   TracksLeft  - Track count of	remaining tracks to be
;				 formatted.
;
;	 Outputs : Tracks_To_Format - Count of the tracks to be	formatted
;				      in the next FormatTrack call.
;
;=========================================================================

Procedure Calc_Track_Count

	push	AX				; Save regs

	mov	AX,Track_Count			; Max bytes to format

	cmp	word ptr TracksLeft+2,0		; M018; More than 64K of tracks?
	jnz	$$IF166				; M018; Then surely use Track_Count

	cmp	AX,word ptr TracksLeft		; M018; Too many tracks?
	JNA	$$IF166
	mov	AX,word ptr TracksLeft		; M018; Format remaining tracks

$$IF166:
	mov	Tracks_To_Format,AX		; Save track count
	pop	AX
	ret

Calc_Track_Count ENDP

;=========================================================================
; FormatTrack		 : This	routine	performs multi track or	single
;			   track formatting based on the state of the
;			   SpecialFunctions byte.
;
;	 Inputs	 : Tracks_To_Format	 - # of	tracks to format in 1 call
;		   FormatPacket		 - Parms for IOCTL call
;
;	 Outputs : NC			 - formatted track(s)
;		   CY			 - error in format
;		   AX			 - extended error on CY
;
;=========================================================================


Procedure FormatTrack

	mov	AX,(IOCTL shl 8) or Generic_IOCTL
	mov	BL,DriveToFormat			; Get Drive number
	inc	BL				; Make it 1 based

	mov	CX,(RawIO shl 8) 
	cmp	IsEXTRAWIODrv,0
	je	DoFrmt2
	mov	CX,(EXTRawIO shl 8)
DoFrmt2:
	or 	CL,Track_Action 		; Track_Action is either
						; Format and Verify, or
						; Verify only
	mov	DX,Tracks_To_Format		; Get track count
	mov	FormatPacket.FP_TrackCount,DX	; Put count in parms list
	lea	DX,FormatPacket 		; Ptr to parms
	int	21h

;;%out FORQUICK ENABLED!!!!!
;;	  clc	  ;;** ARR

	jnc	FormatTrackExit			; Error?
	mov	AH,59h				; Get extended error
	xor	BX,BX				; Clear BX
	int	21h

	cmp	AX,67				; Induced error from ENHDISK?
	jne	notInducedError
	clc
	ret
notInducedError:
	stc					; Flag an error

FormatTrackExit:
	ret

FormatTrack ENDP

;=========================================================================
;
; Format_Track_Retry	 : This	routine	performs the retry logic for
;			   the format multi-track.  It will retry each track
;			   until the failing track is encountered through
;			   a CY	condition.
;
;	 Inputs	 : none
;
;	 Outputs : CY -	indicates either a failing track or end	of format
;
;
;=========================================================================

Procedure Format_Track_Retry

	clc					; Clear existing CY
	mov	Tracks_To_Format,1		; Only format 1 track

$$DO168:					; While we have good tracks
	jc	$$EN168 			; Exit on bad track

	call	FormatTrack			; Format the track
	jc	$$IF170 			; Error?

	call	DisplayCurrentTrack		; Adjust percent counter
	call	Adj_Track_Count
	call	NextTrack			; Calc next track

$$IF170:
	jmp	SHORT $$DO168

$$EN168:
	ret

Format_Track_Retry ENDP

;=========================================================================
;
;  DisplayCurrentTrack :	This procedure prints the percentage of disk
;				formatted so far.
;				If /select is present, format can be exited
;				by returning AX!=0 from the int 2fh call, which
;				is handled by install.  This is to permit the
;				user to stop the format in progress.
;
;===========================================================================

DisplayCurrentTrack proc near

	push	DX
	push	CX
	push	AX

	push	DI		; M018
	push	SI		; M018

	mov	AX,Tracks_To_Format	 	;get track count

	add	Formatted_Tracks_Low,AX		;Indicate formatted a track
	adc	Formatted_Tracks_High,0
	mov	AX,Formatted_Tracks_Low
	mov	BX,Formatted_Tracks_High
	mov	CX,100				;Make integer calc for	div
	call	Multiply_32_Bits		; BX:AX = (Cyl	* Head *100)
	mov	DX,BX				;Set up divide

    ; DX:AX: 100*head*cylinder (should not be bigger than a DWORD)
    ; DI:SI: heads*cylinder
    ; We need to assure a word division

	mov 	DI,word ptr TracksPerDisk+2
	mov	SI,word ptr TracksPerDisk
SetUpDivide:
	or	DI,DI
	jz	DivideOK
	shr	DI,1				; shift DI:SI 1 bit right
	rcr	SI,1
	shr	DX,1				; shift DX:AX 1	bit right
	rcr	AX,1
	jmp	short SetUpDivide
DivideOk:
	div	SI	

	cmp	AX,PercentComplete		;Only print message when change
	je	ScreenUpdateDone

		; johnhe 02-27-90
		; Change added here for DOS 5.0 install program to do a
		; special interrupt to display the percent complete on
		; a gage. AX == special code, BX == percent complete

	test	SwitchMap,Switch_Select		; Was format spawned by the
	jz	NormalDisplay			; install program?
	mov	BX,AX				; BX == percent completed
	mov	AX,GAGE_UPDATE			; AX == special function code
	clc
	int	2fh				; Multiplex interrupt
	or	AX,AX				; AX <> 0 --> user wants to exit
	jz	ScreenUpdateDone
	jmp	FatalExit

	; End of code added for DOS 5.0 install program

NormalDisplay:
	mov	PercentComplete,AX		; Save it if changed
	Message msgCurrentTrack

ScreenUpdateDone:
	pop	SI				; M018
	pop	DI				; M018
	
	pop	AX
	pop	CX				; Restore register
	pop	DX
	return

DisplayCurrentTrack endp

;=========================================================================
; Adj_Track_Count	 : This	routine	adjusts	the track count	by the
;			   number of tracks that have been formatted
;			   in one FormatTrack call.
;
;	 Inputs	 : TracksLeft	 - # of	tracks remaining to be formatted
;		   Tracks_To_Format - Tracks formatted in 1 call
;
;	 Outputs : TracksLeft	 - # of	tracks remaining to be formatted
;=========================================================================

Procedure Adj_Track_Count

	push	AX			; save regs
	push	DX			; M018

	mov	DX,word ptr TracksLeft+2; get tracks remaining
	mov	AX,word ptr TracksLeft

	sub	AX,Tracks_To_Format	; subtract amount formatted
	sbb	DX,0

	mov	word ptr TracksLeft,AX	; save new tracks remaining value
	mov	word ptr TracksLeft+2,DX
	
	pop	DX			; M018
	pop	AX			; restore regs
	ret

Adj_Track_Count endp

;=========================================================================
;
; NextTrack	 : This	routine	determines the next track to be
;		   formatted.
;
;	 Inputs	 : TracksLeft		 - # of	tracks remaining
;		   Tracks_To_Format	 - # of	tracks to format in 1 call
;		   FP_Head		 - disk	head
;		   FP_Cylinder		 - disk	cylinder
;
;	 Outputs : TracksLeft		 - # of	tracks remaining
;		   FP_Head		 - disk	head
;		   FP_Cylinder		 - disk	cylinder
;		   CY			 - no tracks left to format
;		   NC			 - tracks left to format
;
;=========================================================================

Procedure NextTrack


	mov	CX,word ptr TracksLeft+2
	or	CX,Word ptr TracksLeft
	jne	$$IF149 			; Yes

	stc					; Signal end of format
	mov	Format_End,True
	jmp	SHORT $$EN149

$$IF149:
	mov	CX,Tracks_To_Format		; Get mAX track count for call

$$DO151:					; While tracks remain
	cmp	CX,00				; End of head/cyl. adjustment?
	je	$$EN151 			; Yes

	inc	FormatPacket.FP_Head		; Next head
	mov	AX,FormatPacket.FP_Head 	; Get head for comp
	cmp	AX,DeviceParameters.DP_BPB.oldBPB.BPB_Heads ; Exceeded head count?
    .errnz EDP_BPB NE DP_BPB
	jne	$$IF154 			; Yes

	mov	FormatPacket.FP_Head,00 	; Reinit. head
	inc	FormatPacket.FP_Cylinder	; Next cylinder

$$IF154:
	dec	CX				; Decrease counter
	jmp	SHORT $$DO151

$$EN151:
	clc					; Clear CY

$$EN149:
	ret

NextTrack ENDP

;=========================================================================
;	CurrentLogicalSector:
;	 Get the current logical sector	number
;
;    Input:
;	 current track = TracksPerDisk - TracksLeft
;	 SectorsPerTrack
;
;    Output:
;	 BX = logical sector number of the first sector	in the track we
;	      just tried to format
;=========================================================================

CurrentLogicalSector PROC NEAR

	push	AX				; Save regs
	push	BX
	push	DX
.386
	mov	EAX, TracksPerDisk
	sub	EAX, TracksLeft
	movzx	ebx, DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack
    .errnz EDP_BPB NE DP_BPB
	mul	ebx
	mov	dword ptr Relative_Sector_Low,EAX  ; Save sector #
.8086
	pop	DX				; Restore regs
	pop	BX
	pop	AX

	return

CurrentLogicalSector ENDP

;=========================================================================
;
;    BadSector:
;	 Reports the bad Sectors.
;	 Reports the track where DiskFormat stopped.
;	 From then on it formats until it reaches a bad	track, or end,
;	 and reports that.
;
;    Output:
;	 Carry:	set -->	Fatal error
;	 if Carry not set
;	    AX - The number of consecutive bad Sectors encountered
;		 AX == 0 --> no	More bad Sectors
;	    BX - The logical sector number of the first	bad sector
;
;    Algorithm:
;	 if DiskFormatErrors
;	    DiskFormatErrors = false
;	    return current track
;	 else
;	    next track
;	    while not done
;	       if format track fails
;		  return current track
;	       next track
;	    return 0
;=========================================================================

BadSector proc	 near
						; Don't bother to do the format
						; /c was given
	test	FormatError, 0ffH
	jz	ContinueFormat

	mov	FormatError, 0
	jmp	SHORT ReportBadTrack

ContinueFormat:
	call	Adj_Track_Count 		; Decrease track counter
	call	NextTrack			; Adjust head and cylinder
	cmp	Format_End,True 		; End of format?
	je	$$IF44				; No

	call	Format_Loop			; Format until CY
	cmp	Format_End,True 		; End of format?
	je	$$IF45				; No

	call	CheckError			; Must be error - which error?
	jc	$$IF46				; Non-Fatal error?

	call	CurrentLogicalSector		; Yes - get position
						; set tracksize
	mov	AX,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack
    .errnz EDP_BPB NE DP_BPB
	clc					; Signal O.K. to continue

$$IF46:
	jmp	SHORT $$EN45
$$IF45:
	jmp	SHORT NoMoreTracks		  ;End of format
$$EN45:
	jmp	SHORT $$EN44
$$IF44:
	jmp	SHORT NoMoreTracks		; end of format
$$EN44:
	return

ReportBadTrack:
	call	CurrentLogicalSector
	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack
	clc
	return

NoMoreTracks:					; Don't display done msg
	test	SwitchMap,(Switch_Select or SWITCH_AUTOtest)
	jnz	$$IF52				; if EXEC'd by SELECT
	Message msgFormatComplete

$$IF52:
	mov	AX, 0
	clc
	return

BadSector endp

;=========================================================================
; Get_Bad_Sector_Hard	 : Determine the bad sector.
;
;	 Inputs	 :
;		Head of failing track
;		Cylinder of failing track
;		Relative_Sector_Low	- 1st. sector in track
;		Relative_Sector_High
;
;		ClustBound_Adj_Factor	- The number of Sectors
;					  that	are to be read
;					  at one time.
;		ClustBound_SPT_Count	- Used by Calc_Cluster_Boundary
;					  to track how	many Sectors
;					  have been read.
;		ClustBound_Flag	 	- True (Use cluster buffer)
;					- False (Use internal buffer)
;		ClustBound_Buffer_Seg	- Segment of buffer
;
;	 Outputs : Marked cluster as bad
;=========================================================================

Procedure Get_Bad_Sector_Hard

	push	CX				; Save CX
	mov	CX,0001h			; Set counter to start at 1
	mov	ClustBound_SPT_Count,00h	; Clear sector counter
	mov	ClustBound_Adj_Factor,01h	; Default value

						; DO WHILE Sectors left
$$DO115:					
	cmp	CX,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack  ;At end?
    .errnz EDP_BPB NE DP_BPB
	ja	$$EN115 			; Yes,exit
	push	CX				; Save CX

	cmp	ClustBound_Flag,True		; Full buffer there?
	jne	$$IF117 			; Yes
	call	Calc_ClustBound_		; See if on boundary
	mov	AX,ClustBound_Buffer_Seg
						; Point to transfer area
	mov	WORD PTR RWPacket.TRWP_Transferaddress[0],0
	mov	WORD PTR RWPacket.TRWP_Transferaddress[2],AX
	jmp	SHORT $$EN117			; Default to  internal buffer

$$IF117:					; Point to transfer area
	mov	WORD PTR RWPacket.TRWP_Transferaddress[0],offset RW_TRF_Area
	mov	WORD PTR RWPacket.TRWP_Transferaddress[2],DS

$$EN117:
	call	Verify_Structure_Set_Up 	; Set up verify vars
	mov	AX,(IOCTL shl 8) or GENERIC_IOCTL
	xor	BX,BX				; Clear BX
	mov	BL,DriveToFormat			; Get Drive
	inc	BL				; Adjust it

	mov	CX,(IOC_DC shl	8) or READ_TRACK
	cmp	IsEXTRAWIODrv,0
	je	DoIOCTL2
	mov	CX,(IOC_EDC shl  8) or READ_TRACK
    ; Buffer is only cluster size
DoIOCTL2:
	lea	DX,RWPacket			; Point to parms
	int	21h

	pop	CX				; Restore CX
	push	CX				; Save CX

	jnc	$$IF120 			; An error occurred
	call	Calc_Cluster_Position		; Determine which cluster
	call	BadClus 			; Mark the cluster as bad

$$IF120:
	pop	CX
	add	CX,ClustBound_Adj_Factor	; Adjust loop counter
	mov	AX,ClustBound_Adj_Factor	; Get adjustment factor
	xor	DX,DX
	add	AX,Relative_Sector_Low		; Add in low word
	adc	DX,Relative_Sector_High 	; Pick up carry in high word
	mov	Relative_Sector_Low,AX		; Save low word
	mov	Relative_Sector_High,DX 	; Save high word
	jmp	SHORT $$DO115

$$EN115:
	pop	CX
	ret

Get_Bad_Sector_Hard ENDP

;=========================================================================
; Get_Bad_Sector_Floppy : This	routine	marks an entire	track as bad
;			   since it is a floppy	disk.
;
;	 Inputs	 : Relative_Sector_Low	 - first sector
;
;	 Outputs : Fat marked with bad Sectors
;=========================================================================

Procedure Get_Bad_Sector_Floppy

	push	BX				; Save regs
	push	CX
						; Get Sectors/track
	mov	CX,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack
    .errnz EDP_BPB NE DP_BPB

$$DO123:					; While Sectors left
	cmp	CX,00				; At end
	je	$$EN123 			; Yes

	push	BX				; Save BX we destroy it
	push	CX				; Save CX we destroy it
	call	Calc_Cluster_Position		; Get cluster position
	call	BadClus 			; Mark it as bad
	pop	CX				; Restore regs
	pop	BX
	dec	CX				; Decrease loop counter
.386
	inc	dword ptr Relative_Sector_Low	; Next sector
.8086
	jmp	SHORT $$DO123

$$EN123:
	pop	CX				; Restore regs
	pop	BX
	ret

Get_Bad_Sector_Floppy ENDP

;=========================================================================
;
;   Inputs:	DX:AX - Cluster number
;   Outputs:	The given cluster is marked as	invalid
;		Zero flag is set if the cluster was already marked bad
;
;   Registers modified: DX
;			SI
;
; BADCLUS	 :	 Marks off a bad cluster in the	Fat
;			 If a cluster has already been marked bad it
;			 will return with ZR.
;
;	 Inputs	 :	 DX:AX - Cluster Number
;
;	 Outputs :	 Cluster is marked invalid
;			 ZR set	if cluster already marked bad
;
;=========================================================================

BadClus	 proc		 near		; mark bad clusters

	push	DI			; save affected regs
	push	AX
	push	BX
	push	CX
	push	DX
	push	ES

	cmp	FATNotAllInMem,0
	je	DoBadInMem
	push	dx			; Save cluster number
	push	ax
	call	AllocInitBadClusBitmap	; Does nothing if BadClusBitmap
					;   already exists
.386
;; Manual assemble to prevent compile warning
;;	  pop	  eax				; recover cluster #
	db	066h,058h
;;
	jc	$$EN10
	push	ds
	push	si
	lds	si,BadClusBitMap
	mov	ebx,eax
	shr	ebx,19			; (E)BX is "64k index" of this bit
	and	eax,00007FFFFh		; bit index in that 64k
	mov	cx,ds
	add	cx,bx			; Go to correct 64k piece
	mov	ds,cx
	bts	dword ptr [si],eax	; Set the bit
	pop	si
	pop	ds
	jnc	short ClrZr
	xor	ax,ax			; Set zero flag, cluster already marked
	jmp	$$EN10

ClrZr:
	inc	eax			; Clear the zero flag
.8086
	jmp	$$EN10

DoBadInMem:
	mov	ES, WORD PTR FatSpace + 2 ; obtain seg of Fat

	cmp	fBig32Fat,TRUE		; 32 bit Fat?
	je	$$IF8a			; yes
	cmp	fBigFat,TRUE		; 16 bit Fat?
	je	$$IF8			; yes

    ; 12-bit FAT

	mov	CX,2			; divide by 2

	push	AX			; saves low cluster number
	mov	SI,DX			; pick up high word of cluster
	mov	DI,AX			; pick up low word of cluster
	call	divide_32_Bits		; 32 bit divide

	add	AX,DI			; add in low word of result
	adc	DX,SI			; pick up low word carry
					; cluster = cluster * 1.5
	add	AX,WORD PTR FatSpace	; add 0
	adc	DX,0			; pick up carry

	mov	BX,DX			; get high word for adjust
	mov	CX,ES			; place seg in AX
	call	BadClus_address_Adjust	; adjust segment offset
	mov	ES,CX			; new segment
	mov	SI,AX			; new offset

	mov	DX,0ff7h		; bad cluster flag
	mov	AX,0fffh		; mask value

	pop	CX			; restore AX in CX - low cluster #
	test	CX,1			; is old clus num odd?
	jz	$$IF9			; yes
.386
	shl	AX,4			; get only 12 bits - fff0
	shl	DX,4			; get 12 bits - ff70
.8086
$$IF9:
	jmp	SHORT $$EN8

$$IF8a:
    ; 32-bit FAT
	xor	SI,SI			; clear si
	mov	BX,DX			; get high word for multiply
	mov	CX,4			; multiply by 4
	call	Multiply_32_Bits	; 32 bit multiply due to 4 bytes per
					; Fat cell. This gives us an offset
					; into the FAT
	mov	CX,ES			; place seg in CX
	call	BadClus_Address_Adjust	; adjust segment:offset
	mov	ES,CX			; new segment
	mov	SI,AX			; new offset
.386
	mov	ecx,dword ptr ES:[SI]	; Get previous value
	and	ecx,00FFFFFFFh		; Discard high 4 bits
	mov	edx,00ffffff7h
	mov	dword ptr ES:[SI],edx	; flag it a bad cluster
	cmp	EDX,ECX 		; return op == badval;
.8086
	jmp	short $$EN10

$$IF8:
    ; 16-bit FAT
	xor	SI,SI			; clear si
	mov	BX,DX			; get high word for multiply
	mov	CX,2			; multiply by 2
	call	Multiply_32_Bits	; 32 bit multiply due to 2 bytes per
					; Fat cell. This gives us an offset
					; into the FAT

	mov	CX,ES			; place seg in CX
	call	BadClus_Address_Adjust	; adjust segment:offset
	mov	ES,CX			; new segment
	mov	SI,AX			; new offset

	mov	DX,0fff7h		; bad cluster value
	mov	AX,0ffffh		; mask value

$$EN8:
	mov	CX,ES:[SI]		; get contents of Fat cell
	and	CX,AX			; make it 12 or 16 bit
					; depending on value in AX
	not	AX			; set AX to 0

	and	ES:[SI],AX		; clear Fat entry

	or	ES:[SI],DX		; flag it a bad cluster
	cmp	DX,CX			; return op == badval;
$$EN10:
	pop	ES
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	pop	DI
	return

badclus	endp

;=========================================================================
; Verify_Structure_Set_Up	 : Set up the fields for the Read IOCTL
;				   to verify the Sectors in a failing
;				   track.  Also, it displays the
;				   message notifying the user of the
;				   Sectors it is verifying.
;=========================================================================

Procedure	 Verify_Structure_Set_Up		; Set up verify structure

	mov	RWPacket.TRWP_SpecialFunctions,00h	; Reset special functions

	mov	AX,FormatPacket.FP_Head 		; Get current head
	mov	RWPacket.TRWP_Head,AX			; Get current head

	mov	AX,FormatPacket.FP_Cylinder		; Get current cylinder
	mov	RWPacket.TRWP_Cylinder,AX		; Get current cylinder

	dec	CX					; Make sector 0 based
	mov	RWPacket.TRWP_FirstSector,CX		; Get sector	to read

	mov	AX,ClustBound_Adj_Factor		; Get # of Sectors to read
	mov	RWPacket.TRWP_SectorsToReadWrite,AX	; Read only # sector(s)

	call	Calc_Cluster_Position			; Determine cluster number
	mov	WORD PTR Msg_Allocation_Unit_Val[+2],DX ; Save high word of cluster
	mov	WORD PTR Msg_Allocation_Unit_Val[+0],AX ; Save low word of cluster
	message msgVerify

	ret

Verify_Structure_Set_Up ENDP

;=========================================================================
; Calc_Cluster_Position : This	routine	calculates which cluster the
;			   failing sector falls	in.
;
;	 Inputs	 : Relative_Sector_High	 - high	word of	sector position
;		   Relative_Sector_Low	 - low word of sector position
;
;	 Outputs : DX:AX - Cluster number
;=========================================================================

Procedure Calc_Cluster_Position

	push	CX				; Save regs
	push	DI
	push	SI

	mov	DX,WORD PTR Relative_Sector_High ; Get the high sector word
	mov	AX,WORD PTR Relative_Sector_Low  ; Get the low sector word
	sub	AX,word ptr StartSector 	; Get relative sector #
	sbb	DX,word ptr StartSector+2	; Pick up borrow

	mov	SI,DX				; Get high word
	mov	DI,AX				; Get low word
	xor	CX,CX				; Clear CX
						; Get Sectors/cluster
	mov	CL,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
    .errnz EDP_BPB NE DP_BPB
	call	divide_32_Bits			; 32 bit division

	mov	DX,SI				; Get high word of result
	mov	AX,DI				; Get low word of result
	add	AX,2				; Adjust for cluster bias
	adc	DX,0				; Pick up carry

	pop	SI				; Restore regs
	pop	DI
	pop	CX
	ret

Calc_Cluster_Position ENDP

;=========================================================================
; Calc_ClustBound_ : This routine will determine where, within a
;			   cluster, a sector resides.
;
;	 Inputs	 : Relative_Sector_Low		- Sector
;		   Relative_Sector_High
;
;	 Outputs : ClustBound_Adj_Factor	- The number of Sectors
;						   remaining in	the cluster.
;		   ClustBound_SPT_Count	 	- The count of	Sectors
;						  having been accessed	for
;						  a track.
;=========================================================================

Procedure Calc_ClustBound_

	push	AX				; Save regs
	push	BX
	push	CX
	push	DX
	push	SI
	push	DI

	xor	DX,DX				; Clear high word
	mov	DX,WORD PTR Relative_Sector_High
	mov	AX,WORD PTR Relative_Sector_Low
	sub	AX,word ptr StartSector 	; Get relative sector #
	sbb	DX,word ptr StartSector+2	; Pick up borrow

	mov	SI,DX				; Get high word
	mov	DI,AX				; Get low word
	xor	CX,CX				; Clear CX
	mov	CL,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
    .errnz EDP_BPB NE DP_BPB
	call	divide_32_Bits			; 32 bit division

	or	CX,CX				; See if remainder exists
	jz	$$IF132 			; Remainder exists

	xor	BX,BX
	mov	BL,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
	sub	BX,CX
	mov	ClustBound_Adj_Factor,BX	; Remainder = sector count
	jmp	SHORT $$EN132			; Noremainder

$$IF132:
	xor	BX,BX				; Clear BX
	mov	BL,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
	mov	ClustBound_Adj_Factor,BX

$$EN132:

	mov	AX,ClustBound_SPT_Count 	; Get current sector count
	xor	DX,DX				; Clear high word
	add	AX,ClustBound_Adj_Factor	; Get next sector count
						; Exceeded Sectors/track?
	cmp	AX,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack
	jna	$$IF135 			; Yes
						; only use difference
	mov	AX,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack
	sub	AX,ClustBound_SPT_Count 	; Get next sector count
	mov	ClustBound_Adj_Factor,AX

$$IF135:
	mov	AX,ClustBound_SPT_Count 	; Get sector count
	xor	DX,DX				; Clear high word
	add	AX,ClustBound_Adj_Factor	; Get new sector count
	mov	ClustBound_SPT_Count,AX 	; Save it

	pop	DI				; Restore regs
	pop	SI
	pop	DX
	pop	CX
	pop	BX
	pop	AX

	ret

Calc_ClustBound_ ENDP

;=========================================================================
;
; BadClus_address_Adjust	 - This	routine	adjusts	the segment and
;				   offset to provide addressibility into
;				   the Fat table.
;
;	 Inputs	 : BX	 - high	word to	adjust segment for
;		   AX	 - low word to adjust segment for
;		   CX	 - segment to be adjusted
;
;	 Outputs : CX	 - new segment value
;		   AX	 - new offset value
;
;=========================================================================

Procedure BadClus_address_Adjust

	push	BX				; Save regs
	push	DX
	push	DI
	push	SI

	mov	DX,CX				; Save segment value
	mov	SI,BX				; Get high word for divide
	mov	DI,AX				; Get low word for divide
	xor	CX,CX				; Clear CX
	mov	CL,Paragraph_Size		; Divide by 16
	call	divide_32_Bits			; Perform division

	add	DX,DI				; Adjust segment for result
	mov	AX,CX				; Pick up the remainder
	mov	CX,DX				; Pass back new segment

	pop	SI				; Restore regs
	pop	DI
	pop	DX
	pop	BX

	ret

BadClus_address_Adjust ENDP

;=========================================================================
;Routine name:	Multiply_32_Bits
;=========================================================================
;Description: A real sleazy 32	bit x 16 bit multiply routine. Works by	adding
;	       the 32 bit number to itself for each power of 2 contained in the
;	       16 bit number. Whenever a bit that is set in the	multiplier (CX)
;	       gets shifted to the bit 0 spot, it means	that that amount has
;	       been multiplied so far, and it should be	added into the total
;	       value. Take the example CX = 12 (1100). Using the associative
;	       rule, this is the same as CX = 8+4 (1000	+ 0100). The
;	       multiply	is done	on this	principle - whenever a bit that	is set
;	       is shifted down to the bit 0 location, the value	in BX:AX is
;	       added to	the running total in DI:SI. The	multiply is continued
;	       until CX	= 0. The routine will exit with	CY set if overflow
;	       occurs.
;
;
;Called Procedures: None
;
;Change History: Created	 7/23/87	 MT
;
;Input: BX:AX = 32 bit	number to be multiplied
;	 CX = 16 bit number to be multiplied. (Must be even number)
;
;Output: BX:AX	= output.
;	  CY set if overflow
;
;=========================================================================

Multiply_32_Bits PROC

.386
	push	ax
	mov	ax,bx
	shl	eax,16
	pop	ax
	movzx	ecx,cx
	mul	ecx
	mov	ebx,eax
	shr	ebx,16
	or	edx,edx 		; Overflow?
	jz	short OkRet		; No, carry clear
	stc
OkRet:
.8086
	ret

Multiply_32_Bits endp

;=========================================================================
; divide_32_Bits	 - This	routine	will perform 32bit division
;			   It works by first dividing the high word
;			   and leaving the remainder in DX and then
;			   dividing the low word with the remainder
;			   still in DX
;
;	 Inputs	 : SI:DI - value to be divided
;		   CX	 - divisor
;
;	 Outputs : SI:DI - result
;		   CX	 - remainder
;=========================================================================

Procedure divide_32_Bits

	push	AX			; Save regs
	push	BX
	push	DX


	xor	DX,DX			; clear DX
	mov	AX,SI			; get high word
	div	CX			; get high word result
	mov	SI,AX			; save high word result


	mov	AX,DI			; get low word
	div	CX			; get low word result
	mov	DI,AX			; save low word result
	mov	CX,DX			; pick up remainder

	pop	DX			; restore regs
	pop	BX
	pop	AX

	ret

divide_32_Bits	 endp


;=========================================================================
;
;  QuickFormat :	This procedure will perform a Quick format by
;			simply copying any bad cluster markers from the 
;			old FAT on the disk to the new FAT.  The old FAT is
;			read in one sector at a time using FatSector buffer.
;			The new FAT is held in FatSpace buffer.
;
;  Registers Destroyed : SI,AX,BX,CX
;
;  Assumes:	DS:DATA,ES:Nothing
;
;=========================================================================

QuickFormat	proc	near

	mov	SI,DATA
	mov	ES,SI				; Set ES to data segment

	assume	ES:DATA,DS:Nothing		; Assembler directive

						; Set device parameters here
	mov	ES:DeviceParameters.DP_SpecialFunctions,(INSTALL_FAKE_BPB or TRACKLAYOUT_IS_GOOD)
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS
	lea	DX,ES:DeviceParameters
	call	SetDeviceParameters

.386
	mov	ES:sector_in_buffer,0ffffffffh	; force first read to ensure
						; buffer validity

	test	ES:fBig32FAT,0ffh		; See if 32 bit fat
	jz	short Test16BitEntry		; If zero then 16 or 12 bit fat
	mov	EBX,00ffffff7h			; Set 32 bit value for bad cluster
	jmp	SHORT InitClusCount

Test16BitEntry:
	test 	ES:fBigFAT,0ffh			; See if 16 bit fat
	jz	short Set12BitEntry		; If zero then 12 bit fat
	mov	EBX,0000fff7h			; Set 16 bit value for bad cluster
	jmp	SHORT InitClusCount

Set12BitEntry:
	mov	EBX,00000ff7h			; Set 12 bit value for bad cluster

InitClusCount:
	mov	ES:CurrentCluster,2		; M015; No need to do the first 2
	mov	ES:BadClusValue,EBX

	cmp	es:FATNotAllInMem,0
	je	short QuickLoop
	push	ds
	push	es
	pop	ds

	message msgSetBadClus

	pop	ds
QuickLoop:
	mov	EAX,ES:CurrentCluster
	call	calc_sector_and_offset		; determine location of this entry

	mov	EBX,ES:sector_in_buffer
	mov	EAX,ES:sector_to_read
	cmp	EAX,EBX 			; check if required sector is in buffer
	je	short DontHaveToRead
	cmp	es:FATNotAllInMem,0
	je	short DoRead
	push	ds
	push	es
	pop	ds

	call	DisplayFatDonePcnt

	pop	ds
DoRead:
	call	ReadFatSector			; read a sector of the FAT into buffer
	jc	ExitQuickFormatCRLFErr		; check for error

DontHaveToRead:
	mov	EAX,ES:CurrentCluster		; EAX = current cluster
	xor	CX,CX				; ECX = get cluster contents signal
	lds	SI,ES:FatSector			; DS:SI --> FAT buffer
	call	GetFatSectorEntry		; EAX = contents of FAT entry

	mov	EBX,ES:BadClusValue		; Restore bad cluster value
	cmp	EAX,EBX 			; Is this cluster marked bad?
	jne	short NextCluster		; If EAX<>EBX good cluster
MarkInFormatBuffer:
	cmp	es:FATNotAllInMem,0
	je	short DoBadInMem2
	push	es
	pop	ds
	call	AllocInitBadClusBitmap		; Does nothing if BadClusBitmap
						;   already exists
	jc	short ExitQuickFormatCRLFErr	; check for error
	mov	EAX,ES:CurrentCluster		; EAX = current cluster
	lds	si,es:BadClusBitMap
	mov	ebx,eax
	shr	ebx,19				; (E)BX is "64k index" of this bit
	and	eax,00007FFFFh			; bit index in that 64k
	mov	cx,ds
	add	cx,bx				; Go to correct 64k piece
	mov	ds,cx
	bts	dword ptr [si],eax		; Set the bit
	jmp	short NextCluster

DoBadInMem2:
	mov	ECX,EBX 			; ECX = value to set in FAT buffer
	mov	EAX,ES:CurrentCluster		; EAX = this cluster number
	lds	SI,ES:FatSpace			; DS:SI --> Format's FAT buffer
	call	GetSetFatEntry	       	   	; Set the cluster in Format's buffer
	
NextCluster:
	inc	ES:CurrentCluster		; go to next cluster

	mov	EAX,ES:CurrentCluster
	mov	EBX,ES:TotalClusters
	cmp	EAX,EBX 			; check for last cluster in FAT
	jna	QuickLoop
.8086
	mov	BX,DATA	
	mov	DS,BX				; restore DS to DATA segment

	assume	DS:DATA,ES:DATA			; Assembler directive

	cmp	ds:FATNotAllInMem,0
	je	ExitQuickFormatRet		; Carry clear if jmp

	message msgSetBadClusDone

	clc
ExitQuickFormatRet:
	ret

ExitQuickFormatCRLFErr:
	mov	BX,DATA	
	mov	DS,BX
	cmp	ds:FATNotAllInMem,0
	stc
	je	ExitQuickFormatRet

	Message msgCrLf

	stc
	jmp	short ExitQuickFormatRet

QuickFormat	endp

;===========================================================================
;
; calc_sector_and_offset :	This procedure computes the logical sector
;				number the given FAT entry is in, and its
;				offset from the start of the sector.
;
;  Inputs :	EAX = entry number
;		fBigFat = flag for 12- or 16-bit FAT entries
;		Number of reserved sectors
;
;  Output :	sector_to_read = logical disk sector holding FAT entry
;		entry_offset   = offset from start of sector
;		odd_entry      = flag for 12-bit entry alignment (1=odd,0=even)
;
;  Registers Destroyed : AX,BX,CX,DX 
;
;  Strategy :	This procedure assumes the sector size is 512 bytes.
;		The byte offset from the start of the FAT is first
;		calculated.  This is then divided by 512, so that
;			required sector = quotient
;			offset	        = remainder
;		The logical sector number is obtained by adding on the
;		number of reserved sectors.
;
; M017: The code does not assume 512 BytesPerSector (it is even simpler!)
;============================================================================

calc_sector_and_offset	proc	near

	assume	DS:NOTHING,ES:DATA
.386
	xor	EDX,EDX
	test	ES:fBig32Fat,0ffh	; See if 32 bit FAT
	jz	short TestOffset16	; If not do 16 or 12 bit FAT
	shl	EAX,1			; EAX *= 2
	rcl	EDX,1
	jmp	short FindOffset16	; Now mult by 2 again for * 4

TestOffset16:
	test	ES:fBigFat,0ffh		; See if 16 bit FAT
	jz	short FindOffset12	; If not do 12 bit FAT
FindOffset16:
	shl	EAX,1			; EAX *= 2
	rcl	EDX,1
					; Now offset from start of FAT is
					; in EDX:EAX
	jmp	SHORT	FindSector

FindOffset12:
	mov	BX,AX			; BX = cluster number
	shl	AX,1
	add	AX,BX			; AX *= 3

	mov	ES:odd_entry,AL 	; lsb of AX determines even or odd
	and	ES:odd_entry,1

	shr	AX,1			; Divide by 2
					; Now offset from start of FAT is
					; in EDX:EAX

FindSector:
	movzx	ebx,ES:DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
    .errnz EDP_BPB NE DP_BPB
	div	ebx
	mov	ES:entry_offset,DX
	movzx	ebx,ES:DeviceParameters.DP_BPB.oldBPB.BPB_RESERVEDSECTORS
	add	EAX,ebx
	mov	ES:sector_to_read,EAX
.8086
	ret

calc_sector_and_offset	endp

;===========================================================================
;
; ReadFatSector :	This procedure will read in a sector of the FAT
;			into the FatSector buffer.  This is done by loading
;			the required parameters and calling ReadWriteSectors.
;
; Input :	sector_to_read
; Output:	loaded buffer
;		sector_in_buffer
;
; Registers destroyed: AX,BX,CX,DX
;
;===========================================================================

ReadFatSector	proc	near

	assume	DS:NOTHING,ES:DATA
	
	push	DS			; Preserve DS

.386
	mov	EDX,ES:sector_to_read	; EDX = starting sector
;; Manual assemble to prevent compile warning
;;	  push	  edx
	db	066h,052h
;;
	cmp	ES:DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFAT,0
    .errnz EDP_BPB NE DP_BPB
	je	short NotBigFAT1
	mov	cx,ES:DeviceParameters.DP_BPB.BGBPB_ExtFlags
	test	cx,BGBPB_F_NoFATMirror
	jz	short NotBigFAT1
	and	ecx,NOT BGBPB_F_ActiveFATMsk
	jz	short NotBigFAT1
	mov	ebx,edx
	mov	eax,dword ptr ES:DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
	mul	ecx
	add	eax,ebx
	mov	edx,eax
NotBigFAT1:
	mov	ebx,edx
	shr	ebx,16
	mov	ES:Read_Write_Relative.Start_Sector_High,bx
	mov	AL,ES:DriveToFormat	; AL = DOS drive number
	mov	CX,1			; 1 sector only
	lds	BX,ES:FatSector		; DS:BX --> read buffer
 
	call	Read_Disk		; perform read

;; Manual assemble to prevent compile warning
;;	  pop	  edx
	db	066h,05Ah
;;
	mov	ES:sector_in_buffer,EDX ; update sector in memory
.8086
	pop	DS			; Restore DS

	ret

ReadFatSector	endp

;=========================================================================
; WriteFatSector :	 This routine writes the logical sector count requested.
;			 of the FAT
;
;	 Inputs	 :	 AL - Drive letter
;			 DS:BX - Segment:offset	of transfer address
;			 ECX - Sector count
;			 EDX - 1st. sector
;			 ES -> Data
;
;	 Outputs :	 Logical Sectors written
;=========================================================================

procedure WriteFatSector
    assume  DS:NOTHING,ES:DATA
.386
$$DO67:
	or	ECX,ECX 			; any Sectors?
	jz	short $$EN67			; no
ifdef NEC_98
	cmp	ECX,10h 			; Single write?
	jna	short $$IF69			; yes

;; Manual assemble to prevent compilke warning
;;	  push	  ECX				  ; save count left
	db	066h,051h
;;
	mov	CX,10h
	push	AX				; save AX
	mov	eax,edx
	shr	eax,16
	mov	Read_Write_Relative.Start_Sector_High,ax
	pop	ax				; Recover drive
	push	ax
;; Manual assemble to prevent compile warning
;;	  push	  EDX
	db	066h,052h
;;
	call	write_disk			; write it
;; Manual assemble to prevent compile warning
;;	  pop	  EDX
	db	066h,05Ah
;;
	pop	AX				; restore AX
;; Manual assemble to prevent compile warning
;;	  pop	  ECX				  ; restore count
	db	066h,059h
;;
	jc	short Write_Exit		; exit if fail
	mov	SI,ES:DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	shl	SI,1
	shl	SI,1
	shl	SI,1
	shl	SI,1				; * 10h
	call	seg_adj				; adjust segment
	mov	BX,SI				; new offset
	add	EDX,10h
	sub	ECX,10h
	jmp	SHORT $$DO67
else
	cmp	ECX,40h 			; Single write?
	jna	short $$IF69			; yes

;; Manual assemble to prevent compilke warning
;;	  push	  ECX				  ; save count left
	db	066h,051h
;;
	mov	CX,40h
	push	AX				; save AX
	mov	eax,edx
	shr	eax,16
	mov	Read_Write_Relative.Start_Sector_High,ax
	pop	ax				; Recover drive
	push	ax
;; Manual assemble to prevent compile warning
;;	  push	  EDX
	db	066h,052h
;;
	call	write_disk			; write it
;; Manual assemble to prevent compile warning
;;	  pop	  EDX
	db	066h,05Ah
;;
	pop	AX				; restore AX
;; Manual assemble to prevent compile warning
;;	  pop	  ECX				  ; restore count
	db	066h,059h
;;
	jc	short Write_Exit		; exit if fail
	mov	SI,8000h
	call	seg_adj				; adjust segment
	mov	BX,SI				; new offset
	add	EDX,40h
	sub	ECX,40h
	jmp	SHORT $$DO67
endif

$$IF69:
	push	AX				; save drive
	mov	eax,edx
	shr	eax,16
	mov	Read_Write_Relative.Start_Sector_High,ax
	pop	ax				; Recover drive
	push	ax
	call	write_disk			; write it
	pop	AX				; restore AX
	mov	ECX,0				; set CX to 0 - last read
.8086						     ; DO NOT XOR!!!
$$EN67:
Write_Exit:
	ret

WriteFatSector ENDP

FlushCurrInMemFATBuf proc near
    ASSUME DS:DATA,ES:NOTHING

	push	ds
	push	ds
	pop	es
.386
    assume  ES:DATA
	movzx	cx,DeviceParameters.DP_BPB.oldBPB.BPB_NumberOfFats     ;loop control
    .errnz EDP_BPB NE DP_BPB
	or	CX,CX				;check for zero
	stc
	jz	short FFMExit

	movzx	eax,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
	or	ax,ax
	jnz	short GtFatSz
	mov	eax,dword ptr DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
GtFatSz:
	mov	edx,CurrFATInMemStartSec
	lds	BX,FatSpace			;DS:BX --> FatSpace
    assume  DS:NOTHING,ES:DATA
	mov	SI,BX				;Set up for add. calc
	call	SEG_ADJ 			;Get adjusted seg:off
	mov	BX,SI				;Get new offset

WriteFatLp:					;loop while FATs > 0
;; Manual assemble to prevent compile warning
;;	  push	  eax				  ;Save FAT size
	db	066h,050h
;;
	push	BX				;save Fat offset
	push	DS				;save Fat segment
	push	CX				;save Fat count
;; Manual assemble to prevent compile warning
;;	  push	  EDX				  ;Fat start sector
	db	066h,052h
;;
	mov	ecx,CurrFATInMemSecCnt
	mov	AL,DriveToFormat
	call	WriteFatSector			;write the Fat
;; Manual assemble to prevent compile warning
;;	  pop	  EDX				  ;get 1st. Fat sector
	db	066h,05Ah
;;
	pop	CX				;get Fat count
	pop	DS				;restore Fat segment
	pop	BX				;restore Fat offset
;; Manual assemble to prevent compile warning
;;	  pop	  eax				  ;restore FAT size
	db	066h,058h
;;
	jc	short FFMExit			;check for errors
	add	EDX,EAX 			;next FAT start sector
	loop	WriteFatLp			;write all FATs
	clc
FFMExit:
	pop	ds
	ret

FlushCurrInMemFATBuf endp

DisplayFatDonePcnt  proc near
    assume  DS:DATA,ES:NOTHING

.386
	mov	eax,CurrentCluster
	dec	eax
	dec	eax
	mov	ecx,100
	mul	ecx
	mov	ecx,TotalClusters
	dec	ecx
	dec	ecx
	div	ecx
.8086
	cmp	ax,100
	jbe	PcntOk
	mov	ax,100
PcntOk:
	cmp	AX,PercentComplete		;Only print message when change
	je	NoUpd
	mov	PercentComplete,AX		; Save it if changed
	Message msgCurrentTrack
NoUpd:
	ret

DisplayFatDonePcnt  endp


;===========================================================================
; Routine name: FlushFATBuf
;===========================================================================
;
; Description: Flush the in memory FAT buffer out to the disk
;
; Arguments:		None
; ----------------------------------------------------------------
; Returns:		carry set if error
; -----------------------------------------------------
; Registers destroyed:	EAX EBX ECX EDX
; ----------------------------------------
; Strategy
; --------
;===========================================================================

FlushFATBuf PROC   near
    assume  DS:DATA,ES:NOTHING

	push	DS				;preserve DS
	cmp	FATNotAllInMem,0
.386
	je	WrtWholeFat
    ;
    ; What we have at this point is the first part of the FAT in the in
    ;	memory FAT buf and the BadClusBitMap which indicates what clusters
    ;	we want to mark bad.
    ;
    ; Go through the in memory FAT buf (currently first FATSecCntInMem
    ; sectors of the FAT) marking any bad clusters, and/or write an EOF
    ; mark in the root directory start cluster, write it out.
    ;
    ; For rest of FAT, zero init in memory FAT buf, mark bad clusters
    ; and/or put EOF mark in root directory start cluster and write it out.
    ;
    ; We had better be talking 32-bit FAT here!!!!!! 12-bit and 16-bit
    ; FATs always fit in memory.
    ;
	test	fBig32FAT,0ffh
	stc					; Set error
	jz	ExitWriteFat			; Not 32-bit FAT !!!?????

    ; Set the bad clus value
	mov	BadClusValue,00ffffff7h 	; Set 32 bit value for bad cluster

    ; Set the current in mem FAT start sector
	movzx	eax,DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors
    .errnz EDP_BPB NE DP_BPB
	mov	CurrFATInMemStartSec,eax

    ; Calculate how many clusters fit in memory NOTE that since we are
    ; restricted to 32-bit FAT here we KNOW clusters do not span sector
    ; boundaries in the FAT.
	mov	eax,FATSecCntInMem
	mov	CurrFATInMemSecCnt,eax
	movzx	ecx,DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	mul	ecx
	mov	ecx,4			; 4 bytes per cluster
	div	ecx
	mov	FATInMemClusCnt,eax

    ; Init the in memory buffer with the start of the fat

	call	init_fat_with_header

	message msgWriteFat

    ; Set the rest of the buffer control variables for the in memory buffer
	mov	CurrentCluster,2
	mov	CurrFATInMemStartClus,0
ClusLoop2:
	call	DisplayFatDonePcnt
	mov	eax,dword ptr DeviceParameters.DP_BPB.BGBPB_RootDirStrtClus
	cmp	eax,2
	jb	short NoRootEOF
	cmp	EAX,TotalClusters
	ja	short NoRootEOF
	sub	eax,CurrFATInMemStartClus
	jc	short NoRootEOF
	cmp	eax,FATInMemClusCnt
	jae	short NoRootEOF
	shl	eax,2				; * 4 bytes per cluster
	mov	ecx,00FFFFFFFh
	push	ds
	lds	BX,FatSpace			;DS:BX --> FatSpace
    assume  DS:nothing
	ror	eax,16				; AX is high 16 bits of EAX
						; which is "64k index" of
						; this DWORD
	shl	ax,12				; Convert to SEGMENT value
	push	cx				; Save low 16 of bad mark
	mov	cx,ds
	add	cx,ax
	mov	ds,cx
	pop	cx
	ror	eax,16				; Get back offset in this 64k
	add	bx,ax				; Index this cluster entry
	mov	dword ptr ds:[bx],ecx		; Mark as BAD
	pop	ds
    assume  DS:data
NoRootEOF:
	cmp	BadClusBitMap,0 	; Anything to mark?
	je	short NoBadToMark	; Nope
	mov	eax,CurrentCluster
	push	ds
	lds	si,BadClusBitMap
    assume  DS:nothing
	mov	ebx,eax
	shr	ebx,19				; (E)BX is "64k index" of this bit
	and	eax,00007FFFFh			; bit index in that 64k
	mov	cx,ds
	add	cx,bx				; Go to correct 64k piece
	mov	ds,cx
	bt	dword ptr [si],eax		; Bad cluster?
	pop	ds
    assume  DS:data
	jnc	short NxtClus			; No
	mov	eax,CurrentCluster
	sub	eax,CurrFATInMemStartClus
	shl	eax,2				; * 4 bytes per cluster
	mov	ecx,BadClusValue
	push	ds
	lds	BX,FatSpace			;DS:BX --> FatSpace
    assume  DS:nothing
	ror	eax,16				; AX is high 16 bits of EAX
						; which is "64k index" of
						; this DWORD
	shl	ax,12				; Convert to SEGMENT value
	push	cx				; Save low 16 of bad mark
	mov	cx,ds
	add	cx,ax
	mov	ds,cx
	pop	cx
	ror	eax,16				; Get back offset in this 64k
	add	bx,ax				; Index this cluster entry
	mov	dword ptr ds:[bx],ecx		; Mark as BAD
	pop	ds
    assume  DS:data
NxtClus:
	inc	CurrentCluster
	mov	eax,CurrentCluster
	sub	eax,CurrFATInMemStartClus
	cmp	eax,FATInMemClusCnt
	jae	short NextBuf
	jmp	short TestDone

NoBadToMark:
	mov	eax,FATInMemClusCnt
	cmp	CurrentCluster,2	; Special case?
	ja	short OkayAdd		; No
	sub	eax,2			; Special case for first FAT buffer
OkayAdd:
	add	CurrentCluster,eax
NextBuf:
	call	FlushCurrInMemFATBuf
	jc	short ExitWriteFatCRLFErr
	call	Fat_Init		; Zero init the in mem buffer
	mov	eax,CurrFATInMemSecCnt
	add	eax,CurrFATInMemStartSec
	movzx	ECX,DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors
	movzx	edx,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
	or	dx,dx
	jnz	short GtFatSz2
	mov	edx,dword ptr DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
GtFatSz2:
	add	ecx,edx 		; First sector after the FAT
	cmp	eax,ecx 		; Start sector in the FAT area?
	jae	short DoMsgDone 	; No, all done, carry clear if jump
	mov	CurrFATInMemStartSec,eax
	sub	ecx,eax 		; ecx is count of sectors left in FAT
	cmp	ecx,CurrFATInMemSecCnt	; Partial buffer at end of FAT?
	jae	short CntOK		; No.
	mov	CurrFATInMemSecCnt,ecx	; Last part of FAT < buffer size
CntOK:
	mov	eax,CurrentCluster
	mov	CurrFATInMemStartClus,eax
TestDone:
	mov	EAX,CurrentCluster
	cmp	EAX,TotalClusters	; check for last cluster in FAT
	jna	ClusLoop2
.8086
	call	FlushCurrInMemFATBuf	; Sets carry for return
	jc	ExitWriteFatCRLFErr
DoMsgDone:

	message msgSetBadClusDone

	clc
	jmp	short ExitWriteFat

ExitWriteFatCRLFErr:
	Message msgCrLf

	stc
	jmp	short ExitWriteFat

WrtWholeFat:
.386
	push	ds
	pop	es
    assume  ES:DATA
	movzx	cx,DeviceParameters.DP_BPB.oldBPB.BPB_NumberOfFats     ;loop control
	or	CX,CX				;check for zero
	jz	short ExitWriteFat
	movzx	eax,ES:DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
	or	ax,ax
	jnz	short GotFatSz
	mov	eax,dword ptr ES:DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
GotFatSz:
	movzx	EDX,DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors	;starting sector
	lds	BX,FatSpace			;DS:BX --> FatSpace
    assume  DS:NOTHING,ES:DATA
	mov	SI,BX				;Set up for add. calc
	call	SEG_ADJ 			;Get adjusted seg:off
	mov	BX,SI				;Get new offset

WriteFatLoop: 					;loop while FATs > 0
;; Manual assemble to prevent compile warning
;;	  push	  eax				  ;Save FAT size
	db	066h,050h
;;
	push	BX				;save Fat offset
	push	DS				;save Fat segment
	push	CX				;save Fat count
;; Manual assemble to prevent compile warning
;;	  push	  EDX				  ;Fat start sector
	db	066h,052h
;;
	mov	ecx,eax
	mov	AL,DriveToFormat
	call	WriteFatSector			;write the Fat
;; Manual assemble to prevent compile warning
;;	  pop	  EDX				  ;get 1st. Fat sector
	db	066h,05Ah
;;
	pop	CX				;get Fat count
	pop	DS				;restore Fat segment
	pop	BX				;restore Fat offset
;; Manual assemble to prevent compile warning
;;	  pop	  eax				  ;restore FAT size
	db	066h,058h
;;
	jc	short ExitWriteFat		;check for errors
	add	EDX,EAX 			;next FAT start sector
	loop	WriteFatLoop			;write all FATs
ExitWriteFatOK:
	clc					;signal success
ExitWriteFat:
	pop	DS				;restore DS
	assume	DS:DATA
	ret

FlushFATBuf endp


;===========================================================================
; Routine name:	GetSetFatEntry
;===========================================================================
;
; Description: Returns or sets the contents of the specified fat
;	       entry from a specified buffer. The buffer may be
;	       up to 128K in length for 16 bit FATs and 16K for
;	       12 bit FATs.
;
; WARNING: Do not call this if FATNotAllInMem is TRUE
;
; Arguments:		DS:SI --> Start of FAT buffer
;			EAX = Cluster number
;			ECX = 0fffffffeh if get cluster else set cluster from ECX
; ----------------------------------------------------------------
; Returns:		EAX    --> Contents of FAT entry
; -----------------------------------------------------
; Registers destroyed:	EAX EBX ECX EDX
; ----------------------------------------
; Strategy
; --------
;===========================================================================

GetSetFatEntry PROC	near

	assume	DS:NOTHING,ES:DATA

	push	SI			; Save regs for 'C' compatibility
	push	DS
	push	ES

;	mov	BX,DATA			; ES = DATA
;	mov	ES,BX

	call	Seg_Adj			; Normalize the pointer
.386
	xor	edx,edx
	test	ES:fBig32Fat,0ffh	; See if 32 bit FAT
	jz	short TestEntry16	; If not do 12 bit FAT
	shl	EAX,1			; EDX:EAX *= 2
	rcl	edx,1
	jmp	short FindEntry16	; and *2 again for total of *4

TestEntry16:
	test	ES:fBigFat,0ffh		; See if 16 bit FAT
	jz	short FindEntry12	; If not do 12 bit FAT

FindEntry16:
	shl	EAX,1			; EDX:EAX *= 2
	rcl	edx,1

AddToBufStart:				; Offset in EAX may be > 64K
	mov	EBX,16			; Convert EDX:EAX to paragraphs
	div	EBX			; (AX = DX:AX / 16) (DX = DX:AX % 16)

	mov	BX,DS			; Add paragraphs to DS
	add	AX,BX
	mov	DS,AX

	add	SI,DX			; Add remaining offset in DX to SI


	cmp	ecx,0fffffffeh		; if ECX == 0fffffffeh, then get entry
	jz	short GetFatEntry16
	test	ES:fBig32Fat,0ffh	; See if 32 bit FAT
	jz	short DoEntry16a
	mov	dword ptr [SI],ECX	; Set the entry
	jmp	SHORT GetSetEntryExit

DoEntry16a:
	mov	word ptr [SI],CX	; Set the entry
	jmp	SHORT GetSetEntryExitzx ; AX = FAT entry

GetFatEntry16:
	test	ES:fBig32Fat,0ffh	; See if 32 bit FAT
	jz	short DoEntry16
	mov	EAX,dword ptr [SI]	; Move the entry into EAX
	and	EAX,00FFFFFFFh		; Discard high 4 bits
	jmp	SHORT GetSetEntryExit	; EAX = FAT entry
.8086

DoEntry16:
	mov	AX,word ptr [SI]	; Move the entry into AX
	jmp	SHORT GetSetEntryExitzx ; AX = FAT entry

FindEntry12:
	mov	BX,AX			; BX = cluster number
	shl	AX,1
	add	AX,BX			; AX *= 3

	test	AX,1			; Test lsb of AX to see if even or odd
	pushf				; Save zero flag

	shr	AX,1			; Divid by 2
	add	SI,AX			; Address the cluster
	mov	AX,[SI]			; AX = entry + part of another entry
	popf				; Get bit test off the stack
	jnz	OddCluster		; If not zero then it's an odd cluster

EvenCluster:
	cmp	cx,0fffeh
	jz	GetEvenCluster		; Check for get or set
	and	AX,0f000h		; Zero out the value in 12 lsb
	or	AX,CX			; Set the new value
	mov	[SI],AX
	jmp	SHORT GetSetEntryExitzx ; AX = FAT entry

GetEvenCluster:
	and	AX,0fffh		; Mask off high 4 bits
	jmp	SHORT GetSetEntryExitzx ; AX = FAT entry

OddCluster:
	cmp	cx,0fffeh
	jz	GetOddCluster		; Check for get or set

.386
	shl	CX,4			; Set the value Shift left 4 bits
.8086
	and	AX,0fh			; Zero out existing value in 12 msb
	or	AX,CX			; Insert new value
	mov	[SI],AX
	jmp	SHORT GetSetEntryExitzx ; AX = FAT entry

GetOddCluster:
.386
	shr	AX,4			; Shift over 4 bits to get entry
GetSetEntryExitzx:
	movzx	eax,ax
.8086
GetSetEntryExit:
	pop	ES			; Restore regs for 'C' compatibility
	pop	DS
	pop	SI
	ret

GetSetFatEntry ENDP

;===========================================================================
; Routine name:	GetFatSectorEntry
;===========================================================================
;
; Description: Returns the contents of the specified fat
;	       entry from the FatSector buffer. It is assumed that the 
;	       required sector is in the buffer already.  If the entry is
;	       12 bits and overlaps sectors, the next sector will be read
;	       into the FatSector buffer.
;
; Arguments:		DS:SI --> Start of FatSector buffer
;			entry_offset = offset of entry from start of buffer
;			fBigFat fBig32Fat = flags for 12-16-32-bit FAT
; -------------------------------------------------------------------------
; Returns:		EAX    --> Contents of FAT entry
; -----------------------------------------------------
; Registers destroyed:	EAX BX CX DX
; ---------------------------------
;
;===========================================================================

GetFatSectorEntry PROC	near

	assume	DS:NOTHING,ES:DATA

	push	SI			; Save regs for 'C' compatibility
	push	DS
	push	ES

;	mov	BX,DATA			; ES = DATA
;	mov	ES,BX

	call	Seg_Adj			; Normalize the pointer

	mov	DX,ES:entry_offset
	add	SI,DX  			; Add offset value in DX to SI

	test	ES:fBig32Fat,0ffh	; See if 32 bit FAT
	jz	short TestEntry16x	; If not do 12-16 bit FAT
.386
	mov	EAX,dword ptr [SI]		; Move the entry into AX
	and	EAX,00FFFFFFFh			; Discard high 4 bits
.8086
	jmp	SHORT GetFatSectorEntryExit	; EAX = FAT entry

TestEntry16x:
	test	ES:fBigFat,0ffh		; See if 16 bit FAT
	jz	Get12		; If not do 12 bit FAT

Get16:
.386
	movzx	EAX,word ptr [SI]		; Move the entry into AX
.8086
	jmp	SHORT GetFatSectorEntryExit	; EAX = FAT entry

Get12:
ifdef NEC_98
;;;	mov	AX,DeviceParameters.DP_BPB.BPB_BytesPerSector
; Fix for B#7418
	mov	AX,ES:DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	dec	AX
	cmp	DX,AX
else
	cmp	DX,1ffh			; Entry straddles two FAT sectors if
endif
	jb	Does_Not_Straddle	; offset is 511 (last byte in sector) 
Does_Straddle:
	call	ReadInTwoParts		; Handle special case by reading in
	jmp	SHORT  GetFatSectorEntryExit	; the next FAT sector also

Does_Not_Straddle:
.386
	movzx	EAX,word ptr [SI]	; EAX = entry + part of another entry
.8086
	test  	ES:odd_entry,1
	jnz	IsOddCluster		; If not zero then it's an odd cluster

IsEvenCluster:
	and	AX,0fffh		; Mask off high 4 bits
	jmp	SHORT GetFatSectorEntryExit	; EAX = FAT entry

IsOddCluster:
.386
	shr	AX,4			; Shift over 4 bits to get entry
.8086
GetFatSectorEntryExit:
	pop	ES			; Restore regs for 'C' compatibility
	pop	DS
	pop	SI
	ret

GetFatSectorEntry ENDP

;===========================================================================
;
;  ReadInTwoParts :	This procedure will determine the value of a 12-bit 
;			FAT entry which is straddled across two consecutive
;			sectors in the FAT.  The value is found by reading
;			the available part from the first sector, and then
;			loading the next sector in the FatSector buffer and
;			reading and combining the next part.
;  Input : odd_entry
;	   sector_to_read
;	   DS:SI pointer to required entry location in buffer (this is
;	    offset 511 from start of FatSector buffer)
;
;  Output: AX = entry value
;	   FatSector contains next FAT sector
;
;  Registers destroyed : AX
;
;  Strategy :	The position of the entry is different for odd and even
;		entries.  The 3-byte layout for two consecutive 12-bit entries
;		is shown below.  (The byte |X1 X0| or |Y2 X2| is the last 
;		in the buffer).
;
;		|X1 X0|Y0 X2|Y2 Y1|
;
;		Even entries start at X1 (thus need to get X2X1X0).
;		Odd entries start at Y0 (thus need to get Y2Y1Y0).
;
;===========================================================================

ReadInTwoParts	proc	near

	assume	DS:NOTHING,ES:DATA

	push	BX				; Save registers
	push	CX
	push	DX
	push	SI

	xor	AX,AX
	mov	AL,BYTE PTR [SI]		; read last byte of buffer
.386
	mov	EBX,ES:sector_to_read		; compute next sector to read
	inc	EBX
	mov	ES:sector_to_read,EBX
.8086
	test	ES:odd_entry,1
	jnz	OddEntry

EvenEntry:
	push	AX
	call	ReadFatSector			; read in the next FAT sector
	pop	AX
	
	lds	SI,ES:FatSector			; set DS:SI to start of buffer
	xor	BX,BX

	mov	BH,BYTE PTR [SI]		; read first byte of buffer
	and	BH,0fh				; mask out Y2
	or	AX,BX				; place X2 into position

	jmp	SHORT EndReadInTwo

OddEntry:
	and	AL,0f0h				; mask out X2
	mov	CL,4
	shr	AX,CL				; place Y0 into position
	
	push	AX
	call	ReadFatSector			; read in the next FAT sector
	pop	AX

	lds	SI,ES:FatSector			; set DS:SI to start of buffer
	
	xor	BX,BX
	mov	BL,BYTE PTR [SI]		; read first byte of buffer
	mov	CL,4
	shl	BX,CL	
	or	AX,BX				; place Y2 Y1 into position
	
EndReadInTwo:
	pop	SI				; Restore registers
	pop	DX
	pop	CX
	pop	BX
	ret

ReadInTwoParts	endp

AllocInitBadClusBitmap	proc near

    assume  DS:DATA,ES:NOTHING
	push	es
.386
	cmp	BadClusBitMap,0
	jne	short DoneOk
	mov	ebx, TotalClusters
	add	ebx,32			; 32 not 31
	shr	ebx,5			; Cnt of DWORDs
	shl	ebx,2			; Cnt of BYTEs
	add	ebx,15
	shr	ebx,4			; Cnt of paras

    %out BUG limit on bad cluster bitmap

	cmp	ebx,00005000h		; Bitmap > 320k? (2,621,440 clusters)
	ja	short ErrExit_Alloc_BCB ; Yes
	mov	AH, Alloc
	int	21h
	jc	short Exit_Alloc_BCB
	mov	WORD PTR BadClusBitMap+2,AX
	mov	es,ax
	xor	di,di
	xor	AX,AX
	mov	WORD PTR BadClusBitMap,AX
	movzx	ecx,bx			; Cnt of paras
	shl	ecx,3			; 8 words per para
	mov	edx,ecx
NxtBlock:
	cmp	ecx,8000h		; More than 64k left?
	jbe	short ZotIt		; Nope, last one
	mov	ecx,00008000h		; Do at most 64k at a time
ZotIt:
	mov	ebx,ecx 		; Save count
	cld
	rep	stosw			; zero init bit array
	sub	edx,ebx 		; Sub off amount done
	jbe	short DoneOk		; All done
	mov	ax,es
	add	ax,1000h		; Next 64k
	mov	es,ax
	xor	di,di
	mov	ecx,edx
	jmp	short NxtBlock
.8086
DoneOk:
	clc
Exit_Alloc_BCB:
	pop	es
	ret

ErrExit_Alloc_BCB:
	stc
	jmp	short Exit_Alloc_BCB

AllocInitBadClusBitmap	endp


;*** SetUpBadClusTransfer - Set things up to copy bad clusters from the current
;			    disk to the new disk.
;
; DS -> data
;
SetUpBadClusTransfer proc near
    assume  DS:DATA,ES:NOTHING

	mov	word ptr BadClusBitMap,0
	mov	word ptr BadClusBitMap+2,0
	cmp	FATNotAllInMem,0
.386
	je	InitFatWithBad
	call	DetermineExistingFormatNoMsg   
	cmc
	jnc	AllDone6		; Drive isn't valid so no bad sectors
    ;
    ; Build a bit map of the bad clusters
    ;
	message msgSetBadClus

.386
	test	fBig32FAT,0ffh		; See if 32 bit fat
	jz	short Tst16BitEntry	; If zero then 16 or 12 bit fat
	mov	EBX,00ffffff7h		; Set 32 bit value for bad cluster
	jmp	SHORT SetBdVal

Tst16BitEntry:
	mov	EBX,00000ff7h		; Set 12 bit value for bad cluster
	test	fBigFAT,0ffh		; See if 16 bit fat
	jz	short SetBdVal		; If zero then 12 bit fat
	mov	EBX,0000fff7h		; Set 16 bit value for bad cluster
SetBdVal:
	mov	CurrentCluster,2
	mov	BadClusValue,EBX
	push	ds
	pop	es			; following routines expect ES->DATA
ClusLoop:
	call	DisplayFatDonePcnt

	mov	EAX,CurrentCluster
	call	calc_sector_and_offset	; determine location of this entry

	mov	EBX,sector_in_buffer
	mov	EAX,sector_to_read
	cmp	EAX,EBX 		; check if required sector is in buffer
	je	short DontHaveToRead2

	call	ReadFatSector		; read a sector of the FAT into buffer
	jc	short AllDoneDoCRLFErr

DontHaveToRead2:
	mov	EAX,CurrentCluster	; EAX = current cluster
	xor	CX,CX			; ECX = get cluster contents signal
	push	ds
	lds	SI,FatSector		; DS:SI --> FAT buffer
	call	GetFatSectorEntry	; EAX = contents of FAT entry
	pop	ds
	cmp	EAX,BadClusValue	; Is this cluster marked bad?
	jne	short NextClus		; If EAX<>EBX good cluster

	call	AllocInitBadClusBitmap	; Does nothing if BadClusBitMap
	jc	short AllDoneDoCRLFErr	;   already exists

	mov	EAX,CurrentCluster	; EAX = this cluster number
	push	ds
	lds	si,BadClusBitMap
	mov	ebx,eax
	shr	ebx,19			; (E)BX is "64k index" of this bit
	and	eax,00007FFFFh		; bit index in that 64k
	mov	cx,ds
	add	cx,bx			; Go to correct 64k piece
	mov	ds,cx
	bts	dword ptr [si],eax	; Set the bit
	pop	ds
NextClus:
	inc	CurrentCluster		; go to next cluster
	mov	EAX,CurrentCluster
	mov	EBX,TotalClusters
	cmp	EAX,EBX 		; check for last cluster in FAT
.8086
	jna	ClusLoop

	message msgSetBadClusDone

	jmp	short AllDone6Ok

AllDoneDoCRLFErr:
	message msgCRLF
	stc
	jmp	short AllDone6

InitFatWithBad:
	call	load_old_fat		; load old FAT
	call	mark_non_bad_as_free	; mark anything not BAD as FREE
AllDone6Ok:
	clc
AllDone6:
	ret

SetUpBadClusTransfer endp

;***	mark_non_bad_as_free -- mark all non-bad blocks as free in the FAT
;
;	WARNING: Do not call this if FATNotAllInMem is TRUE
;
mark_non_bad_as_free	proc	near

	assume	ds:nothing, es:DATA

.386
	test	fBig32FAT,0ffh			; See if 32 bit fat
	mov	ebx,00ffffff7h			; get bad value for 32-bit
	jnz	short mark_non_bad_1
	test 	fBigFAT,0ffh			; See if 16 bit fat
	mov	ebx,0fff7h			; get bad value for 16-bit
	jnz	short mark_non_bad_1
	and	bh,0fh				; get the 0ff7h for 12-bit
mark_non_bad_1:
	mov	eax,2				; cluster number

mark_non_bad_2:
	push	ds
	lds	si,FatSpace			; point to the FAT buffer
	mov	ecx,0fffffffeh			; get the FAT entry
;; Manual to disable compile warning
;;	  push	  eax				  ; save cluster number
	db	066h,050h
;;	  push	  ebx				  ; save bad value
	db	066h,053h
	call	GetSetFatEntry			; read the cluster value
;;	  pop	  ebx
	db	066h,05Bh
	cmp	eax,ebx 			; is it bad?
	jz	short mark_non_bad_3		; skip if so (leave alone)

;;	 pop	 eax				 ; get the cluster number
	db	066h,058h
;;	 push	 eax
	db	066h,050h
;;	  push	  ebx
	db	066h,053h
	xor	ecx,ecx 			; set FAT entry to FREE
	call	GetSetFatEntry
;;	  pop	  ebx
	db	066h,05Bh

mark_non_bad_3:
;;	  pop	  eax				  ; restore cluster number
	db	066h,058h
	pop	ds
	inc	eax
	cmp	eax,TotalClusters
	jna	mark_non_bad_2
.8086
	ret

mark_non_bad_as_free	endp

;***	load_old_fat -- loads the FAT from the existing media into FatSpace
;
;	WARNING: Do not call this if FATNotAllInMem is TRUE
;
;	If not properly formatted, will just terminate.
;	If any error reading FAT, will zero entire FAT via Fat_Init.

load_old_fat	proc	near

	mov	SI,DATA
	mov	ES,SI				; Set ES to data segment

	assume	ES:DATA,DS:Nothing		; Assembler directive
	push	ds
	call	DetermineExistingFormatNoMsg   
	jc	load_old_fat_error

	call	init_fat_with_header

	mov	CX, DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
    .errnz EDP_BPB NE DP_BPB
	or	cx, cx
	jnz	short GotFSz
    ;
    ; We KNOW the high word must be 0 since whole FAT fits in memory
    ;
	mov	cx, DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
GotFSz:
	mov	DX,DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors  ;starting sector
	mov	AL,DriveToFormat

	lds	bx,FatSpace

load_old_fat_1:
	jcxz	load_old_fat_done		; exit when done

ifdef NEC_98
	push	cx				; save size to write
	cmp	cx,10h				; need more than 40h secs?
	jb	load_old_fat_2			; skip if we can get it all

	mov	cx,10h				; clip to max

load_old_fat_2:
	push	AX				; save AX
	call	Read_Disk			; read it
	pop	AX				; restore AX
	pop	CX				; restore CX
	jc	load_old_fat_error		; exit if error

	push	ax
	mov	ax,ds
	add	ax,es:DeviceParameters.DP_BPB.BPB_BytesPerSector; adjust segment
	mov	ds,ax
	pop	ax
	add	DX,10h
	sub	CX,10h
	ja	load_old_fat_1			; loop until done
else
	push	cx				; save size to write
	cmp	cx,40h				; need more than 40h secs?
	jb	load_old_fat_2			; skip if we can get it all

	mov	cx,40h				; clip to max

load_old_fat_2:
	push	AX				; save AX
	call	Read_Disk			; read it
	pop	AX				; restore AX
	pop	CX				; restore CX
	jc	load_old_fat_error		; exit if error

	push	ax
	mov	ax,ds
	add	ax,40h*512/16			; adjust segment
	mov	ds,ax
	pop	ax
	add	DX,40h
	sub	CX,40h
	ja	load_old_fat_1			; loop until done
endif

load_old_fat_done:
	pop	ds
	jmp	short init_fat_header

load_old_fat_error:
	pop	ds
	if2
	.errnz	(offset $) - (offset init_fat_with_header)	; fall thru!
	endif

load_old_fat	endp

;***	init_fat_with_header -- Do a Fat_Init, and then put bytes at front
;
;	alternate entry point: init_fat_header (just fill in header)

init_fat_with_header	proc	near

	assume	ds:nothing, es:DATA

	mov	DI,DATA
	mov	ES,DI
	call	Fat_Init
init_fat_header:
	push	ES

	push	es
	pop	ds		; get ds -> DATA

	assume	ds:DATA
	les	DI, FatSpace		; ES:DI --> FatSpace buffer
	assume	es:nothing		; Store media descriptor byte
	mov	AL, DeviceParameters.DP_BPB.oldBPB.BPB_MediaDescriptor
    .errnz EDP_BPB NE DP_BPB
ifdef NEC_98
	cmp	AL,Fixed_Disk		;FAT-ID twisted (for HD and 5"MO)
	jne	@F			; F8h --> FEh (Only FAT-ID)
	mov	AL,Single_8_Media	;it is NEC_98 local.
@@:
endif
	mov	AH, 0ffH
	stosw				; Cluster 0 start
	mov	al,ah
	stosb				; cluster 0 if 32 bit else cluster 1
	test	fBig32Fat, TRUE
	jz	Not32
	stosb				; finish cluster 0 dword
	stosw				; cluster 1 dword
	and	ah,0Fh			; High nibble reserved, zero it.
	stosw
	sub	di,5			; Go back to high byte of cluster 0
	mov	al,ah
	stosb				; High nibble reserved, zero it.
	jmp	short NotBig

Not32:
	test	fBigFat, TRUE
	jz	NotBig
	stosb				; finish cluster 1 word
NotBig:
	pop	ES
	ret

init_fat_with_header	endp

;**** IsThisClusterBad
;
;     ENTRY: EAX is cluster #
;
;     EXIT:  Zero set if cluster bad
;
;     USES: EBX,ECX,EDX,FLAGS
;
IsThisClusterBad proc near
	assume	ds:data, es:data

	push	ds
	push	si
.386
;;	 push	 eax
	db	066h,050h

	cmp	FATNotAllInMem,0
	je	short ChkInMemFat
	cmp	BadClusBitMap,0 	; Anything marked?
	je	short NotBadRet 	; Nope
	lds	si,BadClusBitMap
    assume  DS:nothing
	mov	ebx,eax
	shr	ebx,19				; (E)BX is "64k index" of this bit
	and	eax,00007FFFFh			; bit index in that 64k
	mov	cx,ds
	add	cx,bx				; Go to correct 64k piece
	mov	ds,cx
	bt	dword ptr [si],eax		; Bad cluster?
	jnc	short NotBadRet 		; No
	mov	bx,0FFFFh			; Set so following inc sets ZERO
NotBadRet:
	inc	bx
PopRet:
;;	  pop	  eax				  ; restore cluster number
	db	066h,058h
.8086
	pop	si
	pop	ds
	ret

ChkInMemFat:
.386
    assume  DS:data
	test	fBig32FAT,0ffh
	jz	short Tst16BitEnt
	mov	EBX,00ffffff7h
	jmp	SHORT SetBVal

Tst16BitEnt:
	mov	EBX,00000ff7h
	test	fBigFAT,0ffh
	jz	short SetBVal
	mov	EBX,0000fff7h
SetBVal:
	mov	BadClusValue,EBX
	mov	ECX,0fffffffeh			; ECX = Get value
	lds	SI,FatSpace
    assume  DS:nothing
	call	GetSetFatEntry
	cmp	eax,es:BadClusValue
.8086
	jmp	short PopRet

IsThisClusterBad endp

;**** WrtEOFMrkInRootClus
;
;     ENTRY: None
;
;     EXIT:  EOF mark written into root directory staring cluster
;
;     USES: EAX,EBX,ECX,EDX,FLAGS
;
WrtEOFMrkInRootClus proc near
	assume	ds:data, es:data
	push	ds
	push	si
    ;
    ; In FATNotAllInMem case FlushFatBuf will take care of putting
    ;	an eof mark in the root clus
    ;
	cmp	FATNotAllInMem,0
	jne	SetDone
	test	fBig32FAT,0ffh		; See if 32 bit fat
	jz	SetDone 		; No
.386
	mov	eax,dword ptr DeviceParameters.DP_BPB.BGBPB_RootDirStrtClus
    .errnz EDP_BPB NE DP_BPB
	cmp	eax,2
	jb	short SetDone
	cmp	eax,TotalClusters
	ja	short SetDone
	mov	ECX,00fffffffh
.8086
	lds	SI,FatSpace
    assume  DS:nothing
	call	GetSetFatEntry
SetDone:
	pop	si
	pop	ds
	ret

WrtEOFMrkInRootClus endp


CODE ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oemmint\oemmint.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    oemmint.h

Abstract:

    Simple tool to create a Mini NT image
    from a regular NT image

Author:

    Vijay Jayaseelan (vijayj) Aug-08-2000

Revision History:

    None.
    
--*/

#include <setupapi.hpp>
#include <queue.hpp>
#include <algorithm>
#include <list>
#include <tchar.h>
#include <strsafe.h>

#define ARRAY_SIZE(_X)   (sizeof(_X)/sizeof((_X)[0]))
#define NULLSTR          L""


//
// Different types of SxS assembly layouts on the distribution
// media.
//
#define SXS_LAYOUT_TYPE_DIRECTORY   1
#define SXS_LAYOUT_TYPE_CAB         2

#define SXS_CAB_LAYOUT_BUILD_NUMBER 3606

//
// Invalid argument exception
//
struct InvalidArguments {};

//
// function prototypes
//
template <class T>
bool 
CreateDirectories(
    const std::basic_string<T> &DirName,
    LPSECURITY_ATTRIBUTES SecurityAttrs
  );

template <class T>
bool
IsFilePresent(
    const std::basic_string<T> &FileName
    );

//
// Argument cracker
//
template <class T>
struct Arguments {
    std::basic_string<T>  CurrentDirectory;
    std::basic_string<T>  LayoutName;
    std::basic_string<T>  DriverIndexName;
    std::basic_string<T>  SourceDirectoryRoot;
    std::basic_string<T>  SourceDirectory;
    std::basic_string<T>  DestinationDirectory;
    std::basic_string<T>  ExtraFileName;
    std::basic_string<T>  OptionalSrcDirectory;
    std::basic_string<T>  PlatformSuffix;
    std::basic_string<T>  DosNetFileName; 
    std::basic_string<T>  ConfigInfFileName;
    std::basic_string<T>  IntlInfFileName;
    std::basic_string<T>  FontInfFileName;
    bool                  Verbose;
    bool                  WowFilesPresent;
    bool                  SkipWowFiles;
    bool                  SkipFileCopy;
    bool                  CheckVersion;
    bool                  IA64Image;
    int                   WinSxSLayout;
    DWORD                 MajorVersionNumber;
    DWORD                 MinorVersionNumber;
    DWORD                 MajorBuildNumber;
    
    Arguments(int Argc, T *Argv[]);

    
    friend std::ostream& operator<<(std::ostream &os, 
                const Arguments &rhs) {
                
        os << rhs.SourceDirectory << ", " 
           << rhs.DestinationDirectory << ", "
           << rhs.LayoutName << ", "
           << rhs.ExtraFileName << ", "
           << rhs.OptionalSrcDirectory << ", "
           << rhs.DriverIndexName << std::endl;

        return os;
    }
    
    protected:
        VOID IdentifySxSLayout( VOID );
};


//
// Argument Types
//
typedef Arguments<char>     AnsiArgs;
typedef Arguments<wchar_t>  UnicodeArgs;

//
// Driver Index File abstraction. 
//
// This class helps in resolving a binary name to appropriate driver
// cab file (like SP1.CAB or DRIVER.CAB).
//
template <class T>
class DriverIndexInfFile : public InfFile<T> {
public:
    //
    // constructor
    //
    DriverIndexInfFile(const std::basic_string<T> &FileName) : InfFile<T>(FileName){        
        std::map<std::basic_string<T>, Section<T> *>::iterator Iter = Sections.find(CabsSectionName);

        if (Iter == Sections.end()) {
            throw new InvalidInfFile<T>(FileName);            
        }

        CabsSection = (*Iter).second;
        Iter = Sections.find(VersionSectionName);
        
        if (Iter == Sections.end()) {
            throw new InvalidInfFile<T>(FileName);                    
        }

        Section<T> *VersionSection = (*Iter).second;
        SectionValues<T> &Values = VersionSection->GetValue(CabsSearchOrderKeyName);

        for (int Index=0; Index < Values.Count(); Index++) {
            if (sizeof(T) == sizeof(CHAR)) {
                SearchList.push_back((T *)_strlwr((PSTR)Values.GetValue(Index).c_str()));
            } else {
                SearchList.push_back((T *)_wcslwr((PWSTR)Values.GetValue(Index).c_str()));
            }
        }
    }

    //
    // Checks where the given is contained any of the driver cab files
    //
    bool IsFilePresent(const std::basic_string<T> &FileName){    
        return (GetCabFileName(FileName).length() > 0);
    }

    //
    // Returns the driver cab file name which contains the given filename.
    //
    const std::basic_string<T>& GetCabFileName(const std::basic_string<T> &FileName) {    
        const static basic_string<T> NullCabFileName;
        std::list<basic_string<T> >::iterator Iter;

        for(Iter = SearchList.begin(); Iter != SearchList.end(); Iter++) {
            std::map< std::basic_string<T>, Section<T> *>::iterator SectionIter = Sections.find(*Iter);
            
            if (SectionIter != Sections.end()) {
                Section<T> *CurrentSection = (*SectionIter).second;
                
                if (CurrentSection->IsKeyPresent(FileName)) {
                    break;
                }
            }
        }

        if (Iter != SearchList.end()) {
            return CabsSection->GetValue(*Iter).GetValue(0);
        }

        return NullCabFileName;
    }

protected:
    //
    // constant strings
    //
    const static std::basic_string<T>   VersionSectionName;
    const static std::basic_string<T>   CabsSectionName;
    const static std::basic_string<T>   CabsSearchOrderKeyName;

    //
    // data members
    //    
    std::list<std::basic_string<T> >    SearchList;     // the cab file list search order
    Section<T>                          *CabsSection;   // the [cabs] section of drvindex.inf
};


//
// File list creator functor object
//
template <class T>
struct FileListCreatorContext {    
    Arguments<T>    &Args;
    Section<T>      *CurrentSection;
    Section<T>      *DirsSection;
    bool            SkipInfFiles;
    ULONG           FileCount;
    bool            ProcessingExtraFiles;
    InfFile<T>      &IntlInfFile;
    InfFile<T>      &FontInfFile;
    InfFile<T>      &ConfigInfFile;
    ULONG           DummyDirectoryId;
    std::basic_string<T>    WindowsDirectory;
    std::basic_string<T>    WinSxsCabinetFileName;
    DriverIndexInfFile<T>   &DriverIdxFile;
    
    std::basic_string<T>    CurrentCabFileIdx;  // the cab being currently iterated on
    std::basic_string<T>    CurrentFileName;    // the current file while iterating cab
        
    std::map<std::basic_string<T>, std::basic_string<T> > FileList;    
    std::map<std::basic_string<T>, std::basic_string<T> > ExtraFileList;            
    std::map<std::basic_string<T>, std::basic_string<T> > DestDirs;
    std::map<std::basic_string<T>, std::basic_string<T> > WinSxSFileList;
    std::map<std::basic_string<T>, std::basic_string<T> > NlsFileMap;
    std::map<std::basic_string<T>, std::basic_string<T> > NlsDirMap;

    //
    // Map of map i.e. map of cab filename to map of list of source to destination names
    // which need to be extracted for cab file
    //
    std::map<std::basic_string<T>, std::map<std::basic_string<T>, std::basic_string<T> > * > CabFileListMap;    

    FileListCreatorContext(
            Arguments<T> &PrgArgs, 
            Section<T> *Curr, 
            Section<T> *Dirs,
            InfFile<T> &ConfigInf,
            InfFile<T> &IntlInf,
            InfFile<T> &FontInf,
            DriverIndexInfFile<T> &DrvIdxFile
            );

    DWORD ProcessNlsFiles(VOID);

    ~FileListCreatorContext() {
        std::map<std::basic_string<T>, 
            std::map<std::basic_string<T>, std::basic_string<T> > * >::iterator Iter;

        for (Iter=CabFileListMap.begin(); Iter != CabFileListMap.end(); Iter++) {
            delete (*Iter).second;
        }
    }

    ULONG GetSourceCount() const {
        ULONG Count = (FileList.size() + ExtraFileList.size() + 
                        WinSxSFileList.size() + NlsFileMap.size());

        std::map<std::basic_string<T>, 
            std::map<std::basic_string<T>, std::basic_string<T> > * >::iterator Iter;

        for (Iter=CabFileListMap.begin(); Iter != CabFileListMap.end(); Iter++) {
            Count += (*Iter).second->size();
        }

        return Count;
    }        

    bool IsDriverCabFile(const std::basic_string<T> &FileName) {
        return DriverIdxFile.IsFilePresent(FileName);
    }

    //
    // Given the file name returns the cab file name (if any) which contains
    // the file. In case of error "" (empty string) is returned.
    //
    const std::basic_string<T>& GetDriverCabFileName(const std::basic_string<T> &FileName) {
        const std::basic_string<T> &CabFileName = DriverIdxFile.GetCabFileName(FileName);

        // std::cout << "GetDriverCabFileName(" << FileName << ") = " << CabFileName << std::endl;

        return CabFileName;
    }
    

    //
    // Adds to the per cab file map the given source and destination file name that
    // need to be extracted
    //
    void AddFileToCabFileList(const std::basic_string<T> &CabFileName, 
            const std::basic_string<T> &SourceFile, 
            const std::basic_string<T> &DestinationFile) {
        //cout << "AddFileToCabFileList(" << CabFileName << ", " << SourceFile << ", " << DestinationFile << ")" << endl;

        std::map<std::basic_string<T>, 
            std::map<std::basic_string<T>, std::basic_string<T> >* >::iterator Iter;        

        Iter = CabFileListMap.find(CabFileName);

        std::map<std::basic_string<T>, std::basic_string<T> > *FileMap = NULL;

        if (Iter != CabFileListMap.end()) {
            FileMap = (*Iter).second;
        } else {
            //
            // New cab file list 
            //
            CabFileListMap[CabFileName] = FileMap = new std::map<std::basic_string<T>, std::basic_string<T> >();
        }        

        (*FileMap)[SourceFile] = DestinationFile;
    }

    std::basic_string<T> GetNextDummyDirectoryId() {
        T   Buffer[MAX_PATH];
        
        if (sizeof(T) == sizeof(CHAR)) {
            (void)StringCchPrintfA((PSTR)Buffer, ARRAY_SIZE(Buffer), "%d", DummyDirectoryId);
        } else {
            (void)StringCchPrintfW((PWSTR)Buffer, ARRAY_SIZE(Buffer), L"%d", DummyDirectoryId);
        }

        DummyDirectoryId++;

        return std::basic_string<T>((const T*)Buffer);
    }

    void AddDirectoryToNlsDirMap(const std::basic_string<T> &FileName) {
        T Separator;

        if (sizeof(T) == sizeof(CHAR)) {
            Separator = (T)'\\';
        } else {
            Separator = (T)L'\\';
        }

        std::basic_string<T> DirectoryKey = FileName.substr(0, FileName.rfind(Separator));

        if (DirectoryKey.length() && (NlsDirMap.find(DirectoryKey) == NlsDirMap.end())) {
            NlsDirMap[DirectoryKey] = GetNextDummyDirectoryId();
        }
    }

    void ProcessNlsDirMapEntries(void) {
        std::map<std::basic_string<T>, std::basic_string<T> >::iterator Iter;

        for (Iter = NlsDirMap.begin(); Iter != NlsDirMap.end(); Iter++) {
            DestDirs[(*Iter).second] = (*Iter).first;
        }
    }    

    void RemoveDuplicateNlsEntries(void) {
        std::map<std::basic_string<T>, std::basic_string<T> >::iterator NlsIter, PrevIter;            
        
        for (NlsIter = NlsFileMap.begin(); NlsIter != NlsFileMap.end(); ) {            
            PrevIter = NlsFileMap.end();
            
            if (FileList.find((*NlsIter).first) != FileList.end()) {
                PrevIter = NlsIter;
            } 

            NlsIter++;

            if (PrevIter != NlsFileMap.end()) {
                // std::cout << "Erasing : " << (*PrevIter).first << std::endl;
                NlsFileMap.erase(PrevIter);
            }
        }
    }

    void MoveDriverCabNlsFiles(void);

    //
    // static data members
    //
    static
    UINT 
    NlsFileQueueScanWorker(
        PVOID       Context,
        UINT        Notification,
        UINT_PTR    Param1,
        UINT_PTR    Param2
        );            
};


//
// function prototypes
//
template <class T>
void
FileListCreator(
  SectionValues<T> &Values,
  PVOID Context
  );

template <class T>
bool 
IsWow64File(
    SectionValues<T> &Values,
    FileListCreatorContext<T> &Context
    );

template <class T>
bool
IsFileSkipped(
    SectionValues<T> &Values,
    FileListCreatorContext<T> &Context
    );

template <class T>
ULONG
CopyFileList(
  FileListCreatorContext<T> &Context    
  );

template <class T>
ULONG
ProcessExtraFiles(
  FileListCreatorContext<T> &Context
  );

template <class T>
ULONG
ProcessWinSxSFiles(
    IN FileListCreatorContext<T> &Context
    );

template <class T>
ULONG
PreCreateDirs(
  FileListCreatorContext<T> &Context
  );


template <class T>
bool
ProcessInfChanges(
    Arguments<T> &Args,
    const std::basic_string<T> &InfName
    );

template <class T>
bool
CheckMediaVersion(
    Arguments<T>    &Args
    );

//
// utility function to tokenize a given line based on the delimiters
// specified
//
template< class T >
unsigned Tokenize(const T &szInput, const T & szDelimiters, std::vector<T>& tokens) {
    unsigned DelimiterCount = 0;

    tokens.clear();

    if(!szInput.empty()){
        if(!szDelimiters.empty()){
            T::const_iterator       inputIter = szInput.begin();
            T::const_iterator       copyIter = szInput.begin();

            while(inputIter != szInput.end()){
                if(szDelimiters.find(*inputIter) != string::npos){
                    if (copyIter < inputIter) {
                        tokens.push_back(szInput.substr(copyIter - szInput.begin(),
                                                        inputIter - copyIter));
                    }

                    DelimiterCount++;
                    inputIter++;
                    copyIter = inputIter;
                    
                    continue;
                }

                inputIter++;
            }

            if(copyIter != inputIter){
                tokens.push_back(szInput.substr(copyIter - szInput.begin(),
                                                inputIter - szInput.begin()));
            }
        } else {
            tokens.push_back(szInput);
        }        
    }

    return DelimiterCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\forequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;                                              ;                               ;     ;

GAGE_UPDATE 	EQU	(4900h)

NO      equ     0
YES     equ     not NO


FSExec	equ	NO				;conditional assembly
ShipDisk equ	YES				;ship disk flag

Boot_ID equ   0AA55h
DOS_Found equ   0

Not_Include     equ     0
Do_Include         equ     1

INIT    equ     0

FAT12_File_System equ 01h
ifdef NEC_98
FAT16_File_System equ 11h
FAT32_File_System equ 61h
New_File_System equ 21h
else
FAT16_File_System equ 04h
FAT32_File_System equ 0Bh
New_File_System equ 06h
endif

FS_String_Max_Length    equ     5

Paragraph_Size  equ     16                      ;                               ;AN005;
Len_FS_String_Buffer    equ     13

Net_Check equ   1200h
Assign_Check equ 8000h

Found_Yes equ   1
Found_No equ    0

Asciiz_End equ  0
DBCS_Blank_hi	equ	81h
DBCS_Blank_lo	equ	40h
DBCS_Vector_Size equ 2
End_Of_Vector equ 0


Blank   equ     " "

Label_Length equ 11
CR      equ     13

DBCS_VECTOR equ NO

;Limits
BIG_FAT_THRESHOLD equ 4086

fBig		EQU	0ffh		; flag for 12- or 16-bit FAT
fBig32		EQU	0feh		; flag for 32-bit FAT

;-------------------------------------------------------------------------------

DRNUM   EQU     5CH

; Exit status defines
ExitOK  equ     0
ExitCtrlC equ   3
ExitFatal equ   4
ExitNo  equ     5


;-------------------------------------------------------------------------------
; These are the data structures which we will need


Media_ID struc
Media_ID_Info_Level dw 0
Media_ID_Serial_Number dd 0
Media_ID_Volume_Label db 11 dup(" ")
Media_ID_File_System db 8  dup(" ")
Media_ID ends


Relative_Sector_Buffer  struc                   ;                               ;AN000;

Start_Sector_Low        dw      ?               ;Low word of RBA sector         ;AN000;
Start_Sector_High       dw      ?               ;High word of RBA sector        ;AN000;
Number_Sectors          dw      ?               ;Number of sectors              ;AN000;
Buffer_Offset           dw      ?               ;Address of data buffer         ;AN000;
Buffer_Segment          dw      ?               ;                               ;AN000;

Relative_Sector_Buffer ends                     ;                               ;AN000;


;Per system file data structure

a_FileStructure struc
	fileHandle 		DW   	?
	fileSizeInParagraphs 	DW 	?
	fileSizeInBytes 	DD 	?
	fileOffset 		DD   	?
	fileStartSegment 	DW 	?
	fileDate 		DW     	?
	fileTime 		DW     	?
a_FileStructure ends

;-------------------------------------------------------------------------------

LOGBOOTSECT 		equ 	1
Set_Drv_Owner		equ 	0Fh             ; IOCTL subfunction
Custom_Media 		equ 	0F0H            ; Media byte for custom format
Dual_8_Media 		equ	0FFh            ; Dual sided 8 sectored
Single_8_Media 		equ	0FEh            ; Single sided 8 sectored
Dual_9_Media 		equ	0FDh            ; Dual sided 9 sectored
Single_9_Media 		equ	0FCh            ; Single sided 9 sectored
Dual_15_Media 		equ	0F9h            ; Dual sided 15 sectored
Fixed_Disk 		equ  	0F8h            ; Fixed Disk
Invalid_Drive   	equ     000Fh           ; Extended error 15
Max_Format_Size 	equ     0FFFFh          ; Max bytes to Format
Multi_Track_Format      equ     02h             ; Multi-track format
Single_Track_Format     equ     00h             ; Single track format
Select_Disk_Message     equ     0ADC1h


IFNDEF DBLSPACE_HOOKS
DBLSPACE_HOOKS		equ	1
ENDIF
  

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\forinit.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;


;*****************************************************************************
;*****************************************************************************
;UTILITY NAME: FORMAT.COM
;
;MODULE NAME: FORINIT.SAL
;
;
;
; Ŀ
;  Main_Init 
; 
;   
;   Ŀ     Ŀ
;   ôInit_Input_Output´Preload_Messages
;       
;   			    Ŀ   Ŀ
;   			    ôCheck_For_FS_Switch´Parse_For_FS_Switch
;   			      
;   			    			    Ŀ
;   			    			    EXEC_FS_Format
;   			    			     
;   			    Ŀ   Ŀ
;   			    Parse_Command_Line ĴInterpret_Parse
;   			        
;   Ŀ Ŀ
;   ôValidate_Target_Drive´Check_Target_Drive
;   ٳ
;   			    Ŀ
;   			    ôCheck_For_Network
;   			    
;   			    Ŀ
;   			    Check_Translate_Drive
;   			     
;   Ŀ
;   Hook_CNTRL_C
;    
;
;
; Change List: AN000 - New code DOS 3.3 spec additions
;	       AC000 - Changed code DOS 3.3 spec additions
;*****************************************************************************
;*****************************************************************************

;
;---------------------------------------------------------------------------
;
; M024 : B#5495. Added "Insufficient memory" message when FORMAT cannot
;		allocate memory for FAT, Directory... etc. Reclaimed
;		the msgBadDrive which was not being used. Removed the
;		unwanted EXTRN msgBadDrive. 
;
; 08/05/91 MD   Removed M030 changes.
;
;---------------------------------------------------------------------------
;

data	segment public para 'DATA'


Command_Line db NO
PSP_Segment dw	0

;These should stay togather
; ---------------------------------------
FS_String_Buffer db 13 dup(" ")
FS_String_End db "FMT.EXE",0
Len_FS_String_End equ $ - FS_String_End

;----------------------------------------

Vol_Label_Count  db 80h 			;max. string length
Vol_Label_Len	 db 00h 			;len. entered
Vol_Label_Buffer db 80h dup(0)
Vol_Label_Buffer_Length equ $ - Vol_Label_Buffer

Command_Line_Buffer db 80h dup(0)
Command_Line_Length equ $ - Command_Line_Buffer
Fatal_Error db	0

Command_Old_Ptr dw	?

DriveAMState	dd	0		; target drive automount bit mask

data	ends

code	segment public para 'CODE'
	assume	cs:code,ds:data,es:data
code	ends

;
;*****************************************************************************
; Include files
;*****************************************************************************
;

.xlist
include bpb.inc
INCLUDE FORCHNG.INC
INCLUDE FORMACRO.INC
INCLUDE SYSCALL.INC
INCLUDE IOCTL.INC
INCLUDE FOREQU.INC
INCLUDE FORPARSE.INC
INCLUDE FORSWTCH.INC

;INCLUDE VERSION.INC				;M032


.list

;
;*****************************************************************************
; Public Data
;*****************************************************************************
;

						; M033
						; Why declare variables BEFORE
						; include files?!
data	segment public para 'DATA'

;
;*****************************************************************************
; External Data Declarations
;*****************************************************************************
;

	Extrn	SwitchMap:Word
	Extrn	SwitchMap2:Word
	Extrn	ExitStatus:Byte
	Extrn	DriveToFormat:Byte
	Extrn	DriveLetter:Byte
	Extrn	TranSrc:Byte
	Extrn	TrackCnt:Word
	Extrn	NumSectors:Word
	Extrn	SecPerClus:byte
	Extrn	BIOSFile:Byte
	Extrn	CommandFile:Byte
	Extrn	MsgNeedDrive:Byte
	Extrn	MsgBadVolumeID:Byte
;	Extrn	MsgBadDrive:Byte		; M024
	Extrn	MsgAssignedDrive:Byte
	Extrn	MsgNetDrive:Byte
	Extrn	MsgInvZDrive:Byte
	Extrn	msgOptions:Byte			; formsg.inc
	Extrn	msgDblspaceDrv:Byte
	Extrn	msgDblspaceHost:Byte
	Extrn	msgCrLf:Byte
	Extrn	MSG_OPTIONS_LAST:Abs
        Extrn   MSG_OPTIONS_SKIP1:Abs
        Extrn   MSG_OPTIONS_SKIP2:Abs
	Extrn	Parse_Error_Msg:Byte
	Extrn	Extended_Error_Msg:Byte
	Extrn	SizeMap:Byte
	Extrn	MsgSameSwitch:Byte
	Extrn	Org_AX:word			;AX on prog. entry
	Extrn	DeviceParameters:Byte
	Extrn	FAT_Flag:Byte
	Extrn	Sublist_MsgParse_Error:Dword

        Extrn   AlignCount:Word

	EXTRN	EXIT_FATAL		:ABS
        extrn   EXIT_NO                 :ABS

Public	CMCDDFlag

CMCDDFlag		DB	?

data	ends


	Public	FS_String_Buffer
	Public	Command_Line
	Public	Fatal_Error
	Public	Vol_Label_Count
	Public	Vol_Label_Buffer
	Public	PSP_Segment
	Public	Command_Old_Ptr


;
;*****************************************************************************
; Public Routines
;*****************************************************************************
;


	Public	Main_Init

code	segment public	para	'CODE'

;
;*****************************************************************************
; External Routine Declarations
;*****************************************************************************
;

	Extrn	Main_Routine:Near
	Extrn	SysLoadMsg:Near
	Extrn	Get_11_Characters:Near
	Extrn	ControlC_Handler:Near
	Extrn	SysDispMsg:Near
	Extrn	SysLoadMsg:Near
	Extrn	Yes?:Near

;No more SAFE module
;	Extrn	Hook_INT_24:Near		;*Set fatal error handler
;	Extrn	Int_24_Handler:Near		;*Fatal error int handler


IF FSExec					;/FS: conditional assembly

	Extrn	EXEC_FS_Format:Near

ENDIF						;/FS: conditional assembly end

	Extrn	GetDeviceParameters:Near

;*****************************************************************************
;Routine name:	Main_Init
;*****************************************************************************
;
;Description: Main control routine for init section
;
;Called Procedures: Message (macro)
;		    Check_DOS_Version
;		    Init_Input_Output
;		    Validate_Target_Drive
;		    Hook_CNTRL_C
;
;Input: None
;
;Output: None
;
;Change History: Created	5/1/87	       MT
;
;Psuedocode
; ---------
;
;	Get PSP segment
;	Fatal_Error = NO
;	Setup I/O (CALL Init_Input_Output)
;	IF !Fatal_Error
;	   Check target drive letter (CALL Validate_Target_Drive)
;	   IF !Fatal_Error
;	      Set up Control Break (CALL Hook_CNTRL_C)
;	      IF !Fatal_Error
;		 CALL Main_Routine
;	      ENDIF
;	   ENDIF
;	ENDIF
;	Exit program
;*****************************************************************************

Procedure Main_Init


	Set_Data_Segment		;Set DS,ES to Data segment
	DOS_Call GetCurrentPSP		;Get PSP segment address
	mov	PSP_Segment,bx		;Save it for later
	mov	Fatal_Error,No		;Init the error flag
	call	Init_Input_Output	;Setup messages and parse
	cmp	Fatal_Error,Yes 	;Error occur?

	JE	$$IF1			;Nope, keep going
	call	Validate_Target_Drive	;Check drive letter
	cmp	Fatal_Error,Yes		;Error occur?

	JE	$$IF2				;Nope, keep going

	call	Hook_CNTRL_C		;Set CNTRL -Break hook

;No more SAFE module			;*RUP - 10/09/89
;	call	Hook_Int_24		;*Set fatal error handler
					;*jh

	cmp	Fatal_Error,Yes		;Error occur?

	JE	$$IF3			;Nope, keep going
	jmp	SHORT End_Main_Init	;Go do the real program
$$IF3:
$$IF2:
$$IF1:
	mov	al,ExitStatus		;Get Errorlevel
	DOS_Call Exit			;Exit program
	int	20h			;If other exit fails

End_Main_Init:
	ret
Main_Init endp


;***	Check_For_Dblspace -- see if target drive is compressed, error if so
;
;	entry:
;	   DriveToFormat == 0 based drive number
;
;	exit:
;	   Fatal_Error == YES if it is
;          ExitStatus == EXIT_NO

	public	Check_For_Dblspace

Check_For_Dblspace	proc	near

	push	es

	call	IsDblspaceLoaded	; See if DblSpace installed
	jz	@f
	jmp	short Check_For_Dblspace_exit

@@:
	; The DblSpace driver is installed.  Try to auto[UN]mount the
	; drive so we know what's currently there.  The user may have
	; switched disks and not touched the drive yet so the mounted/
	; unmounted state might be wrong.
	;
	; Note: the Get DPB call is made even if automount support is
	; not enabled for the target drive because it will force the
	; unmounting of a manually mounted disk.

	call	RestoreAutoMountState	; allow automounting

	mov	ax, 3524h		; Save current critical error
	int	21h			;   handler address on stack
	push	es
	push	bx

	push	ds			; Set critical error handler to
	mov	ax, 2524h		;   fail all errors.  This is
	mov	dx, cs			;   to catch errors like no disk
	mov	ds, dx			;   in drive or a completely
	mov	dx, offset crit_hndlr	;   unformatted disk.
	int	21h
	pop	ds

    ; NOTE that the following does NOT need to be changed to GetExtendedDPB
    ;	because the media check is done as part of looking at the drive
    ;	letter input. The fact that a AH=32h is invalid on a BigFAT drive
    ;	isn't done till after the media validation is performed.

	push	ds			; Make the undoc'd Get DPB call.
	mov	ah, 32h 		;   This forces a media check of the
	mov	dl, DriveToFormat	;   drive which is just what we need
	inc	dl			;   to auto[UN]mount.  We don't care
	int	21h			;   if it works or not.
	pop	ds

	pop	dx			; Restore prior Int 24h handler
	pop	ax			;   from address on stack
	push	ds
	mov	ds, ax
	mov	ax, 2524h
	int	21h
	pop	ds

	call	DisableAutoMountState	; Disable further automount attempts
					;   for speed
	mov	al, DriveToFormat
	call	IsDblSpaceDisk		; compressed volume?
	jnz	cfd_is_compressed	;  yes, tell user 2 use dblspace/format

	; The target is not a DblSpace compressed drive, but it might be
	; a host for 1 or more compressed drives.  Get DblSpace drive map
	; info for each possible drive letter and see if any compressed
	; drives are hosted on the format target drive.

	xor	dx, dx			; zero based drive numbers
cfd_chk_host:
	mov	ax, 4a11h		; DblSpace ID
	mov	bx, 1			; get drive map info call
	int	2fh
	test	bl, 80h 		; is this a compressed drive?
	jz	cfd_nxt_host

	and	bl, 7fh 		; Yes, is it hosted on format target?
	cmp	bl, DriveToFormat
	je	cfd_is_host		;   yup, go tell user

cfd_nxt_host:
	inc	dl			; next drive to check
	cmp	dl, 26
	jb	cfd_chk_host
	jmp	short Check_For_Dblspace_exit

cfd_is_host:
	mov	al, DriveToFormat		; tell user target is a host
	Message msgDblspaceHost
	jmp	short cfd_error

cfd_is_compressed:
	mov	al,DriveToFormat		; tell user to use dblspace/format
	Message msgDblspaceDrv		;   for this drive

cfd_error:
	mov	Fatal_Error,YES 	; terminate format
	mov	ExitStatus,EXIT_NO

Check_For_Dblspace_exit:
	pop	es
	ret

	; Critical error handler for Get DPB call above.

crit_hndlr:
	mov	al, 3			; Always fail the call
	iret				;   and return to MS-DOS

Check_For_Dblspace	endp


;***	IsDblSpaceLoaded -- Check if DblSpace driver is around
;
; Entry: none
;
; Exit:  Z flag set if DblSpace IS loaded
;
; Uses:  AX, BX, Flags & whatever else the driver changes

	public	IsDblSpaceLoaded

IsDblspaceLoaded proc	near

	mov	ax, 4A11h		; DblSpace ID
	xor	bx, bx			; 0 = version check
	int	2Fh
	or	ax, ax			; Installed if AX == 0
	jnz	idl_exit		;   and BX == 'DM'
	cmp	bx, 'DM'
idl_exit:
	ret

IsDblSpaceLoaded endp


;***	IsDblSpaceDisk - Check is DriveToFormat is a DblSpace Compressed drive
;
; Entry: AL - zero based drive # to check
;
; Exit:  Z flag set if NOT a dblspace disk
;
; Uses:  AX, BX, Flags & whatever else the driver changes

	public	IsDblSpaceDisk

IsDblSpaceDisk	proc	near

	push	ax			; Can't be a mounted CVF if
	call	IsDblSpaceLoaded	;   there's no driver installed
	pop	ax
	jz	idd_loaded

	xor	ax, ax			; No driver, set Z flag
	ret

idd_loaded:
	mov	dl, al			; DL = drive #
	mov	ax, 4A11h		; DblSpace ID
	mov	bx, 1			; 1 = Get Drive Map
	int	2Fh
	test	bl, 80h 		; this bit set if compressed drive
	ret

IsDblSpaceDisk	endp


;***	GetAutoMountState -- get & save current DblSpace automount state
;
; Entry: AL - zero based drive # to get AutoMount info for
;
; Exit: DriveAMState has bitmask for target drive if automounting is
;	currently enabled.  DriveAMState = 0 if DBLSPACE.BIN is not loaded
;	or automounting is currently disabled for target drive.
;
; Uses:  AX, BX, CX, DX, Flags & whatever else the driver changes

	public	GetAutoMountState
	assume	ds:nothing, es:nothing

GetAutoMountState proc	near

	push	ds			; save caller's DS
	mov	bx, data		; set DS = data
	mov	ds, bx
	assume	ds:data

	push	ax			; save drive # around call
	call	IsDblSpaceLoaded	; no automount state if no DblSpace
	pop	ax
	jnz	gam_exit

	xor	ah, ah			; ax = zero based drive #

	mov	cx, ax			; cx = zero based drive #
	mov	ax, 1
	cwd				; dx:ax = 1

	; Create mask for drive in dx:ax.  Bit 0 = A:, bit 1 = B:, etc

	jcxz	gam_got_mask		; mask set if doing drive A:

gam_set_mask:
	shl	ax, 1			; shift 1 bit to drive position
	rcl	dx, 1
	loop	gam_set_mask

gam_got_mask:

	push	ax			; save drive mask on stack
	push	dx

	mov	ax, 4A11h		; DBLSPACE.BIN Int 2Fh ID
	mov	bx, 11			; GetAutoMountDrives service
	int	2Fh			;   returns drive map in cx:dx
	or	ax, ax			;   ax == 0 if successful

	pop	bx			; target drive mask to bx:ax
	pop	ax

	jnz	gam_exit		; done if GetAutoMountDrives failed

	and	cx, bx			; is target drive one of the automount
	and	dx, ax			;   drives?
	or	dx, cx
	jz	gam_exit		; nothing else to do if not...

	mov	word ptr DriveAMState[0], ax	; save AM drive mask for target
	mov	word ptr DriveAMState[2], bx

gam_exit:
	pop	ds
	assume	ds:nothing
	ret

GetAutoMountState endp


;***	DisableAutoMountState -- disable automounting for target drive
;
; Entry: DriveAMState has bitmask for target drive, 0 if initially disabled.
;
; Exit: Automounting is disabled for target drive
;
; Uses:  AX, BX, CX, DX, Flags & whatever else the driver changes

	public	DisableAutoMountState
	assume	ds:nothing, es:nothing

DisableAutoMountState proc near

	push	ds				; save caller's DS
	mov	ax, data			; set DS = data
	mov	ds, ax
	assume	ds:data

	xor	ax, ax				; dx:ax = 0 will cause disable
	xor	dx, dx
	jmp	short SetAutoMountState

DisableAutoMountState endp


;***	RestoreAutoMountState -- restore initial automounting state for target
;
; Entry: DriveAMState has bitmask for target drive, 0 if initially disabled.
;
; Exit: Automout state is restored to initial state for target drive.
;
; Uses:  AX, BX, CX, DX, Flags & whatever else the driver changes

	public	RestoreAutoMountState
	assume	ds:nothing, es:nothing

RestoreAutoMountState proc near

	push	ds				; save caller's DS
	mov	ax, data			; set DS = data
	mov	ds, ax
	assume	ds:data

	mov	ax, word ptr DriveAMState[0]	; loading this will cause
	mov	dx, word ptr DriveAMState[2]	;   enable

SetAutoMountState label near

	mov	cx, word ptr DriveAMState[0]	; nothing to do if was disabled
	or	cx, word ptr DriveAMState[2]	;   when started
	jz	sam_exit

	push	ax			; save target drive mask or 0
	push	dx

	mov	ax, 4A11h		; DBLSPACE.BIN Int 2Fh ID
	mov	bx, 11			; GetAutoMountDrives service
	int	2Fh			;   returns drive map in cx:dx
	or	ax, ax			;   ax == 0 if successful
	jnz	sam_exit_pop		; exit if GetAutoMountDrives failed

	mov	ax, word ptr DriveAMState[0]	; turn off the mask bit
	not	ax				;   for target drive in
	and	dx, ax				;   cx:dx
	mov	ax, word ptr DriveAMState[2]
	not	ax
	and	cx, ax

	pop	bx			; target drive mask or 0 to bx:ax
	pop	ax

	or	cx, bx			; Set bit for target drive if
	or	dx, ax			;   restoring state

	mov	ax, 4A11h		; DBLSPACE.BIN Int 2Fh ID
	mov	bx, 10			; SetAutoMountDrives service
	int	2Fh			;   accepts drive map in cx:dx

sam_exit:
	pop	ds
	assume	ds:nothing
	ret

sam_exit_pop:
	pop	ax			; clear stack and exit
	pop	ax
	jmp	short sam_exit

RestoreAutoMountState endp


;*****************************************************************************
;Routine name: Init_Input_Output
;*****************************************************************************
;
;Description: Initialize messages, Parse command line, allocate memory as
;	      needed. If there is a /FS switch, go handle it first as
;	      syntax of IFS format may be different from FAT format.
;
;Called Procedures: Preload_Messages
;		    Parse_For_FS_Switch
;		    Parse_Command_Line
;
;Change History: Created	4/1/87	       MT
;
;Input: PSP command line at 81h and length at 80h
;	Fatal_Error  = No
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	Load messages (CALL Preload_Messages)
;	IF !Fatal_Error
;	   See if EXEC another file system (CALL Parse_For_FS_Switch)
;	   IF !FATAL_Error (in this case means FS was found and exec'd)
;	      CALL Parse_Command_Line
;	      IF !Fatal_Error
;		 CALL Interpret_Parse
;	      ENDIF
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************

Procedure Init_Input_Output

	Set_Data_Segment			;Set DS,ES to Data segment
	call	Preload_Messages		;Load up message retriever

IF FSExec					;/FS: conditional assembly

	cmp	Fatal_Error,YES 		;Quit?
	JE	$$IF7
	call	Check_For_FS_Switch		;Specify FS other than FAT?

ENDIF						;/FS: conditional assembly end

	cmp	Fatal_Error,YES			;drive is invalid for format?
	JE	$$IF8
	call	Parse_Command_Line		;Parse in command line input
	cmp	Fatal_Error,YES			; Quit?
	JE	$$IF9

	call	Determine_FAT_Non_FAT		;see if drive was non_FAT
	call	Check_For_Invalid_Drive		;Drive joined?
$$IF9:
$$IF8:

IF FSExec					;/FS: conditional assembly

$$IF7:

ENDIF						;/FS: conditional assembly end
	ret

Init_Input_Output endp

;*****************************************************************************
;Routine name: Preload_Messages
;*****************************************************************************
;
;Description: Preload messages using common message retriever routines.
;
;Called Procedures: SysLoadMsg
;
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	Preload All messages (Call SysLoadMsg)
;	IF error
;	   Display SysLoadMsg error message
;	   Fatal_Error = YES
;	ENDIF
;	ret
;*****************************************************************************

Procedure Preload_Messages

	Set_Data_Segment			;Set DS,ES to Data segment
	call	SysLoadMsg			;Preload the messages

	JNC	$$IF13				;Error?
	call	SysDispMsg			;Display preload msg
	mov	Fatal_Error, YES		;Indicate error exit

$$IF13:
	ret

Preload_Messages endp

;*****************************************************************************

IF FSExec					;/FS: conditional assembly

;*****************************************************************************
;Routine name: Check_For_FS_Switch
;*****************************************************************************
;
;Description: Parse to see if /FS switch entered, and if so, go EXEC the
;	      asked for file system. Set Fatal_Error = YES if FS found
;	      If we do find /FS, we need to build a string of xxxxxfmt.exe,0
;	      where xxxxx is the first 5 characters or less of /FS:xxxxx
;
;Called Procedures: Parse_For_FS_Switch
;		    EXEC_FS_Format
;
;Change History: Created	6/21/87 	MT
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 Exit_Status set
;
;Psuedocode
;----------
;
;	Parse for /FS switch (CALL Parse_For_FS_Switch)
;	IF !FATAL_ERROR
;	   IF /FS found
;	      Point at what was entered on /FS:xxxxx
;	      DO
;	      LEAVE end of entered string
;		Got good char, move into path
;	      ENDDO already got 5 chars (max in xxxxxfmt.exe)
;	      Tack on the rest of the string  (fmt.exe,0)
;	      Go exec the needed format (CALL EXEC_FS_Format)
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************

Procedure Check_For_FS_Switch

	Set_Data_Segment			;Set DS,ES to Data segment
	call	Parse_For_FS_Switch		;See if /FS entered
	cmp	Fatal_Error,YES 		;Bad stuff entered??

	JE	$$IF15				;Nope, cruise onward
	cmp	Switch_String_Buffer.Switch_Pointer,offset Switch_FS_Control.Keyword

	JNE	$$IF16				;We got the switch
	mov	Switch_FS_Control.Keyword,20h	;remove switch from table
	test	SwitchMap,Switch_FS		;Have this already?

	JNZ	$$IF17				;Nope
	push	ds				;Get addressibility
	pop	es

	assume	ds:nothing,es:data

						;Get the entered FS
	mov	ax,Switch_String_Buffer.Switch_String_Seg
	mov	ds,ax
	mov	si,es:Switch_String_Buffer.Switch_String_Off
	mov	cx,FS_String_Max_Length
	mov	di,offset es:FS_String_Buffer

$$DO18: 					;Move whatever user entered
	cmp	byte ptr [si],ASCIIZ_End	;End of the string?

	JE	$$EN18				;Yep
	movsb					;Put character in buffer
	dec	cx				;Dec character counter
	cmp	cx,0				;Nope, reached max # chars?

	JNE	$$DO18				;Yes
$$EN18:
	Set_Data_Segment			;Set DS,ES to Data segment
	mov	cx,Len_FS_String_End		;Tack the FMT.EXE onto it
	mov	si,offset es:FS_String_End	;DI still points at string
	rep	movsb				;We now have Asciiz path!
	call	EXEC_FS_Format			;Go try to EXEC it.....

	JMP	SHORT $$EN17
$$IF17:
	Message msgSameSwitch
	mov	Fatal_Error,Yes

$$EN17:
$$IF16:
$$IF15:
	ret

Check_For_FS_Switch endp

;*****************************************************************************
;Routine name: Parse_For_FS_Switch
;*****************************************************************************
;
;Description: Copy the command line. Parse the new command line (Parse routines
;	      destroy the data being parsed, so need to work on copy so that
;	      complete command line can be passed to child format).
;	      The only thing we care about is if the /FS: switch exists, so
;	      parse until  end of command line found. If there was an error,
;	      and it occurred on the /FS switch, then give parse error,
;	      otherwise ignore the parse error, because it might be something
;	      file system specific that doesn't meet DOS syntax rules. Also
;	      check for drive letter, as it is alway required.
;
;Called Procedures: Message (macro)
;		    SysLoadMsg
;		    Preload_Error
;		    SysParse
;
;Change History: Created	5/1/87	       MT
;
;Input: Command line at 80h in PSP
;	   Fatal_Error = NO
;	   PSP_Segment
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;	Copy command line to buffer
;	DO
;	   Parse command line (Call SysParse)
;	LEAVE end of parse
;	ENDDO found /FS
;	IF drive letter not found (This assumes drive letter before switches)
;	   Tell user
;	   Fatal_Error = YES
;	ENDIF
;	ret
;*****************************************************************************

Procedure Parse_For_FS_Switch

	Set_Data_Segment			;Set DS,ES to Data segment
	mov	Drive_Letter_Buffer.Drive_Number,Init
	mov	ds,PSP_Segment			;Get segment of PSP
	assume	ds:nothing

	mov	si,Command_Line_Parms		;Point at command line
	mov	di,offset data:Command_Line_Buffer ;Where to put a copy of it
	mov	cx,Command_Line_Length		;How long was input?
	repnz	movsb				;Copy it

	Set_Data_Segment			;Set DS,ES to Data segment
	xor	cx,cx
	xor	dx,dx				;Required for SysParse call
	mov	si,offset Command_Line_Buffer	;Pointer to parse line
	mov	di,offset Switch_FS_Table	;Pointer to control table

$$DO25: 					;Setup parse call
	call	SysParse			;Go parse
	cmp	ax,End_Of_Parse			;Check for end of parse

	JE	$$EN25				;Exit if it is end, or
	cmp	ax,Operand_Missing		; exit if positional missing

	JE	$$EN25				;In other words, no drive letter
	cmp	Switch_String_Buffer.Switch_Pointer, offset Switch_FS_Control.Keyword

	JNE	$$DO25				;Exit if we find /FS

$$EN25: 					;Check for drive letter found
	cmp	Drive_Letter_Buffer.Drive_Type,Type_Drive

	JE	$$IF28				;Did we not find one?
	MESSAGE msgNeedDrive			;Must enter drive letter
	mov	Fatal_Error,Yes			;Indicate error on exit

$$IF28:
	ret

Parse_For_FS_Switch endp

ENDIF						;/FS: conditional assembly end


;*****************************************************************************
;Routine name: Parse_Command_Line
;*****************************************************************************
;
;Description: Parse the command line. Check for errors, and display error and
;		 exit program if found. Use parse error messages except in case
;		 of no parameters, which has its own message
;
;Called Procedures: Message (macro)
;		    SysParse
;		    Interpret_Parse
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;	PSP_Segment
;
;Output: Fatal_Error = YES/NO
;
;
;Psuedocode
;----------
;
;	Assume Fatal_Error = NO on entry
;	SEARCH
;	EXITIF Fatal_Error = YES,OR  (This can be set by Interpret_Parse)
;	   Parse command line (CALL SysParse)
;	EXITIF end of parsing command line
;	   Figure out last thing parsed (Call Interpret_Parse)
;	ORELSE
;	   See if parse error
;	LEAVE parse error,OR
;	   See what was parsed (Call Interpret_Parse)
;	LEAVE if interpret error such as bad volume label
;	ENDLOOP
;	   Display parse error message and print error operand
;	   Fatal_Error = YES
;	ENDSRCH
;	ret
;*****************************************************************************

Procedure Parse_Command_Line
	Set_Data_Segment			;Set DS,ES to Data segment
	push	ds
	mov	ds,PSP_Segment

	assume	ds:nothing,es:data

	xor	cx,cx				;Parse table @DI
	xor	dx,dx				;Parse line @SI
	mov	si,Command_Line_Parms		;Pointer to parse line
	mov	word ptr es:Command_Old_Ptr,si
	mov	di,offset es:Command_Line_Table ;Pointer to control table

$$DO30: 					;Loop until all parsed
	cmp	es:Fatal_Error,Yes		;Interpret something bad?

	JE	$$LL31				;If so, don't parse any more
	call	SysParse			;Go parse
	cmp	ax,End_Of_Parse			;Check for end of parse

	JNE $$IF30				;Is it?

$$LL31: 					;All done
	JMP	SHORT $$SR30			;Not end

$$IF30:
	cmp	ax,0				;Check for parse error

	JNE	$$EN30				;Stop if there was one
	call	Interpret_Parse 		;Go find what we parsed
	mov	word ptr es:Command_Old_Ptr,si

	JMP	SHORT $$DO30			;Parse error, see what it was

$$EN30:
	mov	byte ptr ds:[si],0
	push	di
	push	ax
	mov	di,offset es:Sublist_MsgParse_Error
	mov	ax,word ptr es:Command_Old_Ptr
	mov	word ptr es:[di+2],ax
	mov	word ptr es:[di+4],ds
	pop	ax
	pop	di
	PARSE_MESSAGE				;Display parse error
	mov	es:Fatal_Error,YES		;Indicate death!

$$SR30:
	pop	ds
	ret

Parse_Command_Line endp

;*****************************************************************************
;Routine name: Interpret_Parse
;*****************************************************************************
;
;Description: Set the SwitchMap  field with the switches found on the
;	      command line. Get the drive letter. /FS will be handled before
;	      here, will not be seen in this parse or accepted. Also, if /V
;	      see if volume label entered and verify it is good, setting up
;	      FCB for later create
;
;Called Procedures: Get_11_Characters
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: SwitchMap set
;	 DriveLetter set
;	 DriveNum set A=0,B=1 etc...
;	 Command_Line = YES/NO
;	 Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	IF Drive letter parsed
;	DriveToFormat = Parsed drive number -1
;	DriveLetter = (Parsed drive number - 1) +'A'
;	ENDIF
;	IF /1
;	  or	SwitchMap,Switch_1
;	ENDIF
;	IF /4
;	  or	SwitchMap,Switch_4
;	ENDIF
;	IF /8
;	  or	SwitchMap,Switch_8
;	ENDIF
;	IF /S
;	  or	SwitchMap,Switch_S
;	ENDIF
;	IF /BACKUP
;	  or	SwitchMap,Switch_BACKUP
;	ENDIF
;	IF /B
;	  or	SwitchMap,Switch_B
;	ENDIF
;	IF /T
;	  or	SwitchMap,Switch_T
;	  TrackCnt = entered value
;	ENDIF
;	IF /N
;	  or	SwitchMap,Switch_N
;	  NumSectors = entered value
;	ENDIF
;	IF /SELECT
;	  or	SwitchMap,Switch_SELECT
;	ENDIF
;	IF /V
;	  or	SwitchMap,Switch_V
;	  IF string entered
;	     Build ASCIIZ string for next call (CALL Build_String)
;	     Verify DBCS and setup FCB (CALL Get_11_Characters)
;	     Command_Line = YES
;		IF error
;		  Invalid label message
;		  Fatal_Error = YES
;		ENDIF
;	  ENDIF
;	ENDIF
;	IF /AUTOTEST
;	  or	SwitchMap,Switch_AUTOTEST
;	ENDIF
;
;	IF /F
;	  or	SwitchMap,Switch_F
;	  or	Size_Map,Item_Tag
;	ENDIF
;	IF /Z	(only if assembled)
;	  or	SwitchMap,Switch_Z
;	ENDIF
;	ret
;*****************************************************************************

; 11-Oct-93: Force /C switch if format size selected from command line
;	     (/F:x /T:x /N:x /1 /4 /8).  This prevents load_old_fat routine
;	     from trying to read wrong FAT size for the disk being formatted
;	     and also prevents it from changing the format size in the
;	     DetermineExistingFormat... subroutine.

Procedure Interpret_Parse

	push	ds				;Save segment
	push	si				;Restore SI for parser
	push	cx
	push	di

	Set_Data_Segment			;Set DS,ES to Data segment

; See if user put /? on command line.

	cmp	Switch_Buffer.Switch_Pointer,offset Switch_?_Control.Keyword
	jne	@F				; skip if not on
	call	Display_Options			; give the message
	mov     Fatal_Error, Yes		; flag get out now
	jmp	Interpret_Parse_Exit		;  and leave this routine
@@:
	;Have drive letter?

	cmp	byte ptr Drive_Letter_Buffer.Drive_Type,Type_Drive

	JNE	$$IF36				;Yes, save info
						;Get drive entered
	mov	al,Drive_Letter_Buffer.Drive_Number
	dec	al				;Make it 0 based
	mov	DriveToFormat,al			; "  "	  "  "
	add	al,'A'				;Make it a drive letter
	mov	DriveLetter,al			;Save it

$$IF36:
	cmp	Switch_Buffer.Switch_Pointer,OFFSET Switch_U_Control.Keyword
	jne	@F
	mov	Switch_U_Control.Keyword,20h
	or	SwitchMap,Switch_U

@@:
	cmp	Switch_Buffer.Switch_Pointer,OFFSET Switch_Q_Control.Keyword
	jne	@F
	mov	Switch_Q_Control.Keyword,20h
	or	SwitchMap,Switch_Q

@@:
ifdef NEC_98
	;;	/1 /4 /8 not support.
else
	cmp	Switch_Buffer.Switch_Pointer,OFFSET Switch_1_Control.Keyword
	JNE	$$IF38
	mov	Switch_1_Control.Keyword,20h	;remove switch from table
	or	SwitchMap,Switch_1
	or	SwitchMap2,Switch2_C		;don't save old FAT contents

$$IF38:
	cmp	Switch_Buffer.Switch_Pointer,OFFSET Switch_4_Control.Keyword
	JNE	$$IF40
	mov	Switch_4_Control.Keyword,20h	;remove switch from table
	or	SwitchMap,Switch_4
	or	SwitchMap2,Switch2_C		;don't save old FAT contents

$$IF40:
	cmp	Switch_Buffer.Switch_Pointer,offset Switch_8_Control.Keyword
	JNE	$$IF42
	mov	Switch_8_Control.Keyword,20h	;remove switch from table
	or	SwitchMap,Switch_8
	or	SwitchMap2,Switch2_C		;don't save old FAT contents

$$IF42:
endif
	cmp	Switch_Buffer.Switch_Pointer,offset Switch_S_Control.Keyword
	JNE	$$IF44
	mov	Switch_S_Control.Keyword,20h	;remove switch from table
	or	SwitchMap,Switch_S

$$IF44:
	cmp	Switch_Buffer.Switch_Pointer,offset Switch_Backup_Control.Keyword
	JNE	$$IF46
	mov	   Switch_Backup_Control.Keyword,20h ;remove switch from table
	or	   SwitchMap,Switch_Backup

$$IF46:
	cmp	Switch_Buffer.Switch_Pointer,offset Switch_Select_Control.Keyword
	JNE	$$IF48
	mov	Switch_Select_Control.Keyword,20h ;remove switch from table
	or	SwitchMap,Switch_Select

$$IF48:
;ifdef OPKBLD
	cmp	Switch_Buffer.Switch_Pointer,offset Switch_B_Control.Keyword
        JNE     $$IF50A
	mov	Switch_B_Control.Keyword,20H
	or	SwitchMap,Switch_B

$$IF50A: ; sivaraja 4/22/00 added for /A
        cmp     Switch_Num_Buffer.Switch_Num_Pointer,offset Switch_A_Control.Keyword
        JNE     $$IF50
        mov     Switch_A_Control.Keyword, 20H
        mov     Switch_Num_Buffer.Switch_Num_Pointer,0 ;Init for next switch
        or      SwitchMap2, Switch2_A
        mov     ax, Switch_Num_Buffer.Switch_Number_Low
        mov     AlignCount, ax
;endif   ;OPKBLD

$$IF50:
	cmp	Switch_Buffer.Switch_Pointer,OFFSET Switch_C_Control.Keyword
	jne	@F
	mov	Switch_C_Control.Keyword,20h
	or	SwitchMap2,Switch2_C

@@:
	cmp	Switch_Num_Buffer.Switch_Num_Pointer, offset es:Switch_T_Control.Keyword

	JNE	$$IF52
	mov	Switch_T_Control.Keyword,20h ;remove switch from table
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0 ;Init for next switch
	test	SwitchMap,Switch_T		;Don't allow if switch already
	JNZ	$$IF53				; entered

	or	SwitchMap,Switch_T
	or	SwitchMap2,Switch2_C		;don't save old FAT contents
						;Get entered tracks
	mov	ax,Switch_Num_Buffer.Switch_Number_Low
	mov	TrackCnt,ax			;1024 or less, so always dw
	JMP SHORT $$EN53

$$IF53:
	Message msgSameSwitch
	mov	Fatal_Error,Yes

$$EN53:
$$IF52:
	cmp	Switch_Num_Buffer.Switch_Num_Pointer,  offset Switch_N_Control.Keyword
	JNE	$$IF57
	mov	Switch_N_Control.Keyword,20h ;remove switch from table
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0 ;Init for next switch
	test	SwitchMap,Switch_N		;Make sure switch not already

	JNZ	$$IF58				; entered
	or	SwitchMap,Switch_N
	or	SwitchMap2,Switch2_C		;don't save old FAT contents
	mov	ax,Switch_Num_Buffer.Switch_Number_Low ;Get entered tracks
	xor	ah,ah				;clear high byte
	mov	NumSectors,ax			;Save tracks per sector
	JMP SHORT $$EN58

$$IF58:
	Message msgSameSwitch
	mov	Fatal_Error,Yes

$$EN58:
$$IF57:

IF ShipDisk

	cmp	Switch_Num_Buffer.Switch_Num_Pointer,  offset Switch_Z_Control.Keyword
	JNE	$$IF57a
	mov	Switch_Z_Control.Keyword,20h ;remove switch from table
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0 ;Init for next switch
	test	SwitchMap,Switch_Z		;Make sure switch not already

	JNZ	$$IF58a 			; entered
	or	SwitchMap,Switch_Z
	mov	ax,Switch_Num_Buffer.Switch_Number_Low ;Get entered sec/clus
	mov	SecPerClus,al			;Save sector/clus value
	JMP SHORT $$EN58a

$$IF58a:
	Message msgSameSwitch
	mov	Fatal_Error,Yes

$$EN58a:
$$IF57a:

ENDIF
	cmp	Switch_String_Buffer.Switch_String_Pointer, offset Switch_V_Control.Keyword
	JNE	$$IF62				;If /v and haven't already done

	mov	   Switch_String_Buffer.Switch_String_Pointer,0 ;Init for next switch
	mov	   Switch_V_Control.Keyword,20h ;remove switch from table
	test	SwitchMap,Switch_V		; it - Only allow one /V entry

	JNZ	$$IF63
	or	SwitchMap,Switch_V	;Set /v indicator
	mov	ds,Switch_String_Buffer.Switch_String_Seg ;Get string address

	assume	ds:nothing

; M009 - Begin
;

	cld
	mov	cx,si				; Save end of /V parameter
	mov	si,es:Switch_String_Buffer.Switch_String_Off
	cmp	byte ptr ds:[si],None	;Is there a string there?

	jne	GotAString

	push	es
	
	mov	di,Command_Old_ptr
	sub	cx,di				; cx = length of whole /v

	mov	es,es:PSP_Segment
	
	mov	al,':'
	repnz	scasb
	pop	es

	push	es
	pop	ds
	assume	DS:DATA,ES:DATA
	jcxz	$$IF64

	mov	Vol_Label_Buffer,0	
	mov	Command_Line,YES
	jmp	short $$IF64
;	JE	$$IF64				;Yep
;M009 - End

GotAString:
	assume	DS:nothing
	mov	di,offset es:Vol_Label_Buffer ;Point at buffer to move string
	mov	cx,Label_Length+1		;Max length of string
	rep	movsb				;This will copy string & always
						; leave ASCIIZ end in buffer,
						; which is init'd to 13 dup(0)
	push	es
	pop	ds				;Set DS,ES to Data segment
	assume	DS:DATA,ES:DATA

	mov	si,offset Vol_Label_Buffer	;Point at string
	mov	Command_Line,YES		;Set flag indicating vol label
	call	Get_11_Characters		;Check DBCS and build FCB

	JNC	$$IF65				;Bad DBCS setup
	Message msgBadVolumeID		;Tell user
	mov	Fatal_Error,YES			;Indicate time to quit

$$IF65:
$$IF64:
	JMP	SHORT $$EN63
$$IF63:
	Message msgSameSwitch
	mov	Fatal_Error,Yes

$$EN63:
$$IF62:
ifdef NEC_98
;	/4 : 1.44MB
;	/M : 1.25MB
;	/5 : 1.2MB
;	/9 : 720KB
;	/6 : 640KB

	cmp	Switch_Buffer.Switch_Pointer, offset Switch_4_Control.Keyword
	JNE	@F
	mov	Switch_4_Control.Keyword,20h	;remove switch from table

						; clear ptr for next iteration
	mov	Switch_String_Buffer.Switch_Pointer,0
						;Init for next switch
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0
	mov	Switch_Buffer.Switch_Pointer,0	;
	test	SwitchMap2,Switch2_4		;

	JZ	SWITCH_4_OK			;
	JMP	$$IF76				;

SWITCH_4_OK :					;

	or	SwitchMap2,Switch2_4		;
	or	SwitchMap2,Switch2_C		;don't save old FAT contents
						; Indicate what size
	or	SizeMap,Size_1440
@@:
	cmp	Switch_Buffer.Switch_Pointer, offset Switch_M_Control.Keyword
	JNE	@F
	mov	Switch_M_Control.Keyword,20h	;remove switch from table

						; clear ptr for next iteration
	mov	Switch_String_Buffer.Switch_Pointer,0
						;Init for next switch
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0
	mov	Switch_Buffer.Switch_Pointer,0	;
	test	SwitchMap2,Switch2_M		;

	JZ	SWITCH_M_OK			;
	JMP	$$IF76				;

SWITCH_M_OK :					;

	or	SwitchMap2,Switch2_M		;
	or	SwitchMap2,Switch2_C		;don't save old FAT contents
						; Indicate what size
	or	SizeMap,Size_1250
@@:
	cmp	Switch_Buffer.Switch_Pointer, offset Switch_5_Control.Keyword
	JNE	@F
	mov	Switch_5_Control.Keyword,20h	;remove switch from table

						; clear ptr for next iteration
	mov	Switch_String_Buffer.Switch_Pointer,0
						;Init for next switch
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0
	mov	Switch_Buffer.Switch_Pointer,0	;
	test	SwitchMap2,Switch2_5		;
	JZ	$$IF70
	JMP	$$IF76				; reuses string buff each time
$$IF70:
	or	SwitchMap2,Switch2_5		;
	or	SwitchMap2,Switch2_C		;don't save old FAT contents
						; Indicate what size
	or	SizeMap,Size_1200
@@:
	cmp	Switch_Buffer.Switch_Pointer, offset Switch_9_Control.Keyword
	JNE	@F
	mov	Switch_9_Control.Keyword,20h	;remove switch from table

						; clear ptr for next iteration
	mov	Switch_String_Buffer.Switch_Pointer,0
						;Init for next switch
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0
	mov	Switch_Buffer.Switch_Pointer,0	;
	test	SwitchMap2,Switch2_9		;

	JZ	$$NO76				; reuses string buff each time
	JMP	$$IF76
$$NO76:
	or	SwitchMap2,Switch2_9		;
	or	SwitchMap2,Switch2_C		;don't save old FAT contents
						; Indicate what size
	or	SizeMap,Size_720
@@:
	cmp	Switch_Buffer.Switch_Pointer, offset Switch_6_Control.Keyword
	JNE	@F
	mov	Switch_6_Control.Keyword,20h	;remove switch from table

						; clear ptr for next iteration
	mov	Switch_String_Buffer.Switch_Pointer,0
						;Init for next switch
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0
	mov	Switch_Buffer.Switch_Pointer,0	;
	test	SwitchMap2,Switch2_6		;

;;;	JNZ	$$IF76				; reuses string buff each time
	jz	Sw6_ok
	jmp	$$IF76				; reuses string buff each time
Sw6_ok:
	or	SwitchMap2,Switch2_6		;
	or	SwitchMap2,Switch2_C		;don't save old FAT contents
						; Indicate what size
	or	SizeMap,Size_640
@@:
	cmp	Switch_Buffer.Switch_Pointer,offset Switch_P_Control.Keyword
	JNE	@F
	mov	Switch_P_Control.Keyword,20h ;remove switch from table
	or	SwitchMap2,Switch2_P
@@:
endif
	cmp	Switch_Buffer.Switch_Pointer, offset Switch_Autotest_Control.Keyword
	JNE	$$IF71
						;remove switch from table
	mov	Switch_Autotest_Control.Keyword,20h
	or	SwitchMap,Switch_Autotest

$$IF71:
	cmp	Switch_String_Buffer.Switch_Pointer, offset Switch_F_Control.Keyword
	JNE	$$IF75
	mov	Switch_F_Control.Keyword,20h	;remove switch from table

						; clear ptr for next iteration
	mov	Switch_String_Buffer.Switch_Pointer,0
						;Init for next switch
	mov	Switch_Num_Buffer.Switch_Num_Pointer,0
	test	SwitchMap,Switch_F		; it - do this because SysParse

	JNZ	$$IF76				; reuses string buff each time
	or	SwitchMap,Switch_F
	or	SwitchMap2,Switch2_C		;don't save old FAT contents
						; Indicate what size
	mov	al,Switch_String_Buffer.Switch_String_Item_Tag
	or	SizeMap,al
	JMP	SHORT $$EN76

$$IF76:
	Message msgSameSwitch
	mov	Fatal_Error,Yes
$$EN76:
$$IF75:
Interpret_Parse_Exit:

	pop	di				;Restore parse regs
	pop	cx
	pop	si
	pop	ds
	ret

Interpret_Parse endp

;*****************************************************************************
;Routine name: Display_Options
;*****************************************************************************
;
;Description: Display the options help message on standard output.
;
;Called Procedures: Message (macro)
;
;Change History: Created	5/2/90	       c-PaulB
;
;Input:  No value passed
;
;Output: No value returned
;
;*****************************************************************************

Procedure Display_Options

DO_Loop:
	Message	msgOptions			; display the options
	cmp	word ptr [msgOptions], MSG_OPTIONS_LAST	; last msg?
	je	DO_Done				; done if so
	inc	word ptr [msgOptions]		; else get next msg
        cmp     word ptr [msgOptions],MSG_OPTIONS_SKIP1
        je      SkipIt
        cmp     word ptr [msgOptions],MSG_OPTIONS_SKIP2
        jne     DO_Loop
SkipIt:
	inc	word ptr [msgOptions]		; Skip it
        cmp     word ptr [msgOptions],MSG_OPTIONS_SKIP1
        je      SkipIt
        cmp     word ptr [msgOptions],MSG_OPTIONS_SKIP2
        je      SkipIt
	jmp	short DO_Loop			;  and go do it

DO_Done:
	ret

Display_Options endp

;*****************************************************************************
;Routine name: Validate_Target_Drive
;*****************************************************************************
;
;Description: Control routine for validating the specified format target drive.
;	      If any of the called routines find an error, they will print
;	      message and terminate program, without returning to this routine
;
;Called Procedures: Check_Target_Drive
;		    Check_For_Network
;		    Check_Translate_Drive
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	CALL Check_Target_Drive
;	IF !Fatal_Error
;	   CALL Check_For_Network
;	   IF !Fatal_Error
;	      CALL Check_Translate_Drive
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************

Procedure Validate_Target_Drive

	call	Check_Target_Drive		;See if valid drive letter
	cmp	Fatal_Error,YES 		;Can we continue?
	JE	$$IF80				;No
	call	Check_For_Network		;See if Network drive letter
	cmp	Fatal_Error,YES			;Can we continue?
	JE	$$IF80				;No
	call	Check_Translate_Drive		;See if Subst, Assigned
	cmp	Fatal_Error,YES			;Can we continue?
	JE	$$IF80				;No
	cmp	SecPerClus,0			;Z switch given?
	je	$$IF80				;No
	call	Check_ValidZSwtch_Drive 	;See if valid for Z switch
$$IF80: 					;- Fatal_Error passed back
	ret

Validate_Target_Drive endp

;*****************************************************************************
;Routine name: Check_ValidZSwtch_Drive
;*****************************************************************************
;
;Description: Check to see if the specified drive is a valid drive for
;	      specification of the Z switch (it has to be a fixed disk).
;
;Called Procedures: Message (macro)
;
;Change History: Created	12/27/95 ARR
;
;Input: Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	See if drive removable (INT 21h, AX=4409h IOCtl)
;	IF error or removable - drive invalid
;	   Display Invalid drive for Z switch message
;	   Fatal_Error= YES
;	ENDIF
;	ret
;*****************************************************************************
Procedure Check_ValidZSwtch_Drive

	mov	bl,DriveToFormat		;Set up for call
	inc	bl				;A=1,B=2 for IOCtl call
	mov	al,08h				;See if drive is removable
	DOS_Call IOCtl

	JNC	$$IF89				;CY means invalid drive
$$IF92:
	Message MsgInvZDrive			;Print message

	mov	Fatal_Error,Yes			;Indicate error
	jmp	short $$IF90

$$IF89:
	cmp	al,01h				;Fixed disk?
	jne	$$IF92				;Nope, invalid
$$IF90:
	ret

Check_ValidZSwtch_Drive endp

;*****************************************************************************
;Routine name: Check_Target_Drive
;*****************************************************************************
;
;Description: Check to see if valid DOS drive by checking if drive is
;	      removable. If error, the drive is invalid. Save default
;	      drive info.
;
;Called Procedures: Message (macro)
;
;Change History: Created	5/1/87	       MT
;
;Input: Fatal_Error = NO
;
;Output: BIOSFile = default drive letter
;	 CommandFile = default drive letter
;	 Fatal_Error = YES/NO
;
;Psuedocode
;----------
;
;	Get default drive (INT 21h, AH = 19h)
;	Convert it to drive letter
;	Save into BIOSFile,CommandFile
;	See if drive removable (INT 21h, AX=4409h IOCtl)
;	IF error - drive invalid
;	   Display Invalid drive message
;	   Fatal_Error= YES
;	ENDIF
;	ret
;*****************************************************************************

Procedure Check_Target_Drive

	DOS_Call Get_Default_Drive		;Find the current drive
	add	al,'A'				;Convert to drive letter
	mov	BIOSFile,al			;Put it into path strings
	mov	CommandFile,al
	mov	bl,DriveToFormat			;Set up for next call
	inc	bl				;A=1,B=2 for IOCtl call
	mov	al,09h				;See if drive is local
	DOS_Call IOCtl				;-this will fail if bad drive

	JNC	$$IF84				;CY means invalid drive
	Extended_Message			;Print message
	mov	Fatal_Error,Yes			;Indicate error
$$IF84:
	ret					;And we're outa here

Check_Target_Drive endp

;*****************************************************************************
;Routine name: Check_For_Network
;*****************************************************************************
;
;Description: See if target drive isn't local, or if it is a shared drive. If
;	      so, exit with error message. The IOCtl call is not checked for
;	      an error because it is called previously in another routine, and
;	      invalid drive is the only error it can generate. That condition
;	      would not get this far
;
;Called Procedures: Message (macro)
;
;Change History: Created	5/1/87	       MT
;
;Input: DriveToFormat
;	   Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;	See if drive is local (INT 21h, AX=4409 IOCtl)
;	IF not local
;	   Display network message
;	   Fatal_ERROR = YES
;	ELSE
;	   IF  8000h bit set on return
;	      Display assign message
;	      Fatal_Error = YES
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************

Procedure Check_For_Network

	mov	bl,DriveToFormat			;Drive is 0=A, 1=B
	inc	bl				;Get 1=A, 2=B for IOCtl call
	mov	al,09h				;See if drive is local or remote
	DOS_CALL IOCtl				;We will not check for error
	test	dx,Net_Check			;if (x & 1200H)(redir or shared);

	JZ	$$IF86				;Found a net drive
	Message MsgNetDrive			;Tell 'em
	mov	Fatal_Error,Yes			;Indicate bad stuff
	JMP	SHORT $$EN86			;Local drive, now check assign

$$IF86:
	test	dx,Assign_Check			;8000h bit is bad news
	JZ	$$IF88				;Found it

	Message MsgAssignedDrive		;Tell error
	mov	Fatal_Error,Yes			;Indicate bad stuff

$$IF88:
$$EN86:
	ret

Check_For_Network endp

;*****************************************************************************
;Routine name: Check_Translate_Drive
;*****************************************************************************
;
;Description: Do a name translate call on the drive letter to see if it is
;	      assigned by SUBST or ASSIGN
;
;Called Procedures: Message (macro)
;
;Change History: Created	5/1/87	       MT
;
;Input: DriveToFormat
;	   Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;
;Psuedocode
;----------
;	Put drive letter in ASCIIZ string "d:\",0
;	Do name translate call (INT 21)
;	IF drive not same
;	   Display assigned message
;	   Fatal_Error = YES
;	ENDIF
;	ret
;*****************************************************************************

Procedure Check_Translate_Drive

	mov	bl,DriveToFormat			;Get drive
	add	byte ptr [TranSrc],bl		;Make string "d:\"
	mov	si,offset TranSrc		;Point to translate string
	push	ds				;Set ES=DS (Data segment)
	pop	es				;     "  "	"  "
	mov	di,offset Command_Line_Buffer	;Point at output buffer
	DOS_Call xNameTrans			;Get real path
	mov	bl,byte ptr [TranSrc]		;Get drive letter from path
	cmp	bl,byte ptr Command_Line_Buffer ;Did drive letter change?

	JE	$$IF91				;If not the same, it be bad
	Message MsgAssignedDrive		;Tell user
	mov	Fatal_Error,Yes			;Setup error flag

$$IF91:
	ret

Check_Translate_Drive endp

;*****************************************************************************
;Routine name: Hook_CNTRL_C
;*****************************************************************************
;
;Description: Change the interrupt handler for INT 13h to point to the
;	      ControlC_Handler routine
;
;Called Procedures: None
;
;Change History: Created	4/21/87 	MT
;
;Input: None
;
;Output: None
;
;Psuedocode
;----------
;
;	Point at ControlC_Handler routine
;	Set interrupt handler (INT 21h, AX=2523h)
;	ret
;*****************************************************************************

Procedure Hook_CNTRL_C

	mov	al,23H				;Specify CNTRL handler
	mov	dx, offset ControlC_Handler	;Point at it
	push	ds				;Save data seg
	push	cs				;Point to code segment
	pop	ds				;
	DOS_Call Set_Interrupt_Vector		;Set the INT 23h handler
	pop	ds				;Get Data degment back
	ret

Hook_CNTRL_C endp

;=========================================================================
; Check_For_Invalid_Drive	: This routine checks the AX received by
;				  FORMAT on its entry.	This value will
;				  tell us if we are attempting to format
;				  a JOINED drive.
;
;	Inputs	: Org_AX	- AX on entry to FORMAT
;
;	Outputs : Fatal_Error	- Yes if AL contained FFh
;=========================================================================

Procedure Check_For_Invalid_Drive

	push	ax				;save ax
	cmp	FAT_Flag,Yes			;FAT system?
	JNE	$$IF93				;yes
	mov	ax,Org_AX			;get its org. value
	cmp	al,0ffh 			;Invalid drive?
	JNE	$$IF94				;yes
	mov	Fatal_Error,YES 		;flag an error
	mov	ax,Invalid_Drive		;error message
	Extended_Message			;tell error

$$IF94:
$$IF93:
	pop	ax
	ret

Check_For_Invalid_Drive endp


;=========================================================================
; Determine_FAT_Non_FAT 	- This routine determines whether or
;				  not a device is formatted to a FAT
;				  specification versus a Non-FAT
;				  specification.
;
;	Inputs	: DX - Pointer to device parameters buffer
;
;	Outputs : DeviceParameters - buffer containing BPB.
;
;	Date	: 11/6/87
;=========================================================================

Procedure Determine_FAT_Non_FAT
;
; M031: With memory card media, a get default BPB requires a media
; in the drive. At this point, we haven't outputted the "Insert disk ..."
; message. This code was also buggy because if the GetDeviceParameters
; failed, FAT_Flag was not properly initialized (it is a DB ?, so it would
; have been equivalent to No). I patched the code to first check if there is
; a CMCDD disk. If so, we will set FAT_flag to Yes.

	push	ax				;save regs
	push	dx

	call	CheckCMCDD			; M033
	cmp	CMCDDFlag, Yes
	je	$$IF98				; M031

	lea	dx, deviceParameters		;point to buffer
	mov	deviceParameters.DP_SpecialFunctions, 0	 ;get default BPB
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS
	call	GetDeviceParameters		;make the call
	JC	$$IF97				;no error occurred

						;non-FAT system?
	cmp	byte ptr DeviceParameters.DP_BPB.BPB_NumberOfFATS,00h
    .errnz EDP_BPB NE DP_BPB
	JNE	$$IF98				;yes
			; Can't create recovery file or do quick
			; format for non FAT disks

	or	SwitchMap,Switch_U
	and	Switchmap, NOT Switch_Q

	mov	FAT_Flag,No			;signal system non-FAT
	mov	ax,5f07h			;allow access to disk
	mov	dl,DriveToFormat			;get 0 based driver number
	int	21h				;allow access to the drive

	JMP	SHORT $$EN98			;FAT system
$$IF98:
	mov	FAT_Flag,Yes			;flag FAT system

$$EN98:
$$IF97:

	pop	dx				;restore regs
	pop	ax
	ret

Determine_FAT_Non_FAT	endp

;M033 - Begin
;=========================================================================
; CheckCMCDD	 		- This routine determines whether or
;				  not the drive is a CMCDD drive.
;
;	Inputs	: None
;
;	Outputs : CMCDDFlag is Yes iff we are on a CMCDD drive
;
;	Trashes : AX, BX, CX, DX
;
;	Date	: 6/5/91
;=========================================================================
procedure CheckCMCDD

	mov	ax,(IOCTL shl 8) or IOCTL_QUERY_BLOCK ; Check if function supported
	mov	bl, DriveToFormat
	inc	bl				; 1 based
	; Determine if get_system_info
	; exist (only CMCDD has it).
	; see if CMCDD
	mov	cx,(RAWIO shl 8) or GET_SYSTEM_INFO_CMCDD
	int	21h
	jc	notCMCDD

	mov	CMCDDFlag, Yes
	ret

notCMCDD:
	mov	CMCDDFlag, No
	ret

CheckCMCDD	endp
;M033 - end

; =========================================================================

code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\forexec.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;*****************************************************************************
;*****************************************************************************
;UTILITY NAME: FORMAT.COM
;
;MODULE NAME: FOREXEC.SAL
;
;
;
; Ŀ
; EXEC_FS_FORMAT
; 
;   
;   Ŀ
;   ôShrink
;   
;   Ŀ
;   ôSetup_EXEC
;   
;   Ŀ	  Ŀ
;   ôEXEC_ArgVĴEXEC_Program
;   	  
;   Ŀ Ŀ
;   ôEXEC_Cur_DirectoryĴEXEC_Program
;    
;   Ŀ	  Ŀ Ŀ
;   EXEC_RoutineĴBuild_Path_And_EXECĴEXEC_Program
;    	   
;
; Change List: AN000 - New code DOS 3.3 spec additions
;	       AC000 - Changed code DOS 3.3 spec additions
;*****************************************************************************
;*****************************************************************************

title	DOS	3.30 FORMAT EXEC Module

IF1
	%OUT	ASSEMBLING: DOS 3.3 FORMAT EXEC LOADER
	%OUT
ENDIF

code	segment public para 'code'
	assume	cs:code
code	ends

;*****************************************************************************
; Include files
;*****************************************************************************

.xlist

INCLUDE FORCHNG.INC
INCLUDE FORMACRO.INC
INCLUDE SYSCALL.INC
INCLUDE FOREQU.INC

.list

;*****************************************************************************
; Public Data
;*****************************************************************************

	Public	Drive_Letter_Msg

;*****************************************************************************
; Public Routines
;*****************************************************************************


IF FSExec

	Public	EXEC_FS_Format

ENDIF		;FSExec 		;end /FS: conditional



;***************************************************************************
; External Data Declarations
;***************************************************************************

	extrn	ExitStatus:Byte
	extrn	Fatal_Error:Byte
	extrn	FS_String_Buffer:Byte
	extrn	msgEXECFailure:Byte
	extrn	PSP_Segment:Word
	extrn	DriveToFormat:byte

;**************************************************************************
; Structures
;**************************************************************************


Exec_Block_Parms struc
Segment_Env	dw	0
Offset_Command	dw	0
Segment_Command dw	0
Offset_FCB1	dw	0
Segment_FCB1	dw	0
Offset_FCB2	dw	0
Segment_FCB2	dw	0

Exec_Block_Parms ends


;**************************************************************************
; Equates
;**************************************************************************


String_Done	equ	0
No_Error	equ	0
Error		equ	1
Stderr		equ	2
Stack_Space	equ	02eh		; IBM addition ROM paras

;**************************************************************************
; PSP Area
;**************************************************************************

PSP	segment public	para   'DUMMY'

org	2Ch
PSP_ENV_SEGMENT label word

FCB1	equ	5Ch

FCB2	equ	6Ch

org	80h
Command_Line label byte


PSP	ends

;**************************************************************************
; Data Area
;**************************************************************************

data	segment public para 'DATA'
	assume	ds:data,es:nothing

Exec_Block Exec_Block_Parms <>
EXEC_Path db	66 dup(0)

Drive_Letter_Msg db "A:",0		;Drive for exec fail message

SP_Save 	dw	?
SS_Save 	dw	?


;These next two should stay togather
; ---------------------------------------

Path_String db	"PATH="
Len_Path_String equ $ - Path_String

;----------------------------------------

;These should stay togather
; ---------------------------------------

Search_FORMAT db "FORMAT"
Len_Search_FORMAT equ $ - Search_FORMAT
Search_Format_End equ $

;----------------------------------------


;These next two should stay togather
; ---------------------------------------

data	ends

;**************************************************************************

code	segment public para 'code'
	assume	cs:code,ds:data

;**************************************************************************
; Main Routine
;**************************************************************************


IF FSExec				;if /FS: desired

Procedure Exec_FS_Format

	Set_Data_Segment
	call	Set_FCB1_Drive
	call	Shrink
	mov	al,ExitStatus		;Setblock fail?

	cmp	al,Error
	JE	$$IF1
	call	Setup_Exec
	call	Exec_Argv		;try exec from dir BASIC loaded
	mov	al,ExitStatus

	cmp	al,Error
	JNE	$$IF2
	call	Exec_Cur_Directory
	mov	al,ExitStatus		;Try exec from cur directory

	cmp	al,Error
	JNE	$$IF2
	call	EXEC_Routine
	mov	al,ExitStatus

	cmp	al,Error
	JNE	$$IF2

	push	ds			;save ds
	push	si			;save si
	mov	si,PSP_Segment		;get psp
	mov	ds,si			;put psp in ds
	assume	ds:PSP

	mov	si,FCB1			;ptr to 1st. FCB
	mov	bl,byte ptr ds:[si]	;get drive ID

	pop	si			;restore si
	pop	ds			;restore ds
	Set_Data_Segment			;set segments

	cmp	bl,0			;Is it default drive?
	JNE	$$IF3
	push	ax			;Save exit code
	DOS_Call Get_Default_Drive	;Get the default drive
	add	al,"A"			;Turn into drive letter
	mov	Drive_Letter_Msg,al	;Save it in message
	pop	ax			;Get return code back

	JMP	SHORT $$EN3
$$IF3:
	add	bl,"A"-1		;Convert to drive letter
	mov	Drive_Letter_Msg,bl

$$EN3:
	Message msgEXECFailure
	JMP SHORT $$EN2

$$IF2:
	DOS_Call WaitProcess
	mov	ExitStatus,al

$$EN2:
$$IF1:
	mov	Fatal_Error,YES 	;Not really, indicates FS used
	ret

Exec_FS_Format endp

;****************************************************************************
; Shrink
;****************************************************************************

Procedure Shrink

	mov	ax,cs			;get code segment
	mov	bx,ds			;get data segment
	sub	ax,bx			;data seg size
	mov	bx,ax			;save paras
	mov	ax,offset End_Program	;Get the offset of end of loader
	mov	cl,4			;Div by 16 to get para's
	shr	ax,cl
	add	bx,ax			;add in code space
	add	bx,Stack_Space		;adjust for stack
	add	bx,11h			;give PSP space
	mov	ax,PSP_Segment
	mov	es,ax
	assume	es:nothing

	DOS_Call SetBlock
	JNC $$IF9
	Message msgEXECFailure
	mov	ExitStatus,Error	;Bad stuff, time to quit
$$IF9:
	ret

Shrink	endp

;**************************************************************************
; Setup_Exec
;**************************************************************************

Procedure Setup_Exec

	Set_Data_Segment
	mov	ax,PSP_Segment			;Get segment of PSP
	mov	ds,ax

	assume	ds:PSP
			;Setup dword pointer to command line to be passed

	mov	es:Exec_Block.Segment_Command,ax ;Segment for command line
	mov	es:Exec_Block.Offset_Command,offset ds:Command_Line

			;Setup dword pointer to first FCB to be passed

	mov	es:Exec_Block.Segment_FCB1,ax	;Segment for FCB1
	mov	es:Exec_Block.Offset_FCB1,offset ds:FCB1 ;Offset of FCB at 05Ch

			;Setup dword pointer to second FCB to be passed 			    ;

	mov	es:Exec_Block.Segment_FCB2,ax	;Segment for FCB2
	mov	es:Exec_Block.Offset_FCB2,offset ds:FCB2 ;Offset of FCB at 06Ch

			;Setup segment of Environment string, get from PSP			    ;

	mov	ax,ds:PSP_Env_Segment
	mov	es:Exec_Block.Segment_Env,ax
	Set_Data_Segment
	ret


Setup_EXEC endp

;****************************************************************************
; Exec_Argv
;****************************************************************************
;
; Read the environment to get the Argv(0) string, which contains the drive,
; path and filename that was loaded for FORMAT.COM. This will be used to find
; the xxxxxfmt.exe, assuming that it is in the same location or path as
; FORMAT.COM
;

Procedure EXEC_Argv

	Set_Data_Segment			;DS,ES = DATA
	cld
	mov	ax,Exec_Block.Segment_Env	;Get the environment
	mov	ds,ax				;Get addressability

	assume	ds:nothing

	xor	si,si				;Start at beginning
$$DO11:
$$DO12:
	inc	si				;Get character
	cmp	byte ptr [si-1],0		;Find string seperator?
	JNE	$$DO12
	inc	si				;Get next char
	cmp	byte ptr [si-1],0		;Are we at Argv(0)? (00?)
	JNE	$$DO11
	add	si,2				;Skip the word count
	mov	di,si				;Save where string starts

$$DO15: 					;Find length of Argv(0) string
	inc	si				;Get char
	cmp	byte ptr [si-1],0		;Is it the end?
						;End found if 0 found
	JNE $$DO15
	mov	cx,si				;Get number of bytes in string
	sub	cx,di				;Put in cx reg for rep count
	mov	si,di				;Point to path
	mov	di,offset es:EXEC_Path		;Point to where to put it
	rep	movsb				;Move the string
	Set_Data_Segment
	dec	di				;Point at end of ArgV string
	std					;Look backwards

$$DO17: 					;Find 'FORMAT' in ARGV string
	mov	cx,Len_Search_FORMAT		;Get length to compare
	mov	si,offset Search_FORMAT_End-1	;Look at comp string from end
	repe	cmpsb				;See if same string


	JNE	$$DO17
	mov	si,offset FS_String_Buffer
	inc	di				;DI = replacement point-1
	cld					;Set direction flag back
	mov	cx,Len_FS_String_Buffer 	;Length of string to move
	rep	movsb				;Build part of the path
	call	EXEC_Program
	ret

EXEC_ArgV endp

;****************************************************************************
; EXEC_Program
;****************************************************************************

Procedure EXEC_Program

	Set_Data_Segment
	mov	ExitStatus,No_Error	;Setup to Exec the file
	mov	dx,offset Exec_Path
	mov	bx,offset Exec_Block
	mov	al,0
	mov	word ptr SP_Save,sp	;save sp
	mov	word ptr SS_Save,ss	;save ss

	DOS_Call Exec

	cli				;turn off int's
	mov	sp,word ptr SP_Save	;retrieve sp
	mov	ss,word ptr SS_Save	;retrieve ss
	sti				;turn on int's


;	$IF	C			;CY means failure
	JNC $$IF19
	   mov	   ExitStatus,Error	;Set error code
;	$ENDIF
$$IF19:
	ret

EXEC_Program endp


;****************************************************************************
; EXEC_Routine
;****************************************************************************

Procedure EXEC_Routine

	Set_Data_Segment
	mov	ExitStatus,Error	;Assume the worst
	cld
	push	ds
	mov	ax,Exec_Block.Segment_Env ;Get the environment
	mov	ds,ax			;Get addressability
	assume	ds:nothing

	xor	si,si			;Start at beginning
;	$SEARCH
$$DO21:
	   cmp	   word ptr ds:[si],0	;End of the Evironment?
;	$EXITIF E			;Reached end, no more look
	JNE $$IF21

;	$ORELSE 			;Look for 'PATH=' in environment
	JMP SHORT $$SR21
$$IF21:
	   mov	   di,offset Path_String
	   mov	   cx,Len_Path_String
	   repe    cmpsb
;	$LEAVE	E			;Found if EQ
	JE $$EN21
;	$ENDLOOP			;Found PATH in environment
	JMP SHORT $$DO21
$$EN21:
	   call    Build_Path_And_Exec
;	$ENDSRCH
$$SR21:
	pop	ds
	ret

EXEC_Routine endp

;****************************************************************************
; Build_Path_For_EXEC
;****************************************************************************

Procedure Build_Path_And_Exec

$$DO27:
	cmp	byte ptr ds:[si],0	;All path entries done?

	JE	$$IF28
	mov	di,offset EXEC_Path	;Point at where to put path
	mov	byte ptr es:[di],0	;End path just in case

$$DO29:
	cmp	byte ptr ds:[si],0	;End of Path?

	JE	$$EN29
	cmp	 byte ptr ds:[si],';'	;End of entry?

	JNE	$$IF31
	inc	si			;point to next character
	jmp	EXIT_BPE_LOOP		;exit loop

$$IF31:
	movsb				;Put char in path string

	JMP SHORT $$DO29
$$EN29:

EXIT_BPE_LOOP:
					;Path filled in,get backslash
	cmp	byte ptr ds:[si-1],0	;Any path there?

	JE	$$IF34
					;Nope
	cmp	 byte ptr ds:[si-1],"\" ;Need a backslash?	     ;

	JE	$$IF35
	mov	byte ptr es:[di],"\"    ;Yes, put one in	     ;
	inc	di			;Line it up for next stuff
	inc	si

$$IF35:
	push	 si			;Save place in path
	push	 ds			;Save segment for environment
	push	 es			;Xchange ds/es
	pop	 ds
	mov	 si,offset FS_String_Buffer ;Fill in filename
	mov	 cx, Len_FS_String_Buffer
	rep	 movsb
	call	 Exec_Program
	cmp	 ExitStatus,No_Error	;E if EXEC okay
	pop	 ds			;Get Env segment back
	pop	 si			;Get place in path back

$$IF34:
$$IF28:

	JNE	$$DO27
	ret

Build_Path_And_EXEC Endp

;**************************************************************************
; Exec_Cur_Directory
;**************************************************************************

Procedure Exec_Cur_Directory

	Set_Data_Segment
	mov	si,offset FS_String_Buffer	;Setup path for current dir
	mov	di,offset EXEC_Path
	mov	cx,Len_FS_String_Buffer
	rep	movsb
	call	EXEC_Program
	ret

EXEC_Cur_Directory endp

;=========================================================================
; Set_FCB1_Drive	: This routine sets the 1st. byte of the FCB1,
;			  the drive identifier, to the default drive.
;=========================================================================

Procedure Set_FCB1_Drive		;set drive ID

	push	ds			;save ds
	push	si			;save si

	mov	si,PSP_Segment		;get segment of PSP
	mov	ds,si			;put it in ds
	assume	ds:PSP
	mov	si,FCB1 		;ptr to FCB1
	mov	byte ptr ds:[si],00h	;set drive ID to
					;      default drive
	pop	si			;restore si
	pop	ds			;restore ds
	Set_Data_Segment		;set up segmentation
	ret

Set_FCB1_Drive	endp

ENDIF		;FSExec 		;end /FS: conditional
					;assembly

;**************************************************************************

	public End_Program
End_Program label byte

;**************************************************************************

code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\forchng.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
.xlist
;
;
;*****************************************************************************
;*                                                                           *
;* Change list to FORMAT modules                                             *
;*                                                                           *
;* Lines are tagged ANxxx for new, ACxxx for changed                         *
;* --------------------------------------------------------------------------*
;*  000 - DOS 4.00 Spec additions and DCR's thru unit/function test          *
;*         Date: 8/3/87    Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  001 - DOS 4.00 DCR D146 Add support for /F switch                        *
;*         Date: 8/13/87   Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  002 - DOS 4.00 DCR D166 Add logic to detect that switches entered        *
;*         multiple times, and print error message                           *
;*         Date: 8/13/87   Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  003 - DOS 4.00 PTM P233 Do not allow Cntrl-Break when writing file       *
;*        system out, only during the actual format                          *
;*        Date: 8/14/87    Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  004 - DOS 4.00 PTM P229 Volume serial number displayed in reverse word   *
;*        order from command.com and diskcopy. Reverse order of words        *
;*        Date: 8/17/87    Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  005 - DOS 4.00 DCR D64  Enable for 128k FAT                              *
;*        Date: 8/19/87    Developer: DMS	                             *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  006 - DOS 4.00 PTM P320 Not detecting write protect. Needed to use       *
;*        extended error messages                                            *
;*        Date 8/20/87     Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  007 - DOS 4.00 PTM P170 Straighten out the switch check logic to allow   *
;*        /B with all diskette formats, add /B/S check, and remove /V/B      *
;*        check except for /8 sectored diskettes (old dir and boot record    *
;*        Date 8/21/87     Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  008 - DOS 4.00 PTM P402 Fields that determine switch type not cleared,   *
;*        so switches got checked multiple times, causing error              *
;*        Date 8/23/87     Developer: MT        , Dave Sewell                *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  009 - DOS 4.00 PTM P341 Check to make sure /N entered with /T            *
;*        Date 8/23/87     Developer: MT                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  010 - DOS 4.00 PTM P233 Capture the CTRL-BREAK interrupt and disable     *
;*        it during the writing of the FAT, DIR, and SYSTEM.                 *
;*        Date 8/25/87     Developer: DMS                                    *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  012 - DOS 4.00 DCR 200 If the NumberOfFATs field of the BPB is 0 we need *
;*        to calculate various values in the BPB to be used by FORMAT.       *
;*        Date 9/10/87    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  013 - DOS 4.00 DCR 208 Set FORMAT in order that the space available it   *
;*        reports is consistent with DIR.                                    *
;*        Date 9/11/87    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  014 - DOS 4.00 PTM 1535 Allow access to a non-formatted disk.            *
;*        Date 10/15/87   Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  015 - DOS 4.00 DCR 390  Multi-Track format of hard media                 *
;*        Date 12/9/87    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  016 - DOS 4.00 DCR 395  SELECT message support.  Use INT 2Fh, function   *
;*        ADC1h to print FORMAT disk prompt from SELECT.                     *
;*        Date 12/14/87   Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  017 - DOS 4.00 PTM 3125 SELECT message support. Disable write protect    *
;*        message under SELECT option.  Addition of exit codes 6 (Drive Not  *
;*        Ready" and 7 (Write Protect).                                      *
;*        Date 1/14/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  018 - DOS 4.00 PTM 3130 Provide for conditional assembly of the /FS:     *
;*        code, since it is not being shipped with DOS 4.00.                 *
;*        Date 1/26/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  019 - DOS 4.00 PTM 3994 FORMAT now has a "heartbeat" when it verifies    *
;*        bad sectors.  By doing so the user knows the FORMAT is still       *
;*        proceeding well.  Without this heartbeat, an AT appears to hang    *
;*        when the sectors are being verified.  This is caused by the slow   *
;*        head resets on an AT.                                              *
;*        Date 3/25/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  020 - DOS 4.00 PTM 4058 When an invalid Volume ID is entered at the      *
;*        volume prompt, FORMAT should go to the next line so that the       *
;*        user can see the invalid volume id.                                *
;*        Date 3/29/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  021 - DOS 4.00 PTM 4081 FORMAT was marking the incorrect cluster as      *
;*        bad under certain situations.  This caused that sector to fail     *
;*        when read or written to.                                           *
;*        Date 3/31/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  022 - DOS 4.00 PTM 4180 FORMAT was not performing an FCB Close after     *
;*        it had done an FCB Create.  This caused the change line counter    *
;*        to go "haywire".  Also a bug was found in the FORMAT retry logic.  *
;*        FORMAT was never entering the retry logic because of a CY flag     *
;*        always existing on entry to the routine.                           *
;*        Date 4/15/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  023 - DOS 4.00 DCR 524 FORMAT must accept a blank or carriage return to  *
;*        allow for a blank volume label.                                    *
;*        Date 4/19/88    Developer: DRM                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  024 - DOS 4.00 PTM 4487 FORMAT trys to get the A: drive when formatting  *
;*        drive B: and then hitting enter for the volume label.  There is a  *
;*        problem with FCB Close but logic was also changed in FORLABEL.SAL  *
;*        to eliminate this condition.                                       *
;*        Date 4/26/88    Developer: DRM                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  025 - DOS 4.00 PTM 4539 FORMAT accesses the default disk instead of the  *
;*        boot disk when the default disk is different than the boot disk.   *
;*        This is incorrect behavior because the user could receive a system *
;*        other than what they wanted.                                       *
;*        Date 4/28/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  026 - DOS 4.00 PTM 4805 FORMAT A: /B gives invalid bad byte count and    *
;*        FORMAT A: /F:160 on an 1.2 Mb drive gives parm error.              *
;*        Date 5/10/88    Developer: DMS                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  027 - DOS 4.00 PTM 4913 FORMAT A: /B displays the serial number of the   *
;*        diskette but never writes it to the diskette.  Format will no      *
;*        display the serial number when formatting with /8.                 *
;*        Date 5/19/88    Developer: DRM                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  028 - DOS 4.00 PTM 5023 FORMAT puts just the N of NO NAME in the volume  *
;*        label of the boot record.  This is corrected in IBMFOR.SAL by      *
;*        setting up the CX register correctly.                              *
;*        Date 6/09/88    Developer: DRM                                     *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  030 - DOS 5.0           FORMAT major changes for supporting safe format  *
;*        wich creates an unformat file to be used by a program to restore   *
;*        the bootsector, fat, root, and first 2 clusters.		     *
;*        Date 10/22/89    Developer: johnhe                                 *
;* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
;*  031 - DOS 5.0           FORMAT made change in format.asm to have it      *
;*        do an int  2fh with AX == 4000h && BX == percent complete when     *
;*        the /SELECT switch is used.					     *
;*        Date 2/27/90    Developer: johnhe                                  *
;*****************************************************************************
;* Note: This is file FORCHNG.INC for updating purposes                      *
;*****************************************************************************
.list


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\formacro.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */







;
;******************************************************************************
; Message Macro Definitions
;******************************************************************************
;

      EXTRN Display_Interface:near


;-----------------------------------------------------------------------------

Message macro   Message_Name                    ;                               ;AN000;
                                                ;
        mov     dx,offset data:Message_Name     ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
        endm                                    ;                               ;AN000;

;-----------------------------------------------------------------------------

Parse_Message macro                             ;                               ;AN000;

                                                ;
        push    ds
        mov     dx,data
        mov     ds,dx
        mov     word ptr Parse_Error_Msg,ax     ;                               ;AN000;
        mov     dx,offset Parse_Error_Msg       ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
        pop     ds                              ;
        endm                                    ;                               ;AN000;

;-----------------------------------------------------------------------------

Extended_Message macro                          ;                               ;AN000;
                                                ;

        push    ds
        mov     dx,data
        mov     ds,dx
        mov     word ptr Extended_Error_Msg,ax       ;                               ;AN000;
        mov     dx,offset data:Extended_Error_Msg    ;                               ;AN000;
        call    Display_Interface               ;                               ;AN000;
        pop     ds
        endm                                    ;                               ;AN000;

;
;*****************************************************************************
; General Macro's
;*****************************************************************************
;

Procedure       macro   Proc_Name

Public  Proc_Name
Proc_Name    proc

        endm
;-----------------------------------------------------------------------------

DOS_Call        macro   Function

        mov     ah,Function
        int     21h

        endm
;-----------------------------------------------------------------------------

Popff   macro

        jmp     $+3
        iret
        push    cs
        call    $-2

        endm


;-----------------------------------------------------------------------------

Set_Data_Segment     macro

        push    ax
        mov     ax,data                         ;Point to data segment
        mov     ds,ax                           ;
        push    ds
        pop     es
        pop     ax

assume  ds:data,es:data

        endm




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\forlabel.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;*****************************************************************************
;*****************************************************************************
;
;UTILITY NAME: FORMAT.COM
;
;MODULE NAME: FORLABEL.SAL
;
;		Interpret_Parse
;			|
;*			|
;ĿĿ|Ŀ Ŀ
;VolIDôGet_New_LabelĴGet_11_Characters´Change_Blanks
;  ٳ
;					    Ŀ
;					    ôSkip_Blanks
;					    
;					    ĿĿ
;					    ôCheck_DBCS_OverrunôCheck_DBCS_Character
;					    
;					    Ŀ
;					    Copy_FCB_String
;					     
;*****************************************************************************
;*****************************************************************************

;
;----------------------------------------------------------------------------
;
; m023 : Bug #5253. get volume label function checks for carry flag
;		after doing a input flush call. But this function call does
;		not return aything in the carry flag.
;
;----------------------------------------------------------------------------
;
data	segment public para 'DATA'

Bad_Char_Table	label	byte			 ;table of invalid vol ID chars
	db	"*"
	db	"?"
	db	"["
	db	"]"
	db	":"
	db	"<"
	db	"|"
	db	">"
	db	"+"
	db	"="
	db	";"
	db	","
	db	"/"
	db	"\"
	db	'.'
	db	'"'
	db	"("
	db	")"
	db	"&"
	db	"^"
Bad_Char_Table_Len	equ	$-Bad_Char_Table ;length of table

DBCS_Vector_Off dw 0
DBCS_Vector_Seg dw 0


data	ends

.xlist
INCLUDE FORCHNG.INC
INCLUDE FORMACRO.INC
INCLUDE SYSCALL.INC
INCLUDE FOREQU.INC
INCLUDE FORSWTCH.INC
.list

;
;*****************************************************************************
; Equates
;*****************************************************************************
;

None	equ	0
StdIn	equ	0
StdOut	equ	1
StdErr	equ	2
Tab	equ	09h
Label_Buffer_length equ 80h
Create_Worked equ 0


;
;*****************************************************************************
; External Data Declarations
;*****************************************************************************
;

	Extrn	SwitchMap:Word
	Extrn	Switch_String_Buffer:Byte
	Extrn	VolFCB:Byte
	Extrn	MsgBadCharacters:Byte
	Extrn	MsgLabelPrompt:Byte
	Extrn	MsgBadVolumeID:Byte
	Extrn	MsgCRLF:Byte
	Extrn	VolNam:Byte
	Extrn	Vol_Label_Count:Byte
	Extrn	VolDrive:Byte
	Extrn	DriveToFormat:Byte
	Extrn	Command_Line:Byte
	Extrn	Vol_Label_Buffer:Byte
	Extrn	DelDrive:Byte
	Extrn	DelFCB:Byte

ifdef NEC_98
	extrn	switchmap2:word
endif
code	segment public para 'CODE'
	assume	cs:code,ds:data	

;************************************************************************************************
;Routine name Volid
;************************************************************************************************
;
;Description: Get volume id from command line /V:xxxxxxx if it is there, or
;	      else prompt user for volume label, parse the input. At this
;	      point setup the FCB and create the volume label. If failure,
;	      prompt user that they entered bad input, and try again.
;
;	      Note: This routine in 3.30 and prior used to check for /V
;		    switch. Volume labels are always required now, so /V
;		    is ignored, except to get volume label on command line.
;
;Called Procedures: Message (macro)
;		    Get_New_Label
;
;Change History: Created	5/1/87	       MT
;
;Input: Switch_V
;	Command_Line = YES/NO
;
;Output: None
;
;Psuedocode
;----------
;
;	Save registers
;	IF /V switch entered
;	   IF /v:xxxxx form not entered
;	      CALL Get_New_Label     ;Return string in Volume_Label
;	   ENDIF
;	ELSE
;	   CALL Get_New_Label	  ;Return string in Volume_Label
;	ENDIF
;	DO
;	   Create volume label
;	LEAVE Create Ok
;	   Display Bad Character message
;	   CALL Get_New_Label	;Return string in Volume_Label
;	ENDDO
;	Restore registers
;	ret
;*****************************************************************************

Procedure Volid

	push	ds				;Save registers
	push	si

	test	SwitchMap,Switch_Select		; Was format spawned by the
	jnz	LabelDone			; DOS 5.x install program

	test	SwitchMap,Switch_V		;Was /V entered
	je	AskForLabel			;Yes, see if label entered also
; M009 - Begin
	cmp	Command_Line,No			;Is there a string there?
	je	AskForLabel			;Yes
	cmp	Vol_Label_Buffer,0		;Is it /V:""
	je	LabelDone
	jmp	short GotLabel
; M009 - End

AskForLabel:
ifdef NEC_98
	test	SwitchMap2,SWITCH2_P
	jnz	LabelDone
endif
	call	Get_New_Label			;Go get volume label from user

GotLabel:
	mov	dl,DriveToFormat			;Get drive number  A=0
	inc	dl				;Make it 1 based
	mov	DelDrive,dl			;Put into FCBs
	mov	VolDrive,dl
	mov	dx,offset DelFCB		;Point at FCB to delete label
	DOS_CALL FCB_Delete			;Do the delete
	mov	dx,offset VolFCB		;Point at FCB for create
	DOS_CALL FCB_Create			;Go create it
	cmp	al,Create_Worked		;See if the create worked
	jne	LabelDone

	mov	dx,offset VolFCB		;Point to the FCB created
	DOS_Call FCB_Close			;Close the newly created FCB

LabelDone:
	pop	si				;Restore registers
	pop	ds
	ret

Volid	endp

;*****************************************************************************
;Routine name: Get_New_Label
;*****************************************************************************
;
;Description: Prompts, inputs and verifies a volume label string. Continues
;	      to prompt until valid vol label is input
;
;Called Procedures: Message (macro)
;		    Build_String
;		    Get_11_Characters
;
;Change History: Created	3/18/87 	MT
;
;Input: None
;
;Output: Volume_Label holds
;
;Psuedocode
;----------
;
;	DO
;	   Display  new volume label prompt
;	   Input vol label
;	   IF No error (NC)
;	      Build Asciiz string with label, pointer DS:SI (CALL Build_String)
;	      Call Get_11_Characters (Error returned CY)
;	   ENDIF
;	LEAVE no error (NC)
;	   Display label error
;	ENDDO
;	ret
;*****************************************************************************

Procedure Get_New_Label

$$DO8:						;Loop until we get good one
	Message msgLabelPrompt			;Prompt to input Vol label
						;clean out input
	mov	ax,(Std_Con_Input_Flush shl 8) + 0
	int	21h
	mov	dx,offset Vol_Label_Count	;beginning of buffer
	mov	ah,Std_Con_String_Input 	;get input
	int	21h
						;clean out input
	mov	ax,(Std_Con_Input_Flush shl 8) + 0
	int	21h
;
; m023 - this function call does not return carry/nocaryy
;
;	JC	$$IF9				;Read ok if NC, Bad sets CY

	mov	si,offset Vol_Label_Buffer	;Get pointer to string
	call	Get_11_Characters		;Handle DBCS stuff on input

$$IF9:						;Ret CY if error
	JNC $$EN8				;Done if NC
	Message MsgCRLF 			;next line
	Message msgBadVolumeID			;Tell user error

	JMP	SHORT $$DO8			;Try again
$$EN8:
	Message MsgCRLF 			;next line
	ret

Get_New_Label endp

;*****************************************************************************
;Routine name: Get_11_Characters
;*****************************************************************************
;
;Description: Handle DBCS considerations, and build FCB to create vol label
;
;
;Called Procedures: Change_Blanks
;		    Skip_Blanks
;		    Check_DBCS_Overrun
;		    Copy_FCB_String
;
;Change History: Created	5/12/87 	MT
;
;Input: DS:SI = Asciiz string containing volume label input
;	Command_Line = YES/NO
;
;Output: Volname will contain an 8.3 volume label in FCB
;	 CY set on invalid label
;
;Psuedocode
;----------
;	Save regs used
;	Scan line replacing all DBCS blanks with SBCS  (CALL_Change_Blanks)
;	Skip over leading blanks (Call Skip_Blanks)
;	IF leading blanks ,AND
;	IF Command line
;	   Indicate invalid label (STC)
;	ELSE
;	   See if DBCS character at 11th byte (CALL Check_DBCS_Overrun)
;	   IF DBCS character at 11th byte
;	      Indicate invalid label (STC)
;	   ELSE
;	   Put string into FCB (CALL Copy_FCB_STRING)
;	   CLC
;	   ENDIF
;	ENDIF
;	Restore regs
;	ret
;*****************************************************************************

Procedure Get_11_Characters

	call	Change_Blanks			;Change DBCS blanks to SBCS
	call	Skip_Blanks			;Skip over leading blanks
	JNC	$$IF13				;Find leading blanks?

	cmp	Command_Line,YES		;Is this command line input?
	JNE	$$IF13				;Yes

	stc					;Indicate error (CY set)
	JMP	SHORT $$EN13			;Leading blanks ok

$$IF13:
	call Check_DBCS_Overrun 		;Is DBCS char at 11th byte?
	JNC	$$IF15				;Yes
	stc					;Indicate invalid label
	JMP	SHORT $$EN15			;No, good characters

$$IF15:
	call	Copy_FCB_String 		;Put string into FCB
	clc					;Indicate everything A-OK!

$$EN15:
$$EN13:
	ret

Get_11_Characters endp

;*****************************************************************************
;Routine name: Change_Blanks
;*****************************************************************************
;
;Description: Replace all DBCS blanks with SBCS blanks, end string with
;	      Asciiz character if one doesn't already exist
;
;Called Procedures: Check_DBCS_Character
;
;Change History: Created	6/12/87 	MT
;
;Input: DS:SI = String containing volume label input
;
;Output: DS:SI = ASCIIZ string with all DBCS blanks replaced with 2 SBCS blanks
;
;
;Psuedocode
;----------
;
;	Save pointer to string
;	DO
;	LEAVE End of string (0)
;	   See if DBCS character (Check_DBCS_Character)
;	   IF CY (DBCS char found)
;	      IF first byte DBCS blank, AND
;	      IF second byte DBCS blank
;		 Convert to SBCS blanks
;	      ENDIF
;	      Point to next byte to compensate for DBCS character
;	   ENDIF
;	ENDDO
;	Tack on ASCIIZ character to string
;	Restore pointer to string
;
;*****************************************************************************

Procedure Change_Blanks

	push	si				;Save pointer to string
	push	cx
	push	ax
	xor	cx,cx

$$DO19: 					;Do while not CR
	cmp	byte ptr [si],Asciiz_End	;Is it end of string?
	JE	$$EN19				;All done if so

	cmp	byte ptr [si],CR		;Is it CR?
	JE	$$EN19				;Exit if yes,end of label

	inc	cx				;Count the character
	cmp	cx,Label_Buffer_Length		;Reached max chars? (80h)
	JE	$$EN19				;Exit if so

	mov	   al,byte ptr [si]		;Get char to test for DBCS
	call	Check_DBCS_Character		;Test for dbcs lead byte
	JNC	$$IF21				;We have a lead byte

	cmp	byte ptr [si],DBCS_Blank_hi	;Is it a lead blank?
	JNE	$$IF22				;If a dbcs char

	cmp	byte ptr [si+1],DBCS_Blank_lo	;Is it an Asian blank?
	JNE	$$IF22				;If an Asian blank

	mov	byte ptr [si+1],Blank		;set up moves
	mov	byte ptr [si],Blank		;to replace

$$IF22:
	inc	si				;Point to dbcs char

$$IF21: 					;End lead byte test
	inc	si				;Point to si+1
	JMP	SHORT $$DO19			;End do while

$$EN19:
	mov	byte ptr [si],Asciiz_End	;Mark end of string
	pop	ax				;Restore regs
	pop	cx
	pop	si
	ret					;return to caller

Change_Blanks endp

;*****************************************************************************
;Routine name: Skip_Blanks
;*****************************************************************************
;
;Description: Scan ASCIIZ string for leading blanks, return pointer to first
;	      non-blank character. Set CY if blanks found
;
;Called Procedures: None
;
;Change History: Created	6/12/87 	MT
;
;Input: DS:SI = ASCIIZ string containing volume label input
;
;Output: DS:SI = Input string starting at first non-blank character
;	 CY set if blanks found
;
;
;
;Psuedocode
;----------
;
;	Save original pointer, DI register
;	DO
;	  Look at character from string
;	LEAVE End of string (0)
;	  IF character is blank,OR
;	  IF character is tab
;	     INC pointer (SI)
;	     Indicate blank
;	  ELSE
;	     Indicate non-blank
;	  ENDIF
;	ENDDO non-blank
;	Get back pointer
;	Cmp string pointer to original pointer
;	IF NE
;	   STC
;	ELSE
;	   CLC
;	ENDIF
;	ret
;*****************************************************************************

Procedure Skip_Blanks

	push	di				;Preserve DI, just in case
	push	si				;Save pointer to string

$$DO26: 					;Look at entire ASCIIZ string
	cmp	byte ptr [si],ASCIIZ_End	;End of string?
	JE	$$EN26				;Yep, exit loop

	cmp	byte ptr [si],Blank		;Find a blank?
	JE	$$LL28				;Yes

	cmp	byte ptr [si],TAB		;Is it tab?
	JNE	$$IF28				;Yes

$$LL28:
	inc	si				;Bump pointer to next character
	clc					;Indicate found blank
	JMP	SHORT $$EN28			;Not blank or tab

$$IF28:
	stc					;Force exit

$$EN28:
	JNC	$$DO26				;Go look at next character

$$EN26:
	pop	di				;Get back original pointer
	cmp	di,si				;Are they the same?
	JE	$$IF32				;If not equal blanks were found
	stc					;Set CY
	JMP	SHORT $$EN32			;No leading blanks found

$$IF32:
	clc					;Clear CY

$$EN32:
	pop	di				;Restore DI
	ret

Skip_Blanks endp


;*****************************************************************************
;Routine name: Copy_FCB_String
;*****************************************************************************
;
;Description: Build an 11 character string in the FCB from ASCIIZ string
;	      If nothing entered, than terminated with 0. Also add drive
;	      number in FCB
;
;Called Procedures: None
;
;Change History: Created	6/12/87 	MT
;
;Input: DS:SI = String containing volume label input
;
;Output: VOLNAM is filled in with Volume label string
;
;
;
;Psuedocode
;----------
;
;	Save regs
;	Init VolNam to blanks
;	DO
;	LEAVE if character is end of ASCIIZ string
;	   Mov character to FCB
;	   Inc counter
;	ENDDO all 11 chars done
;	Restore regs
;*****************************************************************************

Procedure Copy_FCB_String

	push	di
	push	cx
	push	si				;Save pointer to string
	cld					;Set string direction to up
	mov	di,offset Volnam		;Init FCB field to blanks
	mov	al,Blank
	mov	cx,Label_Length
	rep	stosb
	pop	si				;Get back pointer to string
	mov	di,offset VolNam		;Point at FCB field
	xor	cx,cx				;Init counter

$$DO35: 					;Copy characters over
	cmp	byte ptr [si],ASCIIZ_End	;End of String?
	JE	$$EN35				;Yes, don't copy - leave blanks

	movsb					;Nope, copy character
	inc	cx				;Bump up count
	cmp	cx,Label_Length			;Have we moved 11?
	JNE	$$DO35				;Quit if so
$$EN35:
	pop	cx
	pop	di
	ret

Copy_FCB_String endp


;*****************************************************************************
;Routine name: Check_DBCS_Overrun
;*****************************************************************************
;
;Description: Check 11th byte, if the string is that long, to see
;	      if it is a DBCS character that is split down the middle. Must
;	      scan entire string to properly find DBCS characters, due to
;	      the fact a second byte of a DBCS character can fall into
;	      the range of the first byte environment vector, and thus look
;	      like a DBCS char when it really isn't
;
;Called Procedures: Check_DBCS_Character
;
;Change History: Created	6/12/87 	MT
;
;Input: DS:SI = String containing volume label input
;
;Output: CY set if DBCS character at bytes 11-12 in string
;
;*****************************************************************************

Procedure Check_DBCS_Overrun

	push	si				;Save pointer
	push	ax				;Save registers
	push	cx				;  "  "   "  "
	mov	cx,si				;Get start of string
	add	cx,Label_Length 		;Find where to check for overrun

Check_DBCS_OverRun_Cont:			;Scan string for DBCS chars

	cmp	byte ptr [si],ASCIIZ_End	;End of string?
	je	DBCS_Good_Exit			;Yep

	mov	al,[si]				;Get character for routine
	call	Check_DBCS_Character		;See if DBCS leading character
	JNC	$$IF38				;DBCS if CY set

	inc	si				;Next byte to handle DBCS
	cmp	si,cx				;Is DBCS char spanning 11-12?
	JNE	$$IF39				;truncate string

	mov	byte ptr [si-1],20h;blank it out
	mov	byte ptr [si],20h	;blank it out
	jmp	SHORT DBCS_Good_Exit;exit

$$IF39:
	JMP	SHORT $$EN38			;Not DBCS character

$$IF38:
	mov	al,[si] 			;Get character for routine
	call	Scan_For_Invalid_Char		;See if invalid vol ID char
	jc	DBCS_Bad_Exit			;Bad char entered - exit

$$EN38:
	inc	   si				;Point to next character
	jmp	   Check_DBCS_OverRun_Cont	;Continue looping

DBCS_Good_Exit:
	clc					;Signal no error
	jmp	SHORT DBCS_Exit			;Exit routine

DBCS_Bad_Exit:
	stc					;Signal error

DBCS_Exit:
	pop	cx				;Restore registers
	pop	ax
	pop	si				;Restore string pointer
	ret

Check_DBCS_Overrun endp

;*****************************************************************************
;Routine name: Check_DBCS_Character
;*****************************************************************************
;
;Description: Check if specified byte is in ranges of DBCS vectors
;
;Called Procedures: None
;
;Change History: Created	6/12/87 	MT
;
;Input: AL = Character to check for DBCS lead character
;	DBCS_Vector = YES/NO
;
;Output: CY set if DBCS character
;	 DBCS_VECTOR = YES
;
;
;Psuedocode
;----------
;	Save registers
;	IF DBCS vector not found
;	   Get DBCS environmental vector (INT 21h
;	   Point at first set of vectors
;	ENDIF
;	SEARCH
;	LEAVE End of DBCS vectors
;	EXITIF Character > X1,AND  (X1,Y1) are environment vectors
;	EXITIF Character < Y1
;	  STC (DBCS character)
;	ORELSE
;	   Inc pointer to next set of vectors
;	ENDLOOP
;	   CLC (Not DBCS character)
;	ENDSRCH
;	Restore registers
;	ret
;*****************************************************************************

Procedure Check_DBCS_Character

	push	ds				;Save registers
	push	si
	push	ax
	push	ds
	pop	es				;Establish addressability
	cmp	byte ptr es:DBCS_VECTOR,Yes	;Have we set this yet?
	push	ax				;Save input character
	JE	$$IF43				;Nope

	mov	al,0				;Get DBCS environment vectors
	DOS_Call Hongeul			;  "  "    "  "
	mov	byte ptr es:DBCS_VECTOR,YES	;Indicate we've got vector
	mov	es:DBCS_Vector_Off,si		;Save the vector
	mov	ax,ds
	mov	es:DBCS_Vector_Seg,ax

$$IF43: 					; for next time in
	pop	ax				;Restore input character
	mov	si,es:DBCS_Vector_Seg		;Get saved vector pointer
	mov	ds,si
	mov	si,es:DBCS_Vector_Off

$$DO45: 					;Check all the vectors
	cmp	word ptr ds:[si],End_Of_Vector ;End of vector table?
	JE	$$EN45				;Yes, done

	cmp	al,ds:[si]			;See if char is in vector
	JNAE	$$IF45				;If >= to lower, and

	cmp	al,ds:[si+1]			; =< than higher range
	JNBE	$$IF45				; then DBCS character

	stc					;Set CY to indicate DBCS
	JMP	SHORT $$SR45			;Not in range, check next

$$IF45:
	add	si,DBCS_Vector_Size		;Get next DBCS vector
	JMP	SHORT $$DO45			;We didn't find DBCS char

$$EN45:
	clc					;Clear CY for exit

$$SR45:
	pop	ax				;Restore registers
	pop	si
	pop	ds				;Restore data segment
	ret

Check_DBCS_Character endp

ifdef DBCS
public IsDBCSLeadByte
IsDBCSLeadByte	proc	near
	push	ax
	push	ds
	push	es
	Set_Data_Segment
	call	Check_DBCS_CharACter
	jc	idlb_dbcs
	or	al,1
	jmp	short idlb_ret
idlb_dbcs:
	and	al,0
idlb_ret:
	pop	es
	pop	ds
	pop	ax
	ret
IsDBCSLeadByte	endp
endif

;=========================================================================
; Scan_For_Invalid_Char : This routine scans the bad character table
;			  to determine if the referenced character is
;			  invalid.
;
;	Inputs	: Bad_Char_Table	- Table of bad characters
;		  Bad_Char_Table_Len	- Length of table
;		  AL			- Character to be searched for
;
;	Outputs : CY			- Bad character
;		  NC			- Character good
;=========================================================================

Procedure Scan_For_Invalid_Char

	push	ax				;save ax
	push	cx				;save cx
	push	di				;save di

	lea	di,Bad_Char_Table		;point to bad character table
	mov	cx,Bad_Char_Table_Len		;get its length
	repnz	scasb				;scan the table
	clc					;Assume right
	jne	CharacterSet			;Yes - a good character

	stc					;flag a bad character

CharacterSet:

	pop	di				;restore di
	pop	cx				;restore cx
	pop	ax				;restore ax

	ret

Scan_For_Invalid_Char	endp

;=========================================================================

code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\format.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;page	 84,132
;
;	 SCCSID	= @(#)format.asm 1.26 85/10/20
;	 SCCSID	= @(#)format.asm 1.26 85/10/20
; =======================================================================
;
;	 86-DOS	FORMAT DISK UTILITY
;
;	 This routine formats a	new disk,clears	the FAT	and DIRECTORY then
;	 optionally copies the SYSTEM and COMMAND.COM to this new disk
;
;	 SYNTAX: FORMAT	 [drive][/switch1][/switch2]...[/switch16]
;
;	 Regardless of the drive designator , the user will be prompted	to
;	 insert	the diskette to	be formatted.
;
; =======================================================================
;
;	     5/12/82 ARR Mod to	ask for	volume ID
;	     5/19/82 ARR Fixed rounding	bug in CLUSCAL:
;   REV 1.5
;	     Added rev number message
;	     Added dir attribute to DELALL FCB
;   REV 2.00
;	     Redone for	2.0
;   REV 2.10
;	     5/1/83 ARR	Re-do to transfer system on small memory systems
;   REV 2.20
;	     6/17/83 system size re-initialization bug -- mjb001
;   Rev 2.25
;	     8/31/83 16-bit fat	insertion
;   Rev 2.26
;	     11/2/83 MZ	fix signed compare problems for	bad sectors
;   Rev 2.27
;	     11/8/83 EE	current	directories are	always saved and restored
;   Rev 2.28
;	     11/9/83 NP	Printf and changed to an .EXE file
;   Rev 2.29
;	     11/11/83 ARR Fixed	ASSIGN detection to use	NameTrans call to see
;			 if drive letter remapped. No longer IBM only
;   Rev 2.30
;	     11/13/83 ARR SS does NOT =	CS, so all use of BP needs CS override
;   Rev 2.31
;	     12/27/83 ARR REP STOSB instruction	at Clean: changed to be
;			 sure ES = CS.
;
;   Rev 5.00 Summer '90  SA  Reworked Format code.
; =======================================================================

;
;----------------------------------------------------------------------------
;
; M00x : Assume Media is formatted if Query_BLock_IOCTL is not supported
;	 Bug #4801.
;
;
; M024 : B#5495. Added "Insufficient memory" message when FORMAT cannot
;		allocate memory for FAT, Directory... etc. Reclaimed
;		the msgBadDrive which was not being used. Removed the
;		unwanted EXTRN msgBadDrive.
;
; M025 : Removed obsolete IBMCOPYRIGHT conditional
;
;---------------------------------------------------------------------------
;

;----------------------------------------------------------------------------
;
CODE	 SEGMENT PUBLIC PARA 'CODE'
CODE	 ENDS

; =======================================================================


DATA	 SEGMENT PUBLIC PARA 'DATA'
DATA	 ENDS

; =======================================================================

End_Of_Memory SEGMENT PUBLIC PARA 'BUFFERS'
End_Of_Memory ENDS

; =======================================================================

;===========================================================================
;Declaration of include files
;===========================================================================

debug	 equ	 0
	 .xlist
	 INCLUDE DOSEQUS.INC
	 INCLUDE DOSMAC.INC
	 INCLUDE SYSCALL.INC
	 INCLUDE ERROR.INC
	 INCLUDE CPMFCB.INC
	 INCLUDE DIRENT.INC
	 INCLUDE CURDIR.INC
	 INCLUDE BPB.INC
	 INCLUDE FOREQU.INC
	 INCLUDE FORMACRO.INC
	 INCLUDE IOCTL.INC
	 INCLUDE FORSWTCH.INC
       	 INCLUDE SAFE.INC		; Extrn	declarations for SAFE.ASM
	 INCLUDE SAFEDEF.INC
	 INCLUDE MULT.INC
	 .list

;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;===========================================================================
; Data segment
;===========================================================================

DATA    SEGMENT PUBLIC PARA 'DATA'

;Bytes
	EXTRN	fBigFat	 		:BYTE
	EXTRN	fBig32Fat		:BYTE
	EXTRN	CommandFile		:BYTE
IFDEF DBLSPACE_HOOKS
	EXTRN	DblSpaceFile		:BYTE
ENDIF
	EXTRN	msgNoRoomDestDisk	:BYTE
	EXTRN	msgAssignedDrive	:BYTE
	EXTRN	msgBadDosVersion	:BYTE
	EXTRN	msgDirectoryWriteError	:BYTE
	EXTRN	msgFormatComplete	:BYTE
	EXTRN	msgFormatNotSupported	:BYTE
	EXTRN	msgFatwriteError	:BYTE
	EXTRN	msgLabelPrompt		:BYTE
	EXTRN	msgNeedDrive		:BYTE
	EXTRN	msgNoSystemFiles	:BYTE
	EXTRN	msgNetDrive		:BYTE
	EXTRN	msgInsertDisk		:BYTE
	EXTRN	msgHardDiskWarning	:BYTE
	EXTRN	msgSystemTransfered	:BYTE
	EXTRN	msgFormatAnother?	:BYTE
	EXTRN	msgBadCharacters	:BYTE
	EXTRN	msgParametersNotSupported:BYTE
	EXTRN	msgReInsertDisk 	:BYTE
	EXTRN	msgInsertDosDisk	:BYTE
	EXTRN	msgFormatFailure	:BYTE
	EXTRN	msgNotSystemDisk	:BYTE
	EXTRN	msgDiskUnusable 	:BYTE
	EXTRN	msgOutOfMemory		:BYTE
	EXTRN	msgCurrentTrack 	:BYTE
	EXTRN	msgWriteProtected	:BYTE
	EXTRN	msgInterrupt		:BYTE
	EXTRN	msgCrLf 		:BYTE
	EXTRN	msgShowKBytes		:BYTE
	EXTRN	msgShowMBytes		:BYTE
	EXTRN	msgDecimalMBytes	:BYTE
	EXTRN	msgDecimalNumberofDecimal:BYTE
	EXTRN	msgSysWarning		:BYTE
	EXTRN	msgVerifyShowKBytes	:BYTE
	EXTRN	msgVerifyShowMBytes	:BYTE
	EXTRN	msgVerifyDecimalMBytes	:BYTE
	EXTRN	msgSavingUNFORMATInfo	:BYTE
	EXTRN	msgQuickFormatShowKBytes:BYTE
	EXTRN	msgQuickFormatShowMBytes:BYTE
	EXTRN	msgQuickFormatDecimalMBytes:BYTE
	EXTRN	msgNoExclusiveAccess	:BYTE
	EXTRN	msgFileCreationError	:BYTE
	EXTRN	msgReCalcFree		:BYTE
	EXTRN	msgCalcFreeDone 	:BYTE

	EXTRN	ContinueMsg		:BYTE
	EXTRN	Fatal_Error		:BYTE
	EXTRN	Read_Write_Relative	:BYTE
	EXTRN	Parse_Error_Msg 	:BYTE
	EXTRN	Extended_Error_Msg	:BYTE

	EXTRN	CMCDDFlag		:BYTE		; M033

;Words
	EXTRN	PSP_Segment		:WORD
	EXTRN	TotalClusters		:DWORD

        EXTRN   MsdosRemarkLen          :ABS

;Pointers

;Structures

;===============================
;
; Exit Status defines
;
;===============================

EXIT_OK			equ	0
EXIT_CTRLC		equ	3
EXIT_FATAL		equ	4
EXIT_NO			equ	5
EXIT_DRV_NOT_READY	equ	6	; Drive not ready error
EXIT_WRIT_PROTECT	equ	7	; write protect error

DOSVER_LOW		equ	0300H+20
DOSVER_HIGH		equ	0300H+20

RECLEN			equ	fcb_RECSIZ+7
RR			equ	fcb_RR+7

PSP_Environ		equ	2ch		; location of
						; environ. segment
						; in PSP
MIRROR_SIGNATURE	equ	5050h		; Parameter to Mirror to tell
						; it Format's calling it

SavedParams		EA_DEVICEPARAMETERS	<>	;default
DeviceParameters	EA_DEVICEPARAMETERS	<>	;dynamic
SwitchDevParams 	EA_DEVICEPARAMETERS	<>	;switch-based

.errnz (SIZE A_DEVICEPARAMETERS) GT (SIZE EA_DEVICEPARAMETERS)

Disk_Access		A_DiskAccess_Control   <0,0ffh>
FormatPacket		A_FormatPacket		<>

SetDPBPacket		SDPDFormatStruc 	<>

DirectorySector 	dd	0	; pointer to root directory buffer
FatSpace		dd	?	; pointer to FAT buffer
FatSector		dd	?	; pointer to 1-sector buffer used for
					;  reading old FAT from disk
;No more SAFE module
;HeaderBuf		dd	0	; pointer to header buffer for restore file
DirBuf			dd	0	; pointer to DIR buffer for reading
					;  old fat chains

ExclDrive		db	?
IsExtRAWIODrv		db	0FFh	; 0FFh = Unknown
					; 0 means NO
					; 1 means YES

; ========================================================================

Bios			a_FileStructure <>
dos                     a_FileStructure <>
command 		a_FileStructure <>
IFDEF DBLSPACE_HOOKS
DblSpaceBin		a_FileStructure <>
ENDIF

ValidSavedDeviceParameters	db		0
NoDPChange		db	0	; It is sometimes necessary not to
					; modify the drive parameters, even
					; in a Fatal exit.  This flag is set
					; in that case.
FirstHead		dw	?
FirstCylinder		dw	?
TracksLeft		dd	?	; M018
TracksPerDisk		dd	?	; M018

; ========================================================================

Formatted_Tracks_Low	dw	0
Formatted_Tracks_High	dw	0


NumSectors		dw	0FFFFh
TrackCnt		dw	0FFFFh

Old_Dir 		db	FALSE

SectorsInRootDirectory	dw	?

PrintStringPointer	dw	0

ExitStatus		db	0

SecPerClus		db	0

;entry point for locking Chicago default FSD
public  V86Entry
V86Entry	dd	-1

; =======================================================================

RootStr 		db	?
			db	":\",0
DblFlg			db	0	;Initialize flags to zero
mStart			dw	?	; Start of sys	file buffer (para#)
mSize			dw	?	; Size	of above in paragraphs

					; Storage for users current directory

UserDirs		db	DIRSTRLEN + 3 DUP(?)

; ===========================================================================
	PUBLIC	Paras_Per_Fat
; ===========================================================================

Paras_Per_Fat		dw	0000h		; holds Fat para count


CommandFile_Buffer	db	127	 dup(0) ; allow room for copy


VolFcb			db	-1,0,0,0,0,0,8
VolDrive		db	0
VolNam			db	"           "
			db	8
			db	26 DUP(?)

DelFcb			db	-1,0,0,0,0,0,8
DelDrive		db	0
dELnam			db	"???????????"
			db	8
			db	26 DUP(?)

TranSrc 		db	"A:CON",0,0 ; Device so we don't hit the Drive
TranDst 		db	"A:\",0,0,0,0,0,0,0,0,0,0

BegSeg			dw	?
SwitchMap		dw	?
SwitchMap2		dw	?
SwitchCopy		dw	?
Fat			dw	?
			dw	?
ClusSiz 		dw	?
SecSiz			dw	?
Sectors 		dw	?
InBuff			db	80,0
			db	80 dup(?)


DriveToFormat		db	0
DriveLetter		db	"x:\",0
SystemDriveLetter	db	"x:\",0

Ctrl_Break_Vector	dd	?		 ; Holds CTRL-Break
						 ; vector

Command_Path		dd	 ?		 ; hold pointer to
						 ; COMMAND's path



Environ_Segment 	dw	 ?			 ; hold segment of
						 ; environ. vector
; =======================================================================
;
; Disk Table
; Used if NumberOfFats in BPB
; is 0.
;		I documented this table format some, but I don't know what
;		the low byte of the 3rd word is used for; couldn't find
;		a user!  - jgl
;
; IMPORTANT NOTE: These tables need to be kept in sync with the one in
;		  IO.SYS (MSINIT.ASM)
;
; =======================================================================
ifdef NEC_98

;				disk sectors	sec/	root	12/16 bit
;			     hiword    loword	clus   dirents	fat
SASI1024Table		dw	0,	01800h,	0201h,	512,	0	; 1M- 5M
			dw	0,	02C00h,	0402h,	768,	0	; 6M-10M
			dw	0,	04000h,	0402h,	1024,	0	;11M-15M
			dw	0,	05400h,	0803h,	1280,	0	;16M-20M
			dw	0,	06800h,	0803h,	1536,	0	;21M-25M
			dw	0,	07C00h,	0803h,	1792,	0	;26M-30M
			dw	0,	09000h,	1004h,	2560,	0	;31M-35M
			dw	0,	0A400h,	1004h,	3072,	0	;36M-40M

SCSI1024Table		dw	0,	01400h,	0201h,	512,	0	; 1M- 5M
			dw	0,	02800h,	0402h,	768,	0	; 6M-10M
			dw	0,	03C00h,	0201h,	1024,	Fbig	;11M-15M
			dw	0,	05000h,	0201h,	1280,	Fbig	;16M-20M
			dw	0,	06400h,	0201h,	1536,	Fbig	;21M-25M
			dw	0,	07800h,	0201h,	1792,	Fbig	;26M-30M
			dw	0,	08C00h,	0201h,	2560,	Fbig	;31M-35M
			dw	0,	0A000h,	0201h,	3072,	Fbig	;36M-40M
			dw	1,	00000h,	0201h,	3072,	Fbig	;40M-64M
;follows are 5"MO's Large Partition
			dw	00004h,	00000h,	0402h,	3072,	Fbig	; 129M- 255M
			dw	00008h,	00000h,	0803h,	3072,	Fbig	; 256M- 511M
			dw	00010h,	00000h,	1004h,	3072,	Fbig	; 512M-1023M
			dw	00020h,	00000h,	2005h,	3072,	Fbig	;1024M-2047M

Small2048Table		dw	00001h,	00000h,	0201h,	3072,	Fbig	;65M-128M

Large512Table		dw	00008h,	00000h,	0803h,	3072,	Fbig	; 129M- 255M
			dw	00010h,	00000h,	1004h,	3072,	Fbig	; 256M- 511M
			dw	00020h,	00000h,	2005h,	3072,	Fbig	; 512M-1023M
			dw	00040h,	00000h,	4006h,	3072,	Fbig	;1024M-2047M

Large256Table		dw	00010h,	00000h,	1004h,	3072,	Fbig	; 129M- 255M
			dw	00020h,	00000h,	2005h,	3072,	Fbig	; 256M- 511M
			dw	00040h,	00000h,	4006h,	3072,	Fbig	; 512M-1023M
			dw	00080h,	00000h,	8007h,	3072,	Fbig	;1024M-2047M
else

;				disk sectors	sec/	root	12/16 bit
;			     hiword    loword	clus   dirents	fat

DiskTable		dw   00000h,   07FA8h,	0803h,	512,	0
			dw   00004h,   00000h,	0402h,	512,	Fbig
			dw   00008h,   00000h,	0803h,	512,	Fbig
			dw   00010h,   00000h,	1004h,	512,	Fbig
			dw   00020h,   00000h,	2005h,	512,	Fbig
			dw   00040h,   00000h,	4006h,	512,	Fbig
    ; The following entry is NOT included because it is INVALID.
    ; 64k clusters does not work in many many applications because
    ; a computation of bytes/cluster does not fit in a WORD with
    ; a 64k cluster.
;;;;			dw    00080h,  00000h,	8007h,	512,	Fbig
endif

disktable2		dw    00008h,  02000h,	0100h,	  0,	Fbig32
			dw    00100h,  00000h,	0803h,	  0,	Fbig32
			dw    00200h,  00000h,	1004h,	  0,	Fbig32
			dw    00400h,  00000h,	2005h,	  0,	Fbig32
			dw    0FFFFh,  0FFFFh,	4006h,	  0,	Fbig32

Org_AX			dw	?			 ;AX	on entry

ClustBound_Adj_Factor	dw	?


ClustBound_SPT_Count	dw	?


ClustBound_Flag		db	False



ClustBound_Buffer_Seg	dw	?

; WARNING the next two are accessed as a DWORD
Relative_Sector_Low	dw	?
Relative_Sector_High	dw	?

Fat_Flag		db	?

Msg_Allocation_Unit_Val dd	?

SizeInK			dw	0		; Variables used in format size message
SizeInM			dw	0
DecSizeInM		dw	0

RWErrorCode		dw	0		; Used to save error code returned
						; from Int25/26 in ReadWriteSectors,
						; module SAFE. Used by Phase1Initialisation
FoundN			db	FALSE		; flag used in search for N contiguous clusters
Cluster 		dd	0		; cluster variable used in FAT search

sector_to_read		DD	?		; Logical sector number of FAT required
sector_in_buffer	DD	0ffffffffh	; FAT sector currently in memory, init.
						;  to high value to force first read
NumClusters		DD	?		; Holds #clusters required for 1.5K
						;  (Will be 1,2 or 3)

EndValue		DD	?		; Holds FAT entry value for end of chain

IFDEF DBLSPACE_HOOKS
fDblSpace		db	FALSE		; TRUE if DblSpace.bin found
ENDIF

FirstPrompt		db	0		; NZ if special 1st DblSpace
						;   user prompt

GEAState		db	0		; Exclusive Access State
GEAFFState		db	0		; Exclusive Access for format
						;  state
UnderWin?		db	0		; Running under windows ?
AlignCount              dw      0

DATA	ENDS

;===========================================================================
; Executable code segment
;===========================================================================

CODE	 SEGMENT PUBLIC  PARA	 'CODE'

	 ASSUME  CS:CODE,DS:NOTHING,ES:NOTHING


;Functions
	EXTRN	Global_Init		:NEAR
	EXTRN	Phase1Initialisation	:NEAR
	EXTRN	Disk_Format_Proc	:NEAR
	EXTRN	SetDeviceParameters	:NEAR
	EXTRN	Prompt_User_For_Disk	:NEAR
	EXTRN	Multiply_32_Bits	:NEAR
	EXTRN	calc_sector_and_offset	:NEAR
	EXTRN	ReadFatSector		:NEAR
	EXTRN	GetFatSectorEntry	:NEAR
	EXTRN	Yes?			:NEAR
	EXTRN	Check_for_Dblspace	:NEAR
	EXTRN	IsDblSpaceLoaded	:NEAR
	EXTRN	GetAutoMountState	:NEAR
	EXTRN	DisableAutoMountState	:NEAR
	EXTRN	RestoreAutoMountState	:NEAR
	EXTRN	FlushFATBuf		:NEAR
	EXTRN	IsThisClusterBad	:NEAR
	EXTRN	WrtEOFMrkInRootClus	:NEAR
	EXTRN	GetDeviceParameters	:NEAR
	EXTRN	ModifyDevPrmsForZSwich	:NEAR
	EXTRN	Get_Free_Space		:NEAR

;Labels
	EXTRN	WriteDos 		:NEAR

; =======================================================================
;
; Define as public for	debugging
;
; =======================================================================

; procedures

	PUBLIC	ShrinkMemory
	PUBLIC	InitSysParm
	PUBLIC	ZeroAllBuffers
	PUBLIC	ZeroBuffer
	PUBLIC	WriteDiskInfo
	PUBLIC	RestoreDevParm
	PUBLIC	AddToSystemSize
	PUBLIC	Div32
	PUBLIC	Phase2Initialization
	PUBLIC	ShowFormatSize
	PUBLIC	Done
	
	PUBLIC	GetCmdSize
	PUBLIC	Start
	PUBLIC	More
	PUBLIC	FatalExit
	PUBLIC	SysPrm
	PUBLIC	IsRemovable
	PUBLIC	CrLf
	PUBLIC	PrintString
	PUBLIC	Std_Printf
	PUBLIC	Main_Routine
	PUBLIC	ControlC_Handler
	PUBLIC	GetBioSize
	PUBLIC	GetDosSize
	PUBLIC	AddToSystemSize
ifdef   OPKBLD
        PUBLIC  NTFSFriendlyFAT
endif   ;OPKBLD

; bytes
	PUBLIC	RootStr
	PUBLIC	DblFlg
	PUBLIC	DriveToFormat
	PUBLIC	UserDirs
	PUBLIC	VolFcb
	PUBLIC	VolNam
	PUBLIC	TranSrc
	PUBLIC	TranDst
	PUBLIC	InBuff
	PUBLIC	DriveLetter
	PUBLIC	SystemDriveLetter
	PUBLIC	ExitStatus
	PUBLIC	VolDrive
	PUBLIC	DelFcb
	PUBLIC	DelDrive
	PUBLIC	Fat_Flag
	PUBLIC  Old_Dir
	PUBLIC	ClustBound_Flag
	PUBLIC	ValidSavedDeviceParameters
	PUBLIC	NoDPChange
IFDEF DBLSPACE_HOOKS
	PUBLIC	fDblSpace
ENDIF

; words
	PUBLIC	FatSpace
	PUBLIC	FirstHead
	PUBLIC	FirstCylinder
	PUBLIC	TracksLeft
	PUBLIC	TracksPerDisk
	PUBLIC	SectorsInRootDirectory
	PUBLIC	PrintStringPointer
	PUBLIC	mStart
	PUBLIC	mSize
	PUBLIC	BegSeg
	PUBLIC	SwitchMap
	PUBLIC	SwitchMap2
	PUBLIC	SwitchCopy
	PUBLIC	Fat
	PUBLIC	ClusSiz
	PUBLIC	SecSiz
	PUBLIC	Formatted_Tracks_High
	PUBLIC	Formatted_Tracks_Low
	PUBLIC  NumSectors
	PUBLIC	SecPerClus
	PUBLIC  TrackCnt
	PUBLIC  Org_AX
	PUBLIC	ClustBound_Adj_Factor
	PUBLIC	ClustBound_SPT_Count
	PUBLIC	ClustBound_Buffer_Seg
	PUBLIC	Relative_Sector_Low
	PUBLIC	Relative_Sector_High
	PUBLIC	Environ_Segment
	PUBLIC	RWErrorCode
	PUBLIC	SizeInK
	PUBLIC	SizeInM
	PUBLIC	DecSizeInM
	PUBLIC	sector_to_read
	PUBLIC	sector_in_buffer
        PUBLIC  AlignCount

;constants
	PUBLIC  EXIT_OK
	PUBLIC	EXIT_CTRLC		
	PUBLIC	EXIT_FATAL	
	PUBLIC	EXIT_NO			
	PUBLIC	EXIT_DRV_NOT_READY	
	PUBLIC	EXIT_WRIT_PROTECT	

;pointers
	PUBLIC	DirectorySector
	PUBLIC	FatSpace
	PUBLIC  FatSector
	PUBLIC  DirBuf

	

; other
	PUBLIC	DeviceParameters
	PUBLIC	IsExtRAWIODrv
	PUBLIC	SetDPBPacket
	PUBLIC	SavedParams
	PUBLIC	SwitchDevParams
	PUBLIC	Disk_Access
	PUBLIC	FormatPacket
	PUBLIC	bios
        PUBLIC  dos
	PUBLIC	command
IFDEF DBLSPACE_HOOKS
	PUBLIC	DblSpaceBin
ENDIF
	PUBLIC	Msg_Allocation_Unit_Val
ifdef NEC_98
	PUBLIC	SASI1024Table
	PUBLIC	SCSI1024Table
	PUBLIC	Small2048Table
	PUBLIC	Large512Table
	PUBLIC	Large256Table
else
	PUBLIC  DiskTable
endif
	PUBLIC	DiskTable2
	PUBLIC	ExitProgram
	PUBLIC	SEG_ADJ

;For FORPROC and FORMES modules

	PUBLIC	ClusSiz
	PUBLIC	InBuff
	PUBLIC	CrLf
	PUBLIC	Std_Printf
	PUBLIC	DriveLetter
	PUBLIC	PrintString

	EXTRN	CheckSwitches		:NEAR
	EXTRN	LastChanceToSaveIt	:NEAR
	EXTRN	VolId			:NEAR
	EXTRN	WriteBootSector 	:NEAR
	EXTRN	OemDone 		:NEAR
	EXTRN	AccessDisk		:NEAR
	EXTRN	Main_Init		:NEAR
	EXTRN	Read_Disk		:NEAR
	EXTRN	Write_Disk		:NEAR

; =======================================================================

DATA	SEGMENT PUBLIC	 PARA	 'DATA'

	EXTRN	BiosFile		:BYTE
	EXTRN	SysSiz			:DWORD
	EXTRN	BioSiz			:DWORD
	EXTRN	UnformattedHardDrive	:BYTE

DATA	ENDS

; =======================================================================
;
; For FORPROC module
;
; =======================================================================

	EXTRN	FormatAnother?		:NEAR
	EXTRN	report			:NEAR
	EXTRN	user_string		:NEAR

; =======================================================================

;************************************************************************							
; =======================================================================
;
; Entry point to DOS format program.
;
; =======================================================================
;************************************************************************

Start:
	xor	BX,BX
	push	BX
	Set_Data_Segment
	mov	Org_AX,AX			; save AX on entry

	mov	ax, 1600h
	int	2fh				; under win ?
	test	al, 7fh
	jz	not_under_win
	inc	UnderWin?
not_under_win:
	call	Main_Init

	mov	al, DriveToFormat
	call	GetAutoMountState		; Save current automount state
	call	DisableAutoMountState		; Normally off to speed up fmt

	mov	DX,SwitchMap			; save a copy of SwitchMap
	mov	SwitchCopy,DX

Main_Routine:				
	call	ShrinkMemory			; set memory requirements

	; If DblSpace is active, the drive to format may have strange device
	; parameters due to [auto]mounted DblSpace drives.  If DS is loaded,
	; have the user put in the disk early so we can auto[UN]mount and
	; tell him/her/it if there is a problem.
        ;
        ; NOTE: Global_Init sets global state based upon the drive
        ;       parameters (media sense IOCtl), so to minimize the
        ;       disruption of the source code, we need to find out about
        ;       the true drive parameters right now.

	call	IsDblSpaceLoaded		; no DblSpace, no problem
	jnz	NoDblSpace

	lea	DX, DeviceParameters			; Prompt_User_For_Disk
	mov	DeviceParameters.DP_SpecialFunctions, 0 ;   needs something in
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS
	call	GetDeviceParameters			;   DeviceParameters
	jc	NoDblSpace

	call	Prompt_User_For_Disk		; Ask user to insert disk in
	mov	FirstPrompt, 1			;   drive

	call	Check_For_Dblspace		; Will force auto[UN]mount and
	cmp	Fatal_Error, Yes		;   tell user if DblSpace drive
	jne	the_usual

        ; User told us not to reformat Dblspace host drive.  Use
        ; a slightly different exit path to get out of here so that
        ; we guarantee that the disk access flag is properly reset.

	inc	NoDPChange			; Not necc. to modify drive
	Set_Data_Segment			; Ensure addressibility
	jmp	FatalExit_0     		; Exit if DblSpace drive

NoDblSpace:

; M033 - begin
; M031: With memory card, we cannot do a GetDefaultBPB prior to having
; inserted the media. This code should normally be put in glblinit.asm
; but version.inc is not included (Why?).

	cmp	CMCDDFlag, Yes
	jne	the_usual			; If not CMCDD, do the old logic

	call	Prompt_User_For_Disk		; Else ask the user to insert
						; the disk NOW
the_usual:
	call	Global_Init    			; allocate buffers, read in
						; system files if needed
	jnc	FatAllocated			; check for failure

FatalExiting:					; M031; just the label
	Message msgFormatFailure
	inc	NoDPChange			; Not necc. to modify drive
						; parameters if Global_Init failed
	jmp	FatalExit

FatAllocated:
SysLoop:
	mov	NoDPChange,0			; M004; assume we will restore
	call	InitSysParm 			; initialize some parameters
						; for each format iteration
	xor	ax,ax				; Silent version, did noisy
						;  in call to Global_Init
	call	ModifyDevPrmsForZSwich
	jc	NotThisDisk

ifdef NEC_98
    ; for 3.5"MO
	cmp	DeviceParameters.DP_DeviceType, DEV_HARDDISK	; Hard disk?
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	@F						; No

	test	DeviceParameters.DP_DeviceAttributes, 1		; Removable?
    .errnz EDP_DEVICEATTRIBUTES NE DP_DEVICEATTRIBUTES
	jz	$$IF101						; Yes
@@:
endif
	call	ZeroAllBuffers			; initialize buffers
ifdef NEC_98
$$IF101:
endif

	cmp	CMCDDFlag, Yes
	jne	the_usual2			; If CMCDD, let's make sure

	lea	DX, DeviceParameters		; Get the default drive parameters
						; (again!)
	mov	DeviceParameters.DP_SpecialFunctions, 0
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS
	call	GetDeviceParameters
	jc	NotThisDisk

	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
	cmp	AX, SavedParams.DP_BPB.oldBPB.BPB_SectorsPerFat
    .errnz EDP_BPB NE DP_BPB
	ja	NotThisDisk
	or	ax,ax				; BigFAT?
	jnz	ChkRoot 			; No
.386
	mov	EAX, dword ptr DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
	cmp	EAX, dword ptr SavedParams.DP_BPB.BGBPB_BigSectorsPerFat
    .errnz EDP_BPB NE DP_BPB
.8086
	ja	NotThisDisk
ChkRoot:
	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_RootEntries
	cmp	AX, SavedParams.DP_BPB.oldBPB.BPB_RootEntries
    .errnz EDP_BPB NE DP_BPB
	jbe	go_on

NotThisDisk:
	Message msgFormatNotSupported
	jmp	SHORT FatalExiting

the_usual2:
	xor	al, al				; When DblSpace is loaded, the
	xchg	FirstPrompt, al 		;   user is prompted early the
	or	al, al				;   first time through
	jnz	NotDblSpaceDrive

	call	Prompt_User_For_Disk		; Else ask the user to insert the disk
go_on:

	; The user may have inserted a DblSpaced disk.	Force it to automount
	; and complain if so.

	call	Check_for_Dblspace		; Is this a DblSpace disk?
	cmp	Fatal_Error, Yes		; If so we will not format it
	jne	NotDblSpaceDrive

	inc	NoDPChange			; Not necc. to modify drive
	jmp	short FatalExit		        ; parameters if DblSp drive

NotDblSpaceDrive:
	mov	al, DriveToFormat
	mov	ExclDrive, al			; indicate the correct drive
						; for exclusive access
	call	GetExclusiveAccess
	jc	exclusive_access_failed		; lock failed.  Abort Format

check_access:
	call	Get_Disk_Access			; ensure disk access

	call	Phase1Initialisation		; determine deviceparameters
	jnc	@f

	inc	NoDPChange			; Not necc. to modify drive
						; parameters if Phase1 failed
	jmp	SHORT NextDisk			; M004; prompt for next disk

@@:
	call	Phase2Initialization		; determine starting points

	call	GetExclusiveAccessForFormat
        jnc     DoFmt
	inc	NoDPChange			; Not necc. to modify drive
						; parameters if Global_Init failed
	jmp	short exclusive_access_failed
DoFmt:
ifdef OPKBLD
	; check for /A switch
        test    SwitchMap2, SWITCH2_A
        jz      NoNTFSFriendly
        call    NTFSFriendlyFAT
NoNTFSFriendly:
endif ;OPKBLD

	call	Disk_Format_Proc
	jc	NextDisk			; Prompt for next disk if error
	call	WriteDiskInfo			; write out the control information
	cmp	ExitStatus,EXIT_NO		; does user want to continue?
	jz	ExitProgram			; terminate program

NextDisk:
	call	ReleaseExclusiveAccessForFormat

	; release exclusive access ... If we are not running under
	; chicago, then this call will fail, but should not harm anything ...

	call	ReleaseExclusiveAccess

	call	RestoreDevParm			; Restore device parameters
	call	More				; See if More disks to format
	jc	ExitProgram
	jmp	SysLoop 			; Continue if no carry

ExitProgram:

	call	ReleaseExclusiveAccessForFormat

	; release exclusive access ... If we are not running under
	; chicago, then this call will fail, but should not harm anything ...

	call	ReleaseExclusiveAccess

	call	Format_Access_Wrap_Up		; Determine access status

	mov	AH,DISK_RESET			; Do a disk reset (flush buffers)
	int	21h

	call	RestoreAutoMountState		; Enable automount if necessary

	mov	AL,ExitStatus			; Get Errorlevel
	DOS_Call Exit				; Exit program
	int	20h				; If other exit	fails


FatalExit:
	Set_Data_Segment			; Ensure addressibility
	mov	ExitStatus,EXIT_FATAL

FatalExit_0:    ; alternative jump target to avoid resetting ExitStatus
	call	RestoreDevParm			; Restore device parameters
	jmp	SHORT ExitProgram		; Perform normal exit

public exclusive_access_failed
exclusive_access_failed:
 
	; print up the failure message
	Message	msgNoExclusiveAccess

	; goto the fatal exit routine
	Set_Data_Segment
	mov	ExitStatus,EXIT_OK
	jmp	FatalExit_0


;=========================================================================
;  SHRINKMEMORY :	This procedure resizes the memory block allocated
;			to the format utility by calling Int 21H Function
;			4AH (74).  This is done in order to make room for
;			the FAT buffers.
;
;  CALLS :		none
;  CALLED BY :		Main
;  MODIFIES :		BX, ES, AH
;
;=========================================================================

ShrinkMemory	proc	near

	mov	BX,PSP_Segment			; Shrink to free space for Fat
	mov	ES,BX
	mov	BX,End_Of_Memory
	sub	BX,PSP_Segment
	Dos_Call Setblock
	ret

ShrinkMemory	endp

;=========================================================================
; Get_Disk_Access	 : This	routine	will determine the access state	of
;			   the disk.  If access is currently not allowed, it
;			   will be allowed by calling Set_Disk_Access_On_Off.
;
;
;	 Inputs	 : DX -	pointer	to buffer
;	 Outputs : Disk_Access.DAC_Access_Flag - 0ffh signals access allowed
;						 to the	disk previously.
;		   Access to the disk will be allowed.
;
;  CALLS :	Set_Disk_Access_On_Off
;  CALLED BY :  Main
;  MODIFIES :	Disk_Access.DAC_Access_Flag
;
;  M00x : This routine was re-worked for this modification
;
;=========================================================================

Procedure Get_Disk_Access

	push	AX				; Save regs
	push	BX
	push	CX
	push	DX

	mov	UnformattedHardDrive,FALSE	; Assume formatted disk
	mov	Disk_Access.DAC_Access_Flag, 0ffh; Assume we already have
						;  access to disk

	mov	AX,(IOCTL shl 8) or IOCTL_QUERY_BLOCK ; Check if function supported
	xor	BX,BX				; Clear BX
	mov	BL,DriveToFormat		; Get Drive letter
	inc	BL				; Make it 1 based

	mov	CX,(RAWIO shl 8) or Get_Access_Flag ; Determine disk access
	cmp	IsExtRAWIODrv,0
	je	DoIOCTL1
	mov	CX,(EXTRAWIO shl 8) or Get_Access_Flag ; Determine disk access
DoIOCTL1:

	lea	DX,Disk_Access			; Point to parm list
 	int 	21h
	jc	gda_exit			;Not supported on carry

	mov	AX,(IOCTL shl 8) or Generic_IOCTL  ;Now can perform generic IOCtl call
	int	21h
	cmp	Disk_Access.DAC_Access_Flag,01h	; Access is currently allowed?
	jne	@f
	mov	Disk_Access.DAC_Access_Flag,0ffh; Mark that we already have
						;  access to disk
	jmp	short gda_exit
@@:
						; not previously allowed
	mov	UnformattedHardDrive,TRUE	; Won't do CheckExistingFormat
	inc	Disk_Access.DAC_Access_Flag	; signal disk access
	call	Set_Disk_Access_On_Off		; allow disk access

gda_exit:
	pop	DX				; Restore regs
	pop	CX
	pop	BX
	pop	AX
	ret

Get_Disk_Access ENDP

;===========================================================================
;
;  ZeroAllBuffers :	This procedure initializes all allocated buffers
;			by filling them with zeroes.
;
;  Buffers Modified :	DirectorySector
;			FatSpace
;			FatSector
;			xxxHeaderBufxxx (No more SAFE module)
;			DirBuf
;
;  Registers Modified:	AX,BX,CX,DI
;
;===========================================================================

ZeroAllBuffers	proc	NEAR

	Set_Data_Segment
	push	ES

	les	DI,DirectorySector	; ES:DI --> DirectorySector buffer
	mov	CX,DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
    .errnz EDP_BPB NE DP_BPB
	call	ZeroBuffer

	; Not neccessary to init. FatSpace here since
	; this is done in DSKFRMT

	les	DI,FatSector		; ES:DI --> FatSector buffer
	mov	CX,DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	call	ZeroBuffer

	les	DI,DirBuf
	mov	CX,DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	call	ZeroBuffer

	pop	ES

	ret

ZeroAllBuffers	endp

;=========================================================================
;
;  ZeroBuffer :		This procedure initializes buffer space to zero.
;			Note: This routine will not work for buffer sizes
;			greater than 64K, due to segment wrap.
;
;  Assumes     :	ES:DI gives location of buffer
;			CX = size of buffer in bytes
;  Modifies    :	AX, CX
;
;=========================================================================

ZeroBuffer	proc	near

	xor	AX,AX
	shr	CX,1		; Get buffer size in words
	rep	stosw

	ret

ZeroBuffer	endp

; ==========================================================================
;
; IsRemovable :  Determine if the Drive indicated in BX is removable or not.
;
;
;   Inputs:	 BX has	Drive (0=def, 1=A)
;   Outputs:	 Carry clear
;		     Removable
;		 Carry set
;		     not removable
;   Registers modified: DX
; ==========================================================================

IsRemovable PROC NEAR

	SaveReg <AX>
	mov	AX,(IOCTL shl 8) OR 8		; Rem media check
	int	21H
	jnc	CheckRemove

	mov	AX,(IOCTL shl 8) + 9		; Is it a NET Drive?
	int	21h
	jc	NotRemove			; Yipe, say non-removable

	test	DX,1000h
	jnz	NotRemove			; Is NET Drive, flag non-removeable
	jmp	SHORT IsRemove			; Is local, say removable

CheckRemove:
	test	AX,1
	jnz	NotRemove

IsRemove:
	clc
	RestoreReg <AX>
	return

NotRemove:
	stc
	RestoreReg <AX>
	ret

IsRemovable ENDP

;=========================================================================
; Set_Disk_Access_On_Off: This	routine	will either turn access	on or off
;			   to a	disk depending on the contents of the
;			   buffer passed in DX.
;
;	 Inputs	 : DX -	pointer	to buffer
;
;=========================================================================

Procedure Set_Disk_Access_On_Off

	push	AX				; Save regs
	push	BX
	push	CX
	push	DX

	xor	BX,BX				; Clear BX
	mov	BL,DriveToFormat		; Get Drive number
	inc	BL				; Make it 1 based
	call	IsRemovable			; See if removable media
	jnc	$$IF126 			; Not removable

	mov	AX,(IOCTL shl 8) or IOCTL_QUERY_BLOCK ; Check if function supported
	xor	BX,BX				; Clear BX
	mov	BL,DriveToFormat		; Get Drive letter
	inc	BL				; Make it 1 based

	mov	CX,(RAWIO shl 8) or Set_Access_Flag ; Allow access to disk
	cmp	IsExtRAWIODrv,0
	je	DoIOCTL2
	mov	CX,(EXTRAWIO shl 8) or Set_Access_Flag
DoIOCTL2:
	int	21h
	jc 	$$IF126				; Not supported on carry
	mov	AX,(IOCTL shl 8) or Generic_IOCTL  ; Can now perform generic IOCTL
   	int	21h

$$IF126:
	pop	DX				; Restore regs
	pop	CX
	pop	BX
	pop	AX

	ret

Set_Disk_Access_On_Off ENDP

;========================================================================
;
;  INITSYSPARM :	This procedure initializes parameters for each
;			iteration of the disk format process.
;
;  CALLS :	none
;  CALLED BY :	Main
;  MODIFIES :	SysSiz
;		SysSiz+2
;		ExitStatus
;		DblFlg
;		SwitchMap
;		sector_in_buffer
;		RWErrorCode
;		old_dir
;		DeviceParameters.DP_BPB (reset to SavedParams)
;
;========================================================================

InitSysParm	proc	near

.386
	mov	SysSiz,0			; Must intialize for each
						; iteration
.8086
	mov	ExitStatus, EXIT_OK
	mov	DX,SwitchCopy			; restore original SwitchMap
	mov	SwitchMap,DX			; for each disk formatted
.386
	mov	sector_in_buffer,0ffffffffh	; Initialize to force first read
.8086
	mov	RWErrorCode,0			; error code from reading disk
	mov	Old_Dir,FALSE
	push	DS				; copy DS into ES
	pop	ES

	mov	SavedParams.DP_SpecialFunctions,0 ; restore to original value
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS
	mov	SI,OFFSET SavedParams		; DS:SI --> source parameters
	mov	DI,OFFSET DeviceParameters	; ES:DI --> dest. parameters
	mov	CX,SIZE EA_DEVICEPARAMETERS	; bytes to move

	cld
	rep	movsb	

	ret

InitSysParm	ENDP


; ==========================================================================
; Calculate the size in bytes of the system rounded up to sector and
; cluster boundries, the store answer in SysSiz
; ==========================================================================

GetSize proc	 near

	call	GetBioSize
	call	GetDosSize
	call	GetCmdSize
IFDEF DBLSPACE_HOOKS
	call	GetDblSize
ENDIF
	return

GetSize endp

; ==========================================================================

GetBioSize proc near

	mov	AX,WORD PTR Bios.fileSizeInBytes
	mov	DX,WORD PTR Bios.fileSizeInBytes+2
	call	AddToSystemSize
	return

GetBioSize endp

; ==========================================================================

GetDosSize proc near

        mov     AX,WORD PTR dos.fileSizeInBytes
        mov     DX,WORD PTR dos.fileSizeInBytes+2
	call	AddToSystemSize
	return

GetDosSize endp

; ==========================================================================

GetCmdSize proc near

	 mov	 AX,WORD PTR command.fileSizeInBytes
	 mov	 DX,WORD PTR command.fileSizeInBytes+2
	 call	 AddToSystemSize
	 return

GetCmdSize endp

IFDEF DBLSPACE_HOOKS
; ==========================================================================
GetDblSize proc near

	 mov	 AX,WORD PTR DblSpaceBin.fileSizeInBytes
	 mov	 DX,WORD PTR DblSpaceBin.fileSizeInBytes+2
	 call	 AddToSystemSize
	 return

GetDblSize endp
ENDIF

; ==========================================================================
;
; Calculate the	number of Sectors used for the system
;
; Input:	DX:AX holds size to be added on
; Ouput:	Updated SysSiz variable
;
; ==========================================================================

AddToSystemSize proc near

	push	BX
	div	DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
    .errnz EDP_BPB NE DP_BPB
	or	DX,DX
	jz	FNDSIZ0
	inc	AX			; Round up to next sector
FNDSIZ0:
	push	AX
	xor	DX,DX
	xor	BX,BX
	mov	bl, DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
	div	BX
	pop	AX
	or	DX,DX
	jz	OnClus
	sub	DX, BX
	neg	dx
	add	AX,DX			; Round up sector count to cluster
					; boundry
OnClus:
	mul	DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	add	WORD PTR SysSiz,AX
	adc	WORD PTR SysSiz+2,DX
	pop	BX
	return

AddToSystemSize endp

; ==========================================================================
;
; ChkSpace - Check free space to see if there is enough room to load the
;	      system.
;	 On entry: DL =	Drive
;	 On exit:  carry flag set if not enough	room
;		   no other registers are affected
;
; ==========================================================================

Procedure ChkSpace

	push	AX			; Save	registers
	push	BX
	push	CX
	push	DX
    ;
    ; NOTE that the following should be changed to use
    ;	GetExtendedDiskFreeSpace, but it really doesn't need
    ;	to change because all it is doing is checking if there
    ;	is enough space for the system files. The "cooked" 2Gig
    ;	32k/cluster return is good enough to do this.
    ;
	mov	AH,36h			; Get free space
	int	21h
					; 16 bit math okay here
					; no danger of overflow
	mul	CX			; Get bytes/cluster
	mov	CX,AX
	mov	AX,WORD PTR SysSiz	; Get # of bytes for system
	mov	DX,WORD PTR SysSiz+2
	div	CX			; Get # of clusters for system

	cmp	AX,BX			 ; Is there enough space?
	jbe	EnoughSpace		 ;  Y: Go clear	carry
	stc				 ;  N: Set carry
	jmp	short RestoreRegs

EnoughSpace:
	clc

RestoreRegs:
	pop	DX			 ; Restore registers
	pop	CX
	pop	BX
	pop	AX
	ret

ChkSpace endp

; ==========================================================================
;
;  More :	This procedure prompts the user for the formatting of
;		another disk.
;
;  Output  :	User wants to continue - CY clear
;		User wants to exit     - CY set
;
; ==========================================================================

More PROC NEAR
	
	mov	Formatted_Tracks_Low,0		; Reinit the track counter
	mov	Formatted_Tracks_High,0		; in case of another format

; Begin M035		
	cmp	CMCDDFlag, Yes			; If flash disk we don't
	jne	@f				; allow multiple formats
	stc					; so signal an exit
	jmp	SHORT Exit_More
@@:
;end m035
						; If exec'd from select, then
						; don't give user choice
ifdef NEC_98
	test	SwitchMap2,SWITCH2_P
	jz	@F
	stc  					; flag automatic 'no' response
	jmp	SHORT Exit_More
@@:
endif
	test	SwitchMap,(SWITCH_SELECT or SWITCH_AUTOTEST or SWITCH_BACKUP)
	jz	@F
	stc  					; flag automatic 'no' response
	jmp	SHORT Exit_More

@@:						; Would not want to format
						; another hard disk!
	cmp	DeviceParameters.DP_DeviceType,DEV_HARDDISK
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jnz	NotAHardDisk
	stc  					; flag automatic 'no' response
	jmp	SHORT Exit_More

NotAHardDisk:
	call	FormatAnother?			; Get yes or no	response
        pushf                                   ; Save the result
        call    CrLf                            ; One new line
        popf                                    ; Get the result back
	jnc	WantsToContinue
;M002; Do not change ExitStatus
	stc
	jmp	SHORT Exit_More

WantsToContinue:
	call	CrLf

						; M033
	cmp	CMCDDFlag, Yes
	jne	more_standard_exit

	call	Prompt_User_For_disk		; If FLASH, we ask the
						; disk here if yes to more

more_standard_exit:

	clc

Exit_More:
	ret

More ENDP

; ==========================================================================
;
;  RestoreDevParm :	This procedure will prepare for exiting the program
;			by restoring the device parameters to their original
;			value.
;			Note: A call to SetDeviceParameters has the following
;			results:
;			With bit 0 of the SpecialFunctions byte SET,
;				BPB in parameter block is copied into BDS_BPB
;			With bit 0 of the SpecialFunctions byte RESET,
;				BPB in parameter block is copied into BDS_RBPB
;
; ==========================================================================

RestoreDevParm	proc	near

	cmp	CMCDDFlag, Yes			; This extra set_DPB would
	je	EndRestoreDevParm		; make the current card have
						; the size of the first card.
	test	ValidSavedDeviceParameters, 0ffH
	jz	EndRestoreDevParm

	cmp	ExitStatus,EXIT_FATAL
	jnz	Non_Fatal			; NZ --> ExitStatus!=EXIT_FATAL

	test	NoDPChange,0ffh			; Check if drive parameters should not be modified
	jnz	Non_Fatal			; NoDPChange=1 --> do not modify

	; For a Fatal exit, it is necessary to reset the
	; BDS_BPB to the default settings, since it may have
	; been set to an invalid value

	cmp	IsExtRAWIODrv,0
	je	OldTabOff1

	mov	SavedParams.EDP_TrackTableEntries,0
	jmp	short TabSet1

OldTabOff1:
	mov	SavedParams.DP_TrackTableEntries,0	; There is no track layout info in SavedParams


TabSet1:
	mov	SavedParams.DP_SpecialFunctions,INSTALL_FAKE_BPB or TRACKLAYOUT_IS_GOOD
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS

	lea	DX, SavedParams
	call	SetDeviceParameters

	mov	FormatPacket.FP_SpecialFunctions,STATUS_FOR_FORMAT
	mov	AX,(IOCTL shl 8) or GENERIC_IOCTL
	mov	BL,DriveToFormat
	inc	BL

	mov	CX,(RAWIO shl 8) or FORMAT_TRACK
	cmp	IsExtRAWIODrv,0
	je	DoIOCTL3
	mov	CX,(EXTRAWIO shl 8) or FORMAT_TRACK
DoIOCTL3:
	lea	DX,FormatPacket
	int	21h

Non_Fatal:
	cmp	IsExtRAWIODrv,0
	je	OldTabOff2

	mov	SavedParams.EDP_TrackTableEntries,0
	jmp	short TabSet2

OldTabOff2:
	mov	SavedParams.DP_TrackTableEntries,0	; There is no track layout info in SavedParams
TabSet2:
	mov	SavedParams.DP_SpecialFunctions,TRACKLAYOUT_IS_GOOD
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS
	lea	DX, SavedParams
	call	SetDeviceParameters

EndRestoreDevParm:
	ret

RestoreDevParm	endp

;==========================================================================
;
;  SysPrm :	This procedure prompts the user for a system diskette
;		in the default drive.
;
;===========================================================================

SysPrm	proc	near

	mov	AH,GET_DEFAULT_Drive		; Find out the default Drive
	int	21h				; Default now in AL
	mov	BL,AL
	inc	BL				; A = 1
	add	AL,41h				; Now in Ascii
	mov	SystemDriveLetter,AL		; Text now ok
	call	IsRemovable
	jnc	DoPrompt
ifdef NEC_98
	mov	bx,1		;Search Removable Drive from A:
$$search_removable_loop:
	call	IsRemovable
	jc	$$next_drive
	mov	al,bl
	add	al,40h
	jmp	short $$exit_search_removable
$$next_drive:
	inc	bl
	cmp	bl,27
	jb	$$search_removable_loop

				; Removable Drive is not there!!
				; Jmp FatalExit with display msgNoSystemFiles.
	 Message msgNoSystemFiles
	 jmp	 FatalExit

$$exit_search_removable:
	 mov	 BYTE PTR [SystemDriveLetter],AL
	 mov	 [BiosFile],AL
	 mov	 [CommandFile],AL
IFDEF DBLSPACE_HOOKS
	 mov	 [DblSpaceFile], al
ENDIF
else

		; Media is non-removable. Switch sys disk to Drive A.
		; Check, though, to see if Drive A is removable too.

	 mov	 AL,"A"
	 mov	 [SystemDriveLetter],AL
	 mov	 [BiosFile],AL
	 mov	 [CommandFile],AL
IFDEF DBLSPACE_HOOKS
	 mov	 [DblSpaceFile], al
ENDIF
	 mov	 BX,1
	 call	 IsRemovable
	 jnc	 DoPrompt
	 Message msgNoSystemFiles

	 jmp	 FatalExit
endif

DoPrompt:
	 mov	 AL, SystemDriveLetter
	 sub	 AL, 'A'
	 call	 AccessDisk
	 Message msgInsertDOSDisk
	 Message ContinueMsg

	 call	 USER_STRING			; Wait for a key
	 call	 CrLf
	 call	 CrLf

         ret

SysPrm	endp
;===========================================================================

ControlC_Handler:
	mov	AX, seg data
	mov	DS, AX
	Message msgInterrupt
	mov	ExitStatus, EXIT_CTRLC

				; Restore original Device Settings, as would
				; be done after completion of normal format

	cmp	CMCDDFlag, Yes		; This extra set_DPB would
	je	GotoExitProgram		; make the current card have
					; the size of the first card.

					; Note that this one is less critical
					; than the one in RestoreDevParams
					; (the disk is probably non-functional
					; anyway).

	test	ValidSavedDeviceParameters, 0ffH
	jz	GotoExitProgram
	cmp	IsExtRAWIODrv,0
	je	OldTabOff3

	mov	SavedParams.EDP_TrackTableEntries,0
	jmp	short TabSet3

OldTabOff3:
	mov	SavedParams.DP_TrackTableEntries,0	; There is no track layout info in SavedParams
TabSet3:
	mov	SavedParams.DP_SpecialFunctions,TRACKLAYOUT_IS_GOOD
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS
	lea	DX, SavedParams
	call	SetDeviceParameters

GotoExitProgram:
	jmp	ExitProgram


CrLf:
	mov	DX,offset msgCrLf		; CR,LF	added to message
PrintString:
Std_Printf:
	call	Display_Interface
	return

;----------------------------------------------------------------------------
;
; Procedure Name : DIV32 (borrowed from dos\disk3.asm)
;
; Inputs:
;       DX:AX = 32 bit dividend   BX= divisor
; Function:
;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
; Outputs:
;       CX:AX = quotient , DX= remainder
; Uses:
;       All registers except AX,CX,DX preserved.
;----------------------------------------------------------------------------

Div32	proc	near

	mov	cx,ax		; Save least significant word
	mov	ax,dx
	xor	dx,dx
	div	bx		; 0:AX/BX
	xchg	cx,ax		; Restore least significant word and save
				; most significant word
	div	bx		; DX:AX/BX
	ret

Div32	endp

; ==========================================================================
;
;    Phase2Initialization:
;	 Use device parameters to build	information that will be
;	 required for each format
;
;    Algorithm:
;	 Calculate first head/cylinder to format
;	 Calculate number of tracks to format
;	 Calculate the total bytes on the disk and save	for later printout
;	 First initialise the directory	buffer
;
; ==========================================================================

Phase2Initialization proc near
					; Calculate first track/head to format
					; (round up - kludge)
	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_HiddenSectors
	mov	DX, DeviceParameters.DP_BPB.oldBPB.BPB_HiddenSectors + 2
	add	AX, DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack
    .errnz EDP_BPB NE DP_BPB
	adc	DX, 0
	dec	AX
	sbb	DX, 0

	mov	BX,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack
	call	Div32
	mov	DX,CX			; Forget remainder. DX:AX= tracks*heads
					; before M018 we were assuming tracks*head
					; fitted in a word.

	div	DeviceParameters.DP_BPB.oldBPB.BPB_Heads
ifdef NEC_98
	xor	AX,AX
	xor	DX,DX
endif

	mov	FirstCylinder,	AX
	mov	FirstHead, DX
					; Calculate the total number of tracks
					; to be formatted (round down - kludge)
	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
	xor	DX,DX
					; if (TotalSectors == 0) then use
					; BigTotalSectors
	or	AX,AX
	jnz	NotBigTotalSectors
	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors
	mov	DX, DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors + 2

NotBigTotalSectors:
	mov	BX,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack
	call	div32
	mov	word ptr TracksPerDisk, AX
	mov	word ptr TracksPerDisk+2, CX

	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	xor	DX, DX
	mov	BX, size dir_entry
	div	BX
	mov	CX, AX

	les	BX, DirectorySector
					; If Old_Dir =	TRUE then put the first
					; letter of each must be 0E5H
	xor	AL, AL
	cmp	old_Dir, TRUE
	jne	StickE5
	mov	AL, 0e5H

StickE5:
	mov	ES:[BX], AL
	add	BX, size dir_entry
	loop	stickE5

	ret

Phase2Initialization endp

;========================================================================
;
; ShowFormatSize :	This procedure calculates the size of the disk
;			being formatted, and displays an appropriate
;			message.
;
; Strategy :	The total number of bytes on the volume are first calculated.
;		This is converted to K by dividing by 1024.  If the number
;		is less than 1000, the size in K is printed.  Otherwise
;		the number is converted to Megs, as follows.  If size in K
;		is less than 10,000
;			Megs = Kbytes / 1000
;		else
;			Megs = Kbytes / 1024
;		Nonzero decimals will be printed for megs.
;
; Calls :	Multiply_32_Bits
;
; Registers Destroyed :	AX,BX,CX,DX
;
;
;========================================================================

ShowFormatSize	proc	near

	mov	CX,DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	xor	DX,DX
	mov	AX,DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
    .errnz EDP_BPB NE DP_BPB
	or	AX,AX				; If zero, use BigTotalSectors
	jnz	UseSmall

UseBigSectors:
	mov	AX,DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors
	mov	BX,DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors[2]
	call	Multiply_32_Bits
	jnc	NoOverflow
    ;
    ; Really big disk
    ;
.386
	movzx	ecx,cx
	mov	ax,DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors[2]
	shl	eax,16
	mov	ax,DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors
	mul	ecx
	mov	ebx,1024 * 1024
	div	ebx
	shr	edx,10				; Convert remainder to remainder
						;  of second divide by 1024
.8086
	jmp	short GotMegs

NoOverflow:
	mov	DX,BX				; Now DX:AX has total bytes
	jmp	SHORT DoDivide

UseSmall:
	mul	CX				; Now DX:AX has total bytes

DoDivide:
	mov	CX,10				; Set up shift count
Div1024:
	shr	DX,1   				; Rotate DX:AX
	rcr	AX,1
	loop	Div1024					

	cmp	AX,999				; Check if DX:AX >= 1000
	ja	GetMegs
	or	DX,DX				; DX nonzero --> Very big number!
	jnz	GetMegs

	mov	SizeInK,AX
	mov	dx,offset data:msgQuickFormatShowKBytes
	test	SwitchMap,SWITCH_Q
	jnz	GotoDisplaySize
	mov	dx,offset data:msgShowKBytes
	test	SwitchMap,SWITCH_U
	jnz	GotoDisplaySize
	mov	dx,offset data:msgVerifyShowKBytes

GotoDisplaySize:
	jmp	DisplaySize	

GetMegs:
	cmp	AX,10000			; Check if DX:AX > 10000
	ja	UseRealMegs
	or	DX,DX
	jnz	UseRealMegs

UseFloppyMegs:
	mov	BX,1000				; DX:AX <= 10000
	div	BX				; Get size in Megs
ifdef NEC_98				; for 1.25MB
	cmp	AX,1				; 1024*8*77*2 = 1261568
	jne	@F				; 1261568 / 1024 = 1232
	cmp	DX,232				; 1232 % 1000 = 232
	jne	@F
	mov	DX,250			; convert 1.232MB -> 1.25MB
@@:
endif
	jmp	SHORT DoneDivision

UseRealMegs:
	mov	BX,1024				; DX:AX > 10000
	div	BX				; Get size in Megs
GotMegs:
	push	AX				; bring reminder
	mov	AX,DX				; to 1/1000 instead
	xor	DX,DX				; of 1/1024
	mov	BX,250				; multiply by 250
	mul	BX
	mov	DH,DL				; divide by 256
	mov	DL,AH
	pop	AX
	
DoneDivision:
	mov	SizeInM,AX
	cmp	DX,10				; Check for nonzero decimals
	jnb	ShowDecimals
	mov	dx,offset data:msgQuickFormatShowMBytes
	test	SwitchMap,SWITCH_Q
	jnz	DisplaySize
	mov	dx,offset data:msgShowMBytes
	test	SwitchMap,SWITCH_U
	jnz	DisplaySize
	mov	dx,offset data:msgVerifyShowMBytes
	jmp	short DisplaySize	

ShowDecimals:
	mov	AX,DX				; set up for division of
	xor	DX,DX				;  remainder by 10
	mov	BX,10
	div	BX
	mov	CX,AX
	xor	DX,DX
	div	BX
	or 	DX,DX				; Do not display 2d.p.s if 2nd d.p. is zero
	jnz	TwoDecPlaces			; Must display 2 d.p.

OneDecPlace:
	mov	DecSizeInM,AX			; Display only 1 d.p.
	mov	msgDecimalNumberofDecimal,1
	jmp	SHORT ShowDecMessage

TwoDecPlaces:
	mov	DecSizeInM,CX			; Display original 2 d.p.s
	mov	msgDecimalNumberofDecimal,2

ShowDecMessage:
	mov	dx,offset data:msgQuickFormatDecimalMBytes
	test	SwitchMap,SWITCH_Q
	jnz	DisplaySize
	mov	dx,offset data:msgDecimalMBytes
	test	SwitchMap,SWITCH_U
	jnz	DisplaySize
	mov	DX,offset data:msgVerifyDecimalMBytes

DisplaySize:
	call	Display_Interface
	ret

ShowFormatSize	endp

;=========================================================================
; SEG_ADJ	 :	 This routine adjusts the segment:offset to prevent
;			 address wrap.
;
;	 Inputs	 :	 SI - Offset to	adjust segment with
;			 DS - Segment to be adjusted
;
;	 Outputs :	 SI - New offset
;			 DS - Adjusted segment
;=========================================================================

procedure seg_adj

	push	AX
	push	BX
	push	DX

	mov	AX,SI				; get offset
	mov	BX,0010h			; 16
	xor	DX,DX				; clear DX
	div	BX				; get para count
	jnc	$$IF73				; overflow?
	adc	BX,0				; pick it up

$$IF73:
	mov	BX,DS				; get seg
	add	BX,AX				; adjust for paras
	mov	DS,BX				; save new seg
	mov	SI,DX				; new offset

	pop	DX
	pop	BX
	pop	AX
	ret

seg_adj  ENDP

; =========================================================================
;	 format	is done... so clean up the disk!
; =========================================================================

Done PROC NEAR

	call	OemDone
	return

Done	 ENDP


; =========================================================================
;	PrintErrorAbort:
;	 Print an error	message	and abort
;
;    Input:
;	 DX - Pointer to error message string
; =========================================================================

PrintErrorAbort PROC NEAR

	push	DX
	call	CrLf
	pop	DX
	call	PrintString
	jmp	FatalExit

PrintErrorAbort ENDP

;=========================================================================
; Ctrl_Break_Write	 : This	routine	takes the control break	request
;			   an returns.	In essence, it disables	the CTRL-BREAK.
;			   This	routine	is used	during the writing of the
;			   Fat,	DIR, and SYSTEM.
;
;=========================================================================

Ctrl_Break_Write:

	iret					; return to caller


;=========================================================================
; Ctrl_Break_Save	 : This	routine	gets the current vector	of
;			   int 23h and saves it	in CTRL_BREAK_VECTOR.
;	 Inputs	 : none
;
;	 Outputs : CTRL_BREAK_VECTOR - holds address of	int 23h	routine
;=========================================================================

Ctrl_Break_Save PROC NEAR

	push	ES
	push	BX
	push	AX

	mov	AX,3523h			; Get CTRL-BREAK
						; Interrupt vector
	int	21h

	mov	WORD PTR Ctrl_Break_Vector,BX	; Get vector offset
	mov	WORD PTR Ctrl_Break_Vector+2,ES ; Get vector segment

	pop	AX
	pop	BX
	pop	ES

	ret

Ctrl_Break_Save ENDP

;=========================================================================
; Set_Ctrl_Break	 : This	routine	sets the CTRL-Break vector to one
;			   defined by the user.
;
;	 Inputs	 : none
;
;	 Outputs : CTRL_BREAK_VECTOR - holds address of	int 23h	routine
;=========================================================================

Set_Ctrl_Break PROC NEAR

	push	DS				; Save ds
	push	AX				; Save AX
	push	BX				; Save BX
	push	DX				; Save DX

	push	CS				; Swap cs with DS
	pop	DS				; Point to code seg

	mov	DX,offset Ctrl_Break_Write	; Get interrupt vec.
	mov	AX,2523h			; Set CTRL-BREAK
						; Interrupt vector
	int	21h

	pop	DX				; Restore DX
	pop	BX				; Restore BX
	pop	AX				; Restore AX
	pop	DS				; Restore DS

	ret

Set_Ctrl_Break ENDP

;=========================================================================
; Reset_Ctrl_Break	 : This	routine	resets the CTRL-Break vector to	that
;			   originally defined.
;
;	 Inputs	 : CTRL_BREAK_VECTOR - holds address of	int 23h	routine
;
;	 Outputs : none
;=========================================================================

Reset_Ctrl_Break PROC NEAR

	push	DS
	push	AX
	push	BX
	push	DX

	mov	AX,WORD PTR Ctrl_Break_Vector+2 ; Get seg. of vector
	mov	BX,WORD PTR Ctrl_Break_Vector	; Get off. of vector
	mov	DS,AX				; Get seg.
	mov	DX,BX				; Get off.
	mov	AX,2523h			; Set CTRL-BREAK
						; Interrupt vector
	int	21h

	pop	DX
	pop	BX
	pop	AX
	pop	DS

	ret

Reset_Ctrl_Break ENDP


; =========================================================================
; Get_PSP_Parms
; =========================================================================

Procedure Get_PSP_Parms

	Set_Data_Segment
	mov	AX,PSP_Segment			; Get segment of PSP
	mov	DS,AX

	assume	DS:notHING			; Setup segment of Environment
	mov	AX,DS:PSP_Environ		; string, get from PSP
	mov	ES:Environ_Segment,AX
	Set_Data_Segment
	ret

Get_PSP_Parms ENDP

;=========================================================================
; Cap_Char	 : This	routine	will capitalize	the character passed in
;		   DL.
;
;	 Inputs	 : DL -	Character to be	capitalized
;
;	 Outputs : DL -	Capitalized character
;=========================================================================

Procedure Cap_Char

	push	AX				; Save AX
	mov	AX,6520h			; Capitalize character
	int	21h
	pop	AX				; Restore AX
	ret

Cap_Char ENDP

;=========================================================================
;
; Set_CDS_Off			 - This	routine	disallows access to a
;				   disk	if a format fails on a non-Fat
;				   formatted disk.
;
;=========================================================================

Procedure Set_CDS_Off

	push	AX				; Save regs
	push	DX

	mov	AX,5f08h			; Reset CDS
	mov	DL,DriveToFormat		; Drive to reset
	int	21h

	pop	DX				; Restore regs
	pop	AX

	ret

Set_CDS_Off ENDP


;=========================================================================
;
; Format_Access_Wrap_Up	 -	This routine determines whether or
;				not access should be allowed to the
;				disk based on the exit Status of
;				format.
;
;=========================================================================

Procedure Format_Access_Wrap_Up

	cmp	Disk_Access.DAC_Access_Flag,0ffh ; Access prev. allowed?
	je	$$IF140 			; No

	cmp	ExitStatus,EXIT_OK		; Good exit?
	je	$$IF141 			; No
	cmp	ExitStatus,EXIT_NO		; User said no?
	je	$$IF141 			; No

	lea	DX,Disk_Access			; Point to parm block
	mov	Disk_Access.DAC_Access_Flag,00h ; Signal no disk access
	call	Set_Disk_Access_On_Off		; Don't allow disk access
	jmp	SHORT $$EN141			; Bad exit

$$IF141:
	lea	DX,Disk_Access			; Point to parm block
	mov	Disk_Access.DAC_Access_Flag,01h ; Signal disk access
	call	Set_Disk_Access_On_Off		; Allow disk access

$$EN141:
$$IF140:
	cmp	Fat_Flag,No			; Non-Fat format?
	jne	$$IF145 			; Yes

	cmp	ExitStatus,EXIT_OK		; Good exit?
	je	$$IF146 			; No

	call	Set_CDS_Off			; Disallow Fat access

$$IF146:
$$IF145:
	ret

Format_Access_Wrap_Up ENDP

;=========================================================================
;
;  WriteDiskInfo :	This procedure writes out all the control info to
;			the disk, after it has been formatted/verified/
;			quick formatted.  This includes the Boot Sector,
;			Root Directory and FAT.  If /s is present System
;			files will also be written out, if there is enough
;			disk space.
;
;  STRATEGY :		If a safe format is being done (/U not present), it
;			is not necessary to have a directory entry for the
;			recovery file.  A special case arises when a safe
;			format is being done, and /S is present (system
;			required).  In this case it is necessary to write out
;			the system files with the old FAT intact, so as to
;			prevent over-writing any old files.  The FAT chains
;			must then be copied to the new FAT, which is then
;			written out to disk.
;
;  DESTROYS :		AX,BX,CX,DX,SI,DI
;
;=========================================================================

WriteDiskInfo	proc	NEAR

	Set_Data_Segment			;DS,ES = DATA
	assume	DS:DATA,ES:DATA

	test	SwitchMap,SWITCH_S		;if system requested, calculate size
	jz	Cleared

	test	SwitchMap,SWITCH_U		;check for not(/U) & /S combination
	jnz	@F				;normal case

@@:	cmp	BYTE PTR DblFlg,0		;is sys space already calculated?
	jnz	Cleared				;yes

	inc	BYTE PTR DblFlg			;no --	set the	flag
	call	GetSize				;calculate the	system size

Cleared:
	call	Ctrl_Break_Save			;disallow Ctrl_C here
	call	Set_Ctrl_Break

	test	ES:fBig32FAT,0ffh		; See if 32 bit fat
	jz	BootSectorSet			; Not
.386
	mov	DeviceParameters.DP_BPB.BGBPB_ExtFlags,0
	mov	eax,2
ChkNxt:
	call	IsThisClusterBad
	jne	short SetRootClus
	inc	eax
	cmp	eax,TotalClusters
	jna	ChkNxt
	jmp	short Bad_Root

SetRootClus:
	mov	dword ptr DeviceParameters.DP_BPB.BGBPB_RootDirStrtClus,eax
    .errnz EDP_BPB NE DP_BPB
.8086
	call	WrtEOFMrkInRootClus
BootSectorSet:
	call	WriteBootSector			;write out Boot Sector
	jnc	BootSectorOk			;check for error

	call	Reset_Ctrl_Break		;error occurred
	jmp	Problems

BootSectorOk:
	push	DS				;preserve DS
	lds	BX,DirectorySector		;set up for call
	call	ClearDirSector			;fill root dir sector with zeroes
	pop	DS				;restore Ds

	call	WriteRootDir			;write out Root Directory
	jnc	RootDirOk			;check for error
Bad_Root:
	call	Reset_Ctrl_Break		;error occurred
	Message	msgDirectoryWriteError
	jmp	Problems

RootDirOk:
DestroyOldFat:
	call	WriteFat			;write out FAT
	jnc	FatOk				;check for error

	call	Reset_Ctrl_Break		;error occurred
	Message	msgFatWriteError
	jmp	Problems

FatOk:
	cmp	IsExtRAWIODrv,0
	je	OldTabOff4

	mov	SavedParams.EDP_TrackTableEntries,0
	jmp	short TabSet4

OldTabOff4:
	mov	SavedParams.DP_TrackTableEntries,0   ;restore good tracklayout for drive
TabSet4:
	mov	SavedParams.DP_SpecialFunctions,TRACKLAYOUT_IS_GOOD
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS
	lea	DX,SavedParams
	call	SetDeviceParameters

	;now perform an undocumented GET_DPB call to
	;force allocation to be reset from the start
	;of the disk, and force free disk space to be
	;calculated

.386
	xor	eax,eax
	mov	SetDPBPacket.SetDPB_Value3,eax
	mov	SetDPBPacket.SetDPB_Value4,eax
	dec	eax
	mov	SetDPBPacket.SetDPB_Value1,eax
	mov	SetDPBPacket.SetDPB_Value2,eax
	mov	SetDPBPacket.SetDPB_Function,SetDPB_SetAllocInfo
	movzx	dx,DriveToFormat
.8086
	inc	dx				; 1 based drive number
	mov	ax,(Get_Set_DriveInfo SHL 8) OR Set_DPBForFormat
	mov	cx,size SDPDFormatStruc
	lea	di,SetDPBPacket
	push	ds
	pop	es
	int	21h
    ;
    ; NOTE: This call fails in protected mode under Win95 with the FORMAT
    ;	    lock taken (VDEF mounted). This call REALLY isn't necessary anyway.
    ;	    The SetDeviceParameters we do as part of the format is supposed to
    ;	    trigger the device driver to return "media changed" on the next
    ;	    media check call which has the side effect of resetting this anyway.
    ;
	;; jc	   DPBErr

	test	fBig32FAT,0ffh
	jz	short NotFAT32
	Message msgReCalcFree
	call	Get_Free_Space
	Message msgCalcFreeDone
NotFAT32:

	test	SwitchMap,SWITCH_S		;is system desired?
	jz	ResetCtrlBreak			;no, go finish up

	mov	DL,DriveToFormat		;system is required, set up for call
	inc	DL				;DL = drive code (1 = A)
	call	ChkSpace			;check if there's enough space
	jnc	SpaceOK				;  Y: Go load system files

NoRoom:
DiskTooSmall:					;disk is physically too small
	Message msgNoRoomDestDisk		;  N: Print error message

	mov	WORD PTR SysSiz+2,0		;no system transferred
	mov	WORD PTR SysSiz,0		;reset system sizes to zero

	xor	AX,AX
        mov     word ptr [Dos.FileSizeInBytes+0],AX     ;set dos size
        mov     word ptr [Dos.FileSizeInBytes+2],AX
        mov     word ptr [Bios.FileSizeInBytes+0],AX    ;set bios size
	mov	word ptr [Bios.FileSizeInBytes+2],AX
        mov     word ptr [Command.FileSizeInBytes+0],AX ;set command size
	mov	word ptr [Command.FileSizeInBytes+2],AX

IFDEF DBLSPACE_HOOKS
	mov	word ptr [DblSpaceBin.FileSizeInBytes+0], ax	; clr dblspace
	mov	word ptr [DblSpaceBin.FileSizeInBytes+2], ax	;   size
ENDIF
	jmp	short ResetCtrlBreak

SpaceOK:
	mov	AL,DriveToFormat
	call	AccessDisk			;note what is current logical drive

	push	DS				; preserve DS & ES!
	push	ES

	call	WriteDos			;write	the BIOS & DOS

	pop	ES				; restore DS & ES!
	pop	DS

	jnc	SysOk				;check for error

	Message msgNotSystemDisk		;no system transferred
	mov	WORD PTR SysSiz+2,0		;reset system size to zero
	mov	WORD PTR SysSiz,0

SysOk:						;don't display if EXEC'd by Select
	test	SwitchMap,(SWITCH_SELECT or SWITCH_AUTOTEST)
	jnz	@F				;skip message

	Message msgSystemTransfered

@@:
ResetCtrlBreak:
	call	Reset_Ctrl_Break		;restore CTRL-Break
	call	CrLf

	mov	AH,DISK_RESET			;do a disk reset
	int	21h

	call	DONE				;final call to OEM module
	jnc	ReportC				;check for error

	jmp	SHORT Problems			;report an error

ReportC:					;temp fix for /AUTOtest
	test	SwitchMap,(SWITCH_AUTOTEST or SWITCH_8)
	jnz	@F				;volume label not supported with /8
	call	VolId				;handle volume label

@@: 						;need to shut down the report?
	test	SwitchMap,(SWITCH_SELECT or SWITCH_AUTOTEST)
	jnz	Successful_End		 	;no report if exec'd by Select

	call	Report				;print report
	jmp	SHORT Successful_End

Problems:
	test	SwitchMap,SWITCH_SELECT		;SELECT option?
	jnz	End_WriteDiskInfo		;no message if EXEC'd

	Message msgFormatFailure
	mov	ExitStatus,EXIT_FATAL
	stc
	jmp	SHORT End_WriteDiskInfo

Successful_End:
	clc

End_WriteDiskInfo:
	ret

WriteDiskInfo	ENDP

;========================================================================
;
;  WriteRootDir :	This procedure writes out a zeroed root directory
;			to disk.
;
;  RETURNS  :	NC --> success
;		CY --> failure
;
;  DESTROYS :	AX,BX,CX,DX
;
;========================================================================

WriteRootDir	proc	NEAR

	assume	DS:DATA,ES:DATA
					;find sector offset of root dir on disk

.386
	movzx	EBX,DeviceParameters.DP_BPB.oldBPB.BPB_NumberOfFats
	movzx	EAX,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
    .errnz EDP_BPB NE DP_BPB
	or	ax,ax
	jnz	short GotFS
	mov	EAX,dword ptr DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
GotFS:
	mul	EBX				;EAX = total FAT Sectors

	movzx	EDX,DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors
	add	EDX,EAX 			;EDX = root dir start sector
						;      (or first data sector
						;	if FAT32)

	test	ES:fBig32FAT,0ffh	; See if 32 bit fat
	jz	short OldStyleRoot	; Not

	mov	eax,dword ptr DeviceParameters.DP_BPB.BGBPB_RootDirStrtClus
	sub	eax,2			; Convert to zero based cluster #
	jb	short @F		; Carry set if jump
	mov	ecx,edx
	MOVZX	EBX,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
	mul	ebx
	mov	edx,ecx
	add	edx,eax
	mov	cx,bx
	jmp	short WriteASector

OldStyleRoot:
	mov	CX,SectorsInRootDirectory	;CX = sectors to write, loop control

WriteASector:
	mov	eax,edx
	shr	eax,16
	mov	Read_Write_Relative.Start_Sector_High,ax
	mov	AL,DriveToFormat

;; Manual assemble to prevent compile warning
;;	  push	  edx
	db	066h,052h
;;
	push	CX				;preserve loop count CX
	mov	CX,1				;CX = sectors to write

	push	DS				;preserve DS
	lds	BX,DirectorySector		;DS:BX --> zeroed sector
	assume	DS:NOTHING,ES:DATA

	call	Write_Disk			;write all the sectors
	pop	DS				;restore DS
	assume	DS:DATA,ES:DATA

	pop	CX				;restore CX
;; Manual assemble to prevent compile warning
;;	  pop	  edx
	db	066h,05Ah
;;
	jc	short @F			;if error occurred, break loop

	inc	EDX				;write to next sector
.8086
	loop	WriteASector			;write all sectors of root dir

@@:	ret

WriteRootDir	endp

;==========================================================================
;
;  WriteFat :		This procedure copies the contents of the FatSpace
;			buffer to each of the FAT areas on disk.
;
;  RETURNS  :	NC --> success
;		CY --> failure
;
;  CALLS    :   Write_Fat
;
;  DESTROYS :	AX,BX,CX,DX,SI
;
;==========================================================================

WriteFat	proc	NEAR

	assume	DS:DATA,ES:DATA

	call	FlushFATBuf
	ret

WriteFat	endp

;=========================================================================
;
;  ComputeN :	This procedure calculates the number of clusters needed
;		to hold 1.5Kbytes.  This value is stored in the variable
;		NumClusters.
;
;  ARGUMENTS:	DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
;		DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
;
;  DESTROYS :
;
;=========================================================================

ComputeN	proc	NEAR

	assume	DS:NOTHING,ES:DATA

	mov	AX,ES:DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector        ; Sector size
	xor	CX,CX
	mov	CL,ES:DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
    .errnz EDP_BPB NE DP_BPB
	mul	CX				; AX = bytes per cluster
	mov	CX,AX				; CX = bytes per cluster
	mov	AX,1536				; Find how many clusters needed
						; for 1.5K
	xor	DX,DX
	div	CX				; now AX= No. clusters needed
	or	DX,DX				; round up if remainder nonzero
	jz	RoundedUp
	inc	AX
RoundedUp:
.386
	movzx	eax,ax
	mov	ES:NumClusters,EAX
.8086
	ret

ComputeN	endp

;===========================================================================
; Routine name: ClearDirSector
;===========================================================================
;
; Description: Fill a sector size area of memory with zeros
;
; Arguments:		DS:BX --> Sector to clear
;			ES    = DATA
; ---------------------------
; Returns:   		Void
; ---------------------------
; Registers destroyed:	NONE
; ----------------------------------
; Strategy
; --------
;	Save all registers used and set ES:DI to DS:BX
;	Then do a store string, cleanup and leave
;
;===========================================================================

ClearDirSector PROC NEAR

	push	AX			; Can't destroy anything
	push	CX
	push	DI
	push	ES
	
	mov	CX,ES:deviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector ;Num of bytes
    .errnz EDP_BPB NE DP_BPB
	shr	CX,1			; Convert bytes to words

	mov	AX,DS			; Set ES:DI == DS:BX
	mov	ES,AX
	mov	DI,BX

	xor	AX,AX
	cld				; Clear the direction flag
	rep	stosw			; Fill the buffer with 0s

	pop	ES			; Leave with everything intact
	pop	DI
	pop	CX
	pop	AX
	ret

ClearDirSector ENDP


	public	GetExclusiveAccess, ReleaseExclusiveAccess
	public	GetExclusiveAccessForFormat, ReleaseExclusiveAccessForFormat
	public	IsLockErr?

;
;===============================================================================
;
; Routines to get & release exclusive access for the drive which we are
;  formatting. DriveToFormat contains the zero based drive number which are
;  in the process of formatting.
; GEAState & GEAFFState remember the current exclusive acces states
;
;===============================================================================
;

; NOTE that either RAWIO or EXTRAWIO form is OK for FAT32 drives on the
;   LOCK/UNLOCK IOCTLs

LOCK_FUNC	=	((RAWIO shl 8) + LOGICAL_LOCK)
UNLOCK_FUNC	=	((RAWIO shl 8) + LOGICAL_UNLOCK)

GetExclusiveAccess PROC near
	assume	es:nothing, ds:DATA

	push	ds			; save DS
	mov	ax, DATA		; set DS to DATA
	mov	ds, ax
	mov	al, 1
	xchg	GEAState, al
	or	al, al			; do we have access already ?
	jnz	GEADone			; yes, nothing more to do
	xor	ax, ax			; AccessForFormat -- NOT!!
GEAFFEntry:
	mov	cx, LOCK_FUNC		; get exclusive access
REAEntry:
	mov	dx, ax
	mov	bl, DriveToFormat
	inc	bl			; 1 based drive number
	xor	bh, bh			; access level 0
	mov	ax, 440dh
	int	21h
GEADone:
	jnc	GEAReallyDone		; get out if we succeeded
	call	IsLockErr?
GEAReallyDone:
	pop	ds
	ret

GetExclusiveAccess ENDP

ReleaseExclusiveAccess PROC near

	push	ds
	mov	ax, DATA
	mov	ds, ax
	xor	al, al
	xchg	GEAState, al
	or	al, al			; do we have exclusive access ?
	jz	GEADone			; no, get out of here
	xor	dx, dx
	mov	cx, UNLOCK_FUNC		; release exclusive access
	jmp	short REAEntry

ReleaseExclusiveAccess ENDP

GetExclusiveAccessForFormat PROC near

	push	ds
	mov	ax, DATA
	mov	ds, ax
	cmp	UnderWin?, 0
	je	GEADone
	mov	al, 1
	xchg	GEAFFState, al
	or	al, al			; do we have access to format ?
	jnz	GEADone			; yeah, get out of here
	mov	ax, LOCK_FLAGS_FOR_FORMAT ; access for format
	jmp	short GEAFFEntry

GetExclusiveAccessForFormat ENDP

ReleaseExclusiveAccessForFormat PROC near

	push	ds
	mov	ax, DATA
	mov	ds, ax
	xor	al, al
	xchg	GEAFFState, al
	or	al, al
	jz	GEADone
	xor	ax, ax
	mov	cx, UNLOCK_FUNC
	jmp	short REAEntry

ReleaseExclusiveAccessForFormat ENDP

;
; Check whether the current error is a lock violation
;
; exit : CY if lock violation

.errnz	(error_volume_lock_failed - error_invalid_volume_lock - 1)
.errnz	(error_invalid_volume_lock - error_volume_locked - 1)

num_lock_errors	=	(error_volume_lock_failed - error_volume_locked + 1)

IsLockErr? PROC near

	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	bp
	push	ds
	push	es
	mov	ah, 59h
	int	21h
	sub	ax, error_volume_locked	; check if it is exclusive access err
	cmp	ax, num_lock_errors	; carry clear if ax was not lock error
	pop	es
	pop	ds
	pop	bp
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	ret

IsLockErr? ENDP

ifdef OPKBLD

;============================================================================
; 
; sivaraja 4/17/2000
; Added NTFSFriendlyFAT to align system sectors to 4k boundary
;
; ===========================================================================

NTFSFriendlyFAT PROC near
; Check for media ID, we only align (tune) system sectors to ?K boundary on Fixed Disks
    cmp	DeviceParameters.DP_BPB.oldBPB.BPB_MediaDescriptor, Fixed_Disk
    je  ProceedWithNTFSFriendly
    jmp	AlreadyFriendly ; Dont bother

ProceedWithNTFSFriendly:
;    mov	WORD PTR TotalSystemSectors+0, 0
;    mov	WORD PTR TotalSystemSectors+2, 0

    xor dx, dx
    mov ax, DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors
    cmp DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFAT, 0
    jz	ItIsFAT32
    Add	ax, DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFAT
    Add ax, DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFAT
    jmp short ContinueWithCalc
ItIsFAT32:
    Add	ax, DeviceParameters.DP_BPB.oldBPB.BGBPB_BigSectorsPerFAT
    Add	ax, DeviceParameters.DP_BPB.oldBPB.BGBPB_BigSectorsPerFAT
ContinueWithCalc:
    push ax
    push dx
    xor bx,bx
    mov ax, DeviceParameters.DP_BPB.oldBPB.BPB_RootEntries
    mov	cx, 32 ; 32 bytes per dir entry
    mul	cx
    or  ax,ax
    jz	SkipRootDir ; skip root dir if it is fat32
    mov	bx, DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
    div	bx
    mov	bx, ax
SkipRootDir:
    pop	dx ;dx:ax = reservedsec + sectorsperfat
    pop	ax
    add	ax, bx ; bx = number of sectors for root dir, 0 if FAT32

;    mov	WORD PTR TotalSystemSectors+0, ax ; store it here if required
;    mov	WORD PTR TotalSystemSectors+2, dx ; store it here if required

; dx:ax = total system sectors. Here we sense the last N bits
; (N depends on the value of AlignCount), for example if AlignCount is
; 8, we should check 3 bits signifying value 7, because 7 is the highest
; value we can expect from a Mod operation with 8. And 15 is the highest
; value we can expect for operand 16... and so on.
; depending on the position of each bit we add (2 ** bitposition) to bx
; which will give us the (mod) value of TotalSystemSectors % N
; Based on the Mod value we will round TotalSystemSectors to align in N sector
; boundary. BTW, since the max value of AlignCount is 128, we will not be sensing
; any bit in DX


    Mov cx, AlignCount
    shr cx, 1
    jnz ProceedWithSlack ; Just be safe
    Jmp AlreadyFriendly
ProceedWithSlack:
    xor bx, bx ; init bx
    push dx ; save dx just for the heck of it although we dont need it
    mov dx, 1

GetSlack:
    shr ax, 1
    jnc DivideCX
    add bx, dx
DivideCX:
    shl dx, 1 ; dx = 2**BitPosition, keep it ready for next iteration
    shr cx, 1
    or  cx, cx
    jz  GotSlackCount
    jmp GetSlack

GotSlackCount: ; bx = mod value
    pop dx ; restore dx

    or bx, bx ; is it already aligned
    jnz RoundToNextHighBoundary
    jmp	short AlreadyFriendly
RoundToNextHighBoundary:
; now calculate the number of sectors required required to be added
; so that TotalSystemSectors align in 4K boundary	
    mov ax, AlignCount
    sub	ax, bx
    mov	bx, ax

;   mov        WORD PTR SlackSectors, bx ; store it here if required

; now bx = holds number of sectors to be added to align TotalSystemSectors
; distribute this to ReservedSectors and FAT
; if Odd increment Reserved Sectors and 
; divide the remaining count by 2 (number of FATs) and add that value
; to SectorsPerFAT count

    mov	ax, bx
    shr	ax, 1
    jnc	NoReserveInc ; odd number? LSB must be set
    inc DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors
NoReserveInc:
    mov	ax, bx
    shr	ax, 1 ; divide by 2
    cmp	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFAT, 0
    jz	IncBigFATSecCount
    add	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFAT, ax
    jmp	short AlreadyFriendly
IncBigFATSecCount:
    add	DeviceParameters.DP_BPB.oldBPB.BGBPB_BigSectorsPerFAT, ax
AlreadyFriendly:
    ret
    
NTFSFriendlyFAT ENDP

endif ;OPKBLD

CODE	 ENDS
	 END	 Start

; ==========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\forproc.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)forproc.asm	1.2 85/07/25

.xlist
.xcref
BREAK	MACRO	subtitle
	SUBTTL	subtitle
	PAGE
ENDM

	include bpb.inc
	INCLUDE FORCHNG.INC
	INCLUDE SYSCALL.INC
	INCLUDE FOREQU.INC
	INCLUDE FORMACRO.INC
	INCLUDE FORSWTCH.INC
	INCLUDE IOCTL.INC
.cref
.list
data	segment public para 'DATA'
data	ends

code	segment public para 'CODE'
	assume	cs:code,ds:data

	PUBLIC	FormatAnother?,Yes?,REPORT,USER_STRING
	public	fdsksiz,fdsksizM100s,badsiz,badsizM100s
	public	syssiz,datasiz,datasizM100s,biosiz
	public	AllocSize,AllocNum,MegSizes
	public	Get_Free_Space

	extrn	std_printf:near,crlf:near,PrintString:near
	extrn	Multiply_32_Bits:near
	extrn	AddToSystemSize:near

;No more SAFE module
;	EXTRN	UpdateSystemSize:NEAR

data	segment public	para	'DATA'
	extrn	driveLetter:byte
	extrn	msgInsertDisk:byte
	extrn	msgFormatAnother?:byte
	extrn	msgQuickFormatAnother?:byte
	extrn	msgTotalDiskSpace:byte
	extrn	msgTotalDiskSpaceMeg:byte
	extrn	msgSystemSpace:byte
	extrn	msgBadSpace:byte
	extrn	msgBadSpaceMeg:byte
	extrn	msgDataSpace:byte
	extrn	msgDataSpaceMeg:byte
	extrn	Read_Write_Relative:byte
	extrn	msgAllocSize:byte
	extrn	MsgAllocNum:Byte
	extrn	deviceParameters:byte
	EXTRN	fBig32Fat:BYTE
	extrn	bios:byte
        extrn   dos:byte
	extrn	command:byte
IFDEF DBLSPACE_HOOKS
	extrn	DblSpaceBin:byte
ENDIF
	extrn	Serial_Num_Low:Word
	extrn	Serial_Num_High:Word
	extrn	msgSerialNumber:Byte
	extrn	SwitchMap:Word
	extrn	SwitchCopy:Word
	extrn	inbuff:byte

MegSizes	db	0

fdsksiz 	dd	0
fdsksizM100s	dw	0

syssiz		dd	0
biosiz		dd	0

badsiz		dd	0
badsizM100s	dw	0

datasiz 	dd	0
datasizM100s	dw	0

AllocSize	dd	0
AllocNum	dd	0
		dw	offset driveLetter

ExtFreePacket	ExtGetDskFreSpcStruc <>

data	ends

;***************************************************************************
; Wait for key. If yes return carry clear, else no. Insures
;   explicit Y or N answer.
;***************************************************************************

FormatAnother? proc near

	test	SwitchCopy,SWITCH_Q		;use different message with /Q
	jz	@F
	Message msgQuickFormatAnother?
	jmp	SHORT CheckResponse

@@:
	Message msgFormatAnother?

CheckResponse:
	CALL	Yes?
        pushf                                   ; save result
        call    CrLf                            ; send a new line
        popf                                    ; retrieve the result
	jnc	WAIT20
        jz      Wait20
	JMP	SHORT FormatAnother?
WAIT20:
	RET

FormatAnother? endp

;***************************************************************************
;Routine name:Yes?
;***************************************************************************
;
;Description: Validate that input is valid Y/N for the country dependent info
;	      Wait for key. If YES return carry clear,else carry set.
;	      If carry is set, Z is set if explicit NO, else key was not Yes or No.
;
;Called Procedures: Message (macro)
;		    User_String
;
;Change History: Created	4/32/87 	MT
;
;Input: None
;
;Output: CY = 0 Yes is entered
;	 CY = 1, Z = No
;	 CY = 1, NZ = other
;
;Psuedocode
;----------
;
;	Get input (CALL USER STRING)
;	IF got character
;	   Check for country dependent Y/N (INT 21h, AX=6523h Get Ext Country)
;	   IF Yes
;	      clc
;	   ELSE (No)
;	      IF No
;		 stc
;		 Set Zero flag
;	      ELSE (Other)
;		 stc
;		 Set NZ
;	      ENDIF
;	   ENDIF
;	ELSE  (nothing entered)
;	   stc
;	   Set NZ flag
;	ENDIF
;	ret
;***************************************************************************

Procedure YES?

	call	User_String		;Get character

	jz	$$IF1			;Got one if returned NZ
	mov	AL,23h			;See if it is Y/N
	mov	dl,[InBuff+2]		;Get character
	DOS_Call GetExtCntry		;Get country info call
	cmp	AX,Found_Yes		;Which one?

	jne	$$IF2			;Got a Yes
	clc				;Clear CY for return

	jmp	SHORT $$EN2		;Not a Yes
$$IF2:
	cmp	AX,Found_No		;Is it No?

	jne	$$IF4			;Yep
	stc				;Set CY for return

	jmp	SHORT $$EN4		;Something else we don't want
$$IF4:
	xor	AL,AL			;Set NZ flag for ret
	cmp	AL,1			; " "	 " "
	stc				;And CY flag for good measure

$$EN4:
$$EN2:

	jmp	SHORT $$EN1		;No char found at all
$$IF1:
	xor	AL,AL			;Set NZ flag for ret
	cmp	AL,1
	stc				;And CY flag for good measure

$$EN1:
	ret

Yes?	endp


;***************************************************************************
; Get a string from user. Z is set if user typed no chars (imm CR)
;  We need to flush a second time to get rid of incoming Kanji characters also.
;***************************************************************************
Procedure USER_STRING

	mov	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0 ; Clean out input
	int	21h
	mov	DX,OFFSET InBuff
	mov	AH,STD_CON_STRING_INPUT
	int	21h
	mov	AX,(STD_CON_INPUT_FLUSH SHL 8) + 0 ; Clean out input
	int	21h
	cmp	byte ptr [InBuff+1],0
	ret

USER_STRING endp

;*********************************************
; Make a status report including the following information:
; Total disk capacity
; Total system area used
; Total bad space allocated
; Total data space available
; Number of allocation units
; Size of allocation units

Procedure Report

	call	crlf
	call	Calc_System_Space		;calc system space
	call	Calc_Total_Addressible_Space	;calc total space
	cmp	MegSizes,0
	jne	IsHuge3
	jmp	NotHuge3

IsHuge3:
	Message msgTotalDiskSpaceMeg
						;call std_printf
	cmp	word ptr SysSiz,0
	jnz	SHOWSYSh
	cmp	word ptr SysSiz+2,0
	jz	CHKBADh
ShowSysh:
	Message msgSystemSpace
						;CALL	 std_printf
						;Report space used by system
ChkBadh:
	cmp	word ptr BadSiz,0
	jnz	ShowBadh
	cmp	word ptr BadSiz+2,0
	jnz	ShowBadh
	cmp	BadSizM100s,0
	jz	ShowDatah
ShowBadh:
	Message msgBadSpaceMeg
						;call	 std_printf
ShowDatah:
.386
	mov	eax,SysSiz
	xor	edx,edx
	mov	ebx,1024*1024
	div	ebx				;EAX is MEG, EDX remainder
;;	  push	  eax
	db	066h,050h
;;
	mov	eax,edx
	xor	edx,edx
	mov	ebx,(1024 * 1024) / 100
	div	ebx
	shr	ebx,1
	cmp	edx,ebx
	jb	short NoRnd3
	inc	eax
NoRnd3:
;;	  pop	  ecx
	db	066h,059h
;;
	movzx	ebx,BadSizM100s
	add	eax,ebx
	add	ecx,BadSiz			;ECX.EAX is bad+sys size in MEG
	mov	ebx,Fdsksiz
	movzx	edx,FdsksizM100s
ChkBorrow:
	cmp	edx,eax
	jae	short NoSubAdj
	dec	ebx
	add	edx,100
	jmp	short ChkBorrow

NoSubAdj:
	sub	edx,eax
	mov	eax,edx
	sub	ebx,ecx
	mov	datasiz,ebx
.8086
	mov	datasizM100s,AX
	Message msgDataSpaceMeg 		;call	 std_printf
	jmp	short Huge3

NotHuge3:
	Message msgTotalDiskSpace
						;call std_printf
	cmp	word ptr SysSiz,0
	jnz	SHOWSYS
	cmp	word ptr SysSiz+2,0
	jz	CHKBAD
ShowSys:
	Message msgSystemSpace
						;CALL	 std_printf
						;Report space used by system
ChkBad:
	cmp	word ptr BadSiz,0
	jnz	ShowBad
	cmp	word ptr BadSiz+2,0
	jz	ShowData
ShowBad:
	Message msgBadSpace
						;call	 std_printf
ShowData:
	mov	CX,word ptr Fdsksiz
	mov	BX,word ptr Fdsksiz+2
	sub	CX,word ptr BadSiz
	sbb	BX,word ptr BadSiz+2
	sub	CX,word ptr SysSiz
	sbb	BX,word ptr SysSiz+2
	mov	word ptr datasiz,CX
	mov	word ptr datasiz+2,BX
	Message msgDataSpace			;call	 std_printf
Huge3:
	call	crlf
	mov	AX,deviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector ;
	mov	CL,deviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster ;
    .errnz EDP_BPB NE DP_BPB
	xor	CH,CH
	mul	CX				;Get bytes per alloc

	mov	word ptr AllocSize,AX		;Save allocation size
	mov	word ptr AllocSize+2,DX 	; for message
	Message msgAllocSize			;Print size of cluster
	call	Get_Free_Space			;get disk space
.386
	mov	AllocNum,EBX			;Put result in msg
.8086
	Message msgAllocNum			; = cluster/disk
	call	crlf
	test	switchmap, SWITCH_8		;If 8 tracks, don't display
	jnz	NoSerialNumber			;serial number
	Message msgSerialNumber 		;Spit out serial number
	call	crlf

NoSerialNumber:
	ret

Report	endp

;***************************************************************************
;Routine name: Read_Disk
;***************************************************************************
;
;description: Read in data using Generic IOCtl
;
;Called Procedures: None
;
;
;Change History: Created	5/13/87 	MT
;
;Input: AL = Drive number (0=A)
;	DS:BX = Transfer address
;	CX = Number of sectors
;	Read_Write_Relative.Start_Sector_High = Logical start sector high
;	DX = logical start sector number low
;
;Output: CY if error
;	 AH = INT 25h error code
;
;Psuedocode
;----------
;	Save registers
;	Setup structure for function call
;	Read the disk (AX=440Dh, CL = 6Fh)
;	Restore registers
;	ret
;***************************************************************************

Procedure Read_Disk

	push	BX			;Save registers
	push	CX
	push	DX
	push	SI
	push	DI
	push	BP
	push	ES
	push	DS
	mov	SI,data
	mov	ES,SI

	assume	ES:data,DS:nothing
					;Get transfer buffer add
	mov	ES:Read_Write_Relative.Buffer_Offset,BX
	mov	BX,DS
	mov	ES:Read_Write_Relative.Buffer_Segment,BX ;Get segment
	mov	BX,data 		;Point DS at parameter list
	mov	DS,BX

	assume	DS:data,ES:data

	mov	Read_Write_Relative.Number_Sectors,CX ;Number of sec to read
	mov	Read_Write_Relative.Start_Sector_Low,DX ;Start sector
	mov	BX,offset Read_Write_Relative
	mov	CX,0ffffh		;Read relative sector
	mov	dl,al			;Drive # to DL
	inc	dl			;1 based
	mov	ax,(Get_Set_DriveInfo SHL 8) OR Ext_ABSDiskReadWrite
	mov	si,0			;READ
	int	21h			;Do the read
	pop	DS
	pop	ES
	pop	BP
	pop	DI
	pop	SI
	pop	DX			;Restore registers
	pop	CX
	pop	BX
	ret

Read_Disk endp

;***************************************************************************
;Routine name: Write_Disk
;***************************************************************************
;
;description: Write Data using Generic IOCtl
;
;Called Procedures: None
;
;
;Change History: Created	5/13/87 	MT
;
;Input: AL = Drive number (0=A)
;	DS:BX = Transfer address
;	CX = Number of sectors
;	Read_Write_Relative.Start_Sector_High = Logical start sector high
;	DX = logical start sector number low
;
;Output: CY if error
;	 AH = INT 26h error code
;
;Psuedocode
;----------
;	Save registers
;	Setup structure for function call
;	Write to disk (AX=440Dh, CL = 4Fh)
;	Restore registers
;	ret
;***************************************************************************

Procedure Write_Disk

	push	BX			;Save registers
	push	CX
	push	DX
	push	SI
	push	DI
	push	BP
	push	ES
	push	DS
	mov	SI,data
	mov	ES,SI

	assume	ES:data, DS:nothing
					;Get transfer buffer add
	mov	ES:Read_Write_Relative.Buffer_Offset,BX
	mov	BX,DS
	mov	ES:Read_Write_Relative.Buffer_Segment,BX ;Get segment
	mov	BX,data 		;Point DS at parameter list
	mov	DS,BX

	assume	DS:data, ES:data

	mov	Read_Write_Relative.Number_Sectors,CX ;Number of sec to write
	mov	Read_Write_Relative.Start_Sector_Low,DX ;Start sector
	mov	BX,offset Read_Write_Relative
	mov	CX,0ffffh		;Write relative sector
	mov	dl,al			;Drive # to DL
	inc	dl			;1 based
	mov	ax,(Get_Set_DriveInfo SHL 8) OR Ext_ABSDiskReadWrite
	mov	si,1			;WRITE
	int	21h			;Do the write
	pop	DS
	pop	ES
	pop	BP
	pop	DI
	pop	SI
	pop	DX			;Restore registers
	pop	CX
	pop	BX
	ret

Write_Disk endp

;=========================================================================
; Calc_Total_Addressible_Space	: Calculate the total space that is
;				  addressible on the the disk by DOS.
;
;	Inputs	: none
;
;	Outputs : Fdsksiz - Size in bytes of the disk
;=========================================================================

Procedure Calc_Total_Addressible_Space

	push	AX				;save affected regs
	push	DX
	push	BX

	call	Get_Free_Space			;get free disk space

.386
;; Manual assemble to prevent compile warning
;;	  push	  EBX				  ;save avail. cluster
;;	  push	  EDX				  ;save total. cluster
	  db	066h,053h
	  db	066h,052h
;;
	movzx	ecx,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
	movzx	eax,DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
    .errnz EDP_BPB NE DP_BPB
	mul	ecx
	mov	ecx,eax 			;ECX = bytes/clus

;; Manual assemble to prevent compile warning
;;	  pop	  eax				  ;Recover Total Clus
;;	  push	  eax
	db	066h,058h
	db	066h,050h
;;
	mul	ecx				;EDX:EAX = Total Bytes
	mov	FdskSiz,eax
	or	edx,edx 			;Disk >= 4Gig?
	jz	short NotHuge1			;No
	mov	MegSizes,1
	mov	ebx,1024*1024
	div	ebx				; EAX is MEG, EDX remainder
	mov	FdskSiz,EAX
	mov	eax,edx
	xor	edx,edx
	mov	ebx,(1024 * 1024) / 100
	div	ebx
	shr	ebx,1
	cmp	edx,ebx
	jb	short NoRnd1
	inc	eax
NoRnd1:
	mov	fdsksizM100s,ax
	cmp	eax,100
	jb	short NotHuge1
	inc	FdskSiz
	mov	fdsksizM100s,0
NotHuge1:

;; Manual assemble to prevent compile warning
;;	  pop	  EDX				  ;get total clusters
;;	  pop	  EBX				  ;get avail clusters
	db	066h,05Ah
	db	066h,05Bh
;;
	mov	EAX,EDX 			;get total clusters
	sub	EAX,EBX 			;get bad+sys clusters
	test	fBig32FAT,0ffh
	jz	short NotFAT32
	dec	eax				;FAT32 volumes have one
						; cluster allocated to the
						; root dir
NotFAT32:
	mul	ecx				;EDX:EAX bad+sys bytes
	sub	EAX,SysSiz			;Remove sys bytes
	sbb	EDX,0
	mov	ecx,edx
	or	ecx,eax 			;ECX != 0 if any bad clusters
	mov	badsiz,EAX
	cmp	MegSizes,0			;Disk >= 4Gig?
	je	short NotHuge2			;No
	mov	ebx,1024*1024
	div	ebx				;EAX is MEG, EDX remainder
	mov	badsiz,EAX
	mov	eax,edx
	xor	edx,edx
	mov	ebx,(1024 * 1024) / 100
	div	ebx
	shr	ebx,1
	cmp	edx,ebx
	jb	short NoRnd2
	inc	eax
NoRnd2:
	mov	badsizM100s,ax
	cmp	eax,100
	jb	short ChkZr
	inc	badsiz
	mov	badsizM100s,0
ChkZr:
	cmp	badsiz,0
	jnz	short NotHuge2
	cmp	badsizM100s,0
	jnz	short NotHuge2
	or	ecx,ecx 			;Were there any bad clusters?
	jz	short NotHuge2			;No
    ;
    ; There WERE bad clusters, but there were less than .01 MEG worth of them.
    ;	Need to cheat so that the displayed count is != 0
    ;
	inc	badsizM100s
NotHuge2:
.8086
	pop	BX
	pop	DX				;restore regs
	pop	AX

	ret

Calc_Total_Addressible_Space	endp


;=========================================================================
; Get_Free_Space	: Get the free space on the disk.
;
;	Inputs	: none
;
;	Outputs : EBX - Available space in clusters
;		  EDX - Total space in clusters
;=========================================================================

Procedure Get_Free_Space

.386
	push	di
	xor	ebx,ebx
	mov	ax,(Get_Set_DriveInfo SHL 8) OR Get_ExtFreeSpace
	mov	cx,SIZE ExtGetDskFreSpcStruc
	push	ds
	pop	es
	mov	di,offset ExtFreePacket
	mov	DX,offset DriveLetter
	int	21h
	mov	edx,ebx
	jc	short IsDone
	mov	ebx,[di.ExtFree_AvailableClusters]
	mov	edx,[di.ExtFree_TotalClusters]
.8086
IsDone:
	pop	di
	ret

Get_Free_Space	endp

;=========================================================================
; Calc_System_Space	: This routine calculates the space occupied by
;			  the system on the disk.
;
;	Inputs	: BIOS.FileSizeInBytes
;		  Command.FileSizeInBytes
;
;	Outputs : SysSiz			- Size of the system
;=========================================================================

Procedure Calc_System_Space

	push	AX					;save regs
	push	DX

	mov	word ptr SysSiz+0,00h			;clear variable
	mov	word ptr SysSiz+2,00h

        mov     AX,word ptr [Dos.FileSizeInBytes+0]     ;get dos size
        mov     DX,word ptr [Dos.FileSizeInBytes+2]
	call	AddToSystemSize 			;add in values

	mov	AX,word ptr [Bios.FileSizeInBytes+0]	;get bios size
	mov	DX,word ptr [Bios.FileSizeInBytes+2]
	call	AddToSystemSize 			;add in values

	mov	AX,word ptr [Command.FileSizeInBytes+0] ;get command size
	mov	DX,word ptr [Command.FileSizeInBytes+2]
	call	AddToSystemSize 			;add in values

IFDEF DBLSPACE_HOOKS
	mov	ax, word ptr [DblSpaceBin.FileSizeInBytes]	;get dblspace
	mov	dx, word ptr [DblSpaceBin.FileSizeInBytes+2]	; size--may be
	call	AddToSystemSize 				; zero
ENDIF
	pop	DX									;restore regs
	pop	AX
	ret

Calc_System_Space	endp

code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\formsg.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;

;
;*****************************************************************************
; Macro's
;*****************************************************************************
;
;
;---------------------------------------------------------------------------
;
; M024 : B#5495. Added "Insufficient memory" message when FORMAT cannot
;		allocate memory for FAT, Directory... etc. Reclaimed
;		the msgBadDrive which was not being used.
;
; M028 : B#6073. Changed width of cluster number field from 8 to 5
;		in msgVerify sublist.
;
;---------------------------------------------------------------------------
;

Define_Msg macro Message_Name			;
						;
Create_Msg Message_Name,Message_Number,Handle,Sublist,Count,Class,Function,Input
						;
	endm					;

;-----------------------------------------------------------------------------

Create_Msg macro Parm1,Parm2,Parm3,Parm4,Parm5,Parm6,Parm7,Parm8;

Public	Parm1
Parm1	label	word				;
	dw	Parm2				;
	dw	Parm3				;
	dw	Parm4				;
	dw	Parm5				;
	db	Parm6				;
	db	Parm7				;
	dw	Parm8				;
	endm					;


;
;*****************************************************************************
; External data declarations
;*****************************************************************************
;

	Extrn	DriveLetter:Byte
	Extrn	SystemDriveLetter:Byte
	Extrn	CurrentHead:Byte
	Extrn	CurrentCylinder:Word
	Extrn	FdskSiz:DWord
	Extrn	FdskSizM100s:Word
	Extrn	SysSiz:DWord
	Extrn	BadSiz:DWord
	Extrn	BadSizM100s:Word
	Extrn	DataSiz:DWord
	Extrn	DataSizM100s:Word
	Extrn	Drive_Letter_Msg:Byte
	Extrn	PercentComplete:Byte
	Extrn	AllocSize:Dword
	Extrn	AllocNum:Word
	Extrn	Serial_Num_Low:Word
	Extrn	Serial_Num_High:Word
	Extrn	Command_Old_Ptr:Word
	Extrn	Msg_Allocation_Unit_Val:Dword
	Extrn	SizeInK 	:Word
	Extrn	SizeInM 	:Word
	Extrn	DecSizeInM	:Word
;
;*****************************************************************************
; Publics
;*****************************************************************************
;

	Public	msgDecimalNumberofDecimal

;
;*****************************************************************************
; Message Retriever equates
;*****************************************************************************
;

Format_Msg		equ	'C'

N_A			equ	0
Sublist_Length		equ	11
None			equ	0

Blank			equ	" "
No_Function		equ	0
No_Replace		equ	0

Msg_Ser_Class		equ	0
Ext_Err_Class		equ	1
Parse_Err_Class 	equ	2
Utility_Msg_Class	equ	3

Reserved		equ	0

	PUBLIC	MSG_OPTIONS_FIRST, MSG_OPTIONS_LAST, MSG_OPTIONS_SKIP1, MSG_OPTIONS_SKIP2
MSG_OPTIONS_FIRST	equ	300	; first options help msg
ifdef NEC_98
ifdef OPKBLD
MSG_OPTIONS_LAST        equ     322     ;  and last
else
MSG_OPTIONS_LAST        equ     320     ;  and last
endif
else
ifdef OPKBLD
MSG_OPTIONS_LAST        equ     319     ;  and last
else
MSG_OPTIONS_LAST        equ     317     ;  and last
endif
endif

ifdef OPKBLD
MSG_OPTIONS_SKIP1       equ     330     ; Do not skip any help messages
MSG_OPTIONS_SKIP2       equ     330     ; Do not skip any help messages
else
MSG_OPTIONS_SKIP1       equ     311     ; skip /S help
MSG_OPTIONS_SKIP2       equ     310     ; skip /B help
endif

data	segment public	para	'DATA'
	assume	ds:data


;
;*****************************************************************************
; Message Sublist Tables
;*****************************************************************************
;
;The  following  control  blocks  are	used   for   messages  with
;replaceable  paramaters.  These  control  blocks  are	used by  the
;SysDispMsg routine.
;

;---------------------------			;
Sublist_msgCurrentTrack label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset PercentComplete	;
	dw		data			;
	db		1			;
	db		Right_Align+Unsgn_Bin_Word ;
	db		3			;Max % is 100
	db		3			;Min % is 0
	db		Blank			;
;---------------------------			;
Sublist_msgDblspaceDrv	label dword
Sublist_msgDblspaceHost label dword
Sublist_msgInsertDisk	label dword		;
Sublist_msgReInsertDisk label dword		;
Sublist_MsgHardDiskWarning label dword		;
Sublist_msgFormatNotSupported label dword	;
Sublist_msgNoExclusiveAccess	label dword	;

	db		Sublist_Length		;
	db		Reserved		;
	dw		offset DriveLetter	;
	dw		data			;
	db		1			;
	db		Left_Align+Char_Field_Char ;
	db		1			;
	db		1			;
	db		Blank			;
;---------------------------			;
Sublist_msgInsertDOSDisk label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset SystemDriveLetter;
	dw		data			;
	db		1			;
	db		Left_Align+Char_Field_Char ;
	db		1			;
	db		1			;
	db		Blank			;
;---------------------------			;
Sublist_msgTotalDiskSpace label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset FdskSiz		;
	dw		data			;
	db		1			;
	db		Right_Align+Unsgn_Bin_Dword
	db		13			;
	db		13			;4,000,000,000 limit
	db		Blank			;
;---------------------------			;
Sublist_msgTotalDiskSpaceMeg label dword	;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset FdskSiz		;
	dw		data			;
	db		1			;
	db		Right_Align+Unsgn_Bin_Dword
	db		10			;
	db		10			;
	db		Blank			;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset FdskSizM100s	;
	dw		data			;
	db		2			;
	db		Right_Align+Unsgn_Bin_Word ;
	db		2			;
	db		2			;
	db		'0'			;

;---------------------------			;
Sublist_msgSystemSpace	label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset SysSiz		;
	dw		data			;
	db		1			;
	db		Right_Align+Unsgn_Bin_DWord
	db		13			;
	db		13			;64k*3 max
	db		Blank			;
;---------------------------			;
Sublist_msgBadSpace	label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset BadSiz		;
	dw		data			;
	db		1			;
	db		Right_Align+Unsgn_Bin_DWord
	db		13			;
	db		13			;4,000,000,000 max
	db		Blank			;
;---------------------------			;
Sublist_msgBadSpaceMeg	label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset BadSiz		;
	dw		data			;
	db		1			;
	db		Right_Align+Unsgn_Bin_DWord
	db		10			;
	db		10			;
	db		Blank			;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset BadSizM100s	;
	dw		data			;
	db		2			;
	db		Right_Align+Unsgn_Bin_Word ;
	db		2			;
	db		2			;
	db		'0'			;
;---------------------------			;
Sublist_msgDataSpace	label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		Offset DataSiz		;
	dw		data			;
	db		1			;
	db		Right_Align+Unsgn_Bin_DWord
	db		13			;
	db		13			;4,000,000,000 max
	db		Blank			;
;---------------------------			;
Sublist_msgDataSpaceMeg label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		Offset DataSiz		;
	dw		data			;
	db		1			;
	db		Right_Align+Unsgn_Bin_DWord
	db		10			;
	db		10			;
	db		Blank			;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset DataSizM100s	;
	dw		data			;
	db		2			;
	db		Right_Align+Unsgn_Bin_Word ;
	db		2			;
	db		2			;
	db		'0'			;
;---------------------------			;
Sublist_msgWhatIsVolumeId?  label dword 	;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset DriveLetter	;
	dw		data			;
	db		1			;
	db		Left_Align+Char_Field_Char ;
	db		1			;
	db		1			;
	db		Blank			;
;---------------------------			;
Sublist_msgEXECFailure	label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		Drive_Letter_Msg	;
	dw		data			;
	db		1			;
	db		Left_Align+Char_Field_ASCIIZ ;
	db		2			;
	db		2			;
	db		Blank			;
;---------------------------			;
Sublist_msgAllocNum	label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset AllocNum 	;
	dw		data			;
	db		1			;
	db		Right_Align+Unsgn_Bin_DWord
	db		13			;
	db		13			;
	db		Blank			;
;---------------------------			;
Sublist_msgAllocSize	label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset AllocSize	;
	dw		data			;
	db		1			;
	db		Right_Align+Unsgn_Bin_DWord
	db		13			;
	db		13			;
	db		Blank			;
;---------------------------			;
Sublist_msgSerialNumber label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset Serial_Num_Low	;
	dw		data			;
	db		1			;
	db		Right_Align+Bin_Hex_Word ;
	db		4			;
	db		4			;
	db		'0'			;Display leading 0's
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset Serial_Num_High	;
	dw		data			;
	db		2			;
	db		Right_Align+Bin_hex_Word ;
	db		4			;
	db		4			;
	db		'0'			;

Public	Sublist_MsgParse_Error
Sublist_msgParse_Error	      label dword	;

	db		Sublist_Length		;
	db		Reserved		;
	dw		0			;
	dw		Data			;
	db		0			;
	db		Left_Align+Char_Field_ASCIIZ ;
	db		20			;
	db		01			;
	db		Blank			;
;---------------------------			;
Sublist_MsgVerify	label dword		;
						;
	db		Sublist_Length		;
	db		Reserved		;
	dw		offset Msg_Allocation_Unit_Val;
	dw		data			;
	db		1			;
	db		Right_Align+Unsgn_Bin_DWord
	db		13			; Max 4,000,000,000
	db		13			;
	db		Blank
;----------------------------
Sublist_msgShowKBytes label dword		; Added with quick format
						;
	db		Sublist_Length		;				
	db		Reserved		;				
	dw		offset SizeInK		;				
	dw		data			;				
	db		1			;				
	db		Right_Align+Unsgn_Bin_Word ;				
	db		3			;Max is 999			
	db		3			;				
	db		Blank			;				
;---------------------------			;
Sublist_msgShowMBytes label dword		;				
						;
	db		Sublist_Length		;				
	db		Reserved		;				
	dw		offset SizeInM		;				
	dw		data			;				
	db		1			;				
        db              Right_Align+Unsgn_Bin_Word
        db              5                       ;Max is 9,999
        db              5                       ;Min is 1
	db		Blank			;				
;---------------------------			;
Sublist_msgDecimalMBytes label dword		;				
						;
	db		Sublist_Length		;				
	db		Reserved		;				
	dw		offset SizeInM		;				
	dw		data			;				
	db		1			;				
	db		Right_Align+Unsgn_Bin_Word ;				
	db		13			; Max x,000,000,000
	db		0			;				
	db		'0'
	db		Sublist_Length		;				
	db		Reserved		;				
	dw		offset DecSizeInM	;				
	dw		data			;				
	db		2			;				
	db		Right_Align+Unsgn_Bin_Word ;				
	db		2			;Max is .99			
msgDecimalNumberofDecimal label byte		;M007; 
	db		2			;Min is .10 ; M007: Not anymore 
	db		'0'
;----------------------------	
;
;*****************************************************************************
; Message Description Tables
;*****************************************************************************
;

;---------------------- 			;
Message_Number	= 1				;
Handle		= No_Handle			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Input			;
Input		= N_A				;
	Define_Msg	msgBadDOSVersion	;
;---------------------- 			;
Message_Number	= 2				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgCurrentTrack	;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Input			;
Input		= N_A				;
	Define_Msg	msgCurrentTrack 	;
;---------------------- 			;
Message_Number	= 3				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgDataSpace		;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgDataSpace		;
;---------------------- 			;
Message_Number	= 4				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Input			;
Input		= N_A				;
	Define_Msg	msgFormatComplete	;
;---------------------- 			;
Message_Number	= 5				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgBadSpace		;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgBadSpace		;
;---------------------- 			;
Message_Number	= 6				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgTotalDiskSpace	;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgTotalDiskSpace	;
;---------------------- 			;
Message_Number	= 7				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgInsertDisk 	;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgInsertDisk		;
;---------------------- 			;
Message_Number	= 8				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgSystemSpace	;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgSystemSpace		;
;---------------------- 			;
Message_Number	= 9				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgReInsertDisk	;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg   msgReInsertDisk		;
;---------------------- 			;
Message_Number	= 10				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgLabelPrompt		;
;---------------------- 			;
Message_Number	= 11				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgFormatNotSupported ;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgFormatNotSupported	;
;---------------------- 			;
Message_Number	= 12				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgInvalidDeviceParameters;
;---------------------- 			;
Message_Number	= 13				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgErrorInIOCTL 	;
;---------------------- 			;
Message_Number	= 14				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgNotBlockDevice	;
;---------------------- 			;
Message_Number	= 15				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgFATwriteError	;
;---------------------- 			;
Message_Number	= 16				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgDirectoryWriteError	;
;---------------------- 			;
Message_Number	= 17				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgAssignedDrive	;
;---------------------- 			;
Message_Number	= 18				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgNoSystemFiles	;
;---------------------- 			;
Message_Number	= 19				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgNetDrive		;
;---------------------- 			;
Message_Number	= 20				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgBadCharacters	;
;---------------------- 			;
Message_Number	= 21				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgParametersNotSupported ;
;---------------------- 			;
Message_Number	= 22				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgFormatFailure	;
;---------------------- 			;
Message_Number	= 23				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgNotSystemDisk	;
;---------------------- 			;
Message_Number	= 24				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgDiskUnusable 	;
;---------------------- 			;
Message_Number	= 25				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgBootWriteError	;
;---------------------- 			;
Message_Number	= 26				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgDirectoryReadError	;
;---------------------- 			;
Message_Number	= 27				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgNeedDrive		;
;---------------------- 			;
Message_Number	= 28				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	ContinueMsg		;
;---------------------- 			;
Message_Number	= 29				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgBadVolumeId		;
;---------------------- 			;
Message_Number	= 30				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Input			;
Input		= N_A				;
	Define_Msg	msgSystemTransfered	;
;---------------------- 			;
Message_Number	= 31				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgWhatIsVolumeId?	;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgWhatIsVolumeId?	;
;---------------------- 			;
Message_Number	= 32				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgIncompatibleParametersForHardDisk ;
;---------------------- 			;

Message_Number	= 33				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgWriteProtected	;
;---------------------- 			;
Message_Number	= 34				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgNotReady		;
;---------------------- 			;

ifndef NEC_98
Message_Number	= 35				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgPartitionTableReadErr ;
endif
;---------------------- 			;
Message_Number	= 36				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgSerialNumber	;
Count		= 2				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgSerialNumber 	;
;---------------------- 			;
Message_Number	= 37				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgFormatBroken 	;
;---------------------- 			;
Message_Number	= 38				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgEXECFailure	;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgEXECFailure		;
;---------------------- 			;
Message_Number	= 39				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	NO_SYS_MESS		;
ifndef NEC_98
;---------------------- 			;
Message_Number	= 40				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgbadpartitiontable	;
endif
;---------------------- 			;
Message_Number	= 41				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgParametersNotSupportedByDrive ;
;---------------------- 			;
Message_Number	= 42				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgCRLF 		;
;---------------------- 			;
Message_Number	= 43				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgInterrupt		;
;---------------------- 			;
Message_Number	= 44				;
Handle		= STDOUT			;
Sublist 	= Sublist_MsgInsertDOSDisk	;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgInsertDOSDisk	;
;---------------------- 			;
Message_Number	= 45				;
Handle		= STDOUT			;
Sublist 	= Sublist_MsgHardDiskWarning	;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgHardDiskWarning	;
;---------------------- 			;
Message_Number	= 46				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgFormatAnother?	;
ifndef NEC_98
;---------------------- 			;
Message_Number	= 47				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgPartitionTableReadError ;
;---------------------- 			;
Message_Number	= 48				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgPartitionTableWriteError ;
endif
;---------------------- 			;
Message_Number	= 49				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgIncompatibleParameters ;
;---------------------- 			;
Message_Number	= 50				;
Handle		= STDOUT			;
Sublist 	= Sublist_MsgAllocNum		;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgAllocNum		;
;---------------------- 			;
Message_Number	= 51				;
Handle		= STDOUT			;
Sublist 	= Sublist_MsgAllocSize		;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgAllocSize		;
ifndef NEC_98
;---------------------- 			;
Message_Number	= 52				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgPartitionTableWriteErr ;
endif
;---------------------- 			;
Message_Number	= 53				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgSameSwitch		;
;---------------------- 			;
Message_Number	= 54				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgBad_T_N		;
;---------------------- 			;
Message_Number	= 55				;
Handle		= STDOUT			;
Sublist 	= Sublist_MsgVerify		;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	MsgVerify		;
;----------------------
Message_Number	= 56
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgNoRoomForRestore

;----------------------
Message_Number	= 57
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgNoRoomDestDisk

;----------------------
Message_Number	= 58
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgNotCompatablePart
;----------------------
Message_Number	= 59
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgFileCreationError

;---------------------- 			;
Message_Number	= 60				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgBad_8_V		;

;---------------------- 			;
Message_Number	= 61				;
Handle		      = STDOUT			      ;
Sublist       = Sublist_MsgHardDiskWarning    ;
Count	      = 1			      ;
Class	      = Utility_Msg_Class	      ;
Function      = No_Function		      ;
Input	      = N_A			      ;
      Define_Msg      msgDiskWarning	      ;
;---------------------- 		      ;
Message_Number	= MSG_OPTIONS_FIRST
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgOptions
;---------------------- 			;
Message_Number	= 62				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgInvZDrive		;
;---------------------- 			;
Message_Number	= 63				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgCantZThisDrive
;---------------------- 			;
Message_Number	= 64				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgCantZFAT16
;---------------------- 			;
Message_Number	= 65				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgCantZFAT32
;---------------------- 			;
Message_Number	= 66				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgZFAT32Huge
;---------------------- 			;
Message_Number	= 67				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgCantZWithQ
;---------------------- 			;
Message_Number	= 68				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgZFAT32TooHuge
;---------------------- 			;
Message_Number	= 0				;
Handle		= STDERR			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Ext_Err_Class 		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	Extended_Error_Msg	;
;----------------------
Message_Number	= 0				;
Handle		= STDERR			;
Sublist 	= Sublist_MsgParse_Error	;
Count		= 1				;
Class		= Parse_Err_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	Parse_Error_Msg 	;
;-----------------------



;
;These need to be coded as extended an parse errors, but left here to link.
;



Message_Number	= 70				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Input			;
Input		= N_A				;
	Define_Msg	msgOutOfMemory		;
;---------------------- 			;
Message_Number	= 71				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Input			;
Input		= N_A				;
	Define_Msg	msgInsufficientMemory	;M024
;---------------------- 			;
Message_Number	= 10				;
Handle		= StdErr			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Parse_Err_Class		;
Function	= No_Input			;
Input		= N_A				;
	Define_Msg	msgInvalidParameter	;
;---------------------- 			;
Message_Number	= 73				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Input			;
Input		= N_A				;
	Define_Msg	msgLoadFailure		;
;-----------------------
Message_Number	= 75				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgQuickFormatAnother?	;
;-----------------------
Message_Number	= 76
Handle		= STDOUT
Sublist 	= No_Replace
Count		= N_A
Class		= Utility_Msg_Class
Function	= No_Function
Input		= N_A
	Define_Msg	msgExistingFormatDiffers
;----------------------
Message_Number	= 77
Handle		= STDOUT
Sublist 	= No_Replace
Count		= N_A
Class		= Utility_Msg_Class
Function	= No_Function
Input		= N_A
	Define_Msg	msgNoQuickFormat
;----------------------
Message_Number	= 78
Handle		= STDOUT
Sublist 	= Sublist_msgShowKBytes
Count		= 1
Class		= Utility_Msg_Class
Function	= No_Input
Input		= N_A
	Define_Msg	msgShowKBytes
;----------------------
Message_Number	= 79
Handle		= STDOUT
Sublist 	= Sublist_msgShowMBytes
Count		= 1
Class		= Utility_Msg_Class
Function	= No_Input
Input		= N_A				
	Define_Msg	msgShowMBytes 	
;---------------------- 			
Message_Number	= 80
Handle		= STDOUT			
Sublist 	= Sublist_msgDecimalMBytes
Count		= 2				
Class		= Utility_Msg_Class		
Function	= No_Function			
Input		= N_A				
	Define_Msg	msgDecimalMBytes 	
;---------------------- 			
Message_Number	= 81
Handle		= STDOUT			;STDOUT
Sublist 	= No_Replace			;No_Replace
Count		= N_A				;N_A
Class		= Utility_Msg_Class		;Utility_Msg_Class
Function	= No_Function			;No_Function
Input		= N_A				;N_A
	Define_Msg	msgSysWarning
;----------------------
Message_Number	= 82
Handle		= STDOUT			
Sublist 	= Sublist_msgShowKBytes
Count		= 1				
Class		= Utility_Msg_Class		
Function	= No_Input			
Input		= N_A				
	Define_Msg	msgVerifyShowKBytes 	
;---------------------- 			
Message_Number	= 83
Handle		= STDOUT			
Sublist 	= Sublist_msgShowMBytes
Count		= 1				
Class		= Utility_Msg_Class		
Function	= No_Input			
Input		= N_A				
	Define_Msg	msgVerifyShowMBytes 	
;---------------------- 			
Message_Number	= 84
Handle		= STDOUT			
Sublist 	= Sublist_msgDecimalMBytes
Count		= 2				
Class		= Utility_Msg_Class		
Function	= No_Function			
Input		= N_A				
	Define_Msg	msgVerifyDecimalMBytes 	
;---------------------- 			
Message_Number	= 85
Handle		= STDOUT
Sublist 	= No_Replace
Count		= N_A
Class		= Utility_Msg_Class
Function	= No_Input
Input		= N_A
	Define_Msg	msgSavingUNFORMATInfo
;---------------------- 			
Message_Number	= 86
Handle		= STDOUT
Sublist 	= No_Replace
Count		= N_A
Class		= Utility_Msg_Class
Function	= No_Input
Input		= N_A
	Define_Msg	msgCheckExistingDiskFormat
;---------------------- 			
Message_Number	= 87
Handle		= STDOUT			
Sublist 	= Sublist_msgShowKBytes
Count		= 1				
Class		= Utility_Msg_Class		
Function	= No_Input			
Input		= N_A				
	Define_Msg	msgQuickFormatShowKBytes 	
;---------------------- 			
Message_Number	= 88
Handle		= STDOUT			
Sublist 	= Sublist_msgShowMBytes
Count		= 1				
Class		= Utility_Msg_Class		
Function	= No_Input			
Input		= N_A				
	Define_Msg	msgQuickFormatShowMBytes 	
;---------------------- 			
Message_Number	= 89
Handle		= STDOUT			
Sublist 	= Sublist_msgDecimalMBytes
Count		= 2				
Class		= Utility_Msg_Class		
Function	= No_Function			
Input		= N_A				
	Define_Msg	msgQuickFormatDecimalMBytes 	

;---------------------- 			;
Message_Number	= 90				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgDblspaceDrv	;
Count		= 1				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgDblspaceDrv		;

;----------------------
Message_Number	= 91
Handle		= STDOUT
Sublist 	= Sublist_msgDblspaceHost
Count		= 1
Class		= Utility_Msg_Class
Function	= No_Function
Input		= N_A
	Define_Msg	msgDblspaceHost

;----------------------
Message_Number	= 92
Handle		= STDOUT
Sublist 	= Sublist_msgNoExclusiveAccess
Count		= 1
Class		= Utility_Msg_Class
Function	= No_Function
Input		= N_A
	Define_Msg	msgNoExclusiveAccess

;---------------------- 			;
Message_Number	= 93				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgSetBadClus

Message_Number	= 94				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgSetBadClusDone

Message_Number	= 95				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgWriteFat

Message_Number	= 96				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgTotalDiskSpaceMeg	;
Count		= 2				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgTotalDiskSpaceMeg	;

Message_Number	= 97				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgBadSpaceMeg	;
Count		= 2				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgBadSpaceMeg		;

Message_Number	= 98				;
Handle		= STDOUT			;
Sublist 	= Sublist_msgDataSpaceMeg	;
Count		= 2				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgDataSpaceMeg 	;

Message_Number	= 99				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgReCalcFree

Message_Number	= 94				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Function			;
Input		= N_A				;
	Define_Msg	msgCalcFreeDone

Message_Number	= 100				;
Handle		= STDOUT			;
Sublist 	= No_Replace			;
Count		= N_A				;
Class		= Utility_Msg_Class		;
Function	= No_Input			;
Input		= N_A				;
	Define_Msg	msgNoSysSwitch		;

data ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\forswtch.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;FORMAT Pre-defined switches

 SWITCH_S EQU		0001h			   ; System transfer
 SWITCH_V EQU		0002h			   ; Volume ID prompt
 SWITCH_BACKUP EQU	0004h
 SWITCH_Q EQU		0008h
 SWITCH_T EQU		0010h
 SWITCH_N EQU		0020h
 SWITCH_1 EQU		0040h
 SWITCH_4 EQU		0080h
 SWITCH_8 EQU		0100h
 SWITCH_B EQU		0200h
 SWITCH_SELECT	EQU	0400h
 SWITCH_AUTOTEST EQU	0800h
 SWITCH_F	EQU	1000h
 SWITCH_FS	EQU	2000h

IF ShipDisk

 SWITCH_Z	EQU	4000h
						; 1 sector/cluster switch
ENDIF

SWITCH_U	EQU	8000h			; *5.00 No restoration file

;	The following new switch(s) are in the SwitchMap2 variable

SWITCH2_C	EQU	0001h

ifdef NEC_98
SWITCH2_P	EQU	0002h
;
SWITCH2_6	EQU	0004h		;
SWITCH2_9	EQU	0008h		;
SWITCH2_5	EQU	0010h		;
SWITCH2_M	EQU	0020h		;
SWITCH2_4	EQU	0040h		;
;
endif
SWITCH2_A       EQU     0080h           ; for OFORMAT, align system sectors

; The following is a list of equates to define each IBM defined diskette size
; for use with the /F switch


ifdef NEC_98
Size_640	equ	0001h
Size_1250	equ	0002h
Size_160	equ	0000h			;Flag settings for size switch
Size_180	equ	0000h
Size_320	equ	0000h
Size_360	equ	0000h
Size_720	equ	0010h
Size_1200	equ	0020h
Size_1440	equ	0040h
Size_2880	equ	0000h
else
Size_160	equ	0001h			;Flag settings for size switch
Size_180	equ	0002h
Size_320	equ	0004h
Size_360	equ	0008h
Size_720	equ	0010h
Size_1200	equ	0020h
Size_1440	equ	0040h
Size_2880	equ	0080h
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\forparse.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;



data	segment public para 'DATA'

;
;*****************************************************************************
; Publics
;*****************************************************************************
;

	Public	Drive_Letter_Buffer
	Public	Switch_Buffer
	Public	Switch_Num_Buffer
	Public	Switch_String_Buffer


;
;***************************************************************************
; Equates
;***************************************************************************
;

;Match Flags

Numeric_Value		equ	8000h		;				;AN000;
Signed_Numeric_Value	equ	4000h		;				;AN000;
Simple_String		equ	2000h		;				;AN000;
Date_String		equ	1000h		;				;AN000;
Time_String		equ	0800h		;				;AN000;
Complex_List		equ	0400h		;				;AN000;
Filespec		equ	0200h		;				;AN000;
Drive_Only		equ	0100h		;				;AN000;
Quoted_String		equ	0080h		;				;AN000;
Ignore_Colon		equ	0010h		;				;AN000;
Repeats_Allowed 	equ	0002h		;				;AN000;
Optional		equ	0001h		;				;AN000;

;Function_Flags

File_Table_Capitalize	equ	1		;				;AN000;
Char_Table_Capitalize	equ	2		;				;AN000;
Remove_Colon		equ	10h		;				;AN000;

;Extra delimeters and EOL

Delimiters_Only 	equ	1		;				;AN000;
EOL_Or_Delimiters	equ	2		;				;AN000;

Semi_Colon		equ	";"             ;                               ;AN000;
Tab			equ	09h		;				;AN000;
Colon			equ	":"             ;                               ;AN000;


;Parse Errors

No_Error		equ	0		;				;AN000;
Too_Many_Operands	equ	1		;				;AN000;
Operand_Missing 	equ	2		;				;AN000;
Not_In_Switch_List	equ	3		;				;AN000;
Not_In_Keyword_List	equ	4		;				;AN000;
Out_Of_Range		equ	6		;				;AN000;
Not_In_Value_List	equ	7		;				;AN000;
Not_In_String_List	equ	8		;				;AN000;
Syntax_Error		equ	9		;				;AN000;
End_Of_Parse		equ	-1		;				;AN000;

;Return types

Type_Reserved		equ	0		;				;AN000;
Type_Number		equ	1		;				;AN000;
Type_List_Index 	equ	2		;				;AN000;
Type_String		equ	3		;				;AN000;
Type_Complex		equ	4		;				;AN000;
Type_Filespec		equ	5		;				;AN000;
Type_Drive		equ	6		;				;AN000;
Type_Date		equ	7		;				;AN000;
Type_Time		equ	8		;				;AN000;
Type_Quoted_String	equ	9		;				;AN000;

;Other

None			equ	0		;				;AN000;
No_Error		equ	0		;				;AN000;
Switch_Found		equ	0FFFFh		;				;AN000;
Range_Ok		equ	1		;				;AN000;
Command_Line_Parms	equ	81h		;				;AN000;

;
;*****************************************************************************
; Parse Structures
;*****************************************************************************
;

Control 	 struc

Match_Flags	dw	?
Function_Flags	dw	?
Result		dw	?
Values		dw	?
Num_Keywords	db	?
Keyword 	db	?

Control 	ends

Drive_Letter_Return	struc			;				;AN000;

Drive_Type	db	0			;				;AN000;
Drive_Item_Tag	db	0			;				;AN000;
Drive_Pointer	dw	0			;				;AN000;
Drive_Number	db	0			;A=1, B=2, C=3			;AN000;
Drive_debug	db	8 dup(0)

Drive_Letter_Return	ends			;				;AN000;

Switch_Return	 struc				;				;AN000;

Switch_Type	db	0			;				;AN000;
Switch_Item_Tag db	0			;				;AN000;
Switch_Pointer	dw	0			;				;AN000;
Switch_Debug	db	4 dup(0)

Switch_Return	 ends				;				;AN000;

Switch_Num_Return    struc			;				;AN000;

Switch_Num_Type     db	    0			    ;				    ;AN000;
Switch_Num_Item_Tag db	    0			    ;				    ;AN000;
Switch_Num_Pointer  dw	    0			    ;				    ;AN000;
Switch_Number_Low   dw	    0		    ;				    ;AN000;
Switch_Number_High  dw	    0		    ;				    ;AN000;

Switch_Num_Return    ends			;				;AN000;

Switch_String_Return   struc			;				;AN000;

Switch_String_Type     db      0		       ;			       ;AN000;
Switch_String_Item_Tag db      0		       ;			       ;AN000;
Switch_String_Pointer  dw      0		       ;			       ;AN000;
Switch_String_Off	dw	0		;				;AN000;
Switch_String_Seg	dw	0		;				;AN000;

Switch_String_Return ends			;				;AN000;


;
;**************************************************************************
; Parse tables
;**************************************************************************
;

IF FSExec					;conditionally assemble /FS:	;an018; dms;

Switch_FS_Table       label byte		;				;AN000;

	dw	Drive_Control_Definition	;Point to next level		;AN000;
	db	0				;				;AN000;

ENDIF						;end conditional assembly /FS:	;an018; dms;

Command_Line_Table label byte			;				;AN000;

	dw	Command_Control 		;Point to next level		;AN000;
	db	0				;				;AN000;

;
;**************************************************************************
;Define Positionals, Switches and Keywords
;**************************************************************************
;


IF FSExec					;conditionally assemble /FS:	;an018; dms;

Drive_Control_Definition label byte		;				;AN000;

	db	1,1				;Only drive letter posistional	;AN000;
	dw	Positional_Control		;Pointer to control table	;AN000;
	db	1				;1 switch			;AN000;
	dw	Switch_FS_Control		;				;AN000;
	db	None				;No Keywords (maxk)		;AN000;

ENDIF						;end conditional assembly /FS:	;an018; dms;

Command_Control label byte			;				;AN000;

	db	1,1				;Only drive letter posistional	;AN000;
	dw	Positional_Control		;Pointer to control table	;AN000;

IF	ShipDisk
ifdef NEC_98
		db	20	; /Z only extra switch needed
else
		db	17	; /U and /Z switches needed
endif
ELSE
ifdef NEC_98
		db	19	; /Z only extra switch needed
else
		db	16	; /Z only extra switch needed
endif
ENDIF

	dw	Switch_V_Control		;Without quotes 		AN000;
	dw	Switch_S_Control		;				;AN000;
ifdef NEC_98
	dw	Switch_4_Control		;				;AN000;
	dw	Switch_M_Control		;				;AN000;
	dw	Switch_5_Control		;				;AN000;
	dw	Switch_9_Control		;				;AN000;
	dw	Switch_6_Control		;				;AN000;
	dw	Switch_P_Control		;
else
	dw	Switch_4_Control		;				;AN000;
	dw	Switch_1_Control		;				;AN000;
	dw	Switch_8_Control		;				;AN000;
endif
ifdef OPKBLD
	dw	Switch_B_Control		;				;AN000;
endif
	dw	Switch_T_Control		;				;AN000;
	dw	Switch_N_Control		;				;AN000;
	dw	Switch_Select_Control		;				;AN000;
	dw	Switch_Backup_Control		;				;AN000;
	dw	Switch_Autotest_Control 	;				;AN000;
	dw	Switch_F_Control		;				;AC001;

IF ShipDisk
	dw	Switch_Z_Control		;1 sector/cluster switch	;an000; dms;
ENDIF

	dw	Switch_U_Control		; No restore file switch

	dw	Switch_?_Control		; Display options
	dw	Switch_Q_Control		; Quick format option
	dw	Switch_C_Control		; Clear FAT option (revert)
;ifdef   OPKBLD
        dw      Switch_A_Control                ; Align System sectors
;endif
	db	None				;No Keywords (maxk)		;AN000;



;
;**************************************************************************
;Control Tables
;**************************************************************************
;

Positional_Control label byte			;				;AN000;

	dw	Drive_Only			;Match_Flag			;AN000;
	dw	None				;No function flags		;AN000;
	dw	Drive_Letter_Buffer		;Where it will be returned	;AN000;
	dw	No_Value			;No value ranges defined	;AN000;
	db	None				;No defined switches/keywords	;AN000;

IF FSExec					;conditionally assemble /FS:	;an018; dms;

Switch_FS_Control label byte
	dw	Simple_String			;/FS:xxxxx			;AN000;
	dw	File_Table_Capitalize		;Make it uppercase		;AN000;
	dw	Switch_String_Buffer		;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/FS",0                         ;                               ;AN000;

ENDIF						;end conditional assembly /FS:	;an018; dms;

Switch_V_Control label byte			;				;AN000;

	dw	Simple_String+Quoted_String+Optional ;/v:xxxxxxxx		;AN000;
	dw	File_Table_Capitalize		;				;AN000;
	dw	Switch_String_Buffer		;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/V",0                          ;                               ;AN000;

Switch_S_Control label byte			;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/S",0                          ;                               ;AN000;

ifdef NEC_98
Switch_4_Control label byte			;

	dw	None				;
	dw	None				;
	dw	Switch_Buffer			;
	dw	No_Value			;
	db	1				;
	db	"/4",0                          ;

Switch_M_Control label byte			;

	dw	None				;
	dw	None				;
	dw	Switch_Buffer			;
	dw	No_Value			;
	db	1				;
	db	"/M",0                          ;

Switch_5_Control label byte			;
	dw	None				;
	dw	None				;
	dw	Switch_Buffer			;
	dw	No_Value			;
	db	1				;
	db	"/5",0                          ;

Switch_9_Control label byte			;

	dw	None				;
	dw	None				;
	dw	Switch_Buffer			;
	dw	No_Value			;
	db	1				;
	db	"/9",0                          ;

Switch_6_Control label byte			;

	dw	None				;
	dw	None				;
	dw	Switch_Buffer			;
	dw	No_Value			;
	db	1				;
	db	"/6",0                          ;

Switch_P_Control label byte			;

	dw	None				;
	dw	None				;
	dw	Switch_Buffer			;
	dw	No_Value			;
	db	1				;
	db	"/P",0                          ;
else
Switch_4_Control label byte			;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/4",0                          ;                               ;AN000;

Switch_1_Control label byte			;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/1",0                          ;                               ;AN000;

Switch_8_Control label byte			;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/8",0                          ;                               ;AN000;
endif

Switch_B_Control label byte			;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/B",0                          ;                               ;AN000;

Switch_T_Control label byte			;				;AN000;

	dw	Numeric_Value			;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Num_Buffer		;				;AN000;
	dw	Switch_T_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/T",0                          ;                               ;AN000;

Switch_N_Control label byte			;				;AN000;

	dw	Numeric_Value			;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Num_Buffer		;				;AN000;
	dw	Switch_N_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/N",0                          ;                               ;AN000;

Switch_Select_Control label byte		;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/SELECT",0                     ;                               ;AN000;

Switch_Backup_Control label byte		;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/BACKUP",0                     ;                               ;AN000;

Switch_Autotest_Control label byte		;				;AN000;

	dw	None				;				;AN000;
	dw	None				;				;AN000;
	dw	Switch_Buffer			;				;AN000;
	dw	No_Value			;				;AN000;
	db	1				;				;AN000;
	db	"/AUTOTEST",0                   ;                               ;AN000;

Switch_F_Control label byte			;				;AN001;
	dw	Simple_String			;/F:xxxxx			;AN001;
	dw	File_Table_Capitalize		;Make it uppercase		;AN001;
	dw	Switch_String_Buffer		;				;AN001;
	dw	Switch_Size_Value		;				;AN001;
	db	1				;				;AN001;
	db	"/F",0                          ;                               ;AN001;

IF ShipDisk

Switch_Z_Control label	byte			;control structure for /Z	;an000; dms;
	dw	Numeric_Value
	dw	None
	dw	Switch_Num_Buffer
	dw	Switch_Z_Value
	db	1
	db	"/Z",0

ENDIF

Switch_U_Control label byte

	dw	None
	dw	None	
	dw	Switch_Buffer
	dw	No_Value
	db	1	
	db	"/U",0        

; New switch added 4/18/90 for display options
; c-PaulB

Switch_?_Control label byte

	dw	None
	dw	None	
	dw	Switch_Buffer
	dw	No_Value
	db	1	
	db	"/?",0        

		; Added for /Q quick format switch t-sa 6/27/90

Switch_Q_Control label byte

	dw	None
	dw	None	
	dw	Switch_Buffer
	dw	No_Value
	db	1	
	db	"/Q",0        

		; Added for /C clear fat switch chuckst 7/09/93

Switch_C_Control label byte

	dw	None
	dw	None	
	dw	Switch_Buffer
	dw	No_Value
	db	1	
	db	"/C",0        

                ; Added for /A align system sectors sivaraja 4/22/00

Switch_A_Control label byte
        dw      Numeric_Value
        dw      None
        dw      Switch_Num_Buffer
        dw      Switch_A_Value
        db      1
        db      "/A",0

;
;************************************************************************
; PARSE Value Lists
;************************************************************************
;

IF ShipDisk

Switch_Z_Value label byte

	db	1				;Range only
	db	7				;7 ranges
	db	Range_OK			;Item_Tag
	dd	1				;1 (0.5k/clus) is only value
	dd	1
	db	Range_OK			;Item_Tag
	dd	2				;2 (1k/clus) is only value
	dd	2
	db	Range_OK			;Item_Tag
	dd	4				;4 (2k/clus) is only value
	dd	4
	db	Range_OK			;Item_Tag
	dd	8				;8 (4k/clus) is only value
	dd	8
	db	Range_OK			;Item_Tag
	dd	16				;16 (8k/clus) is only value
	dd	16
	db	Range_OK			;Item_Tag
	dd	32				;32 (16k/clus) is only value
	dd	32
	db	Range_OK			;Item_Tag
	dd	64				;64 (32k/clus) is only value
	dd	64

ENDIF

Switch_T_Value label byte			;				;AN000;

	db	1				;Range only			;ANOOO;
	db	1				;1 range			;ANOOO;
	db	Range_OK			;Item_Tag			;ANOOO;
	dd	1				;1 is low bound 		;ANOOO;
	dd	1024				;2**10 is max			;AN000;

Switch_N_Value label byte			;				;AN000;

	db	1				;Range only			;ANOOO;
	db	1				;1 range			;ANOOO;
	db	Range_OK			;Item_Tag			;ANOOO;
	dd	1				;1 is low bound 		;ANOOO;
	dd	64				;2**6  is max			;AN000;

Switch_A_Value label byte

	db	1				;Range only
	db	7				;7 ranges
	db	Range_OK			;Item_Tag
        dd      2                               ;2 sector boundary
	dd	2
	db	Range_OK			;Item_Tag
        dd      4                               ;4 sector boundary
	dd	4
	db	Range_OK			;Item_Tag
        dd      8                               ;8 sector boundary
	dd	8
	db	Range_OK			;Item_Tag
        dd      16                              ;16 sector boundary
	dd	16
	db	Range_OK			;Item_Tag
        dd      32                              ;32 sector boundary
	dd	32
	db	Range_OK			;Item_Tag
        dd      64                              ;64 sector boundary
	dd	64
	db	Range_OK			;Item_Tag
        dd      128                             ;128 sector boundary
        dd      128


Switch_Size_Value	label	byte		;				;AN001;

	db	3				;Look for strings		;AN001;
	db	0				;No ranges			;AN001;
	db	0				;No numerics			;AN001;

ifdef NEC_98
	db	24	;Patern			;

	db	Size_640			;				;AN001;
	dw	String_640k_1			;/F:640 			;AN001;
	db	Size_640			;				;AN001;
	dw	String_640k_2			;/F:640K			;AN001;
	db	Size_640			;				;AN001;
	dw	String_640k_3			;/F:640KB			;AN001;
	db	Size_720			;				;AN001;
	dw	String_720k_1			;/F:720 			;AN001;
	db	Size_720			;				;AN001;
	dw	String_720k_2			;/F:720K			;AN001;
	db	Size_720			;				;AN001;
	dw	String_720k_3			;/F:720KB			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_1			;/F:1200 			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_2			;/F:1200K			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_3			;/F:1200KB			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_4			;/F:1.2 			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_5			;/F:1.2M			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_6			;/F:1.2MB			;AN001;
	db	Size_1250			;				;AN001;
	dw	String_1250k_1			;/F:1250 			;AN001;
	db	Size_1250			;				;AN001;
	dw	String_1250k_2			;/F:1250K			;AN001;
	db	Size_1250			;				;AN001;
	dw	String_1250k_3			;/F:1250KB			;AN001;
	db	Size_1250			;				;AN001;
	dw	String_1250k_4			;/F:1.25 			;AN001;
	db	Size_1250			;				;AN001;
	dw	String_1250k_5			;/F:1.25M			;AN001;
	db	Size_1250			;				;AN001;
	dw	String_1250k_6			;/F:1.25MB			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_1			;/F:1440			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_2			;/F:1440K			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_3			;/F:1440KB			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_4			;/F:1.44			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_5			;/F:1.44M			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_6			;/F:1.44MB			;AN001;
else
;	db	27				;16 possible strings		;AN001;
	db	27+8				;

	db	Size_160			;				;AN001;
	dw	String_160k_1			;/F:160 			;AN001;
	db	Size_160			;				;AN001;
	dw	String_160k_2			;/F:160K			;AN001;
	db	Size_160			;				;AN001;
	dw	String_160k_3			;/F:160KB			;AN001;
	db	Size_180			;				;AN001;
	dw	String_180k_1			;/F:180 			;AN001;
	db	Size_180			;				;AN001;
	dw	String_180k_2			;/F:180K			;AN001;
	db	Size_180			;				;AN001;
	dw	String_180k_3			;/F:180KB			;AN001;
	db	Size_320			;				;AN001;
	dw	String_320k_1			;/F:320 			;AN001;
	db	Size_320			;				;AN001;
	dw	String_320k_2			;/F:320K			;AN001;
	db	Size_320			;				;AN001;
	dw	String_320k_3			;/F:320KB			;AN001;
	db	Size_360			;				;AN001;
	dw	String_360k_1			;/F:360 			;AN001;
	db	Size_360			;				;AN001;
	dw	String_360k_2			;/F:360K			;AN001;
	db	Size_360			;				;AN001;
	dw	String_360k_3			;/F:360KB			;AN001;
	db	Size_720			;				;AN001;
	dw	String_720k_1			;/F:720 			;AN001;
	db	Size_720			;				;AN001;
	dw	String_720k_2			;/F:720K			;AN001;
	db	Size_720			;				;AN001;
	dw	String_720k_3			;/F:720KB			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_1			;/F:1200			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_2			;/F:1200K			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_3			;/F:1200KB			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_4			;/F:1.2 			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_5			;/F:1.2M			;AN001;
	db	Size_1200			;				;AN001;
	dw	String_1200k_6			;/F:1.2MB			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_1			;/F:1440			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_2			;/F:1440K			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_3			;/F:1440KB			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_4			;/F:1.44			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_5			;/F:1.44M			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_6			;/F:1.44MB			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_5			;/F:1.44M			;AN001;
	db	Size_1440			;				;AN001;
	dw	String_1440k_6			;/F:1.44MB			;AN001;
	
	db	Size_2880			;				;AN001;
	dw	String_2880k_1			;/F:2880			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_2			;/F:2880K			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_3			;/F:2880KB			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_4			;/F:2.88			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_5			;/F:2.88M			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_6			;/F:2.88MB			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_5			;/F:2.88M			;AN001;
	db	Size_2880			;				;AN001;
	dw	String_2880k_6			;/F:2.88MB			;AN001;
endif

No_Value	label	byte			;				;AN000;
	db	0				;				;AN000;

;
;*****************************************************************************
; Data Area for value lists
;*****************************************************************************
;

;
;The following are a list of the allowed strings for the /F:xxxxx switch.
;

ifdef NEC_98

String_640k_1	db	"640"  ,Asciiz_End      ;                               ;AN001;
String_640k_2	db	"640K" ,Asciiz_End      ;                               ;AN001;
String_640k_3	db	"640KB" ,Asciiz_End      ;                               ;AN001;

String_1250k_1	db	"1250" ,Asciiz_End      ;                               ;AN001;
String_1250k_2	db	"1250K",Asciiz_End      ;                               ;AN001;
String_1250k_3	db	"1250KB",Asciiz_End      ;                               ;AN001;
String_1250k_4	db	"1.25" ,Asciiz_End      ;                               ;AN001;
String_1250k_5	db	"1.25M" ,Asciiz_End      ;                               ;AN001;
String_1250k_6	db	"1.25MB" ,Asciiz_End      ;                               ;AN001;
String_128m_1	db	"128" ,Asciiz_End      ;
String_128m_2	db	"128M" ,Asciiz_End      ;
String_128m_3	db	"128MB" ,Asciiz_End      ;
String_230m_1	db	"230" ,Asciiz_End      ;
String_230m_2	db	"230M" ,Asciiz_End      ;
String_230m_3	db	"230MB" ,Asciiz_End      ;
String_650m_1	db	"650" ,Asciiz_End      ;
String_650m_2	db	"650M" ,Asciiz_End      ;
String_650m_3	db	"650MB" ,Asciiz_End      ;
else
String_160k_1	db	"160"  ,Asciiz_End      ;                               ;AN001;
String_160k_2	db	"160K" ,Asciiz_End      ;                               ;AN001;
String_160k_3	db	"160KB" ,Asciiz_End      ;                               ;AN001;

String_180k_1	db	"180"  ,Asciiz_End      ;                               ;AN001;
String_180k_2	db	"180K" ,Asciiz_End      ;                               ;AN001;
String_180k_3	db	"180KB" ,Asciiz_End      ;                               ;AN001;

String_320k_1	db	"320"  ,Asciiz_End      ;                               ;AN001;
String_320k_2	db	"320K" ,Asciiz_End      ;                               ;AN001;
String_320k_3	db	"320KB" ,Asciiz_End      ;                               ;AN001;
String_360k_1	db	"360"  ,Asciiz_End      ;                               ;AN001;

String_360k_2	db	"360K" ,Asciiz_End      ;                               ;AN001;
String_360k_3	db	"360KB" ,Asciiz_End      ;                               ;AN001;
endif
String_720k_1	db	"720"  ,Asciiz_End      ;                               ;AN001;
String_720k_2	db	"720K" ,Asciiz_End      ;                               ;AN001;
String_720k_3	db	"720KB" ,Asciiz_End      ;                               ;AN001;

String_1200k_1	db	"1200" ,Asciiz_End      ;                               ;AN001;
String_1200k_2	db	"1200K",Asciiz_End      ;                               ;AN001;
String_1200k_3	db	"1200KB",Asciiz_End      ;                               ;AN001;
String_1200k_4	db	"1.2" ,Asciiz_End      ;                               ;AN001;
String_1200k_5	db	"1.2M" ,Asciiz_End      ;                               ;AN001;
String_1200k_6	db	"1.2MB" ,Asciiz_End      ;                               ;AN001;

String_1440k_1	db	"1440" ,Asciiz_End      ;                               ;AN001;
String_1440k_2	db	"1440K",Asciiz_End      ;                               ;AN001;
String_1440k_3	db	"1440KB",Asciiz_End      ;                               ;AN001;
String_1440k_4	db	"1.44",Asciiz_End      ;                               ;AN001;
String_1440k_5	db	"1.44M",Asciiz_End      ;                               ;AN001;
String_1440k_6	db	"1.44MB",Asciiz_End      ;                               ;AN001;

ifndef NEC_98
String_2880k_1	db	"2880" ,Asciiz_End      ;                               ;AN001;
String_2880k_2	db	"2880K",Asciiz_End      ;                               ;AN001;
String_2880k_3	db	"2880KB",Asciiz_End      ;                               ;AN001;
String_2880k_4	db	"2.88",Asciiz_End      ;                               ;AN001;
String_2880k_5	db	"2.88M",Asciiz_End      ;                               ;AN001;
String_2880k_6	db	"2.88MB",Asciiz_End      ;                               ;AN001;
endif

;
;************************************************************************
; PARSE Return Buffers
;************************************************************************
;

Drive_Letter_Buffer	Drive_Letter_Return	<> ;Example of structure	;AN000;
Switch_Buffer		Switch_Return		<> ;				;AN000;
Switch_Num_Buffer	Switch_Num_Return	<> ;				;AN000;
Switch_String_Buffer	Switch_String_Return	<> ;				;AN000;

data	ends

;
;*****************************************************************************
; SysParse Routines
;*****************************************************************************
;


code	segment public	para 'CODE'
	assume cs:code,ds:Data

FarSW	equ	Not_Include							;AN000;
DateSW	equ	Not_Include			;				;AN000;
TimeSW	equ	Not_Include			;				;AN000;
FileSW	equ	Do_Include			;				;AN000;
CAPSW	equ	Do_Include			;				;AN000;
CmpxSW	equ	Not_Include			;				;AN000;
NumSW	equ	Do_Include			;				;AN000;
KeySW	equ	Not_Include			;				;AN000;
SwSW	equ	Do_Include			;				;AN000;
Val1SW	equ	DO_Include			;				;AN000;
Val2SW	equ	Not_Include			;				;AN000;
Val3SW	equ	Do_Include			;				;AN001;
DrvSW	equ	Do_Include			;				;AN000;
QusSW	equ	Do_Include			;				;AN000;

include dosequs.inc
INCLUDE PARSE.ASM				;				;AN000;


code	ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\glblinit.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;===========================================================================
; 
; FILE: GLBLINIT.ASM
;
;===========================================================================

;===========================================================================
;Declaration of include files
;===========================================================================

;
;---------------------------------------------------------------------------
;
; M024 : B#5495. Added "Insufficient memory" message when FORMAT cannot
;		allocate memory for FAT, Directory... etc 
;
;---------------------------------------------------------------------------
;
debug	 equ	 0

        .xlist

	INCLUDE		BPB.INC
	INCLUDE		DOSEQUS.INC
	INCLUDE		DOSMAC.INC
	INCLUDE		SYSCALL.INC
	INCLUDE		FOREQU.INC	
	INCLUDE		FORMACRO.INC
	INCLUDE		IOCTL.INC
	INCLUDE		FORSWTCH.INC
	INCLUDE		SAFEDEF.INC
	INCLUDE		SYSVAR.INC
	.list


;===========================================================================
; Data segment
;===========================================================================

DATA    SEGMENT PUBLIC PARA 'DATA'

SECTORS_FOR_MIRROR	EQU	7		; # extra buffer sectors
						; required by Mirror utility,
						; apart from FAT & Root Dir

;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;Bytes
	EXTRN	msgCrLF 		  :BYTE
	EXTRN	DriveToFormat		  :BYTE
	EXTRN	ClustBound_Flag		  :BYTE
	EXTRN	FileStat		  :BYTE
	EXTRN	SystemDriveLetter	  :BYTE
	EXTRN	SecPerClus		  :BYTE
	EXTRN	CMCDDFlag		  :BYTE

;Words
	EXTRN	SwitchMap		  :WORD
	EXTRN 	mSize			  :WORD
	EXTRN	mStart			  :WORD
	EXTRN	ClustBound_Buffer_Seg	  :WORD
	EXTRN	Paras_per_fat		  :WORD

;Pointers and DWORDs
	EXTRN	DirectorySector		  :DWORD
	EXTRN	FatSpace	  	  :DWORD
	EXTRN	FatSector		  :DWORD
	EXTRN	DirBuf			  :DWORD
	EXTRN	TotalClusters		  :DWORD

;Messages
	EXTRN	msgFormatNotSupported	  :BYTE
	EXTRN	msgCantZThisDrive	  :BYTE
	EXTRN	msgCantZWithQ		  :BYTE
	EXTRN	msgCantZFAT16		  :BYTE
	EXTRN	msgCantZFAT32		  :BYTE
	EXTRN	msgZFAT32Huge		  :BYTE
	EXTRN	msgZFAT32TooHuge	  :BYTE
	EXTRN	msgOutOfMemory		  :BYTE
	EXTRN	msgInsufficientMemory     :BYTE
IFNDEF OPKBLD
        EXTRN   msgNoSysSwitch            :BYTE
ENDIF   ;OPKBLD

;Structures
	EXTRN	SavedParams		  :BYTE
	EXTRN	DeviceParameters	  :BYTE
	EXTRN	IsExtRAWIODrv		  :BYTE
	EXTRN	Bios			  :BYTE
	EXTRN	dos			  :BYTE
	EXTRN	Command 		  :BYTE
IFDEF DBLSPACE_HOOKS
	EXTRN	DblSpaceBin		  :BYTE
ENDIF

	PUBLIC	FATNotAllInMem
	PUBLIC	FATSecCntInMem

FATNotAllInMem	db	0
FATSecCntInMem	dd	0

ifdef NEC_98
AllocSectorSize		DW	?		; fixed #16585
endif
DATA	ENDS

;===========================================================================
; Executable code segment
;===========================================================================

CODE	SEGMENT PUBLIC PARA	'CODE'
	ASSUME	CS:CODE, DS:DATA, ES:DATA


;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;Functions

;Labels
	EXTRN	FatalExit		  :NEAR
	EXTRN	ReadDos			  :NEAR
	EXTRN	SysPrm			  :NEAR
	EXTRN	exclusive_access_failed	  :NEAR
	EXTRN	IsLockErr?		  :NEAR
	EXTRN	Calc_Big32_Fat		  :NEAR
	EXTRN	Calc_Big16_Fat		  :NEAR
	EXTRN	GetTotalClusters	  :NEAR
	EXTRN	Yes?			  :NEAR

;===========================================================================
; Declarations for all publics in this module
;===========================================================================

	PUBLIC	Global_Init
	PUBLIC	GetDeviceParameters
	PUBLIC	ModifyDevPrmsForZSwich

; for debug

	PUBLIC	Copy_Device_Parameters
	PUBLIC	Alloc_Dir_Buf
	PUBLIC	Alloc_Fat_Buf
	PUBLIC	Alloc_Fat_Sec_Buf
	PUBLIC	Alloc_DirBuf2
	PUBLIC	Alloc_Cluster_Buf
IFDEF OPKBLD
	PUBLIC	Do_Switch_S
ENDIF   ;OPKBLD


;===========================================================================
;
;  Global_Init  :	This procedure first gets the default drive parameters.
;			It then allocates buffer space for the root directory
;			sector, FAT,a fat sector, a file header and first
;			root DIR sector based on these parameters.  It
;			then checks for the /s switch and if this is present,
;			a buffer is allocated for the system files and these
;			are read into memory.  A prompt to insert the system
;			disk will be given in the case of removable media.
;
;===========================================================================

Global_Init	proc	near

	lea	DX, DeviceParameters	; Get the default drive parameters
	mov	DeviceParameters.DP_SpecialFunctions, 0
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS
	call	GetDeviceParameters
	
	jnc	GotDeviceParameters
	call	IsLockErr?
	jnc	@f
	jmp	exclusive_access_failed
@@:
	Message msgFormatNotSupported
	stc 				; Let the jump to FatalExit be made
	ret				;  in the main routine, upon returning

GotDeviceParameters:			
ifdef NEC_98	; fixed #16585
	cmp	DeviceParameters.DP_DeviceType,DEV_HARDDISK
	je	@f
	cmp	DeviceParameters.DP_DeviceType,DEV_OPTICAL
	je	@f
	mov	AllocSectorSize,0400h
	jmp	short	Set_ok
@@:
	push	bx
	mov	bx, DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	mov	AllocSectorSize,bx
	pop	bx
Set_ok:
endif		; fixed #16585
	call	Copy_Device_Parameters	; Save the device parameters
					; for when we exit
	cmp	SecPerClus,0
	je	NoZSwtch
	mov	ax,1			; Noisy version
	call	ModifyDevPrmsForZSwich
	jc	gi_err
NoZSwtch:
ifdef NEC_98
	; If 3.5"MO, allcate memory after updating default BPB
	cmp	DeviceParameters.DP_DeviceType, DEV_HARDDISK	; Hard disk?
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	@F						; No

	test	DeviceParameters.DP_DeviceAttributes, 1		; Removable?
    .errnz EDP_DEVICEATTRIBUTES NE DP_DEVICEATTRIBUTES
	jz	$$IF100						; Yes
@@:
endif
	call	Alloc_Dir_Buf		; Allocate root directory buffer
	jc	gi_memerr

	call	Alloc_Fat_Buf		; Allocate FAT buffer
	jc	gi_memerr

	call	Alloc_Fat_Sec_Buf	; Allocate fat sector buffer
	jc	gi_memerr

	call	Alloc_DirBuf2		; Allocate 1-sector buffer DirBuf (general-
					; purpose use)
	jc	gi_memerr

	call	Alloc_Cluster_Buf	; get room for retry buffer

IFDEF OPKBLD
	call	Do_Switch_S		; Load system files if needed
ELSE
	test	SwitchMap,SWITCH_S
        jz      NoS1                    ; Carry clear if jump
	Message msgNoSysSwitch
        jmp     short gi_err

NoS1:
ENDIF   ;OPKBLD
					; carry flag determined by Do_Switch_S
ifdef NEC_98
$$IF100:
endif
	ret

gi_memerr:
	Message msgInsufficientMemory
gi_err:
	stc
	ret

Global_Init	endp

; =========================================================================
;
;   ModifyDevPrmsForZSwich:
;	Modify the device parameters for a different sec/clus value
;
;   Input:
;	DeviceParameters set
;	AX != 0 for noisy version (do the message thing)
;   Output:
;	carry set if problem.
;
; =========================================================================

ModifyDevPrmsForZSwich proc near

	push	ax			; Save noisy switch on stack
.386
	movzx	cx,SecPerClus
.8086
	or	cx,cx
	jz	MFZDoneJ		; Carry clear if jump
	cmp	CMCDDFlag, Yes
	jne	DrvOk1
DispErrMsg:
	mov	dx,offset data:msgCantZThisDrive
DispErrMsgSet:
	pop	ax
	push	ax
	or	ax,ax
	jz	MFZDoneErrJ
	call	Display_Interface
MFZDoneErrJ:
	stc
MFZDoneJ:
	jmp	MFZDone

DrvOk1:
;;
;; This used to ignore things if you weren't actually making a change.
;; This is now out as it is important to poke Mr. User if he is making
;; a huge FAT drive.
;;
;;	cmp	cl,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
;;	je	MFZDoneJ		; Carry clear if jump
;;;;
	mov	dx,offset data:msgCantZWithQ
	test	SwitchMap,SWITCH_Q	; Check for quick format
	jnz	DispErrMsgSet
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster,cl
	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFAT,0
	je	IsFAT32
	call	Calc_Big16_Fat
	mov	dx,0002h
	xor	ax,ax			; DX:AX = 128k bytes
	mov	cx,DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	div	cx			; AX = Sectors in 128k
	cmp	ax,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFAT
	jb	Bad16
.386
	ja	MFZDone 		; Carry clear if jump
.8086
	call	GetTotalClusters
.386
	cmp	TotalClusters,0000FFF0h
.8086
	cmc				; Change "JB Is-OK" to "JNC Is-OK"
	jnc	MFZDone
Bad16:
	mov	dx,offset data:msgCantZFAT16
	jmp	short DispErrMsgSet

IsFAT32:
	call	Calc_Big32_Fat
	call	GetTotalClusters
.386
	cmp	TotalClusters,65536-10
.8086
	mov	dx,offset data:msgCantZFAT32
	jb	DispErrMsgSet
.386
	mov	eax,TotalClusters
	inc	eax			; EAX now count including clus 0 and 1
    ;
    ; GUI SCANDISK is a 16-bit windows app. GlobalAlloc in 16-bit windows is
    ;	limited to 16Meg-64k per block. Check if we have made a drive with a huge FAT
    ;   that may result in slow disk util perf.
    ;
	cmp	eax, ((16 * 1024 * 1024) - (64 * 1024)) / 4
        je      short MFZDone           ; carry clear if jump
        cmc                             ; Turn carry around so clear if below limit
        jnc     short MFZDone
.8086
	pop	ax
	push	ax
	or	ax,ax                   ; Noisy?
	jz	MFZDone 		; No, Carry clear if jump
	Message msgZFAT32Huge
	call	Yes?			; Carry clear if YES, set if NO
	pushf
	Message	msgCrlf
	popf
MFZDone:
	pop	ax
	ret

ModifyDevPrmsForZSwich endp

; =========================================================================
;
;   GetDeviceParameters:
;	Get the	device parameters
;
;   Input:
;	DriveToFormat
;	DX - pointer to	device parameters
; =========================================================================

GetDeviceParameters proc near

	mov	AX, (IOCTL shl 8) or GENERIC_IOCTL
	mov	bl, DriveToFormat
	inc	bl
	mov	CX, (EXTRAWIO shl 8) or GET_DEVICE_PARAMETERS
	int	21H
	jc	TryOldForm
	mov	IsExtRAWIODrv,1
DoRet:
	jc	realdoret
	push	bx
	mov	bx,dx
	cmp	[bx.DP_BPB.oldBPB.BPB_TotalSectors],0
	je	realdoretP
    ;
    ; the WORD total sectors field is non-zero, make sure the DWORD
    ;	total sectors field is 0. Having BigTotalSectors be a DWORD
    ;	version of TotalSectors in this case is SUPPOSED to be perfectly
    ;	ok but it turns out that several apps (mostly SETUP apps) get
    ;	upset about this (on floppies in particular).
    ;
	mov	[bx.DP_BPB.oldBPB.BPB_BigTotalSectors],0
	mov	[bx.DP_BPB.oldBPB.BPB_BigTotalSectors+2],0
realdoretP:
	pop	bx
	clc
realdoret:
	return

TryOldForm:
	mov	IsExtRAWIODrv,0
	mov	AX, (IOCTL shl 8) or GENERIC_IOCTL
	mov	bl, DriveToFormat
	inc	bl
	mov	CX, (RAWIO shl 8) or GET_DEVICE_PARAMETERS
	int	21H
	jmp	short DoRet

GetDeviceParameters endp

;==========================================================================
;
; Copy_Device_Parameters :	This procedure saves a copy of the original
;				device parameters in the structure 
;				SavedParams.
;
;==========================================================================

Copy_Device_Parameters	proc	near
					
	lea	SI, DeviceParameters	
	lea	DI, SavedParams
	mov	CX, size EA_DeviceParameters
	push	DS
	pop	ES
	rep	movsb
	ret

Copy_Device_Parameters	endp


;==========================================================================
;
;  Alloc_Dir_Buf  :  This procedure allocates a memory block for the root 
;		     directory buffer, based on the device parameters only.
;
;  Inputs	  :  DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
;  Outputs	  :  CY CLEAR - DirectorySector pointer to buffer
;		     CY SET   - failure
;  Modifies	  :  AX, BX, DirectorySector
;
;==========================================================================

Alloc_Dir_Buf	proc	near
					; DirectorySector =
				 	; malloc( Bytes Per Sector )
ifdef	NEC_98	; fixed #16585
	mov	BX, AllocSectorSize
else
	mov	BX, DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
endif
    .errnz EDP_BPB NE DP_BPB
	add	BX, 0fH
.386
	shr	bx, 4			; Divide by 16 to get #paragraphs
.8086
	mov	AH, Alloc
	int	21h
	jc      Exit_Alloc_Dir_Buf
					; Base address of newly allocated
					; block is AX:0000
	mov	WORD PTR DirectorySector+2,AX
	xor	AX,AX
	mov	WORD PTR DirectorySector,AX

Exit_Alloc_Dir_Buf:
	ret

Alloc_Dir_Buf	endp

;==========================================================================
;
;  Alloc_Fat_Buf  :  This procedure allocates a memory block for the FAT
;		     buffer, based on the device parameters only.  In order
;		     to ensure there is enough buffer space for the Mirror
;	  	     utility, the FatSpace buffer is initially allocated
;		     with size:
;			FAT + RootDir + 6 sectors + 1 surplus sector
;		     which is all the buffer space required by Mirror.
;
;  Inputs	  :  DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
;		     DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
;		     DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
;		     DeviceParameters.DP_BPB.oldBPB.BPB_RootEntries
;
;  Outputs	  :  CY CLEAR - FatSpace pointer to buffer
;		     CY SET   - failure
;
;  Modifies	  :  AX, BX, DX, FatSpace
;
;==========================================================================

Alloc_Fat_Buf	proc	near

	xor	ax,ax
	mov	FATNotAllInMem,al	; Assume FAT will fit in mem
.386
ifdef	NEC_98	; fixed #16585
	cmp	DeviceParameters.DP_DeviceType, DEV_3INCH1440KB
	jne	short $$IF101
	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors, 0
	je	short $$IF101
	movzx	EAX, AllocSectorSize
	jmp	short $$EN101
$$IF101:
	movzx	EAX, DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
$$EN101:
else
	movzx	EAX, DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
endif
    .errnz EDP_BPB NE DP_BPB
	add	EAX, 0fH		; round up for next para
	shr	eax, 4			; convert to paras
	movzx	ebx,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
	or	bx,bx
	jnz	short GotFSz
	mov	ebx,dword ptr DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
GotFSz:
	mul	ebx
	or	edx,edx
	jz	short NotHi
GotBigFat:
	mov	FATNotAllInMem,1
	mov	eax,128*1024
	movzx	ebx,DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	xor	edx,edx
	div	ebx
	mov	FATSecCntInMem,eax
	mov	ax,(128*1024)/16
	jmp	short SetRestFatBuf

NotHi:
	cmp	eax,(128*1024)/16	; FAT bigger than 128k?
	ja	short GotBigFat 	; Yes
SetRestFatBuf:
.8086
	mov	BX,AX			; Save FAT size in paras in BX
	mov	Paras_per_fat,BX	; Set paras_per_fat here, to 
					;  avoid having to calculate it later
					; Now add on root dir + extra sectors
	mov	AX,DeviceParameters.DP_BPB.oldBPB.BPB_RootEntries
    ;;	shl	ax,5			; * 32 bytes per dor entry
    ;;	shr	ax,4			; / 16 bytes per para
    ;; Combine above two shifts....
	shl	AX,1			; AX = para size of root dir

	add	BX,AX			; BX = FAT + root dir

ifdef	NEC_98	; fixed #16585
	cmp	DeviceParameters.DP_DeviceType, DEV_3INCH1440KB
	jne	$$IF102
	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors, 0
	je	$$IF102
	mov	AX, AllocSectorSize
	jmp	short $$EN102
$$IF102:
	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
$$EN102:
else
	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
endif
	add	AX, 0fH			; round up for next para
.386
	shr	AX, 4			; convert to paras
.8086
	mov	CX,SECTORS_FOR_MIRROR	; CX = # additional sectors needed by Mirror
	mul	CX			; AX = total extra sector size in paras

	add	BX,AX			; BX = FAT + root dir + extra sectors
					;  in paras
	mov	AH,Alloc
	int	21h
	jc      Exit_Alloc_Fat_Buf

	mov	WORD PTR FatSpace+2,AX
	xor	AX,AX
	mov	WORD PTR FatSpace,AX

Exit_Alloc_Fat_Buf:
	ret

Alloc_Fat_Buf	endp

;==========================================================================
;
;  Alloc_Fat_Sec_Buf : This procedure allocates a memory block for the fat 
;		       sector buffer which is used when copying chains from
;		       the old FAT to the new FAT.
;
;  Inputs	  :  DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
;  Outputs	  :  CY CLEAR - FatSector pointer to buffer
;		     CY SET   - failure
;  Modifies	  :  AX, BX, FatSector
;
;==========================================================================

Alloc_Fat_Sec_Buf	proc	near
					; FatSector =
				 	; malloc( Bytes Per Sector )
ifdef	NEC_98	; fixed #16585
	mov	BX, AllocSectorSize
else
	mov	BX, DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
endif
    .errnz EDP_BPB NE DP_BPB
	add	BX, 0fH
.386
	shr	BX, 4			; Divide by 16 to get #paragraphs
.8086
	mov	AH, Alloc
	int	21h
	jc      Exit_Alloc_Fat_Sec_Buf
					; Base address of newly allocated
					; block is AX:0000
	mov	WORD PTR FatSector+2,AX
	xor	AX,AX
	mov	WORD PTR FatSector,AX

Exit_Alloc_Fat_Sec_Buf:
	ret

Alloc_Fat_Sec_Buf	endp

;==========================================================================
;
;  Alloc_DirBuf2  :  This procedure allocates a memory block for a 1-sector
;		     buffer.  This buffer is used when reading in the boot
;		     sector in Phase1.
;
;  Inputs	  :  DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
;  Outputs	  :  CY CLEAR - DirBuf pointer to buffer
;		     CY SET   - failure
;  Modifies	  :  AX, BX, DirBuf
;
;==========================================================================

Alloc_DirBuf2	proc	near
					; DirBuf =
				 	; malloc( Bytes Per Sector )
ifdef	NEC_98	; fixed #16585
	mov	BX, AllocSectorSize
else
	mov	BX, DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
endif
    .errnz EDP_BPB NE DP_BPB
	add	BX, 0fH
.386
	shr	BX, 4			; Divide by 16 to get #paragraphs
.8086
	mov	AH, Alloc
	int	21h
	jc      Exit_Alloc_DirBuf2
					; Base address of newly allocated
					; block is AX:0000
	mov	WORD PTR DirBuf+2,AX
	xor	AX,AX
	mov	WORD PTR DirBuf,AX

Exit_Alloc_DirBuf2:
	ret

Alloc_DirBuf2	endp

;=========================================================================
; Alloc_Cluster_Buf	         : This	routine	will allocate a	buffer
;				   based on a cluster's	size.  If enough
;				   space does not exist, a cluster will
;				   be redefined	to a smaller size for
;				   purposes of sector retries.
;				   Note: This buffer is used only for bad
;				   tracks on hard disks.
;
;	 Inputs  : DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
;		   DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
;
;	 Outputs : ClustBound_Flag	 - True	(space available)
;					   False(not enough space)
;		   ClustBound_Buffer_Seg - Pointer to buffer
;=========================================================================

Procedure Alloc_Cluster_Buf

	push	AX				; Save regs
	push	BX

	mov	AX,(Alloc shl 8)		; Allocate memory
	mov	BX,0ffffh			; Get available memory
	int	21h

ifdef	NEC_98	; fixed #16585
	mov	AX, AllocSectorSize
else
	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
endif
    .errnz EDP_BPB NE DP_BPB
	add	AX, 0fH
.386
	shr	AX, 4
.8086
	mul	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster

	cmp	BX,AX				; Enough room
	jna	$$IF137 			; Yes

	mov	BX,AX				; Allocate needed memory
	mov	AX,(Alloc shl 8)
	int	21h
	mov	ClustBound_Buffer_Seg,AX	; Save pointer to buffer
	mov	ClustBound_Flag,True		; Signal space available
	jmp	SHORT $$EN137			; Not enough room

$$IF137:
	mov	ClustBound_Flag,False		; Signal not enough space

$$EN137:
	pop	BX				; Restore regs
	pop	AX

	ret

Alloc_Cluster_Buf ENDP

IFDEF OPKBLD

;=========================================================================
;
;  DO_SWITCH_S  :	This procedure will load the system files into
;			memory (if there's space) if the /s switch is
;			specified.
;
;  CALLS  :		ReadDos
;			SysPrm
;  CALLED BY :		Global_Init
;  STRATEGY :		The largest block of memory available is first
;			determined.  The program is aborted if this is zero.
;			This block is then allocated, and the system files
;			are read into it.  A prompt for the system disk
;			will be given if the system files are not found.
;
;=========================================================================

Do_Switch_S	proc	near

	test	SwitchMap,SWITCH_S
.386
	jz	End_Do_Switch_S 	; System files not required
					; allocate memory for system files
.8086
	mov	BX,0ffffh		; This call will actually fail
	mov	AH,Alloc		; so that BX returns max block avlbl
	int	21h

	or	BX,BX
	jz	MemErr			; No memory
	mov	[mSize],BX		; Now allocate the largest block
	mov	AH,alloc
	int	21h
	jnc	Mem_OK

MemErr:
	mov	AX, seg data		; Check for memory allocation error
	mov	DS, AX
	Message msgOutOfMemory		; call PrintString
	stc 				; Let the jump to FatalExit be made
	jmp	End_Do_Switch_S 	;  in the main routine, upon returning

Mem_OK:
	mov	[mStart],AX		; Save the starting paragraph

; =========================================================================
; This call to ReadDos may not be able to read in all of the DOS files if
; there is insufficient memory available. In that case the files will
; be read in after the disk is formatted. If the Drive being formatted is
; also the boot Drive this function will read the files from that
; Drive if there is enough memory. If there is insufficent memory it will
; force the files to be read from Drive A: if the Drive being formatted
; is also the boot Drive
; M011; Wrong: Try Boot, Then Default, Then sysprm (usually "A").
;       If not enough memory at boot time, we fail.
; =========================================================================

RdFrst:
	mov	AH,GET_DEFAULT_Drive		; Find out default Drive
	int	21h
	push	AX				; save default Drive
	mov	ax, 3305h			; get startup drive
	int	21h
	mov	al,dl
	add	AL,40h				; Make it ASCII
	pop	BX				; restore default Drive
ifndef NEC_98
	cmp	AL,41h				; Q: Booted from Drive A?
	jnz	go_get_Bios			;  N: Not a special case
	cmp	bl,1				; Q: is	B: current Drive
	jnz	go_get_Bios			;  N: Not a special case
	jmp	short check_default		; check	default	Drive
endif

go_get_Bios:					; Here to check booted
	call	Get_Host_Drive			; Translate to DblSpace host
	mov	SystemDriveLetter,AL		;   (if necessary)

	call	ReadDos
	jnc	CheckAllFilesIn

check_default:					; Here to check default
	mov	AH,GET_DEFAULT_Drive		; Find out default Drive
	int	21h
	add	AL,41h				; Make it ASCII, 1 based
	call	Get_Host_Drive			; Translate to DblSpace host
	mov	SystemDriveLetter,AL

TryThisOne:
	call	ReadDos				; Read BIOS and	DOS
	jnc	CheckAllFilesIn			; Files read in OK
NeedSys:
	call	SysPrm				; Prompt for system disk
	jmp	TryThisOne			; Try again

CheckAllFilesIn:
				; abort program here if all system files
				; have not been read into memory, since
				; program fails when trying to read them
				; in after formatting is complete
	and	FileStat,3fh			; zero out 2 msb
	cmp	FileStat,22h			; BIOS and COMMAND in memory?
	jne	MemErr				; no - abort program
    ;
    ; Now we have all of the files in memory, SETBLOCK the allocation
    ;	block down to the amount required.
    ;
.386
	mov	bx,[dos.fileStartSegment]
	mov	eax,[dos.fileSizeInBytes]
	cmp	bx,[bios.fileStartSegment]
	ja	short Skip1
	mov	bx,[bios.fileStartSegment]
	mov	eax,[bios.fileSizeInBytes]
Skip1:
	cmp	bx,[command.fileStartSegment]
	ja	short Skip2
	mov	bx,[command.fileStartSegment]
	mov	eax,[command.fileSizeInBytes]
Skip2:
IFDEF DBLSPACE_HOOKS
	cmp	bx,[DblSpaceBin.fileStartSegment]
	ja	short Skip3
	mov	bx,[DblSpaceBin.fileStartSegment]
	mov	eax,[DblSpaceBin.fileSizeInBytes]
Skip3:
ENDIF
	add	eax,15
	shr	eax,4				; AX = # of paras from SEG BX
.8086
	add	bx,ax				; SEG after end of sys files
	sub	bx,[mStart]			; SIZE of sys area
	mov	es,[mStart]
	mov	AH,setblock
	int	21h
	clc					; yes
End_Do_Switch_S:
	ret

Do_Switch_S	ENDP


;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Get_Host_Drive
;*******************************************************************************
;
;Description: Given a drive letter in AL, check to see if it is a dblspace
;	      drive, and if so, translate the drive letter to the host
;	      drive letter.
;
;Called Procedures: None
;
;Input: ASCII drive letter in AL
;
;Output: drive letter in AL
;
;Change History: Created			11/21/92	 MD
;		 Cut and paste from SYS command 12/07/92	 JEM
;
;******************* END OF SPECIFICATIONS *************************************

public Get_Host_Drive

Get_Host_Drive PROC NEAR

        push    ax
   	mov	ax,4a11h	; DBLSPACE multiplex number
	xor	bx,bx		; inquire version number
	int	2fh
	or	ax,ax		; error?
	jnz	not_dblspace
	cmp	bx,'DM'		; stamp returned correctly?
	jnz	not_dblspace

;	DBLSPACE.BIN is loaded.  At this time:
;
;	(dx & 0x7fff) == driver internal version number
;	high bit of DH set of driver has not yet been permanently placed
;	cl == first disk letter reserved for DBLSPACE
;	ch == number of disk letters reserved for DBLSPACE

	mov	ax,4a11h	; DBLSPACE multiplex number
	mov	bx,1		; inquire drive map
        pop     dx
	push	dx
	sub	dl, 'A' 	; convert drv letter to 0 based drv number
	int	2fh
	test	bl,80h		; COMPRESSED bit true?
	jz	not_dblspace

;	Drive is compressed.  At this time:
;
;	(bl & 0x7f) == host drive's CURRENT drive number
;	bh          == CVF extension number
;
        mov     al,bl
	and	al,7Fh
	add	al, 'A' 	; convert drv number to drv letter
        cbw
        pop     dx
        push    ax

not_dblspace:
        pop     ax
        ret

Get_Host_Drive	ENDP

ENDIF   ;OPKBLD

CODE	ENDS

	END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\msfor.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
; e forproc.sal= @(#)ibmfor.asm 1.28 85/10/15
	name	OemFormatRoutines
;
;******************************************************************************
;AN001 - ???
;AN002 - D304 Modify Boot record structure for OS2		  11/09/87 J.K.
;******************************************************************************

INCLUDE FORCHNG.INC
debug	equ	0


data	segment public para 'DATA'

ifdef NEC_98
	public	IPL_FD
	public	IPL_HD
else
	public	boot2
	public	onesecboot
endif
	public	twosecboot

	public	scratchBuffer
	public	scratchBufferSize

	public	oldDrive
	public	oldVolumeId
	public	Read_Write_Relative
	public	Serial_Num_Low
	public	Serial_Num_High
	public	SizeMap

	public	ptr_msgWhatIsVolumeId?

	public	trackReadWritePacket

data	ends

; ============================================================================

code	segment public para 'CODE'
	assume	cs:code,ds:data

; ============================================================================

; Public for debugging only

	public	WriteBootSector
	public	WriteBogusDos
ifndef NEC_98
	public	ConvertToOldDirectoryFormat
	public	SetPartitionTable
	public	ReadSector
	public	WriteSector
	public	SectorIO
endif
	public	GetVolumeId

	public	EndSwitchCheck
	public	GetBPBs
	public	CalcTotal
	public	WeCanNotIgnoreThisError
ifdef NEC_98
	public	BogusDos
else
	public	HardDisk?
	public	BogusDos
	public	sys_mess_loop
	public	end_sys_loop
	public	DirectoryRead
	public	wrtdir
	public	DirectoryWritten
endif
	public	FCBforVolumeIdSearch
	public	CopyVolumeId
	public	CheckSwitch8B

; ============================================================================

	public	AccessDisk
	public	CheckSwitches
	public	LastChanceToSaveIt
	public	OemDone
	public	BiosFile
        public  AltBiosFile
        public  AltBiosLen
        public  MsdosFile
        public  MsdosRemark
        public  MsdosRemarkLen

data	segment public	para	'DATA'
	extrn	AddToSystemSize:near
	extrn	currentCylinder:word
	extrn	currentHead:word
	extrn	deviceParameters:byte
	extrn	IsExtRAWIODrv:byte
	extrn	DriveToFormat:byte
	extrn	driveLetter:byte
	extrn	fBigFAT:byte
	extrn	fBig32FAT:byte
ifndef NEC_98
	extrn	inbuff:byte
endif
	extrn	switchmap:word
	extrn	Old_Dir:byte
	extrn	fLastChance:byte
	extrn	Fatal_Error:byte
	extrn	Bios:byte
        extrn   Dos:byte
ifndef NEC_98
	extrn	Command:byte
endif
	extrn	CustomCPMBPBs:byte
	extrn	EndStandardBPBs:byte
	extrn	CPMSwitchTable:byte
	extrn	BPB720:byte
ifdef NEC_98
        extrn   BPB128:byte
        extrn   BPB230:byte
        extrn   BPB650:byte

        extrn   BPB640:byte
        extrn   BPB12:byte
        extrn   BPB1250:byte
	extrn	switchmap2:word
	extrn	UnformattedHardDrive:byte
endif

	extrn	msgBad_T_N:byte
ifndef NEC_98
	extrn	msgBadVolumeId:byte
	extrn	msgBadPartitionTable:byte
endif
	extrn	msgBootWriteError:byte
	extrn	msgFormatFailure:byte
	extrn	msgDirectoryReadError:byte
	extrn	msgDirectoryWriteError:byte
	extrn	msgIncompatibleParameters:byte
	extrn	msgIncompatibleParametersForHardDisk:byte
	extrn	msgParametersNotSupportedByDrive:byte
ifndef NEC_98
	extrn	msgPartitionTableReadError:byte
	extrn	msgPartitionTableWriteError:byte
endif
	extrn	msgWhatIsVolumeId?:byte
	extrn   msgBad_8_V:byte
	extrn	Extended_Error_Msg:byte

	extrn	NumSectors:word, TrackCnt:word
	extrn	FatSector:dword

IF	DEBUG
	extrn	msgFormatBroken:byte
ENDIF

; ============================================================================

data	ends

; ============================================================================

ifndef NEC_98
	extrn	PrintString:near
	extrn	std_printf:near
	extrn	crlf:near
	extrn	user_string:near
endif
	extrn	Read_Disk:near
	extrn	Write_Disk:near
	extrn	FatalExit:near

        extrn   SysGetMsg:near
	extrn	exclusive_access_failed:near
	extrn	ReleaseExclusiveAccessForFormat:near
	EXTRN	SetDeviceParameters:NEAR

; ============================================================================
; Constants
; ============================================================================

.xlist
INCLUDE	BPB.INC
INCLUDE BOOTSEC.INC
INCLUDE DOSMAC.INC
INCLUDE FORMACRO.INC
INCLUDE FOREQU.INC
INCLUDE FORSWTCH.INC

; This defines all the int 21H system calls
INCLUDE SYSCALL.INC

; Limits

INCLUDE filesize.inc

; ============================================================================
; These are the data structures which we will need
; ============================================================================

INCLUDE DIRENT.INC
INCLUDE ioctl.INC
INCLUDE dosequs.inc

.list

; ============================================================================
; And this is the actual data
; ============================================================================

data	segment public	para	'DATA'

Read_Write_Relative Relative_Sector_Buffer <>


BiosFile    db  0,":\WINBOOT.SYS", 0
            db  0,":\"                  ; use AltBiosFile-3 if you want
AltBiosFile db  "IO.SYS", 0             ; to specify a drive with AltBiosFile
AltBiosLen  equ $-AltBiosFile
MsdosFile   db  0,":\MSDOS.SYS", 0
MsdosRemark db  ";FORMAT",13,10
MsdosRemarkLen equ $-MsdosRemark

Dummy_Label db	"NO NAME    "
Dummy_Label_Size dw  11

Serial_Num_Low dw 0
Serial_Num_High dw 0

SizeMap db	0

trackReadWritePacket a_TrackReadWritePacket <>

ifndef NEC_98
boot2	db	0,0,0, "Boot 1.x"
	db	512 - 11 dup(?)

REORG2	LABEL	BYTE
	ORG	BOOT2
	INCLUDE BOOT11.INC
	ORG	REORG2

ONESECBOOT    LABEL   BYTE
	      INCLUDE BOOT.INC
ONESECBOOTEND LABEL   BYTE

ActualOneSecBootSize	dw    (ONESECBOOTEND - ONESECBOOT)

else

IPL_FD	LABEL	BYTE
	INCLUDE	IPL_FD.INC
	INCLUDE IPL_NULL.INC

IPL_HD	LABEL	BYTE
	INCLUDE	IPL_HDMO.INC
	INCLUDE	IPL_NULL.INC
	INCLUDE	IPL_NULL.INC
	INCLUDE	IPL_NULL.INC

IPL_MO	LABEL	BYTE
	INCLUDE	IPL_35MO.INC
IPL_MOEND	LABEL	BYTE

ActualOneSecBootSize	dw    (IPL_MOEND - IPL_MO)

endif
TWOSECBOOT    LABEL   BYTE
	INCLUDE BOOT2.INC
ENDTWOSECBOOT LABEL BYTE

ActualTwoSecBootSize	dw    (ENDTWOSECBOOT - TWOSECBOOT)
ActualTwoSecBootSizeSec dw    0

;
; BOOTBUF must be ActualTwoSecBootSize in size.
;
BootBuf       db (ENDTWOSECBOOT - TWOSECBOOT) dup (0)
scratchBuffer db 2048 dup(0)

scratchBufferSize	dw    (scratchBufferSize-scratchBuffer)

DoingTwoSecBoot 	db	0

ptr_msgWhatIsVolumeId? dw offset msgWhatIsVolumeId?
	dw	offset driveLetter

FAT12_String db "FAT12   "
FAT16_String db "FAT16   "
FAT32_String db "FAT32   "

Media_ID_Buffer Media_ID <>

; ============================================================================

data	ends

; ============================================================================
; AccessDisk:
;    Called whenever a different disk is about to be accessed
;
;    Input:
;	al - drive letter (0=A, 1=B, ...)
;
;    Output:
;	none
; ============================================================================

AccessDisk proc near

	push	ax				; save drive letter
	mov	bl,al				; Set up GENERIC IOCTL REQUEST
	inc	bl				; preamble
	mov	ax,(IOCTL SHL 8) + Set_Drv_Owner ; IOCTL function
	int	21h
	pop	ax
	return

AccessDisk endp

; ============================================================================
;    CheckSwitches:
;	Check switches against device parameters
;	Use switches to modify device parameters
;
;    Input:
;	deviceParameters
;
;    Output:
;	deviceParameters may be modified
;	Carry set if error
;
;
;  /B <> /S
;  /B/8 <> /V
;  /1 or /8 <> /T/N
;
; ============================================================================

	Public	CHeckSwitches
CheckSwitches proc near

	cld					; Everything forward
						; Disallow /C
CheckExcl:
	test	SwitchMap,SWITCH_Q		;Quick Format?
ifdef NEC_98
	jz	Q_Is_Valid
else
	jz	No_q
endif

						;/Q is allowed only with 
						;/S,/V,/B,/T,/N,/1,/4,/8,/F /U
	test	SwitchMap,not(SWITCH_Q or SWITCH_S or SWITCH_V or SWITCH_B or\
			      SWITCH_T or SWITCH_N or SWITCH_1 or SWITCH_U or\
			      SWITCH_4 or SWITCH_8 or SWITCH_F or SWITCH_AUTOTEST)

	jz	Q_Is_Valid
ifdef NEC_98
	jmp	Incompatible
else
	jmp	SHORT Incompatible
endif

No_q:
Q_Is_Valid:
ifdef NEC_98	;
	test	SwitchMap2,SWITCH2_6
	jz	@f
	test	SwitchMap,Switch_F
;;	jnz	Incompatible
	jz	F_on1
	jmp	short Incompatible
F_on1:
	or	SwitchMap,SWITCH_F
@@:
	test	SwitchMap2,SWITCH2_9
	jz	@f
	test	SwitchMap,Switch_F
	jnz	Incompatible
	or	SwitchMap,SWITCH_F
@@:
	test	SwitchMap2,SWITCH2_5
	jz	@f
	test	SwitchMap,Switch_F
	jnz	Incompatible
	or	SwitchMap,SWITCH_F
@@:
	test	SwitchMap2,SWITCH2_M
	jz	@f
	test	SwitchMap,Switch_F
	jnz	Incompatible
	or	SwitchMap,SWITCH_F
@@:
	test	SwitchMap2,SWITCH2_4
	jz	@f
	test	SwitchMap,Switch_F
	jnz	Incompatible
	or	SwitchMap,SWITCH_F
@@:
	test	SwitchMap,Switch_F		;Specify size?
	JZ	$$IF1				; No
	test	SwitchMap,(Switch_N+Switch_T)
	jnz	Incompatible			; /F and /T/N both ON->error!!
	jmp	short $$IF2			; call [Size_To_Switch]
else
	test	SwitchMap,Switch_F		;Specify size?
	JZ	$$IF1				;Yes
	test	SwitchMap,(Switch_1+Switch_8+Switch_4+Switch_N+Switch_T)
	JZ	$$IF2				;/F replaces above switches
endif		; NEC_98

Incompatible:
	Message msgIncompatibleParameters	;Print error
	mov	Fatal_Error,Yes			;Force exit
	JMP	SHORT $$EN2

$$IF2:
	call	Size_To_Switch			;Go set switches based
						; on the size

$$EN2:
$$IF1:
	cmp	Fatal_Error,NO
	JNE	$$IF6

	call	CheckSwitch8B
	call	CheckTN

$$IF6:
	cmp	Fatal_Error,Yes
	jne	ExclChkDone
	
	Message	msgFormatFailure
	jmp	FatalExit	

ExclChkDone:

; ============================================================================
; Patch the boot sector so that the boot strap loader knows what disk to
; boot from

ifdef NEC_98
	;NEC_98 already written EXT_PHYDRV in default data.
	;because NEC_98's IPL are separated FD,HD.
	;Then NEC_98 doesn't have to repatch this area.

	cmp	deviceParameters.DP_DeviceType, DEV_HARDDISK
	je	@F
	jmp	CheckFor5InchDrives
@@:
else
	mov	OneSecBoot.EXT_PHYDRV, 00H
	mov	TwoSecBoot.EXT_BGPHYDRV, 00H
	cmp	deviceParameters.DP_DeviceType, DEV_HARDDISK
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	CheckFor5InchDrives

; Formatting a hard disk so we must repatch the boot sector

	mov	OneSecBoot.EXT_PHYDRV, 80H
	mov	TwoSecBoot.EXT_BGPHYDRV, 80H
endif
	test	switchmap,not (SWITCH_S or SWITCH_V or SWITCH_Z or SWITCH_Select or \
			  SWITCH_AUTOTEST or Switch_B or SWITCH_U or SWITCH_Q)

	jz	SwitchesOkForHardDisk

	Message msgIncompatibleParametersForHardDisk
	stc
	ret

; ============================================================================
; Before checking the Volume Id we need to verify that a valid one exists
; We assume that unless a valid boot sector exists on the target disk, no
; valid Volume Id can exist.
; Assume Dir for vol ID exists in 1st 32mb of partition
; ============================================================================

SwitchesOkForHardDisk:

ifdef NEC_98
	test	DeviceParameters.DP_DeviceAttributes, 1		; Removable?
    .errnz EDP_DEVICEATTRIBUTES NE DP_DEVICEATTRIBUTES
	jz	$$IF9						; Yes
endif
	SaveReg <ax,bx,cx,dx,ds>
	mov	al,DriveToFormat
	mov	cx,LogBootSect
	xor	dx,dx

	mov	Read_Write_Relative.Start_Sector_High,0

	push	ds
	push	si
	push	di

	push	ds
	lds	bx, FatSector
	call	Read_Disk			;INT	 25h
	pop	es

	lea	di, Scratchbuffer
	mov	si, bx
	cld
	mov	cx, 512/2
	rep	movsw

	pop	di
	pop	si
	pop	ds
	
	jnc	CheckSignature
	stc
	RestoreReg <ds,dx,cx,bx,ax>
	ret

CheckSignature: 				;IF (Boot_Signature != aa55)
	mov	ax, word ptr ScratchBuffer.Boot_Signature
	cmp	ax, 0aa55h			;Find a valid boot record?
ifdef NEC_98
;;NEC_98'IPL is possible that BootSignature doesn't have.
	je	@F
	mov	ah, byte ptr [ScratchBuffer]
	mov	al, byte ptr [ScratchBuffer+2]
	cmp	ah,0E9h				;near jmp
	je	@F				; ||
	cmp	ah,0EBh				;short jmp
	jne	@F				;  +
	cmp	al,090h				;nop
@@:
endif
	RestoreReg <ds,dx,cx,bx,ax>
	clc					;No, so no need to check label
	JNZ	$$IF8				;No further checking needed
						;Should we prompt for vol label?
	test	SwitchMap,(SWITCH_Select or SWITCH_AUTOTEST)
	JNZ	$$IF9				;Yes, if /Select not entered
ifdef NEC_98
	test	SwitchMap2,SWITCH2_P
	JNZ	$$IF8
endif

	call	CheckVolumeId			;Go ask user for vol label
	JMP	SHORT $$EN9			;/Select entered

$$IF9:
	clc					;CLC indicates passed label test

$$EN9:
$$IF8:
	return

; ============================================================================

Incomp_Message: 				; fix PTM 809

	Message msgIncompatibleParameters	; print incompatible parms
	stc					; signal error
	return					; return to caller

Print_And_Return:
						; call PrintString
	stc
	return


CheckFor5InchDrives:

; Switch is set in FORMAT.ASM if disk is removable
;If drive type is anything other than 48 or 96,
;then only /V/S/H/N/T allowed

	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH96TPI
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	je	Got96

	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	je	Got48

	xor	ax,ax
	or	ax,(Switch_V or Switch_S or Switch_N or Switch_T or Switch_B)
	or	ax,(Switch_Backup or Switch_Select or Switch_Autotest)

	or	AX,SWITCH_U
	
	or	AX,SWITCH_Q

	not	ax
	test	switchmap,ax			;invalid switch?
	jz	Goto_Got_BPB1			;continue format

	Message msgParametersNotSupportedByDrive
	jmp	short Print_And_Return

Goto_Got_BPB1:
	jmp	SHORT Goto_Got_BPB

				; We have a 96tpi floppy drive /4 allows just
				; about all switches however, /1 requires
Got96:
	test	switchmap, SWITCH_4
	jnz	CheckForInterestingSwitches	;If /4 check /N/T/V/S

	test	switchmap, SWITCH_1		;If /1 and /4 check others
	jz	Got48

					;If only /1 with no /4, see if /N/T
	test	SwitchMap,(Switch_N or Switch_T)
	jnz	CheckForInterestingSwitches

	jmp	Incomp_message			; tell user error occurred

Got48:
					;Ignore /4 for non-96tpi 5 1/4" drives
	and	switchmap, not SWITCH_4

					;Ignore /1 if drive has only one head
					;and not /8

	cmp	word ptr deviceParameters.DP_BPB.oldBPB.BPB_Heads, 1
    .errnz EDP_BPB NE DP_BPB
	ja	CheckForInterestingSwitches
	test	switchmap, SWITCH_8
	jz	CheckForInterestingSwitches
	and	switchmap, not SWITCH_1

					;Are any interesting switches set?
CheckForInterestingSwitches:
	test	switchmap, not (SWITCH_V or SWITCH_S or Switch_Backup or \
				SWITCH_SELECT or SWITCH_AUTOTEST or \
				Switch_B or SWITCH_U or SWITCH_Q)

	jz	Goto_EndSwitchCheck		;No, everything ok

			;At this point there are switches other than /v/s/h
	test	SwitchMap,(SWITCH_N or SWITCH_T)
	jz	Use_48tpi		;Not /n/t, so must be /b/1/8/4
					;We've got /N/T, see if there are others
	test	SwitchMap, not (SWITCH_N or SWITCH_T or SWITCH_V or \
				SWITCH_S or Switch_Backup or SWITCH_SELECT \
				or SWITCH_AUTOTEST or SWITCH_U or SWITCH_B \
				or SWITCH_Q)

	jz	NT_Compatible			;Nope, all is well

	;If 96tpi drive and /1 exists with /N/T, then okay, otherwise error

	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH96TPI
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	Bad_NT_Combo

	test	SwitchMap, not (SWITCH_1 or SWITCH_N or SWITCH_T or \
				SWITCH_V or SWITCH_U or SWITCH_B or \
				SWITCH_S or Switch_Backup or SWITCH_SELECT or \
				Switch_Autotest or SWITCH_Q)
	jz	 Goto_Got_BPB

Bad_NT_Combo:
	Message msgIncompatibleParameters
	jmp	Print_And_Return

Goto_Got_BPB:
	jmp	SHORT Got_BPB_Ok		;Sleazy, but je won't reach it

Goto_EndSwitchCheck:
	jmp	EndSwitchCheck

; ============================================================================
; There is a problem with /N/T in that IBMBIO will default to a BPB with the
; media byte set to F0 (other) if the /N/T combo is used for the format. This
; will cause problems if we are creating a media that has an assigned media
; byte, i.e. 160,180,320,360, or 720k media using /N/T. To avoid this problem,
; if we detect a /N/T combo that would correspond to one of these medias, then
; we will set things up using the /4/1/8 switches instead of the /N/T
; MT - 7/17/86 PTR 33D0110
;
; Combo's that we look for - 96tpi drive @ /T:40, /N:9
;			     96tpi drive @ /T:40, /N:8
;
; Look for this combo after we set everything up with the /T/N routine
;			     1.44 drive  @ /T:80, /N:9
; ============================================================================

NT_Compatible:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH96TPI
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	Goto_Got_BPB

	cmp	TrackCnt,40			;Look for 40 tracks
	jne	Got_BPB_Ok

	cmp	NumSectors,9			;9 sectors?
	je	Found_48tpi_Type

	cmp	NumSectors,8			;8 sectors?
	jne	Goto_Got_BPB			;Nope diff type let it go thru

	or	SwitchMap,SWITCH_8		;Yes, turn on /8 switch

Found_48tpi_Type:
	and	SwitchMap,not (SWITCH_N or SWITCH_T) ;Turn off /T/N

; ============================================================================
; End PTR fix
; if we have a 96 tpi drive then we will be using it in 48 tpi mode
; ============================================================================

Use_48tpi:
	cmp	byte ptr deviceParameters.DP_DeviceType, DEV_5INCH96TPI
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	Not96tpi

	mov	byte ptr deviceParameters.DP_MediaType, 1
    .errnz EDP_MEDIATYPE NE DP_MEDIATYPE
	mov	word ptr deviceParameters.DP_Cylinders, 40
    .errnz EDP_CYLINDERS NE DP_CYLINDERS
Not96tpi:

; ============================================================================
; Since we know we are formatting in 48 tpi mode turn on /4 switch
; (We use this info in LastChanceToSaveIt)
; ============================================================================

	or	switchmap, SWITCH_4

; ============================================================================
; At this point we know that we will require a special BPB
; It will be one of:
;    0) 9 track 2 sides - if no switches
;    1) 9 track 1 side	- if only /1 specified
;    2) 8 track 2 sides - if only /8 specified
;    3) 8 track 1 side	- if /8 and /1 specified
;
; ============================================================================

GetBPBs:

	mov	cx,4		; 4 values to try
	mov	bx,offset data:CPMSwitchTable
	mov	si,offset data:CustomCPMBPBs
	mov	ax,SwitchMap
	and	ax,SWITCH_4+SWITCH_8+SWITCH_1

FindItLoop:
	cmp	ax,[bx]
	jz	FoundIt
	inc	bx
	inc	bx
	add	si,size a_BPB
	loop	FindItLoop		; Cannot failed

FoundIt:
	test	switchmap, SWITCH_8
	jz	Not8SectorsPerTrack
					; /8 implies Old_Dir = TRUE
	mov	Old_Dir,TRUE

Not8SectorsPerTrack:

				; Ok now we know which BPB to use so lets move
				; it to the device parameters
	lea	di, deviceParameters.DP_BPB
    .errnz EDP_BPB NE DP_BPB
	mov	cx, size a_BPB
	push	ds
	pop	es
	repnz	movsb
	jmp	EndSwitchCheck

; ============================================================================
; /N/T DCR stuff.  Possible flaw exists if we are dealing with a
; HardDisk. If they support the  "custom format" features for
; Harddisks too, then CheckForInterestingSwitches should
; consider /n/t UNinteresting, and instead of returning
; after setting up the custom BPB we fall through and do our
; Harddisk Check.
; ============================================================================

Got_BPB_OK:
	test	switchmap,SWITCH_N+SWITCH_T
	jnz	Setup_Stuff
	jmp	EndSwitchCheck
Setup_Stuff:
; Set up NumSectors and SectorsPerTrack entries correctly
	test	switchmap,SWITCH_N
	jz	No_Custom_Seclim
	mov	ax,word ptr NumSectors
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack,ax
    .errnz EDP_BPB NE DP_BPB
	jmp	short Handle_Cyln
No_Custom_Seclim:
	mov	ax,deviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack
	mov	NumSectors,ax

Handle_Cyln:
	test	switchmap,SWITCH_T
	jz	No_Custom_Cyln
; Set up TrackCnt and Cylinders entries correctly
	mov	ax,TrackCnt
	mov	DeviceParameters.DP_Cylinders,ax
    .errnz EDP_CYLINDERS NE DP_CYLINDERS
	jmp	short Check_720
No_Custom_Cyln:
	mov	ax,DeviceParameters.DP_Cylinders
    .errnz EDP_CYLINDERS NE DP_CYLINDERS
	mov	TrackCnt,ax

ifdef NEC_98
Check_720:

        cmp     TrackCnt,77
        je      $$Possible_1250

        cmp     Numsectors,8
        je      $$Possible_640

        cmp     Numsectors,15
        je      $$Possible_1200

        cmp     TrackCnt,80
        jne     CalcTotal

$$Possible_720:
        cmp     Numsectors,9
        je      This_is_720
        jmp     short CalcTotal


$$Possible_1250:
        cmp     Numsectors,8
        je	This_is_1250
        jmp     short CalcTotal

$$Possible_640:
        cmp     TrackCnt,80
        je	This_is_640
        jmp     short CalcTotal

$$Possible_1200:
        cmp     TrackCnt,80
        je	This_is_1200
        jmp     short CalcTotal

This_is_1250:
        SaveReg <si>
        mov     si,offset BPB1250
	JMP	short @F

This_is_1200:
        SaveReg <si>
        mov     si,offset BPB12
	JMP	short @F

This_is_640:
        SaveReg <si>
        mov     si,offset BPB640
	JMP	short @F

This_is_720:
        SaveReg <si>
        mov     si,offset BPB720

@@:
CopyBPB:
        SaveReg <ds,es,di,cx>

        mov     cx,seg data                     ; Setup seg regs, just in
        mov     ds,cx                           ; case they ain't!
        mov     es,cx
        mov     di,offset deviceParameters.DP_BPB
        mov     cx,size a_BPB
        rep     movsb
        RestoreReg <cx,di,es,ds,si>
        and     SwitchMap,not Switch_N          ;Turn off /N so doesn't effect
        and     SwitchMap,not Switch_T          ;Turn off /T so doesn't effect
        jmp     SHORT EndSwitchCheck

else
; ============================================================================
; PTM P868  -	Always making 3 1/2 media byte 0F0h. If 720, then set to
;		0F9h and use the DOS 3.20 BPB. Should check all drives
;		at this point (Make sure not 5 inch just for future
;		protection)
;		We will use the known BPB info for 720 3 1/2 diskettes for
;		this special case. All other new diskette media will use the
;		calculations that follow CalcTotal for BPB info.
; Fix MT	11/12/86
; ============================================================================

Check_720:

	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH96TPI
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	je	CalcTotal

	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	je	CalcTotal

	cmp	TrackCnt,80
	jne	CalcTotal

	cmp	NumSectors,9
	jne	CalcTotal

; ============================================================================
; At this point we know we have a 3 1/2 720kb diskette to format. Use the
; built in BPB rather than the one handed to us by DOS, because the DOS one
; will be based on the default for that drive, and it can be different from
; what we used in DOS 3.20 for the 720's. Short sighted on our part to use
; 0F9h as the media byte, should have use 0F0h (OTHER) and then we wouldn't
; have this problem.
; ============================================================================

	SaveReg <ds,es,si,di,cx>

	mov	cx,seg data			; Setup seg regs, just in
	mov	ds,cx				; case they ain't!
	mov	es,cx

	mov	si,offset BPB720		;Copy the BPB!
	mov	di,offset deviceParameters.DP_BPB
    .errnz EDP_BPB NE DP_BPB
	mov	cx,size a_BPB
	rep	movsb
	RestoreReg <cx,di,si,es,ds>
	jmp	SHORT EndSwitchCheck
endif

; ============================================================================
; End PTM P868 fix
; ============================================================================

CalcTotal:
	mov	ax,NumSectors
	mov	bx,DeviceParameters.DP_BPB.oldBPB.BPB_Heads
    .errnz EDP_BPB NE DP_BPB
	mul	bl				; AX = # of sectors * # of heads
	mul	TrackCnt			; DX:AX = Total Sectors
	or	dx,dx
	jnz	Got_BigTotalSectors
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors,ax
	jmp	short Set_BPB
Got_BigTotalSectors:
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors,ax
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors+2,dx
	push	dx				; preserve dx for further use
	xor	dx,dx
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors,dx
	pop	dx

Set_BPB:

; ============================================================================
; We calculate the number of sectors required in a FAT. This is done as:
; # of FAT Sectors = TotalSectors / SectorsPerCluster * # of bytes in FAT to
; represent one cluster (i.e. 3/2) / BytesPerSector (i.e. 512)
; ============================================================================

	xor	bx,bx
	mov	bl,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
	div	bx				; DX:AX contains # of clusters
; now multiply by 3/2
	mov	bx,3
	mul	bx
	mov	bx,2
	div	bx
	xor	dx,dx				; throw away modulo
; now divide by 512
	mov	bx,512
	div	bx
; dx:ax contains number of FAT sectors necessary
	inc	ax				; Go one higher
    ;
    ; 12-bit FAT only, so no BigSectorsPerFat
    ;
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFAT,ax
	mov	DeviceParameters.DP_MediaType,0
    .errnz EDP_MEDIATYPE NE DP_MEDIATYPE

; M010 - begin
	mov	si,offset data:CustomCPMBPBs
	lea	di,DeviceParameters.DP_BPB	; All matches
	push	ds
	pop	es
WhileLoop:
	cmp	si,offset data:EndStandardBPBs	; Find the compatible BPB
	je	MediaNotFound
	mov	ax,[si].BPB_TotalSectors
	cmp	ax,[di].BPB_TotalSectors
	jne	NotThisOne
	mov	ax,[si].BPB_SectorsPerTrack
	cmp	ax,[di].BPB_SectorsPerTrack
	jne	NotThisOne
	
	mov	cx,size a_BPB
	rep	movsb
	jmp	short EndSwitchCheck

NotThisOne:
	add	si,size a_BPB
	jmp	short WhileLoop

MediaNotFound:
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_MediaDescriptor,Custom_Media
; M010 - end

EndSwitchCheck:
	clc
	return

CheckSwitches endp

;*****************************************************************************
;Routine name: Size_To_Switch
;*****************************************************************************
;
;Description: Given the SizeMap field as input indicating the SIZE= value
;	      entered, validate that the specified size is valid for the
;	      drive, and if so, turn on the appropriate data fields and
;	      switches that would be turned on by the equivilent command line
;	      using only switchs. All defined DOS 4.00 sizes are hardcoded,
;	      in case a drive type of other is encountered that doesn't
;	      qualify as a DOS 4.00 defined drive. Exit with error message if
;	      unsupported drive. The switches will be setup for the CheckSwitches
;	      routine to sort out, using existing switch matrix logic.
;
;Called Procedures: Low_Density_Drive
;		    High_Capacity_Drive
;		    720k_Drives
;		    Other_Drives
;
;Change History: Created	8/1/87	       MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 SwitchMap = appropriate Switch_?? values turned on
;	 TrackCnt, NumSectors set if Switch_T,Switch_N turned on
;*****************************************************************************

Procedure Size_To_Switch

	cmp	SizeMap,0			;Are there sizes entered?
	JE	$$IF13				;Yes
	cmp	deviceParameters.DP_DeviceType,DEV_HARDDISK
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	JNE	$$IF14				;No size for fixed disk

	Message msgIncompatibleParametersForHardDisk
	JMP	SHORT $$EN14			;Diskette, see what type
$$IF14:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	JNE	$$IF16				;Found 180/360k drive

	call	Low_Density_Drive		;Go set switches
	JMP	SHORT $$EN16			;Check for 96TPI

$$IF16:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_5INCH96TPI
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	JNE	$$IF18				;Found it

	call	High_Capacity_Drive
	JMP	SHORT $$EN18

$$IF18:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_3INCH720KB
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	JNE	$$IF20				;Found 720k drive
	call	  Small_Drives
	JMP SHORT $$EN20

$$IF20:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_OTHER
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	JNE	NewType				;Must be 1.44mb
	call	Other_Drives
	JMP	SHORT $$EN22

NewType:
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_3INCH2880KB
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	JNE	$$IF22
	call	Other_Drives
	JMP	SHORT $$EN22

$$IF22:
ifdef NEC_98
	cmp	byte ptr deviceParameters.DP_DeviceType,DEV_8INCHDS
	JNE	$$not_supported
	call	NEC_98_1024_Drives
        JMP     SHORT $$EN22
$$not_supported:
endif
ifndef NEC_98
	Message msgParametersNotSupportedByDrive
endif
	mov	  Fatal_Error,Yes

$$EN22:
$$EN20:
$$EN18:
$$EN16:
$$EN14:
$$IF13:
	cmp	Fatal_Error,Yes
	JNE	$$IF30
ifdef JAPAN
	Message msgParametersNotSupportedByDrive
else
	Message msgIncompatibleParameters
endif

$$IF30:

	cmp	deviceParameters.DP_DeviceType,DEV_HARDDISK
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	JNE	$$IF32
	mov	Fatal_Error,Yes

$$IF32:
	and	SwitchMap,not Switch_F		;Turn off /F so doesn't effect
	ret					; following logic

Size_To_Switch endp

;*****************************************************************************
;Routine name: High_Capacity_Drive
;*****************************************************************************
;
;Description: See if 1.2mb diskette, or one of the other 5 1/4 sizes. Turn
;	      on /4 if 360k or lower
;
;Called Procedures: Low_Density_Drive
;
;Change History: Created	8/1/87	       MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 SwitchMap = Switch_4 if 360k or lowere
;*****************************************************************************

Procedure High_Capacity_Drive

	test	SizeMap,Size_1200		;1.2mb diskette?
	JNZ	$$IF34				;Nope

	call	Low_Density_Drive		;Check for /4 valid types
	cmp	Fatal_Error, No			;Find 160/180/320/360k?
	JNE	$$IF35				;Yes

	or	SwitchMap,Switch_4		;Turn on /4 switch
	JMP	SHORT $$EN35			;Did not find valid size

$$IF35:
	mov	Fatal_Error,Yes			;Indicate invalid device

$$EN35:
$$IF34:
	ret

High_Capacity_Drive endp

;*****************************************************************************
;Routine name: Low_Density_Drive
;*****************************************************************************
;
;Description: See if 360k diskete or one of the other 5 1/4 sizes. Turn
;	      on the /1/8 switch to match sizes
;
;Called Procedures: Low_Density_Drive
;
;Change History: Created	8/1/87	       MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 SwitchMap = Switch_1, Switch_8 to define size
;
;	360k = No switch
;	320k = Switch_8
;	180k = Switch_1
;	160k = Switch_1 + Switch_8
;*****************************************************************************


Procedure Low_Density_Drive

ifndef NEC_98
	test	SizeMap,Size_160
	JZ	@F
	or	SwitchMap,Switch_1+Switch_8
	JMP	SHORT $$EN39

@@:
	test	SizeMap,Size_180
	JZ	@F
	or	SwitchMap,Switch_1
	JMP	SHORT $$EN39

@@:
	test	SizeMap,Size_320
	JZ	@F
	or	SwitchMap,Switch_8
	JMP	SHORT $$EN39

@@:
	test	SizeMap,Size_360
	JNZ	$$EN39				;None of the above, not valid
	mov	Fatal_Error,Yes

$$EN39:
endif	; NEC_98
	ret

Low_Density_Drive endp

;*****************************************************************************
;Routine name: Small_Drives
;*****************************************************************************
;
;Description: See if 720k media in 720 drive, set up /T/N if so, otherwise
;	      error
;
;Called Procedures: None
;
;Change History: Created	8/1/87	       MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 SwitchMap
;	 TrackCnt
;	 NumSectors
;	720k = /T:80 /N:9
;*****************************************************************************

Procedure Small_Drives

ifdef NEC_98
        test    SizeMap,Size_720                ;Ask for 720k?
        JZ      $$not_720

        or      SwitchMap,Switch_T+Switch_N     ;Turn on /T:80 /N:9
        mov     TrackCnt,80
        mov     NumSectors,9
	JMP	short @F

$$not_720:
        test    SizeMap,Size_640                ;Ask for 640k?
        JZ      $$Fail_Small

        or      SwitchMap,Switch_T+Switch_N     ;Turn on /T:80 /N:8
        mov     TrackCnt,80
        mov     NumSectors,8
        jmp     short @F

$$Fail_Small:
				;NEC_98 both 720k and 640k Floppy "2"
else
	test	SizeMap,Size_720		;Ask for 720k?
	JNZ	@F				;Nope, thats all drive can do
endif
	mov	Fatal_Error,Yes 		;Indicate error
@@:
	ret

Small_Drives endp

ifdef NEC_98
;*****************************************************************************
;Routine name: NEC_98_1024_Drives
;*****************************************************************************
;
;Description: See if 1250k media in 1250 drive, otherwise
;             error
;
;Called Procedures: None
;
;Change History: Created        8/26/94         Y.Kata
;
;Input: SizeMap
;       Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;        SwitchMap
;*****************************************************************************

Procedure NEC_98_1024_Drives

        test    SizeMap,Size_1250               ;Ask for 1.25mb?
        JZ      $$not_1024

        or      SwitchMap,Switch_T+Switch_N
        mov     TrackCnt,77
        mov     NumSectors,8
	JMP	short @F

$$not_1024:
        test    SizeMap,Size_1200               ;1.2mb diskette?
        JZ      $$not_1200

        or      SwitchMap,Switch_T+Switch_N
        mov     TrackCnt,80
        mov     NumSectors,15
	JMP	short @F

$$not_1200:
	call	Small_Drives
	cmp	Fatal_Error,No
	JE	@F

        mov     Fatal_Error,Yes                 ;Indicate error
@@:
        ret

NEC_98_1024_Drives endp
endif

;*****************************************************************************
;Routine name: Other_Drives
;*****************************************************************************
;
;Description: See if 1.44 media or 720k media, setup /t/n, otherwise error
;
;Called Procedures: Small_Drives
;
;Change History: Created	8/1/87	       MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;	 SwitchMap
;	 TrackCnt
;	 NumSectors
;	720k = /T:80 /N:9
;*****************************************************************************

Procedure Other_Drives

	test	SizeMap,Size_2880		;Ask for 1.44mb diskette?
	jnz	Do_2880


	test	SizeMap,Size_1440		;Ask for 1.44mb diskette?
	JNZ	Do_1440				;Nope

ifdef NEC_98
	call	NEC_98_1024_Drives		;See if NEC 1.25MB
        JMP     short @F                        ;Got 1.25M
else
	call	Small_Drives			;See if 720k
	cmp	Fatal_Error,No			;Fatal_error=Yes if not
	JNE	@F				;Got 720k

	or	SwitchMap,Switch_T+Switch_N	;Turn on /T:80 /N:9
	mov	TrackCnt,80
	mov	NumSectors,9
endif

@@:
	JMP	SHORT OtherDrivesExit

Do_1440:
	or	SwitchMap,Switch_T+Switch_N	;Turn on /T:80 /N:18;
	mov	TrackCnt,80			;This will protect SIZE=1440
	mov	NumSectors,18			; from non-standard drives with
	JMP	SHORT OtherDrivesExit


Do_2880:
	or	SwitchMap,Switch_T+Switch_N	;Turn on /T:80 /N:18;
	mov	TrackCnt,80			;This will protect SIZE=1440
	mov	NumSectors,36			; from non-standard drives with


OtherDrivesExit:
	ret

Other_Drives endp


;*****************************************************************************
;Routine name:CheckTN
;*****************************************************************************
;
;Description: Make sure than if /T is entered, /N is also entered
;
;Called Procedures:  None
;
;Change History: Created	8/23/87  MT
;
;Input: SizeMap
;	Fatal_Error = NO
;
;Output: Fatal_Error = YES/NO
;*****************************************************************************

Procedure CheckTN

	test	SwitchMap,Switch_N		;Make sure /T entered if /N
	JZ	@F

	test	SwitchMap,Switch_T
	JNZ	@F

	Message msgBad_T_N			;It wasn't, so barf
	mov	Fatal_Error,Yes 		;Indicate error
	JMP	SHORT $$EN57

@@:
	test	SwitchMap,Switch_T		;Make sure /N entered if /T
	JZ	$$EN57

	test	SwitchMap,Switch_N
	JNZ	$$EN57				;It wasn't, so also barf
	Message msgBad_T_N
	mov	Fatal_Error,Yes 		;Indicate error

$$EN57:
	ret

CheckTN endp

;------------------------------------------------------------------------------
;    LastChanceToSaveIt:
;	This routine is called when an error is detected in DiskFormat.
;	If it returns with carry not set then DiskFormat is restarted.
;	It gives the oem one last chance to try formatting differently.
;	fLastChance gets set Then to prevent multiple prompts from being
;	issued for the same diskette.
;
;	Algorithm:
;		IF (error_loc == Track_0_Head_1) &
;			  ( Device_type < 96TPI )
;		   THEN
;			fLastChance  := TRUE
;			try formatting 48TPI_Single_Sided
;		   ELSE return ERROR
;
;------------------------------------------------------------------------------

LastChanceToSaveIt proc near

	cmp	currentCylinder, 0
	jne	WeCanNotIgnoreThisError
	cmp	currentHead, 1
	jne	WeCanNotIgnoreThisError

	cmp	deviceParameters.DP_DeviceType, DEV_5INCH
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	ja	WeCanNotIgnoreThisError

	mov	fLastChance, TRUE

	or	switchmap, SWITCH_1
	call	CheckSwitches
	clc
	ret

WeCanNotIgnoreThisError:
	stc
	ret

LastChanceToSaveIt endp


;*****************************************************************************
;Routine name WriteBootSector
;*****************************************************************************
;
;DescriptioN: Copy EBPB information to boot record provided by Get recommended
;	      BPB, write out boot record, error
;	      if can write it, then fill in new fields (id, etc..). The volume
;	      label will not be added at this time, but will be set by the
;	      create volume label call later.
;
;Called Procedures: Message (macro)
;
;Change History: Created	4/20/87 	MT
;
;Input: DeviceParameters.DP_BPB
;
;Output: CY clear if ok
;	 CY set if error writing boot or media_id info
;
;Psuedocode
;----------
;
;	Copy recommended EBPB information to canned boot record
;	Write boot record out (INT 26h)
;	IF error
;	   Display boot error message
;	   stc
;	ELSE
;	   Compute serial id and put into field (CALL Create_Serial_ID)
;	   IF fBIG32Fat  ;32 bit FAT
;	      Point at 'FAT_32' for file system type
;	   ELSE Point at 'FAT_12' string for file system type
;	       IF fBIGFat    ;16 bit FAT
;		  Point at 'FAT_16' for file system type
;	       ENDIF
;	   ENDIF
;	   Copy file system string into media_id field
;	   Write info to boot (INT 21h AX=440Dh, CX=0843h SET MEDIA_ID)
;	   IF error (CY set)
;	      Display boot error message
;	      stc
;	   ELSE
;	      clc
;	   ENDIF
;	ENDIF
;	ret
;*****************************************************************************

Procedure WriteBootSector

ifndef NEC_98
BOOT_SECT_MSG           equ     330
BOOT_SECT_MSG_OFFSET    equ     1EEh            ; Fixed offset of boot sector message
endif

        push    ds
        pop     es

    ; See which boot sector to write

	mov	DoingTwoSecBoot,0
	test	fBig32FAT,0FFh			;Is it FAT32?
	jz	DoBootOne			;No
	inc	DoingTwoSecBoot
	lea	si, TWOSECBOOT
	mov	cx, ActualTwoSecBootSize
	jmp	short MovBoot

DoBootOne:
	lea	di, BootBuf
	mov	cx, ActualTwoSecBootSize
	shr	cx, 1
	xor	ax,ax
	rep	stosw
ifdef NEC_98
	call	decision_IPL
	mov	si,di
else
	lea	si, ONESECBOOT
endif
	mov	cx, ActualOneSecBootSize
MovBoot:
	lea	di, BootBuf
	shr	cx, 1
	cld
	rep	movsw

ifndef NEC_98
    ; patch the boot messages in the boot sector

        mov     ax, BOOT_SECT_MSG
        mov     dh, 3
        call    SysGetMsg
        jc      No_msg
	mov	di, offset BootBuf
        add     di, es:[di+BOOT_SECT_MSG_OFFSET]
	cld
Copy_msg:
        lodsb
        stosb
        test    al,al                           ; this clears carry too
        jnz     Copy_msg
No_msg:
endif
        push    es
        pop     ds

    ; Copy the BPB from the device parameters into the boot sector

	lea	si, deviceParameters.DP_BPB	;Copy EBPB to the boot record
    .errnz EDP_BPB NE DP_BPB

	lea	di, BootBuf.EXT_BOOT_BPB
	mov	cx, size EXT_BPB_INFO
	cmp	DoingTwoSecBoot,0
	je	MovBPB

    ; NOTE that we don't do anything with BGBPB_RootDirStrtClus
    ; in the device parameters, it is already set properly.

    ; The FAT mirror active FAT field is always 0ed by FORMAT (mirror off)

	mov	deviceParameters.DP_BPB.EBGBPB_EXTFLAGS,0
	mov	deviceParameters.DP_BPB.EBGBPB_FS_VERSION,FAT32_Curr_Version

    ; The FSInfoSec and BkUpBootSec fields are always reset to the default
    ; by format.

	mov	ax,BootBuf.EXT_BGBOOT_BPB.EBGBPB_FSINFOSEC
	mov	deviceParameters.DP_BPB.BGBPB_FSInfoSec,ax
	mov	ax,BootBuf.EXT_BGBOOT_BPB.EBGBPB_BKUPBOOTSEC
	mov	deviceParameters.DP_BPB.BGBPB_BkUpBootSec,ax

    ; The reserved fields are always 0ed by format

	xor	ax,ax
	mov	deviceParameters.DP_BPB.BGBPB_Reserved,ax
	mov	deviceParameters.DP_BPB.BGBPB_Reserved+2,ax
	mov	deviceParameters.DP_BPB.BGBPB_Reserved+4,ax
	mov	deviceParameters.DP_BPB.BGBPB_Reserved+6,ax
	mov	deviceParameters.DP_BPB.BGBPB_Reserved+8,ax
	mov	deviceParameters.DP_BPB.BGBPB_Reserved+10,ax
    .errnz (SIZE BGBPB_Reserved) NE (6 * 2)

    ; Now SET these new device parameters

	mov	DeviceParameters.DP_SpecialFunctions, (INSTALL_FAKE_BPB or TRACKLAYOUT_IS_GOOD)
    .errnz EDP_SPECIALFUNCTIONS      NE DP_SPECIALFUNCTIONS
	lea	DX, DeviceParameters
	call	SetDeviceParameters		; Set the root directory cluster
.386
	jc	NotWriteProtected
.8086
    ; Now copy the device parameters into the boot sector

	mov	cx, size EXT_BIGBPB_INFO
MovBPB:
	cld
	rep	movsb				;Do the copy

    ; Write out the boot record

    ; Make sure scratch buffer is zeroed.

	lea	di, scratchBuffer
	mov	cx, scratchBufferSize
	shr	cx, 1
	xor	ax,ax
	rep	stosw

    ; Make sure scratch buffer is at least a sector in size

	mov	ax,scratchBufferSize
	cmp	ax,deviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	jb	NotWriteProtected	; Scratch buffer is to small

    ; See which boot sector to write

	cmp	DoingTwoSecBoot,0	; One sec boot?
	je	DoBootWrtOne		; Yes
	mov	si,deviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors
	xor	dx,dx
	mov	ax,ActualTwoSecBootSize
	mov	bx,deviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	dec	bx
	add	ax,bx
	adc	dx,0
	inc	bx
	div	bx			; AX is rounded up size of boot code
					; in sectors
	mov	ActualTwoSecBootSizeSec,ax
	mov	cx,ax
	cmp	cx,si
	ja	NotWriteProtected	; Boot code wont fit
	sub	si,cx			; After we write the boot record
					;   there are this many sectors
					;   "left over" that we need to zero
	mov	di,cx			; Starting at this sector #
	xor	ax,ax
	dec	ax
	cmp	si,ActualTwoSecBootSizeSec	; Room for another boot?
	jb	SetBckUp			; No
	cmp	di,BootBuf.EXT_BGBOOT_BPB.EBGBPB_BKUPBOOTSEC ; Valid backup start?
	ja	SetBckUp			; No
	mov	dx,deviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors
	sub	dx,ActualTwoSecBootSizeSec
	cmp	dx,BootBuf.EXT_BGBOOT_BPB.EBGBPB_BKUPBOOTSEC ; Valid backup start?
	jae	DoBootWrt			; Yes
SetBckUp:
	mov	BootBuf.EXT_BGBOOT_BPB.EBGBPB_BKUPBOOTSEC,ax
	jmp	short DoBootWrt

DoBootWrtOne:
	mov	cx, 1			; Specify 1 sector
DoBootWrt:
	lea	bx,BootBuf		;Point at the boot record
	mov	al, DriveToFormat		;Get drive letter
	xor	dx, dx				;Logical sector 0
	mov	Read_Write_Relative.Start_Sector_High,0
	call	Write_Disk
	JNC	$$IF62				; No Error on write
BootWrtErr:
	cmp	ah,3
	jnz	NotWriteProtected
	mov	ax,19
	Extended_message
	stc
	ret

NotWriteProtected:
	Message msgBootWriteError		;Print error
	stc					;CY=1 means error
	ret

$$IF62:
    ;
    ; Zero out balance of reserved sectors if any
    ;
	cmp	DoingTwoSecBoot,0   ; One sec boot?
	je	NoExtZero	    ; Yes
	or	si,si		    ; Any "left over" reserved sectors to zero?
	jz	NoExtZero	    ; No
	mov	dx,di		    ; Start at this sector #
	lea	bx, ScratchBuffer
	mov	cx, 1		; Specify 1 sector
	mov	Read_Write_Relative.Start_Sector_High,0
DoRsvdZrWrt:
	mov	al, DriveToFormat		;Get drive letter
	call	Write_Disk
	jc	BootWrtErr
	inc	dx			; Next sector
	dec	si
	jnz	DoRsvdZrWrt
    ;
    ; Write the backup boot record
    ;
	mov	dx,BootBuf.EXT_BGBOOT_BPB.EBGBPB_BKUPBOOTSEC
	inc	dx
	jz	NoExtZero
	dec	dx
	lea	bx, BootBuf
	mov	cx,ActualTwoSecBootSizeSec
	mov	Read_Write_Relative.Start_Sector_High,0
	mov	al, DriveToFormat		;Get drive letter
	call	Write_Disk
	jc	BootWrtErr
NoExtZero:
	call	ReleaseExclusiveAccessForFormat
	jnc	short UnlockOk
	jmp	exclusive_access_failed
UnlockOk:
	mov	cx,Dummy_Label_Size		;Put in dummy volume label
	lea	si,Dummy_Label			; size ac028
	lea	di,Media_ID_Buffer.Media_ID_Volume_Label
	rep	movsb
	call	Create_Serial_ID		;Go create unique ID number
	lea	si,FAT32_String 		;Assume 32 bit FAT
	test	fBig32FAT,0FFh			;Is it?
	jnz	$$IF64				;yes
	lea	si,FAT12_String			;Assume 12 bit FAT
	test	fBigFAT,0FFh			;Is it?
	JZ	$$IF64				;Not if fBigFat is set....
	lea	si,FAT16_String 		;Got 16 bit FAT
$$IF64:
						;Copy file system string
	mov	cx,8				; to buffer
	lea	di,Media_ID_Buffer.Media_ID_File_System
	repnz	movsb
	mov	bl,DriveToFormat			;Get drive
	inc	bl				;Make it 1 based
	xor	bh,bh				;Set bh=0

	mov	CH,RAWIO
	cmp	IsExtRAWIODrv,0
	je	DoIOCTL1
	mov	CH,EXTRAWIO
DoIOCTL1:
	mov	cl,Set_Media_ID 		;Set Media ID call
	mov	dx,offset Media_ID_Buffer	;Point at buffer

	mov	al,IOCTL_QUERY_BLOCK		;Check if function is supported
	DOS_Call IOCtl				;before attempting it
	JC	$$IF66				;Skip over operation since not
						;supported on carry
	mov	al,Generic_IOCtl		;Perform actual function since
	DOS_Call IOCtl				;got no carry from ioctl query
	JNC	$$IF66				;Error ? (Write or old boot rec)

	Message msgBootWriteError		;Indicate we couldn't write it
	stc					;CY=1 for error return
	JMP	SHORT $$EN66			;Set Media ID okay

$$IF66:
	clc					;CY=0 for good return
$$EN66:
$$EN62:
	ret

WriteBootSector endp


;*****************************************************************************
;Routine name Create_Serial_ID
;*****************************************************************************
;
;DescriptioN&gml Create unique 32 bit serial number by getting current date and
;	      time and then scrambling it around.
;
;Called Procedures: Message (macro)
;
;Change History&gml Created	   4/20/87	   MT
;
;Input&gml None
;
;Output&gml Media_ID_Buffer.Serial_Number = set
;	    AX,CX,DX destroyed
;	    Serial_Num_Low/High = Serial number generated
;
;Psuedocode
;----------
;
;	Get date (INT 21h, AH=2Bh)
;	Get time (INT 21h, AH=2Ch)
;	Serial_ID+0 = DX reg date + DX reg time
;	Serial_ID+2 = CX reg date + CX reg time
;	Serial_Num_Low = Serial_ID+2
;	Serial_Num_High = Serial_ID+0
;	ret
;*****************************************************************************

Procedure Create_Serial_ID

	DOS_Call Get_Date			;Get date from DOS
	push	cx				;Save results
	push	dx
	DOS_Call Get_Time			;Get_Time
	mov	ax,dx				;Scramble it
	pop	dx
	add	ax,dx
	mov	word ptr Media_ID_Buffer.Media_ID_Serial_Number+2,ax
	mov	Serial_Num_Low,ax
	mov	ax,cx
	pop	cx
	add	ax,cx
	mov	word ptr Media_ID_Buffer.Media_ID_Serial_Number,ax
	mov	Serial_Num_High,ax
	ret

Create_Serial_ID endp

;-------------------------------------------------------------------------------
;
; OemDone:
;
;-------------------------------------------------------------------------------

OemDone proc	near

; if /b write out a fake dos & bios
	test	switchmap, SWITCH_B
	jz	Switch8?
	call	WriteBogusDos
	retc

Switch8?:
ifndef NEC_98
	test	switchmap, SWITCH_8
	jz	HardDisk?
	call	ConvertToOldDirectoryFormat
	retc

HardDisk?:
	cmp	deviceParameters.DP_DeviceType, DEV_HARDDISK
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	clc
	retnz
	call	SetPartitionTable
endif

	return

OemDone endp

;------------------------------------------------------------------------------
; simple code to stuff bogus dos in old-style diskette.
;------------------------------------------------------------------------------

BogusDos:
ifdef NEC_98	;This source from NEC_98 DOS5.0A

DYIO_SYS:	;DUMMY IO.SYS CODE
		JMP	STAT
IO_ERR		DB	"No system files",0
		DB	50 DUP ("STACK")
STACK_AREA	LABEL BYTE
STAT:
		XOR	AX,AX
		MOV	ES,AX
		MOV	AX,CS
		MOV	DS,AX
		MOV	SS,AX
		MOV	SP,OFFSET STACK_AREA - OFFSET DYIO_SYS + 200h
		MOV	AX,0A00H	;*SET CRT MODE
		INT	18H
		MOV	AH,0CH			;*TEXT
		INT	18H
		MOV	AH,12H
		INT	18H
		MOV	DI,CS
		MOV	DS,DI
		CLD
		XOR	AX,AX
		MOV	ES,AX
		MOV	DI,0A200H
		TEST	BYTE PTR ES:[0501H],08H
		JZ	PC98
		MOV	DI,0E200H
PC98:
		MOV	ES,DI
		MOV	DI,320		;*3LINE
		MOV	AL,0E1H
DYIO_LOOP1:
		CMP	DI,32+320
		JNC	MOJI
		STOSB
		INC	DI
		JMP	SHORT DYIO_LOOP1
MOJI:
		MOV	SI,OFFSET IO_ERR - OFFSET DYIO_SYS + 200h
		XOR	AX,AX
		MOV	ES,AX
		MOV	DI,0A000H
		TEST	BYTE PTR ES:[0501H],08H
		JZ	PC9801
		MOV	DI,0E000H
PC9801:
		MOV	ES,DI
		MOV	DI,320
DYIO_LOOP2:
		CMP	DI,32+320
		JNC	MOJI2
		MOVSB
		INC	DI
		JMP	SHORT DYIO_LOOP2
MOJI2:
		MOV	AL,06H
		OUT	37H,AL
HLT1:
		JMP SHORT HLT1
;***********************************************
else
	push	cs
	pop	ds
	mov	al,20h
	out	20h,al				; turn on the timer so the
	jmp	SHORT DelayJump 		; disk motor
						; shuts off
DelayJump:
	mov	si,mesofs

sys_mess_loop:
	lodsb

if 0
end_sys_loop:
endif

	or	al,al
	jz	end_sys_loop
	mov	ah,14
	mov	bx,7
	int	16
	jmp	sys_mess_loop

ife 0
end_sys_loop:
	xor	ah, ah				; get next char function
	int	16h				; call keyboard services
	int	19h				; reboot
endif

	include BOOT.CL1
mesofs	equ	sysmsg - BogusDos
endif

; ===========================================================================

WriteBogusDos proc near

        mov     al,driveLetter
        mov     [AltBiosFile-3],al
        mov     cx, ATTR_HIDDEN or ATTR_SYSTEM
        lea     dx, AltBiosFile-3
        mov     ah,CREAT
        int     21h
        jc      wbd_return
        xchg    bx,ax

ifdef NEC_98
	mov	cx,0000h
	mov	dx,0200h
	mov	ah,LSEEK
	mov	al,0
	int	21h
endif
        mov     cx, WriteBogusDos - BogusDos
        push    ds
        push    cs
        pop     ds
        assume  ds:code
        lea     dx, BogusDos
        mov     ah,WRITE
        int     21h
        pop     ds
        assume  ds:data

        mov     dx,BIOS_SIZE_KB
        mov     cx,dx
        .386
        shl     dx,10
        shr     cx,16-10
        .8086
        mov     ax,LSEEK shl 8
        int     21h

        mov     word ptr Bios.FileSizeInBytes,ax
        mov     word ptr Bios.FileSizeInBytes+2,dx

        call    AddToSystemSize

        sub     cx,cx
        mov     ah,WRITE
        int     21h

        mov     ah,CLOSE
        int     21h

        mov     al,driveLetter
        mov     [MsdosFile],al
        mov     cx, ATTR_HIDDEN or ATTR_SYSTEM
        lea     dx, MsdosFile
        mov     ah,CREAT
        int     21h
        jc      wbd_return
        xchg    bx,ax

        mov     cx,MsdosRemarkLen
        mov     ax,cx
        xor     dx,dx                   ; DX:AX = size of bogus MSDOS.SYS

        mov     word ptr DOS.FileSizeInBytes,ax
        mov     word ptr DOS.FileSizeInBytes+2,dx

        call    AddToSystemSize         ; btw, this trashes DX:AX only

        mov     dx,offset MsdosRemark
        mov     ah,WRITE
        int     21h

        mov     ah,CLOSE
        int     21h

        clc

wbd_return:
        return

WriteBogusDos endp

ifndef NEC_98
;-----------------------------------------------------------------------------
; convert to 1.1 directory
;-----------------------------------------------------------------------------

ConvertToOldDirectoryFormat proc near


	mov	al,DriveToFormat			; Get 1st sector of directory
	mov	cx,1				; 1.1 directory always starts
	mov	dx,3				; on sector 3
	lea	bx,scratchBuffer
	mov	Read_Write_Relative.Start_Sector_High,0
	call	Read_Disk
	jnc	DirectoryRead

	Message msgDirectoryReadError
	stc
	ret

DirectoryRead:

					; fix attribute of ibmbio and ibmdos
	lea	bx,scratchBuffer
	mov	byte ptr [bx].dir_attr, ATTR_HIDDEN or ATTR_SYSTEM
	add	bx, size dir_entry
	mov	byte ptr [bx].dir_attr, ATTR_HIDDEN or ATTR_SYSTEM

wrtdir:
	mov	al,[DriveToFormat]			; write out the directory
	cbw
	mov	cx,1
	mov	dx,3
	lea	bx,scratchBuffer
	mov	Read_Write_Relative.Start_Sector_High,0
	call	Write_Disk
	jnc	DirectoryWritten
	Message msgDirectoryWriteError
	stc
	ret

DirectoryWritten:
	test	switchmap, SWITCH_S		; Was system requested?
	retnz					; yes, don't write old boot sec

	mov	al,DriveToFormat
	cbw

	push	DI 				; Fix for old style disk
	push	SI				; we have to copy the
	push	ES				; BPB to the boot record

	mov	SI,DS
	mov	ES,SI

	mov	DI,offset boot2 + bsBPB
	mov	SI,OFFSET deviceParameters.DP_BPB
    .errnz EDP_BPB NE DP_BPB
	mov	CX,SIZE BPB - 6
	rep	movsb

	pop	ES
	pop	SI
	pop	DI

	mov	bx,offset boot2 		; no,  write old boot sector
	cmp	deviceParameters.DP_BPB.oldBPB.BPB_Heads, 1
    .errnz EDP_BPB NE DP_BPB
	je	bootset8
	mov	word ptr [bx+3],0103h		; start address for double
						; sided drives

bootset8:
	mov	cx,1
	xor	dx,dx
	mov	Read_Write_Relative.Start_Sector_High,0
	call	Write_Disk
	retnc

	Message msgBootWriteError
	stc
	ret

ConvertToOldDirectoryFormat endp

;-------------------------------------------------------------------------------

a_PartitionTableEntry struc
BootInd 	db	?
BegHead 	db	?
BegSector	db	?
BegCylinder	db	?
SysInd		db	?
EndHead 	db	?
EndSector	db	?
EndCylinder	db	?
RelSec		dd	?
CSec		dd	?
a_PartitionTableEntry ends

;-------------------------------------------------------------------------------

; structure of the IBM hard disk boot sector:
IBMBoot STRUC
	db	512 - (4*size a_PartitionTableEntry + 2) dup(?)
PartitionTable db 4*size a_PartitionTableEntry dup(?)
Signature dw	?
IBMBoot ENDS


;*****************************************************************************
;Routine name: SetPartitionTable
;*****************************************************************************
;
;Description: Find location for DOS partition in partition table, get the
;	      correct system indicator byte, and write it out. If can not
;	      read/write boot record or can't find DOS partition, display
;	      error
;
;Called Procedures: Message (macro)
;		    Determine_Partition_Type
;		    ReadSector
;		    WriteSector
;
;Change History: Created	4/20/87 	MT
;
;Input: None
;
;Output: CY set if error
;
;Psuedocode
;----------
;
;	Read the partition table (Call ReadSector)
;	IF ok
;	   IF boot signature of 55AAh
;	       Point at system partition table
;	       SEARCH
;		  Assume DOS found
;		  IF System_Indicator <> 1,AND
;		  IF System_Indicator <> 4,AND
;		  IF System_Indicator <> 6
;		    STC   (DOS not found)
;		  ELSE
;		    CLC
;		  ENDIF
;	       EXITIF DOS found (CLC)
;		  CALL Determine_Partition_Type
;		  Write the partition table (CALL WriteSector)
;		  IF error
;		     Display boot write error message
;		     stc
;		  ELSE
;		     clc
;		  ENDIF
;	       ORELSE
;		  Point at next partition entry (add 16 to partition table ptr)
;	       ENDLOOP if checked all 4 partition entries
;		  Display Bad partition table message
;		  stc
;	       ENDSRCH
;	   ELSE invalid boot record
;	      Display Bad partition table message
;	      stc
;	   ENDIF
;	ELSE error
;	   Display Partition table error
;	   stc
;	ENDIF
;	ret
;*****************************************************************************

Procedure SetPartitionTable

	xor	ax, ax				;Head
	xor	bx, bx				;Cylinder
	xor	cx, cx				;Sector
	lea	dx, boot2			;Never use 1.x boot on hardfile
	call	ReadSector			;this will use space as buffer
	JC	$$IF70				;If read okay

        cmp     word ptr Boot2.Boot_Signature,Boot_ID
	JNE	$$IF71				;Does signature match?

	lea	bx, boot2.PartitionTable	;Yes, point at partition table

$$DO72: 					;Look for DOS partition
	cmp	[bx].sysind,FAT12_File_System
	JE	$$IF73

	cmp	[bx].sysind,FAT16_File_System
	JE	$$IF73

	cmp	[bx].sysind,New_File_System
	JE	$$IF73

	cmp	[bx].sysind,FAT32_File_System
	JE	$$IF73

	stc					;We didn't find partition
	JMP	SHORT $$EN73

$$IF73:
	clc					;Indicate found partition

$$EN73:
	JC	$$IF72				;Get correct id for it

	CALL	Determine_Partition_Type
	mov	ax, 0				;Head
	mov	bx, 0				;Cylinder
	mov	cx, 0				;Sector
	lea	dx, boot2			;
;;;
;;; DO NOT DO THIS ALARMINGLY STUPID IDIOT STUFF AND TRASH THE MBR!!!!!!!
;;;
	clc
;;;	   call    WriteSector			   ;Write out partition table
	JNC	$$IF77				;Error writing boot record

	MESSAGE msgPartitionTableWriteError
	stc					;Set CY to indicate error
	JMP	SHORT $$EN77

$$IF77:
	clc					;No error means no CY

$$EN77:
	JMP	SHORT $$SR72

$$IF72:
	add	bx,size a_PartitionTableEntry
	cmp	bx,(offset Boot2.PartitionTable)+4*size a_PartitionTableEntry
	JMP	SHORT $$DO72			;Checked all 4 partition entries

;*** No way to get to this code

	MESSAGE msgBadPartitionTable		;Tell user bad table
	stc					;Set CY for exit

$$SR72:
	JMP	SHORT $$EN71			;Invalid boot record

$$IF71:
	MESSAGE msgBadPartitionTable
	stc					;Set CY for error return

$$EN71:
	JMP	SHORT $$EN70			;Couldn't read boot record

$$IF70:
	MESSAGE msgPartitionTableReadError
	stc					;Set CY for error return

$$EN70:
	ret

SetPartitionTable endp

;*****************************************************************************
;Routine name: Determine_Partition_Type
;*****************************************************************************
;
;DescriptioN: Set the system indicator field to its correct value as
;	      determined by the following rules:
;
;	     - Set SysInd = 01h if partition or logical drive size is < 10mb
;	       and completely contained within the first 32mb of DASD.
;	     - Set SysInd = 04h if partition or logical drive size is >10mb,
;	       <32mb, and completely contained within the first 32mb of DASD
;	     - Set SysInd to 06h if partition or logical drive size is > 32mb,
;
;Called Procedures: Message (macro)
;
;Change History: Created	3/18/87 	MT
;
;Input: BX has offset of partition table entry
;	fBigFAT = TRUE if 16bit FAT
;
;Output: BX.SysInd = correct partition system indicator value (1,4,6)
;
;Psuedocode
;----------
;	Add partition start location to length of partition
;	IF end > 32mb
;	   BX.SysInd = 6
;	ELSE
;	   IF fBigFat
;	      BX.SysInd = 4
;	   ELSE
;	      BX.SysInd = 1
;	   ENDIF
;	ret
;
;
;  THIS CODE IS ALARMINGLY STUPIDLY BUSTED AND HAS BEEN FOR YEARS AND YEARS...
;  It will change the mark of the wrong partition. It will change the mark
;  of the correct partition to the wrong value.
;
;  IT IS NOT FORMAT'S JOB TO MESS WITH PARTITION TABLES!!!!!!!!!!!!!!!
;  That is what FDISK is for.
;
;*****************************************************************************

Procedure Determine_Partition_Type

	mov	dx,word ptr [bx].Csec+2 	; Get high word of sector count
	cmp	dx,0				; > 32Mb?
	JE	$$IF87				; No
$$IF86:
	test	fBig32FAT,0FFh			; 32 bit FAT?
	jnz	Set32				; Yes
;;	  mov	  [BX].SysInd,New_File_System	  ; type 6
	JMP	SHORT $$EN87

Set32:
;;	  mov	  [BX].SysInd,FAT32_File_System   ; type B
	JMP	SHORT $$EN87

$$IF87:
	call	Calc_Total_Sectors_For_Partition ;returns DX:AX total sectors
	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_HiddenSectors[+2],0	;> 32Mb?
    .errnz EDP_BPB NE DP_BPB
	JNE	$$IF86
	cmp	dx,0				; partition > 32 Mb?
	JE	$$IF91				; yes
;;	  mov	  [bx].SysInd,New_File_System	  ; type 6
	JMP	SHORT $$EN91			; < 32 Mb partition
$$IF91:
	test	fBig32FAT,0FFh			; 32 bit FAT?
	jnz	Set32
	test	fBigFAT,0FFh			; 16 bit FAT?
	jz	$$IF93				; no
;;	  mov	  [BX].SysInd,FAT16_File_System   ; type 4
	JMP	SHORT $$EN93

$$IF93:
;;	  mov	  [bx].SysInd,FAT12_File_System   ; type 1 12 bit FAT
$$EN93:
$$EN91:
$$EN87:
	ret

Determine_Partition_Type endp


;=========================================================================
; Calc_Total_Sectors_For_Partition	: This routine determines the
;					  total number of sectors within
;					  this partition.
;
;	Inputs	: DeviceParameters
;
;	Outputs : DX:AX - Double word partition size
;=========================================================================

Procedure Calc_Total_Sectors_For_Partition

	mov	ax,word ptr DeviceParameters.DP_BPB.oldBPB.BPB_HiddenSectors[0]
	mov	dx,word ptr DeviceParameters.DP_BPB.oldBPB.BPB_HiddenSectors[2]
	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors,0 ; extended BPB?
    .errnz EDP_BPB NE DP_BPB
	JNE	$$IF99			; yes

	add	ax,word ptr DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors[0]
	adc	dx,0			; pick up carry if any

	add	dx,word ptr DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors[2]
	JMP	SHORT $$EN99		; standard BPB

$$IF99:
	add	ax,word ptr DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
	adc	dx,0			; pick up carry if any

$$EN99:
	ret

Calc_Total_Sectors_For_Partition	endp


;-------------------------------------------------------------------------------
; ReadSector:
;    Read one sector
;
;    Input:
;	ax - head
;	bx - cylinder
;	cx - sector
;	dx - transfer address

ReadSector proc near

	mov	TrackReadWritePacket.TRWP_FirstSector, cx

	mov	cx,(RAWIO shl 8) or READ_TRACK
	cmp	IsExtRAWIODrv,0
	je	DoIOCTL2
	mov	cx,(EXTRAWIO shl 8) or READ_TRACK
DoIOCTL2:
	call	SectorIO
	return

ReadSector endp

;-------------------------------------------------------------------------------
; WriteSector:
;    Write one sector
;
;    Input:
;	ax - head
;	bx - cylinder
;	cx - sector
;	dx - transfer address

WriteSector proc near

	mov	TrackReadWritePacket.TRWP_FirstSector, cx

	mov	cx,(RAWIO shl 8) or WRITE_TRACK
	cmp	IsExtRAWIODrv,0
	je	DoIOCTL3
	mov	cx,(EXTRAWIO shl 8) or WRITE_TRACK
DoIOCTL3:
	call	SectorIO
	return

WriteSector endp

;-------------------------------------------------------------------------------
; SectorIO:
;    Read/Write one sector
;
;    Input:
;	ax - head
;	bx - cylinder
;	cx - (RAWIO shl 8) or READ_TRACK
;	   - (RAWIO shl 8) or WRITE_TRACK
;	dx - transfer address

SectorIO proc	near

	mov	TrackReadWritePacket.TRWP_Head, ax
	mov	TrackReadWritePacket.TRWP_Cylinder, bx
	mov	WORD PTR TrackReadWritePacket.TRWP_TransferAddress, dx
	mov	WORD PTR TrackReadWritePacket.TRWP_TransferAddress + 2, ds
	mov	TrackReadWritePacket.TRWP_SectorsToReadWrite, 1

	mov	bl, DriveToFormat
	inc	bl
	mov	ax, (IOCTL shl 8) or GENERIC_IOCTL
	lea	dx, trackReadWritePacket
	int	21H
	return

SectorIO endp
endif

; ==========================================================================

data	segment public	para	'DATA'

oldDrive db	?

FCBforVolumeIdSearch db 0ffH
	db	5 dup(0)
	db	08H
	db	0
	db	"???????????"
	db	40 DUP(0)

data	ends

; ==========================================================================

GetVolumeId proc near
; Input:
;    dl = drive
;    di = name buffer

; Save current drive
	mov	ah,19H
	int	21H
	mov	oldDrive, al

; Change current drive to the drive that has the volume id we want
	mov	ah, 0eH
	int	21H

; Search for the volume id
	mov	ah, 11H
	lea	dx, FCBforVolumeIdSearch
	int	21H
	push	ax

; Restore current drive
	mov	ah, 0eH
	mov	dl,oldDrive
	int	21H

; Did the search succeed?
	pop	ax
	or	al,al
	jz	CopyVolumeId
	stc
	ret

CopyVolumeId:
		; Find out where the FCB for the located volume id was put
	mov	ah,2fH
	int	21H

; Copy the Volume Id
	mov	si, bx
	add	si, 8
	push	es
	push	ds
	pop	es
	pop	ds
	mov	cx, 11
	rep	movsb
	push	es
	pop	ds

	clc
	ret

GetVolumeId endp

; ==========================================================================

data	segment public	para	'DATA'
oldVolumeId db	11 dup(0)
data	ends

; ==========================================================================

CheckVolumeId proc near

; Get the volume id that's on the disk
	lea	di, oldVolumeId
	mov	dl, DriveToFormat
	call	GetVolumeId
	clc					;No, return with no error
	ret

CheckVolumeId endp


; ==========================================================================

CheckSwitch8B	proc	near

	test	SwitchMap, SWITCH_B		;/8/B <> /V because
	JZ	$$IF102 			; old directory type

	test	SwitchMap, Switch_8		; used which didn't support
	JZ	$$IF102 			; volume labels.

	test	SwitchMap, SWITCH_V
	JZ	$$IF102

	Message msgBad_8_V			; Tell user
	mov	Fatal_Error,Yes			; Bad stuff
	JMP	SHORT $$EN102			; No problem so far

$$IF102:
	test	SwitchMap, Switch_B		; Can't reserve space and
	JZ	$$IF104 			; install sys files at the

	test	SwitchMap, Switch_S		; same time.
	JZ	$$IF104 			; No /S/B

	Message msgIncompatibleParameters ;Tell user
	mov	Fatal_Error,Yes	;Bad stuff
	JMP	SHORT $$EN104			;Still okay

$$IF104:
	test	SwitchMap,Switch_1		;/1/8/4 not okay with /N/T
	JNZ	$$LL106

	test	SwitchMap,Switch_8
	JNZ	$$LL106

	test	SwitchMap,Switch_4
	JZ	$$IF106

$$LL106:
	test	SwitchMap,(Switch_T or Switch_N)
	JZ	$$IF107 			;Found /T/N <> /1/8
	Message msgIncompatibleParameters	;Tell user
	mov	Fatal_Error,Yes 		;Bad stuff
	JMP	SHORT $$EN107

$$IF107:
	test	SwitchMap,Switch_V
	JZ	$$IF109
	test	SwitchMap,Switch_8
	JZ	$$IF109

	Message msgBad_8_V
	mov	Fatal_Error,Yes

$$IF109:
$$EN107:
$$IF106:
$$EN104:
$$EN102:
	 ret

CheckSwitch8B	endp

ifdef NEC_98
;	if HD or 5"MO --> di = offset IPL_HD
;	else          --> di = offset IPL_FD
;
;OUT	di = IPL offset
;
decision_IPL	proc	near
	cmp	DeviceParameters.DP_DeviceType,DEV_HARDDISK
	jne	$$go_iplfd
	mov	di, offset IPL_HD
	jmp	short $$exit_decision_ipl
$$go_iplfd:
	mov	di, offset IPL_FD
$$exit_decision_ipl:
	ret
decision_IPL	endp
endif
; ==========================================================================

code	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\path.asm ===
title   Path Searching Routines
;/*
; *                      Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1993
; *                      All Rights Reserved.
; */
        Page    ,132

; PATH.ASM - Code to search the environment for a particular data string,
; and to search the path for a particular file.  Adapted from the original
; COMMAND.COM version.
;
; Routines supported:
;       Find_in_Environment - locate the start of a given string
;                               in the environment
;       Path_Crunch - concantenates a file name with a directory path from
;                       the PATH environment variable
;       Search - Finds executable or other files, given a base name
;
        include dossym.inc
        include curdir.inc
        include find.inc
        include pdb.inc
        include syscall.inc

	DATA segment para public 'DATA'
Path_str        db      "PATH="
Path_str_size   equ     $ - offset Path_Str

Comspec_str     db      "COMSPEC="
Comspec_str_size equ    $ - offset Comspec_str

comext  db      ".COM",0
exeext	db	".EXE",0

        DATA ends

	CODE segment para public 'CODE'
        assume	cs:CODE,ds:DATA

IFDEF DBCS
        extrn   IsDBCSLeadByte:near
ENDIF

;----------------------------------------------------------------------------
; Path_Crunch - takes a pointer into a environment PATH string and a file
; name, and sticks them together, for subsequent searching.
;
; ENTRY:
;   BH			--	additional terminator character (i.e., ';')
;   DS:SI		--	pointer into pathstring to be dissected
;   ES:DI               --      buffer to store target name
;   DX			--	pointer to filename
; EXIT:
;   SI			--	moves along pathstring from call to call
;   ES:DI               --      filled in with concatenated name
;   Carry set if end of path string has been reached.
;
;---------------
Path_Crunch PROC NEAR
        public  Path_Crunch
;---------------
        assume  ds:nothing
        assume  es:DATA

IFDEF DBCS
	xor	cl,cl				; clear flag for later use 3/3/KK
ENDIF

path_cr_copy:
	lodsb					; get a pathname byte
	or	al,al				; check for terminator(s)
	jz	path_seg			; null terminates segment & pathstring
	cmp	AL, BH
	jz	path_seg			; BH terminates a pathstring segment

IFDEF DBCS
	invoke	IsDBCSLeadByte			;
	jnz	NotKanj2			;
	stosb					;
	movsb					;
	MOV	CL,1				; CL=1 means latest stored char is DBCS
	jmp	path_cr_copy			;

NotKanj2:					;
	xor	cl,cl				; CL=0 means latest stored char is SBCS
ENDIF

	stosb					; save byte in concat buffer
	jmp	path_cr_copy			; loop until we see a terminator

path_seg:
        push    si                              ; save resting place in env. seg.
	mov	BL, AL				; remember if we saw null or not...

path_cr_look:					; form complete pathname
	mov	al, '\'      			; add pathname separator for suffix

IFDEF DBCS
	or	cl,cl				;
	jnz	path_cr_store			; this is a trailing byte of ECS code 3/3/KK
ENDIF
	cmp	al,es:byte ptr [di-1]
	jz	path_cr_l1

path_cr_store:					
	stosb

path_cr_l1:
	mov	SI, DX

path_cr_l2:
	lods	byte ptr es:[si]       		; tack the stripped filename onto
	stosb					; the end of the path, up to and
	or	AL, AL				; including the terminating null
	jnz	path_cr_l2

path_cr_leave:
	or	BL, BL				; did we finish off the pathstring?
	clc
        jnz	path_cr_exit			; null in BL means all gone...
	cmc

path_cr_exit:
        pop     si                              ; retrieve
	ret

        assume  es:nothing

;---------------
Path_Crunch endp
;----------------------------------------------------------------------------

;----------------------------------------------------------------------------
;   SEARCH, when given a pathname, attempts to find a file with
; one of the following extensions:  .com, .exe (highest to
; lowest priority).  Where conflicts arise, the extension with
; the highest priority is favored.
; ENTRY:
;   DX		--	pointer to null-terminated pathname
;   BX  	--	dma buffer for findfirst/next
;   AL          --      0 if we should look for .COM and .EXE extensions
;                       1 if extensions is pre-specified
; EXIT:
;   AX		--	8)  file found with .com extension, or file with
;                           pre-specified extension found
;			4)  file found with .exe extension
;			0)  no such file to be found
;   DX          --      points to resolved path name 
;   DS          --      DATA
; NOTES:
;   1)	Requires caller to have allocated executed a setdma.
;       
;---------------
; CONSTANTS:
;---------------
search_attr                 equ         attr_read_only+attr_hidden
search_file_not_found	    equ 	0
search_com		    equ 	8
search_exe		    equ 	4
fname_len		    equ 	8
fname_max_len		    equ 	23
dot			    equ 	'.'
wildchar		    equ 	'?'

search_best                 db          (?)
;---------------
Search PROC NEAR
        public Search
;---------------
        push    si                              ; 
        push    ax                              ; save extension flag
	mov	DI, DX				; working copy of pathname

	mov	CX, search_attr 		; filetypes to search for
        mov     ah, Find_First			; request first match, if any
        int     21h
        pop     ax                              
	jc	search_no_file
        
        or      al,al                           ; looking for specific ext?
        jz      search_no_ext                   ; no, jump
        mov     search_best,search_com          ; report we found best match
        jmp     short search_file_found         ; yes, found it

search_no_ext:
        mov     search_best, search_file_not_found

search_loop:
	call	search_ftype			; determine if .com, &c...
	cmp	AL, search_best 		; better than what we've found so far?
	jle	search_next			; no, look for another
	mov	search_best, AL 		; found something... save its code
	cmp	AL, search_com			; have we found the best of all?
	je	search_done

search_next:					; keep on looking
	mov	CX, search_attr
        mov     ah, Find_Next                   ; next match
        int     21h
	jnc	search_loop

search_done:					; it's all over with...
        cmp     search_best, search_file_not_found
        je      search_no_file
        cmp     search_best, search_com
        mov     si, offset comext
        je      search_move_ext
        mov     si, offset exeext

search_move_ext:
        mov     di, dx
        mov     al, '.'
        mov     cx, DIRSTRLEN
        rep     scasb
        dec     di
        movsw   
        movsw   

search_file_found:
        mov     al, search_best
	jmp	short search_exit

search_no_file: 				; couldn't find a match
	mov	AX, search_file_not_found

search_exit:
        pop     si
	ret
Search endp
;----------------------------------------------------------------------------


;----------------------------------------------------------------------------
;   SEARCH_FTYPE determines the type of a file by examining its extension.
; ENTRY:
;   BX    --	    dma buffer containing filename
; EXIT:
;   AL	    --	    file code, as given in search header
;---------------

Search_Ftype PROC NEAR
        public Search_Ftype

	push	DI
	mov	AL, search_file_not_found	; find the end of the filename
	mov	DI, BX
	add	di,Find_Buf_Pname
	mov	CX, fname_max_len
	cld
	repnz	scasb				; search for the terminating null
	jnz	ftype_exit			; weird... no null byte at end
;
; Scan backwards to find the start of the extension
;
        dec     di                              ; point back to null
        mov     cx, 5                           ; . + E + X + T + null
        std                                     ; scan back
        mov     al, '.'
        repnz   scasb
        jnz     ftype_exit                      ; must not be any extension
        inc     di                              ; point to start of extension
        cld
;
; Compare .COM
;
	mov	si,offset comext
	mov	ax,di
	cmpsw
	jnz	ftype_exe
	cmpsw
	jnz	ftype_exe
	mov	AL, search_com			; success!
	jmp	short ftype_exit
;
; Compare .EXE
;
ftype_exe:					; still looking... now for '.exe'
	mov	di,ax
	mov	si,offset exeext
	cmpsw
	jnz	ftype_fail
	cmpsw
	jnz	ftype_fail
	mov	AL, search_exe			; success!
	jmp	short ftype_exit

ftype_fail:					; file doesn't match what we need
	mov	al,search_file_not_found

ftype_exit:
	pop	DI
	ret

Search_Ftype endp

;----------------------------------------------------------------------------
;
; Find_Comspec_In_Environment - find the beginning of the COMSPEC string
;       Entry : DS = DATA
;               ES = PSP
;       Exit  : ES:DI => start of Comspec path
;       

FIND_COMSPEC_IN_environment PROC NEAR
        public Find_Comspec_In_Environment
        lea     si,Comspec_str
	mov     cx,Comspec_str_size		; cx = length of name
        jmp     short Find_in_Environment
Find_Comspec_in_Environment        endp

;----------------------------------------------------------------------------
;
; Find_Path_In_Environment - find the beginning of the PATH string
;       Entry : DS = DATA
;               ES = PSP
;       Exit  : ES:DI => start of Path directory list
;       

FIND_PATH_IN_environment PROC NEAR
        public Find_Path_In_Environment
        lea     si,Path_str
	mov     cx,Path_str_size		; cx = length of name
; fall through to following
Find_Path_in_Environment        endp


; Find_In_Environment - locate a given string in the environment
;        
; Input :       SI = name to find in environment
;               CX = length of name
;               DS = DATA
;               ES = PSP segment
;
; Output: ES:DI points to the arguments in the environment
;	  carry is set if name not found
;

Find_in_Environment PROC NEAR
        public Find_In_Environment

	cld
        xor     di,di
        mov     ax,es:[di].PDB_Environ
        or      ax,ax                          ; is there an environment?
        jz      find_nf_exit                   ; no, quit now
        mov     es,ax
        assume  es:nothing        

find1:
        push    si
        push    cx                              ; save starting values
find11:

ifdef dbcs
	lodsb
	call	IsDBCSLeadByte
	jnz	notkanj3
	dec	si
	lodsw
	inc	di
	inc	di
	cmp	ax,es:[di-2]
	jnz	find12
	dec	cx
	loop	find11
	jmp	short find12

notkanj3:
	inc	di
	cmp	al,es:[di-1]
	jnz	find12
	loop	find11

else    ;dbcs

        repe cmpsb   

endif   ;dbcs

find12:
        pop     dx
        pop     si                              ; clear stack
	jz      find_exit
        dec     di
	xor	al,al				; scan for a nul
	mov	cx,100h                         ; arbitrary size 
	repnz	scasb
	cmp	byte ptr es:[di],0              ; check for trailing null
        mov     cx,dx                           ; original count back in CX
	jnz	find1
	
find_nf_exit:
        stc					; indicate not found

find_exit:
	ret

Find_in_environment endp


CODE    ends
        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\safe.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1989 - 1991
; *                      All Rights Reserved.
; */
;===========================================================================
; 	                                    
; 
; FILE: SAFE.INC
;
; Contains all extern declarations for SAFE.ASM
;
; johnhe - 10/09/89
;===========================================================================

EXTRN		msgNoRoomForRestore:BYTE

DEBUG_MODEL	EQU	0

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\phase1.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;===========================================================================
; 
; FILE: PHASE1.ASM
;
;===========================================================================

;===========================================================================
;Include file declarations
;===========================================================================
debug	 equ	 0
	 .xlist
	 INCLUDE DOSEQUS.INC
	 INCLUDE DOSMAC.INC
	 INCLUDE SYSCALL.INC
	 INCLUDE ERROR.INC
	 INCLUDE DIRENT.INC
	 INCLUDE BPB.INC
	 INCLUDE BOOTSEC.INC
	 INCLUDE FOREQU.INC
	 INCLUDE FORMACRO.INC
	 INCLUDE IOCTL.INC
	 INCLUDE FORSWTCH.INC
	 .list
;
;---------------------------------------------------------------------------
;
; M020 : Looked for EXT_BOOT_SIG before assuming that the BPB in the boot
;	 sector is an extended one. Bug #4946
;
;---------------------------------------------------------------------------
;



;===========================================================================
; Data segment
;===========================================================================

DATA    SEGMENT PUBLIC PARA 'DATA'

;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;Constants
	EXTRN	EXIT_NO			  :ABS
	EXTRN	EXIT_FATAL		  :ABS
;Bytes
	EXTRN  CMCDDFlag		  :BYTE

	EXTRN	ValidSavedDeviceParameters:BYTE
	EXTRN	DriveToFormat		  :BYTE
	EXTRN	msgFormatNotSupported	  :BYTE
	EXTRN	msgInsertDisk		  :BYTE
	EXTRN	msgInvalidDeviceParameters:BYTE
	EXTRN	ContinueMsg		  :BYTE
	EXTRN	msgNotCompatablePart	  :BYTE
	EXTRN	msgExistingFormatDiffers  :BYTE
	EXTRN	msgNoQuickFormat	  :BYTE
	EXTRN	msgCrLf			  :BYTE
	EXTRN	msgCheckExistingDiskFormat:BYTE
	EXTRN	Extended_Error_Msg	  :BYTE
	EXTRN	old_dir			  :BYTE
	EXTRN	ExitStatus		  :BYTE
ifdef NEC_98
	EXTRN	SizeMap			  :BYTE
	EXTRN	msgInsufficientMemory	  :BYTE
endif

;Words
	EXTRN	SectorsInRootDirectory	  :WORD
	EXTRN	Paras_Per_Fat		  :WORD
	EXTRN	SwitchMap		  :WORD
	EXTRN	SwitchMap2		  :WORD
	EXTRN	SwitchCopy		  :WORD
ifdef NEC_98
	EXTRN	SASI1024Table		  :WORD
	EXTRN	SCSI1024Table		  :WORD
	EXTRN	Small2048Table		  :WORD
	EXTRN	Large512Table		  :WORD
	EXTRN	Large256Table		  :WORD
else
	EXTRN	DiskTable		  :WORD
	EXTRN	DiskTable2		  :WORD
endif
	EXTRN	RWErrorCode		  :WORD

;Pointers
	EXTRN	FatSpace		  :DWORD

;Structures
	EXTRN	SavedParams		  :BYTE
	EXTRN	DeviceParameters	  :BYTE
	EXTRN	IsExtRAWIODrv		  :BYTE
	EXTRN	SwitchDevParams		  :BYTE
	EXTRN	Read_Write_Relative	  :BYTE
	EXTRN	SetDPBPacket		  :BYTE

fBigFat			DB	FALSE
fBig32Fat		DB	FALSE
ThisSysInd		DB	0		; indicates size of FAT

StartSector		DD	?		; holds first data sector
TotalClusters		DD	?		; holds total #clusters on disk

UnformattedHardDrive	DB	?
ifdef NEC_98
SAV_INT24_OFF		DW	0		; original int 24 vector address
SAV_INT24_SEG		DW	0
endif

MediaSensePacket	A_MEDIA_SENSE		<> ; structure used in media
						   ; sensing call

; the following table provides templates for
; BPBs used in CP/M disks.
; Order is very important (used by both MSFOR and PHASE1)

CustomCPMBPBs	LABEL	BYTE
BPB320	a_BPB	<512, 2, 1, 2, 112,  2*8*40, 0ffh, 1,  8, 2, 0, 0, 0, 0>
BPB160  a_BPB   <512, 1, 1, 2,  64,  1*8*40, 0feh, 1,  8, 1, 0, 0, 0, 0>
BPB360  a_BPB  	<512, 2, 1, 2, 112,  2*9*40, 0fdh, 2,  9, 2, 0, 0, 0, 0>
BPB180  a_BPB	<512, 1, 1, 2,  64,  1*9*40, 0fch, 2,  9, 1, 0, 0, 0, 0>

EndCustomCPMBPBs LABEL	BYTE

; This must folow CustomCPMBPBs

BPB12	a_BPB	<512, 1, 1, 2, 224, 2*15*80, 0F9h, 7, 15, 2, 0, 0, 0, 0>
BPB720	a_BPB	<512, 2, 1, 2, 112, 2* 9*80, 0F9h, 3,  9, 2, 0, 0, 0, 0>
BPB1440	a_BPB	<512, 1, 1, 2, 224, 2*18*80, 0F0h, 9, 18, 2, 0, 0, 0, 0>
BPB2880	a_BPB	<512, 2, 1, 2, 240, 2*36*80, 0F0h, 9, 36, 2, 0, 0, 0, 0>
ifdef NEC_98
BPB640	a_BPB	<512, 2, 1, 2, 112, 2* 8*80, 0FBh, 2,  8, 2, 0, 0, 0, 0>
BPB1250	a_BPB	<1024,1, 1, 2, 192, 2* 8*77, 0FEh, 2,  8, 2, 0, 0, 0, 0>
BPB128	a_BPB	<512,4,1, 2, 512, 0, 0F0h, 0F3h, 019h, 1, 0,0, 0CBE0h, 03h>
BPB230	a_BPB	<512,8,1, 2, 512, 0, 0F0h, 0DAh, 019h, 1, 0,0, 0CF75h, 06h>
BPB650	a_BPB	<512,020h,1, 2, 512, 0, 0F0h, 09Fh, 019h, 1, 0,0, 0D040h, 013h>
endif
EndStandardBPBs	LABEL	BYTE	

				; the following table indicates the switches
				; which must be set for the given CP/M media
CPMSwitchTable	LABEL	BYTE
	dw	Switch_4 + Switch_8		;320K
	dw	Switch_1 + Switch_4 + Switch_8	;160K
	dw	Switch_4			;360K
	dw	Switch_1 + Switch_4		;180K

; ========================================================================
; Tables added for media sense support in 5.00.
; ========================================================================

MediaTable	LABEL WORD

ifdef NEC_98
	dw	0			; 0
	dw	OFFSET BPB12		; 1	/5
	dw	OFFSET BPB720		; 2	/9
	dw	0			; 3
	dw	OFFSET BPB1250		; 4	/M
	dw	0			; 5
	dw	0			; 6
	dw	OFFSET BPB1440		; 7	/4
	dw	0			; 8
	dw	OFFSET BPB2880		; 9	not supported! but rest.
else
	dw	0			; 0
	dw	0 			; 1
	dw	OFFSET BPB720		; 2
	dw	0			; 3
	dw	0			; 4
	dw	0			; 5
	dw	0			; 6
	dw	OFFSET BPB1440		; 7
	dw	0			; 8
	dw	OFFSET BPB2880		; 9
endif

EndMediaTable	LABEL WORD

DATA	ENDS

;===========================================================================
; Executable code segment
;===========================================================================

CODE	SEGMENT PUBLIC PARA	'CODE'
	ASSUME	CS:CODE, DS:DATA, ES:DATA


;===========================================================================
; Declarations for all externs
;===========================================================================

;Functions
	EXTRN	AccessDisk		  :NEAR
	EXTRN	USER_STRING		  :NEAR
	EXTRN	CrLf			  :NEAR
	EXTRN	CheckSwitches		  :NEAR
	EXTRN	Read_Disk		  :NEAR
	EXTRN	Yes?			  :NEAR
ifdef NEC_98
	EXTRN	GetDeviceParameters	  :NEAR
	EXTRN	Alloc_Dir_Buf		  :NEAR
	EXTRN	Alloc_Fat_Buf		  :NEAR
	EXTRN	Alloc_Fat_Sec_Buf	  :NEAR
	EXTRN	Alloc_DirBuf2		  :NEAR
	EXTRN	Alloc_Cluster_Buf	  :NEAR
ifdef OPKBLD
	EXTRN	Do_Switch_S		  :NEAR
endif   ;OPKBLD
	EXTRN	ZeroAllBuffers		  :NEAR
endif   ;NEC_98

;Labels
	EXTRN	FatalExit		  :NEAR
	EXTRN	ExitProgram		  :NEAR


;===========================================================================
; Declarations for all publics in this module
;===========================================================================

	PUBLIC	Phase1Initialisation
	PUBLIC	MediaSense
	PUBLIC	TargPrm
	PUBLIC	CopyToSwitchDevParams
	PUBLIC	CompareDevParams
	PUBLIC	LoadSwitchDevParams
	PUBLIC	DetermineExistingFormat
	PUBLIC	DetermineExistingFormatNomsg
	PUBLIC	IsValidBpb
	PUBLIC	ResetDeviceParameters
	PUBLIC	DetermineCPMFormat
	PUBLIC	SetCPMParameters
	PUBLIC	Set_BPB_Info
	PUBLIC	Scan_Disk_Table
	PUBLIC	Calc_Big16_Fat
	PUBLIC	Calc_Big32_Fat
	PUBLIC	Calc_Small_Fat
	PUBLIC	SetStartSector
	PUBLIC	SetfBigFat
	PUBLIC	GetTotalClusters
	PUBLIC	fBigFat
	PUBLIC	fBig32Fat
	PUBLIC	StartSector
	PUBLIC	TotalClusters
	PUBLIC	CustomCPMBPBs
	PUBLIC	CPMSwitchTable
	PUBLIC	EndStandardBPBs
	PUBLIC	BPB720
ifdef NEC_98
	PUBLIC	BPB640
	PUBLIC	BPB12
	PUBLIC	BPB1250
	PUBLIC	BPB128
	PUBLIC	BPB230
	PUBLIC	BPB650
endif
	PUBLIC	UnformattedHardDrive

; ==========================================================================
; Phase1Initialisation:
;    This routine sets up fBigFat
;    It also does most	of the other initialisation
;
;    Algorithm:
;	Perform media sensing and if present adjust DeviceParameters
;	Check switches against parameters
;	Use switches to modify device parameters
;	Save a copy of current DeviceParameters in SwitchDevParams
;
;	IF (!SWITCH_U)
;	{
;	  IF (!ValidBootRecord || !ValidBPB)
;	    set SWITCH_U
;	  ELSE
;	  {
;	    get device layout from BPB on disk
;	    IF (DeviceParameters = SwitchDevParams)
;	      do safe/quick format
;	    ELSE
;	    {
;	      IF (Switch_N || Switch_T || Switch_F)
;	      {
;	        Issue warning
;	        Format with BPB from SwitchDevParams if user continues
;	      }
;	      ELSE	
;	        do safe/quick format
;	    }
;	  }
;	}
;	
;	Calculate start sector (first sector not used by DOS)
;	fBig32Fat = (((TotalSectors - StartSector)/SectorsPerCluster) >= 65526)
;	fBigFat = (((TotalSectors - StartSector)/SectorsPerCluster) >= 4086)
; ==========================================================================

Phase1Initialisation proc near

    ; use DevParms to check for removable
	test	DeviceParameters.DP_DeviceAttributes,1
    .errnz EDP_DEVICEATTRIBUTES NE DP_DEVICEATTRIBUTES
	jnz	@F				; Bit 0=1 --> not removable

    ; New media sensing call added for 5.00 will see if
    ; see if media sensing is avaliable and if it is will
    ; reset DeviceParameters to the real parameters for
    ; the type of disk being formatted.

ifndef NEC_98
	call	MediaSense
else
	cmp	DeviceParameters.DP_DeviceType, DEV_HARDDISK	; Hard disk?
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	@F						; No

    ; We ignore INT24 in order not to be stop formatting
    ; when "INT21 AH=32" is called.

    ; Set my INT24
	push	es
	mov	ah, 35h
	mov	al, 24h
	int	21h			; get INT24's vector address
	mov	SAV_INT24_OFF, bx	; save original INT24
	mov	SAV_INT24_SEG, es	; save original INT24
	pop	es

	push	ds
	push	cs
	pop	ds
	mov	ah, 25h
	mov	al, 24h
	mov	dx, OFFSET MY_INT24
	int	21h			; set my INT24
	pop	ds

    ; Update Default BPB
	push	ds
	push	bx
	mov	ah, 32h
	mov	dl, DriveToFormat
	inc	dl
	int	21h			; Get Drive Parameter Block
	pop	bx
	pop	ds

    ; Set original INT 24
	push	ds
	push	dx
	mov	ah, 25h
	mov	al, 24h
	mov	ds, SAV_INT24_SEG
	mov	dx, SAV_INT24_OFF
	int	21h			; set original INT24
	pop	dx
	pop	ds

    ; Get default BPB
	lea	DX, DeviceParameters
	mov	DeviceParameters.DP_SpecialFunctions, 0
	call	GetDeviceParameters

    ; Allocate memory
	call	Alloc_Dir_Buf		; Allocate root directory buffer
	jc	gi_memerr

	call	Alloc_Fat_Buf		; Allocate FAT buffer
	jc	gi_memerr

	call	Alloc_Fat_Sec_Buf	; Allocate fat sector buffer
	jc	gi_memerr

	call	Alloc_DirBuf2		; Allocate 1-sector buffer DirBuf (general-
					; purpose use)
	jc	gi_memerr

	call	Alloc_Cluster_Buf	; get room for retry buffer

ifdef OPKBLD
	call	Do_Switch_S		; Load system files if needed
					; carry flag determined by Do_Switch_S
else
        clc
endif   ;OPKBLD
	call	ZeroAllBuffers		; initialize buffers
	jmp	short @f

gi_memerr:
	Message msgInsufficientMemory
	stc
	ret
endif
@@:
					; Ensure that there is	a valid #
					; of Sectors in	the track table

	mov	ValidSavedDeviceParameters, 1
	cmp	IsExtRAWIODrv,0
	je	OldTabOff2

	mov	SavedParams.EDP_TrackTableEntries, 0
	mov	DeviceParameters.EDP_TrackTableEntries,0
	jmp	short SetBPBnf

OldTabOff2:
	mov	SavedParams.DP_TrackTableEntries, 0
					; Initialise to zero to see if
					; CheckSwitches define track layout
	mov	DeviceParameters.DP_TrackTableEntries,0
SetBPBnf:
	call	Set_BPB_Info		; Check to see if we are on
					; Fat system.If not set BPB to proper
					; values for format.
SetMTsupp:
					; Check switches against parameters
					; and use switches to modify device
					; parameters
	call	CheckSwitches
	retc

	call	CopyToSwitchDevParams	; Save a copy of deviceparameters as
					; returned by CheckSwitches

	mov	ax,SwitchMap		; No need to check existing format
	and	ax,SWITCH_U+SWITCH_Q
	cmp	ax,SWITCH_U		; if unconditional format specified
	jnz	CheckExistingFormat
	jmp	DevParamsOk

CheckExistingFormat:

    ; New call added for 5.00 to see if the disk has been
    ; previously formatted, and if so this will reset
    ; DeviceParameters to those of the existing format.

	call	DetermineExistingFormat   
	jnc	ValidExistingFormat	; carry clear if valid existing format

InvalidExistingFormat:
	and	RWErrorCode,0ffh	; check low byte for 'drive not ready' error	
	cmp	RWErrorCode,ERROR_I24_NOT_READY	;'not ready' error  code = 2
	jne	CheckForQ		; no error reading disk
		
					; 'not ready' error occurred, give msg
	mov	AX,21			; load AX with extended error code for not ready
SetFatalErr:
	Extended_Message		; deliver message "Not Ready"
	mov	ExitStatus,EXIT_FATAL	; M006;
	stc
	jmp	EndPhase1

CheckForQ:
	test	SwitchMap,SWITCH_Q	; Need to give message if /q was specified
	jz	MakeUnconditional

	test	SwitchCopy,(SWITCH_T or SWITCH_N or SWITCH_F)	; did user specify size?
	jnz	TurnOffQ		; do an unconditional format at specified size
ifdef OPKBLD
                                        ; Let OEM's quickformat a clean disk
        test    DeviceParameters.DP_DeviceAttributes,1
        jnz      DevParamsOk                      ; Bit 0=1 --> not removable
endif   ;OPKBLD
	Message	msgNoQuickFormat	; Inform user quick format cannot be done
	call	Yes?			; Continue with unconditional format?

	pushf
	Message	msgCrLf
	popf

	jnc	TurnOffQ
	mov	ExitStatus,EXIT_NO	; load exit code 5 (response is 'no')
	jmp	ExitProgram		; User wants to exit

TurnOffQ:
	and	SwitchMap,NOT SWITCH_Q	; Turn off /Q to continue

MakeUnconditional:
	or	SwitchMap,SWITCH_U	; Enable /U since invalid existing format
	or	SwitchMap2, Switch2_C	; Enable /C since invalid existing format
	jmp	SHORT DevParamsOk	; Device parameters will not have been
					; modified since invalid existing format

ValidExistingFormat:
	call	CompareDevParams	; see if SwitchDevParams = DeviceParameters
	jnc	DevParamsOk		; they are equal

					; Check if user had specified a format
					; size, since DeviceParameters on disk
					; are different.

	test	SwitchMap,SWITCH_Q	; special case where size was specified
					; together with /Q :- use size specified
					; only if invalid existing format
	jnz	DevParamsOk		; use the parameters found on disk
	or	SwitchMap,SWITCH_U	; Enable /U since new format specified
	or	SwitchMap2, Switch2_C	; Enable /C since new format specified
	call	LoadSwitchDevParams	; Set deviceparameters to SwitchDevParams
					; i.e. follow user-specified size
DevParamsOk:
	call	SetDOS_Dpb		; m035 Setup default DOS DPB for this
					;      drive (for memory cards).
	jc	SetFatalErr
					; Store sector table info (layout of
					; each track)
	mov	CX, DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerTrack;CX = loop count
    .errnz EDP_BPB NE DP_BPB
	mov	AX, 1					       ;AX = sector #
	mov	BX, DeviceParameters.DP_BPB.oldBPB.BPB_bytesPerSector ;BX = sector size
	cmp	IsExtRAWIODrv,0
	je	OldTabOff

	cmp	DeviceParameters.EDP_TrackTableEntries,0
	jne	TrackLayoutSet		; There is a good track layout
	mov	DeviceParameters.EDP_TrackTableEntries,CX
	lea	DI, DeviceParameters.EDP_SectorTable
	jmp	short GotTabOff

OldTabOff:
	cmp	DeviceParameters.DP_TrackTableEntries,0
	jne	TrackLayoutSet		; There is a good track layout
	mov	DeviceParameters.DP_TrackTableEntries,CX
	lea	DI, DeviceParameters.DP_SectorTable
GotTabOff:
	cld
LoadSectorTable:
	stosw				; Write the sector number
	xchg	AX, BX			; Get the sector size in bytes
	stosw				; Write the sector size
	xchg	AX, BX
	inc	AX			; Go to the next sector
	loop	LoadSectorTable

TrackLayoutSet:	    
	call	SetStartSector
	call	SetfBigFat
	call	GetTotalClusters
	clc

EndPhase1:
	return

Phase1Initialisation endp

; =========================================================================
;
;   MediaSense
;	Checks for media sensing via IOCtl 440d subfuction 0868.
;	If sensing is supported the user will be prompted to insert
;	the disk if it's not detect and then the device parameters
;	will be set according to the type of media being used.
;
;	Before we can use the type returned we must be sure it's
;	not a larger size disk than is formattable in the drive.
;	We can do this by checking the media type byte in the
;	saved device parameters.
;
;   Input:
;	DriveToFormat	- Must have already been set
;
; =========================================================================

MediaSense PROC NEAR

	mov	BL, DriveToFormat
	inc	BX

	mov	CX, (RAWIO shl 8) or SENSE_MEDIA_TYPE
	cmp	IsExtRAWIODrv,0
	je	DoIOCTL1
	mov	CX, (EXTRAWIO shl 8) or SENSE_MEDIA_TYPE
DoIOCTL1:
	lea	DX,MediaSensePacket

					; First check if BIOS supports call
	mov	AX, (IOCTL shl	8) or IOCTL_QUERY_BLOCK
	int	21h
	jc	MediaSenseExit

					; Now do actual call
	mov	AX, (IOCTL shl	8) or GENERIC_IOCTL
	int	21h

	jnc	GotMediaSense

	cmp	AL,error_not_ready
	jne	MediaSenseExit		; Machine does not support media sensing

	call	TargPrm			; Insert disk prompt
	jmp	SHORT MediaSense	; Retry the operation

		; See if the type of media inserted is the same as the
		; default for this type of drive and if not check to
		; be sure it's 

GotMediaSense:
	mov	AL,MediaSensePacket.MS_DEVICETYPE ; AL == media type
	cmp	SavedParams.DP_DEVICETYPE,AL 	  ; If the media in the
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jl	MediaSenseExit		; drv is > default size, use default

					; Load BPB for sensed media
	xor	AH,AH
	shl	AX,1			; AX == word offset in media table
	mov	BX, offset MediaTable	; BX -> Start of media table
	add	BX, AX			; BX -> Sensed type in media table

	cmp	BX, offset EndMediaTable ; Make sure we're still in the table
	jge	MediaSenseExit


	mov	SI,[BX]			; DS:SI -> Sensed device parameters
	or	SI,SI
	je	MediaSenseExit		; Unknown Media?!

	lea	DI, DeviceParameters.DP_BPB ; ES:DI -> Format parameters
    .errnz EDP_BPB NE DP_BPB

	mov	CX, size A_BPB		; CX = bytes to move
	cmp	IsExtRAWIODrv,0
	je	DoIOCTL2
	mov	CX, size A_BF_BPB	; CX = bytes to move
DoIOCTL2:
	cld
	rep	movsb
;
; Update the D_Cylinders. With 120mb floppies the cylinders field does change
; as opposed 720/1.44 drives
; We just back calculate the cylinders from sec/track, heads & total sectors
;

.386
	push	edx
	push	ecx
	push	eax
	movzx	eax, DeviceParameters.DP_BPB.A_BPB_Heads
	movzx	edx, DeviceParameters.DP_BPB.A_BPB_SectorsPerTrack
	mul	edx
	mov	ecx, eax		; save sectors per cylinder in ECX
	xor	eax, eax
	mov	ax, DeviceParameters.DP_BPB.A_BPB_TotalSectors
	or	ax, ax
	jnz	mse_sec_ok
	mov	eax, dword ptr DeviceParameters.DP_BPB.A_BPB_BigTotalSectors
mse_sec_ok:
	div	ecx			; EAX = number of cylinders
	mov	DeviceParameters.DP_Cylinders, ax
	pop	eax
	pop	ecx
	pop	edx
.8086

MediaSenseExit:
	ret

MediaSense ENDP

;========================================================================
;
;  TargPrm :	This procedure prompts the user to insert the target disk
;		into the drive.
;
;========================================================================

TargPrm PROC NEAR

	 mov	 AL, DriveToFormat
	 call	 AccessDisk
	 Message MsgInsertDisk
	 Message ContinueMsg
	 call	 USER_STRING
	 call	 CrLf
	 ret

TargPrm ENDP

;=========================================================================
;
;  CopyToSwitchDevParams :	This procedure copies the structure
;				DeviceParameters into SwitchDevParams.
;  Registers destroyed :	CX,DI,SI
;  Assumes :			DS:DATA, ES:Nothing
;  
;=========================================================================

CopyToSwitchDevParams	proc	NEAR

	push	DS
	pop	ES

	mov	DI,OFFSET SwitchDevParams		; ES:DI --> dest. parms

	mov	SI,OFFSET DeviceParameters		; DS:SI --> src. parms

	mov	CX,SIZE EA_DEVICEPARAMETERS		; byte transfer count

	cld
	rep	movsb

	ret

CopyToSwitchDevParams	endp

;=========================================================================
;
;  CompareDevParams :		This procedure compares the structure
;				DeviceParameters with SwitchDevParams.
;  Registers destroyed :	CX,DI,SI
;  Assumes :			DS:DATA, ES:Nothing
;
;=========================================================================

CompareDevParams	proc	NEAR

	push	DS
	pop	ES

	mov	DI,OFFSET SwitchDevParams	; ES:DI --> dest. parms

	mov	SI,OFFSET DeviceParameters	; DS:SI --> src. parms

	mov	CX,SIZE A_DEVICEPARAMETERS	; Set up count in bytes
	cmp	IsExtRAWIODrv,0
	je	DoCmp
	mov	CX,SIZE EA_DEVICEPARAMETERS	; Set up count in bytes
DoCmp:
	cld					; Set the direction
	repe	cmpsb				; Compare the two BPBs
	jz	EqualParams			; If ZR then BPBs matched

NotEqualParams:
	stc					; Signal BPBs don't match
	jmp	SHORT CompareParamsExit

EqualParams:
	clc					; Signal BPB matches

CompareParamsExit:
	ret

CompareDevParams	endp

;=========================================================================
;
;  LoadSwitchDevParams :	This procedure copies the structure 
;				SwitchDevParams into DeviceParameters.
;  Registers destroyed :	CX,DI,SI
;  Assumes :			DS:DATA,ES:Nothing
;
;=========================================================================

LoadSwitchDevParams	proc	NEAR

	push	DS
	pop	ES

	mov	DI,OFFSET DeviceParameters		; ES:DI --> dest. parms

	mov	SI,OFFSET SwitchDevParams		; DS:SI --> src. parms

	mov	CX,SIZE EA_DEVICEPARAMETERS		; byte transfer count

	cld
	rep	movsb

	ret

LoadSwitchDevParams	endp

;=========================================================================
;
;  DetermineExistingFormat :	This procedure will check if there is a
;				valid format existing on the disk, in 
;				which case DeviceParameters will be reset
;				to that format.
;				
;				It is assumed the destination disk is 
;				already in the drive.
;
;  DetermineExistingFormatNoMsg : alternate entry with no message
;
;
;  Calls :	IsValidBpb
;		ResetDeviceParameters
;		DetermineCPMFormat
;
;  Called by :  Phase1Initialisation
;
;=========================================================================

DetermineExistingFormat	proc	near

	push	DS
	push	ES
	Set_Data_Segment			;ensure addressibility

	cmp	UnformattedHardDrive,TRUE
	jne	@F
	jmp	InvalidBootRecord

@@:
	Message	msgCheckExistingDiskFormat
	jmp	short DetermineExistCommon

DetermineExistingFormatNoMsg:

	push	ds
	push	es
	set_data_segment
	cmp	UnformattedHardDrive,TRUE
	je	InvalidBootRecord

DetermineExistCommon:
 	xor	DX,DX				; Starting sector  to 0
	mov	AL,DriveToFormat		; Set drive number
	mov	AH,DH				; Signal this is a read AH=0
	lds	BX,FatSpace			; Load transfer address
	assume	DS:NOTHING,ES:DATA

	mov	CX,2				; # of sectors to read
						; we are accessing < 32mb
	mov	ES:Read_Write_Relative.Start_Sector_High,0
 
	call	Read_Disk			; Disk sector read
 
	jnc	BootCheck
	mov	ES:RWErrorCode,AX		; Save error code (if any)
	jmp	InvalidbootRecord
BootCheck:
	cmp	word ptr [bx+3], 'SM'
	jne	@F
	cmp	word ptr [bx+5], 'MD'
	jne	@F
	cmp	word ptr [bx+7], '3F'
	jne	@F
	mov	es:RWErrorCode, 0
	stc
	jmp	short EndDetermine
@@:
	cmp	BYTE PTR [BX],0e9h		; Check for JMP opcode
	je	TestBootSignature		; If Ok then check signature
						; we can not know #reserved sectors)
	cmp	BYTE PTR [BX],0ebh		; Else check for SHORT jmp	
	jne	TryCPM				; No match then not valid boot
	cmp	BYTE PTR [BX+2],90h		; Now check for NOP opcode
	jne	TryCPM				; No match then not valid boot

TestBootSignature:
ifndef NEC_98
	cmp	WORD PTR [BX + 510],0aa55h	; Check for 55 AA sequence
	jne	TryCPM				; Error if not equal
endif

CheckTheBpb:
	call	IsValidBpb
	jc	TryCPM				; CY --> Invalid format

	call	ResetDeviceParameters		; set DeviceParameters to
	clc					; existing ones on the disk
	jmp	SHORT EndDetermine

TryCPM:
ifdef NEC_98
	cmp	ES:DeviceParameters.DP_DeviceType,DEV_HARDDISK
	je	InvalidBootRecord
endif
						; check in case a CP/M disk is present
	test	ES:DeviceParameters.DP_DeviceAttributes,1
    .errnz EDP_DEVICEATTRIBUTES NE DP_DEVICEATTRIBUTES
	jnz	InvalidBootRecord		; Bit 0=1 --> not removable

	call	DetermineCPMFormat
	jmp	SHORT EndDetermine 		; CP/M disk present, DeviceParameters
						; will have been modified
						; Carry propagated up to
						; Note: DS can be anything

InvalidBootRecord:
	stc					;flag invalid format

EndDetermine:
	pop	ES
	pop	DS

	ret

DetermineExistingFormat	endp

;=========================================================================
;
; IsValidBpb :	This procedure will inspect the BPB loaded into
;			memory by the DetermineExistinFormat procedure.  
;
; Input  :	DS:BX Buffer holding boot sector (FatSpace) ; M016
; Output :	BPB is valid   - NC
;		BPB is invalid - CY
;
; Assumes:	DS:BX: FatSpace (preserved); M016
;
;=========================================================================

IsValidBpb	proc	near

	assume	DS:NOTHING,ES:DATA

	push	BX			; M016; preserve BX
	lea	bx,[bx.bsBPB]
ifdef NEC_98
;;;	It is possible NEC_98's BPB is not 200h.
	cmp	[BX.oldBPB.BPB_BytesPerSector],200h	   ; check BytesPerSector=512
	je	@F
	cmp	[BX.oldBPB.BPB_BytesPerSector],400h	   ; check BytesPerSector=1024
	je	@F
	cmp	[BX.oldBPB.BPB_BytesPerSector],800h	   ; check BytesPerSector=2048
	jne	NotValidBpb
@@:
else
	cmp	[BX.oldBPB.BPB_BytesPerSector],200h    ; check BytesPerSector=512
	jne	NotValidBpb
endif

	and	[BX.oldBPB.BPB_TotalSectors],0ffffh ; check that both TotalSectors
	jnz	ResetBigTotalSectors			     ; and BigTotalSectors are not zero
	and	[BX.oldBPB.BPB_BigTotalSectors],0ffffh	   ; low word
	jnz	CheckMore
	and	[BX.oldBPB.BPB_BigTotalSectorsHigh],0ffffh ; high word
	jz	NotValidBpb
	jmp	SHORT CheckMore

ResetBigTotalSectors:			; if TotalSectors<>0 set 
	and	[BX.oldBPB.BPB_BigTotalSectors],0h    ; BigTotalSectors to zero
	and	[BX.oldBPB.BPB_BigTotalSectorsHigh],0h

CheckMore:
	and	[BX.oldBPB.BPB_SectorsPerFAT],0ffffh ; check SectorsPerFat <> 0
	jnz	CheckMore2
    ;
    ; Is a FAT32 BPB
    ;
	and	[BX.BGBPB_BigSectorsPerFat],0ffffh
	jnz	CheckMore2
	and	[BX.BGBPB_BigSectorsPerFatHi],0ffffh
	jz	NotValidBpb
CheckMore2:
	cmp	[BX.oldBPB.BPB_SectorsPerTrack],1h ; check 0 < SectorsPerTrack < 64
	jb	NotValidBpb
	cmp	[BX.oldBPB.BPB_SectorsPerTrack],3fh
	ja	NotValidBpb
	
	cmp	[BX.oldBPB.BPB_Heads],1h    ; check 0 < Heads < 256
	jb	NotValidBpb
	cmp	[BX.oldBPB.BPB_Heads],0ffh
	ja	NotValidBpb

BpbIsValid:
	clc
	jmp	SHORT EndIsValidBpb

NotValidBpb:
	stc

EndIsValidBpb:
	pop	BX			; M016; restore BX
	ret

IsValidBpb	endp

;=========================================================================
;
; ResetDeviceParameters :	This procedure will copy the BPB of the
;				disk into DeviceParameters.  It will also
;				set the fields DP_CYLINDERS and  DP_MEDIATYPE,
;				for removable media.
;
; Inputs :	DS:BX Boot sector held in FatSpace ; M016
; Output :	Modified DeviceParameters
; Modifies:	ES,SI,DI,CX,DX,BX,AX
; Assumes:	DS:BX Boot sector, ES:DATA
;
;=========================================================================

ResetDeviceParameters	proc	near

	assume	DS:NOTHING,ES:DATA

	lea	si,[bx.bsBPB]		; Use SI instead of BX for copy
					; DS:SI source BPB in buffer

    ;No need to modify DP_CYLINDERS,DP_MEDIATYPE
    ;(and DP_DEVICETYPE) for fixed disks.

ifdef NEC_98
	cmp	ES:DeviceParameters.DP_DeviceType,DEV_HARDDISK
	je	CopyBpb
endif
    ;use DevParms to check for removable
	test	ES:DeviceParameters.DP_DeviceAttributes,1
    .errnz EDP_DEVICEATTRIBUTES NE DP_DEVICEATTRIBUTES
	jnz	CopyBpb				; Bit 0=1 --> not removable

    ;first compute total cylinders as
    ;total sectors /(sectors per track)*#heads
.386
	movzx	EAX,[SI.oldBPB.BPB_TotalSectors]      ;get total sectors
.8086
	or	AX,AX			;do we need to use Big total sectors?
	jnz	GotTotalSectors		;don't need to if not zero

UseBigTotalSectors:
.386
	mov	EAX,DWORD PTR [SI.oldBPB.BPB_BigTotalSectors]

GotTotalSectors:			    ;now EAX has total #sectors
	movzx	EBX,[SI.oldBPB.BPB_SectorsPerTrack]    ;get sectors per track
	xor	edx,edx
	div	EBX
.8086
	xor	DX,DX			    ;clear the remainder
	mov	CX,[SI.oldBPB.BPB_Heads]    ;get number of heads
	div	CX
	or	DX,DX
	jz	CylindersOk
	inc	AX

;BUGBUG: Arithmetic may result in CYLINDERS being 1 less than actual value,
;	 for big disks (hence this calculation is skipped for fixed disks)
; PYS: fixed using same code as MSINIT.ASM

CylindersOk:
	mov	ES:DeviceParameters.DP_CYLINDERS,AX
    .errnz EDP_CYLINDERS NE DP_CYLINDERS

    ;now determine DP_MEDIATYPE & DP_DEVICETYPE

	mov	ES:DeviceParameters.DP_MEDIATYPE,0	; init. to zero
    .errnz EDP_MEDIATYPE NE DP_MEDIATYPE
	cmp	AX,40					; only 360K or less has 40 cylinders
	jne	CopyBpb					; MEDIATYPE has been set

	cmp	ES:DeviceParameters.DP_DEVICETYPE,DEV_5INCH96TPI
    .errnz EDP_DEVICETYPE NE DP_DEVICETYPE
	jne	CopyBpb

Is360K:
	mov	ES:DeviceParameters.DP_MEDIATYPE,1	; set to 1 only for 360K in 1.2M
    .errnz EDP_MEDIATYPE NE DP_MEDIATYPE


;BUGBUG: Changing the value of DEVICETYPE can result in SwitchDevParams !=
;	 DeviceParameters, and hence a just-formatted 360K disk may not be
;	 recognized!  -is it really necessary to set DEVICETYPE?

CopyBpb:
	mov	DI,OFFSET ES:DeviceParameters.DP_BPB
    .errnz EDP_BPB NE DP_BPB

    ;ES:DI destination BPB in DeviceParameters

	mov	CX,SIZE BIGFATBPB	;byte transfer count
	cmp	[si.BPB_SectorsPerFAT],0 ;FAT32 BPB?
	je	@f			;Yes

	mov	CX,SIZE BPB		;byte transfer count
	cmp	byte ptr [si.bsBootSignature-bsBPB], 29h  ; extended BPB ?
	je	@f			; Yes
	mov	cx,((SIZE BPB)-6)	; no, ancient small BPB
@@:
	cld				;set the direction  
	rep	movsb			;write the new BPB
	ret

ResetDeviceParameters	endp

;=========================================================================
;
; DetermineCPMFormat :		This procedure will check the media 
;				descriptor in the FAT of the disk.  The
;				disk has a valid CP/M format if this is
;				in the range FCh - FFh.
;
;  Assumes :	DS:BX points to boot sectors. ; M016
;  Modifies :	DS ; M016
;  Returns :	NC - Valid CP/M format detected
;		     DeviceParameters modified
;		CY - Invalid format
;
;==========================================================================

DetermineCPMFormat	proc	NEAR

	assume	DS:NOTHING,ES:DATA	

	cmp	ES:DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector,512
    .errnz EDP_BPB NE DP_BPB
	stc				; Checking default for drive
					; (cannot check BPB since disk
					;  may not have one)
	jne	ExitDetCPMFormat
	add	BX,512			; DS:BX points to first FAT


	mov	CL,BYTE PTR [BX]  	; load media descriptor byte into CL
	cmp	CL,0fch
	jb	ExitDetCPMFormat	; below = carry, how practical!

	Set_Data_Segment		; For the two following calls

	call	SetCPMParameters	; modify DeviceParameters accordingly

ExitDetCPMFormat:
	ret

DetermineCPMFormat	endp

;=========================================================================
;
; SetCPMParameters :	This procedure copies the required BPB from the
;			CP/M BPB table into DeviceParameters.BPB.  Also,
;			DeviceParameters.MediaType is set to 1, and
;			DeviceParameters.Cylinders is set to 40.
;			
;			In case the disk has a 160K or 320K format, the /8
;			switch is set, so that 
; Returns :	NC - DeviceParameters updated
;		CY - Error (out of table boundaries)
;
; Modifies :	AX,BX,CX,DX,SI,DI,ES
;		DeviceParameters
;
; Assumes :	CL contains media descriptor byte
;
;=========================================================================

SetCPMParameters	proc	NEAR

	xor	AX,AX			; find index into CP/M BPB table by
	mov	AL,0ffh			; subtracting media descriptor from ffh
	sub	AL,CL

	mov	BX,SIZE A_BPB		; now find byte offset by multiplying
	mul	BX			; by entry size
	
	lea	SI,CustomCPMBPBs
	add	SI,AX
	cmp	SI,OFFSET EndCustomCPMBPBs ; check we are still in table
	ja	NotInTable

	lea	DI,DeviceParameters.DP_BPB
    .errnz EDP_BPB NE DP_BPB

	mov	CX,SIZE A_BPB		; set up byte transfer count

	push	DS			; set ES=DS
	pop	ES		

	cld				;set the direction  
	rep	movsb			; load the BPB

	mov	BYTE PTR DeviceParameters.DP_MediaType,1
    .errnz EDP_MEDIATYPE NE DP_MEDIATYPE
	mov	BYTE PTR DeviceParameters.DP_Cylinders,40
    .errnz EDP_CYLINDERS NE DP_CYLINDERS

	clc
	jmp	SHORT ExitSetCPMParm

NotInTable:
	stc

ExitSetCPMParm:
	ret

SetCPMParameters	endp

;=========================================================================
; Set_BPB_Info	 :	 When we have a	Fat count of 0,	we must	calculate
;			 certain parts of the BPB.  The	following code
;			 will do just that.
;
;	 Inputs	 : DeviceParameters
;
;	 Outputs : BPB information
;=========================================================================

Procedure Set_BPB_Info			; Calc new BPB

	Set_Data_Segment		; Set up addressibility
ifdef NEC_98
	cmp	DeviceParameters.DP_BPB.BPB_NumberOfFats,00h
	je	@F 		; Yes, 0 FatS specified

	cmp	DeviceParameters.DP_DeviceType,DEV_HARDDISK
	je	$$IF101
	test	DeviceParameters.DP_DeviceAttributes,1
	jnz	$$IF101				; Bit 0=1 --> not removable

	cmp	CMCDDFlag,Yes			; Memory card?
	je	$$IF101				; We don't need current BPB

	lea	DX, DeviceParameters
	mov	DeviceParameters.DP_SpecialFunctions,INSTALL_FAKE_BPB
	call	GetDeviceParameters
	jmp	short $$IF101
@@:
else
					; See if we have 0 Fats specified
	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_NumberOfFats,00h
    .errnz EDP_BPB NE DP_BPB
	jne	$$IF101 		; Yes, 0 FatS specified
endif
	call	Scan_Disk_Table 	; Access disk table
	mov	BL,BYTE PTR DS:[SI+8]	; Get Fat type
	mov	CX,WORD PTR DS:[SI+4]	; Get Sectors/cluster
	mov	DX,WORD PTR DS:[SI+6]	; Number of entries for the root DIR

	mov	DeviceParameters.DP_BPB.oldBPB.BPB_RootEntries,DX
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster,CH
ifdef NEC_98
	;;
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_MediaDescriptor,Fixed_Disk

	;;and ReservedSector not Fixed 1.(Large Partition)
	;; reserved sector >= 1024 bytes (NEC)

	cmp	word ptr DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector,0200h
	je	$$reserved_2
	cmp	word ptr DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector,0100h
	;Chicago is not supported 256 secters but for safely.
	je	$$reserved_4

	mov	DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors,0001h
	jmp	short @F
$$reserved_2:
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors,0002h
	jmp	short @F
$$reserved_4:
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors,0004h
@@:
else
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector,0200h
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors,0001h
endif
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_NumberOfFats,02h
    .errnz EDP_BPB NE DP_BPB

	cmp	BL,fBig32		; 32-bit Fat?
	jne	$$IF103 		; No
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors,0020h
	call	Calc_Big32_Fat		; Calc Fat info
	jmp	SHORT $$EN102

$$IF103:
	cmp	BL,fBig 		; 16-bit Fat?
	jne	$$IF102 		; no
	call	Calc_Big16_Fat		; Calc Fat info
	jmp	SHORT $$EN102

$$IF102:
	call	Calc_Small_Fat		; Calc small Fat info
$$EN102:
$$IF101:
	ret

Set_BPB_Info ENDP

;=========================================================================
; Scan_Disk_Table	 : Scans the table containing information on
;			   the disk's attributes.  When	it finds the
;			   applicable data, it returns a pointer in
;			   DS:SI for reference by the calling proc.
;
;	 Inputs	 : DiskTable - Contains	data about disk	types
;
;	 Outputs : DS:SI     - Points to applicable disk data
;=========================================================================

Procedure Scan_Disk_Table

	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors,00h ; small disk?
    .errnz EDP_BPB NE DP_BPB
	je	$$IF106 			; Yes

	mov	DX,00h				; Set high to 0
	mov	AX,WORD PTR DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
	jmp	SHORT $$EN106

$$IF106:
	mov	DX,WORD PTR DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors[+2]
	mov	AX,WORD PTR DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors[+0]

$$EN106:
ifdef NEC_98
	call	SetDiskTableNEC_98
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector,BX
	cmp	dx,0
	je	@F
	mov	word ptr DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors,0
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors,AX
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectorsHigh,DX
	jmp	short set_ok
@@:
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors,AX
	mov	word ptr DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors,0
	mov	word ptr DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectorsHigh,0
set_ok:
else
	mov	SI,offset DiskTable		; Point to disk data
endif
Scan:

	cmp	DX,WORD PTR DS:[SI]		; Below?
	jb	Scan_Disk_Table_Exit		; Yes, exit
	ja	Scan_Next			; No, continue

	cmp	AX,WORD PTR DS:[SI+2]		; Below or equal?
ifdef NEC_98
	jb	Scan_Disk_Table_Exit		; Yes, exit
else
	jbe	Scan_Disk_Table_Exit		; Yes, exit
endif

Scan_Next:
	add	SI,5*2				; Adjust pointer
	jmp	Scan				; Continue scan

Scan_Disk_Table_Exit:

	ret

Scan_Disk_Table ENDP

;=========================================================================
; Calc_Big32_Fat :	 Calculates the Sectors per Fat for a 32 bit Fat.
;
;	 Inputs  : DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors	or
;		   DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
;
;	 Outputs : DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
;		   DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
;		   DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFatHi
;		   DeviceParameters.DP_BPB.BGBPB_ExtFlags
;		   DeviceParameters.DP_BPB.BGBPB_FS_Version
;		   DeviceParameters.DP_BPB.BGBPB_RootDirStrtClus
;		   DeviceParameters.DP_BPB.BGBPB_RootDirStrtClusHi
;
;=========================================================================

Procedure Calc_Big32_Fat

.386
     ; Root dir is a cluster chain on FAT32 volumes

	movzx	edx,DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors ; EDX = Reserved
    .errnz EDP_BPB NE DP_BPB
    ; Get total sector count
	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors,00h ; Small disk?
	je	short $$IF109a		; Yes
	movzx	EAX,DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
	jmp	SHORT $$EN109a

$$IF109a:
	mov	EAX,DWORD PTR DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors

$$EN109a:
	sub	EAX,EDX 		; EAX	= T - R
	xor	ebx,ebx
	mov	BL,DeviceParameters.DP_BPB.oldBPB.BPB_NumberOfFATs
	mov	BH,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
	shr	ebx,1			; At 4 bytes per clus instead of 2,
					;    halve divisor
GotDiv1:
	add	EAX,EBX 		; EAX	= T-R-D+(256*SPC)+nFAT
	dec	EAX			; EAX	= T-R-D+(256*SPC)+nFAT-1
	xor	edx,edx
	div	EBX			; Sec/Fat = CEIL((TOTAL-DIR-RES)/
					; (((256*SECPERCLUS)+NUMFATS)/2)

	mov	DWORD PTR DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat,EAX
	xor	ax,ax
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat,ax
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_RootEntries,ax
	mov	DeviceParameters.DP_BPB.BGBPB_ExtFlags,ax
    ;
    ; For the moment we set the root dir start clus to 0. Later on, after
    ;	we determine which clusters are BAD, we will set this to something
    ;	proper.
    ;
	mov	DeviceParameters.DP_BPB.BGBPB_RootDirStrtClus,ax
	mov	DeviceParameters.DP_BPB.BGBPB_RootDirStrtClusHi,ax
	mov	DeviceParameters.DP_BPB.BGBPB_FS_Version,FAT32_Curr_FS_Version
.8086
	ret

Calc_Big32_Fat ENDP


;=========================================================================
; Calc_Big16_Fat   :	   Calculates the Sectors per Fat for a 16 bit Fat.
;
;	 Inputs  : DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors	or
;		   DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
;
;	 Outputs : DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
;
;=========================================================================

Procedure Calc_Big16_Fat

     ; Get root size in sectors and add reserved to it

	mov	AX,DeviceParameters.DP_BPB.oldBPB.BPB_RootEntries
    .errnz EDP_BPB NE DP_BPB
	mov	bx,size dir_entry
	mul	bx			; DX:AX = bytes in root dir
	mov	bx,DeviceParameters.DP_BPB.oldBPB.BPB_bytesPerSector
	dec	bx			; Round up to sector multiple
	add	ax,bx
	adc	dx,0
	inc	bx			; get back sector size
	div	bx			; AX is sectors in root dir
	mov	bx,DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors
	add	ax,bx			; AX = R + D
	mov	bx,ax			; over to BX

    ; Get Total sectors

	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors,00h ; Small disk?
	je	$$IF109 		; Yes

	xor	DX,DX			; Set high to 0
	mov	AX,DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
	jmp	SHORT $$EN109

$$IF109:
	mov	DX,DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors[+2]
	mov	AX,DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors[+0]

$$EN109:
	sub	AX,BX			; DX:AX = T - R - D
	sbb	DX,0
	mov	BL,DeviceParameters.DP_BPB.oldBPB.BPB_NumberOfFATs
	mov	BH,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
	add	AX,BX			; AX	= T-R-D+(256*SPC)+nFAT
	adc	DX,0
	sub	AX,1			; AX	= T-R-D+(256*SPC)+nFAT-1
	sbb	DX,0
	div	BX			; Sec/Fat = CEIL((TOTAL-DIR-RES)/
					; ((256*SECPERCLUS)+NUMFATS)

	mov	WORD PTR DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat,AX
	ret

Calc_Big16_Fat ENDP


;=========================================================================
; Calc_Small_Fat:	 Calculates the	Sectors	per Fat	for a 12 bit Fat.
;
;	 Inputs  : DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors	or
;		   DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
;
;	 Outputs : DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
;
;=========================================================================

Procedure Calc_Small_Fat

     ; Get root size in sectors and add reserved to it

	mov	AX,DeviceParameters.DP_BPB.oldBPB.BPB_RootEntries
    .errnz EDP_BPB NE DP_BPB
	mov	bx,size dir_entry
	mul	bx			; DX:AX = bytes in root dir
	mov	bx,DeviceParameters.DP_BPB.oldBPB.BPB_bytesPerSector
	dec	bx			; Round up to sector multiple
	add	ax,bx
	adc	dx,0
	inc	bx			; get back sector size
	div	bx			; AX is sectors in root dir
	mov	bx,DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors
	add	ax,bx			; AX = R + D
	mov	bx,ax			; over to BX

    ; Get total sectors

	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors,00h ;small disk?
	je	$$IF112 		; Yes

	xor	DX,DX			; Set high to 0
	mov	AX,WORD PTR DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
	jmp	SHORT $$EN112

$$IF112:
	mov	DX,WORD PTR DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors[+2]
	mov	AX,WORD PTR DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors[+0]

$$EN112:
	sub	AX,BX			; DX:AX    = T - R - D
	sbb	DX,0

	xor	BX,BX
	mov	BL,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
	div	BX
					; Now multiply	by 3/2
	mov	BX,3
	mul	BX			; Div by log 2 of Sectors/clus
	mov	BX,2
	div	BX
	xor	DX,DX
					; Now divide by 512
	mov	BX,512
	div	BX
ifdef NEC_98
	or	dx,dx		; for remainder
	jz	@F
	inc	AX
@@:
	test	ax,01h		; for even
	jz	@F
	inc	ax
@@:
	cmp	DeviceParameters.DP_BPB.BPB_BytesPerSector,2048
	jne	@F
	test	ax,02h		; for 2048 bytes/sector
	jz	@F
	add	ax,2
@@:
else
	inc	AX
					; DX:AX contains number of Fat
					; sectors necessary
endif
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat,AX
	ret

Calc_Small_Fat ENDP

; ==========================================================================
; StartSector = number	of reserved Sectors
;	  + number of Fat Sectors	 ( Number of FatS * Sectors Per	Fat )
;	  + number of directory	Sectors	 ( 32* Root Entries / bytes Per	Sector )
;					 ( above is rounded up )
;
; Calculate the number	of directory Sectors
; ==========================================================================

SetStartSector	proc near

	xor	ax,ax
	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFAT,ax
	je	NoRootDir
	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_RootEntries
    .errnz EDP_BPB NE DP_BPB
	mov	BX, size dir_entry
	mul	BX			; DX:AX is bytes in root dir
	mov	bx, DeviceParameters.DP_BPB.oldBPB.BPB_bytesPerSector
	dec	bx			; Round up to sector multiple
	add	ax,bx
	adc	dx,0
	inc	bx			; Get sector size back
	div	bx			; AX = Sectors in root dir
NoRootDir:
	mov	SectorsInRootDirectory,AX
.386
	movzx	eax,ax
	mov	StartSector, EAX			;not done yet!

; Calculate the number	of Fat Sectors

	movzx	EAX, DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
	or	ax,ax
	jnz	short NotFat32a
	mov	EAX, DWORD PTR DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
NotFat32a:
	movzx	ebx,DeviceParameters.DP_BPB.oldBPB.BPB_numberOfFats
	mul	ebx
; add in the number of	boot Sectors
	movzx	ebx,DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors

	add	EAX,EBX
	add	StartSector, EAX
.8086
	return

SetStartSector	endp

; ==========================================================================
;
; fBigFat = ( ( (TotalSectors - StartSector) / SectorsPerCluster) >= 4086 )
;
; ==========================================================================

SetfBigFat proc near

	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFAT,0
    .errnz EDP_BPB NE DP_BPB
	jne	NotFat32b
	mov	fBig32Fat, TRUE 		; Set flag
	mov	ThisSysInd,8
	jmp	SHORT $$EN21

NotFat32b:
	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors+2,0
	je	$$IF21				; no, 12-bit Fat
	mov	fBigFat, TRUE			; Set flag
	mov	ThisSysInd,6
	jmp	SHORT $$EN21			; Nope, < 32,b

$$IF21: 					; Assume this used
	mov	AX,DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors
	cmp	AX,0				; Was this field used?
	jne	$$IF23				; Yes
    ; No, use other sector field
	mov	AX, DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
$$IF23: 					; ** Fix for PTM PCDOS P51
	mov	ThisSysInd,1			; Set small Fat for default
	sub	AX,word ptr StartSector 	; Get Sectors in data area
	xor	DX,DX
	xor	BX,BX
	mov	bl,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
	div	BX				; Get total clusters

	cmp	AX,BIG_Fat_THRESHOLD		; Is clusters >= 4086?	
	jnae	$$IF25

	mov	fBigFat,TRUE			; 16 bit Fat if	>=4096
						; ** END fix for PTM PCDOS P51
	mov	ThisSysInd,4			; set large Fat
$$IF25:
$$EN21:
	return

SetfBigFat endp

;==========================================================================
;
; GetTotalClusters :	This procedure initializes the variable TotalClusters.
;			This is utilized by Quick Format to check for when all
;			the clusters have been processed.
; Destroys :	AX,BX,CX,DX
; Strategy :	TotalClusters = (TotalSectors-Fats-Root-Reserved)/SectorsPerCluster
;
;==========================================================================

GetTotalClusters	proc	NEAR

.386
	movzx	EAX,DeviceParameters.DP_BPB.oldBPB.BPB_TotalSectors
    .errnz EDP_BPB NE DP_BPB
	or	AX,AX			; Check if BigTotalSectors must be used
	jnz	short GoSubstract	      ; M015; Substrack Fats, Root and reserved

GetBigSectors:
	mov	EAX,dword ptr DeviceParameters.DP_BPB.oldBPB.BPB_BigTotalSectors

GoSubstract:
	movzx	edx,DeviceParameters.DP_BPB.oldBPB.BPB_ReservedSectors
	sub	EAX,EDX

	movzx	edx,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat
	or	dx,dx
	jnz	short NotFat32c
	mov	DeviceParameters.DP_BPB.oldBPB.BPB_RootEntries,dx   ; No root dir on FAT32
	mov	edx,dword ptr DeviceParameters.DP_BPB.BGBPB_BigSectorsPerFat
NotFat32c:
	movzx	cx,DeviceParameters.DP_BPB.oldBPB.BPB_NumberOfFats
	jcxz	GoDivide		; M017; if non fat, don't even do the root

SubstractAFat:
	sub	EAX,EDX
	loop	SubstractAFat

GoSubstractRoot:
; Assumes that BytesPerSectors is a power of 2 and at least 32
; Those are valid assumptions since BIOS requires the same.

	mov	BX,DeviceParameters.DP_BPB.oldBPB.BPB_BytesPerSector
	shr	BX,5			; divide by 32, BX = root entries per sector (a power of 2)

	or	BX,BX			; Sanity check for infinite looping
	jz	short SayWhat

	mov	CX,DeviceParameters.DP_BPB.oldBPB.BPB_RootEntries

SubstractRootLoop:
	test	BX,1
	jnz	short SubstractRootReady
	shr	BX,1
	shr	CX,1
	jmp	short SubstractRootLoop

SubstractRootReady:
	movzx	ecx,cx

	sub	EAX,ECX
GoDivide:
	movzx	ebx,DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerCluster
	xor	edx,edx
	div	EBX

	inc	EAX			; Bump by 1 since start with 2
	cmp	DeviceParameters.DP_BPB.oldBPB.BPB_SectorsPerFat,0
	je	short NoOvlChk
	cmp	EAX,0000FFEFh		; Sanity check
	ja	short SayWhat
NoOvlChk:
	mov	TotalClusters,EAX
.8086
	ret

SayWhat:
	Message	msgInvalidDeviceParameters
	jmp	FatalExit

GetTotalClusters	endp

; SetDOS_Dpb - Need to set the DPB for a memory card because the
;	       default will be for the last disk accessed in the
;	       the drive and may not be correct for the current
;	       disk.

SetDOS_Dpb PROC

	cmp	CMCDDFlag, Yes
	je	@f
	clc
	ret

@@:
	push	ds
	pop	es
	mov	di, offset SetDPBPacket
	mov	ax, OFFSET DeviceParameters.DP_BPB ; DS:AX --> BPB for disk
    .errnz EDP_BPB NE DP_BPB
	mov	word ptr [di.SetDPB_Value1],ax
	mov	word ptr [di.SetDPB_Value1+2],ds
	xor	ax,ax
	mov	word ptr [di.SetDPB_Value2],ax
	mov	word ptr [di.SetDPB_Value2+2],ax
	mov	word ptr [di.SetDPB_Value3],ax
	mov	word ptr [di.SetDPB_Value3+2],ax
	mov	word ptr [di.SetDPB_Value4],ax
	mov	word ptr [di.SetDPB_Value4+2],ax
.386
	mov	[di.SetDPB_Function],SetDPB_SetDPBFrmBPB
	movzx	dx,DriveToFormat
.8086
	inc	dx				; 1 based drive number
	mov	ax,(Get_Set_DriveInfo SHL 8) OR Set_DPBForFormat
	mov	cx,size SDPDFormatStruc
	int	21h
    ;
    ; NOTE: This call fails in protected mode under Win95. VFAT/VDEF do not
    ;	    implement it. This call REALLY isn't necessary anyway. The
    ;	    SetDeviceParameters we do as part of the format is supposed to
    ;	    trigger the device driver to return "media changed" on the next
    ;	    media check call.
    ;
	clc

	ret

SetDOS_Dpb ENDP

;==========================================================================
ifdef NEC_98
; IN  : DX:AX total_sectors
;     : DeviceParameters
; OUT : SI = offset DiskTable
;     : BX = BytesPerSector
;     : DX:AX = total sectors
;
; USE : AX,BX,DX,SI
;
SetDiskTableNEC_98	proc	near

	mov	bx,DeviceParameters.DP_BPB.BPB_BytesPerSector

	cmp	bx,200h
	je	large?_512
	cmp	bx,100h
	je	large?_256
	cmp	bx,400h
	jne	not_large

large?_1024:
	cmp	dx,2
	jb	not_large
	je	@F
	jmp	set_large1024	; 1024 and DX > 2 --> large partition.
				; > 129MB

@@:
	cmp	ax,200h
	jb	not_large
	jmp	set_large1024	; 1024 and DX = 2 and AX >= 512 --> large partition.
				; > 128.5MB

large?_512:
	cmp	dx,4
	jb	not_large
	je	@F
	jmp	set_large512	; 512 and DX > 4 --> large partition.
				; > 129MB

@@:
	cmp	ax,400h
	jb	not_large
	jmp	set_large512	; 512 and DX = 4 and AX >= 1024 --> large partition.
				; > 128.5MB

large?_256:
	cmp	dx,8
	jb	not_large
	je	@F
	jmp	set_large256	; 256 and DX > 8 --> large partition.
				; > 129MB

@@:
	cmp	ax,800h
	jb	not_large
	jmp	set_large256	; 256 and DX = 8 and AX >= 2048 --> large partition.
				; > 128.5MB

not_large:
	cmp	bx,800h
	jne	@F
	jmp	set_2K

@@:
	cmp	bx,200h
	je	sec2K?_512
	cmp	bx,100h
	je	sec2K?_256

sec2K?_1024:
	cmp	dx,1
	jb	not_2K
	je	@F

	shr	dx,1		;convert 1K->2K
	rcr	ax,1
	jmp	set_2K		; 1024 and DX > 1 --> 2KB partition.
				; > 65MB

@@:
	cmp	ax,200h
	jb	not_2K
	shr	dx,1		;convert 1K->2K
	rcr	ax,1
	jmp	set_2K		; 1024 and DX = 1 and AX >= 1024 --> 2KB partition.
				; > 64.5MB

sec2K?_512:
	cmp	dx,2
	jb	not_2K
	je	@F
	shr	dx,1		;convert 512->2K
	rcr	ax,1
	shr	dx,1
	rcr	ax,1
	jmp	set_2K		; 512 and DX > 2 --> 2KB partition.
				; > 65MB

@@:
	cmp	ax,400h
	jb	not_2K
	shr	dx,1		;convert 512->2K
	rcr	ax,1
	shr	dx,1
	rcr	ax,1
	jmp	set_2K		; 512 and DX = 2 and AX >= 1024 --> 2KB partition.
				; > 64.5MB

sec2K?_256:
	cmp	dx,4
	jb	not_2K
	je	@F
	shr	dx,1		;convert 256->2K
	rcr	ax,1
	shr	dx,1
	rcr	ax,1
	shr	dx,1
	rcr	ax,1
	shr	dx,1
	rcr	ax,1
	jmp	set_2K		; 256 and DX > 4 --> 2KB partition.
				; > 65MB

@@:
	cmp	ax,800h
	jb	not_2K
	shr	dx,1		;convert 256->2K
	rcr	ax,1
	shr	dx,1
	rcr	ax,1
	shr	dx,1
	rcr	ax,1
	shr	dx,1
	rcr	ax,1
	jmp	set_2K		; 256 and DX = 4 and AX >= 1024 --> 2KB partition.
				; > 64.5MB

not_2K:
	push	cx
	push	dx
	push	ax
	xor	dx,dx
	mov	ax,1024
	div	bx
	mov	cx,ax
	pop	ax		;DX:AX total sectors
	pop	dx
@@:
	shr	cx,1
	jc	@F
	shr	dx,1
	rcr	ax,1
	jmp	short @B
	pop	cx		;DX:AX convert ->1KB

	mov	bx,1024
	cmp	dx,0
	je	@F
	mov	ax,0FFFFh
	mov	dx,0
@@:
;;;	follow function is NEC_98 only.
	push	ax
	push	ds
	push	dx
	push	cx

	push	cs
	pop	ds
	mov	dx,offset LPTABLE
	mov	cl,13h
	int	220			;GET LPTABLE

	add	dx,001Ah		;EXLPTABLE start offset
	mov	al,DriveToFormat
	shl	al,1			;Drive * 2
	xor	ah,ah
	add	dx,ax
	inc	dx			;+1 (=DA/UA)
	mov	bx,dx
	mov	al,[bx]			;GET DA/UA at al
	pop	cx
	pop	dx
	pop	ds
	mov	ah,al			;al copy to ah
	and	al,0F0h
	cmp	al,80h
	je	@F
	jmp	set_SCSItable		;STACK AX	;Not 8xh

@@:
	push	es
	push	ax
	mov	ax,40h
	mov	es,ax		;es = 0040h
	pop	ax
	mov	al,es:[0057h]
	pop	es
	cmp	ah,80h
	je	IDE1_check	;STACK AX
	and	al,00000111b
	cmp	al,00000110b
	je	set_SASItable	;STACK AX	2nd IDE is 40MB
	cmp	al,00000100b
	je	set_SASItable	;STACK AX	2nd IDE is 20MB
	jmp	short set_SCSItable	;STACK AX
IDE1_check:
	and	al,00111000b
	cmp	al,00110000b
	je	set_SASItable	;STACK AX	1st IDE is 40MB
	cmp	al,00100000b
	je	set_SASItable	;STACK AX	1st IDE is 20MB
	jmp	short set_SCSItable	;STACK AX

LPTABLE		DB	96 DUP (?)

set_SASItable:
	pop	ax
	mov	si, offset SASI1024Table
	jmp	short exit_disktable
set_large1024:
set_SCSItable:
	pop	ax
	mov	si, offset SCSI1024Table
	jmp	short exit_disktable
set_large256:
	mov	si, offset Large256Table
	jmp	short exit_disktable
set_large512:
	mov	si, offset Large512Table
	jmp	short exit_disktable
set_2K:
	mov	bx,2048
	cmp	dx,0
	je	@F
	mov	ax,0FFFFh
	mov	dx,0
@@:
	mov	si, offset Small2048Table

exit_disktable:
	ret
SetDiskTableNEC_98	endp

MY_INT24	proc	far
	mov	al, 0		; don't display messages
	iret
MY_INT24	endp

endif

CODE	ENDS

END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\safedef.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1989 - 1991
; *                      All Rights Reserved.																
; */
;===========================================================================
;
;
; FILE: SAFEDEF.INC
;
; Contains all structure declarations and equates for SAFE.ASM
;
; johnhe - 10/09/89
;===========================================================================


;===========================================================================
; Entry layout for a DOS file in a DOS directory									*/
;===========================================================================

Dir STRUC
	fName		DB	'        '	; File primary name
	fExt		DB	'   '		; File extension
	fAttrib		DB	0		; File attributes
	fReserved	DB	10 DUP (0)	; Reserved by DOS
	fTime		DW	0		; Packed creation time
	fDate		DW	0		; Packed creation date
	fCluster	DW	0		; Files starting cluster
	fSize		DD	0		; File lenght in bytes
Dir ENDS

;===========================================================================
; Layout of the recovery file header
;===========================================================================

FileHeader STRUC

	fhSign1		DB	4 DUP (?)	; 055h, 0AAh, 0AAh, 055h
	fhSign2		DB	16 DUP (?)	; "Microsoft Corp.",0
	fhHeadChksum	DB	(?)		; Chksum for 1st 512 bytes
	fhFileChkSum	DB	(?)		; Chksum for rest of the file
	fhChainOffset	DW	(?)		; File's cluster chain		

	fhBootSize	DD	(?)		; Size of boot record
	fhFatSize	DD	(?)		; Size of FAT
	fhDirSize	DD	(?)		; Size of root directory
	fhClustSize	DD	(?)		; Size of the 2 cluster

	fhBootOffset	DD	(?)		; Offset of boot record
	fhFatOffset	DD	(?)		; Offset of FAT
	fhDirOffset	DD	(?)		; Offset of root directory
	fhClustOffset	DD	(?)		; Offset of the 2 cluster

	fhDir		DB	32 DUP (?)	; This file's directory entry
	fhBpb		DB	25 DUP (?)	; Disk's BPB structure
	fhFileReserve	DB	(?)		; Start of reserved area

FileHeader ENDS

;===========================================================================
; Layout of the int 25 & 26 packets
;===========================================================================

DiskPacket STRUC
	pAddr		DD	(?)		; Buffer address
	pSectors	DW	(?)		; Number of sectors
	pStart		DD	(?)		; Relative starting sector
DiskPacket ENDS

;===========================================================================
; Misc. equates
;===========================================================================

IGNORE_BIT	EQU	00001000b	; Mask to get ignore bit from AH
					; at entry to int 24h handler
SECTOR_SIZE	EQU 	512		; Normal sector size
HEADER_SIZE	EQU	2048		; Smallest cluster on a hard disk
MAX_SECTORS	EQU	3fh		; Max secters for read or write
OFFSET_BPB	EQU	11		; Offset of BPB in boot record
BPB_LENGTH	EQU	25		; Length of BPB structure
DIR_ENTRY_LEN	EQU	32		; Lenght of a directory entry
DIR_NAME_LEN	EQU 	11		; Bytes in a directory file name
ERASED_FILE	EQU	0e5h

IFDEF DBLSPACE_HOOKS
  NUM_SYS_FILES EQU     4           ; IO.SYS MSDOS.SYS COMMAND.COM DBLSPACE.BIN
ELSE
  NUM_SYS_FILES EQU     3           ; IO.SYS MSDOS.SYS COMMAND.COM
ENDIF

DO_READ		EQU	0		; Signal to do a read
DO_WRITE	EQU	1		; Signal to do a write
MAX_BLOCK_SIZE	EQU	0fff0h		; Max bytes for DOS read or write

BOOT_VALUE	EQU	0		; Layout of values in the arrays
FAT_VALUE	EQU	1		; which describe the offset in
DIR_VALUE	EQU	2		; in the restore file and each
CLUSTER_VALUE	EQU	3		; areas length

RESTORE_ATTRIBS	EQU 	7		; Restore file's attributes

;===========================================================================


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\oformat\switch_s.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;===========================================================================
;
; FILE: .ASM
;
;===========================================================================

;===========================================================================
;Declaration of include files
;===========================================================================
debug	 equ	 0
	 .xlist
	 INCLUDE DOSEQUS.INC
	 INCLUDE DOSMAC.INC
	 INCLUDE SYSCALL.INC
	 INCLUDE ERROR.INC
	 INCLUDE DIRENT.INC
	 INCLUDE BPB.INC
	 INCLUDE FOREQU.INC
	 INCLUDE FORMACRO.INC
	 .list
;
;---------------------------------------------------------------------------
;
; M029 : Remove the assumption that COMSPEC= has an absolute path name.
;	  and build the file name (COMMAND.COM) in a different buffer
;	  other than the buffer in which COMSPEC was stored.
;
;---------------------------------------------------------------------------
;

;===========================================================================
; Data segment
;===========================================================================

DATA    SEGMENT PUBLIC PARA 'DATA'

;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;Bytes
	EXTRN	DriveLetter		:BYTE
	EXTRN	SystemDriveLetter	:BYTE
	EXTRN	Extended_Error_Msg	:BYTE
	EXTRN	BiosFile		:BYTE
        EXTRN   AltBiosFile             :BYTE
        EXTRN   AltBiosLen              :ABS
        EXTRN   MsdosFile               :BYTE
        EXTRN   MsdosRemark             :BYTE
        EXTRN   MsdosRemarkLen          :ABS
IFDEF DBLSPACE_HOOKS
	EXTRN	fDblSpace		:BYTE
ENDIF

;Words
	EXTRN	mStart			:WORD
	EXTRN	mSize			:WORD
	EXTRN	Environ_Segment 	:WORD
	EXTRN	PSP_Segment		:WORD

;Pointers

;Structures
	EXTRN	Bios			:BYTE
        EXTRN   dos                     :BYTE
	EXTRN	command 		:BYTE
IFDEF DBLSPACE_HOOKS
	EXTRN	DblSpaceBin		:BYTE
ENDIF


BiosAttributes		equ	attr_hidden + attr_system + attr_read_only
DosAttributes		equ	attr_hidden + attr_system + attr_read_only

IFDEF DBLSPACE_HOOKS
DblSpaceAttributes	equ	attr_hidden + attr_system + attr_read_only
ENDIF

CommandAttributes	equ	0

CommandFile		db	"X:\COMMAND.COM",0
			db	(128 - 15) DUP (0)	; M012

Comspec_ID		db	 "COMSPEC=",00	 ; Comspec target

;       DOS status bits in FileStat are unused.
;       Starting with Chicago, IO.SYS and MSDOS.SYS have been combined.
;       For our purposes, the single file will be referred to as BIOS.
FileStat		db	?	; In memory Status of files
					; XXXXXX00B BIOS not in
					; XXXXXX01B BIOS partly in
					; XXXXXX10B BIOS all in
					; XXXX00XXB DOS not in
					; XXXX01XXB DOS partly	in
					; XXXX10XXB DOS all in
					; XX00XXXXB COMMAND not in
					; XX01XXXXB COMMAND partly in
					; XX10XXXXB COMMAND all in

Command_Com		DB	"X:\COMMAND.COM",0			; M029


IFDEF DBLSPACE_HOOKS
 DblSpaceFile		db	"X:\DRVSPACE.BIN",0 ;full path to source copy
			db	64 DUP (0)	    ;  of DRVSPACE.bin

DblSpaceTargetName	db	"X:\"             ;target DRVSPACE.bin name
DblSpaceBase		db	"DRVSPACE.BIN",0  ;base name used to srch PATH
ENDIF


DOS_BUFFER		db	45 dup (?)	; Find First/Next buffer

TempHandle		dw	?

IOCNT			dd	?

DATA	ENDS

;===========================================================================
; Executable code segment
;===========================================================================

CODE	SEGMENT PUBLIC PARA	'CODE'
	ASSUME	CS:CODE, DS:DATA, ES:DATA


;===========================================================================
; Declarations for all publics in other modules used by this module
;===========================================================================

;Functions
	EXTRN	SysPrm			:NEAR
	EXTRN	TargPrm			:NEAR
	EXTRN	Get_PSP_Parms		:NEAR
	EXTRN	Cap_Char		:NEAR

;Labels
	EXTRN	FatalExit		:NEAR
	EXTRN	Find_Path_In_Environment:NEAR
	EXTRN	Path_Crunch		:NEAR
	EXTRN	Search			:NEAR

;===========================================================================
; Declarations for all publics in this module
;===========================================================================

	PUBLIC	ReadDos
	PUBLIC	WriteDos
	PUBLIC	CommandFile

IFDEF DBLSPACE_HOOKS
	PUBLIC	DblSpaceFile
ENDIF

	PUBLIC	FileStat

; ==========================================================================
; Copy WINBOOT.SYS, COMMAND.COM, and DRVSPACE.BIN (if present) into
; data area.
; Carry set if	problems
; M011; SystemDriveLetter=Drive to Try
; ==========================================================================

ReadDos:
;M011 - begin
	xor	ax, ax
	mov	Bios.FileSizeInParagraphs, ax	; Initialize file sizes
	mov	Command.FileSizeInParagraphs, ax
IFDEF DBLSPACE_HOOKS
	mov	DblSpaceBin.FileSizeInParagraphs, ax
ENDIF
	mov	AL,SystemDriveLetter
	mov	[BiosFile],AL			; Stuff it in file specs.
	mov	[CommandFile],AL
IFDEF DBLSPACE_HOOKS
	mov	[DblSpaceFile], al
ENDIF

	call	Get_Bios
	jnc	RdFils
;M011 - end
	return

RdFils:
	mov	BYTE PTR [FileStat],0
	mov	BX,[Bios.fileHandle]
	mov	AX,[mStart]
	mov	DX,AX
	add	DX,[mSize]			; CX first bad para
	mov	[Bios.fileStartSegment],AX
	mov	CX,[Bios.fileSizeInParagraphs]
	add	AX,CX
	cmp	AX,DX
	jbe	GotBios

	mov	BYTE PTR [FileStat],00000001B	; Got part of Bios
	mov	SI,[mSize]
	xor	DI,DI
	call	DISIX4

	push	DS
	mov	DS,[Bios.fileStartSegment]

	assume	DS:NOTHING
	call	ReadFile
	pop	DS

	assume	DS:data
	jc	ClsAll
	xor	DX,DX
	mov	CX,DX
	mov	AX,(LSEEK shl 8) OR 1
	int	21H
	mov	WORD PTR [Bios.fileOffset],AX
	mov	WORD PTR [Bios.fileOffset+2],DX

FilesDone:
	clc

ClsAll:
	pushF
	call	FILE_CLS
	popF
	return

; ==========================================================================

GotBios:
	mov	BYTE PTR [FileStat],00000010B	; Got all of Bios
	push	ES
	les	SI,[Bios.fileSizeInBytes]
	mov	DI,ES
	pop	ES
	push	DS
	mov	DS,[Bios.fileStartSegment]

	assume	DS:nothing
	call	ReadFile
	pop	DS

	assume	DS:data
	jc	ClsAll

	push	AX
	push	DX
	call	File_Cls
        call    Get_DOS
        pop     DX
        pop     AX
ClsAllJ:
	jnc	notClsAll
	jmp	ClsAll

NotClsAll:
        push    AX
        push    DX
	call	Get_Command_Path		; get path of COMMAND.COM
	call	Get_Command			; Point to COMMAND and read it
	pop	DX
	pop	AX
	jnc	Found_Command

	return

;  ==========================================================================

Found_COMMAND:
	mov	BX,[command.fileHandle]
	mov	[command.fileStartSegment],AX
	cmp	AX,DX				; No room left?
	jz	ClsAllJ				; Yes

	mov	CX,[command.fileSizeInParagraphs]
	add	AX,CX
	cmp	AX,DX
	jbe	GotCom

	or	BYTE PTR [FileStat],00010000B	; Got part of COMMAND
	sub	DX,[command.fileStartSegment]
	mov	SI,DX
	xor	DI,DI
	call	DISIX4
	push	DS
	mov	DS,[command.fileStartSegment]
	assume	DS:nothing
	call	ReadFile
	pop	DS
	assume	DS:data
	jc	ClsAllJ

	xor	DX,DX
	mov	CX,DX
	mov	AX,(LSEEK shl 8) OR 1
	int	21h
	mov	WORD PTR [command.fileOffset],AX
	mov	WORD PTR [command.fileOffset+2],DX
	jmp	FilesDone

GotCom:
	or	BYTE PTR [FileStat],00100000B	; Got all of COMMAND
	push	ES
	les	SI,[command.fileSizeInBytes]
	mov	DI,ES
	pop	ES
	push	DS
	mov	DS,[command.fileStartSegment]
	assume	DS:nothing
	call	ReadFile
	pop	DS
	assume	DS:data
	jc	ClsAllJ



IFDEF DBLSPACE_HOOKS

	; Attempt to locate dblspace.bin

	push	ax
	push	dx
	call	File_cls			; close COMMAND.COM
	call	Get_DblSpace
	pop	dx
	pop	ax
	jnc	Found_DblSpace

	; DblSpace.bin is nowhere to be found!	This isn't fatal, clear
	; carry and return.

	clc
	return

;  ==========================================================================

	; DblSpace.bin has been located, will it fit in memory?
	; AX has next free location in memory buffer, DX has
	; (just past) end of buffer address.

Found_DblSpace:
	mov	bx, [DblSpaceBin.fileHandle]
	mov	[DblSpaceBin.fileStartSegment], ax

	cmp	ax, dx				; any room left?
	jz	ClsAllJ2			; no!

	mov	cx, [DblSpaceBin.fileSizeInParagraphs]
	add	ax, cx
	cmp	ax, dx
	jbe	GotDblSpace
;
; No mem for dblspace driver. Lets not count its size towards SysSiz
;
	mov	word ptr [DblSpaceBin.fileSizeInBytes], 0
	mov	word ptr [DblSpaceBin.fileSizeInBytes].2, 0
;
; BUGBUG :: Display a warning message
;

ClsAllJ2:					; insufficient memory, skip
	jmp	ClsAll				;   DRVSPACE.bin (CY is clear)

GotDblSpace:
	mov	[fDblSpace], TRUE				; got it!
	mov	si, word ptr [DblSpaceBin.fileSizeInBytes]
	mov	di, word ptr [DblSpaceBin.fileSizeInBytes+2]	; di:si = size
	push	ds
	mov	ds, [DblSpaceBin.fileStartSegment]		; ds:0 = addr
	assume	ds:nothing
	call	ReadFile					; load it
	pop	ds
	assume	ds:data

ENDIF



	jmp	ClsAll

; ==========================================================================
; Write	Bios DOS COMMAND to the	newly formatted	disk.
; ==========================================================================

	ASSUME	 DS:DATA

WriteDos:
	 mov	 CX,BiosAttributes
	 mov	 DX,OFFSET BiosFile		; DS:DX --> ASCIIZ pathname
	 push	 ES
	 les	 SI,[Bios.fileSizeInBytes]
	 mov	 DI,ES				; DI:SI is file size
	 pop	 ES
	 call	 MakeFil			; create & open file in dest. drive
	 retc

	 mov	 [TempHandle],BX		; save file handle
	 test	 BYTE PTR FileStat,00000010B	; is BIOS all in already?
	 jnz	 GotAllBio			; yes, write it out
	 call	 Get_Bios			; no, read it in
	 jnc	 Got_WBios			; check for error
	 ret

; ==========================================================================

Got_WBios:

	 push	 ES
	 LES	 SI,[Bios.fileOffset]
	 mov	 DI,ES				; DI:SI is file pointer
	 pop	 ES
	 mov	 WORD PTR [IOCNT],SI
	 mov	 WORD PTR [IOCNT+2],DI
	 mov	 BP,OFFSET Bios			; BP --> parameter block for BIOS file
	 call	 GotTArg
	 retc
	 jmp	 SHORT BiosDone

GotAllBio:
	 push	 ES
	 LES	 SI,[Bios.fileSizeInBytes]
	 mov	 DI,ES				; DI:SI is BIOS file size
	 pop	 ES
	 push	 DS
	 mov	 DS,[Bios.fileStartSegment]	; DS:0 --> start of BIOS in memory
	 assume	 DS:nothing
	 call	 WriteFile			; write BIOS to disk
	 pop	 DS
	 assume	 DS:data
BiosDone:
	 mov	 BX,[TempHandle]
	 mov	 CX,Bios.fileTime
	 mov	 DX,Bios.fileDate
         call    CloseTarg                      ; close BIOS file on target disk
         cmp     [MsdosFile],0
         je      skip_msdos

         mov     CX,DosAttributes
         mov     DX,OFFSET MsdosFile            ; DS:DX --> ASCIIZ pathname
         sub     si,si
         sub     di,di                          ; DI:SI is file size
	 call	 MakeFil			; create & open file in dest. drive
         jc      skip_msdos

         call    Get_Dos
         mov     dx,offset MsdosRemark
	 mov	 cx,word ptr [dos.fileSizeInBytes]
         mov     ah,WRITE
         int     21h

	 mov	 CX,Bios.fileTime
	 mov	 DX,Bios.fileDate
         call    CloseTarg                      ; close dummy MSDOS file on target disk

skip_msdos:
	 mov	 CX,CommandAttributes

;M029	 call	 Command_Root			 ;adjust path for
;M029						 ;COMMAND.COM creation

	 mov	 DX,OFFSET Command_Com		 ; M029
	 push	 ES
	 les	 SI,[command.fileSizeInBytes]
	 mov	 DI,ES
	 pop	 ES
	 call	 MakeFil
	 retc

	 mov	 [TempHandle],BX
	 test	 BYTE PTR FileStat,00100000B
	 jnz	 GotAllCom
	 call	 Get_COMMAND
	 jnc	 Got_WCOM
	 ret

Got_WCOM:
	 mov	 BP,OFFSET command		; BP --> parameter block for COMMAND file
	 test	 BYTE PTR FileStat,00010000B
	 jnz	 PartCom
	 mov	 WORD PTR [command.fileOffset],0
	 mov	 WORD PTR [command.fileOffset+2],0
	 call	 GETSYS3
	 retc
	 jmp	 SHORT ComDone

PartCom:
	 push	 ES
	 LES	 SI,[command.fileOffset]
	 mov	 DI,ES
	 pop	 ES
	 mov	 WORD PTR [IOCNT],SI
	 mov	 WORD PTR [IOCNT+2],DI
	 call	 GotTArg
	 retc
	 jmp	 SHORT ComDone

GotAllCom:
	 push	 ES
	 les	 SI,[command.fileSizeInBytes]
	 mov	 DI,ES
	 pop	 ES
	 push	 DS
	 mov	 DS,[command.fileStartSegment]
	 assume	 DS:nothing
	 call	 WriteFile
	 pop	 DS
	 assume	 DS:data
ComDone:
	 mov	 BX,[TempHandle]
	 mov	 CX,command.fileTime
	 mov	 DX,command.fileDate
         call    CloseTarg



IFDEF DBLSPACE_HOOKS

	; Write dblspace.bin to target disk if it was located and loaded
	; into memory.

	cmp	[fDblSpace], TRUE			;Have it?
	jne	WriteDosDone				;  no...

	mov	cx, DblSpaceAttributes			;Create file on
	mov	dx, offset DblSpaceTargetName		;  target disk
	mov	si, word ptr [DblSpaceBin.fileSizeInBytes]
	mov	di, word ptr [DblSpaceBin.fileSizeInBytes+2]
	call	MakeFil
	retc

	mov	[TempHandle], bx

	mov	si, word ptr [DblSpaceBin.fileSizeInBytes]
	mov	di, word ptr [DblSpaceBin.fileSizeInBytes+2]
	push	ds
	mov	ds, [DblSpaceBin.fileStartSegment]
	assume	ds:nothing
	call	WriteFile			;Write dblspace.bin image
	pop	ds
	assume	ds:data

	mov	bx, [TempHandle]		;Set time/date, close
	mov	cx, [DblSpaceBin.fileTime]	;  DblSpace.bin
	mov	dx, [DblSpaceBin.fileDate]
	call	ClosetArg

WriteDosDone:

ENDIF
	 clc
	 return

; ==========================================================================
; Create a file on target disk
; CX =	attributes, DX points to name
; DI:SI is size file is to have
;
;   There is a	bug in DOS 2.00	and 2.01 having	to do with writes
;   from the end of memory. In	order to circumvent it this routine
;   must create files with the	length in DI:SI
;
; On return BX	is handle, carry set if	problem
; ==========================================================================

MakeFil:
	 mov	 BX,DX				; BX --> ASCIIZ pathname
	 push	 WORD PTR [BX]			; save drive letter in pathname
	 mov	 AL,DriveLetter
	 mov	 [BX],AL			; set new drive letter in pathname
	 mov	 AH,CREAT
	 int	 21H				; create the file on disk
	 pop	 WORD PTR [BX]			; restore original drive letter in pathname
	 mov	 BX,AX				; save handle in BX
	 jc	 CheckMany
	 mov	 CX,DI
	 mov	 DX,SI				; CX:DX is size of file
	 mov	 AX,LSEEK shl 8
         int     21H                            ; Seek to eventual EOF
         xor     CX,CX
         mov     AH,WRITE
         int     21H                            ; Set size of file to position
         xor     CX,CX
         mov     DX,CX
         mov     AX,LSEEK shl 8
         int     21H                            ; Seek back to start
	 return

; ==========================================================================
; Examine error code in AX to see if it is too-many-open-files.
; If it is, we	abort right here. Otherwise we return.
; ==========================================================================

CheckMany:
	 cmp	 AX,error_too_many_open_files
	 retnz
	 Extended_Message
	 jmp	 FatalExit

;*********************************************
; Close a file	on the target disk
; CX/DX is time/date, BX is handle

CloseTarg:
	 mov	 AX,(FILE_TIMES	shl 8) OR 1
	 int	 21H
	 mov	 AH,CLOSE
	 int	 21H
	 return

;****************************************
; Transfer system files
; BP points to	data structure for file	involved
; offset is set to current amount read	in
; Start set to	start of file in buffer
; TempHandle is handle	to write to on target

IoLoop:
	 mov	 AL,[SystemDriveLetter]
	 cmp	 AL,[DriveLetter]
	 jnz	 GotTArg
	 mov	 AH,DISK_RESET
	 int	 21H
	 call	 TargPrm			 ;Get target disk


; ==========================================================================
; Enter	here if	some of	file is	already	in buffer, IOCNT must be set
; to size already in buffer.
; ==========================================================================

	ASSUME	 DS:DATA
GotTArg:
	 mov	 BX,[TempHandle]
	 mov	 SI,WORD PTR [IOCNT]
	 mov	 DI,WORD PTR [IOCNT+2]
	 push	 DS
	 mov	 DS,DS:[BP.fileStartSegment]
	 assume	 DS:nothing
	 call	 WriteFile			 ; Write next part
	 pop	 DS
	 assume	 DS:data
	 retc

	 push	 ES
	 LES	 AX,DS:[BP.fileOffset]
	 cmp	 AX,WORD PTR DS:[BP.fileSizeInBytes]	; has all the file been written?
	 jnz	 GETSYS3				; no, read rest in
	 mov	 AX,ES
	 cmp	 AX,WORD PTR DS:[BP.fileSizeInBytes+2]
	 jnz	 GETSYS3
	 pop	 ES
	 return					 ; Carry clear from cmp

GETSYS3:

; ==========================================================================
; Enter	here if	none of	file is	in buffer
; (or none of what remains to be written is in buffer)
; ==========================================================================
	pop	ES
	mov	AH,DISK_RESET
	int	21H
	mov	AX,[mStart]			; Furthur IO done start here
	mov	DS:[BP.fileStartSegment],AX	; point	to start of buffer
	mov	AL,[SystemDriveLetter]		; see if we have system	disk
	cmp	AL,[DriveLetter]
	jnz	TestSys
gSys:
				; Need to prompt for system disk
;	call 	File_Cls			;SA; close file that was opened
	mov	AH,DISK_RESET
	int	21H
	call	SysPrm				; Prompt for system disk
;	inc	NeedSysDisk			;SA;signal need for sys disk
;	stc					;SA;force return to caller
;	ret					;SA;handle SysPrm in WriteSysFiles

TestSys:
;	call	TestSysDISK
	jc	gSys				; repeat prompt if needed
	mov	BX,WORD PTR DS:[BP.fileHandle]	; CS over ARR 2.30
	push	ES
	LES	DX,dWORD PTR DS:[BP.fileOffset] ; CS over ARR 2.30
	mov	CX,ES				; CX:DX = required offset in file
	pop	ES
	push	DX
	mov	AX,LSEEK shl 8
	int	21H
	pop	DX
	push	ES
	LES	SI,dWORD PTR DS:[BP.fileSizeInBytes] ; CS over
	mov	DI,ES				; put high word	in di
	pop	ES
	SUB	SI,DX				; get low word value
	SBB	DI,CX				; DI:SI is #bytes to go
	push	DI
	push	SI
	add	SI,15				; round	up 1 para
	ADC	DI,0				; pick up carry
	call	DISID4				; div 16 to get	para count
	mov	AX,SI				; put para count in AX
	pop	SI				; restore bytes	remaining
	pop	DI				; restore bytes	remaining
	cmp	AX,[mSize]			; enough memory	for remainder?
	jbe	GOTSIZ2			 	; yes
	mov	SI,[mSize]
	xor	DI,DI
	call	DISIX4
GOTSIZ2:
	mov	WORD PTR [IOCNT],SI		; save byte count for read
	mov	WORD PTR [IOCNT+2],DI
	push	DS
	mov	DS,[mStart]
	assume	DS:nothing
	call	ReadFile
	pop	DS
	assume	DS:data
	jnc	GetOffs
	call	ClsAll
	jmp	gSys
GetOffs:
	xor	DX,DX				; clear	DX
	mov	CX,DX				; clear	CX
	mov	AX,(LSEEK shl 8) OR 1
	int	21H
	mov	WORD PTR DS:[BP.fileOffset],AX
	mov	WORD PTR DS:[BP.fileOffset+2],DX
	jmp	IoLoop

; ==========================================================================
; Test	to see if correct system disk. Open handles
; ==========================================================================

CRET12:
	stc
	return

; ==========================================================================
; TestSysDISK:
; ==========================================================================

Get_Bios:
	mov	AX,OPEN shl 8
	mov	DX,OFFSET BiosFile		; DS:DX --> ASCIIZ pathname
	int	21H
	jnc	SetBios

        push    es
        push    ds
        pop     es
        mov     cx,AltBiosLen
        lea     si,AltBiosFile
        mov     di,dx
        mov     al,[di]
        mov     [MsdosFile],al
        add     di,3
        cld
        rep     movsb
        pop     es

	mov	AX,OPEN shl 8
	int	21H
	jnc	SetBios
	jmp	CheckMany

SetBios:
	mov	[Bios.fileHandle],AX		; save file handle
	mov	BX,AX				; BX = file handle
	call	GetFsiz
	cmp	[Bios.fileSizeInParagraphs],0
	jz	SetBioSize
	cmp	[Bios.fileSizeInParagraphs],AX
	jz	SetBioSize
BiosCls:
	mov	AH,CLOSE
	mov	BX,[Bios.fileHandle]
	int	21h
	ret

; ==========================================================================

SetBioSize:
	mov	[Bios.fileSizeInParagraphs],AX
	mov	WORD PTR [Bios.fileSizeInBytes],SI
	mov	WORD PTR [Bios.fileSizeInBytes+2],DI
	mov	[Bios.fileDate],DX
	mov	[Bios.fileTime],CX
	clc
	ret
; ==========================================================================

Get_COMMAND:
	mov	AX,OPEN shl 8
	mov	DX,OFFSET CommandFile
	int	21H
	jnc	GotComHand
	jmp	CheckMany

Get_DOS:
        mov     WORD PTR [dos.fileSizeInBytes],MsdosRemarkLen
        mov     WORD PTR [dos.fileSizeInBytes+2],0
        ret

GotComHand:
	mov	[command.fileHandle],AX
	mov	BX,AX
	call	GetFsiz
	cmp	[command.fileSizeInParagraphs],0
	jz	SetComSize
	cmp	[command.fileSizeInParagraphs],AX
	jz	SetComSize
ComCls:
	mov	AH,CLOSE
	mov	BX,[command.fileHandle]
	int	21H
	ret

; ==========================================================================

SetComSize:
	mov	[command.fileSizeInParagraphs],AX
	mov	WORD PTR [command.fileSizeInBytes],SI
	mov	WORD PTR [command.fileSizeInBytes+2],DI
	mov	[command.fileDate],DX
	mov	[command.fileTime],CX
	CLC
	return



IFDEF DBLSPACE_HOOKS
; ==========================================================================
Get_DblSpace:
	mov	AX,OPEN shl 8
	mov	DX,OFFSET DblSpaceFile
	int	21H
	jnc	GotDblHand

	; We didn't locate DblSpace.bin in the root directory, look for
	; it along the PATH

	call	Find_DblSpace_on_Path		; sets CY if not found
	retc

	mov	AX,OPEN shl 8			; open the copy found
	mov	DX,OFFSET DblSpaceFile
	int	21H
	retc

GotDblHand:
	mov	[DblSpaceBin.fileHandle],AX

	mov	BX,AX
	call	GetFsiz

	mov	[DblSpaceBin.fileSizeInParagraphs],AX
	mov	WORD PTR [DblSpaceBin.fileSizeInBytes],SI
	mov	WORD PTR [DblSpaceBin.fileSizeInBytes+2],DI
	mov	[DblSpaceBin.fileDate],DX
	mov	[DblSpaceBin.fileTime],CX

	CLC
	return

ENDIF



; ==========================================================================

FILE_CLS:
	mov	AH,CLOSE
	int	21H
	ret

; ==========================================================================
; Handle in BX, return	file size in para in AX
; File	size in	bytes DI:SI, file date in DX, file
; time	in CX.
; ==========================================================================

GetFsiz:
	mov	AX,(LSEEK shl 8) OR 2
	xor	CX,CX
	mov	DX,CX
	int	21h
	mov	SI,AX
	mov	DI,DX
	add	AX,15				; Para	round up
	adc	DX,0
	and	DX,0fH				; If file is larger than this
				 		; it is bigger than the 8086
				 		; address space!
	mov	CL,12
	shl	DX,CL
	mov	CL,4
	shr	AX,CL
	or	AX,DX
	push	AX
	mov	AX,LSEEK shl 8
	xor	CX,CX
	mov	DX,CX
	int	21H
	mov	AX,FILE_TIMES shl 8
	int	21H
	pop	AX
	return

; ==========================================================================
; Read/Write file
;	 DS:0 is Xaddr
;	 DI:SI is byte count to	I/O
;	 BX is handle
; Carry set if	screw up
;
; I/O SI bytes
; I/O 64K - 1 bytes DI	times
; I/O DI bytes
; ==========================================================================

ReadFile:					; Must preserve AX,DX
	push	AX
	push	DX
	push	BP
	mov	BP,READ shl 8
	call	FilIo

	pop	BP
	pop	DX
	pop	AX
	return

WriteFile:
	push	BP
	mov	BP,WRITE shl 8
	call	FilIo
	pop	BP
	return

FilIo:
	xor	DX,DX
	mov	CX,SI
	jCXZ	K64IO
	mov	AX,BP
	int	21H
	retc
	add	DX,AX
	cmp	AX,CX				; If not =, AX<CX, carry set.
	retnz
	call	Normalize
K64IO:
	CLC
	mov	CX,DI
	jCXZ	IoRet
	mov	AX,BP
	int	21H
	retc
	add	DX,AX
	cmp	AX,CX				; If not =, AX<CX, carry set.
	retnz
	call	Normalize
	mov	CX,DI
K64M1:
	push	CX
	xor	AX,AX
	OR	DX,DX
	jz	NormIo
	mov	CX,10H
	SUB	CX,DX
	mov	AX,BP
	int	21H
	jc	IoRetP
	add	DX,AX
	cmp	AX,CX				; If not =, AX<CX, carry set.
	jnz	IoRetP
	call	Normalize
NormIo:
	mov	CX,0FFFFH
	SUB	CX,AX
	mov	AX,BP
	int	21H
	jc	IoRetP
	add	DX,AX
	cmp	AX,CX				; If not =, AX<CX, carry set.
	jnz	IoRetP
	call	Normalize			; Clears carry
	pop	CX
	LOOP	K64M1
	push	CX
IoRetP:
	pop	CX
IoRet:
	return


; ==========================================================================
; Shift DI:SI left 4 bits
; ==========================================================================

DISIX4:
	mov	CX,4
@@:
	shl	SI,1
	rcl	DI,1
	loop	@B
	return

; ==========================================================================
; Shift DI:SI right 4 bits
; ==========================================================================

DISID4:
	mov	CX,4
@@:
	shr	DI,1
	rcr	SI,1
	loop	@B
	return

; ==========================================================================
; Normalize DS:DX
; ==========================================================================

Normalize:
	 push	 DX
	 push	 AX
	 SHR	 DX,1
	 SHR	 DX,1
	 SHR	 DX,1
	 SHR	 DX,1
	 mov	 AX,DS
	 add	 AX,DX
	 mov	 DS,AX
	 pop	 AX
	 pop	 DX
	 and	 DX,0FH				 ; Clears carry
	 return

;=========================================================================
; Get_Command_Path		 : This	routine	finds the path where
;				   COMMAND.COM resides based on	the
;				   environmental vector.  Once the
;				   path	is found it is copied to
;				   CommandFile.
;
;	 Inputs	 : Exec_Block.Segment_Env - Segment of environmental vector
;		   Comspec_ID		  - "COMSPEC="
;
;	 Outputs : CommandFile		  - Holds path to COMMAND.COM
;=========================================================================

Procedure Get_Command_Path

	push	DS
	push	ES

	Set_Data_Segment			; DS,ES = Data
	call	Get_PSP_Parms			; Gets PSP info.
	cld					; Clear direction
	mov	AX,ES:Environ_Segment		; Get seg. of
						; Environ. vector
	mov	DS,AX				; Put it in DS
	assume	DS:nothing
	xor	SI,SI				; Clear SI

;M012 - begin

GCP_WhileNotFound:
	mov	BX,SI				; Save SI
	cmp	byte ptr DS:[SI],0
	jz	GCP_NotFound
	
	mov	DI,offset Comspec_ID
	mov	CX,8				; Loop 8 times
	repe	cmpsb				; "COMSPEC=" ?
	jnz	GCP_NotThisLine			; "COMSPEC=" not found

						; "COMSPEC=" found
	mov	DI,offset ES:CommandFile
	lodsb					; Priming read

			; Copy COMSPEC even if COMSPEC drive != boot drive
;	mov	DL,AL				; Prepare for capitalization
;	call	Cap_Char			; Capitalize character in DL
;	cmp	DL,ES:CommandFile		; COMSPEC same as boot Drive?
;	jne	GCP_NotFound			; COMSPEC drive != boot drive

GCP_GetPath: 					; While AL not = 0
	stosb					; Save it
	or	al,al				; At end?
	je	GCP_Done			; Yes

	lodsb					; Get character
	jmp	SHORT GCP_GetPath

GCP_NotThisLine:
	mov	SI,BX				; Restore SI

GCP_Find0Terminator:
	lodsb					; Loop until past the first 0.
	or	al,al
	jnz	GCP_Find0Terminator
	jmp	GCP_WhileNotFound
		
GCP_NotFound:
						; Nothing to do
						; since commandfile is
						; already patched to try
						; in the root of the
						; default or boot drive
GCP_Done:

;M012 - end

	pop	ES
	pop	DS

	ret

Get_Command_Path ENDP

comment ^					; M029
;
; This routine is no longer required		; M029
;
;=========================================================================
; Command_Root	 :	 This routine sets up CommandFile so that the
;			 COMMAND.COM will be written to	the root.
;			 It does this by copying at offset 3 of	CommandFile
;			 the literal COMMAND.COM.  This	effectively
;			 overrides the original	path, but maintains the
;			 Drive letter that is to be written to.
;
;	 Inputs	 :	 CommandFile - Holds full path to default COMMAND.COM
;	 Outputs :	 CommandFile - Holds modified path to new COMMAND.COM
;				       on target Drive.
;=========================================================================



Procedure Command_Root

	push	DS
	push	ES
	push	DI
	push	SI
	push	CX

	Set_Data_Segment
	mov	DI,offset CommandFile+3 	; Point to path past drive spec
	mov	SI,offset Command_Com		; Holds the literal COMMAND.COM
	mov	CX,000ch			; Len. of literal
	rep	movsb				; Move it

	pop	CX
	pop	SI
	pop	DI
	pop	ES
	pop	DS

	ret

Command_Root ENDP

endcomment ^					; M029



IFDEF DBLSPACE_HOOKS

;******************* START OF SPECIFICATIONS ***********************************
;Routine name: Find_DblSpace_on_Path
;*******************************************************************************
;
;Description:	    Search Path for DRVSPACE.bin
;
;Output: no error - CF = 0	  DblSpaceFile filled in with
;                                 full path to DRVSPACE.bin
;	    error - CF = 1	  Dblspace.bin not found
;
; Cut and pasted from SYS command code:   12/07/92  JEM
;
;******************* END OF SPECIFICATIONS *************************************

Find_DblSpace_on_Path PROC NEAR

        push es
        push ds                         ; save our segments
        push si                         ; save DTA address

	mov	ax, PSP_Segment
	mov	es, ax			; get our PSP to ES

        call Find_Path_In_Environment   ; returns ptr to path string in ES:DI
        jc   fdp_exit                   ; no path, can't find DRVSPACE.bin

        assume es:nothing
        mov  ax,ds                      ; swap DS and ES
        push es
        pop  ds
        assume ds:nothing
        mov  si,di                      ; DS:SI ==> Path string
        mov  es,ax
        assume es:data

fdp_path_loop:
        mov  bh,';'                     ; path separator character
	mov  dx,offset DblSpaceBase	; base file name
	mov  di,offset DblSpaceFile	; buffer to stick full path in
        call Path_Crunch                ; concatenate name and path
        pushf                           ; save result
        push ds                         ; save segment of Path
        push es
        pop  ds
        assume ds:data
	mov  dx,offset DblSpaceFile	; buffer with full path name
        mov  bx,offset DOS_BUFFER       ; DMA buffer for finds
        mov  al,1                       ; extension is specified
        call Search
        or   al,al                      ; found the file?
        pop  ds                         ; recover path segment
        assume ds:nothing
        pop  ax                         ; recover flags in AX
        jnz  fdp_exit                   ; found it!
        xchg ah,al
        sahf                            ; check Path_Crunch result
        jnc  fdp_path_loop

fdp_exit:
        pop  si
        pop  ds
        pop  es
        assume ds:data
        ret

Find_DblSpace_on_Path ENDP

ENDIF



CODE  	ENDS

END

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\opklib\diskapi.c ===
/****************************************************************************\

    DISKAPI.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    Disk API source file for custom disk APIs used in the OPK Wizard.

    4/99 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard as part of the
        Millennium rewrite.

\****************************************************************************/


//
// Include file(s)
//

#include <pch.h>
#include <commdlg.h>
#include <tchar.h>
#include <shlobj.h>


//
// Internal Define(s):
//

#define IDC_BROWSE_EDIT     0x3744  // Common dialogs edit box in the SHBrowseForFolder function.

//
// Internal Function Prototype(s):
//

static DWORD CopyDirectoryEngine(HWND hwnd, HANDLE hEvent, LPCTSTR lpSrc, LPCTSTR lpDst, BOOL fCount);
static CALLBACK BrowseCallbackProc(HWND, UINT, LPARAM, LPARAM);


//
// External Function(s):
//

BOOL DirectoryExists(LPCTSTR lpDirectory)
{
    DWORD dwAttr;

    return ( ( lpDirectory != NULL ) &&
             ( *lpDirectory != NULLCHR ) &&
             ( (dwAttr = GetFileAttributes(lpDirectory)) != 0xFFFFFFFF ) &&
             ( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) );
}

BOOL FileExists(LPCTSTR lpFile)
{
    DWORD dwAttr;

    return ( ( lpFile != NULL ) &&
             ( *lpFile != NULLCHR ) &&
             ( (dwAttr = GetFileAttributes(lpFile)) != 0xFFFFFFFF ) &&
             ( !(dwAttr & FILE_ATTRIBUTE_DIRECTORY) ) );
}

BOOL CopyResetFile(LPCTSTR lpSource, LPCTSTR lpTarget)
{
    if ( !CopyFile(lpSource, lpTarget, FALSE) )
        return FALSE;
    SetFileAttributes(lpTarget, FILE_ATTRIBUTE_NORMAL);
    return TRUE;
}

DWORD IfGetLongPathName(LPCTSTR lpszShortPath, LPTSTR lpszLongPath, DWORD cchBuffer)
{
//
// See also \nt\base\win32\client\vdm.c.
//
    DWORD        dwReturn = 0;
#if defined(_WIN64) // _WIN64 postdates the introduction of GetLongPathName.
    typedef (WINAPI* PFNGetLongPathNameA)( PCSTR lpszShortPath,  PSTR lpszLongPath, DWORD cchBuffer);
    typedef (WINAPI* PFNGetLongPathNameW)(PCWSTR lpszShortPath, PWSTR lpszLongPath, DWORD cchBuffer);
#ifdef UNICODE
    typedef PFNGetLongPathNameW PFNGetLongPathName;
    const static char ProcName[] = "GetLongPathNameW";
#else
    typedef PFNGetLongPathNameA PFNGetLongPathName;
    const static char ProcName[] = "GetLongPathNameA";
#endif
    static PFNGetLongPathName hGetLongPathName = NULL;
    static BOOL  fInited = FALSE;

    if (!fInited)
    {
        //
        // GetModuleHandle is in kernel32, so as long as this lib code
        // is around, the handle to kernel32 is constant and the result of
        // GetProcAccess is valid.
        //
        // The old code that called LoadLibrary/FreeLibrary would lose the
        // value of GetLastError by calling FreeLibrary.
        //
        HMODULE hKernel32;
        if (hKernel32 = GetModuleHandle(TEXT("Kernel32.dll")))
            hGetLongPathName = (PFNGetLongPathName)(GetProcAddress(hKernel32, ProcName));
        fInited = TRUE;
    }

    if (hGetLongPathName)
    {
        dwReturn = hGetLongPathName(lpszShortPath, lpszLongPath, cchBuffer);
    }
#else
    dwReturn = GetLongPathName(lpszShortPath, lpszLongPath, cchBuffer);
#endif
    return dwReturn;
}

BOOL CreatePath(LPCTSTR lpPath)
{   
    LPTSTR lpFind = (LPTSTR) lpPath;

    while ( lpFind = _tcschr(lpFind + 1, CHR_BACKSLASH) )
    {
        if ( !((lpFind - lpPath <= 2) && (*(lpFind - 1) == _T(':'))) )
        {
            *lpFind = NULLCHR;
            if ( !DirectoryExists(lpPath) )
                CreateDirectory(lpPath, NULL);
            *lpFind = CHR_BACKSLASH;
        }
    }

    if ( !DirectoryExists(lpPath) )
        CreateDirectory(lpPath, NULL);

    return DirectoryExists(lpPath);
}

BOOL DeletePath(LPCTSTR lpDirectory)
{
    WIN32_FIND_DATA FileFound;
    HANDLE          hFile;

    // Validate the parameters.
    //
    if ( ( lpDirectory == NULL ) ||
         ( *lpDirectory == NULLCHR ) ||
         ( !SetCurrentDirectory(lpDirectory) ) )
    {
        return TRUE;
    }

    // Process all the files and directories in the directory passed in.
    //
    SetCurrentDirectory(lpDirectory);
    if ( (hFile = FindFirstFile(_T("*"), &FileFound)) != INVALID_HANDLE_VALUE )
    {
        do
        {
            // First check to see if this is a file (not a directory).
            //
            if ( !( FileFound.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
            {
                // Make sure we clear the readonly flag 
                //
                SetFileAttributes(FileFound.cFileName, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(FileFound.cFileName);
            }
            // Otherwise, make sure the directory is not "." or "..".
            //
            else if ( ( lstrcmp(FileFound.cFileName, _T(".")) ) &&
                      ( lstrcmp(FileFound.cFileName, _T("..")) ) )
            {
                DeletePath(FileFound.cFileName);
            }

        }
        while ( FindNextFile(hFile, &FileFound) );
        FindClose(hFile);
    }

    // Go to the parent directory and remove the current one.
    // We have to make sure and reset the readonly attributes
    // on the dir also.
    //
    SetCurrentDirectory(_T(".."));
    SetFileAttributes(lpDirectory, FILE_ATTRIBUTE_NORMAL);
    return RemoveDirectory(lpDirectory);
}

BOOL DeleteFilesEx(LPCTSTR lpDirectory, LPCTSTR lpFileSpec)
{
    WIN32_FIND_DATA FileFound;
    HANDLE          hFile;
    TCHAR           szCurDir[MAX_PATH];

    // Validate the parameters.
    //
    if ( ( lpDirectory == NULL ) ||
         ( *lpDirectory == NULLCHR ) ||
         ( !SetCurrentDirectory(lpDirectory) ) )
    {
        return FALSE;
    }

    // Get our current directory so we can set ourself back
    //
    GetCurrentDirectory(MAX_PATH, szCurDir);

    // Process all the files and directories in the directory passed in.
    //
    SetCurrentDirectory(lpDirectory);
    if ( (hFile = FindFirstFile(lpFileSpec, &FileFound)) != INVALID_HANDLE_VALUE )
    {
        do
        {
            // First check to see if this is a file (not a directory).
            //
            if ( !( FileFound.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
            {
                DeleteFile(FileFound.cFileName);
            }
        }
        while ( FindNextFile(hFile, &FileFound) );
        FindClose(hFile);
    }

    SetCurrentDirectory(szCurDir);
    return TRUE;
}

LPTSTR AddPathN(LPTSTR lpPath, LPCTSTR lpName, DWORD cbPath)
{
    LPTSTR lpTemp = lpPath;

    // Validate the parameters passed in.
    //
    if ( ( lpPath == NULL ) ||
         ( lpName == NULL ) )
    {
        return NULL;
    }

    // Find the end of the path.
    //
    while ( *lpTemp )
    {
        lpTemp = CharNext(lpTemp);
        if ( cbPath )
        {
            cbPath--;
        }
    }

    // If no trailing backslash on the path then add one.
    //
    if ( ( lpTemp > lpPath ) &&
         ( *CharPrev(lpPath, lpTemp) != CHR_BACKSLASH ) )
    {
        // Make sure there is room in the path buffer to
        // add the backslash and the null terminator.
        //
        if ( cbPath < 2 )
        {
            return NULL;
        }

        *lpTemp = CHR_BACKSLASH;
        lpTemp = CharNext(lpTemp);
        cbPath--;
    }
    else
    {
        // Make sure there is at least room for the null
        // terminator.
        //
        if ( cbPath < 1 )
        {
            return NULL;
        }
    }

    // Make sure there is no preceeding spaces or backslashes
    // on the name to add.
    //
    while ( ( *lpName == CHR_SPACE ) ||
            ( *lpName == CHR_BACKSLASH ) )
    {
        lpName = CharNext(lpName);
    }

    // Add the new name to existing path.
    //
    lstrcpyn(lpTemp, lpName, cbPath);

    // Trim trailing spaces from result.
    //
    while ( ( lpTemp > lpPath ) &&
            ( *(lpTemp = CharPrev(lpPath, lpTemp)) == CHR_SPACE ) )
    {
        *lpTemp = NULLCHR;
    }

    return lpPath;
}

LPTSTR AddPath(LPTSTR lpPath, LPCTSTR lpName)
{
    return AddPathN(lpPath, lpName, 0xFFFFFFFF);
}

DWORD ExpandFullPath(LPTSTR lpszPath, LPTSTR lpszReturn, DWORD cbReturn)
{
    LPTSTR  lpszExpanded = AllocateExpand(lpszPath ? lpszPath : lpszReturn),
            lpszDontCare;
    DWORD   dwRet;

    *lpszReturn = NULLCHR;
    if ( NULL == lpszExpanded )
    {
        return 0;
    }
    dwRet = GetFullPathName(lpszExpanded, cbReturn, lpszReturn, &lpszDontCare);
    FREE(lpszExpanded);

    return dwRet;
}

BOOL CopyDirectory(LPCTSTR lpSrc, LPCTSTR lpDst)
{
    return ( CopyDirectoryEngine(NULL, NULL, lpSrc, lpDst, FALSE) != 0 );
}

BOOL CopyDirectoryProgress(HWND hwnd, LPCTSTR lpSrc, LPCTSTR lpDst)
{
    return ( CopyDirectoryEngine(hwnd, NULL, lpSrc, lpDst, FALSE) != 0 );
}

BOOL CopyDirectoryProgressCancel(HWND hwnd, HANDLE hEvent, LPCTSTR lpSrc, LPCTSTR lpDst)
{
    return ( CopyDirectoryEngine(hwnd, hEvent, lpSrc, lpDst, FALSE) != 0 );
}

DWORD FileCount(LPCTSTR lpSrc)
{
    return CopyDirectoryEngine(NULL, NULL, lpSrc, NULL, TRUE);
}

BOOL BrowseForFolder(HWND hwndParent, INT iString, LPTSTR lpDirBuf, DWORD dwFlags)
{
    BROWSEINFO      bi = {0};
    TCHAR           szBuffer[MAX_PATH],
                    szPath[MAX_PATH],
                    szTitle[256] = NULLSTR;
    LPITEMIDLIST    lpil;

    // Copy the current directory into the buffer so
    // we start out from that folder.
    //
    lstrcpyn(szPath, lpDirBuf, AS(szPath));

    // Load the instructional text for the dialog.
    //
    if ( iString )
        LoadString(NULL, iString, szTitle, sizeof(szTitle) / sizeof(TCHAR));

    // Setup the BrowseInfo struct.
    //
    bi.hwndOwner        = hwndParent;
    bi.pidlRoot         = NULL;
    bi.pszDisplayName   = szBuffer;
    bi.lpszTitle        = szTitle;
    bi.ulFlags          = dwFlags ? dwFlags : BIF_RETURNONLYFSDIRS;
    bi.lpfn             = (BFFCALLBACK) BrowseCallbackProc;
    bi.lParam           = (LPARAM) szPath;

    // Return the new path if we got one.
    //
    if ( ( (lpil = SHBrowseForFolder(&bi)) != NULL ) &&
         ( SHGetPathFromIDList(lpil, szPath) && szPath[0] && DirectoryExists(szPath) ) )
    {
        lstrcpy(lpDirBuf, szPath);
        return TRUE;
    }

    return FALSE;
}

BOOL BrowseForFile(HWND hwnd, INT iTitle, INT iFilter, INT iExtension, LPTSTR lpFileName, DWORD cbFileName, LPTSTR lpDirectory, DWORD dwFlags)
{
    OPENFILENAME    ofn = {sizeof(ofn)};
    TCHAR           szTitle[256]            = NULLSTR,
                    szFilter[256]           = NULLSTR,
                    szExtension[256]        = NULLSTR,
                    szFullPath[MAX_PATH]    = NULLSTR;
    LPTSTR          lpSearch,
                    lpNext,
                    lpFilePart              = NULL;

    // Load all the strings we need for the open file structure.
    //
    if ( iTitle )
        LoadString(NULL, iTitle, szTitle, sizeof(szTitle) / sizeof(TCHAR));
    if ( iFilter )
        LoadString(NULL, iFilter, szFilter, sizeof(szFilter) / sizeof(TCHAR));
    if ( iExtension )
        LoadString(NULL, iExtension, szExtension, sizeof(szExtension) / sizeof(TCHAR));

    // Replace all the | in the filter string with \0.
    //
    lpSearch = szFilter;
    while ( *lpSearch )
    {
        lpNext = CharNext(lpSearch);
        if ( *lpSearch == _T('|') )
            *lpSearch = NULLCHR;
        lpSearch = lpNext;
    }

    // Figure out what the default directory and file will be.
    //
    if ( *lpFileName && GetFullPathName(lpFileName, STRSIZE(szFullPath), szFullPath, &lpFilePart) && szFullPath[0] )
    {
        // If the whole path is a directory, there is no file part.
        //
        if ( DirectoryExists(szFullPath) )
            lpFilePart = NULL;

        // Copy off the file name part.
        //
        if ( lpFilePart && ( (DWORD) lstrlen(lpFilePart) < cbFileName ) )
            lstrcpy(lpFileName, lpFilePart);
        else
            *lpFileName = NULLCHR;

        // Now chop off the file name so we are left with the directory.
        //
        if ( lpFilePart )
            *lpFilePart = NULLCHR;
    }
    else
    {
        // No cool default directory or file name to use, so we use the
        // directory passed in and no file name.
        //
        *lpFileName = NULLCHR;
        szFullPath[0] = NULLCHR;
    }

    // Setup the open file struture.
    //
    ofn.hwndOwner         = hwnd;
    ofn.lpstrFilter       = szFilter[0] ? szFilter : NULL;
    ofn.nFilterIndex      = szFilter[0] ? 1 : 0;
    ofn.lpstrFile         = lpFileName;
    ofn.nMaxFile          = cbFileName;
    ofn.lpstrInitialDir   = ( szFullPath[0] && DirectoryExists(szFullPath) ) ? szFullPath : lpDirectory;
    ofn.lpstrTitle        = szTitle[0] ? szTitle : NULL;
    ofn.lpstrDefExt       = szExtension[0] ? szExtension : NULL;
    ofn.Flags             = dwFlags ? dwFlags : (OFN_HIDEREADONLY | OFN_FILEMUSTEXIST);

    // Make sure the buffer is zero'ed out if the function failes.
    //
    if ( !GetOpenFileName(&ofn) )
        *lpFileName = NULLCHR;

    // Return true only if we are passing back a file name.
    //
    return ( *lpFileName != NULLCHR );
}


//
// Internal Functions:
//

static DWORD CopyDirectoryEngine(HWND hwnd, HANDLE hEvent, LPCTSTR lpSrc, LPCTSTR lpDst, BOOL fCount)
{
    WIN32_FIND_DATA FileFound;
    HANDLE          hFile;
    BOOL            bReturn     = TRUE;
    DWORD           dwReturn    = 0;
    TCHAR           szDst[MAX_PATH];
    LPTSTR          lpFileName,
                    lpSearch    = NULL;

    // If a source directory was passed in, set the current directory
    // to it because that is we we are going to search for files.
    //
    if ( lpSrc )
    {
        // If the source isn't a directory, it is a file or file pattern we are
        // copying.
        //
        if ( DirectoryExists(lpSrc) )
        {
            // Now make sure we set the current directory to the source directory.
            //
            bReturn = SetCurrentDirectory(lpSrc);
        }
        else
        {
            // We have to separate the path from the file or file pattern.
            //
            if ( lpSearch = _tcsrchr(lpSrc, CHR_BACKSLASH) )
            {
                // Set the current directory to the path part of the source buffer.
                //
                TCHAR szPath[MAX_PATH];
                lstrcpyn(szPath, lpSrc, 1 + (int)(lpSearch - lpSrc));
                if ( *(lpSearch = CharNext(lpSearch)) == NULLCHR )
                    lpSearch = NULL;
                bReturn = SetCurrentDirectory(szPath);
            }
            else
                lpSearch = (LPTSTR) lpSrc;
        }
    }

    // Make sure the source directory existed, create the
    // destination directory, and make sure it exists also.
    //
    if ( bReturn && ( fCount || ( bReturn = CreatePath(lpDst) ) ) )
    {
        // Setup the destination buffer with a pointer to the
        // end of the path.
        //
        if ( !fCount )
        {
            lstrcpy(szDst, lpDst);
            AddPath(szDst, NULLSTR);
            lpFileName = szDst + lstrlen(szDst);
        }

        // Process all the files and directories in the directory passed in.
        //
        if ( (hFile = FindFirstFile(lpSearch ? lpSearch : _T("*"), &FileFound)) != INVALID_HANDLE_VALUE )
        {
            do
            {
                // Create the full path destination name.
                //
                if ( !fCount )
                    lstrcpy(lpFileName, FileFound.cFileName);

                // First check to see if this is a file (not a directory).
                //
                if ( !( FileFound.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
                {
                    // Copy the file from the source to the destination.
                    //
                    fCount ? (dwReturn++) : (bReturn = CopyResetFile(FileFound.cFileName, szDst));

                    // Increase the progress bar.  This is the only difference between
                    // CopyDirectroy() and CopyDirectoryProgress().
                    //
                    if ( hwnd )
                        SendMessage(hwnd, PBM_STEPIT, 0, 0);

                }
                // Otherwise, make sure the directory is not "." or "..".
                //
                else if ( lstrcmp(FileFound.cFileName, _T(".")) &&
                          lstrcmp(FileFound.cFileName, _T("..")) &&
                          SetCurrentDirectory(FileFound.cFileName) )
                {
                    // Process all the files there.
                    //
                    DWORD dwBuffer = CopyDirectoryEngine(hwnd, hEvent, NULL, szDst, fCount);
                    fCount ? (dwReturn += dwBuffer) : (bReturn = (dwBuffer != 0));
                    SetCurrentDirectory(_T(".."));
                }

                // Check event to see if the user canceled.
                //
                if ( hEvent && ( WaitForSingleObject(hEvent, 0) != WAIT_TIMEOUT ) )
                    bReturn = FALSE;

            }
            while ( bReturn && FindNextFile(hFile, &FileFound) );
            FindClose(hFile);
        }
    }

    return bReturn ? (fCount ? dwReturn : 1) : 0;
}

static CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    TCHAR   szPathName[MAX_PATH];
    LPTSTR  lpszData = (LPTSTR) lpData;

    switch ( uMsg )
    {
        case BFFM_INITIALIZED:  

            // Initialize the dialog with the OK button and current directory.
            //
            if ( lpszData && *lpszData )
            {
                LPTSTR lpEnd;

                // Make sure there is a trailing backslash so that a drive passed in
                // works (like c:).
                //
                szPathName[0] = NULLCHR;
                if ( GetFullPathName(lpszData, STRSIZE(szPathName), szPathName, NULL) && szPathName[0] )
                    lstrcpy(lpszData, szPathName);

                // For some dumb reason, the BFFM_SETSELECTION doesn't like it when there
                // is a trailing backslash on the path.
                //
                if ( ( lstrlen(lpszData) > 3 ) &&
                     ( lpEnd = CharPrev(lpszData, lpszData + lstrlen(lpszData)) ) &&
                     ( *lpEnd == CHR_BACKSLASH ) )
                {
                    *lpEnd = NULLCHR;
                }

                // Update the tree with the default dir and enable/disable the OK button
                // if there is a valid directory.
                //
                SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
                SendMessage(hwnd, BFFM_ENABLEOK, 0, (DirectoryExists(lpszData) != 0));
            }
            else
                SendMessage(hwnd, BFFM_ENABLEOK, 0, 0);
            break;

        case BFFM_SELCHANGED:
            
            // Turn the id into a folder name.
            //
            szPathName[0] = NULLCHR;
            if ( SHGetPathFromIDList((LPITEMIDLIST) lParam, szPathName) && szPathName[0] && DirectoryExists(szPathName) )
            {
                SetDlgItemText(hwnd, IDC_BROWSE_EDIT, szPathName);
                SendMessage(hwnd, BFFM_ENABLEOK, 0, 1);
            }
            else
                SendMessage(hwnd, BFFM_ENABLEOK, 0, 0);
            break;

        case BFFM_VALIDATEFAILED:
            SendMessage(hwnd, BFFM_ENABLEOK, 0, 0);
            return TRUE;
    }

    return 0;
}

BOOL CreateUnicodeFile(LPCTSTR lpFile)
{
    HANDLE  hFile;
    DWORD   dwWritten = 0;
    WCHAR   cHeader =  0xFEFF;
    BOOL    bReturn = FALSE;

    // If we have a file name and the file does not exist, attempt to create
    //
    if ( lpFile && *lpFile && !FileExists(lpFile))
    {
        if ( (hFile = CreateFile(lpFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE)
        {
            WriteFile(hFile, &cHeader, sizeof(cHeader), &dwWritten, NULL);

            CloseHandle(hFile);

            bReturn = TRUE;
        }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\opklib\log.c ===
/****************************************************************************\

    LOG.C / OPK Library (OPKLIB.LIB)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    Logging API source file for use in the OPK tools.

    08/00 - Jason Cohen (JCOHEN)
        Added this new source file to Whistler for common logging
        functionality across all the OPK tools.

\****************************************************************************/


//
// Include File(s):
//

#include <pch.h>
#include <stdio.h>


//
// Defines
//

#ifdef CHR_NEWLINE
#undef CHR_NEWLINE
#endif // CHR_NEWLINE
#define CHR_NEWLINE              _T('\n')


#ifdef CHR_CR
#undef CHR_CR
#endif // CHR_CR
#define CHR_CR                   _T('\r')


// Global logging info handle.
//
PLOG_INFO g_pLogInfo = NULL;



//
// Exported Function(s):
//

INT LogFileLst(LPCTSTR lpFileName, LPTSTR lpFormat, va_list lpArgs)
{
    INT     iChars  = 0;
    HANDLE  hFile;

    // Make sure we have the required params and can create the file.
    //
    if ( ( lpFileName && lpFileName[0] && lpFormat ) &&
         ( hFile = _tfopen(lpFileName, _T("a")) ) )
    {
        // Print the debug message to the end of the file.
        //
        iChars = _vftprintf(hFile, lpFormat, lpArgs);

        // Close the handle to the file.
        //
        fclose(hFile);
    }

    // Return the number of chars written from the printf call.
    //
    return iChars;
}

INT LogFileStr(LPCTSTR lpFileName, LPTSTR lpFormat, ...)
{
    va_list lpArgs;

    // Initialize the lpArgs parameter with va_start().
    //
    va_start(lpArgs, lpFormat);

    // Return the return value of the MessageBox() call.  If there was a memory
    // error, 0 will be returned.  This is all 
    //
    return LogFileLst(lpFileName, lpFormat, lpArgs);
}

INT LogFile(LPCTSTR lpFileName, UINT uFormat, ...)
{
    va_list lpArgs;
    INT     nReturn;
    LPTSTR  lpFormat = NULL;

    // Initialize the lpArgs parameter with va_start().
    //
    va_start(lpArgs, uFormat);

    // Get the format and caption strings from the resource.
    //
    if ( uFormat )
        lpFormat = AllocateString(NULL, uFormat);

    // Return the return value of the MessageBox() call.  If there was a memory
    // error, 0 will be returned.
    //
    nReturn = LogFileLst(lpFileName, lpFormat, lpArgs);

    // Free the format and caption strings.
    //
    FREE(lpFormat);

    // Return the value saved from the previous function call.
    //
    return nReturn;
}

//
// Function Implementations
//


/*++

Routine Description:

    This routine ckecks the specified ini file for settings for logging.  Logging 
    is enabled by default if nothing is specified in the ini file.  
    Disables logging by setting pLogInfo->szLogFile = NULL.
    
Arguments:

    None.

Return Value:

    None.

--*/

BOOL OpkInitLogging(LPTSTR lpszIniPath, LPTSTR lpAppName)
{
    TCHAR     szScratch[MAX_PATH] = NULLSTR;
    LPTSTR    lpszScratch;
    BOOL      bWinbom = ( lpszIniPath && *lpszIniPath );
    PLOG_INFO pLogInfo = NULL;

    pLogInfo = MALLOC(sizeof(LOG_INFO));

    if ( NULL == pLogInfo )
    {
        return FALSE;
    }
    
    if ( lpAppName )
    {
        pLogInfo->lpAppName = MALLOC((lstrlen(lpAppName) + 1) * sizeof(TCHAR));
        lstrcpy(pLogInfo->lpAppName, lpAppName);
    }
    
    // First check if logging is disabled in the WinBOM.
    //
    if ( ( bWinbom ) &&
         ( GetPrivateProfileString(INI_SEC_LOGGING, INI_KEY_LOGGING, _T("YES"), szScratch, AS(szScratch), lpszIniPath) ) &&
         ( LSTRCMPI(szScratch, INI_VAL_NO) == 0 ) )
    {
        // FREE macro sets pLogInfo to NULL.
        FREE(pLogInfo->lpAppName);
        FREE(pLogInfo);
    }
    else
    {
        // All these checks can only be done if we have a winbom.
        //
        if ( bWinbom )
        {
            // Check for quiet mode.  If we are in quiet mode don't display any MessageBoxes. 
            //
            if ( ( GetPrivateProfileString(INI_SEC_LOGGING, INI_KEY_QUIET, NULLSTR, szScratch, AS(szScratch), lpszIniPath) ) &&
                 ( 0 == LSTRCMPI(szScratch, INI_VAL_YES) )
               )
            {
                SET_FLAG(pLogInfo->dwLogFlags, LOG_FLAG_QUIET_MODE);
            }

/*            // See if they want to turn on perf logging.
            //
            szScratch[0] = NULLCHR;
            if ( ( GetPrivateProfileString(WBOM_FACTORY_SECTION, INI_KEY_WBOM_LOGPERF, NULLSTR, szScratch, AS(szScratch), lpszIniPath) ) &&
                 ( 0 == lstrcmpi(szScratch, WBOM_YES) ) )
            {
                SET_FLAG(pLogInfo->dwLogFlags, FLAG_LOG_PERF);
            }
*/      
            // Set the logging level.
            //
            pLogInfo->dwLogLevel = (DWORD) GetPrivateProfileInt(INI_SEC_LOGGING, INI_KEY_LOGLEVEL, (DWORD) pLogInfo->dwLogLevel, lpszIniPath);
        }

#ifndef DBG
        if ( pLogInfo->dwLogLevel >= LOG_DEBUG )
            pLogInfo->dwLogLevel = LOG_DEBUG - 1;
#endif
        
        // Check to see if they have a custom log file they want to use.
        //
        if ( ( bWinbom ) &&
             ( lpszScratch = IniGetExpand(lpszIniPath, INI_SEC_LOGGING, INI_KEY_LOGFILE, NULL) ) )
        {
            TCHAR   szFullPath[MAX_PATH]    = NULLSTR;
            LPTSTR  lpFind                  = NULL;

            // Turn the ini key into a full path.
            //
            
            // NTRAID#NTBUG9-551266-2002/03/27-acosma,robertko - Buffer overrun possibility.
            //
            lstrcpy(pLogInfo->szLogFile, lpszScratch);
            if (GetFullPathName(pLogInfo->szLogFile, AS(szFullPath), szFullPath, &lpFind) && szFullPath[0] && lpFind)
            {
                // Copy the full path into the global.
                //
                lstrcpyn(pLogInfo->szLogFile, szFullPath, AS(pLogInfo->szLogFile));

                // Chop off the file part so we can create the
                // path if it doesn't exist.
                //
                *lpFind = NULLCHR;

                // If the directory cannot be created or doesn't exist turn off logging.
                //
                if (!CreatePath(szFullPath))
                    pLogInfo->szLogFile[0] = NULLCHR;
            }

            // Free the original path buffer from the ini file.
            //
            FREE(lpszScratch);
        }
        else  // default case
        {
            // Create it in the current directory.
            //
            GetCurrentDirectory(AS(pLogInfo->szLogFile), pLogInfo->szLogFile);
            
            // NTRAID#NTBUG9-551266-2002/03/27-acosma - Buffer overrun possibility.
            //
            AddPath(pLogInfo->szLogFile, _T("logfile.txt"));
        }

        // Check to see if we have write access to the logfile. If we don't turn off logging.
        // If we're running in WinPE we'll call this function again once the drive becomes
        // writable.
        //
        // Write an FFFE header to the file to identify this as a Unicode text file.
        //
        if ( pLogInfo->szLogFile[0] )
        {
            HANDLE hFile;
            DWORD dwWritten = 0;
            WCHAR cHeader =  0xFEFF;
     
            SetLastError(ERROR_SUCCESS);
   
            if ( INVALID_HANDLE_VALUE != (hFile = CreateFile(pLogInfo->szLogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)))
            {
                if ( ERROR_ALREADY_EXISTS != GetLastError() )
                    WriteFile(hFile, &cHeader, sizeof(cHeader), &dwWritten, NULL);
                CloseHandle(hFile);
            }
            else
            {   // There was a problem opening the file.  Most of the time this means that the media is not writable.
                // Disable logging in that case. Macro sets variable to NULL.
                //
                FREE(pLogInfo->lpAppName);
                FREE(pLogInfo);
            }
        }
    }

    g_pLogInfo = pLogInfo;
    return TRUE;
}

// NTRAID#NTBUG9-551266-2002/03/27-acosma,robertko - Buffer overrun possibilities in this function. Use strsafe functions.
//
DWORD OpkLogFileLst(PLOG_INFO pLogInfo, DWORD dwLogOpt, LPTSTR lpFormat, va_list lpArgs)
{
    LPTSTR lpPreOut             = NULL;
    LPTSTR lpOut                = NULL;
    DWORD  dwSize               = 1024;
    TCHAR  szPreLog[MAX_PATH]   = NULLSTR;
    HANDLE hFile;
    DWORD  dwWritten            = 0;
    DWORD  cbAppName            = 0;
    DWORD  dwLogLevel           = (DWORD) (dwLogOpt & LOG_LEVEL_MASK);
    
    
    if ( ( dwLogLevel <= pLogInfo->dwLogLevel) && lpFormat )
    {    
        // Build the output string.
        //
        if ( pLogInfo->lpAppName )
        {
            // Create the prefix string
            //
            lstrcpy(szPreLog, pLogInfo->lpAppName);
            lstrcat(szPreLog, _T("::"));
        }
        
        // This is for skipping the App Name prefix when printing to the log file
        //
        cbAppName = lstrlen(szPreLog);
        
        if ( GET_FLAG(dwLogOpt, LOG_ERR) )
        {
            if ( 0 == dwLogLevel )
                lstrcat(szPreLog, _T("ERROR: "));
            else
                swprintf(szPreLog + cbAppName, _T("WARN%d: "), dwLogLevel);
        }
      
        if ( GET_FLAG(dwLogOpt, LOG_TIME) )
        {
            TCHAR  szTime[100] = NULLSTR;

            GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_FORCE24HOURFORMAT, NULL, _T("'['HH':'mm':'ss'] '"), szTime, AS(szTime));
            lstrcat(szPreLog, szTime);
        }

        // Replace all the parameters in the Error string. Allocate more memory if necessary.  
        // In case something goes seriously wrong here, cap memory allocation at 1 megabyte.
        //
        for ( lpPreOut = (LPTSTR) MALLOC((dwSize) * sizeof(TCHAR));
              lpPreOut && ( -1 == _vsnwprintf(lpPreOut, dwSize, lpFormat, lpArgs)) && dwSize < (1024 * 1024);
              FREE(lpPreOut), lpPreOut = (LPTSTR) MALLOC((dwSize *= 2) * sizeof(TCHAR))
            );

        //
        // We now have the Error string and the prefix string. Copy this to the final 
        // string that we need to output.
        //
        
        if ( lpPreOut )
        {
        
            // Allocate another string that will be the final output string. 
            // We need 1 extra TCHAR for NULL terminator and 2 extra for
            // an optional NewLine + Linefeed TCHAR pair that may be added.
            //
            dwSize = lstrlen(szPreLog) + lstrlen(lpPreOut) + 3;
            lpOut = (LPTSTR) MALLOC( (dwSize) * sizeof(TCHAR) );
            
            if ( lpOut )
            {
                lstrcpy(lpOut, szPreLog);
                lstrcat(lpOut, lpPreOut);
                
                // Make sure that string is terminated by NewLine unless the caller doesn't want to.
                //
                if ( !GET_FLAG(dwLogOpt, LOG_NO_NL) )
                {
                     LPTSTR lpNL = lpOut;
                     TCHAR szCRLF[] = _T("\r\n");
                     BOOL  bStringOk = FALSE;
                     
                     // Find the end of the string.
                     //
                     lpNL = lpNL + lstrlen(lpNL);
                     
                     // Make sure the string is terminated by "\r\n".
                     //
                     // There are three cases here: 
                     //  1. The string is already terminated by \r\n. Leave it alone.
                     //  2. String is terminated by \n.  Replace \n with \r\n.
                     //  3. String is not terminated by anything. Append string with \r\n.
                     //
                                                              
                     if ( CHR_NEWLINE == *(lpNL = (CharPrev(lpOut, lpNL))) )
                     {
                         if ( CHR_CR != *(CharPrev(lpOut, lpNL)) )
                         {
                            *(lpNL) = NULLCHR;
                         }
                         else
                         {
                             bStringOk = TRUE;
                         }
                     }
                     
                     // If there is a need to, fix up the string
                     //
                     if ( !bStringOk )
                     {
                         lstrcat( lpOut, szCRLF );
                     }
                }

                // Write the error to the file and close the file.
                // Skip the "AppName::" at the beginning of the string when printing to the file.
                //
                if ( pLogInfo->szLogFile[0] &&
                    ( INVALID_HANDLE_VALUE != (hFile = CreateFile(pLogInfo->szLogFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)))
                   )
                {
                    if ( INVALID_SET_FILE_POINTER != SetFilePointer(hFile, 0, 0, FILE_END) )
                    {
                        WriteFile(hFile, (lpOut + cbAppName), lstrlen(lpOut + cbAppName) * sizeof(TCHAR), &dwWritten, NULL);
                    }
                    CloseHandle(hFile);
                }              

                // Output the string to the debugger and free it.
                //
                OutputDebugString(lpOut);
                FREE(lpOut);
            }
            
            // Put up the MessageBox if specified.  This only allows message boxes
            // to be log level 0.
            //
            if ( !GET_FLAG(pLogInfo->dwLogFlags, LOG_FLAG_QUIET_MODE) && 
                 GET_FLAG(dwLogOpt, LOG_MSG_BOX) && 
                 (0 == dwLogLevel)
               )
                 MessageBox(NULL, lpPreOut, pLogInfo->lpAppName, MB_OK | MB_SYSTEMMODAL |
                            (GET_FLAG(dwLogOpt, LOG_ERR) ? MB_ICONERROR : MB_ICONWARNING) );

            // Free the error string
            //
            FREE(lpPreOut);
        }
    }
    

    // Return the number of bytes written to the file.
    //
    return dwWritten;
}


DWORD OpkLogFile(DWORD dwLogOpt, UINT uFormat, ...)
{
    va_list lpArgs;
    DWORD   dwWritten = 0;
    LPTSTR  lpFormat = NULL;
        
    if ( g_pLogInfo )
    {

        // Initialize the lpArgs parameter with va_start().
        //
        va_start(lpArgs, uFormat);

        if  ( lpFormat = AllocateString(NULL, uFormat) )
        {
            dwWritten = OpkLogFileLst(g_pLogInfo, dwLogOpt, lpFormat, lpArgs);
        }

        // Free the format string.
        //
        FREE(lpFormat);
    }
    
    // Return the value saved from the previous function call.
    //
    return dwWritten;
}


DWORD OpkLogFileStr(DWORD dwLogOpt, LPTSTR lpFormat, ...)
{
    va_list lpArgs;
    DWORD dwWritten = 0;
   
    if ( g_pLogInfo )
    {
        // Initialize the lpArgs parameter with va_start().
        //
        va_start(lpArgs, lpFormat);
    
        dwWritten = OpkLogFileLst(g_pLogInfo, dwLogOpt, lpFormat, lpArgs);
    }
    
    // Return the value saved from the previous function call.
    //
    return dwWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\opklib\midware.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    midware.c

Abstract:

    Setting OEM default middleware application settings.

    This is a separate .c file because the linker pulls in an entire OBJ file
    if any function in the OBJ file is called.

    (1) This file contains static data which we don't want pulled into a
        host application unless the application actually calls
        SetDefaultOEMApps().

    (2) The host application is expected to implement the function
        ReportSetDefaultOEMAppsError().  By keeping it in a separate
        OBJ, only host applications that call SetDefaultOEMApps()
        need to define ReportSetDefaultOEMAppsError().

--*/
#include <pch.h>
#include <winbom.h>

BOOL SetDefaultAppForType(LPCTSTR pszWinBOMPath, LPCTSTR pszType, LPCTSTR pszIniVar)
{
    TCHAR szBuf[MAX_PATH];
    TCHAR szDefault[MAX_PATH];
    HKEY hkType;
    BOOL fOEMAppSeen = FALSE;

    if (!pszWinBOMPath[0] ||
        !GetPrivateProfileString(INI_SEC_WBOM_SHELL, pszIniVar, NULLSTR,
                                 szDefault, ARRAYSIZE(szDefault),
                                 pszWinBOMPath))
    {
        // OEM didn't specify an app, so act as if we "saw" it
        // so we don't complain that the OEM specified an app that
        // isn't installed.
        fOEMAppSeen = TRUE;
    }

    wnsprintf(szBuf, ARRAYSIZE(szBuf), _T("Software\\Clients\\%s"), pszType);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0,
                     KEY_READ | KEY_WRITE, &hkType) == ERROR_SUCCESS)
    {
        DWORD dwIndex;
        for (dwIndex = 0;
             RegEnumKey(hkType, dwIndex, szBuf, ARRAYSIZE(szBuf)) == ERROR_SUCCESS;
             dwIndex++)
        {
            HKEY hkInfo;
            BOOL fIsOEMApp = lstrcmpi(szBuf, szDefault) == 0;
            StrCatBuff(szBuf, _T("\\InstallInfo"), ARRAYSIZE(szBuf));
            if (RegOpenKeyEx(hkType, szBuf, 0, KEY_READ | KEY_WRITE, &hkInfo) == ERROR_SUCCESS)
            {
                DWORD dw, dwType, cb;
                if (fIsOEMApp)
                {
                    // Set this as the OEM default app
                    dw = 1;
                    RegSetValueEx(hkInfo, _T("OEMDefault"), 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));
                    // If it's the default app, then ARP will show the icon automatically
                    RegDeleteValue(hkInfo, _T("OEMShowIcons"));
                    fOEMAppSeen = TRUE;
                }
                else
                {
                    // If it's not the OEM default app then untag it
                    RegDeleteValue(hkInfo, _T("OEMDefault"));

                    // and copy the current icon show state to the OEM show state
                    // (or delete the OEM show state if no show info is available)
                    cb = sizeof(dw);
                    if (RegQueryValueEx(hkInfo, _T("IconsVisible"), NULL, &dwType, (LPBYTE)&dw, &cb) == ERROR_SUCCESS &&
                        dwType == REG_DWORD && (dw == TRUE || dw == FALSE))
                    {
                        RegSetValueEx(hkInfo, _T("OEMShowIcons"), 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));
                    }
                    else
                    {
                        RegDeleteValue(hkInfo, _T("OEMShowIcons"));
                    }
                }
                RegCloseKey(hkInfo);
            }
        }

        RegCloseKey(hkType);
    }

    if (!fOEMAppSeen)
    {
        ReportSetDefaultOEMAppsError(szDefault, pszIniVar);
    }

    return fOEMAppSeen;
}

typedef struct {
    LPCTSTR pszKey;
    LPCTSTR pszIni;
} DEFAULTAPPINFO;

const DEFAULTAPPINFO c_dai[] = {
    { _T("StartMenuInternet") ,INI_KEY_WBOM_SHELL_DEFWEB     },
    { _T("Mail")              ,INI_KEY_WBOM_SHELL_DEFMAIL    },
    { _T("Media")             ,INI_KEY_WBOM_SHELL_DEFMEDIA   },
    { _T("IM")                ,INI_KEY_WBOM_SHELL_DEFIM      },
    { _T("JavaVM")            ,INI_KEY_WBOM_SHELL_DEFJAVAVM  },
};

BOOL SetDefaultOEMApps(LPCTSTR pszWinBOMPath)
{
    BOOL fRc = TRUE;
    int i;

    for (i = 0; i < ARRAYSIZE(c_dai); i++)
    {
        if (!SetDefaultAppForType(pszWinBOMPath, c_dai[i].pszKey, c_dai[i].pszIni))
        {
            fRc = FALSE;
        }
    }

    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\opklib\iniapi.c ===
/****************************************************************************\

    INIAPI.C / Common Routines Library

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    INI API source file for custom INI APIs used to easily interface with the
    private profile APIs and INI files.

    05/01 - Jason Cohen (JCOHEN)
        Added this new source file.

\****************************************************************************/


//
// Include file(s)
//

#include "pch.h"


//
// Internal Function Prototype(s):
//

static LPTSTR IniGetStr(LPTSTR lpszIniFile, LPTSTR lpszSection, LPTSTR lpszKey, LPTSTR lpszDefault, BOOL bSection, LPDWORD lpdwSize);


//
// External Function(s):
//

LPTSTR IniGetExpand(LPTSTR lpszIniFile, LPTSTR lpszSection, LPTSTR lpszKey, LPTSTR lpszDefault)
{
    LPTSTR lpszString = IniGetStr(lpszIniFile, lpszSection, lpszKey, lpszDefault, FALSE, NULL);

    // Make sure we go something from the ini file.
    //
    if ( lpszString )
    {
        LPTSTR lpszExpand = AllocateExpand(lpszString);

        // If we are able to expand it out, then free our original
        // buffer and return the expanded one.
        //
        if ( lpszExpand )
        {
            FREE(lpszString);
            return lpszExpand;
        }
    }

    return lpszString;
}

LPTSTR IniGetString(LPTSTR lpszIniFile, LPTSTR lpszSection, LPTSTR lpszKey, LPTSTR lpszDefault)
{
    return IniGetStr(lpszIniFile, lpszSection, lpszKey, lpszDefault, FALSE, NULL);
}

LPTSTR IniGetSection(LPTSTR lpszIniFile, LPTSTR lpszSection)
{
    return IniGetStr(lpszIniFile, lpszSection, NULL, NULL, TRUE, NULL);
}

LPTSTR IniGetStringEx(LPTSTR lpszIniFile, LPTSTR lpszSection, LPTSTR lpszKey, LPTSTR lpszDefault, LPDWORD lpdwSize)
{
    return IniGetStr(lpszIniFile, lpszSection, lpszKey, lpszDefault, FALSE, lpdwSize);
}

LPTSTR IniGetSectionEx(LPTSTR lpszIniFile, LPTSTR lpszSection, LPDWORD lpdwSize)
{
    return IniGetStr(lpszIniFile, lpszSection, NULL, NULL, TRUE, lpdwSize);
}

BOOL IniSettingExists(LPCTSTR lpszFile, LPCTSTR lpszSection, LPCTSTR lpszKey, LPCTSTR lpszValue)
{
    TCHAR szBuffer[256] = NULLSTR;

    // Make sure there is an ini file.
    //
    if ( !(lpszFile && *lpszFile) )
    {
        return FALSE;
    }

    // There also has to be a section.
    //
    if ( !(lpszSection && *lpszSection) )
    {
        return FileExists(lpszFile);
    }

    // See if they are checking for a key, or just the section.
    //
    if ( lpszKey && *lpszKey )
    {
        // Make sure the key exists.
        //
        GetPrivateProfileString(lpszSection, lpszKey, NULLSTR, szBuffer, AS(szBuffer), lpszFile);

        // The may want also check to see if the key is a particular value.
        //
        if ( lpszValue && *lpszValue )
        {
            return ( lstrcmpi(szBuffer, lpszValue) == 0 );
        }
    }
    else
    {
        // No key specified, so we just check for the entire section.
        //
        GetPrivateProfileSection(lpszSection, szBuffer, AS(szBuffer), lpszFile);
    }

    return ( NULLCHR != szBuffer[0] );
}


//
// Internal Function(s):
//

static LPTSTR IniGetStr(LPTSTR lpszIniFile, LPTSTR lpszSection, LPTSTR lpszKey, LPTSTR lpszDefault, BOOL bSection, LPDWORD lpdwSize)
{
    LPTSTR  lpszRet     = NULL;
    DWORD   dwChars     = 128,
            dwExtra     = bSection ? 2 : 1,
            dwReturn;

    // Get the string from the INI file.
    //
    do
    {
        // Start with 256 characters, doubling each time.
        //
        dwChars *= 2;

        // Free the previous buffer, if there was one.
        //
        if ( lpszRet )
        {
            // FREE() macro resets pointer to NULL.
            //
            FREE(lpszRet);
        }

        // Allocate a new buffer.
        //
        if ( lpszRet = (LPTSTR) MALLOC(dwChars * sizeof(TCHAR)) )
        {
            if ( bSection )
            {
                dwReturn = GetPrivateProfileSection(lpszSection, lpszRet, dwChars, lpszIniFile);
            }
            else
            {
                dwReturn = GetPrivateProfileString(lpszSection, lpszKey, lpszDefault ? lpszDefault : NULLSTR, lpszRet, dwChars, lpszIniFile);
            }
        }
        else
        {
            dwReturn = 0;
        }
    }
    while ( dwReturn >= (dwChars - dwExtra) );

    // If the don't want anything for the default value, we will always
    // free the string and pass back NULL if there was nothing returned by
    // the private profile API.
    //
    if ( ( NULL == lpszDefault ) &&
         ( lpszRet ) &&
         ( 0 == dwReturn ) )
    {
        // FREE() macro resets pointer to NULL.
        //
        FREE(lpszRet);
    }

    // See if we need to return the size of the buffer allocated.
    //
    if ( lpszRet && lpdwSize )
    {
        *lpdwSize = dwChars;
    }

    // Return the string, will be NULL if we didn't allocate anything.
    //
    return lpszRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\opklib\opkfac.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    opk.c

Abstract:

    Common modules shared by OPK tools.  Note: Source Depot requires that we 
    publish the .h (E:\NT\admin\published\ntsetup\opklib.w) and .lib 
    (E:\NT\public\internal\admin\lib).

Author:

    Brian Ku        (briank) 06/20/2000
    Stephen Lodwick (stelo)  06/28/2000

Revision History:

--*/
#include <pch.h>
#include <objbase.h>
#include <tchar.h>
#include <regstr.h>
#include <winbom.h>


//
// Local Define(s):
//

#define FILE_WINBOM_INI             _T("WINBOM.INI")
#define MAX_NAME                    50

#define REG_KEY_FACTORY             _T("SOFTWARE\\Microsoft\\Factory")
#define REG_KEY_FACTORY_STATE       REG_KEY_FACTORY _T("\\State")
#define REG_KEY_SETUP_SETUP         REGSTR_PATH_SETUP REGSTR_KEY_SETUP
#define REG_VAL_FACTORY_WINBOM      _T("WinBOM")
#define REG_VAL_FACTORY_USERNAME    _T("UserName")
#define REG_VAL_FACTORY_PASSWORD    _T("Password")
#define REG_VAL_FACTORY_DOMAIN      _T("Domain")
#define REG_VAL_DEVICEPATH          _T("DevicePath")
#define REG_VAL_SOURCEPATH          _T("SourcePath")
#define REG_VAL_SPSOURCEPATH        _T("ServicePackSourcePath")

#define DIR_SYSTEMROOT              _T("%SystemDrive%\\") // This has to have the trailing backslash, don't remove.

#define NET_TIMEOUT                 30000   // Time out to wait for net to start in milliseconds.

//
// Local Type Define(s):
//

typedef struct _STRLIST
{
    LPTSTR              lpszData;
    struct _STRLIST *   lpNext;
}
STRLIST, *PSTRLIST, *LPSTRLIST;


//
// Local variables
// 
static WCHAR NameOrgName[MAX_NAME+1];
static WCHAR NameOrgOrg[MAX_NAME+1];

static LPTSTR CleanupDirs [] =
{
    {_T("Win9xmig")},
    {_T("Win9xupg")},
    {_T("Winntupg")}
};

//
// Internal Fuction Prototype(s):
//

static BOOL CheckWinbomRegKey(LPTSTR lpWinBOMPath,  DWORD cbWinbBOMPath,
                              LPTSTR lpszShare,     DWORD cbShare,
                              LPTSTR lpszUser,      DWORD cbUser,
                              LPTSTR lpszPass,      DWORD cbPass,
                              LPTSTR lpFactoryMode, LPTSTR lpKey,
                              BOOL bNetwork,        LPBOOL lpbExists);
static BOOL SearchRemovableDrives(LPTSTR lpWinBOMPath, DWORD cbWinbBOMPath, LPTSTR lpFactoryMode, UINT uDriveType);
static BOOL WinBOMExists(LPTSTR lpWinBom, LPTSTR lpMode);

static void SavePathList(HKEY hKeyRoot, LPTSTR lpszSubKey, LPSTRLIST lpStrList, BOOL bWrite);
static BOOL AddPathToList(LPTSTR lpszExpanded, LPTSTR lpszPath, LPSTRLIST * lplpSorted, LPSTRLIST * lplpUnsorted);
static void EnumeratePath(LPTSTR lpszPath, LPSTRLIST * lplpSorted, LPSTRLIST * lplpUnsorted);
static BOOL AddPathsToList(LPTSTR lpszBegin, LPTSTR lpszRoot, LPSTRLIST * lplpSorted, LPSTRLIST * lplpUnsorted, BOOL bRecursive);


/*++

Routine Description:

    Enable or disable a given named privilege.

Arguments:

    PrivilegeName - supplies the name of a system privilege.

    Enable - flag indicating whether to enable or disable the privilege.

Return Value:

    Boolean value indicating whether the operation was successful.

--*/
BOOL
EnablePrivilege(
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    )
{
    HANDLE Token;
    BOOL bRet;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    bRet = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );
    //
    // The return value of AdjustTokenPrivileges() can be true even though we didn't set all
    // the privileges that we asked for.  We need to call GetLastError() to make sure the call succeeded.
    //
    bRet = bRet && ( ERROR_SUCCESS == GetLastError() );

    CloseHandle(Token);

    return(bRet);
}


/*++
===============================================================================
Routine Description:

    This routine will clean up any registry changes that we made to facilitate
    the factory pre-install process

Arguments:

    none
    
Return Value:

===============================================================================
--*/
void  CleanupRegistry
(
    void
)
{
    HKEY        hSetupKey;
    DWORD       dwResult;
    DWORD       dwValue = 0;
                    
    // Open HKLM\System\Setup
    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            L"SYSTEM\\Setup",
                            0,
                            KEY_ALL_ACCESS,
                            &hSetupKey);
    if (NO_ERROR == dwResult)
    {
        // Set the SystemSetupInProgress Value to 0.
        RegSetValueEx(hSetupKey,
                      L"SystemSetupInProgress",
                      0,
                      REG_DWORD,
                      (LPBYTE) &dwValue,
                      sizeof(DWORD));
        
        dwValue = 0;
        RegSetValueEx(hSetupKey,
                      L"SetupType",
                      0,
                      REG_DWORD,
                      (CONST BYTE *)&dwValue,
                      sizeof(DWORD));

        
        
        // Delete the FactoryPreInstall value
        RegDeleteValue(hSetupKey, L"FactoryPreInstallInProgress");
        RegDeleteValue(hSetupKey, L"AuditInProgress");
        
        // Close the setup reg key
        RegCloseKey(hSetupKey);
    }

    return;
}

//
// Get Organization and Owner names from registry
//
void GetNames(TCHAR szNameOrgOrg[], TCHAR szNameOrgName[])
{
    HKEY  hKey = NULL;
    DWORD dwLen =  0;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"), &hKey)) {            
        dwLen = MAX_NAME;
        RegQueryValueEx(hKey, TEXT("RegisteredOrganization"), 0, 0, (LPBYTE)szNameOrgOrg, &dwLen);

        dwLen = MAX_NAME;
        RegQueryValueEx(hKey, TEXT("RegisteredOwner"), 0, 0, (LPBYTE)szNameOrgName, &dwLen);

        RegCloseKey(hKey);
    }
}

//
// Strip out non alphabets from guid
//
DWORD StripDash(TCHAR *pszGuid)
{
    TCHAR *pszOrg, *pszTemp = pszGuid;
    pszOrg = pszGuid;

    while (pszGuid && *pszGuid != TEXT('\0')) {
        if (*pszTemp != TEXT('-') && *pszTemp != TEXT('{') && *pszTemp != TEXT('}'))
            *pszGuid++ = *pszTemp++;
        else
            pszTemp++;
    }
    if (pszOrg)
        return (DWORD)lstrlen(pszOrg);

    return 0;
}

//
// GenUniqueName - Create a random computer name with a base name of 8 chars
//
VOID GenUniqueName(
        OUT PWSTR GeneratedString,
        IN  DWORD DesiredStrLen
        )
{
    GUID  guid;
    DWORD total = 0, length = 0;
    TCHAR szGuid[MAX_PATH];

    // If we have a valid out param 
    //
    if (GeneratedString) {

        static PCWSTR UsableChars = L"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

        //
        // How many characters will come from the org/name string.
        //
        DWORD   BaseLength = 8;
        DWORD   i,j;
        DWORD   UsableCount;

        if( DesiredStrLen < BaseLength ) {
            BaseLength = DesiredStrLen - 1;
        }

        // 
        // Get the Organization and Owner name from registry
        //
        GetNames(NameOrgOrg, NameOrgName);

        if( NameOrgOrg[0] ) {
            wcscpy( GeneratedString, NameOrgOrg );
        } else if( NameOrgName[0] ) {
            wcscpy( GeneratedString, NameOrgName );
        } else {
            wcscpy( GeneratedString, TEXT("X") );
            for( i = 1; i < BaseLength; i++ ) {
                wcscat( GeneratedString, TEXT("X") );
            }
        }

        //
        // Get him upper-case for our filter...
        //
        CharUpper(GeneratedString);

        //
        // Now we want to put a '-' at the end
        // of our GeneratedString.  We'd like it to
        // be placed in the BASE_LENGTH character, but
        // the string may be shorter than that, or may
        // even have a ' ' in it.  Figure out where to
        // put the '-' now.
        //
        for( i = 0; i <= BaseLength; i++ ) {

            //
            // Check for a short string.
            //
            if( (GeneratedString[i] == 0   ) ||
                (GeneratedString[i] == L' ') ||
                (!wcschr(UsableChars, GeneratedString[i])) ||
                (i == BaseLength      )
              ) {
                GeneratedString[i] = L'-';
                GeneratedString[i+1] = 0;
                break;
            }
        }

        //
        // Special case the scenario where we had no usable
        // characters.
        //
        if( GeneratedString[0] == L'-' ) {
            GeneratedString[0] = 0;
        }

        total = lstrlen(GeneratedString);

        // Loop until we have meet the desired string length
        //
        while (total < DesiredStrLen) {

            // Create a unique guid to be used in the string
            //
            CoCreateGuid(&guid);
            StringFromGUID2(&guid, szGuid, AS(szGuid));

            // Remove the curly brace and dashes to generate the string
            //
            length = StripDash(szGuid);
            total += length;
            if (!lstrlen(GeneratedString)) {
                if (DesiredStrLen < total)
                    lstrcpyn(GeneratedString, szGuid, DesiredStrLen+1); /* +1 for NULL */
                else
                    lstrcpy(GeneratedString, szGuid);
            }
            else if (total < DesiredStrLen)
                lstrcat(GeneratedString, szGuid);
            else
                _tcsncat(GeneratedString, szGuid, (length - (total - DesiredStrLen)));
        }

        CharUpper(GeneratedString);
        
        // Assert if (total != DesiredStrLen)
        //
    }
}


/****************************************************************************\

BOOL                        // Returns TRUE if any credentials are found and
                            // are going to be returned.

GetCredentials(             // Tries to get user credentials from a few
                            // different places.

    LPTSTR  lpszUsername,   // Pointer to a string buffer that will recieve
                            // the user name for the credentials found.

    DWORD   cbUsername,     // Size, in characters, of the lpszUsername
                            // string buffer.

    LPTSTR  lpszPassword,   // Pointer to a string buffer that will recieve
                            // the password for the credentials found.

    DWORD   cbPassword,     // Size, in characters, of the lpszPassword
                            // string buffer.

    LPTSTR  lpFileName,     // Optional pointer to the file name that will
                            // contain the credentials.  If this is NULL or
                            // an empty string, the know registry key will
                            // be checked instead for the credentials.

    LPTSTR  lpAlternate     // Optional pointer to the alternate section to
                            // check first if lpFileName is vallid, or the
                            // the optional registry key to check instead of
                            // the normal known one.

);

\****************************************************************************/

BOOL GetCredentials(LPTSTR lpszUsername, DWORD cbUsername, LPTSTR lpszPassword, DWORD cbPassword, LPTSTR lpFileName, LPTSTR lpAlternate)
{
    BOOL  bRet = FALSE;
    TCHAR szUsername[UNLEN + 1] = NULLSTR,
          szPassword[PWLEN + 1] = NULLSTR,
          szDomain[DNLEN + 1]   = NULLSTR;
    LPSTR lpUserName;
    HKEY  hKey;
    DWORD dwType,
          dwSize;
    BOOL  bAlternate = ( lpAlternate && *lpAlternate );

    // Make sure there is a filename, otherwise we check the registry.
    //
    if ( lpFileName && *lpFileName )
    {
        // First try the alternate key for a user name.
        //
        if ( bAlternate )
        {
            GetPrivateProfileString(lpAlternate, INI_VAL_WBOM_USERNAME, NULLSTR, szUsername, AS(szUsername), lpFileName);
        }

        // If none found, try the normal section.  If they happen
        // to pass the normal section in as the alternate section then
        // we will check it twice if no key exists, no big deal.
        //
        if ( NULLCHR == szUsername[0] )
        {
            lpAlternate = WBOM_FACTORY_SECTION;
            GetPrivateProfileString(lpAlternate, INI_VAL_WBOM_USERNAME, NULLSTR, szUsername, AS(szUsername), lpFileName);
        }

        // Make sure we found a user name.
        //
        if ( szUsername[0] )
        {
            // If there is now backslash in the username, and there is a domain key, use that as the domain
            //
            if ( ((StrChr( szUsername, CHR_BACKSLASH )) == NULL) &&
                 (GetPrivateProfileString(lpAlternate, INI_VAL_WBOM_DOMAIN, NULLSTR, szDomain, AS(szDomain), lpFileName)) && szDomain[0]
               )
            {
                // Copy the "domain\username" string into the returning buffer
                //
                lstrcpyn(lpszUsername, szDomain, cbUsername);
                AddPathN(lpszUsername, szUsername, cbUsername);
            }
            else
            {
                // Copy the username into the returning buffer
                //
                lstrcpyn(lpszUsername, szUsername, cbUsername);
            }

            // We found the credentials
            //
            bRet = TRUE;

            // Get the password
            //
            if ( GetPrivateProfileString(lpAlternate, INI_VAL_WBOM_PASSWORD, NULLSTR, szPassword, AS(szPassword), lpFileName) )
            {
                // Copy the password into the returning buffer
                //
                lstrcpyn(lpszPassword, szPassword, cbPassword);
            }
            else
                *lpszPassword = NULLCHR;

        }
    }
    else if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, bAlternate ? lpAlternate : REG_KEY_FACTORY, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS )
    {
        // Check the registry key to see if it has user credentials.
        //
        dwSize = sizeof(szUsername);
        if ( ( RegQueryValueEx(hKey, REG_VAL_FACTORY_USERNAME, NULL, &dwType, (LPBYTE) szUsername, &dwSize) == ERROR_SUCCESS ) &&
             ( dwType == REG_SZ ) &&
             ( szUsername[0] ) )
        {
            // Check the registry key to see if it has user credentials.
            //
            dwSize = sizeof(szDomain);
            if ( ( StrChr(szUsername, CHR_BACKSLASH) == NULL ) &&
                 ( RegQueryValueEx(hKey, REG_VAL_FACTORY_DOMAIN, NULL, &dwType, (LPBYTE) szDomain, &dwSize) == ERROR_SUCCESS ) &&
                 ( dwType == REG_SZ ) &&
                 ( szDomain[0] ) )
            {
                // Copy the domain and username into the returning buffer.
                //
                AddPathN(szDomain, szUsername, AS(szDomain));
                lstrcpyn(lpszUsername, szDomain, cbUsername);
            }
            else
            {
                // Copy the username into the returning buffer.
                //
                lstrcpyn(lpszUsername, szUsername, cbUsername);
            }

            // We found the credentials
            //
            bRet = TRUE;

            // Check the registry key to see if it has user credentials.
            //
            dwSize = sizeof(szPassword);
            if ( ( RegQueryValueEx(hKey, REG_VAL_FACTORY_PASSWORD, NULL, &dwType, (LPBYTE) szPassword, &dwSize) == ERROR_SUCCESS ) &&
                 ( dwType == REG_SZ ) )
            {
                // Copy the password into the returning buffer
                //
                lstrcpyn(lpszPassword, szPassword, cbPassword);
            }
            else
            {
                // No password specified, just return and empty string.
                //
                *lpszPassword = NULLCHR;
            }
        }

        // Always remember to close the key.
        //
        RegCloseKey(hKey);
    }
    
    return bRet;
}


NET_API_STATUS FactoryNetworkConnectEx(LPTSTR lpszPath, LPTSTR lpszWinBOMPath, LPTSTR lpAlternateSection, LPTSTR lpszUsername, DWORD cbUsername, LPTSTR lpszPassword, DWORD cbPassword, BOOL bState)
{
    NET_API_STATUS  nErr,
                    nRet                                = 0;
    static BOOL     bFirst                              = TRUE;
    BOOL            bJustStarted                        = FALSE;
    TCHAR           szUsername[UNLEN + DNLEN + 2]       = NULLSTR,
                    szPassword[PWLEN + 1]               = NULLSTR,
                    szBuffer[MAX_PATH],
                    szWinbomShare[MAX_PATH]             = NULLSTR;
    LPTSTR          lpSearch;
    DWORD           dwStart;

    // Get the credentials for the current section
    //
    if ( bState )
    {
        // Make sure we pass in a username buffer big enough to hold the "domain\username" string.
        //
        GetCredentials(szUsername, AS(szUsername), szPassword, AS(szPassword), lpszWinBOMPath, lpAlternateSection);
    }

    // Get just the share pare of the winbom path if it is a UNC.
    //
    if ( lpszWinBOMPath )
    {
        GetUncShare(lpszWinBOMPath, szWinbomShare, AS(szWinbomShare));
    }

    // Determine all of the UNC paths in the string supplied
    //
    lpSearch = lpszPath;
    while ( lpSearch = StrStr(lpSearch, _T("\\\\")) )
    {
        // See if this is a UNC share.
        //
        if ( GetUncShare(lpSearch, szBuffer, AS(szBuffer)) && szBuffer[0] )
        {
            // We can not connect or disconnect from the share where the winbom is.
            //
            if ( ( NULLCHR == szWinbomShare[0] ) ||
                 ( lstrcmpi(szBuffer, szWinbomShare) != 0 ) )
            {
                // Connect/disconnect from the share and 
                //
                nErr = 0;
                dwStart = GetTickCount();
                do
                {
                    if ( nErr )
                    {
                        Sleep(100);
                    }
                    if ( NERR_WkstaNotStarted == (nErr = ConnectNetworkResource(szBuffer, szUsername, szPassword, bState)) )
                    {
                        // Wierd bug here we are hacking around.  If we just wait till the network starts, sometimes the first
                        // call it gives us a wierd error.  So if we run into the not started error, then we keep retrying on
                        // any error until we time out.
                        //
                        bJustStarted = TRUE;
                    }
#ifdef DBG
                    LogFileStr(_T("c:\\sysprep\\winbom.log"), _T("FactoryNetworkConnect(%s)=%d [%d,%d]\n"), szBuffer, nErr, dwStart, GetTickCount());
#endif // DBG
                }
                while ( ( bFirst && bJustStarted && nErr ) &&
                        ( (GetTickCount() - dwStart) < NET_TIMEOUT ) );

                // If we hit an error and it is the first one,
                // return it.
                //
                if ( nErr && ( 0 == nRet ) )
                {
                    nRet = nErr;
                }

                // Once we have tried to connect to a network resource, we set
                // this so we don't ever time out again as long as we are still
                // running.
                //
                bFirst = FALSE;
            }

            // Move the pointer past the share name.
            //
            lpSearch += lstrlen(szBuffer);
        }
        else
        {
            // Go past the double backslash even though it is not a UNC path.
            //
            lpSearch += 2;
        }
    }

    // Might need to return the credentials we used.
    //
    if ( lpszUsername && cbUsername )
    {
        lstrcpyn(lpszUsername, szUsername, cbUsername);
    }
    if ( lpszPassword && cbPassword )
    {
        lstrcpyn(lpszPassword, szPassword, cbPassword);
    }

    // Return the net error, or 0 if everything worked.
    //
    return nRet;
}


NET_API_STATUS FactoryNetworkConnect(LPTSTR lpszPath, LPTSTR lpszWinBOMPath, LPTSTR lpAlternateSection, BOOL bState)
{
    return FactoryNetworkConnectEx(lpszPath, lpszWinBOMPath, lpAlternateSection, NULL, 0, NULL, 0, bState);
}



/*++
===============================================================================
Routine Description:

    This routine will locate the WINBOM.INI file. The search algorithm will be:
        * Check the registry key
        * Check local floppy drives
        * Check local CD-ROM drives
        * Check the sysprep folder
        * Check the root of the boot volume
Arguments:

    lpWinBOMPath - return buffer where the winbom path will be copied.
    cbWinbBOMPath - size of return buffer in characters.
    lpFactoryPath - the sysprep folder where factory.exe is.

Return Value:

    TRUE - WINBOM.INI was found

    FALSE - WINBOM.INI could not be found

===============================================================================
--*/

BOOL LocateWinBom(LPTSTR lpWinBOMPath, DWORD cbWinbBOMPath, LPTSTR lpFactoryPath, LPTSTR lpFactoryMode, DWORD dwFlags)
{
    BOOL    bFound              = FALSE,
            bRunningFromCd,
            bNetwork            = !(GET_FLAG(dwFlags, LOCATE_NONET));
    TCHAR   szWinBom[MAX_PATH]  = NULLSTR;
    TCHAR   szNewShare[MAX_PATH],
            szNewUser[256],
            szNewPass[256],
            szCurShare[MAX_PATH] = NULLSTR,
            szCurUser[256]       = NULLSTR,
            szCurPass[256]       = NULLSTR;

    // Set the error mode so no drives display error messages ("please insert floppy")
    //
    SetErrorMode(SEM_FAILCRITICALERRORS);

    // Always set the return buffer to an empty string first.
    //
    *lpWinBOMPath = NULLCHR;

    // This neat little flag is used when we think that we already found a
    // winbom sometime this boot (like when factory runs from the run key) and
    // we want to make sure we use the same winbom instead of searching again
    // and maybe getting a different one.
    //
    if ( GET_FLAG(dwFlags, LOCATE_AGAIN) )
    {
        BOOL bDone;

        // Try our state winbom key to see if we have a winbom that we are already using.
        //
        bFound = CheckWinbomRegKey(szWinBom, AS(szWinBom), szCurShare, AS(szCurShare), szCurUser, AS(szCurUser), szCurPass, AS(szCurPass), lpFactoryMode, REG_KEY_FACTORY_STATE, bNetwork, &bDone);

        // Now if the registry key existed, we don't want to do anything more.  Just use
        // what we got right now and be done with it.
        //
        if ( bDone )
        {
            // Check to see if we have anything to return.
            //
            if ( bFound )
            {
                // Copy the path we found into the return buffer.
                //
                lstrcpyn(lpWinBOMPath, szWinBom, cbWinbBOMPath);
            }

            // Set the error mode back to system default
            //
            SetErrorMode(0);

            // Return right now if we found it or not.
            //
            return bFound;
        }
    }

    // Check to see if the system drive is a CD-ROM (which pretty much
    // means that we are running in WinPE and we should search this drive
    // last).
    //
    ExpandEnvironmentStrings(DIR_SYSTEMROOT, szWinBom, AS(szWinBom));
    bRunningFromCd = ( GetDriveType(szWinBom) == DRIVE_CDROM );
    szWinBom[0] = NULLCHR;

    // Check the magic registry key first as an option to override were the winbom is.
    //
    bFound = CheckWinbomRegKey(szWinBom, AS(szWinBom), szCurShare, AS(szCurShare), szCurUser, AS(szCurUser), szCurPass, AS(szCurPass), lpFactoryMode, REG_KEY_FACTORY, bNetwork, NULL);

    // Walk through the drives first checking if the drive is removeable and NOT CDROM.
    // Check for the presence of the WinBOM file and quit if it is found.
    //
    if ( !bFound )
    {
        bFound = SearchRemovableDrives(szWinBom, AS(szWinBom), lpFactoryMode, DRIVE_REMOVABLE);
    }

    // Walk through the drives again this time checking if the drive IS a CD-ROM.
    // Check for the presence of the WinBOM file and quit if it is found.  Also
    // only do this if the OS is not running from a CD.  This is so in the WinPE
    // case the person can put a winbom on the hard drive and it will be used
    // before the one that is always on the CD-ROM that WinPE boots from.
    //
    if ( !bFound )
    {
        bFound = SearchRemovableDrives(szWinBom, AS(szWinBom), lpFactoryMode, bRunningFromCd ? DRIVE_FIXED : DRIVE_CDROM);
    }

    // Now if still not found, check the same directory as factory.
    //
    if ( !bFound )
    {
        lstrcpyn(szWinBom, lpFactoryPath, AS(szWinBom));
        AddPath(szWinBom, FILE_WINBOM_INI);
        bFound = WinBOMExists(szWinBom, lpFactoryMode);
    }

    // Now if still not found, check the root of the system drive.
    //
    if ( !bFound )
    {
        ExpandEnvironmentStrings(DIR_SYSTEMROOT, szWinBom, AS(szWinBom));
        lstrcat(szWinBom, FILE_WINBOM_INI);
        bFound = WinBOMExists(szWinBom, lpFactoryMode);
    }

    // Now if we skipped the CD-ROM search above, do it now if we still
    // don't have a winbom.
    //
    if ( !bFound && bRunningFromCd )
    {
        bFound = SearchRemovableDrives(szWinBom, AS(szWinBom), lpFactoryMode, DRIVE_CDROM);
    }

    // Make sure we found a WinBOM and look for a NewWinbom key.
    //
    if ( bFound )
    {
        DWORD   dwLimit = 10;  // Must be greater than zero.
        BOOL    bAgain;
        LPTSTR  lpszNewWinbom;

        // Copy the path we found into the return buffer.
        //
        lstrcpyn(lpWinBOMPath, szWinBom, cbWinbBOMPath);

        // Now do the loop to search for possible NewWinBom keys.
        //
        do
        {
            // Reset the bool so we can check for alternate WinBOMs.
            //
            bAgain = FALSE;

            // See if the NewWinBom key exists in the winbom we found.
            //
            if ( lpszNewWinbom = IniGetExpand(lpWinBOMPath, INI_SEC_WBOM_FACTORY, INI_KEY_WBOM_FACTORY_NEWWINBOM, NULL) )
            {
                LPTSTR  lpShareRemove;
                BOOL    bSame = FALSE;

                // The NewWinBom key might be a UNC, so see if we need to connect
                // to the share.
                //
                szNewShare[0] = NULLCHR;
                szNewUser[0] = NULLCHR;
                szNewPass[0] = NULLCHR;
                if ( bNetwork && GetUncShare(lpszNewWinbom, szNewShare, AS(szNewShare)) && szNewShare[0] )
                {
                    // Only really need to connect if the we are not already
                    // connected.
                    //
                    if ( lstrcmpi(szNewShare, szCurShare) != 0 )
                    {
                        FactoryNetworkConnectEx(szNewShare, lpWinBOMPath, NULL, szNewUser, AS(szNewUser), szNewPass, AS(szNewPass), TRUE);
                    }
                    else
                    {
                        bSame = TRUE;
                    }
                }

                // Now make sure the winbom we found really exists and is a vallid
                // winbom we can use.
                //
                if ( WinBOMExists(lpszNewWinbom, lpFactoryMode) )
                {
                    // Copy the new winbom path we found into the return buffer.
                    //
                    lstrcpyn(lpWinBOMPath, lpszNewWinbom, cbWinbBOMPath);

                    bAgain = TRUE;
                    lpShareRemove = szCurShare;
                }
                else
                {
                    lpShareRemove = szNewShare;
                }

                // Do any share cleanup that needs to happen.
                //
                if ( bNetwork && *lpShareRemove && !bSame )
                {
                    FactoryNetworkConnect(lpShareRemove, NULL, NULL, FALSE);
                    *lpShareRemove = NULLCHR;
                }

                // Also save the share info if there was one so we can cleanup
                // later if we find another winbom.
                //
                if ( bAgain )
                {
                    lstrcpyn(szCurShare, szNewShare, AS(szCurShare));
                    lstrcpyn(szCurUser, szNewUser, AS(szCurUser));
                    lstrcpyn(szCurPass, szNewPass, AS(szCurPass));
                }

                // Clean up the ini key we allocated.
                //
                FREE(lpszNewWinbom);
            }
        }
        while ( --dwLimit && bAgain );
    }

    // Save the winbom we are using (or empty string if not using one) to our state
    // key so other programs or instances of factory running this boot know what winbom
    // to use.
    //
    RegSetString(HKLM, REG_KEY_FACTORY_STATE, REG_VAL_FACTORY_WINBOM, lpWinBOMPath);

    // We may want to save the credentials that we used to get to this winbom in our
    // state key so we can get them back and reconnect, but for now if we just don't
    // ever disconnect from the share where the winbom is, we should be fine.  Only need
    // to worry about this if the caller of the function wanted to disconnect this
    // network resource when they were done.  If we do that, these keys will have to
    // be written.  But we will have to put in a bunch of code so that CheckWinbomRegKey()
    // returns the credentials used, and when doing our NewWinBom search that we also
    // save the credentials we finally end up using.  This is a lot of work, and I see
    // no need for this now.  Just make sure if you call this function that you do NOT
    // call FactoryNetworkConnect() to remove the net connection.
    //
    // This didn't work, because when we log on we loose our net connection so we need
    // the credentials to reconnect after logon.  So I went through all the work I mentioned
    // above to make this work.
    //
    RegSetString(HKLM, REG_KEY_FACTORY_STATE, REG_VAL_FACTORY_USERNAME, szCurUser);
    RegSetString(HKLM, REG_KEY_FACTORY_STATE, REG_VAL_FACTORY_PASSWORD, szCurPass);

    // Set the error mode back to system default
    //
    SetErrorMode(0);

    // Return if we found it or not.
    //
    return bFound;
}

BOOL SetFactoryStartup(LPCTSTR lpFactory)
{
    HKEY    hKey;
    BOOL    bRet    = TRUE;

    // Now make sure we are also setup as a setup program to run before we log on.
    //
    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SYSTEM\\Setup"), 0, KEY_ALL_ACCESS, &hKey ) == ERROR_SUCCESS )
    {
        TCHAR   szFileName[MAX_PATH + 32]   = NULLSTR;
        DWORD   dwVal;

        //
        // Setup the control flags for the SETUP key
        // The Setting used are:
        //      CmdLine = c:\sysprep\factory.exe -setup
        //      SetupType = 2 (No reboot)
        //      SystemSetupInProgress = 0 (no service restrictions)
        //      MiniSetupInProgress = 0 (Not doing a mini setup)
        //      FactoryPreInstallInProgress = 1 (Delay pnp driver installs)
        //      AuditInProgress = 1 (general key to determine if the OEM is auditing the machine)
        //

        lstrcpyn(szFileName, lpFactory, AS(szFileName));
        lstrcat(szFileName, _T(" -setup"));
        if ( RegSetValueEx(hKey, _T("CmdLine"), 0, REG_SZ, (CONST LPBYTE) szFileName, ( lstrlen(szFileName) + 1 ) * sizeof(TCHAR)) != ERROR_SUCCESS )
            bRet = FALSE;

        dwVal = SETUPTYPE_NOREBOOT;
        if ( RegSetValueEx(hKey, TEXT("SetupType"), 0, REG_DWORD, (CONST LPBYTE) &dwVal, sizeof(DWORD)) != ERROR_SUCCESS )
            bRet = FALSE;

        dwVal = 0;
        if ( RegSetValueEx(hKey, TEXT("SystemSetupInProgress"), 0, REG_DWORD, (CONST LPBYTE) &dwVal, sizeof(DWORD)) != ERROR_SUCCESS )
            bRet = FALSE;

        dwVal = 0;
        if ( RegSetValueEx(hKey, TEXT("MiniSetupInProgress"), 0, REG_DWORD, (CONST LPBYTE) &dwVal, sizeof(DWORD)) != ERROR_SUCCESS )
            bRet = FALSE;

        dwVal = 1;
        if ( RegSetValueEx(hKey, TEXT("FactoryPreInstallInProgress"), 0, REG_DWORD, (CONST LPBYTE) &dwVal, sizeof(DWORD)) != ERROR_SUCCESS )
            bRet = FALSE;

        dwVal = 1;
        if ( RegSetValueEx(hKey, TEXT("AuditInProgress"), 0, REG_DWORD, (CONST LPBYTE) &dwVal, sizeof(DWORD)) != ERROR_SUCCESS )
            bRet = FALSE;

        RegCloseKey(hKey);
    }
    else
        bRet = FALSE;

    return bRet;
}

BOOL UpdateDevicePathEx(HKEY hKeyRoot, LPTSTR lpszSubKey, LPTSTR lpszNewPath, LPTSTR lpszRoot, BOOL bRecursive)
{
    LPSTRLIST   lpSorted = NULL,
                lpUnsorted = NULL;
    LPTSTR      lpszDevicePath;

    // First add any paths already in the registry to the lists.
    //
    if ( lpszDevicePath = RegGetString(hKeyRoot, lpszSubKey, REG_VAL_DEVICEPATH) )
    {
        AddPathsToList(lpszDevicePath, NULL, &lpSorted, &lpUnsorted, FALSE);
        FREE(lpszDevicePath);
    }

    // Now add any they wanted to the list.
    //
    AddPathsToList(lpszNewPath, lpszRoot, &lpSorted, &lpUnsorted, bRecursive);

    // Now that we are done, we can free our sorted list.
    //
    SavePathList(hKeyRoot, lpszSubKey, lpSorted, FALSE);

    // Now save our final list back to the registry and free
    // it.
    //
    SavePathList(hKeyRoot, lpszSubKey, lpUnsorted, TRUE);

    return TRUE;
}

BOOL UpdateDevicePath(LPTSTR lpszNewPath, LPTSTR lpszRoot, BOOL bRecursive)
{
    return ( UpdateDevicePathEx( HKLM, 
                                 REGSTR_PATH_SETUP, 
                                 lpszNewPath, 
                                 lpszRoot ? lpszRoot : DIR_SYSTEMROOT, 
                                 bRecursive ) );
}

BOOL UpdateSourcePath(LPTSTR lpszSourcePath)
{
    BOOL bRet = FALSE;

    if ( lpszSourcePath && *lpszSourcePath )
    {
        if (bRet = RegSetString(HKLM, REG_KEY_SETUP_SETUP, REG_VAL_SOURCEPATH, lpszSourcePath))
        {
            bRet = RegSetString(HKLM, REG_KEY_SETUP_SETUP, REG_VAL_SPSOURCEPATH, lpszSourcePath);
        }
    }

    return bRet;
}


//
// Internal Function(s):
//

static BOOL CheckWinbomRegKey(LPTSTR lpWinBOMPath,  DWORD cbWinbBOMPath,
                              LPTSTR lpszShare,     DWORD cbShare,
                              LPTSTR lpszUser,      DWORD cbUser,
                              LPTSTR lpszPass,      DWORD cbPass,
                              LPTSTR lpFactoryMode, LPTSTR lpKey,
                              BOOL bNetwork,        LPBOOL lpbExists)
{
    HKEY    hKey;
    BOOL    bFound              = FALSE,
            bExists             = FALSE;
    TCHAR   szWinBom[MAX_PATH]  = NULLSTR;

    // Check the registry key to see if it knows about a winbom to use.
    //
    if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpKey, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS )
    {
        DWORD   dwType,
                dwSize = sizeof(szWinBom);

        // Try to get the value.
        //
        if ( ( RegQueryValueEx(hKey, REG_VAL_FACTORY_WINBOM, NULL, &dwType, (LPBYTE) szWinBom, &dwSize) == ERROR_SUCCESS ) &&
             ( dwType == REG_SZ ) )
        {
            // Now the key must have existed.  If there was something
            // in the key, lets try to use it.
            //
            if ( szWinBom[0] )
            {
                TCHAR   szShare[MAX_PATH]   = NULLSTR,
                        szUser[256]         = NULLSTR,
                        szPass[256]         = NULLSTR;

                // Throw some networking support in here.
                //
                if ( bNetwork && GetUncShare(szWinBom, szShare, AS(szShare)) && szShare[0] )
                {
                    FactoryNetworkConnectEx(szShare, NULL, lpKey, szUser, AS(szUser), szPass, AS(szPass), TRUE);
                }

                // Check to see if the winbom is actually there still.
                // If not, then it is bad and we should just act like
                // the key didn't even exist.
                //
                if ( WinBOMExists(szWinBom, lpFactoryMode) )
                {
                    // If found, return the winbom in the supplied buffer.
                    //
                    lstrcpyn(lpWinBOMPath, szWinBom, cbWinbBOMPath);
                    bFound = bExists = TRUE;

                    // See what we might need to return.
                    //
                    if ( lpszShare && cbShare )
                    {
                        lstrcpyn(lpszShare, szShare, cbShare);
                    }
                    if ( lpszUser && cbUser )
                    {
                        lstrcpyn(lpszUser, szUser, cbUser);
                    }
                    if ( lpszPass && cbPass )
                    {
                        lstrcpyn(lpszPass, szPass, cbPass);
                    }
                }
                else if ( bNetwork && szShare[0] )
                {
                    // Clean up our net connection.
                    //
                    FactoryNetworkConnect(szShare, NULL, NULL, FALSE);
                }
            }
            else
            {
                // There wasn't anything in the key, but it did exist.
                // This most likely means we didn't find the winbom the
                // first time around, so we may need to know that now.
                //
                bExists = TRUE;
            }
        }

        // Always remember to close the key.
        //
        RegCloseKey(hKey);
    }

    // If they want to know if the key existed, then return it to them.
    //
    if ( lpbExists )
    {
        *lpbExists = bExists;
    }

    // If we found a winbom, return true.
    //
    return bFound;
}

static BOOL SearchRemovableDrives(LPTSTR lpWinBOMPath, DWORD cbWinbBOMPath, LPTSTR lpFactoryMode, UINT uDriveType)
{
    DWORD   dwDrives;
    TCHAR   szWinBom[MAX_PATH],
            szDrive[]           = _T("_:\\");
    BOOL    bFound              = FALSE;

    // Loop through all the dirves on the system.
    //
    for ( szDrive[0] = _T('A'), dwDrives = GetLogicalDrives();
          ( szDrive[0] <= _T('Z') ) && dwDrives && !bFound;
          szDrive[0]++, dwDrives >>= 1 )
    {
        // First check to see if the first bit is set (which means
        // this drive exists in the system).  Then make sure it is
        // a drive type that we want to check for a winbom.
        //
        if ( ( dwDrives & 0x1 ) &&
             ( GetDriveType(szDrive) == uDriveType ) )
        {
            // See if there is a wINBOM.INI file on the drive.
            //
            lstrcpyn(szWinBom, szDrive, AS(szWinBom));
            lstrcat(szWinBom, FILE_WINBOM_INI);
            if ( WinBOMExists(szWinBom, lpFactoryMode) )
            {
                // Return the path to the winbom in the supplied buffer.
                //
                lstrcpyn(lpWinBOMPath, szWinBom, cbWinbBOMPath);
                bFound = TRUE;
            }
        }
    }

    return bFound;
}

static BOOL WinBOMExists(LPTSTR lpWinBom, LPTSTR lpMode)
{
    BOOL bRet = FALSE;

    // First the file must exists.
    //
    if ( FileExists(lpWinBom) )
    {
        TCHAR szModes[256] = NULLSTR;

        // See if there is even a mode string in this winbom (has to be or
        // we will automatically use it).
        //
        if ( lpMode &&
             *lpMode &&
             GetPrivateProfileString(WBOM_FACTORY_SECTION, INI_KEY_WBOM_FACTORY_TYPE, NULLSTR, szModes, AS(szModes), lpWinBom) &&
             szModes[0] )
        {
            LPTSTR  lpCheck = szModes,
                    lpNext;

            // Loop through ever comma delimited field in the value we got
            // from the winbom (there is always at least one).
            //
            do
            {
                // See if there is another mode field in this string.
                //
                if ( lpNext = StrChr(lpCheck, _T(',')) )
                    *lpNext++ = NULLCHR;

                // Make sure there are no spaces around the field.
                //
                StrTrm(lpCheck, _T(' '));

                // If the mode we are in matches the one in the winbom, then
                // we are good to go.
                //
                if ( lstrcmpi(lpMode, lpCheck) == 0 )
                    bRet = TRUE;

                // Set the check pointer to the next
                // field.
                //
                lpCheck = lpNext;
            }
            while ( !bRet && lpCheck );

            // It would be nice to log if we don't use this winbom because of this
            // setting, but we can't really do that because we need to winbom to
            // init logging.
            //
            /*
            if ( !bRet )
            {
                // Log here.
            }
            */
        }
        else
            bRet = TRUE;
    }

    return bRet;
}

static void SavePathList(HKEY hKeyRoot, LPTSTR lpszSubKey, LPSTRLIST lpStrList, BOOL bWrite)
{
    LPSTRLIST   lpStrListNode;
    DWORD       cbDevicePath = 256,
                dwLength     = 0,
                dwOldSize;
    LPTSTR      lpszDevicePath;

    // Initialize our intial buffer we are going to use to
    // write to the registry.
    //
    if ( bWrite )
    {
        lpszDevicePath = (LPTSTR) MALLOC(cbDevicePath * sizeof(TCHAR));
    }

    // Loop through the list.
    //
    while ( lpStrList )
    {
        // Save a pointer to the current node.
        //
        lpStrListNode = lpStrList;

        // Advanced to the next node.
        //
        lpStrList = lpStrList->lpNext;

        // If we are saving this list to the registry, then
        // we need to add to our buffer.
        //
        if ( bWrite && lpszDevicePath )
        {
            // Make sure our buffer is still big enough.
            // The two extra are for the possible semi-colon
            // we might add and one more to be safe.  We
            // don't have to worry about the null terminator
            // because we do less than or equal to our current
            // buffer size.
            //
            dwOldSize = cbDevicePath;
            dwLength += lstrlen(lpStrListNode->lpszData);
            while ( cbDevicePath <= (dwLength + 2) )
            {
                cbDevicePath *= 2;
            }

            // If it wasn't big enough, we need to reallocate it.
            //
            if ( cbDevicePath > dwOldSize )
            {
                LPTSTR lpszTmpDevicePath = (LPTSTR) REALLOC(lpszDevicePath, cbDevicePath * sizeof(TCHAR));

                //
                // Make sure the REALLOC succeeded before reassigning the memory
                //
                if ( lpszTmpDevicePath )
                {
                    lpszDevicePath = lpszTmpDevicePath;
                }
            }

            // Make sure we still have a buffer.
            //
            if ( lpszDevicePath )
            {
                // If we already have added a path, tack on a semicolon.
                //
                if ( *lpszDevicePath )
                {
                    lstrcat(lpszDevicePath, _T(";"));
                    dwLength++;
                }

                // Now add our path.
                //
                lstrcat(lpszDevicePath, lpStrListNode->lpszData);
            }
        }

        // Free the data in this node.
        //
        FREE(lpStrListNode->lpszData);

        // Free the node itself.
        //
        FREE(lpStrListNode);
    }

    // If we have the data, save it to the registry.
    //
    if ( bWrite && lpszDevicePath )
    {
        RegSetExpand(hKeyRoot, lpszSubKey, REG_VAL_DEVICEPATH, lpszDevicePath);
        FREE(lpszDevicePath);
    }
}

static BOOL AddPathToList(LPTSTR lpszExpanded, LPTSTR lpszPath, LPSTRLIST * lplpSorted, LPSTRLIST * lplpUnsorted)
{
    LPSTRLIST   lpSortedNode,
                lpUnsortedNode;
    BOOL        bQuit = FALSE;

    // Loop until we get to the end or find a string that is bigger than
    // ours.
    //
    while ( *lplpSorted && !bQuit )
    {
        // If we do this, we don't have to do the complicated
        // indirection.
        //
        lpSortedNode = *lplpSorted;

        // Compare the nodes string to the one we want to add.
        //
        switch ( CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpszExpanded, -1, lpSortedNode->lpszData, -1) )
        {
            case CSTR_EQUAL:
                
                // If the are the same, we just return FALSE because we do
                // not need to add it.
                //
                return FALSE;

            case CSTR_LESS_THAN:

                // If our string is less than the one in this node, we need
                // to stop so we can insert ourself before it.
                //
                bQuit = TRUE;
                break;

            default:

                // Default, just try the next item in the list.
                //
                lplpSorted = &(lpSortedNode->lpNext);
        }
    }

    // Now we need to advance the pointer of the unsorted list to the
    // end so we can add ours.
    //
    while ( *lplpUnsorted )
    {
        lpUnsortedNode = *lplpUnsorted;
        lplpUnsorted = &(lpUnsortedNode->lpNext);
    }

    // Allocate our nodes.  If anything fails, we have to return false.
    //
    if ( NULL == (lpSortedNode = (LPSTRLIST) MALLOC(sizeof(STRLIST))) )
    {
        return FALSE;
    }
    if ( NULL == (lpUnsortedNode = (LPSTRLIST) MALLOC(sizeof(STRLIST))) )
    {
        FREE(lpSortedNode);
        return FALSE;
    }

    // Set the data in the sorted node and insert the list since we
    // know where that goes right now.
    //
    lpSortedNode->lpszData = lpszExpanded;
    lpSortedNode->lpNext = *lplpSorted;
    *lplpSorted = lpSortedNode;

    // Now set the data in the unsorted node and insert it at the end
    // of that list.
    //
    lpUnsortedNode->lpszData = lpszPath;
    lpUnsortedNode->lpNext = NULL;
    *lplpUnsorted = lpUnsortedNode;

    return TRUE;
}

static void EnumeratePath(LPTSTR lpszPath, LPSTRLIST * lplpSorted, LPSTRLIST * lplpUnsorted)
{
    WIN32_FIND_DATA FileFound;
    HANDLE          hFile;
    LPTSTR          lpszNewPath,
                    lpszExpandedPath;
    DWORD           cbNewPath;
    BOOL            bAdded = FALSE;

    // Process all the files and directories in the directory passed in.
    //
    if ( (hFile = FindFirstFile(_T("*"), &FileFound)) != INVALID_HANDLE_VALUE )
    {
        do
        {
            // First check to see if this is a a directory.
            //
            if ( ( FileFound.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
                 ( lstrcmp(FileFound.cFileName, _T(".")) != 0 ) &&
                 ( lstrcmp(FileFound.cFileName, _T("..")) != 0 ) &&
                 ( SetCurrentDirectory(FileFound.cFileName) ) )
            {
                // Need the size for the new path... which is the length of the
                // old path, plus new path, and 3 extra for the joining backslash,
                // null terminator, and another one more to be safe.
                //
                cbNewPath = lstrlen(lpszPath) + lstrlen(FileFound.cFileName) + 3;
                if ( lpszNewPath = (LPTSTR) MALLOC(cbNewPath * sizeof(TCHAR)) )
                {
                    // Create our new path (note this one is not expanded out,
                    // it may contain environment variables.
                    //
                    lstrcpyn(lpszNewPath, lpszPath, cbNewPath);
                    AddPathN(lpszNewPath, FileFound.cFileName, cbNewPath);

                    // Make sure we can expand out the buffer.
                    //
                    if ( lpszExpandedPath = AllocateExpand(lpszNewPath) )
                    {
                        // Now add the path to the list.
                        //
                        bAdded = AddPathToList(lpszExpandedPath, lpszNewPath, lplpSorted, lplpUnsorted);

                        // If the path didn't get added, we have to free the buffer.
                        //
                        if ( !bAdded )
                        {
                            FREE(lpszExpandedPath);
                        }
                    }

                    // Continue the recursive search
                    //
                    EnumeratePath(lpszNewPath, lplpSorted, lplpUnsorted);

                    // If the path didn't get added, we have to free the buffer.
                    //
                    if ( !bAdded )
                    {
                        FREE(lpszNewPath);
                    }
                }

                // Set the current directory to parent, to continue.
                //
                SetCurrentDirectory(_T(".."));
            }

        }
        while ( FindNextFile(hFile, &FileFound) );

        FindClose(hFile);
    }
}

static BOOL AddPathsToList(LPTSTR lpszBegin, LPTSTR lpszRoot, LPSTRLIST * lplpSorted, LPSTRLIST * lplpUnsorted, BOOL bRecursive)
{
    BOOL    bRet            = TRUE,
            bAddBackslash   = FALSE,
            bAdded;
    LPTSTR  lpszEnd,
            lpszPath,
            lpszExpanded,
            lpszCat;
    DWORD   dwSize,
            dwBackslash;

    // If they don't pass in the root we don't do anything.
    //
    if ( lpszRoot )
    {
        if ( NULLCHR == *lpszRoot )
        {
            lpszRoot = NULL;
        }
        else if ( _T('\\') != *CharPrev(lpszRoot, lpszRoot + lstrlen(lpszRoot)) )
        {
            // The root path passed in doesn't have a backslash at
            // the end so we set this so that we know we have to add
            // one each time we add a path.
            //
            bAddBackslash = TRUE;
        }
    }

    // Loop through all the semicolon separated paths in the
    // buffer passed to use.
    //
    do
    {
        // Find the beginning of the path past all
        // the semicolons.
        //
        while ( _T(';') == *lpszBegin )
        {
            lpszBegin++;
        }

        if ( *lpszBegin )
        {
            // Find the end of the path which is the next
            // semicolon or the end of the string, whichever
            // comes first.
            //
            lpszEnd = lpszBegin;
            while ( *lpszEnd && ( _T(';') != *lpszEnd ) )
            {
                lpszEnd++;
            }

            // See if our new path has a backslash at the
            // beginning of it.
            //
            dwBackslash = 0;
            if ( _T('\\') == *lpszBegin )
            {
                // If it does and we don't want to add one,
                // then advance the pointer past it.
                //
                if ( !bAddBackslash )
                {
                    lpszBegin++;
                }
            }
            else if ( bAddBackslash )
            {
                // Set this so we know to add the backslash and
                // allocate the extra space for it.
                //
                dwBackslash = 1;
            }

            // Figure out the size we need for the path we are going
            // to create.  It is the length of the new string, plus
            // the root if one was passed in, plus 1 for the backslash
            // if we need to add one, plus 2 extra (one for the null
            // terminator and one just to be safe).
            //
            dwSize = ((int) (lpszEnd - lpszBegin)) + dwBackslash + 2;
            if ( lpszRoot )
            {
                dwSize += lstrlen(lpszRoot);
            }

            // Now allocate our path buffer.
            //
            if ( lpszPath = (LPTSTR) MALLOC(dwSize * sizeof(TCHAR)) )
            {
                // Reset this so if anything doesn't work we know to
                // free our allocated memory.
                //
                bAdded = FALSE;

                // Copy the path into our buffer.
                //
                lpszCat = lpszPath;
                if ( lpszRoot )
                {
                    lstrcpy(lpszCat, lpszRoot);
                    lpszCat += lstrlen(lpszCat);
                }
                if ( dwBackslash )
                {
                    *lpszCat++ = _T('\\');
                }
                lstrcpyn(lpszCat, lpszBegin, (int) (lpszEnd - lpszBegin) + 1);

                if ( lpszExpanded = AllocateExpand(lpszPath) )
                {
                    // Add it to our lists.
                    //
                    bAdded = AddPathToList(lpszExpanded, lpszPath, lplpSorted, lplpUnsorted);

                    // If this is a recursive add, we try to enumerate all the
                    // sub directories and add them as well.
                    //
                    if ( ( bRecursive ) &&
                         ( DirectoryExists(lpszExpanded) ) &&
                         ( SetCurrentDirectory(lpszExpanded) ) )
                    {
                        EnumeratePath(lpszPath, lplpSorted, lplpUnsorted);
                    }

                    // If it wasn't added to the list, then free the memory.
                    //
                    if ( !bAdded )
                    {
                        FREE(lpszExpanded);
                    }
                }

                // If it wasn't added to the list, then free the memory.
                //
                if ( !bAdded )
                {
                    FREE(lpszPath);
                }
            }

            // Reset the beginning to the next string.
            //
            lpszBegin = lpszEnd;
        }
    }
    while ( *lpszBegin );

    return bRet;
}

VOID CleanupSourcesDir(LPTSTR lpszSourcesDir)
{
    UINT    i = 0;
    LPTSTR  lpEnd = NULL;

    // If we have a valid sources
    if ( lpszSourcesDir && 
         *lpszSourcesDir &&
         DirectoryExists(lpszSourcesDir)
       )

    {
        lpEnd = lpszSourcesDir + lstrlen(lpszSourcesDir);

        for (i = 0; ( i < AS(CleanupDirs) ); i++)
        {
            AddPath(lpszSourcesDir, CleanupDirs[i]);
            DeletePath(lpszSourcesDir);
            *lpEnd = NULLCHR;
        }

    }
}


// External functions
//
typedef BOOL ( *OpkCheckVersion ) ( DWORD dwMajorVersion, DWORD dwQFEVersion );

// 
// Wrapper around the syssetup OPKCheckVersion() function.
//
BOOL OpklibCheckVersion( DWORD dwMajorVersion, DWORD dwQFEVersion )
{
    BOOL bRet                        = TRUE;  // Allow tool to run by default, in case we can't load syssetup or find the entry point.
    HINSTANCE       hInstSysSetup    = NULL;
    OpkCheckVersion pOpkCheckVersion = NULL;

    hInstSysSetup = LoadLibrary( _T("syssetup.dll") );

    if ( hInstSysSetup )
    {
        pOpkCheckVersion = (OpkCheckVersion) GetProcAddress( hInstSysSetup, "OpkCheckVersion" );
        if ( pOpkCheckVersion )
        {
            bRet = pOpkCheckVersion( dwMajorVersion, dwQFEVersion );
        }

        FreeLibrary( hInstSysSetup );
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\rcpatch\rcpatch.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    rcpatch.cpp

Abstract:

    Patches cmdcons\bootsect.dat to the current
    active system partition boot sector.

    NOTE : This is needed if someone wants to
    sysprep the recovery console also as part
    of the reference machine and then apply the
    images to different target machines. 

    This utility needs to be executed in 
    mini-setup using the sysprep infrastructure.

    Also allows you to patch the MBR boot code        

Author:

    Vijay Jayaseelan (vijayj) 02-Nov-2000

Revision History:

    None

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <bootmbr.h>
#include <iostream>
#include <string>
#include <exception>
#include <windows.h>
#include <tchar.h>
#include <locale>
#include "msg.h"
#include <libmsg.h>

//
// Global variables used to get formatted message for this program.
//
HMODULE ThisModule = NULL;
WCHAR Message[4096];

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fputws((PWSTR)str.c_str(), OutStream);
    return os;
}

//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, WCHAR *Str) {
    std::wstring WStr = Str;
    os << WStr;
    
    return os;
}


//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};
          

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;
        if (GetFormattedMessage(ThisModule,
                                TRUE,
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(MsgBuffer[0]),
                                ErrorCode)){
            std::wstring Msg(MsgBuffer);
            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Invalid arguments
//
struct InvalidArguments : public ProgramException {
    const char *what() const throw() {
        return "Invalid Arguments";
    }

    void Dump(std::ostream &os) {
        os << what() << std::endl;
    }
};

//
// Invalid arguments
//
struct ProgramUsage : public ProgramException {
    std::wstring PrgUsage;

    ProgramUsage(){}
    
    const char *what() const throw() {
        return "Program Usage exception";
    }

    void Dump(std::ostream &os) {
        os << GetFormattedMessage(  ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_PGM_USAGE) << std::endl;
    }
};

//
// Program Arguments abstraction
//
struct ProgramArguments {
    bool    PatchMBR;
    bool	BootCodePatch;
    ULONG   DiskIndex;
    WCHAR   DriveLetter;
    
    ProgramArguments(INT Argc, WCHAR *Argv[]) {
        PatchMBR = false;
        DiskIndex = 0;
        BootCodePatch = false;
        bool ShowUsage = false;

        for (ULONG Index=0; !ShowUsage && (Index < Argc); Index++) {
            if (!_wcsicmp(Argv[Index], L"/fixmbr")) {
                Index++;

                if ((Index < Argc) && Argv[Index]) {            
                    ULONG CharIndex;
                    
                    for (CharIndex=0; 
                        Argv[Index] && iswdigit(Argv[Index][CharIndex]); 
                        CharIndex++){
                        // do nothing currently
                    }                        
                    
                    if (CharIndex && !Argv[Index][CharIndex]) {
                        PWSTR   EndPtr = NULL;
                        
                        PatchMBR = true;
                        DiskIndex = wcstoul(Argv[Index], &EndPtr, 10);
                    }                                    
                }

                ShowUsage = !PatchMBR;
            } else if (!_wcsicmp(Argv[Index], L"/?") ||
                       !_wcsicmp(Argv[Index], L"-?") ||
                       !_wcsicmp(Argv[Index], L"?") ||
                       !_wcsicmp(Argv[Index], L"/h") ||
                       !_wcsicmp(Argv[Index], L"-h")) {
                ShowUsage = true;                       
            } else if (!_wcsicmp(Argv[Index], L"/syspart")){

                Index++;
                if ((Index < Argc) && Argv[Index]) {
                		
                	//
                	// Check validity of the character that follows the 
                	// "/syspart" option.
                	//
                	if (iswalpha(Argv[Index][0])){
                			BootCodePatch = true;	
                			DriveLetter = Argv[Index][0];		
                		
                	}                                  
                }
            }                     
        }            

        if (ShowUsage) {
            throw new ProgramUsage();
        }                        
    }
};

//
// Dumps the given binary data of the specified size
// into the output stream with required indent size
//
void
DumpBinary(unsigned char *Data, int Size,
           std::ostream& os, int Indent = 16)
{
    if (Data && Size) {
        int  Index = 0;
        int  foo;
        char szBuff[128] = {'.'};
        int  Ruler = 0;

        while (Index < Size) {
            if (!(Index % Indent)) {
                if (Index) {
                    szBuff[Indent] = 0;
                    os << szBuff;
                }

                os << std::endl;
                os.width(8);
                os.fill('0');
                os << Ruler << "  ";
                Ruler += Indent;
            }

            foo = *(Data + Index);
            szBuff[Index % Indent] = ::isalnum(foo) ? (char)foo : (char)'.';
            os.width(2);
            os.fill('0');
            os.flags(std::ios::uppercase | std::ios::hex);
            os << foo << ' ';
            Index++;
        }

        while (Index % Indent) {
            os << '   ';
            Index++;
            szBuff[Index % Indent] = ' ';
        }

        szBuff[Indent] = 0;
        os << szBuff;
    } else {
        os << GetFormattedMessage(  ThisModule,
                                    FALSE,
                                    Message,
                                    sizeof(Message)/sizeof(Message[0]),
                                    MSG_NO_DATA) << std::endl;
    }
}

//
// File system types we care about
//
enum FsType {
    FileSystemFat,
    FileSystemFat32,
    FileSystemNtfs,
    FileSystemUnknown
};

//
// Abstracts a disk (using Win32 APIs)
//
class W32Disk {
public:
    W32Disk(ULONG Index) {
        swprintf(Name, 
            L"\\\\.\\PHYSICALDRIVE%d",
            Index);                        

        DiskHandle = CreateFile(Name,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if ((DiskHandle == INVALID_HANDLE_VALUE) ||
            (DiskHandle == NULL)) {
            throw new W32Error(GetLastError());
        }            
    }

    ~W32Disk() {
        CloseHandle(DiskHandle);        
    }

    //
    // Reads the requested size of data from the given sector
    //
    DWORD ReadSectors(ULONG Index, PBYTE DataBuffer, ULONG BufferSize = 512) {        
        SetFilePointer(DiskHandle,
                    Index * SectorSize,
                    NULL,
                    FILE_BEGIN);

        DWORD LastError = GetLastError();

        if (!LastError) {
            DWORD   BytesRead = 0;
            
            if (!ReadFile(DiskHandle,
                        DataBuffer,
                        BufferSize,
                        &BytesRead,
                        NULL)) {
                LastError = GetLastError();
            }                
        }        

        return LastError;
    }

    //
    // Writes the requested size of data to the specified sector
    //
    DWORD WriteSectors(ULONG Index, PBYTE DataBuffer, ULONG BufferSize = 512) {
        SetFilePointer(DiskHandle,
                    Index * SectorSize,
                    NULL,
                    FILE_BEGIN);

        DWORD LastError = GetLastError();

        if (!LastError) {
            DWORD   BytesWritten = 0;
            
            if (!WriteFile(DiskHandle,
                        DataBuffer,
                        BufferSize,
                        &BytesWritten,
                        NULL)) {
                LastError = GetLastError();
            }                
        }        

        return LastError;
    }
    
    
protected:
    //
    // data members
    //
    WCHAR   Name[MAX_PATH];
    HANDLE  DiskHandle;    
    const static ULONG SectorSize = 512;
};

//
// Abstracts a Partition (using Win32 APIs)
//
class W32Partition {
public:
    //
    // constructor(s)
    //
    W32Partition(const std::wstring &VolName) : 
        SectorSize(512), FileSystemType(FileSystemUnknown) {        

        if (VolName.length() == 1) {            
            DriveName = TEXT("\\\\.\\");
            DriveName += VolName;
            DriveName += TEXT(":");
        } else {
            DriveName = TEXT("\\\\.\\") + VolName + TEXT("\\");
        }

        //
        // Open the partition
        //
        PartitionHandle = CreateFile(DriveName.c_str(),
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);     

        if (PartitionHandle != INVALID_HANDLE_VALUE) {
            DWORD           NotUsed = 0;
            std::wstring    RootPath = VolName;
            WCHAR           FileSystemName[64] = {0};

            if (VolName.length() == 1) {
                RootPath += TEXT(":\\");
            } else {
                RootPath += TEXT("\\");
            }                

            //
            // Get the file system information on the
            // partition
            //
            if (GetVolumeInformation(RootPath.c_str(),
                    NULL,
                    0,
                    &NotUsed,
                    &NotUsed,
                    &NotUsed,
                    FileSystemName,
                    sizeof(FileSystemName)/sizeof(FileSystemName[0]))) {

                std::wstring  FsName = FileSystemName;                    

                if (FsName == TEXT("FAT")) {
                    FileSystemType = FileSystemFat;
                } else if (FsName == TEXT("FAT32")) {
                    FileSystemType = FileSystemFat32;
                } else if (FsName == TEXT("NTFS")) {
                    FileSystemType = FileSystemNtfs;
                } else {
                    FileSystemType = FileSystemUnknown;
                }                                 

                switch (GetFileSystemType()) {      
                    case FileSystemFat:
                    case FileSystemFat32:
                        BootCodeSize = 1 * SectorSize;
                        break;

                    case FileSystemNtfs:
                        BootCodeSize = 16 * SectorSize;
                        break;

                    default:
                        break;
                }                
            }                    
        }

        DWORD LastError = GetLastError();

        if (LastError) {
            CleanUp();
            throw new W32Error(LastError);
        }                    
    }

    //
    // destructor
    //
    virtual ~W32Partition() {
        CleanUp();
    }

    ULONG GetBootCodeSize() const {
        return BootCodeSize;
    }

    FsType GetFileSystemType() const {
        return FileSystemType;
    }        

    //
    // Reads the requested size of data from the given sector
    //
    DWORD ReadSectors(ULONG Index, PBYTE DataBuffer, ULONG BufferSize = 512) {        
        SetFilePointer(PartitionHandle,
                    Index * SectorSize,
                    NULL,
                    FILE_BEGIN);

        DWORD LastError = GetLastError();

        if (!LastError) {
            DWORD   BytesRead = 0;
            
            if (!ReadFile(PartitionHandle,
                        DataBuffer,
                        BufferSize,
                        &BytesRead,
                        NULL)) {
                LastError = GetLastError();
            }                
        }        

        return LastError;
    }
    
protected:

    void CleanUp() {
        if (PartitionHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(PartitionHandle);
            PartitionHandle = INVALID_HANDLE_VALUE;
        }
    }                        
        
    //
    // Data members
    //
    std::wstring        DriveName;
    HANDLE              PartitionHandle;
    const ULONG         SectorSize;
    FsType              FileSystemType;
    ULONG               BootCodeSize;
};


DWORD
GetSystemPartitionName(
    IN OUT  PWSTR   NameBuffer
    )
/*++

Routine Description:

    Retrieves the system partition name from the registry
    
Arguments:

    NameBuffer - Buffer to hold the system partition name. Should
                 be of minimum MAX_PATH size
    
Return value:

    0 if successful otherwise appropriate Win32 error code

--*/    
{
    DWORD   ErrorCode = ERROR_BAD_ARGUMENTS;

    if (NameBuffer) {
        HKEY    SetupKey = NULL;
        
        ErrorCode = RegOpenKey(HKEY_LOCAL_MACHINE,
                        TEXT("System\\Setup"),
                        &SetupKey);

        if (!ErrorCode && SetupKey) {
            DWORD   Type = REG_SZ;
            DWORD   BufferSize = MAX_PATH * sizeof(TCHAR);
            
            ErrorCode = RegQueryValueEx(SetupKey,
                            TEXT("SystemPartition"),
                            NULL,
                            &Type,
                            (PBYTE)NameBuffer,
                            &BufferSize);

            RegCloseKey(SetupKey);        
        }                                                        
    }

    return ErrorCode;
}


DWORD
GetSystemPartitionDriveLetter(
    WCHAR  &SysPart
    )
/*++

Routine Description:

    Gets the system partition drive letter (like C / D etc.)

    NOTE : The logic is
    
        1. Find the system partition volume name by looking
           at HKLM\System\Setup\SystemPartition value.
           
        2. Iterate through \DosDevices namespace, finding
           target name string for all drive letters. If
           there is match then we found the system drive
           letter
    
Arguments:

    SysPart - Place holder for system partition drive letter
    
Return value:

    0 if successful otherwise appropriate Win32 error code

--*/    
{
    WCHAR   SystemPartitionName[MAX_PATH] = {0};
    DWORD   Result = ERROR_BAD_ARGUMENTS;    
    WCHAR   SysPartName = 0;
    
    Result = GetSystemPartitionName(SystemPartitionName);

    if (!Result) {       
        NTSTATUS            Status;
        UNICODE_STRING      UnicodeString;
        OBJECT_ATTRIBUTES   Attributes;
        OSVERSIONINFO       VersionInfo = {0};
        PWSTR               W2KDir = TEXT("\\??");
        PWSTR               WhistlerDir = TEXT("\\global??");
        PWSTR               DosDirName = W2KDir;

        //
        // NOTE : On whistler \\?? directory does not not have all 
        // the needed partition drive letters. They are present
        // under \\global?? directory
        //
        VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if (GetVersionEx(&VersionInfo) && (VersionInfo.dwMajorVersion == 5)
                && (VersionInfo.dwMinorVersion == 1)) {
            DosDirName = WhistlerDir;                    
        }                    
            
        std::wstring DirName = DosDirName;
    
        UnicodeString.Buffer = (PWSTR)DirName.c_str();
        UnicodeString.Length = lstrlenW(UnicodeString.Buffer)*sizeof(WCHAR);
        UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

        InitializeObjectAttributes( &Attributes,
                                    &UnicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL                                        
                                  );

        HANDLE  DirectoryHandle = NULL;
        ULONG   BufferSize = 512 * 1024;
        PBYTE   Buffer = new BYTE[BufferSize];
        PBYTE   EndOfBuffer = Buffer + BufferSize;
        ULONG   Context = 0;
        ULONG   ReturnedLength = 0;
        bool    Found = false;                                              
        POBJECT_DIRECTORY_INFORMATION DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;

        if ( Buffer ) {           
        
            RtlZeroMemory(Buffer, BufferSize);
        
            Status = NtOpenDirectoryObject( &DirectoryHandle,
                                            DIRECTORY_QUERY,
                                            &Attributes);


            if (NT_SUCCESS(Status)) {
                Status = NtQueryDirectoryObject(DirectoryHandle,
                              Buffer,
                              BufferSize,
                              FALSE,
                              TRUE,
                              &Context,
                              &ReturnedLength);
            }                              

            while (NT_SUCCESS( Status ) && !Found) {                                                   
                //
                //  Check the status of the operation.
                //

                if (!NT_SUCCESS( Status ) && (Status != STATUS_NO_MORE_ENTRIES)) {
                    break;
                }             
            
                while (!Found && (((PBYTE)DirInfo) < EndOfBuffer)) {
                    WCHAR   ObjName[4096] = {0};

                    //
                    //  Check if there is another record.  If there isn't, then get out
                    //  of the loop now
                    //

                    if (!DirInfo->Name.Buffer || !DirInfo->Name.Length) {
                        break;
                    }

                    //
                    // Make sure that the Name is pointing within the buffer
                    // supplied by us.
                    //
                    if ((DirInfo->Name.Buffer > (PVOID)Buffer) &&
                        (DirInfo->Name.Buffer < (PVOID)EndOfBuffer)) {

                        memmove(ObjName, DirInfo->Name.Buffer, DirInfo->Name.Length);
                        ObjName[DirInfo->Name.Length/(sizeof(WCHAR))] = 0;                        

                    if ((wcslen(ObjName) == 2) && (ObjName[1] == TEXT(':'))) {
                        OBJECT_ATTRIBUTES   ObjAttrs;
                        UNICODE_STRING      UnicodeStr;
                        HANDLE              ObjectHandle = NULL;
                        WCHAR               DriveLetter = ObjName[0];
                        WCHAR               FullObjName[4096] = {0};


                            wcscpy(FullObjName, TEXT("\\DosDevices\\"));
                            wcscat(FullObjName, ObjName);

                            UnicodeStr.Buffer = FullObjName;
                            UnicodeStr.Length = wcslen(FullObjName) * sizeof(WCHAR);
                            UnicodeStr.MaximumLength = UnicodeString.Length + sizeof(WCHAR);
                        
                            InitializeObjectAttributes(
                                &ObjAttrs,
                                &UnicodeStr,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );

                            Status = NtOpenSymbolicLinkObject(&ObjectHandle,
                                        READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                        &ObjAttrs
                                        );

                            if(NT_SUCCESS(Status)) {
                                //
                                // Query the object to get the link target.
                                //
                                UnicodeString.Buffer = FullObjName;
                                UnicodeString.Length = 0;
                                UnicodeString.MaximumLength = sizeof(FullObjName)-sizeof(WCHAR);

                                Status = NtQuerySymbolicLinkObject(ObjectHandle,
                                                &UnicodeString,
                                                NULL);

                                CloseHandle(ObjectHandle);

                                if (NT_SUCCESS(Status)) {
                                    FullObjName[UnicodeString.Length/sizeof(WCHAR)] = NULL;
                                    
                                    if (!_wcsicmp(FullObjName, SystemPartitionName)) {
                                        Found = true;
                                        SysPartName = DriveLetter;
                                    }                                        
                                }
                            }                                
                        }
                    }

                    //
                    //  There is another record so advance DirInfo to the next entry
                    //
                    DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PUCHAR) DirInfo) +
                                  sizeof( OBJECT_DIRECTORY_INFORMATION ) );
                
                }

                RtlZeroMemory(Buffer, BufferSize);

                Status = NtQueryDirectoryObject( DirectoryHandle,
                                                  Buffer,
                                                  BufferSize,
                                                  FALSE,
                                                  FALSE,
                                                  &Context,
                                                  &ReturnedLength);                    
            }                    

            delete []Buffer;

            if (!Found) {
                Result = ERROR_FILE_NOT_FOUND;
            }
        }
        else { // if we can't allocate the Buffer
            Result = ERROR_OUTOFMEMORY;
        }

        if (!Result && !SysPartName) {
            Result = ERROR_FILE_NOT_FOUND;
        }                
    }            

    if (!Result) {
        SysPart = SysPartName;
    }            

    return Result;
}


DWORD
PatchBootSectorForRC(
    IN PBYTE    BootSector,
    IN ULONG    Size,
    IN FsType   FileSystemType
    )
/*++

Routine Description:

    Patches the given boot sector for recovery console
    
Arguments:

    BootSector  :   BootSector copy in memory
    Size        :   Size of the boot sector
    FsType      :   File system type on which the boot sector
                    resides
    
Return value:

    0 if successful otherwise appropriate Win32 error code

--*/    
{
    DWORD   Result = ERROR_BAD_ARGUMENTS;
    BYTE    NtfsNtldr[] = { 'N', 0, 'T', 0, 'L', 0, 'D', 0, 'R', 0 };
    BYTE    NtfsCmldr[] = { 'C', 0, 'M', 0, 'L', 0, 'D', 0, 'R', 0 };
    BYTE    FatNtldr[] = { 'N', 'T', 'L', 'D', 'R' };  
    BYTE    FatCmldr[] = { 'C', 'M', 'L', 'D', 'R' };
    PBYTE   SrcSeq = NtfsNtldr;
    PBYTE   DestSeq = NtfsCmldr;
    ULONG   SeqSize = sizeof(NtfsNtldr);

    if (BootSector && Size && (FileSystemType != FileSystemUnknown)) {
        Result = ERROR_FILE_NOT_FOUND;
        
        if (FileSystemType != FileSystemNtfs) {
            SrcSeq = FatNtldr;
            DestSeq = FatCmldr;
            SeqSize = sizeof(FatNtldr);
        }

        for (ULONG Index=0; Index < (Size - SeqSize); Index++) {
            if (!memcmp(BootSector + Index, SrcSeq, SeqSize)) {
                memcpy(BootSector + Index, DestSeq, SeqSize);
                Result = 0;
                
                break;
            }
        }
    }

    if (!Result) {
        SetLastError(Result);
    }                
        
    return Result;
}

VOID
PatchMasterBootCode(
    IN  ULONG           DiskIndex
    )
/*++

Routine Description:

    Writes the master boot code to the specified disk's
    MBR
    
Arguments:

    DiskIndex   -   NT disk number to use (0, 1, etc)
    
Return value:

    None. On error throws appropriate exception.

--*/    
{
    W32Disk Disk(DiskIndex);
    BYTE    MBRSector[512] = {0};
    DWORD   Error = Disk.ReadSectors(0, MBRSector);

    if (!Error) {
        CopyMemory(MBRSector, x86BootCode, 440);
        Error = Disk.WriteSectors(0, MBRSector);            
    }

    if (Error) {
        throw new W32Error(Error);
    }
}
    

//
// main() entry point
//
int 
__cdecl
wmain(
    int         Argc,
    wchar_t     *Argv[]
    )
{
    int Result = 0;
    ThisModule = GetModuleHandle(NULL);
    
    try {    
        ProgramArguments    Args(Argc, Argv);
        bool                Successful = false;
        WCHAR               SysPartName[MAX_PATH] = {0};
        DWORD               LastError = 0;        
        WCHAR               SysPartDrvLetter = 0;

        if (Args.PatchMBR) {
            try {
                PatchMasterBootCode(Args.DiskIndex);

                Result = 0;
                std::cout << GetFormattedMessage(   ThisModule,
                                                    FALSE,
                                                    Message,
                                                    sizeof(Message)/sizeof(Message[0]),
                                                    MSG_MBR_PATCHED_SUCCESSFULLY) << std::endl;
            }
            catch(W32Error *Exp) {
                if (Exp) {
                    Exp->Dump(std::cout);
                }                    
            }
        } else {

	
            //
            // Get hold of the system partition drive letter
            //
            if (Args.BootCodePatch)
            	SysPartDrvLetter = Args.DriveLetter;
            else
            	LastError = GetSystemPartitionDriveLetter(SysPartDrvLetter);       

            if (!LastError) {
                SysPartName[0] = SysPartDrvLetter;
                SysPartName[1] = NULL;
                
                W32Partition        SysPart(SysPartName);
                std::wstring        RcBootFileName = SysPartName;
                std::wstring        RcBackupBootFileName = SysPartName;

                RcBootFileName += TEXT(":\\cmdcons\\bootsect.dat");
                RcBackupBootFileName += TEXT(":\\cmdcons\\bootsect.bak");

                //
                // Make a backup of recovery console's existing bootsect.dat file and
                // delete the existing bootsect.dat file
                //
                if (CopyFile(RcBootFileName.c_str(), RcBackupBootFileName.c_str(), FALSE) && 
                        SetFileAttributes(RcBootFileName.c_str(), FILE_ATTRIBUTE_NORMAL) &&
                        DeleteFile(RcBootFileName.c_str())) {        

                    //
                    // Create a new bootsect.dat file
                    //
                    HANDLE  BootSectorFile = CreateFile(RcBootFileName.c_str(),
                                                GENERIC_READ | GENERIC_WRITE,
                                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                NULL,
                                                CREATE_ALWAYS,
                                                FILE_ATTRIBUTE_NORMAL,
                                                NULL);                                                                                                           

                    if (BootSectorFile != INVALID_HANDLE_VALUE) {
                        BYTE    BootSector[0x4000] = {0};   // 16K

                        //
                        // Get the current boot sector from the system partition
                        //
                        if (!SysPart.ReadSectors(0, BootSector, SysPart.GetBootCodeSize())) {
                            DWORD BytesWritten = 0;                        

                            //
                            // Patch the boot sector and write it out
                            //
                            if (!PatchBootSectorForRC(BootSector, 
                                    SysPart.GetBootCodeSize(),
                                    SysPart.GetFileSystemType()) &&
                                WriteFile(BootSectorFile,
                                    BootSector,
                                    SysPart.GetBootCodeSize(),
                                    &BytesWritten,
                                    NULL)) {
                                Successful = true;
                            }                        
                        }                    

                        LastError = GetLastError();

                        CloseHandle(BootSectorFile);
                    }                
                }            

                if (!LastError) {
                    LastError = GetLastError();
                }                
            }            

            if (!Successful || LastError) {
                throw new W32Error(LastError);
            }            

            Result = 0;
            std::cout << GetFormattedMessage(   ThisModule,
                                                FALSE,
                                                Message,
                                                sizeof(Message)/sizeof(Message[0]),
                                                MSG_RC_PATCHED_SUCCESSFULLY) << std::endl;
        }            
    }
    catch(ProgramArguments *pArgs) {
        Result = 1;
        std::cout << GetFormattedMessage(   ThisModule,
                                            FALSE,
                                            Message,
                                            sizeof(Message)/sizeof(Message[0]),
                                            MSG_PGM_USAGE) << std::endl;
        if (pArgs) {
            delete pArgs;
        }
    }
    catch(W32Error  *W32Err) {
        if (W32Err) {   // to make prefix happy :(
            Result = W32Err->ErrorCode;

            switch (W32Err->ErrorCode) {
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    std::cout << GetFormattedMessage(   ThisModule,
                                                        FALSE,
                                                        Message,
                                                        sizeof(Message)/sizeof(Message[0]),
                                                        MSG_COULD_NOT_FIND_RC) << std::endl;

                    break;

                default:
                    W32Err->Dump(std::cout);
                    break;
            }

            delete W32Err;
        }   
    }
    catch(ProgramException *PrgExp) {
        Result = 1;
        PrgExp->Dump(std::cout);
        delete PrgExp;
    } catch (exception *Exp) {
        Result = 1;
        std::cout << Exp->what() << std::endl;
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\opklib\pch.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Pre-compiled header for opk.lib.  

Author:

    Brian Ku (briank) 06/20/2000

Revision History:

--*/
#include <opklib.h>
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\opklib\regapi.c ===
/****************************************************************************\

    REGAPI.C / OPK Common Library (OPKLIB.LIB)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    Registry API source file for custom registry APIs used in the OPK tools
    to easily interface with the registry.

    01/01 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK library.

\****************************************************************************/


//
// Include file(s)
//

#include <pch.h>


//
// External Function(s):
//

BOOL RegExists(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue)
{
    HKEY    hOpenKey    = NULL;
    BOOL    bExists     = FALSE;

    if (lpKey)
    {
        if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
            return bExists;
    }
    else
        hOpenKey = hKeyReg;

    if (lpValue)
        bExists = (RegQueryValueEx(hOpenKey, lpValue, NULL, NULL, NULL, NULL) == ERROR_SUCCESS);
    else
        bExists = TRUE;

    if (lpKey)
        RegCloseKey(hOpenKey);

    return bExists;
}

BOOL RegDelete(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue)
{
    BOOL bSuccess = FALSE;

    if (lpValue) {

        if (lpSubKey) {

            HKEY    hRegKey;

            if (RegOpenKeyEx(hRootKey, lpSubKey, 0, KEY_ALL_ACCESS, &hRegKey) == ERROR_SUCCESS) {

                bSuccess = (RegDeleteValue(hRegKey, lpValue) == ERROR_SUCCESS);
                RegCloseKey(hRegKey);

            }

        }
        else
            bSuccess = (RegDeleteValue(hRootKey, lpValue) == ERROR_SUCCESS);

    }
    else
        bSuccess = (RegDeleteKey(hRootKey, lpSubKey) == ERROR_SUCCESS);

    return bSuccess;
}

LPTSTR RegGetStringEx(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue, BOOL bExpand)
{
    HKEY    hOpenKey    = NULL;
    LPTSTR  lpBuffer    = NULL,
            lpExpand    = NULL;
    DWORD   dwSize      = 0,
            dwType;

    // If the key is specified, we must open it.  Otherwise we can
    // just use the HKEY passed in.
    //
    if (lpKey)
    {
        // If the open key fails, return NULL because the value can't exist.
        //
        if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
            return NULL;
    }
    else
        hOpenKey = hKeyReg;

    // Now query the value to get the size to allocate.  Make sure the date
    // type is a string and that the malloc doesn't fail.
    //
    if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS ) &&
         ( ( dwType == REG_SZ ) || ( dwType == REG_EXPAND_SZ ) ) &&
         ( lpBuffer = (LPTSTR) MALLOC(dwSize) ) )
    {
        // We know the value exists and we have the memory we need to query the value again.
        //
        if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, NULL, (LPBYTE) lpBuffer, &dwSize) == ERROR_SUCCESS ) &&
             ( ( dwType == REG_SZ ) || ( dwType == REG_EXPAND_SZ ) ) )
        {
            // We should expand it if it is supposed to be.
            //
            if ( ( bExpand ) &&
                 ( dwType == REG_EXPAND_SZ ) )
            {
                if ( ( dwSize = ExpandEnvironmentStrings(lpBuffer, NULL, 0) ) &&
                     ( lpExpand = (LPTSTR) MALLOC(dwSize * sizeof(TCHAR)) ) &&
                     ( ExpandEnvironmentStrings(lpBuffer, lpExpand, dwSize) ) &&
                     ( *lpExpand ) )
                {
                    // The expand worked, so free the original buffer and return
                    // the expanded one.
                    //
                    FREE(lpBuffer);
                    lpBuffer = lpExpand;
                }
                else
                {
                    // The expand failed see we should free everything up
                    // and return NULL.
                    //
                    FREE(lpExpand);
                    FREE(lpBuffer);
                }
            }
        }
        else
            // For some reason the query failed, that shouldn't happen
            // but now we need to free and return NULL.
            //
            FREE(lpBuffer);
    }

    // If we opened a key, we must close it.
    //
    if (lpKey)
        RegCloseKey(hOpenKey);

    // Return the buffer allocated, or NULL if something failed.
    //
    return lpBuffer;
}

LPTSTR RegGetString(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue)
{
    return RegGetStringEx(hKeyReg, lpKey, lpValue, FALSE);
}

LPTSTR RegGetExpand(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue)
{
    return RegGetStringEx(hKeyReg, lpKey, lpValue, TRUE);
}

LPVOID RegGetBin(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue)
{
    HKEY    hOpenKey    = NULL;
    LPVOID  lpBuffer    = NULL;
    DWORD   dwSize      = 0,
            dwType;

    // If the key is specified, we must open it.  Otherwise we can
    // just use the HKEY passed in.
    //
    if (lpKey)
    {
        // If the open key fails, return NULL because the value can't exist.
        //
        if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
            return NULL;
    }
    else
        hOpenKey = hKeyReg;

    // Now query the value to get the size to allocate.  Make sure the date
    // type is a string and that the malloc doesn't fail.
    //
    if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS ) &&
         ( dwType == REG_BINARY ) &&
         ( lpBuffer = MALLOC(dwSize) ) )
    {
        // We know the value exists and we have the memory we need to query the value again.
        //
        if ( ( RegQueryValueEx(hOpenKey, lpValue, NULL, NULL, (LPBYTE) lpBuffer, &dwSize) != ERROR_SUCCESS ) ||
             ( dwType != REG_BINARY ) )
            // For some reason the query failed, that shouldn't happen
            // but now we need to free and return NULL.
            //
            FREE(lpBuffer);
    }

    // If we opened a key, we must close it.
    //
    if (lpKey)
        RegCloseKey(hOpenKey);

    // Return the buffer allocated, or NULL if something failed.
    //
    return lpBuffer;
}

DWORD RegGetDword(HKEY hKeyReg, LPTSTR lpKey, LPTSTR lpValue)
{
    HKEY    hOpenKey    = NULL;
    DWORD   dwBuffer,
            dwSize      = sizeof(DWORD),
            dwType;

    if (lpKey) {

        if (RegOpenKeyEx(hKeyReg, lpKey, 0, KEY_ALL_ACCESS, &hOpenKey) != ERROR_SUCCESS)
            return 0;

    }
    else
        hOpenKey = hKeyReg;

    if ( (RegQueryValueEx(hOpenKey, lpValue, NULL, &dwType, (LPBYTE) &dwBuffer, &dwSize) != ERROR_SUCCESS) ||
         (dwSize != sizeof(DWORD)) )

        dwBuffer = 0;

    if (lpKey)
        RegCloseKey(hOpenKey);

    return dwBuffer;
}

BOOL RegSetStringEx(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, LPTSTR lpData, BOOL bExpand)
{
    BOOL bSuccess = FALSE;

    if (lpSubKey) {

        HKEY    hRegKey;
        DWORD   dwBuffer;

        if (RegCreateKeyEx(hRootKey, lpSubKey, 0, TEXT(""), 0, KEY_ALL_ACCESS, NULL, &hRegKey, &dwBuffer) == ERROR_SUCCESS) {

            bSuccess = (RegSetValueEx(hRegKey, lpValue, 0, bExpand ? REG_EXPAND_SZ : REG_SZ, (CONST BYTE *) lpData, (lstrlen(lpData) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS);
            RegCloseKey(hRegKey);

        }

    }
    else

        bSuccess = (RegSetValueEx(hRootKey, lpValue, 0, REG_SZ, (CONST BYTE *) lpData, lstrlen(lpData) + 1) == ERROR_SUCCESS);

    return bSuccess;
}

BOOL RegSetString(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, LPTSTR lpData)
{
    return RegSetStringEx(hRootKey, lpSubKey, lpValue, lpData, FALSE);
}

BOOL RegSetExpand(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, LPTSTR lpData)
{
    return RegSetStringEx(hRootKey, lpSubKey, lpValue, lpData, TRUE);
}

BOOL RegSetDword(HKEY hRootKey, LPTSTR lpSubKey, LPTSTR lpValue, DWORD dwData)
{
    BOOL bSuccess = FALSE;

    if (lpSubKey) {

        HKEY    hRegKey;
        DWORD   dwBuffer;

        if (RegCreateKeyEx(hRootKey, lpSubKey, 0, TEXT(""), 0, KEY_ALL_ACCESS, NULL, &hRegKey, &dwBuffer) == ERROR_SUCCESS) {

            bSuccess = (RegSetValueEx(hRegKey, lpValue, 0, REG_DWORD, (CONST BYTE *) &dwData, sizeof(dwData)) == ERROR_SUCCESS);
            RegCloseKey(hRegKey);

        }

    }
    else

        bSuccess = (RegSetValueEx(hRootKey, lpValue, 0, REG_SZ, (CONST BYTE *) &dwData, sizeof(dwData)) == ERROR_SUCCESS);

    return bSuccess;
}

/****************************************************************************\

BOOL                        // Returns TRUE if value queried is non-zero.  
                            // Otherwise returns FALSE.
                            // Works for REG_SZ, DWORD, and BINARY.

RegCheck(                   // Checks registry for existing value.

    HKEY hKeyRoot,          // Root key to open.
    
    LPTSTR lpKey,           // Subkey to open.
    
    LPTSTR lpValue          // Value to check.
);

\****************************************************************************/
BOOL RegCheck(HKEY hKeyRoot, LPTSTR lpKey, LPTSTR lpValue)
{
    LPTSTR      lpBuffer;
    DWORD       dwSize = 0,
                dwType,
                dwBuffer = 0;
    HKEY        hKeyReg;
    BOOL        bReturn = FALSE;

    if (lpKey)
    {
        if (RegOpenKeyEx(hKeyRoot, lpKey, 0, KEY_ALL_ACCESS, &hKeyReg) != ERROR_SUCCESS)
            return 0;
    }
    else
        hKeyReg = hKeyRoot;

    // Query for the value and allocate the memory for the 
    // value data if it is type REG_SZ.
    //
    if (RegQueryValueEx(hKeyReg, lpValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS)
    {
        if (dwType == REG_SZ)
        {
            // It is a string value, must allocate a buffer for the string.
            //
            if (lpBuffer = (LPTSTR) MALLOC(dwSize))
            {
                if ( (RegQueryValueEx(hKeyReg, lpValue, NULL, NULL, (LPBYTE) lpBuffer, &dwSize) == ERROR_SUCCESS) &&
                    (*lpBuffer != '0') && (*lpBuffer) )
                {
                    dwBuffer = 1;
                }
                FREE(lpBuffer);
            }
        }
        else
        {
            // Must be a DWORD or BIN value.
            //
            RegQueryValueEx(hKeyReg, lpValue, NULL, &dwType, (LPBYTE) &dwBuffer, &dwSize);
        }

        bReturn = (dwBuffer != 0);
    }

    if (lpKey)
        RegCloseKey(hKeyReg);

    return bReturn;
}

BOOL RegEnumKeys(HKEY hKey, LPTSTR lpRegKey, REGENUMKEYPROC hCallBack, LPARAM lParam, BOOL bDelKeys)
{
    TCHAR       szKeyName[MAX_PATH + 1];
    DWORD       dwIndex     = 0,
                dwSize      = AS(szKeyName);
    HKEY        hKeyReg     = hKey,
                hKeyEnum;
    BOOL        bReturn     = TRUE;
    
    // Open a key handle to the key to enumerate.
    //
    if ( ( lpRegKey == NULL ) || 
         ( RegOpenKeyEx(hKey, lpRegKey, 0, KEY_ALL_ACCESS, &hKeyReg) == ERROR_SUCCESS ) )
    {
        // Enumerate all the subkeys in this key.
        //
        while ( bReturn && ( RegEnumKeyEx(hKeyReg, dwIndex, szKeyName, &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS ) )
        {
            if ( RegOpenKeyEx(hKeyReg, szKeyName, 0, KEY_ALL_ACCESS, &hKeyEnum) == ERROR_SUCCESS )
            {
                bReturn = hCallBack(hKeyEnum, szKeyName, lParam);
                RegCloseKey(hKeyEnum);
            }
            if ( !bDelKeys || ( RegDeleteKey(hKeyReg, szKeyName) != ERROR_SUCCESS ) )
                dwIndex++;
            dwSize = sizeof(szKeyName);
        }
        if (lpRegKey)
            RegCloseKey(hKeyReg);
    }
    else
        bReturn = FALSE;
    return bReturn;
}

BOOL RegEnumValues(HKEY hKey, LPTSTR lpRegKey, REGENUMVALPROC hCallBack, LPARAM lParam, BOOL bDelValues)
{
    TCHAR       szValueName[MAX_PATH + 1];
    LPTSTR      lpBuffer;
    DWORD       dwIndex     = 0,
                dwSize      = AS(szValueName),
                dwDataSize  = 0,
                dwType;
    HKEY        hKeyReg     = hKey;
    BOOL        bReturn     = TRUE;
    
    // Open a key handle to the key to enumerate.
    //
    if ( (lpRegKey == NULL) || 
         (RegOpenKeyEx(hKey, lpRegKey, 0, KEY_ALL_ACCESS, &hKeyReg) == ERROR_SUCCESS) ) {

        // Enumerate all the values in this key.
        //
        while (bReturn && (RegEnumValue(hKeyReg, dwIndex, szValueName, &dwSize, NULL, &dwType, NULL, &dwDataSize) == ERROR_SUCCESS)) {

            if ((dwType == REG_SZ) &&
                (lpBuffer = (LPTSTR) MALLOC(dwDataSize))) {

                if (RegQueryValueEx(hKeyReg, szValueName, NULL, NULL, (LPBYTE) lpBuffer, &dwDataSize) == ERROR_SUCCESS)
                    bReturn = hCallBack(szValueName, lpBuffer, lParam);

                FREE(lpBuffer);

            }

            if ( !bDelValues || (RegDeleteValue(hKeyReg, szValueName) != ERROR_SUCCESS) )
                dwIndex++;

            dwSize = sizeof(szValueName);
            dwDataSize = 0;

        }

        if (lpRegKey)
            RegCloseKey(hKeyReg);

    }
    else
        bReturn = FALSE;

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\opklib\strapi.c ===
/****************************************************************************\

    STRAPI.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    String API source file for generic APIs used in the OPK Wizard.

    4/99 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard as part of the
        Millennium rewrite.
    7/00 - Brian Ku (BRIANK)
        Added to Whistler

\****************************************************************************/


//
// Include file(s)
//

#include <pch.h>
#include <tchar.h>


//
// Internal Defined Value(s):
//

#define NULLCHR                 _T('\0')


//
// External Function(s):
//

/****************************************************************************\

LPTSTR                      // Returns a pointer to the first occurance of a
                            // character in a string, or NULL if the
                            // character isn't found.

StrChr(                     // Searches a string for a particular character.

    LPCTSTR lpString,       // Points to a string buffer to search.

    TCHAR cSearch           // Character to search for.

);

\****************************************************************************/
#ifndef _INC_SHLWAPI
LPTSTR StrChr(LPCTSTR lpString, TCHAR cSearch)
{
    // Validate the parameters passed in.
    //
    if ( ( lpString == NULL ) || ( *lpString == NULLCHR ) )
		return NULL;

    // Go through the string until the character is found,
    // or we hit the null terminator.
    //
    while ( ( *lpString != cSearch ) && ( *(lpString = CharNext(lpString)) ) );

    // If we didn't find it, null the pointer out.
    //
    if ( *lpString != cSearch )
        lpString = NULL;

    // Return either null or a pointer to the found character.
    //
    return (LPTSTR) lpString;
}

/****************************************************************************\

LPTSTR                      // Returns a pointer to the last occurance of a
                            // character in a string, or NULL if the
                            // character isn't found.

StrRChr(                    // Searches a string for a particular character.

    LPCTSTR lpString,       // Points to a string buffer to search.

    TCHAR cSearch           // Character to search for.

);

\****************************************************************************/

LPTSTR StrRChr(LPCTSTR lpString, TCHAR cSearch)
{
    LPTSTR lpSearch;

    // Validate the parameters passed in.
    //
    if ( ( lpString == NULL ) || ( *lpString == NULLCHR ) )
		return NULL;

    // Go back through the string until the character is found,
    // or we hit the begining of the string.
    //
    for ( lpSearch = (LPTSTR) lpString + lstrlen(lpString);
          ( lpSearch > lpString ) && ( *lpSearch != cSearch );
          lpSearch = CharPrev(lpString, lpSearch));

    // If we didn't find it, null the pointer out.
    //
    if ( *lpSearch != cSearch )
        lpSearch = NULL;

    // Return either null or a pointer to the found character.
    //
    return (LPTSTR) lpSearch;
}
#endif // _INC_SHLWAPI

/****************************************************************************\

LPTSTR                      // Returns a pointer to the string buffer passed
                            // in.

StrRem(                     // Searches a string for a particular character
                            // and removes that character from the string in
                            // place.

    LPCTSTR lpString,       // Points to a string buffer to search and remove
                            // the characters from.

    TCHAR cRemove           // Character to search for and remove.

);

\****************************************************************************/

LPTSTR StrRem(LPTSTR lpString, TCHAR cRemove)
{
    LPTSTR lpSearch;

    // Validate the parameters passed in.
    //
    if ( ( lpString == NULL ) || ( *lpString == NULLCHR ) || ( cRemove == NULLCHR ) )
		return lpString;

    // Search the string for the character we want to remove.
    // Everytime we find it, shift the string over a character
    // to remove it.
    //
    for ( lpSearch = StrChr(lpString, cRemove); lpSearch; lpSearch = StrChr(lpSearch, cRemove) )
        lstrcpy(lpSearch, lpSearch + 1);

    // Return the pointer to the string passed in.
    //
    return lpString;
}

/****************************************************************************\

LPTSTR                      // Returns a pointer to the string buffer passed
                            // in.

StrRTrm(                    // Searches a string for a particular ending
                            // character, and removes all of them from the
                            // ending of the string.

    LPCTSTR lpString,       // Points to a string buffer to search and remove
                            // the characters from.

    TCHAR cTrim             // Character to search for and remove.

);

\****************************************************************************/

LPTSTR StrRTrm(LPTSTR lpString, TCHAR cTrim)
{
    LPTSTR  lpEnd;

    // Validate the parameters passed in.
    //
	if ( ( lpString == NULL ) || ( *lpString == NULLCHR ) || ( cTrim == NULLCHR ) )
		return lpString;

    // Null out the end of the string minus
    // the chacters we are trimming.
    //
    for ( lpEnd = lpString + lstrlen(lpString); (lpEnd > lpString) && (*CharPrev(lpString, lpEnd) == cTrim); lpEnd = CharPrev(lpString, lpEnd) );
    *lpEnd = NULLCHR;

	return lpString;
}

/****************************************************************************\

LPTSTR                      // Returns a pointer to the string buffer passed
                            // in.

StrTrm(                     // Searches a string for a particular proceeding
                            // and ending character, and removes all of them
                            // from the beginning and ending of the string.

    LPCTSTR lpString,       // Points to a string buffer to search and remove
                            // the characters from.

    TCHAR cTrim             // Character to search for and remove.

);

\****************************************************************************/

LPTSTR StrTrm(LPTSTR lpString, TCHAR cTrim)
{
    LPTSTR  lpBegin;

    // Validate the parameters passed in.
    //
	if ( ( lpString == NULL ) || ( *lpString == NULLCHR ) || ( cTrim == NULLCHR ) )
		return lpString;

    // Get a pointer to the begining of the string
    // minus the characters we are trimming.
    //
    for ( lpBegin = lpString; *lpBegin == cTrim; lpBegin = CharNext(lpBegin) );

    // Make sure we didn't hit the null terminator.
    //
    if ( *lpBegin == NULLCHR )
    {
        *lpString = NULLCHR;
        return lpString;
    }

    // Null out the end of the string minus
    // the chacters we are trimming.
    //
    StrRTrm(lpBegin, cTrim);

    // Now we may need to move the string to the beginning
    // of the buffer if we trimmed of proceeding characters.
    //
    if ( lpBegin > lpString )
        lstrcpy(lpString, lpBegin);

	return lpString;
}

/****************************************************************************\

LPTSTR                      // Returns a pointer to the string a character in
                            // the string passed in.

StrMov(                     // Moves a pointer forward or backward the number
                            // of characters passed in.

    LPCTSTR lpStart,        // Pointer to the begining of the string buffer.
                            // This may only be NULL if nCount is positive.

    LPCTSTR lpCurrent,      // Pointer to a character in the null-terminated
                            // string.

    INT nCount              // Number of characters to move the pointer,
                            // forward if it is a positive value, backward
                            // if it is negative.

);

\****************************************************************************/

LPTSTR StrMov(LPTSTR lpStart, LPTSTR lpCurrent, INT nCount)
{
    // Validate the parameters.
    //
    if ( ( lpCurrent == NULL ) ||
         ( ( lpStart == NULL ) && ( nCount < 0 ) ) )
    {
        return lpCurrent;
    }

    // Loop throuh until we don't need to move the pointer anymore.
    //
    while ( nCount != 0 )
    {
        // Check to see if we are moving forward or backward.
        //
        if ( nCount > 0 )
        {
            // Move the pointer forward one character.
            //
            lpCurrent = CharNext(lpCurrent);
            nCount--;
        }
        else
        {
            // Move the pointer backward one character.
            //
            lpCurrent = CharPrev(lpStart, lpCurrent);
            nCount++;
        }
    }

    // Return the pointer to the new position.
    //
    return lpCurrent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\opklib\opklib.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    opk.c

Abstract:

    Common modules shared by OPK tools.  Note: Source Depot requires that we 
    publish the .h (E:\NT\admin\published\ntsetup) and .lib 
    (E:\NT\public\internal\admin\lib).

Author:

    Brian Ku (briank) 06/20/2000

Revision History:

    7/00 - Jason Cohen (jcohen)
        Added in the rest of the common APIs form Millennium (need for lfnbk).

--*/


//
// Include file(s)
//

#include <pch.h>
#include <tchar.h>
#include <shlwapi.h>


//
// External Function(s):
//

LPTSTR AllocateString(HINSTANCE hInstance, UINT uID)
{
    //  ISSUE-2002/02/26-acosma - This sets a restriction of 256 characters on the buffer.
    //
    TCHAR   szBuffer[256];
    LPTSTR  lpBuffer = NULL;

    // Load the string from the resource and then allocate
    // a buffer just big enough for it.  Strings can exceed 256 characters.
    //
    if ( ( LoadString(hInstance, uID, szBuffer, sizeof(szBuffer) / sizeof(TCHAR)) ) &&
         ( lpBuffer = (LPTSTR) MALLOC(sizeof(TCHAR) * (lstrlen(szBuffer) + 1)) ) )
    {
        lstrcpy(lpBuffer, szBuffer);
    }

    // Return the allocated buffer, or NULL if there was an error.
    //
    return lpBuffer;
}

LPTSTR AllocateExpand(LPTSTR lpszBuffer)
{
    LPTSTR      lpszExpanded = NULL;
    DWORD       cbExpanded;

    // First we need to get the size of the expanded buffer and
    // allocate it.
    //
    if ( ( cbExpanded = ExpandEnvironmentStrings(lpszBuffer, NULL, 0) ) &&
         ( lpszExpanded = (LPTSTR) MALLOC(cbExpanded * sizeof(TCHAR)) ) )
    {
        // Now expand out the buffer.
        //
        if ( ( 0 == ExpandEnvironmentStrings(lpszBuffer, lpszExpanded, cbExpanded) ) ||
             ( NULLCHR == *lpszExpanded ) )
        {
            FREE(lpszExpanded);
        }
    }

    // Return the allocated buffer, or NULL if there was an error
    // or nothing in the string.
    //
    return lpszExpanded;
}

LPTSTR AllocateStrRes(HINSTANCE hInstance, LPSTRRES lpsrTable, DWORD cbTable, LPTSTR lpString, LPTSTR * lplpReturn)
{
    LPSTRRES    lpsrSearch  = lpsrTable;
    LPTSTR      lpReturn    = NULL;
    BOOL        bFound;

    // Init this return value.
    //
    if ( lplpReturn )
        *lplpReturn = NULL;

    // Try to find the friendly name for this string in our table.
    //
    while ( ( bFound = ((DWORD) (lpsrSearch - lpsrTable) < cbTable) ) &&
            ( lstrcmpi(lpString, lpsrSearch->lpStr) != 0 ) )
    {
        lpsrSearch++;
    }

    // If it was found, allocate the friendly name from the resource.
    //
    if ( bFound )
    {
        lpReturn = AllocateString(hInstance, lpsrSearch->uId);
        if ( lplpReturn )
            *lplpReturn = lpsrSearch->lpStr;
    }

    return lpReturn;
}

int MsgBoxLst(HWND hwndParent, LPTSTR lpFormat, LPTSTR lpCaption, UINT uType, va_list lpArgs)
{
    INT     nReturn;
    DWORD   dwCount     = 0;
    LPTSTR  lpText      = NULL;

    // The format string is required.
    //
    if ( lpFormat )
    {
        do
        {
            // Allocate 1k of characters at a time.
            //
            dwCount += 1024;

            // Free the previous buffer, if there was one.
            //
            FREE(lpText);

            // Allocate a new buffer.
            //
            if ( lpText = MALLOC(dwCount * sizeof(TCHAR)) )
                nReturn = _vsntprintf(lpText, dwCount, lpFormat, lpArgs);
            else
                nReturn = 0;
        }
        while ( nReturn < 0 );

        // Make sure we have the format string.
        //
        if ( lpText )
        {
            // Display the message box.
            //
            nReturn = MessageBox(hwndParent, lpText, lpCaption, uType);
            FREE(lpText);
        }
    }
    else
        nReturn = 0;

    // Return the return value of the MessageBox() call.  If there was a memory
    // error, 0 will be returned.
    //
    return nReturn;
}

int MsgBoxStr(HWND hwndParent, LPTSTR lpFormat, LPTSTR lpCaption, UINT uType, ...)
{
    va_list lpArgs;

    // Initialize the lpArgs parameter with va_start().
    //
    va_start(lpArgs, uType);

    // Return the return value of the MessageBox() call.  If there was a memory
    // error, 0 will be returned.  This is all 
    //
    return MsgBoxLst(hwndParent, lpFormat, lpCaption, uType, lpArgs);
}

int MsgBox(HWND hwndParent, UINT uFormat, UINT uCaption, UINT uType, ...)
{
    va_list lpArgs;
    INT     nReturn;
    LPTSTR  lpFormat    = NULL,
            lpCaption   = NULL;

    // Initialize the lpArgs parameter with va_start().
    //
    va_start(lpArgs, uType);

    // Get the format and caption strings from the resource.
    //
    if ( uFormat )
        lpFormat = AllocateString(NULL, uFormat);
    if ( uCaption )
        lpCaption = AllocateString(NULL, uCaption);

    // Return the return value of the MessageBox() call.  If there was a memory
    // error, 0 will be returned.
    //
    nReturn = MsgBoxLst(hwndParent, lpFormat, lpCaption, uType, lpArgs);

    // Free the format and caption strings.
    //
    FREE(lpFormat);
    FREE(lpCaption);    

    // Return the value saved from the previous function call.
    //
    return nReturn;
}

void CenterDialog(HWND hwnd)
{
    CenterDialogEx(NULL, hwnd); 
}


void CenterDialogEx(HWND hParent, HWND hChild)
{
    RECT rcChild,
         rcParent;

    if ( GetWindowRect(hChild, &rcChild) )
    {
        // If parent is specified center with respect to parent.
        if ( hParent && (GetWindowRect(hParent, &rcParent)) )
            SetWindowPos(hChild, NULL, ((rcParent.right + rcParent.left - (rcChild.right - rcChild.left)) / 2), ((rcParent.bottom + rcParent.top - (rcChild.bottom - rcChild.top)) / 2), 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

        // Otherwise center with respect to screen.
        //
        else 
            SetWindowPos(hChild, NULL, ((GetSystemMetrics(SM_CXSCREEN) - (rcChild.right - rcChild.left)) / 2), ((GetSystemMetrics(SM_CYSCREEN) - (rcChild.bottom - rcChild.top)) / 2), 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
    }
}
        

        


INT_PTR CALLBACK SimpleDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            //CenterDialog(hwnd);
            return FALSE;

        case WM_COMMAND:
            EndDialog(hwnd, LOWORD(wParam));
            return FALSE;

        default:
            return FALSE;
    }

    return TRUE;
}

INT_PTR SimpleDialogBox(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent)
{
    return DialogBox(hInstance, lpTemplate, hWndParent, SimpleDialogProc);
}

/****************************************************************************\

HFONT                       // Returns a valid handle to a font if it is
                            // successfully created, or NULL if something
                            // failed.  The font handle should be deleteted
                            // with DeleteObject() when it is no longer
                            // needed.

GetFont(                    // This function creates a font based in the info
                            // passed in.

    HWND hwndCtrl,          // Handle to a control that is used for the
                            // default font characteristics.  This may be
                            // NULL if not default is control is available.

    LPTSTR lpFontName,      // Points to a string that contains the name of
                            // the font to create. This parameter may be NULL
                            // if a valid control handle is passed in.  In
                            // that case, the font of the control is used.

    DWORD dwFontSize,       // Point size to use for the font.  If it is zero,
                            // the default is used.

    BOOL bSymbol            // If this is TRUE, the font is set to
                            // SYMBOL_CHARSET.  Typically this is FALSE.

);

\****************************************************************************/

HFONT GetFont(HWND hwndCtrl, LPTSTR lpFontName, DWORD dwFontSize, LONG lFontWeight, BOOL bSymbol)
{
    HFONT           hFont;
    LOGFONT         lFont;
    BOOL            bGetFont;

    // If the font name is passed in, then try to use that
    // first before getting the font of the control.
    //
    if ( lpFontName && *lpFontName )
    {
        // Make sure the font name is not longer than
        // 32 characters (including the NULL terminator).
        //
        if ( lstrlen(lpFontName) >= sizeof(lFont.lfFaceName) )
            return NULL;

        // Setup the structure to use to get the
        // font we want.
        //
        ZeroMemory(&lFont, sizeof(LOGFONT));
        lFont.lfCharSet = DEFAULT_CHARSET;
        lstrcpy(lFont.lfFaceName, lpFontName);
    }
        
    // First try to get the font that we wanted.
    //
    if ( ( lpFontName == NULL ) ||
         ( *lpFontName == NULLCHR ) ||
         ( (hFont = CreateFontIndirect((LPLOGFONT) &lFont)) == NULL ) )
    {
        // Couldn't get the font we wanted, try the font of the control
        // if a valid window handle was passed in.
        //
        if ( ( hwndCtrl == NULL ) ||
             ( (hFont = (HFONT) (WORD) SendMessage(hwndCtrl, WM_GETFONT, 0, 0L)) == NULL ) )
        {
            // All atempts to get the font failed.  We must return NULL.
            //
            return NULL;
        }
    }

    // Return the font we have now if we don't need to
    // change the size or weight.
    //
    if ( (lFontWeight == 0) && (dwFontSize == 0) )
        return hFont;

    // We must have a valid HFONT now.  Fill in the structure
    // and setup the size and weight we wanted for it.
    //
    bGetFont = GetObject(hFont, sizeof(LOGFONT), (LPVOID) &lFont);
    DeleteObject(hFont);

    if ( bGetFont )
    {
        // Set the bold and point size of the font.
        //
        if ( lFontWeight )
            lFont.lfWeight = lFontWeight;
        if ( dwFontSize )
            lFont.lfHeight = -MulDiv(dwFontSize, GetDeviceCaps(GetDC(NULL), LOGPIXELSY), 72);
        if ( bSymbol )
            lFont.lfCharSet = SYMBOL_CHARSET;

        // Create the font.
        //
        hFont = CreateFontIndirect((LPLOGFONT) &lFont);
    }
    else
        hFont = NULL;

    return hFont;
}

void ShowEnableWindow(HWND hwnd, BOOL bShowEnable)
{
    EnableWindow(hwnd, bShowEnable);
    ShowWindow(hwnd, bShowEnable ? SW_SHOW : SW_HIDE);
}

/****************************************************************************\

BOOL                        // Returns TRUE if we are running a server OS.

IsServer(                   // This routine checks if we're running on a
                            // Server OS.

    VOID

);

\****************************************************************************/

BOOL IsServer(VOID) 
{
    OSVERSIONINFOEX verInfo;
    BOOL            fReturn = FALSE;

    verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if ( ( GetVersionEx((LPOSVERSIONINFO) &verInfo) ) &&
         ( verInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ) &&
         ( ( verInfo.wProductType == VER_NT_SERVER ) ||
           ( verInfo.wProductType == VER_NT_DOMAIN_CONTROLLER ) ) )
    {
        fReturn = TRUE;
    }

    return fReturn;
}


BOOL IsIA64() 
/*++
===============================================================================
Routine Description:

    This routine checks if we're running on a 64-bit machine.

Arguments:

    None - 

Return Value:

    TRUE - We are running on 64-bit machine.
    FALSE - Not a 64-bit machine.

===============================================================================
--*/
{
    BOOL        fReturn         = FALSE;
    ULONG_PTR   Wow64Info       = 0;
    DWORD       dwSt            = 0;
    SYSTEM_INFO siSystemInfo;

    ZeroMemory( &siSystemInfo, sizeof(SYSTEM_INFO) );
    GetSystemInfo(&siSystemInfo);

    if ( (siSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) ||
         (siSystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64) )
        fReturn = TRUE;
    

    if (!fReturn)
    {
        // Now make sure that GetSystemInfo isn't lying because we are in emulation mode.
    
        dwSt = NtQueryInformationProcess(GetCurrentProcess(), ProcessWow64Information, &Wow64Info, sizeof(Wow64Info), NULL);
        if (!NT_SUCCESS(dwSt)) 
        {
            // Handle to process is bad, or the code is compiled 32-bit and running on NT4 or earlier.
            // Do nothing

        } 
        else if (Wow64Info)
        {
            // The process is 32-bit and is running inside WOW64.
            // We are really on IA64 and running in 32-bit mode.
            fReturn = TRUE;

        }
    }
    return fReturn;

}







BOOL ValidDosName(LPCTSTR lpName)
{
    LPCTSTR lpSearch    = lpName;
    int     nDot        = 0,
            nSpot       = 0,
            nLen;

    // Do the easy checks.
    //
    if ( ( lpSearch == NULL ) ||
         ( *lpSearch == NULLCHR ) ||
         ( (nLen = lstrlen(lpSearch)) > 12 ) )
    {
        return FALSE;
    }

    // Search the string.
    //
    for (; *lpSearch; lpSearch++)
    {
        // Check for dots.
        //
        if ( *lpSearch == _T('.') )
        {
            // Keep track of the number of dots.
            //
            nDot++;
            nSpot = (int) (lpSearch - lpName);
        }
        else
        {
            // Check for valid characters.
            //
            if ( !( ( ( _T('0') <= *lpSearch ) && ( *lpSearch <= _T('9') ) ) ||
                    ( ( _T('a') <= *lpSearch ) && ( *lpSearch <= _T('z') ) ) ||
                    ( ( _T('A') <= *lpSearch ) && ( *lpSearch <= _T('Z') ) ) ||
                    ( *lpSearch == _T('-') ) ||
                    ( *lpSearch == _T('_') ) ||
                    ( *lpSearch == _T('~') ) ) )
            {
                // Invalid character.
                //
                return FALSE;
            }
        }
    }

    // Make sure the dot is in the right place.
    //
    if ( ( nDot > 1 ) ||
         ( ( nDot == 0 ) && ( nLen > 8 ) ) ||
         ( ( nDot == 1 ) && ( nSpot > 8 ) ) ||
         ( ( nDot == 1 ) && ( (nLen - nSpot) > 4 ) ) )
    {
        return FALSE;
    }

    return TRUE;
}

DWORD GetLineArgs(LPTSTR lpSrc, LPTSTR ** lplplpArgs, LPTSTR * lplpAllArgs)
{
    LPTSTR  lpCmdLine,
            lpArg,
            lpDst;
    DWORD   dwArgs = 0;
    BOOL    bQuote;

    // Fist make sure that we were passed in a valid pointer, we have a command
    // line to parse, and that we were able to allocate the memory to hold it.
    //
    if ( ( lplplpArgs != NULL ) &&
         ( lpSrc ) &&
         ( *lpSrc ) &&
         ( lpCmdLine = (LPTSTR) MALLOC((lstrlen(lpSrc) + 1) * sizeof(TCHAR)) ) )
    {
        // Fist parse the command line into NULL terminated sub strings.
        //
        lpDst = lpCmdLine;
        while ( *lpSrc )
        {
            // Eat the preceeding spaces.
            //
            while ( *lpSrc == _T(' ') )
                lpSrc = CharNext(lpSrc);

            // Make sure we still have an argument.
            //
            if ( *lpSrc == _T('\0') )
                break;

            // Return a pointer to all the command line args if they want one.
            //
            if ( ( dwArgs == 1 ) && lplpAllArgs )
                *lplpAllArgs = lpSrc;

            // Save the current arg pointer.
            //
            lpArg = lpDst;
            dwArgs++;

            // See if we are looking for the next quote or space.
            //
            if ( bQuote = (*lpSrc == _T('"')) )
                lpSrc = CharNext(lpSrc);

            // Copy the argument into our allocated buffer until we
            // hit the separating character (which will always be a space).
            //
            while ( *lpSrc && ( bQuote || ( *lpSrc != _T(' ') ) ) )
            {
                // We special case the quote.
                //
                if ( *lpSrc == _T('"') )
                {
                    // If the character before the quote is a backslash, then
                    // we don't count this as the separating quote.
                    //
                    LPTSTR lpPrev = CharPrev(lpCmdLine, lpDst);
                    if ( lpPrev && ( *lpPrev == _T('\\') ) )
                        *lpPrev = *lpSrc++;
                    else
                    {
                        // Since we have found the separating quote, set this to
                        // false so we look for the next space.
                        //
                        bQuote = FALSE;
                        lpSrc++;
                    }                        
                }
                else
                    *lpDst++ = *lpSrc++;
            }

            // NULL terminate this argument.
            //
            *lpDst++ = _T('\0');
        }

        // Now setup the pointers to each argument.  Make sure we have some arguments
        // to return and that we have the memory allocated for the array.
        //
        if ( *lpCmdLine && dwArgs && ( *lplplpArgs = (LPTSTR *) MALLOC(dwArgs * sizeof(LPTSTR)) ) )
        {
            DWORD dwCount = 0;

            // Copy a pointer to each NULL terminated sub string into our
            // array of arguments we are going to return.
            //
            do
            {
                *(*lplplpArgs + dwCount) = lpCmdLine;
                lpCmdLine += lstrlen(lpCmdLine) + 1;
            }
            while ( ++dwCount < dwArgs );
        }
        else
        {
            // Either there were no command line arguments, or the memory allocation
            // failed for the list of arguments to return.
            //
            dwArgs = 0;
            FREE(lpCmdLine);
        }
    }

    return dwArgs;
}

DWORD GetCommandLineArgs(LPTSTR ** lplplpArgs)
{
    return GetLineArgs(GetCommandLine(), lplplpArgs, NULL);
}

// 
// Generic singularly linked list pvItem must be allocated with MALLOC
//
BOOL FAddListItem(PGENERIC_LIST* ppList, PGENERIC_LIST** pppNewItem, PVOID pvItem)
{    
    if (pppNewItem && *pppNewItem == NULL)
        *pppNewItem = ppList;

    if (*pppNewItem) {
        if (**pppNewItem = (PGENERIC_LIST)MALLOC(sizeof(GENERIC_LIST))) {
            (**pppNewItem)->pNext = NULL;
            (**pppNewItem)->pvItem = pvItem;
            *pppNewItem = &((**pppNewItem)->pNext);
            return TRUE;
        }
    }
    return FALSE;
}

void FreeList(PGENERIC_LIST pList)
{
    while (pList) {
        PGENERIC_LIST pTemp = pList;
        pList = pList->pNext;

        FREE(pTemp->pvItem);
        FREE(pTemp);
    }
}

// Find factory.exe from the current process, should be in same directory
//
BOOL FGetFactoryPath(LPTSTR pszFactoryPath)
{
    // Attempt to locate FACTORY.EXE
    //
    // NTRAID#NTBUG9-549770-2002/02/26-acosma,georgeje - Possible buffer overflow.
    //
    if (pszFactoryPath && GetModuleFileName(NULL, pszFactoryPath, MAX_PATH)) {
        if (PathRemoveFileSpec(pszFactoryPath)) {
            PathAppend(pszFactoryPath, TEXT("FACTORY.EXE"));
            if (FileExists(pszFactoryPath))
                return TRUE;
        }
    }
    return FALSE;
}

// Find sysprep.exe from the current process, should be in same directory
//
BOOL FGetSysprepPath(LPTSTR pszSysprepPath)
{
    // Attempt to locate SYSPREP.EXE
    //
    // NTRAID#NTBUG9-549770-2002/02/26-acosma,georgeje - Possible buffer overflow.
    //
    if (pszSysprepPath && GetModuleFileName(NULL, pszSysprepPath, MAX_PATH)) {
        if (PathRemoveFileSpec(pszSysprepPath)) {
            PathAppend(pszSysprepPath, TEXT("SYSPREP.EXE"));
            if (FileExists(pszSysprepPath))
                return TRUE;
        }
    }
    return FALSE;
}


//------------------------------------------------------------------------------------------------------
//
// Function:    ConnectNetworkResource
//
// Purpose:     This function allows the user to connect to a network resource with
//              supplied credentials.
//
// Arguments:   lpszPath:       Network Resource that should be shared out
//              lpszUsername:   Username for credentials, can be in form of domain\username
//              lpszPassword:   Password to use for credentials
//              bState:         If set to TRUE we will add the connection, if FALSE we will
//                              attempt to delete the connection
//
// Returns:     BOOL            If the NetUse command was successful, TRUE is returned
//
//------------------------------------------------------------------------------------------------------
NET_API_STATUS ConnectNetworkResource(LPTSTR lpszPath, LPTSTR lpszUsername, LPTSTR lpszPassword, BOOL bState)
{
    BOOL            bRet   = FALSE;
    USE_INFO_2      ui2;
    NET_API_STATUS  nerr_NetUse;
    TCHAR           szDomain[MAX_PATH]  = NULLSTR,
                    szNetUse[MAX_PATH]  = NULLSTR;
    LPTSTR          lpUser,
                    lpSearch;

    // Zero out the user information structure
    //
    ZeroMemory(&ui2, sizeof(ui2));

    // Copy the path into our buffer so we can work with it
    //
    lstrcpyn(szNetUse, lpszPath, AS(szNetUse));
    StrRTrm(szNetUse, CHR_BACKSLASH);

    if ( szNetUse[0] && PathIsUNC(szNetUse) )
    {
        // Disconnect from existing share
        //
        nerr_NetUse = NetUseDel(NULL, szNetUse, USE_NOFORCE);

        // We need to Add a connection
        //
        if ( bState )
        {
            ui2.ui2_remote      = szNetUse;
            ui2.ui2_asg_type    = USE_DISKDEV;
            ui2.ui2_password    = lpszPassword;
    
            lstrcpyn(szDomain, lpszUsername, AS(szDomain));

            // Break up the Domain\Username for the NetUse function
            //
            if (lpUser = StrChr(szDomain, CHR_BACKSLASH) )
            {
                // Put a NULL character after the domain part of the user name
                // and advance the pointer to point to the actual user name.
                //
                *(lpUser++) = NULLCHR;
            }
            else
            {
                // Use the computer name in the path as the domain name.
                //
                if ( lpSearch = StrChr(szNetUse + 2, CHR_BACKSLASH) )
                    lstrcpyn(szDomain, szNetUse + 2, (int)((lpSearch - (szNetUse + 2)) + 1));
                else
                    lstrcpyn(szDomain, szNetUse + 2, AS(szDomain));

                lpUser = lpszUsername;
            }

            // Set the domain and user name pointers into our struct.
            //
            ui2.ui2_domainname  = szDomain;
            ui2.ui2_username    = lpUser;

            // Create a connect to the share
            //
            nerr_NetUse = NetUseAdd(NULL, 2, (LPBYTE) &ui2, NULL);
        }
    }
    else
        nerr_NetUse = NERR_UseNotFound;

    // Return failure/success
    //
    return nerr_NetUse;
}

BOOL GetUncShare(LPCTSTR lpszPath, LPTSTR lpszShare, DWORD cbShare)
{
    BOOL    bRet;
    LPCTSTR lpSrc = lpszPath;
    LPTSTR  lpDst = lpszShare;
    DWORD   dwBackslashes,
            dwCount;

    // Make sure the path is a UNC by calling the shell function.
    //
    bRet = PathIsUNC(lpszPath);

    // This will loop through the path string twice, each time coping all the
    // backslashes and then all the non-backslashes.  So if the string passed
    // in was "\\COMPUTER\SHARE\DIR\FILE.NAME", the first pass will copy
    // "\\COMPUTER" and the next pass would then copy "\SHARE" so the final
    // string would then be "\\COMPUTER\SHARE".  This loop also verifies there
    // are the correct number of backslashes and non-backslashes.  If there is
    // no return buffer, then we just are verifing the share.
    //
    for ( dwBackslashes = 2; dwBackslashes && bRet; dwBackslashes-- )
    {
        // First copy the backslashes.
        //
        dwCount = 0;
        while ( _T('\\') == *lpSrc )
        {
            if ( lpDst && cbShare )
            {
                *lpDst++ = *lpSrc;
                cbShare--;
            }
            lpSrc++;
            dwCount++;
        }

        // Make sure the number of backslashes is correct.
        // The fist pass there should be two and the next
        // pass should be just one.
        //
        if ( dwBackslashes != dwCount )
        {
            bRet = FALSE;
        }
        else
        {
            // Now copy the non-backslashes.
            //
            dwCount = 0;
            while ( ( *lpSrc ) &&
                    ( _T('\\') != *lpSrc ) )
            {
                if ( lpDst && cbShare )
                {
                    *lpDst++ = *lpSrc;
                    cbShare--;
                }
                lpSrc++;
                dwCount++;
            }

            // Make sure there was at least one non-backslash.
            // character.
            //
            // Also if we are on the first pass and the path
            // buffer is already empty, then we don't have the
            // share part so just error out.
            //
            if ( ( 0 == dwCount ) ||
                 ( ( 2 == dwBackslashes ) &&
                   ( NULLCHR == *lpSrc ) ) )
            {
                bRet = FALSE;
            }
        }
    }

    // Only fix up the return buffer if there is one.
    //
    if ( lpszShare )
    {
        // Make sure that we didn't fail and that we still
        // have room for the null terminator.
        //
        if ( bRet && cbShare )
        {
            // Don't forget to null terminate the return string.
            //
            *lpDst = NULLCHR;
        }
        else
        {
            // If we failed or ran out of buffer room, make sure
            // we don't return anything.
            //
            *lpszShare = NULLCHR;
        }
    }

    return bRet;
}

DWORD GetSkuType()
{
    DWORD           dwRet = 0;
    OSVERSIONINFOEX osvi;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if ( GetVersionEx((LPOSVERSIONINFO) &osvi) )
    {
        if ( VER_NT_WORKSTATION == osvi.wProductType )
        {
            if ( GET_FLAG(osvi.wSuiteMask, VER_SUITE_PERSONAL) )
            {
                dwRet = VER_SUITE_PERSONAL;
            }
            else
            {
                dwRet = VER_NT_WORKSTATION;
            }
        }
        else
        {
            if ( GET_FLAG(osvi.wSuiteMask, VER_SUITE_DATACENTER) )
            {
                dwRet = VER_SUITE_DATACENTER;
            }
            else if ( GET_FLAG(osvi.wSuiteMask, VER_SUITE_ENTERPRISE) )
            {
                dwRet = VER_SUITE_ENTERPRISE;
            }
            else if ( GET_FLAG(osvi.wSuiteMask, VER_SUITE_BLADE) )
            {
                dwRet = VER_SUITE_BLADE;
            }
            else
            {
                dwRet = VER_NT_SERVER;
            }
        }
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setup\makefile.inc ===
# THIS BUILDS THE OPK.MSI WITH VERSION INFORMATION
#
opk_msi: $(O)\opk.msi

$(O)\opk.msi: opk.msx
          copy opk.msx $(O)\opk.msi          
          copy file.idt $(O)\file.idt
	  perl $(PROJECT_ROOT)\ntsetup\opktools\setup\tok_upgdtbl.pl $(PROJECT_ROOT)\ntsetup\opktools\setup\upgrade.idt > $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O)\upgrade.idt
	  perl $(PROJECT_ROOT)\ntsetup\opktools\setup\tok_bldnum.pl $(PROJECT_ROOT)\ntsetup\opktools\setup\property.idt > $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O)\temp1.idt
	  perl $(PROJECT_ROOT)\ntsetup\opktools\setup\tok_lang.pl $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O)\temp1.idt ENG > $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O)\property.idt
          perl $(PROJECT_ROOT)\ntsetup\opktools\setup\tok_lang.pl $(PROJECT_ROOT)\ntsetup\opktools\setup\director.idt ENG > $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O)\temp2.idt
          msidb -d $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O)\opk.msi -f $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O) -i property
          msidb -d $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O)\opk.msi -f $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O) -i temp2
          msidb -d $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O)\opk.msi -f $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O) -i file
	  msidb -d $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O)\opk.msi -f $(PROJECT_ROOT)\ntsetup\opktools\setup\$(O) -i upgrade
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setact\setact.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    setact.cpp

Abstract:

    Gets/Sets the active partition on an MBR disk

Author:

    Vijay Jayaseelan (vijayj) 30-Oct-2000

Revision History:

    None

--*/

#include <iostream>
#include <string>
#include <exception>
#include <windows.h>
#include <winioctl.h>
#include <io.h>
#include <tchar.h>

//
// Usage format
//
std::wstring Usage(L"Usage: setactive.exe hardisk-number [partition-number]");


//
// Helper dump operators
//
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fwprintf(OutStream, str.c_str());
    return os;
}


//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;

        DWORD CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

        if (CharCount) {
            std::wstring Msg(MsgBuffer);

            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

//
// Invalid arguments
//
struct InvalidArguments : public ProgramException {
    const char *what() const throw() {
        return "Invalid Arguments";
    }

    void Dump(std::ostream &os) {
        os << what() << std::endl;
    }
};

//
// Invalid arguments
//
struct ProgramUsage : public ProgramException {
    std::wstring PrgUsage;

    ProgramUsage(const std::wstring &Usg) : PrgUsage(Usg) {}
    
    const char *what() const throw() {
        return "Program Usage exception";
    }

    void Dump(std::ostream &os) {
        os << Usage << std::endl;
    }
};

//
// Argument cracker
//
struct ProgramArguments {
    ULONG   DiskNumber;
    ULONG   PartitionNumber;
    BOOLEAN Set;

    ProgramArguments(int Argc, wchar_t *Argv[]) {
        Set = FALSE;
        
        if (Argc > 1) {
            DiskNumber = (ULONG)_ttol(Argv[1]);

            if (Argc > 2) {
                PartitionNumber = (ULONG)_ttol(Argv[2]);
                Set = TRUE;

                if (!PartitionNumber) {
                    throw new ProgramUsage(Usage);
                }                
            }            
        } else {
            throw new ProgramUsage(Usage);
        }
    }

    friend std::ostream operator<<(std::ostream &os, const ProgramArguments &Args) {
        os << "Arguments : DiskNumber = " 
           << std::dec << Args.DiskNumber << ", "
           << std::dec << Args.PartitionNumber << std::endl;

        return os;           
    }
};


//
// HardDisk abstraction
//
class W32HardDisk {
public:
    W32HardDisk(ULONG DiskNum) : DiskNumber(DiskNum), Dirty(FALSE) {
        WCHAR   DiskName[MAX_PATH];

        _stprintf(DiskName, TEXT("\\\\.\\PHYSICALDRIVE%d"), DiskNumber);
        
        DiskHandle = CreateFileW(DiskName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

        if (DiskHandle == INVALID_HANDLE_VALUE) {
            throw new W32Error(GetLastError());
        }

        DriveLayout = NULL;
        DriveLayoutSize = 0;

        GetPartitionInformation();
    }    

    virtual ~W32HardDisk() {
        if (IsDirty() && !CommitChanges()) {
            throw new W32Error(GetLastError());
        }

        delete []((PBYTE)(DriveLayout));

        CloseHandle(DiskHandle);
    }

    BOOLEAN IsDirty() const { return Dirty; }
    ULONG   GetPartitionCount() const { return DriveLayout->PartitionCount; }

    PARTITION_STYLE GetDiskStyle() const { 
        return (PARTITION_STYLE)(DriveLayout->PartitionStyle); 
    }

    const PARTITION_INFORMATION_EX* GetPartition(ULONG PartitionNumber) const {
        PPARTITION_INFORMATION_EX   PartInfo = NULL;
        
        for (ULONG Index = 0; Index < DriveLayout->PartitionCount; Index++) {
            PPARTITION_INFORMATION_EX CurrPartInfo = 
                                        DriveLayout->PartitionEntry + Index;

            if (CurrPartInfo->PartitionNumber == PartitionNumber) {
                PartInfo = CurrPartInfo;
                break;
            }
        }

        return PartInfo;
    }        

    BOOLEAN SetPartitionInfo(ULONG PartitionNumber, 
                const PARTITION_INFORMATION_EX &PartInformation) {        
        BOOLEAN Result = FALSE;
        PPARTITION_INFORMATION_EX   PartInfo = (PPARTITION_INFORMATION_EX)GetPartition(PartitionNumber);

        if (PartInfo) {
            *PartInfo = PartInformation;
            PartInfo->PartitionNumber = PartitionNumber;
            Dirty = Result = TRUE;
        }

        return Result;
    }

    const PARTITION_INFORMATION_EX* GetActivePartition(BOOLEAN Rescan = FALSE){
        if (Rescan) {
            GetPartitionInformation();
        }
        
        PPARTITION_INFORMATION_EX   ActivePartition = NULL;

        if (GetDiskStyle() == PARTITION_STYLE_MBR) {            
            for (ULONG Index = 0; Index < GetPartitionCount(); Index++) {
                PPARTITION_INFORMATION_EX PartInfo = DriveLayout->PartitionEntry + Index;

                if (PartInfo->Mbr.BootIndicator) {
                    ActivePartition = PartInfo;
                    break;
                }
            }
        }

        return ActivePartition;
    }

    BOOLEAN SetActivePartition(ULONG PartitionNumber) {
        BOOLEAN Result = FALSE;

        if (GetDiskStyle() == PARTITION_STYLE_MBR) {
            //
            // Set the give partition as active and turn off all the other
            // active bits on other partitions
            //
            const PARTITION_INFORMATION_EX *PartInfo = GetPartition(PartitionNumber);

            if (PartInfo) {
                //
                // NOTE : Does not check for primary partition
                //
                for (ULONG Index = 0; Index < GetPartitionCount(); Index++) {
                    PPARTITION_INFORMATION_EX PartInfo = (DriveLayout->PartitionEntry + Index);

                    if (PartInfo->PartitionNumber == PartitionNumber) {
                        Dirty = TRUE;
                        PartInfo->Mbr.BootIndicator = TRUE;
                        PartInfo->RewritePartition = TRUE;
                        Result = TRUE;
                    } else if (CanActivatePartition(*PartInfo)) {
                        PartInfo->Mbr.BootIndicator = FALSE;
                        PartInfo->RewritePartition = TRUE;
                        Dirty = TRUE;
                    }                        
                }                
            }
        }            

        if (Result) {
            Result = CommitChanges();

            if (!Result) {
                throw new W32Error(GetLastError());
            }                                
        }            

        return Result;
    }

protected:

    VOID GetPartitionInformation() {
        //
        // Allocate space for 128 partitions
        //
        DWORD ErrorStatus = ERROR_MORE_DATA;
        ULONG Iteration = 0;

        if (DriveLayout && DriveLayoutSize) {
            delete [](PBYTE)(DriveLayout);
        }
        
        do {
            Iteration++;
            DriveLayoutSize = sizeof(PARTITION_INFORMATION_EX) * (128 * Iteration) ;
            DriveLayout = (PDRIVE_LAYOUT_INFORMATION_EX) new BYTE[DriveLayoutSize];
            ZeroMemory(DriveLayout, DriveLayoutSize);

            if (DriveLayout) {
                DWORD   BytesReturned = 0;
                
                if (DeviceIoControl(DiskHandle,
                                    IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                    NULL,
                                    0,
                                    DriveLayout,
                                    DriveLayoutSize,
                                    &BytesReturned,
                                    NULL)) {
                    ErrorStatus = 0;
                } else {
                    ErrorStatus = GetLastError();
                }                    
            } else {
                throw new W32Error(GetLastError());
            }
        }
        while (ErrorStatus == ERROR_MORE_DATA);

        if (ErrorStatus) {
            throw new W32Error(GetLastError());
        }
    }

    //
    // Helper methods
    //
    BOOLEAN CanActivatePartition(const PARTITION_INFORMATION_EX &PartInfo) const {
        return (PartInfo.PartitionNumber && PartInfo.StartingOffset.QuadPart &&
                PartInfo.PartitionLength.QuadPart && 
                (GetDiskStyle() == PARTITION_STYLE_MBR) &&
                !IsContainerPartition(PartInfo.Mbr.PartitionType) &&
                IsRecognizedPartition(PartInfo.Mbr.PartitionType));
    }

    BOOLEAN CommitChanges() {
        DWORD   BytesReturned = 0;

        return DeviceIoControl(DiskHandle,
                    IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
                    DriveLayout,
                    DriveLayoutSize,
                    NULL,
                    0,
                    &BytesReturned,
                    NULL) ? TRUE : FALSE;
    }


    //
    // data members
    //    
    ULONG   DiskNumber;
    HANDLE  DiskHandle;
    BOOLEAN Dirty;
    
    ULONG                           DriveLayoutSize;
    PDRIVE_LAYOUT_INFORMATION_EX    DriveLayout;    
};


//
// main() entry point
//
int 
__cdecl
wmain(
    int         Argc,
    wchar_t     *Argv[]
    )
{
    int Result = 0;
    
    try {
        ProgramArguments    Args(Argc, Argv);        
        W32HardDisk         Disk(Args.DiskNumber);

        if (Args.Set) {
            Disk.SetActivePartition(Args.PartitionNumber);
        }        

        const PARTITION_INFORMATION_EX * ActivePart = Disk.GetActivePartition();

        if (ActivePart) {
            std::cout << std::dec << ActivePart->PartitionNumber 
                << " is the Active Partition on Disk " 
                << std::dec << Args.DiskNumber << std::endl;                    
        } else {
            std::cout << "No active partition on Disk " 
                << std::dec << Args.DiskNumber << std::endl;                    
        }
    }
    catch(ProgramException *PrgExp) {
        Result = 1;
        PrgExp->Dump(std::cout);
        delete PrgExp;
    } catch (exception *Exp) {
        Result = 1;
        std::cout << Exp->what() << std::endl;
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupcl\fileacl.c ===
/*++

File Description:

    This file contains the utility function used
    to go scan drives and examine the related
    ACLs.

Author:

    Matt Holle (matth) Feb 1998


--*/

//
// System header files
//
#include <nt.h>
// 
// Disable the DbgPrint for non-debug builds
//
#ifndef DBG
#define _DBGNT_
#endif
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <wtypes.h>

//
// CRT header files
//
#include <stdlib.h>

//
// Private header files
//
#include "setupcl.h"

NTSTATUS
DeleteUsnJournal(
    PWSTR    DrivePath
    );

NTSTATUS
ResetACLs(
    IN WCHAR    *DirName,
    ULONG       indent
    );

NTSTATUS
EnumerateDrives(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This function will enumerate all drives on the machine.  We're looking
    for NTFS volumes.  For each that we find, we'll go scan the drive and
    poke each directory and file for its ACLs.

Arguments:

Return Value:

    Status is returned.
===============================================================================
--*/
{
NTSTATUS            Status = STATUS_SUCCESS;
OBJECT_ATTRIBUTES   ObjectAttributes;
HANDLE              DosDevicesDir;
CHAR                DirInfoBuffer[2048],
                    LinkTargetBuffer[2048];
UNICODE_STRING      UnicodeString,
                    LinkTarget,
                    DesiredPrefix1,
                    DesiredPrefix2,
                    LinkTypeName;
POBJECT_DIRECTORY_INFORMATION DirInfo;
ULONG               Context,
                    Length;
HANDLE              Handle;
BOOLEAN             b;

    //
    // Open \DosDevices
    //
    RtlInitUnicodeString(&UnicodeString,L"\\DosDevices");
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_PERMANENT,
        NULL,
        NULL
        );

    Status = NtOpenDirectoryObject(&DosDevicesDir,DIRECTORY_QUERY,&ObjectAttributes);
    TEST_STATUS_RETURN( "SETUPCL: EnumerateDrives - Failed to open DosDevices." );

    LinkTarget.Buffer = (PVOID)LinkTargetBuffer;
    RtlInitUnicodeString(&LinkTypeName,L"SymbolicLink");
    RtlInitUnicodeString(&DesiredPrefix1,L"\\Device\\Harddisk");
    RtlInitUnicodeString(&DesiredPrefix2,L"\\Device\\Volume");

    DirInfo = (POBJECT_DIRECTORY_INFORMATION)DirInfoBuffer;

    b = TRUE;

    //
    // Query first object in \DosDevices directory
    //
    Status = NtQueryDirectoryObject( DosDevicesDir,
                                     DirInfo,
                                     sizeof(DirInfoBuffer),
                                     TRUE,
                                     TRUE,
                                     &Context,
                                     &Length );

    while(NT_SUCCESS(Status)) {

        //
        // Terminate these guys just in case...
        //
        DirInfo->Name.Buffer[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
        DirInfo->TypeName.Buffer[DirInfo->TypeName.Length/sizeof(WCHAR)] = 0;


        DbgPrint( "SETUPCL: EnumerateDrives - About to examine an object: %ws\n", DirInfo->Name.Buffer );

        //
        // Make sure he's a symbolic link.
        //
        // It's possible for two objects to link to the same device.  To
        // preclude following duplicate links, disallow any objects except
        // those that are a drive letter.  Crude but effective...
        //

        if( (DirInfo->Name.Buffer[1] == L':') &&
            (RtlEqualUnicodeString(&LinkTypeName,&DirInfo->TypeName,TRUE)) ) {

            DbgPrint( "\tSETUPCL: EnumerateDrives - Object: %ws is a symbolic link\n", DirInfo->Name.Buffer );

            InitializeObjectAttributes(
                &ObjectAttributes,
                &DirInfo->Name,
                OBJ_CASE_INSENSITIVE,
                DosDevicesDir,
                NULL
                );

            Status = NtOpenSymbolicLinkObject( &Handle,
                                               SYMBOLIC_LINK_ALL_ACCESS,
                                               &ObjectAttributes );
            if(NT_SUCCESS(Status)) {

                LinkTarget.Length = 0;
                LinkTarget.MaximumLength = sizeof(LinkTargetBuffer);

                Status = NtQuerySymbolicLinkObject( Handle,
                                                    &LinkTarget,
                                                    NULL );

                LinkTarget.Buffer[LinkTarget.Length/sizeof(WCHAR)] = 0;
                DbgPrint( "\tSETUPCL: EnumerateDrives - We queried him and his name is %ws.\n", LinkTarget.Buffer );
                NtClose(Handle);

                if( NT_SUCCESS(Status) &&
                    ( RtlPrefixUnicodeString(&DesiredPrefix1,&LinkTarget,TRUE) ||
                      RtlPrefixUnicodeString(&DesiredPrefix2,&LinkTarget,TRUE) ) ) {

                IO_STATUS_BLOCK     IoStatusBlock;
                UCHAR               buffer[4096];
                PFILE_FS_ATTRIBUTE_INFORMATION Info = (PFILE_FS_ATTRIBUTE_INFORMATION)buffer;
                OBJECT_ATTRIBUTES   Obja;

                    //
                    // OK, this is a symbolic link to a hard drive.
                    // Make sure it's 0-terminated.
                    //
                    LinkTarget.Buffer[LinkTarget.Length/sizeof(WCHAR)] = 0;

                    DbgPrint( "\tSETUPCL: EnumerateDrives - He's a drive.\n" );

                    //
                    // Is he an NTFS drive?  Open him and see.
                    //
                    InitializeObjectAttributes( &Obja,
                                                &LinkTarget,
                                                OBJ_CASE_INSENSITIVE,
                                                NULL,
                                                NULL );
                    Status = NtOpenFile( &Handle,
                                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                         &Obja,
                                         &IoStatusBlock,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         FILE_SYNCHRONOUS_IO_ALERT);

                    if( NT_SUCCESS(Status) ) {

                        Status = NtQueryVolumeInformationFile( Handle,
                                                               &IoStatusBlock,
                                                               buffer,
                                                               sizeof(buffer),
                                                               FileFsAttributeInformation );

                        if( NT_SUCCESS(Status) ) {
                            Info->FileSystemName[Info->FileSystemNameLength/sizeof(WCHAR)] = 0;
                            DbgPrint( "\tSETUPCL: EnumerateDrives - His file system is: %ws\n", Info->FileSystemName );
                            if( !_wcsicmp(Info->FileSystemName,L"NTFS") ) {
                                //
                                // He's NTFS.  Go whack the change journal, then
                                // scan this drive and fix up the ACLs.
                                //
                                DeleteUsnJournal( LinkTarget.Buffer );
                                
                                //
                                // ISSUE-2002/02/26-brucegr,jcohen - potential buffer overrun?
                                //
                                wcscat( LinkTarget.Buffer, L"\\" );

                                ResetACLs( LinkTarget.Buffer, 0 );
                            }
                        } else {
                            TEST_STATUS( "SETUPCL: EnumerateDrives - failed call to NtQueryVolumeInformationFile" );
                        }
                    } else {
                        TEST_STATUS( "SETUPCL: EnumerateDrives - Failed NtOpenFile on this drive" );
                    }

                    NtClose(Handle);
                }

            }
        }

        //
        // Query next object in \DosDevices directory
        //
        Status = NtQueryDirectoryObject( DosDevicesDir,
                                         DirInfo,
                                         sizeof(DirInfoBuffer),
                                         TRUE,
                                         FALSE,
                                         &Context,
                                         &Length );
    }

    NtClose(DosDevicesDir);

    return( STATUS_SUCCESS );
}


NTSTATUS
ResetACLs(
    IN WCHAR    *ObjectName,
    ULONG       indent
    )
/*++
===============================================================================
Routine Description:

    This function will go search a drive and inspect each file and directory
    for an ACL.  If found, it will look for, and replace, any ACL that
    contains the old SID with the new SID.

Arguments:

Return Value:

    Status is returned.
===============================================================================
--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   Obja;
    IO_STATUS_BLOCK     IoStatusBlock;
    HANDLE              Handle;
    PFILE_BOTH_DIR_INFORMATION DirectoryInfo;
    PWSTR               NewObjectName;
    DWORD               dwDirectoryInfoSize;
    BOOLEAN             bStartScan = TRUE,
                        bContinue  = TRUE;
    ULONG               i;

#if 0
    for( i = 0; i < indent; i++ )
        DbgPrint( " " );
     DbgPrint( "About to operate on a new object: %ws\n", ObjectName );
#endif
 
    DisplayUI();

    //
    // Open the file/directory and whack his ACL.
    //
    INIT_OBJA(&Obja, &UnicodeString, ObjectName);

    Status = NtOpenFile( &Handle,
                         READ_CONTROL | WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         0 );
    TEST_STATUS( "SETUPCL: ResetACLs - Failed to open file/directory." );

    Status = TestSetSecurityObject( Handle );

    TEST_STATUS( "SETUPCL: ResetACLs - Failed to reset ACL on file/directory." );

    NtClose( Handle );

    //
    // Now list the directory.
    //
    Status = NtOpenFile( &Handle,
                         FILE_LIST_DIRECTORY | SYNCHRONIZE,
                         &Obja,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT );

    //
    // Don't report this error because we'll fail if the handle points
    // to a file, which is quite possible and valid.  Just quietly return.
    //

    // TEST_STATUS_RETURN( "SETUPCL: ResetACLs - Failed to open file/directory for list access." );
    if( !NT_SUCCESS(Status) ) {
        return( STATUS_SUCCESS );
    }

    //
    // It is gruesome to have the allocation/deallocation of this inside
    // the while loop, but it saves a *lot* of stack space.  We aren't after
    // speed here.
    //
    dwDirectoryInfoSize = (MAX_PATH * 2) + sizeof(FILE_BOTH_DIR_INFORMATION);
    DirectoryInfo = (PFILE_BOTH_DIR_INFORMATION)RtlAllocateHeap( RtlProcessHeap(),
                                                                 0,
                                                                 dwDirectoryInfoSize );

    if ( NULL == DirectoryInfo )
    {
        bContinue = FALSE;
    }

    while( bContinue ) 
    {
        Status = NtQueryDirectoryFile( Handle,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       DirectoryInfo,
                                       dwDirectoryInfoSize,
                                       FileBothDirectoryInformation,
                                       TRUE,
                                       NULL,
                                       bStartScan );

        if ( NT_SUCCESS( Status ) ) 
        {
            //
            // Make sure the scan doesn't get restarted...
            //
            bStartScan = FALSE;

            //
            // Terminate the name, just in case.
            //
            DirectoryInfo->FileName[DirectoryInfo->FileNameLength/sizeof(WCHAR)] = 0;
        }
        else
        {
            if ( STATUS_NO_MORE_FILES == Status )
            {
                Status = STATUS_SUCCESS;
            }
            else
            {
                PRINT_STATUS( "SETUPCL: ResetACLs - Failed to query directory." );
            }

            //
            // We want to exit the loop...
            //
            bContinue = FALSE;
        }

        //
        // We can't really do anything with encrypted files...
        //
        if ( bContinue &&
             ( ( !(DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                 !(DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ) ||
               //
               // Don't recurse into the "." and ".." directories...
               //
               ( (DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                 ( (wcscmp( DirectoryInfo->FileName, L"."  )) &&
                   (wcscmp( DirectoryInfo->FileName, L".." )) ) ) ) )
        {
            //
            // Calculate the maximum buffer size we need to allocate...
            // We need to factor in 4 things: 1) the current object
            //                                2) the directory name
            //                                3) a possible backslash
            //                                4) the null terminator
            //
            DWORD dwObjectLength    = wcslen(ObjectName),
                  dwNewObjectLength = dwObjectLength + (DirectoryInfo->FileNameLength / sizeof(WCHAR)) + 2;

            //
            // Build the name of the new object.
            //
            NewObjectName = (PWSTR)RtlAllocateHeap( RtlProcessHeap(),
                                                    0,
                                                    dwNewObjectLength * sizeof(WCHAR) );
            //
            // Make sure the allocation succeeded...
            //
            if ( NewObjectName )
            {
                memset( NewObjectName, 0, dwNewObjectLength * sizeof(WCHAR) );
                wcsncpy( NewObjectName, ObjectName, dwNewObjectLength - 1 );

                //
                // If there's not an ending backslash, append one...
                // Note: we've already accounted for this possible backslash in the buffer allocation...
                //
                if ( ObjectName[dwObjectLength - 1] != L'\\' )
                {
                    wcscat( NewObjectName, L"\\" );
                }

                //
                // Append the FileName buffer onto our NewObjectName buffer...
                // Note: we've already accounted for the filename length in the buffer allocation...
                //
                wcscat( NewObjectName, DirectoryInfo->FileName );

                //
                // Call ourselves on the new object.
                //
                ResetACLs( NewObjectName, indent + 1 );

                RtlFreeHeap( RtlProcessHeap(),
                             0,
                             NewObjectName );
            }
            else
            {
                PRINT_STATUS( "SETUPCL: ResetACLs - Failed to allocate NewObjectName buffer." );

                bContinue = FALSE;
            }
        }
    }

    //
    // Free the DirectoryInfo pointer...
    //
    if ( DirectoryInfo )
    {
        RtlFreeHeap( RtlProcessHeap(),
                     0,
                     DirectoryInfo );
    }

    NtClose( Handle );

    return( Status );
}


NTSTATUS
DeleteUsnJournal(
    PWSTR    DrivePath
    )
/*++
===============================================================================
Routine Description:

    This function will remove the Change Journal on NTFS partitions.

Arguments:

    DriveLetter     Supplies the drive letter of the partition we'll be
                    operating on.

Return Value:

    Status is returned.
===============================================================================
--*/
{
NTSTATUS            Status = STATUS_SUCCESS;
UNICODE_STRING      UnicodeString;
OBJECT_ATTRIBUTES   ObjectAttributes;
HANDLE              FileHandle;
IO_STATUS_BLOCK     IoStatusBlock;
PUSN_JOURNAL_DATA   OutputBuffer = NULL;
PDELETE_USN_JOURNAL_DATA InputBuffer = NULL;
ULONG               OutputBufferSize, InputBufferSize;

    //
    // Build the volume name, then open it.
    //
    INIT_OBJA( &ObjectAttributes,
               &UnicodeString,
               DrivePath );
    Status = NtOpenFile( &FileHandle,
                         SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_ALERT);

    TEST_STATUS_RETURN( "SETUPCL: DeleteUsnJournal - Failed to open volume." );

    //
    // Allocate buffers for the query and delete operation.
    //
    OutputBufferSize = sizeof(USN_JOURNAL_DATA);
    OutputBuffer = (PUSN_JOURNAL_DATA)RtlAllocateHeap( RtlProcessHeap(),
                                                       0,
                                                       sizeof(USN_JOURNAL_DATA) );

    InputBufferSize = sizeof(DELETE_USN_JOURNAL_DATA);
    InputBuffer = (PDELETE_USN_JOURNAL_DATA)RtlAllocateHeap( RtlProcessHeap(),
                                                             0,
                                                             sizeof(DELETE_USN_JOURNAL_DATA) );

    if( !(OutputBuffer && InputBuffer) ) {
        DbgPrint( "SETUPCL: DeleteUsnJournal - Failed to allocate buffers.\n" );
        //
        // ISSUE-2002/02/26-brucegr,jcohen - Leaks Input or Output buffers and FileHandle!
        //
        return( STATUS_UNSUCCESSFUL );
    }

    Status = NtFsControlFile( FileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatusBlock,
                              FSCTL_QUERY_USN_JOURNAL,
                              NULL,
                              0,
                              OutputBuffer,
                              OutputBufferSize );
    TEST_STATUS( "SETUPCL: DeleteUsnJournal - Failed to query journal." );

    if( NT_SUCCESS( Status ) ) {
        //
        // Now delete him.
        //

        InputBuffer->DeleteFlags = USN_DELETE_FLAG_DELETE;
        InputBuffer->UsnJournalID = OutputBuffer->UsnJournalID;

        Status = NtFsControlFile( FileHandle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_DELETE_USN_JOURNAL,
                                  InputBuffer,
                                  InputBufferSize ,
                                  NULL,
                                  0 );

        TEST_STATUS( "SETUPCL: DeleteUsnJournal - Failed to delete journal." );
    }

    NtClose( FileHandle );

    RtlFreeHeap( RtlProcessHeap(),
                 0,
                 OutputBuffer );

    RtlFreeHeap( RtlProcessHeap(),
                 0,
                 InputBuffer );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupcl\setupcl.c ===
/*++

File Description:

    This file contains the driver functions to modify the
    domain SID on a machine.

Author:

    Matt Holle (matth) Oct 1997


--*/

//
// System header files
//
#include <nt.h>

// 
// Disable the DbgPrint for non-debug builds
//
#ifndef DBG
#define _DBGNT_
#endif
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <wtypes.h>
#include <ntddksec.h>

#ifdef IA64
#include <winioctl.h>
#include <efisbent.h>

#if defined(EFI_NVRAM_ENABLED)
#include <efi.h>
#include <efiapi.h>
#endif             
#endif

//
// CRT header files
//
#include <stdlib.h>
#include <stdio.h>

//
// Private header files
//
#include "setupcl.h"
#include "msg.h"

#ifdef IA64

// Seed for GUID generator function:
//
// This is initialized first at the beginning of main() with the NtQuerySystemTime()
// and then is updated every time the CreateNewGuid function is called.
// We use the system time at the time CreateNewGuid is called for another part of the GUID.
// This is done so that we achieve some variability accross machines, as the time delta between
// calls to NtQuerySystemTime() should be somewhat different accross machines and invocations of 
// this program.
// 
ULONG RandomSeed;

#endif

// Start time for setupcl.  This is used so we can display a UI if setupcl takes longer than 15 seconds to 
// complete. Note that the checks for time only happen in the recursive function calls so if a step is added
// to setupcl that takes a considerable amount of time DisplayUI() should be called as part of that step as well.
//

LARGE_INTEGER StartTime;
LARGE_INTEGER CurrentTime;
LARGE_INTEGER LastDotTime;  // For putting up dots every few seconds.

BOOL bDisplayUI = FALSE;    // Initially don't display the UI.

NTSTATUS
ProcessHives(
    VOID
    );

NTSTATUS
FinalHiveCleanup(
    VOID
    );

NTSTATUS
ProcessRepairHives(
    VOID
    );

NTSTATUS
RetrieveOldSid(
    VOID
    );

NTSTATUS
GenerateUniqueSid(
    IN  DWORD Seed
    );


NTSTATUS
ProcessHives(
    VOID
    )
/*++
===============================================================================
Routine Description:

    This function check keys (and all subkeys) for:
    - keys with the old SID name
    - value keys with the old SID value

Arguments:

    None.

Return Value:

    NTSTATUS.

===============================================================================
--*/
{
ULONG       i;
NTSTATUS    Status;
PWSTR       KeysToWhack[] = {
                    //
                    // SAM hive...
                    //
                    L"\\REGISTRY\\MACHINE\\SAM\\SAM",

                    //
                    // Security hive...
                    //
                    L"\\REGISTRY\\MACHINE\\SECURITY",

                    //
                    // Software hive...
                    //
                    L"\\REGISTRY\\MACHINE\\SOFTWARE",

                    //
                    // System hive...
                    //
                    L"\\REGISTRY\\MACHINE\\SYSTEM",

                };
LARGE_INTEGER   Start_Time, End_Time;

    //
    // Record our start time.
    //
    NtQuerySystemTime( &Start_Time );

    for( i = 0; i < sizeof(KeysToWhack) / sizeof(PWSTR); i++ ) {

        DbgPrint( "\nSETUPCL: ProcessHives - About to process %ws\n", KeysToWhack[i] );

        Status = SiftKey( KeysToWhack[i] );
        TEST_STATUS( "SETUPCL: ProcessHives - Failed to process key..." );
    }

    //
    // Record our end time.
    //
    NtQuerySystemTime( &End_Time );

    //
    // Record our execution time.
    //
    End_Time.QuadPart = End_Time.QuadPart - Start_Time.QuadPart;
#if 0
    Status = SetKey( TEXT(REG_SYSTEM_SETUP),
                     TEXT("SetupCL_Run_Time"),
                     (PUCHAR)&End_Time.LowPart,
                     sizeof( DWORD ),
                     REG_DWORD );
#endif
    return( Status );

}

NTSTATUS
FinalHiveCleanup(
    VOID
    )
/*++
===============================================================================
Routine Description:

    This function will go load each user-specific hive on the machine and
    propogate the new SID into it.

Arguments:

    None.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
    NTSTATUS            Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      UnicodeString,
                        UnicodeValue;
    HANDLE              hKey, hKeyChild;
    ULONG               ResultLength,
                        KeyValueLength,
                        Index,
                        LengthNeeded;
    PKEY_BASIC_INFORMATION  KeyInfo;
    WCHAR               KeyBuffer[BASIC_INFO_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo = NULL;


    //
    // ========================
    // User Profile Hives
    // ========================
    //
    DbgPrint( "\nAbout to operate on user-specific profile hives.\n" );

    //
    // We need to go check the user profile hives out on the disk.
    // If we find any, we need to change his ACLs to reflect the new
    // SID.
    //

    //
    // Open the PROFILELIST key.
    //
    INIT_OBJA( &Obja, &UnicodeString, TEXT( REG_SOFTWARE_PROFILELIST ) );
    Status = NtOpenKey( &hKey,
                        KEY_ALL_ACCESS,
                        &Obja );
    TEST_STATUS( "SETUPCL: FinalHiveCleanup - Failed to open PROFILELIST key." );

    KeyInfo = (PKEY_BASIC_INFORMATION)KeyBuffer;
    //
    // Now enumerate all his subkeys and see if any of them have a
    // ProfileImagePath key.
    //
    for( Index = 0; ; Index++ ) {
        
        // Local variable.
        //
        DWORD dwPass;
        PWCHAR lpszHiveName[] = { 
                                 L"\\NTUSER.DAT",
                                 L"\\Local Settings\\Application Data\\Microsoft\\Windows\\UsrClass.dat"
                                };

        Status = NtEnumerateKey( hKey,
                                 Index,
                                 KeyBasicInformation,
                                 KeyInfo,
                                 sizeof(KeyBuffer),
                                 &ResultLength );

        if(!NT_SUCCESS(Status)) {
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            } else {
                TEST_STATUS( "SETUPCL: FinalHiveCleanup - Failure during enumeration of subkeys." );
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;
        DbgPrint( "SETUPCL: FinalHiveCleanup - enumerated %ws\n", KeyInfo->Name );

        //
        // Generate a handle for this child key and open him too.
        //
        INIT_OBJA( &Obja, &UnicodeString, KeyInfo->Name );
        Obja.RootDirectory = hKey;
        Status = NtOpenKey( &hKeyChild,
                            KEY_ALL_ACCESS,
                            &Obja );
        //
        // ISSUE-2002/02/26-brucegr,jcohen - If NtOpenKey fails, hKey is leaked
        //
        TEST_STATUS_RETURN( "SETUPCL: FinalHiveCleanup - Failed to open child key." );

        //
        // Now get the ProfileImagePath value.
        //
        RtlInitUnicodeString( &UnicodeString, TEXT( PROFILEIMAGEPATH ) );

        //
        // How big of a buffer do we need?
        //
        Status = NtQueryValueKey( hKeyChild,
                                  &UnicodeString,
                                  KeyValuePartialInformation,
                                  NULL,
                                  0,
                                  &LengthNeeded );

        //
        // ISSUE-2002/02/26-brucegr,jcohen - Check for STATUS_SUCCESS, not assume success on STATUS_OBJECT_NAME_NOT_FOUND
        //
        if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            DbgPrint( "SETUPCL: FinalHiveCleanup - Unable to query key %ws size.  Error (%lx)\n", TEXT( PROFILEIMAGEPATH ), Status );
        } else {
            Status = STATUS_SUCCESS;
        }

        //
        // Allocate a block.
        //
        if( NT_SUCCESS( Status ) ) {
            if( KeyValueInfo ) {
                RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInfo );
                KeyValueInfo = NULL;
            }

            KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)RtlAllocateHeap( RtlProcessHeap(),
                                                                            0,
                                                                            LengthNeeded + 0x10 );

            if( KeyValueInfo == NULL ) {
                DbgPrint( "SETUPCL: FinalHiveCleanup - Unable to allocate buffer\n" );
                Status = STATUS_NO_MEMORY;
            }
        }

        //
        // Get the data.
        //
        if( NT_SUCCESS( Status ) ) {
            Status = NtQueryValueKey( hKeyChild,
                                      &UnicodeString,
                                      KeyValuePartialInformation,
                                      (PVOID)KeyValueInfo,
                                      LengthNeeded,
                                      &KeyValueLength );
            if( !NT_SUCCESS( Status ) ) {
                DbgPrint( "SETUPCL: FinalHiveCleanup - Failed to query key %ws (%lx)\n", TEXT( PROFILEIMAGEPATH ), Status );
            }
        }
        NtClose( hKeyChild );
        
        //
        // Do two passes.  First pass will be for the NTUSER.DAT hive and the second will be for
        // UsrClass.dat hive.
        //
        for ( dwPass = 0; dwPass < AS(lpszHiveName); dwPass++ ) {
            
            if( NT_SUCCESS( Status ) ) {
                PWCHAR      TmpChar;
                ULONG       i;

                memset( TmpBuffer, 0, sizeof(TmpBuffer) );
                wcsncpy( TmpBuffer, (PWCHAR)&KeyValueInfo->Data, AS(TmpBuffer) - 1);

                //
                // We've got the path to the profile hive, but it will contain
                // an environment variable.  Expand the variable.
                //
                DbgPrint( "SETUPCL: FinalHiveCleanup - Before the expand, I think his ProfileImagePath is: %ws\n", TmpBuffer );

                RtlInitUnicodeString( &UnicodeString, TmpBuffer );

                UnicodeValue.Length = 0;
                UnicodeValue.MaximumLength = MAX_PATH * sizeof(WCHAR);
                UnicodeValue.Buffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(), 0, UnicodeValue.MaximumLength );

                //
                // Prefix Bug # 111373.
                //
                if ( UnicodeValue.Buffer )
                {
                    RtlZeroMemory( UnicodeValue.Buffer, UnicodeValue.MaximumLength );
                    Status = RtlExpandEnvironmentStrings_U( NULL, &UnicodeString, &UnicodeValue, NULL );

                    //
                    // RtlExpandEnvironmentStrings_U has given us a path, but
                    // it will contain a drive letter.  We need an NT path.
                    // Go convert it.
                    //
                    if( NT_SUCCESS( Status ) && 
                        ( (UnicodeValue.Length + (wcslen(lpszHiveName[dwPass]) * sizeof(WCHAR))) < sizeof(TmpBuffer) ) ) 
                    {
                        WCHAR   DriveLetter[3];
                        WCHAR   NTPath[MAX_PATH] = {0};

                        //
                        // TmpBuffer will contain the complete path, except
                        // he's got the drive letter.
                        //
                        RtlCopyMemory( TmpBuffer, UnicodeValue.Buffer, UnicodeValue.Length );
                        TmpBuffer[(UnicodeValue.Length / sizeof(WCHAR))] = 0;
                        wcscat( TmpBuffer, lpszHiveName[dwPass] );
                        DbgPrint( "SETUPCL: FinalHiveCleanup - I think the dospath to his ProfileImagePath is: %ws\n", TmpBuffer );


                        DriveLetter[0] = TmpBuffer[0];
                        DriveLetter[1] = L':';
                        DriveLetter[2] = 0;

                        //
                        // Get the symbolic link from the drive letter.
                        //
                        Status = DriveLetterToNTPath( DriveLetter[0], NTPath, AS(NTPath) );

                        if( NT_SUCCESS( Status ) ) {
                            //
                            // Translation was successful.  Insert the ntpath into our
                            // path to the profile.
                            //
                            Status = StringSwitchString( TmpBuffer, AS(TmpBuffer), DriveLetter, NTPath );
                        } else {
                            DbgPrint( "SETUPCL: FinalHiveCleanup - We failed our call to DriveLetterToNTPath (%lx)\n", Status );
                        }

                        DbgPrint( "SETUPCL: FinalHiveCleanup - After the expand, I think his ProfileImagePath is: %ws\n", TmpBuffer );
                    } else {
                        DbgPrint( "SETUPCL: FinalHiveCleanup - We failed our call to RtlExpandEnvironmentStrings_U (%lx)\n", Status );
                    }

                    RtlFreeHeap( RtlProcessHeap(),
                                 0,
                                 UnicodeValue.Buffer );
                }

                //
                // Attempt to load the hive, open his root key, then
                // go swap ACLs on all the subkeys.
                //
                Status = LoadUnloadHive( TEXT( TMP_HIVE_NAME ),
                                         TmpBuffer );
                if( NT_SUCCESS( Status ) ) {


                    //
                    // Let's go search for any instance of the SID in our
                    // newly loaded hive.
                    //
                    Status = SiftKey( TEXT( TMP_HIVE_NAME ) );
                    TEST_STATUS( "SETUPCL: FinalHiveCleanup - Failed to push new sid into user's hive." );


    #if 0
                    //
                    // Move call to SetKeySecurityRecursive into
                    // SiftKey so that implicitly fixup ACLs too.
                    //



                    //
                    // Open the root of our newly loaded hive.
                    //
                    INIT_OBJA( &Obja, &UnicodeString, TEXT( TMP_HIVE_NAME ) );
                    Status = NtOpenKey( &hKeyChild,
                                        KEY_ALL_ACCESS,
                                        &Obja );

                    //
                    // Now go attempt to whack the ACLs on this, and
                    // all subkeys.
                    //
                    if( NT_SUCCESS( Status ) ) {
                        SetKeySecurityRecursive( hKeyChild );

                        NtClose( hKeyChild );
                    } else {
                        DbgPrint( "SETUPCL: FinalHiveCleanup - Failed open of TmpHive root.\n" );
                    }
    #endif

                    LoadUnloadHive( TEXT( TMP_HIVE_NAME ),
                                    NULL );

                } else {
                    DbgPrint( "SETUPCL: FinalHiveCleanup - Failed load of TmpHive.\n" );
                }
            }
        }
    }

    NtClose( hKey );

    //
    // ========================
    // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\CONTROL\REGISTRYSIZELIMIT
    // ========================
    //
    DbgPrint( "\nAbout to operate on SYSTEM\\CURRENTCONTROLSET\\CONTROL\\REGISTRYSIZELIMIT.\n" );

    //
    // sysprep bumped the registry limit up by 4Mb.  We need to lower it
    // back down.
    //

    INIT_OBJA( &Obja,
               &UnicodeString,
               TEXT(REG_SYSTEM_CONTROL) );
    Status = NtOpenKey( &hKey,
                         KEY_ALL_ACCESS,
                        &Obja );
    TEST_STATUS( "SETUPCL: ProcessSYSTEMHive - Failed to open Control key!" );

    //
    // ISSUE-2002/02/26-brucegr,jcohen - Shouldn't try to query value if NtOpenKey fails!
    //

    //
    // Get the data out of this key.
    //
    RtlInitUnicodeString(&UnicodeString, TEXT(REG_SIZE_LIMIT) );

    //
    // How big of a buffer do we need?
    //
    Status = NtQueryValueKey( hKey,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              NULL,
                              0,
                              &LengthNeeded );

    //
    // ISSUE-2002/02/26-brucegr,jcohen - Check for STATUS_SUCCESS, not assume success on STATUS_OBJECT_NAME_NOT_FOUND
    //
    if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        DbgPrint( "SETUPCL: FinalHiveCleanup - Unable to query key %ws size.  Error (%lx)\n", TEXT(REG_SIZE_LIMIT), Status );
    } else {
        Status = STATUS_SUCCESS;
    }

    //
    // Allocate a block.
    //
    if( NT_SUCCESS( Status ) ) {
        if( KeyValueInfo ) {
            RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInfo );
            KeyValueInfo = NULL;
        }

        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)RtlAllocateHeap( RtlProcessHeap(),
                                                                        0,
                                                                        LengthNeeded + 0x10 );

        if( KeyValueInfo == NULL ) {
            DbgPrint( "SETUPCL: FinalHiveCleanup - Unable to allocate buffer\n" );
            Status = STATUS_NO_MEMORY;
        }
    }

    //
    // Get the data.
    //
    if( NT_SUCCESS( Status ) ) {
        Status = NtQueryValueKey( hKey,
                                  &UnicodeString,
                                  KeyValuePartialInformation,
                                  (PVOID)KeyValueInfo,
                                  LengthNeeded,
                                  &KeyValueLength );
        if( !NT_SUCCESS( Status ) ) {
            DbgPrint( "SETUPCL: FinalHiveCleanup - Failed to query key %ws (%lx)\n", TEXT(REG_SIZE_LIMIT), Status );
        }
        else{
            Index = *(PDWORD)(&KeyValueInfo->Data);
            Index = Index - REGISTRY_QUOTA_BUMP; //Bring it back to original value

            //
            // Set him.
            //
            Status = SetKey( TEXT(REG_SYSTEM_CONTROL),
                             TEXT(REG_SIZE_LIMIT),
                             (PUCHAR)&Index,
                             sizeof( DWORD ),
                             REG_DWORD );
            DbgPrint("SETUPCL: ProcessSYSTEMHive - Size allocated = %lx\n",Index);
            TEST_STATUS( "SETUPCL: ProcessSYSTEMHive - Failed to update SYSTEM\\CURRENTCONTROLSET\\CONTROL\\REGISTRYSIZELIMIT key." );

        }
    }
    NtClose( hKey );

    //
    // ========================
    // \REGISTRY\MACHINE\SYSTEM\CURRENTCONTROLSET\Control\Session Manager\SetupExecute
    // ========================
    //
    DbgPrint( "\nAbout to operate on SYSTEM\\CURRENTCONTROLSET\\CONTROL\\SESSION MANAGER\\SETUPEXECUTE key.\n" );

    //
    // Open the Session manager key.
    //
    INIT_OBJA( &Obja,
               &UnicodeString,
               TEXT(REG_SYSTEM_SESSIONMANAGER) );
    Status = NtOpenKey( &hKey,
                         KEY_ALL_ACCESS,
                        &Obja );
    TEST_STATUS_RETURN( "SETUPCL: ProcessSYSTEMHive - Failed to open Session Manager key!" );

    //
    // Now delete the SetupExecute Key.
    //
    RtlInitUnicodeString(&UnicodeString, TEXT(EXECUTE) );
    Status = NtDeleteValueKey( hKey, &UnicodeString );
    NtClose( hKey );
    TEST_STATUS( "SETUPCL: ProcessSYSTEMHive - Failed to update SYSTEM\\CURRENTCONTROLSET\\CONTROL\\SESSION MANAGER\\SETUPEXECUTE key." );

    if( KeyValueInfo ) {
        RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInfo );
        KeyValueInfo = NULL;
    }

    return Status;
}







NTSTATUS
ProcessRepairHives(
    VOID
    )
/*++
===============================================================================
Routine Description:

    This function check keys (and all subkeys) for:
    - keys with the old SID name
    - value keys with the old SID value

Arguments:

    None.

Return Value:

    NTSTATUS.

===============================================================================
--*/
{
ULONG       i;
NTSTATUS    Status;
PWSTR       KeysToWhack[] = {
                    //
                    // SAM hive...
                    //
                    L"\\REGISTRY\\MACHINE\\RSAM",

                    //
                    // Security hive...
                    //
                    L"\\REGISTRY\\MACHINE\\RSECURITY",

                    //
                    // Software hive...
                    //
                    L"\\REGISTRY\\MACHINE\\RSOFTWARE",

                    //
                    // System hive...
                    //
                    L"\\REGISTRY\\MACHINE\\RSYSTEM",

                };


PWSTR       KeysToLoad[] = {
                    //
                    // SAM hive...
                    //
                    L"\\SYSTEMROOT\\REPAIR\\SAM",

                    //
                    // Security hive...
                    //
                    L"\\SYSTEMROOT\\REPAIR\\SECURITY",

                    //
                    // Software hive...
                    //
                    L"\\SYSTEMROOT\\REPAIR\\SOFTWARE",

                    //
                    // System hive...
                    //
                    L"\\SYSTEMROOT\\REPAIR\\SYSTEM",

                };



    for( i = 0; i < sizeof(KeysToWhack) / sizeof(PWSTR); i++ ) {

        //
        // Load the repair hive.
        //
        DbgPrint( "\nSETUPCL: ProcessRepairHives - About to load %ws hive.\n", KeysToLoad[i] );

        Status = LoadUnloadHive( KeysToWhack[i],
                                 KeysToLoad[i] );
        TEST_STATUS_RETURN( "SETUPCL: ProcessRepairHives - Failed to load repair hive." );

        //
        // Now operate on it.
        //
        DbgPrint( "SETUPCL: ProcessRepairHives - About to process %ws\n", KeysToWhack[i] );

        Status = SiftKey( KeysToWhack[i] );

        TEST_STATUS( "SETUPCL: ProcessRepairHives - Failed to process key..." );

        //
        // Unload the hive.
        //
        DbgPrint( "SETUPCL: ProcessRepairHives - About to unload %ws hive.\n", KeysToLoad[i] );

        Status = LoadUnloadHive( KeysToWhack[i],
                                 NULL );
        TEST_STATUS( "SETUPCL: ProcessRepairHives - Failed to unload repair hive." );
    }

    return( Status );

}


NTSTATUS
RetrieveOldSid(
    VOID
    )
/*++
===============================================================================
Routine Description:

    Retrieves the current SID (as read from the registry.

    Use RtlFreeSid() to free the SID allocated by this routine.

Arguments:

Return Value:

    Status code indicating outcome.
===============================================================================
--*/
{
    NTSTATUS        Status;
    HANDLE          hKey;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING  UnicodeString;
    ULONG           KeyValueLength,
                    LengthNeeded;
    UNICODE_STRING  SidString;


    //
    // We can conveniently retrieve our SID from
    // \registry\machine\Security\Policy\PolAcDmS\<No Name>
    //
    // We'll open him up, read his data, then blast that into
    // a SID structure.
    //

    //
    // Open the PolAcDmS key.
    //
    INIT_OBJA( &ObjectAttributes, &UnicodeString, TEXT(REG_SECURITY_POLACDMS) );
    Status = NtOpenKey( &hKey,
                        KEY_ALL_ACCESS,
                        &ObjectAttributes );
    TEST_STATUS_RETURN( "SETUPCL: RetrieveOldSid - Failed to open PolAcDmS key!" );

    //
    // Get the data out of this key.
    //
    RtlInitUnicodeString(&UnicodeString, TEXT("") );

    //
    // How big of a buffer do we need?
    //
    Status = NtQueryValueKey( hKey,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              NULL,
                              0,
                              &LengthNeeded );

    //
    // ISSUE-2002/02/26-brucegr,jcohen - Check for STATUS_SUCCESS, not assume success on STATUS_OBJECT_NAME_NOT_FOUND
    //
    if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        DbgPrint( "SETUPCL: RetrieveOldSid - Unable to query size of old sid.  Error (%lx)\n", Status );
    } else {
        Status = STATUS_SUCCESS;
    }

    //
    // Allocate a block.
    //
    if( NT_SUCCESS( Status ) ) {
        //
        // ISSUE-2002/02/26-brucegr,jcohen - This block will never get hit
        //
        if( KeyValueInfo ) {
            RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInfo );
            KeyValueInfo = NULL;
        }

        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)RtlAllocateHeap( RtlProcessHeap(),
                                                                        0,
                                                                        LengthNeeded + 0x10 );

        if( KeyValueInfo == NULL ) {
            DbgPrint( "SETUPCL: RetrieveOldSid - Unable to allocate buffer\n" );
            Status = STATUS_NO_MEMORY;
        }
    }

    //
    // Get the data.
    //
    if( NT_SUCCESS( Status ) ) {
        Status = NtQueryValueKey( hKey,
                                  &UnicodeString,
                                  KeyValuePartialInformation,
                                  (PVOID)KeyValueInfo,
                                  LengthNeeded,
                                  &KeyValueLength );
        if( !NT_SUCCESS( Status ) ) {
            DbgPrint( "SETUPCL: RetrieveOldSid - Failed to query old sid key (%lx)\n", Status );
        }
    }


    TEST_STATUS_RETURN( "SETUPCL: RetrieveOldSid - Failed to query PolAcDmS key!" );

    //
    // Allocate space for our new SID.
    //
    G_OldSid = RtlAllocateHeap( RtlProcessHeap(), 0,
                              SID_SIZE );
    if( G_OldSid == NULL ) {
        DbgPrint( "SETUPCL: Call to RtlAllocateHeap failed!\n" );
        return( STATUS_NO_MEMORY );
    }


    //
    // Blast our Old SID into the memory we just allocated...
    //
    RtlCopyMemory( G_OldSid, ((PUCHAR)&KeyValueInfo->Data), SID_SIZE );

    //
    // ISSUE-2002/02/26-brucegr,jcohen - Close the key sooner!
    //
    NtClose( hKey );

    //
    // I need to get a text version of the 3 values that make
    // up this SID's uniqueness.  This is pretty gross.  It turns
    // out that the first 8 characters of the SID string (as gotten
    // from a call to RtlConvertSidtoUnicodeString) are the same
    // for any Domain SID.  And it's always the 9th character that
    // starts the 3 unique numbers.
    //
    Status = RtlConvertSidToUnicodeString( &SidString, G_OldSid, TRUE );
    TEST_STATUS_RETURN( "SETUPCL: RetrieveOldSid - RtlConvertSidToUnicodeString failed!" );
    memset( G_OldSidSubString, 0, sizeof(G_OldSidSubString) );
    wcsncpy( G_OldSidSubString, &SidString.Buffer[9], AS(G_OldSidSubString) - 1 );

#ifdef DBG
    //
    // Debug spew.
    //
    {
        int i;

        DbgPrint( "SETUPCL: RetrieveOldSid - Retrieved SID:\n" );
        for( i = 0; i < SID_SIZE; i += 4 ) {
            DbgPrint( "%08lx   ", *(PULONG)((PUCHAR)(G_OldSid) + i));
        }
        DbgPrint( "\n" );

        DbgPrint("Old Sid = %ws \n",SidString.Buffer);
    }
#endif

    RtlFreeUnicodeString( &SidString );

    //
    // ISSUE-2002/02/26-brucegr,jcohen - Free the value buffer sooner?  Do we need to assign KeyValueInfo to NULL after we're done with it?
    //
    if( KeyValueInfo ) {
        RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInfo );
        KeyValueInfo = NULL;
    }

    return( STATUS_SUCCESS );
}

BOOL
SetupGenRandom(
    OUT    PVOID pbRandomKey,
    IN     ULONG cbRandomKey
    )
{
    BOOL              fRet = FALSE;
    HANDLE            hFile;
    NTSTATUS          Status;
    UNICODE_STRING    DriverName;
    IO_STATUS_BLOCK   IOSB;
    OBJECT_ATTRIBUTES ObjA;

    //
    // have to use the Nt flavor of the file open call because it's a base
    // device not aliased to \DosDevices
    //
    RtlInitUnicodeString( &DriverName, DD_KSEC_DEVICE_NAME_U );
    InitializeObjectAttributes( &ObjA,
                                &DriverName,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );

    Status = NtOpenFile( &hFile,
                         SYNCHRONIZE | FILE_READ_DATA,
                         &ObjA,
                         &IOSB,
                         FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         FILE_SYNCHRONOUS_IO_ALERT );

    if ( NT_SUCCESS(Status) )
    {
        Status = NtDeviceIoControlFile( hFile,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IOSB,
                                        IOCTL_KSEC_RNG_REKEY,   // indicate a RNG rekey
                                        NULL,                   // input buffer (existing material)
                                        0,                      // input buffer size
                                        pbRandomKey,            // output buffer
                                        cbRandomKey );          // output buffer size

        if ( NT_SUCCESS(Status) )
        {
            fRet = TRUE;
        }
        else
        {
            PRINT_STATUS( "SetupGenRandom: NtDeviceIoControlFile failed!" );
        }

        NtClose( hFile );
    }
    else
    {
        PRINT_STATUS( "SetupGenRandom: NtOpenFile failed!" );
    }

    return fRet;
}

NTSTATUS
SetupGenerateRandomDomainSid(
    OUT PSID NewDomainSid
    )
/*++

Routine Description:

    This function will generate a random sid to be used for the new account domain sid during
    setup.

Arguments:

    NewDomainSid - Where the new domain sid is returned.  Freed via RtlFreeSid()


Return Values:

    STATUS_SUCCESS -- Success.
    STATUS_INVALID_PARAMETER -- We couldn't generate a random number
    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    ULONG    SubAuth1, SubAuth2, SubAuth3;

    //
    // Generate three random numbers for the new domain SID...
    //
    if ( SetupGenRandom( &SubAuth1, sizeof(SubAuth1) ) &&
         SetupGenRandom( &SubAuth2, sizeof(SubAuth2) ) &&
         SetupGenRandom( &SubAuth3, sizeof(SubAuth3) ) )
    {
        SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;

#ifdef DBG
        DbgPrint( "New SID:  0x%lx, 0x%lx, 0x%lx\n", SubAuth1, SubAuth2, SubAuth3 );
#endif
        Status = RtlAllocateAndInitializeSid( &IdentifierAuthority,
                                              4,
                                              0x15,
                                              SubAuth1,
                                              SubAuth2,
                                              SubAuth3,
                                              0,
                                              0,
                                              0,
                                              0,
                                              NewDomainSid );
    }

    return( Status );
}

NTSTATUS
GenerateUniqueSid(
    IN  DWORD   Seed
    )

/*++
===============================================================================
Routine Description:

    Generates a (hopefully) unique SID for use by Setup. Setup uses this
    SID as the Domain SID for the Account domain.

    Use RtlFreeSid() to free the SID allocated by this routine.

Arguments:

    Sid  - On return points to the created SID.

Return Value:

    Status code indicating outcome.

===============================================================================
--*/
{
    NTSTATUS        Status;
    HANDLE          hKey;
    UNICODE_STRING  SidString;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo = NULL;

    //
    // Use the same logic as LSASS to generate a unique system SID...
    //
    Status = SetupGenerateRandomDomainSid( &G_NewSid );
    TEST_STATUS_RETURN( "SETUPCL: GenerateUniqueSid - LsapGenerateRandomDomainSid failed!" );

    //
    // I need to get a text version of the 3 values that make
    // up this SID's uniqueness.  This is pretty gross.  It turns
    // out that the first 8 characters of the SID string (as gotten
    // from a call to RtlConvertSidtoUnicodeString) are the same
    // for any Domain SID.  And it's always the 9th character that
    // starts the 3 unique numbers.
    //
    Status = RtlConvertSidToUnicodeString( &SidString, G_NewSid, TRUE );
    TEST_STATUS_RETURN( "SETUPCL: GenerateUniqueSid - RtlConvertSidToUnicodeString failed!" );
    wcscpy( G_NewSidSubString, &SidString.Buffer[9] );

#ifdef DBG
    //
    // Debug spew.
    //
    {
        int i;

        DbgPrint( "SETUPCL: SetupGenerateUniqueSid - Generated SID:\n" );
        for( i = 0; i < SID_SIZE; i += 4 ) {
            DbgPrint( "%08lx   ", *(PULONG)((PUCHAR)(G_NewSid) + i));
        }
        DbgPrint( "\n" );

        DbgPrint("Generated Sid = %ws \n",SidString.Buffer);
    }
#endif


    RtlFreeUnicodeString( &SidString );

    if( KeyValueInfo ) {
        RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInfo );
        KeyValueInfo = NULL;
    }

    return Status;
}



#ifdef IA64

VOID
CreateNewGuid(
    IN GUID *Guid
    )
/*++

Routine Description:

    Creates a new pseudo GUID.  

Arguments:

    Guid    -   Place holder for the new pseudo

Return Value:

    None.

--*/
{
    if (Guid) 
    {
        LARGE_INTEGER   Time;
        ULONG Random1 = RtlRandom(&RandomSeed); 
        ULONG Random2 = RtlRandom(&RandomSeed); 

        //
        // Get system time
        //
        NtQuerySystemTime(&Time);

        RtlZeroMemory(Guid, sizeof(GUID));

        //
        // First 8 bytes is system time
        //
        RtlCopyMemory(Guid, &(Time.QuadPart), sizeof(Time.QuadPart));

        //
        // Next 8 bytes are two random numbers
        //
        RtlCopyMemory(Guid->Data4, &Random1, sizeof(ULONG));

        RtlCopyMemory(((PCHAR)Guid->Data4) + sizeof(ULONG),
            &Random2, sizeof(ULONG));

    }
}


VOID* MyMalloc(size_t Size) 
{
    return RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, Size );
}


VOID MyFree(VOID *Memory)
{
    RtlFreeHeap( RtlProcessHeap(), 0, Memory );
}

NTSTATUS
GetAndWriteBootEntry(
    IN POS_BOOT_ENTRY pBootEntry
    )
/*++

Routine Description:

    Get the boot entry from NVRAM for the given boot entry Id.  Construct a filename
    of the form BootXXXX, where XXXX = id.  Put the file in the same directory as the
    EFI OS loader.  The directory is determined from the LoaderFile string. 
     
Arguments:

    pBootEntry              pointer to the POS_BOOT_ENTRY structure
    
Return Value:

    NTSTATUS

Remarks:
    
    This was ported from \textmode\kernel\spboot.c on 6/9/2001.

--*/
{
    NTSTATUS            status;
    UNICODE_STRING      idStringUnicode;
    WCHAR               idStringWChar[9] = {0};
    WCHAR               BootEntryPath[MAX_PATH] = {0};
    HANDLE              hfile;
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     iostatus;
    UCHAR*              bootVar = NULL;
    ULONG               bootVarSize;
    UNICODE_STRING      uFilePath;
    UINT64              BootNumber;
    UINT64              BootSize;
    GUID                EfiBootVariablesGuid = EFI_GLOBAL_VARIABLE;
    ULONG               Id = 0;
    WCHAR*              pwsFilePart = NULL;

    hfile = NULL;

    if (NULL == pBootEntry)
        return STATUS_INVALID_PARAMETER;

    //
    // BootEntryPath = OsLoaderVolumeName + OsLoaderPath
    // OsLoaderVolumeName = "\Device\HarddriveVolume1"
    // OsLoaderPath       = "\Efi\Microsoft\Winnt50\ia64ldr.efi"
    // Then Strip off the ia64ldr.efi and replace with BootXXX.
    //
    wcsncpy(BootEntryPath, pBootEntry->OsLoaderVolumeName, AS(BootEntryPath) - 1);
    wcsncpy(BootEntryPath + wcslen(BootEntryPath), pBootEntry->OsLoaderPath, AS(BootEntryPath) - wcslen(BootEntryPath) - 1);

    // 
    // Backup to last backslash before ia64ldr.efi careful of clength
    //
    pwsFilePart = wcsrchr(BootEntryPath, L'\\');
    *(++pwsFilePart) = L'\0';
    
    // 
    // Id = BootEntry Id
    //
    Id = pBootEntry->Id;

    //
    // Retrieve the NVRAM entry for the Id specified
    //
    _snwprintf( idStringWChar, AS(idStringWChar) - 1, L"Boot%04x", Id);

    //
    // Append the BootXXXX
    //
    wcsncpy(BootEntryPath + wcslen(BootEntryPath), idStringWChar, AS(BootEntryPath) - wcslen(BootEntryPath) - 1);

    DbgPrint("SETUPCL: Writing to NVRBoot file %ws.\n", BootEntryPath);

    RtlInitUnicodeString( &idStringUnicode, idStringWChar);
    
    bootVarSize = 0;

    status = NtQuerySystemEnvironmentValueEx(&idStringUnicode,
                                        &EfiBootVariablesGuid,
                                        NULL,
                                        &bootVarSize,
                                        NULL);

    if (status != STATUS_BUFFER_TOO_SMALL) {
        
        ASSERT(FALSE);
        
        DbgPrint("SETUPCL: Failed to get size for boot entry buffer.\n");
    
        goto Done;

    } else {
        
        bootVar = RtlAllocateHeap(RtlProcessHeap(), 0, bootVarSize);
        if (!bootVar) {
            
            status = STATUS_NO_MEMORY;

            DbgPrint("SETUPCL: Failed to allocate boot entry buffer.\n");
            
            goto Done;
        }
         
        status = NtQuerySystemEnvironmentValueEx(&idStringUnicode,
                                                &EfiBootVariablesGuid,
                                                bootVar,
                                                &bootVarSize,
                                                NULL);
        
        if (status != STATUS_SUCCESS) {

            ASSERT(FALSE);
            
            DbgPrint("SETUPCL: Failed to get boot entry.\n");
            
            goto Done;
        }
    }

    //
    // open the file 
    //

    INIT_OBJA(&oa, &uFilePath, BootEntryPath);

    status = NtCreateFile(&hfile,
                            FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                            &oa,
                            &iostatus,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_OVERWRITE_IF,
                            FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,
                            0
                            );
    if ( ! NT_SUCCESS(status) ) {

        DbgPrint("SETUPCL: Failed to create boot entry recovery file %lx.\n", status);
        
        goto Done;
    }

    //
    // Write the bits to disk using the format required
    // by base/efiutil/efinvram/savrstor.c
    //
    // [BootNumber][BootSize][BootEntry (of BootSize)]
    //

    //
    // build the header info for the boot entry block
    //

    // [header] include the boot id
    BootNumber = Id;
    status = NtWriteFile( hfile,
                          NULL,
                          NULL,
                          NULL,
                          &iostatus,
                          &BootNumber,
                          sizeof(BootNumber),
                          NULL,
                          NULL
                          );
    if ( ! NT_SUCCESS(status) ) {

        DbgPrint("SETUPCL: Failed writing boot number to boot entry recovery file.\n");
        
        goto Done;
    }

    // [header] include the boot size
    BootSize = bootVarSize;
    status = NtWriteFile( hfile,
                          NULL,
                          NULL,
                          NULL,
                          &iostatus,
                          &BootSize,
                          sizeof(BootSize),
                          NULL,
                          NULL
                          );
    if ( ! NT_SUCCESS(status) ) {

        DbgPrint("SETUPCL: Failed writing boot entry size to boot entry recovery file.\n");

        goto Done;
    }

    // boot entry bits
    status = NtWriteFile( hfile,
                            NULL,
                            NULL,
                            NULL,
                            &iostatus,
                            bootVar,
                            bootVarSize,
                            NULL,
                            NULL
                            );
    if ( ! NT_SUCCESS(status) ) {

        DbgPrint("SETUPCL: Failed writing boot entry to boot entry recovery file.\n");
        
        goto Done;
    }

Done:

    //
    // We are done
    //

    if (bootVar) {
        RtlFreeHeap(RtlProcessHeap(), 0, bootVar);
    }
    if (hfile) {
        NtClose( hfile );
    }

    return status;

}

NTSTATUS
ResetDiskGuids(VOID)
{
    NTSTATUS                    Status;
    SYSTEM_DEVICE_INFORMATION   sdi;
    ULONG                       iDrive;

    // Clean up the memory
    //
    RtlZeroMemory(&sdi, sizeof(sdi));

    // Query the number of physical devices on the system
    //
    Status = NtQuerySystemInformation(SystemDeviceInformation, &sdi, sizeof(SYSTEM_DEVICE_INFORMATION), NULL);
    
    // We successfully queried the devices and there are devices there
    //
    if ( NT_SUCCESS(Status) && sdi.NumberOfDisks)
    {
        POS_BOOT_OPTIONS    pBootOptions                 = NULL;
        POS_BOOT_OPTIONS    pBootOptionsInitial          = NULL;
        POS_BOOT_ENTRY      pBootEntry                   = NULL;
        
        DbgPrint("Successfully queried (%lx) disks.\n", sdi.NumberOfDisks);
                
        // Initialize the library with our own memory management functions
        //
        if ( OSBOLibraryInit(MyMalloc, MyFree) )
        {
            // Determine initial BootOptions
            //
            pBootOptions        = EFIOSBOCreate();
            pBootOptionsInitial = EFIOSBOCreate();

            // Were we able to create the BootOptions
            //
            if ( pBootOptions && pBootOptionsInitial )
            {
                // Iterate through each disk and determine the GUID
                //
                for ( iDrive = 0; iDrive < sdi.NumberOfDisks && NT_SUCCESS(Status); iDrive++ )
                {
                    WCHAR               szPhysicalDrives[MAX_PATH] = {0};
                    UNICODE_STRING      UnicodeString;
                    OBJECT_ATTRIBUTES   Obja;
                    HANDLE              DiskHandle;
                    IO_STATUS_BLOCK     IoStatusBlock;

                    // Generate the path to the drive
                    //
                    _snwprintf(szPhysicalDrives, AS(szPhysicalDrives) - 1, L"\\Device\\Harddisk%d\\Partition0", iDrive);
            
                    // Initialize the handle to unicode string
                    //
                    INIT_OBJA(&Obja,&UnicodeString,szPhysicalDrives);

                    // Attempt to open the file
                    //
                    Status = NtCreateFile( &DiskHandle,
                                           FILE_GENERIC_READ | FILE_GENERIC_WRITE,
                                           &Obja,
                                           &IoStatusBlock,
                                           NULL,
                                           FILE_ATTRIBUTE_NORMAL,
                                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                                           FILE_OPEN,
                                           0,
                                           NULL,
                                           0 );

                    // Check to see if we were able to open the disk
                    //
                    if ( !NT_SUCCESS(Status) )
                    {
                        DbgPrint("Unable to open file on %ws. Error (%lx)\n", szPhysicalDrives, Status);
                    }
                    else
                    {
                        PDRIVE_LAYOUT_INFORMATION_EX    pLayoutInfoEx   = NULL;
                        ULONG                           lengthLayoutEx  = 0,
                                                        iPart;

                        DbgPrint("Successfully opened file on %ws\n", szPhysicalDrives);

                        lengthLayoutEx = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + (sizeof(PARTITION_INFORMATION_EX) * 128);
                        pLayoutInfoEx = (PDRIVE_LAYOUT_INFORMATION_EX) MyMalloc( lengthLayoutEx );
                        if ( pLayoutInfoEx )
                        {
                            // Attempt to get the drive layout
                            //
                            Status = NtDeviceIoControlFile( DiskHandle, 0, NULL, NULL, &IoStatusBlock, IOCTL_DISK_GET_DRIVE_LAYOUT_EX, NULL, 0, pLayoutInfoEx, lengthLayoutEx );
                
                            // Check the status of the drive layout
                            //
                            if ( !NT_SUCCESS(Status) )
                                DbgPrint("Unable to open IOCTL on %ws. Error (%lx)\n", szPhysicalDrives, Status);
                            else
                            {
                                DbgPrint("Opened IOCTL on drive %ws. Error (%lx)\n", szPhysicalDrives, Status);
                                DbgPrint("\tPhysical Disk %d\n", iDrive);
                                DbgPrint("\tPartition Count: %d\n", pLayoutInfoEx->PartitionCount);

                                // Iterate through each partition
                                //
                                for (iPart = 0; iPart < pLayoutInfoEx->PartitionCount; iPart++)
                                {
                                    // We only would like to deal with GPT partitions
                                    //
                                    if ( pLayoutInfoEx->PartitionEntry[iPart].PartitionStyle == PARTITION_STYLE_GPT )
                                    {
                                        const   UUID GuidNull = { 0 };
#ifdef DBG
                                        UNICODE_STRING cGuid;
                                        UNICODE_STRING cGuidNew;
#endif
                                        // Only replace the Guid if it's NULL.
                                        //
                                        if (IsEqualGUID(&(pLayoutInfoEx->PartitionEntry[iPart].Gpt.PartitionId), &GuidNull))
                                        {
                                            //
                                            // ISSUE-2002/02/26-brucegr,jcohen - CreateNewGuid expects GUID structure. Possible mismatch?
                                            //
                                            // (acosma 2002/04/24) Fix this issue in Longhorn. UUID is typedef to GUID or the 
                                            // other way around so they are the same thing, however for readability we will fix this.
                                            //
                                            UUID    Guid;

                                            // Create a new GUID for this machine
                                            //
                                            CreateNewGuid(&Guid);
#ifdef DBG
                                            if ( NT_SUCCESS( RtlStringFromGUID((LPGUID) &(pLayoutInfoEx->PartitionEntry[iPart].Gpt.PartitionId), &cGuid) ) )
                                            {
                                                if ( NT_SUCCESS( RtlStringFromGUID((LPGUID) &Guid, &cGuidNew) ) )
                                                {
                                                    DbgPrint("\tPartition: %ws (%x), %ws %ws\n",
                                                            pLayoutInfoEx->PartitionEntry[iPart].Gpt.Name, iPart, cGuid.Buffer, cGuidNew.Buffer);

                                                    RtlFreeUnicodeString(&cGuidNew);
                                                }
                                                RtlFreeUnicodeString(&cGuid);
                                            }
#endif
                                        
                                            // This is a struct to struct assignment. It is legal in C.
                                            //
                                            pLayoutInfoEx->PartitionEntry[iPart].Gpt.PartitionId = Guid;
                                        }
                                    }
                                }
                            }

                            TEST_STATUS("SETUPCL: ResetDiskGuids - Failed to reset Disk Guids.");

                            if ( NT_SUCCESS( Status = NtDeviceIoControlFile( DiskHandle, 0, NULL, NULL, &IoStatusBlock, IOCTL_DISK_SET_DRIVE_LAYOUT_EX, pLayoutInfoEx, lengthLayoutEx, NULL, 0 ) ) )
                            {
                                DbgPrint("\tSuccessfully reset %ws\n", szPhysicalDrives);
                            }

                            //
                            // Free the layout info buffer...
                            //
                            MyFree( pLayoutInfoEx );
                        }

                        // Clean up the memory
                        //
                        NtClose( DiskHandle );
                    }
                }

                // Delete the old boot entries and recreate them so we pick up the new GUIDS if they changed.
                //
                if ( NT_SUCCESS(Status) )
                {
                    POS_BOOT_ENTRY pActiveBootEntry = NULL;
                    DWORD          dwBootEntryCount = OSBOGetBootEntryCount(pBootOptionsInitial);
                
                    DbgPrint("SETUPCL: ResetDiskGuids - Updating boot entries to use new GUIDS.\n");

                    if (dwBootEntryCount)
                    {
                        ULONG Index;
                        BOOL  bSetActive = FALSE;
                    
                        // Get the current boot entry
                        //
                        pActiveBootEntry = OSBOGetActiveBootEntry(pBootOptionsInitial); 
                        pBootEntry = OSBOGetFirstBootEntry(pBootOptionsInitial, &Index);

                        while ( pBootEntry ) 
                        {
                            // Don't set the current entry active by default.
                            //
                            bSetActive = FALSE;

                            if (  OSBE_IS_WINDOWS(pBootEntry) )
                            {
                                POS_BOOT_ENTRY  pBootEntryToDelete = NULL;
                                WCHAR           FriendlyName[MAX_PATH],
                                                OsLoaderVolumeName[MAX_PATH],
                                                OsLoaderPath[MAX_PATH],
                                                BootVolumeName[MAX_PATH],
                                                BootPath[MAX_PATH],
                                                OsLoadOptions[MAX_PATH];

                                // Load the boot entry parameters into their own buffer
                                //
                                memset(FriendlyName,        0, AS(FriendlyName));
                                memset(OsLoaderVolumeName,  0, AS(OsLoaderVolumeName));
                                memset(OsLoaderPath,        0, AS(OsLoaderPath));
                                memset(BootVolumeName,      0, AS(BootVolumeName));
                                memset(BootPath,            0, AS(BootPath));
                                memset(OsLoadOptions,       0, AS(OsLoadOptions));

                                wcsncpy(FriendlyName,       OSBEGetFriendlyName(pBootEntry),        AS(FriendlyName) - 1);
                                wcsncpy(OsLoaderVolumeName, OSBEGetOsLoaderVolumeName(pBootEntry),  AS(OsLoaderVolumeName) - 1);
                                wcsncpy(OsLoaderPath,       OSBEGetOsLoaderPath(pBootEntry),        AS(OsLoaderPath) - 1);
                                wcsncpy(BootVolumeName,     OSBEGetBootVolumeName(pBootEntry),      AS(BootVolumeName) - 1);
                                wcsncpy(BootPath,           OSBEGetBootPath(pBootEntry),            AS(BootPath) - 1);
                                wcsncpy(OsLoadOptions,      OSBEGetOsLoadOptions(pBootEntry),       AS(OsLoadOptions) - 1);
                            
                                // If this is the active boot entry set active the new boot entry that we are going to create.
                                //
                                if ( pBootEntry == pActiveBootEntry )
                                {
                                    bSetActive = TRUE;
                                }

                                if ( ( pBootEntryToDelete = OSBOFindBootEntry(pBootOptions, pBootEntry->Id) ) && 
                                     OSBODeleteBootEntry(pBootOptions, pBootEntryToDelete) )
                                {
                                    POS_BOOT_ENTRY pBootEntryNew = NULL;

                                    pBootEntryNew = OSBOAddNewBootEntry(pBootOptions, 
                                                                        FriendlyName,
                                                                        OsLoaderVolumeName,
                                                                        OsLoaderPath,
                                                                        BootVolumeName,
                                                                        BootPath,
                                                                        OsLoadOptions);
                                    if ( pBootEntryNew )
                                    {
                                        if ( bSetActive )
                                        {
                                            OSBOSetActiveBootEntry(pBootOptions, pBootEntryNew);
                                        }
                                    
                                        // Update the NVRBoot file
                                        //
                                        GetAndWriteBootEntry(pBootEntryNew);
                                        
                                        // Flush out the boot options
                                        //
                                        OSBEFlush(pBootEntryNew);
                                    }
                                    else
                                    {
                                        DbgPrint("SETUPCL: ResetDiskGuids - Failed to add a boot entry [%ws]\n", FriendlyName);
                                    }
                                }
                                else
                                {
                                    DbgPrint("SETUPCL: ResetDiskGuids - Failed to delete a boot entry [%ws]\n", FriendlyName);
                                }
                            }
                            
                            // Get the next entry.
                            // 
                            pBootEntry = OSBOGetNextBootEntry(pBootOptionsInitial, &Index);
                        }
                    }

                    // Flush the boot options if we've changed GUIDS.
                    //
                    OSBOFlush(pBootOptions);
                }
            }
            else
            {
                DbgPrint("SETUPCL: ResetDiskGuids - Failed to load the existing boot entries.\n");
            }

            // 
            // Free the boot option structures.
            //
            if ( pBootOptions )
            {
                OSBODelete(pBootOptions);
            }

            if ( pBootOptionsInitial )
            {
                OSBODelete(pBootOptionsInitial);
            }
        }
        else
        {
            DbgPrint("SETUPCL: ResetDiskGuids - Failed to initialize the boot options library.\n");
        }
    }

    return Status;
}

#endif \\ #ifdef IA64

// This function always deletes a CRLF from the end of the string.  It assumes that there
// is a CRLF at the end of the line and just removes the last two characters.  
//
void OutputString(LPTSTR szMsg)
{
    UNICODE_STRING  uMsg;
    RtlInitUnicodeString(&uMsg, szMsg);

    // Whack the CRLF at the end of the string. Doing this here for performance reasons. 
    // Don't want to put this in DisplayUI().
    //
    if (uMsg.Length > ( 2 * sizeof(WCHAR)) ) 
    {
        uMsg.Length -= (2 * sizeof(WCHAR));
        uMsg.Buffer[uMsg.Length / sizeof(WCHAR)] = 0; // UNICODE_NULL
    }
    NtDisplayString(&uMsg);
}

// Keep this function as short as possible. This gets called a lot in the recursive functions of setupcl.
// Do not create any stack based variables here for performance reasons.
//
__inline void DisplayUI()
{
   NtQuerySystemTime(&CurrentTime);
   
   if ( !bDisplayUI )
   {    
        if ( (CurrentTime.QuadPart - StartTime.QuadPart) > UITIME )
        {
            static UNICODE_STRING UnicodeString = { 0 };
            bDisplayUI = TRUE;
            LastDotTime.QuadPart = CurrentTime.QuadPart;
            
            if ( LoadStringResource(&UnicodeString, IDS_UIMAIN) )
            {
                OutputString(UnicodeString.Buffer);
                RtlFreeUnicodeString(&UnicodeString);
            }
            
       }
    }
    else
    {   // If more than 3 seconds passed since our last output put up a dot.
        //
        if ( (CurrentTime.QuadPart - LastDotTime.QuadPart) > UIDOTTIME )
        {
            LastDotTime.QuadPart = CurrentTime.QuadPart;
            OutputString(TEXT("."));
        }
    }

}

int __cdecl
main(
    int     argc,
    char**  argv,
    char**  envp,
    ULONG DebugParameter
    )
/*++
===============================================================================
Routine Description:

    This routine is the main entry point for the program.

    We do a bit of error checking, then, if all goes well, we update the
    registry to enable execution of our second half.

===============================================================================
--*/

{
    BOOLEAN         b;
    int             i;
    NTSTATUS        Status;
    LARGE_INTEGER   Time;

    //
    // Get Time for seed generation...
    //
    NtQuerySystemTime(&Time);

#ifdef IA64

    // Setup the Seed for generating GUIDs
    //
    RandomSeed = (ULONG) Time.LowPart;
    
    
#endif

    // Initialize the StartTime
    //
    StartTime.QuadPart = Time.QuadPart;
    LastDotTime.QuadPart = Time.QuadPart;
  
    i = 0;        
    //
    // Enable several privileges that we will need.
    //
    //
    // NTRAID#NTBUG9-545904-2002/02/26-brucegr,jcohen - Do something smarter with regard to error conditions.
    //
    Status = RtlAdjustPrivilege(SE_BACKUP_PRIVILEGE,TRUE,FALSE,&b);
    TEST_STATUS( "SETUPCL: Warning - unable to enable SE_BACKUP_PRIVILEGE privilege!" );

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,TRUE,FALSE,&b);
    TEST_STATUS( "SETUPCL: Warning - unable to enable SE_RESTORE_PRIVILEGE privilege!" );

    Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,TRUE,FALSE,&b);
    TEST_STATUS( "SETUPCL: Warning - unable to enable SE_SHUTDOWN_PRIVILEGE privilege!" );

    Status = RtlAdjustPrivilege(SE_TAKE_OWNERSHIP_PRIVILEGE,TRUE,FALSE,&b);
    TEST_STATUS( "SETUPCL: Warning - unable to enable SE_TAKE_OWNERSHIP_PRIVILEGE privilege!" );

    Status = RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE,TRUE,FALSE,&b);
    TEST_STATUS( "SETUPCL: Warning - unable to enable SE_SECURITY_PRIVILEGE privilege!" );

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE,TRUE,FALSE,&b);
    TEST_STATUS( "SETUPCL: Warning - unable to enable SE_TCB_PRIVILEGE privilege!" );
    

#ifdef IA64
    // 
    // Reset the Disk GUIDs.
    //
    DbgPrint("We are currently running on IA64. Resetting disk GUIDs.\n");
    
    //
    // ISSUE-2002/02/26-brucegr,jcohen - Error code isn't tested!
    //
    ResetDiskGuids();
#endif
  
    //
    // Retrieve old Security ID.
    //
    Status = RetrieveOldSid( );
    TEST_STATUS_RETURN( "SETUPCL: Retrieval of old SID failed!" );
        
    //
    // Generate a new Security ID.
    //
    //
    // NTRAID#NTBUG9-545855-2002/02/26-brucegr,jcohen - Use same sid generation algorithm as LsapGenerateRandomDomainSid
    //                 in ds\security\base\lsa\server\dspolicy\dbinit.c
    //
    Status = GenerateUniqueSid( Time.LowPart );
    TEST_STATUS_RETURN( "SETUPCL: Generation of new SID failed!" );

    //
    // Make a copy of the repair hives.
    //
    Status = BackupRepairHives();
    if( NT_SUCCESS(Status) ) {
    
        //
        // Do the repair hives.
        //
        Status = ProcessRepairHives();
        TEST_STATUS( "SETUPCL: Failed to update one of the Repair hives." );
    }
    //
    // Decide if we need to restore the repair hives from our backups.
    //
    CleanupRepairHives( Status );
    
    //
    // Now process the hives, one at a time.
    //
    //
    // NTRAID#NTBUG9-545904-2002/02/26-brucegr,jcohen - Do something smarter with regard to error conditions.
    //
    Status = ProcessHives();
    
    //
    // NTRAID#NTBUG9-545904-2002/02/26-brucegr,jcohen - Do something smarter with regard to error conditions.
    //
    Status = FinalHiveCleanup();
    
    //
    // Now go enumerate all the drives.  For each NTFS drive,
    // we'll whack the ACL to reflect the new SID.
    //
    //
    // NTRAID#NTBUG9-545904-2002/02/26-brucegr,jcohen - Do something smarter with regard to error conditions.
    //
    Status = EnumerateDrives();
    
    return Status;
}


// 
// Disable the DbgPrint for non-debug builds
//
#ifndef DBG
void DbgPrintSub(char *szBuffer, ...)
{
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupcl\utils.c ===
/*++

File Description:

    This file contains utility functions used by the
    SID modifier tool.

Author:

    Matt Holle (matth) Oct 1997


--*/

//
// System header files
//
#include <nt.h>
// 
// Disable the DbgPrint for non-debug builds
//
#ifndef DBG
#define _DBGNT_
#endif
#include <ntrtl.h>

#include <nturtl.h>
#include <ntverp.h>
#include <wtypes.h>

//
// Private header files
//
#include "setupcl.h"



SECURITY_INFORMATION ALL_SECURITY_INFORMATION = DACL_SECURITY_INFORMATION  |
                                                SACL_SECURITY_INFORMATION  |
                                                GROUP_SECURITY_INFORMATION |
                                                OWNER_SECURITY_INFORMATION;


//
// ISSUE-2002/02/26-brucegr,jcohen - Dead Code!  Nobody calls DeleteKey!
//
NTSTATUS
DeleteKey(
    PWSTR   Key
    );

NTSTATUS
DeleteKeyRecursive(
    HANDLE  hKeyRoot,
    PWSTR   Key
    );

NTSTATUS
FileDelete(
    IN WCHAR    *FileName
    );

NTSTATUS
FileCopy(
    IN WCHAR    *TargetName,
    IN WCHAR    *SourceName
    );

NTSTATUS
SetKey(
    IN WCHAR    *KeyName,
    IN WCHAR    *SubKeyName,
    IN CHAR     *Data,
    IN ULONG    DataLength,
    IN ULONG    DATA_TYPE
    );

NTSTATUS
ReadSetWriteKey(
    IN WCHAR    *ParentKeyName,  OPTIONAL
    IN HANDLE   ParentKeyHandle, OPTIONAL
    IN WCHAR    *SubKeyName,
    IN CHAR     *OldData,
    IN CHAR     *NewData,
    IN ULONG    DataLength,
    IN ULONG    DATA_TYPE
    );

NTSTATUS
LoadUnloadKey(
    IN PWSTR        KeyName,
    IN PWSTR        FileName
    );

NTSTATUS
BackupRepairHives(
    VOID
    );

NTSTATUS
CleanupRepairHives(
    NTSTATUS RepairHivesSuccess
    );

NTSTATUS
TestSetSecurityObject(
    HANDLE  hKey
    );

NTSTATUS
SetKeySecurityRecursive(
    HANDLE  hKey
    );

NTSTATUS
CopyKeyRecursive(
    HANDLE  hKeyDst,
    HANDLE  hKeySrc
    );

NTSTATUS
CopyRegKey(
    IN WCHAR    *TargetName,
    IN WCHAR    *SourceName,
    IN HANDLE   ParentKeyHandle OPTIONAL
    );

//
// ISSUE-2002/02/26-brucegr,jcohen - Dead Code!  Nobody calls MoveRegKey!
//
NTSTATUS
MoveRegKey(
    IN WCHAR    *TargetName,
    IN WCHAR    *SourceName
    );

NTSTATUS
FindAndReplaceBlock(
    IN PCHAR    Block,
    IN ULONG    BlockLength,
    IN PCHAR    OldValue,
    IN PCHAR    NewValue,
    IN ULONG    ValueLength
    );

NTSTATUS
SiftKeyRecursive(
    HANDLE hKey,
    int    indent
    );

NTSTATUS
SiftKey(
    PWSTR   KeyName
    );

//
// ISSUE-2002/02/26-brucegr,jcohen - Dead Code!  Nobody calls DeleteKey!
//
NTSTATUS
DeleteKey(
    PWSTR   KeyName
    )

/*++
===============================================================================
Routine Description:

    Does some overhead work, then calls out to DeleteKeyRecursive in order
    to ensure that if this key has any children, they get whacked too.

Arguments:

    Key:         Key to delete.

Return Value:

    Status is returned.
===============================================================================
--*/
{
NTSTATUS            Status;
UNICODE_STRING      UnicodeString;
OBJECT_ATTRIBUTES   ObjectAttributes;
WCHAR               TerminateKey[MAX_PATH],
                    ParentName[MAX_PATH];
HANDLE              hKey;
LONG                i;

    //
    // Get the name of the parent key.  Do this by replacing the last
    // back-whack with a NULL.
    //
    i = wcslen( KeyName );
    while( (KeyName[i] != '\\') &&
           ( i >= 0 ) ) {
        i--;
    }

    if( i >= 0 ) {
        KeyName[i] = 0;
        wcscpy( ParentName, KeyName );
        KeyName[i] = '\\';
    } else {
        return( -1 );
    }

    //
    // Get the name of the key we're going to terminate...
    //
    wcscpy( TerminateKey, KeyName + i + 1 );

    //
    // Open the parent
    //
    INIT_OBJA( &ObjectAttributes, &UnicodeString, ParentName );
    ObjectAttributes.RootDirectory = NULL;
    Status = NtOpenKey( &hKey,
                        KEY_ALL_ACCESS,
                        &ObjectAttributes );
    TEST_STATUS_RETURN( "SETUPCL: DeleteKey - Failed to open Parent key!" );

    Status = DeleteKeyRecursive( hKey, TerminateKey );
    TEST_STATUS( "SETUPCL: DeleteKey - Call to DeleteKeyRecursive Failed!" );
    NtClose( hKey );

    return( Status );
}


NTSTATUS
DeleteKeyRecursive(
    HANDLE  hKeyRoot,
    PWSTR   Key
    )
/*++
===============================================================================
Routine Description:

    Routine to recursively delete all subkeys under the given
    key, including the key given.

Arguments:

    hKeyRoot:    Handle to root relative to which the key to be deleted is
                 specified.

    Key:         Root relative path of the key which is to be recursively
                 deleted.

Return Value:

    Status is returned.
===============================================================================
--*/
{
WCHAR               ValueBuffer[BASIC_INFO_BUFFER_SIZE];
ULONG               ResultLength;
PKEY_BASIC_INFORMATION  KeyInfo;
NTSTATUS            Status;
UNICODE_STRING      UnicodeString;
OBJECT_ATTRIBUTES   Obja;
PWSTR               SubkeyName;
HANDLE              hKey;

    //
    // Initialize
    //
    KeyInfo = (PKEY_BASIC_INFORMATION)ValueBuffer;

    //
    // Open the key
    //
    INIT_OBJA(&Obja,&UnicodeString,Key);
    Obja.RootDirectory = hKeyRoot;
    Status = NtOpenKey( &hKey,
                        KEY_ALL_ACCESS,
                        &Obja);
    TEST_STATUS_RETURN( "SETUPCL: DeleteKeyRecursive - Failed to open key!" );

    //
    // Enumerate all subkeys of the current key. if any exist they should
    // be deleted first.  since deleting the subkey affects the subkey
    // index, we always enumerate on subkeyindex 0
    //
    while(1) {
        Status = NtEnumerateKey( hKey,
                                 0,
                                 KeyBasicInformation,
                                 ValueBuffer,
                                 sizeof(ValueBuffer),
                                 &ResultLength );
        if(!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Recursively call this guy with a child.
        //
        Status = DeleteKeyRecursive( hKey, KeyInfo->Name );
        if(!NT_SUCCESS(Status)) {
            break;
        }
    }


    //
    // Check the status, if the status is anything other than
    // STATUS_NO_MORE_ENTRIES we failed in deleting some subkey,
    // so we cannot delete this key too
    //

    if( Status == STATUS_NO_MORE_ENTRIES) {
        Status = STATUS_SUCCESS;
    }
    TEST_STATUS( "SETUPCL: DeleteKeyRecursive - Failed to delete all keys!" );

    Status = NtDeleteKey( hKey );
    TEST_STATUS( "SETUPCL: DeleteKeyRecursive - Failed to delete key!" );

    Status = NtClose( hKey );
    TEST_STATUS( "SETUPCL: DeleteKeyRecursive - Failed to close key!" );

    return( Status );
}


NTSTATUS
FileDelete(
    IN WCHAR    *FileName
    )
/*++
===============================================================================
Routine Description:

    This function will attempt a delete on the given file name.

Arguments:

    FileName        - The name of the file we're going to be deleting.

Return Value:

    NTSTATUS.

===============================================================================
--*/
{
NTSTATUS            Status = STATUS_SUCCESS;
UNICODE_STRING      UnicodeString;
OBJECT_ATTRIBUTES   ObjectAttributes;
HANDLE              hFile;
IO_STATUS_BLOCK     IoStatusBlock;
WCHAR               buffer[MAX_PATH];

    INIT_OBJA( &ObjectAttributes,
               &UnicodeString,
               FileName );

    Status = NtCreateFile( &hFile,
                           FILE_GENERIC_READ | DELETE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           0,
                           FILE_OPEN,
                           FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_DELETE_ON_CLOSE,
                           NULL,
                           0 );
    //
    // ISSUE-2002/02/26-brucegr,jcohen - Check Status before trying to close handle!
    //
    NtClose( hFile );

    TEST_STATUS( "SETUPCL: MyDelFile - Failed a delete." );

    return( Status );
}


NTSTATUS
FileCopy(
    IN WCHAR    *TargetName,
    IN WCHAR    *SourceName
    )

/*++
===============================================================================
Routine Description:

    This function will attempt a copy of the given file.

Arguments:

    TargetName      - The name of the file we'll be writing.
    SourceName      - The name of the file we'll be reading.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
NTSTATUS            Status = STATUS_SUCCESS;
UNICODE_STRING      UnicodeString;
OBJECT_ATTRIBUTES   ObjectAttributes;
HANDLE              SourceHandle,
                    TargetHandle,
                    SectionHandle;
IO_STATUS_BLOCK     IoStatusBlock;
ULONG               FileSize,
                    remainingLength,
                    writeLength;
SIZE_T              ViewSize;
LARGE_INTEGER       SectionOffset,
                    FileOffset;
PVOID               ImageBase;
PUCHAR              base;

FILE_STANDARD_INFORMATION StandardInfo;

    //
    // Open the Source file.
    //
    INIT_OBJA( &ObjectAttributes,
               &UnicodeString,
               SourceName );

    Status = NtCreateFile( &SourceHandle,
                           FILE_GENERIC_READ,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ,
                           FILE_OPEN,
                           0,
                           NULL,
                           0 );
    TEST_STATUS_RETURN( "SETUPCL: FileCopy - Failed to open source." );

    //
    // Get the Source file size.
    //
    Status = NtQueryInformationFile( SourceHandle,
                                     &IoStatusBlock,
                                     &StandardInfo,
                                     sizeof(StandardInfo),
                                     FileStandardInformation );
    TEST_STATUS_RETURN( "SETUPCL: FileCopy - Failed to get Source StandardInfo." );
    FileSize = StandardInfo.EndOfFile.LowPart;

    //
    // Map the Source file.
    //
    ViewSize = 0;
    SectionOffset.QuadPart = 0;
    Status = NtCreateSection( &SectionHandle,
                              STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ,
                              NULL,
                              NULL,       // entire file
                              PAGE_READONLY,
                              SEC_COMMIT,
                              SourceHandle );
    TEST_STATUS_RETURN( "SETUPCL: FileCopy - Failed CreateSection on Source." );

    ImageBase = NULL;
    Status = NtMapViewOfSection( SectionHandle,
                                 NtCurrentProcess(),
                                 &ImageBase,
                                 0,
                                 0,
                                 &SectionOffset,
                                 &ViewSize,
                                 ViewShare,
                                 0,
                                 PAGE_READONLY );
    TEST_STATUS_RETURN( "SETUPCL: FileCopy - Failed MapViewOfSection on Source." );

    //
    // Open the Target file.
    //
    INIT_OBJA( &ObjectAttributes,
               &UnicodeString,
               TargetName );

    Status = NtCreateFile( &TargetHandle,
                           FILE_GENERIC_WRITE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           0,
                           FILE_OVERWRITE_IF,
                           FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_SEQUENTIAL_ONLY,
                           NULL,
                           0 );
    TEST_STATUS_RETURN( "SETUPCL: FileCopy - Failed to open target." );

    //
    // Write him.  We guard him with a try/except because if there is an
    // i/o error, memory management will raise an in-page exception.
    //
    FileOffset.QuadPart = 0;
    base = ImageBase;
    remainingLength = FileSize;
    try {
        while( remainingLength != 0 ) {
            writeLength = 60 * 1024;
            if( writeLength > remainingLength ) {
                writeLength = remainingLength;
            }
            Status = NtWriteFile( TargetHandle,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  base,
                                  writeLength,
                                  &FileOffset,
                                  NULL );
            base += writeLength;
            FileOffset.LowPart += writeLength;
            remainingLength -= writeLength;

            if( !NT_SUCCESS( Status ) ) {
                break;
            }
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Status = STATUS_IN_PAGE_ERROR;
    }

    NtClose( TargetHandle );

    TEST_STATUS_RETURN( "SETUPCL: FileCopy - Failed to write target." );

    //
    // Unmap the source file.
    //
    Status = NtUnmapViewOfSection( NtCurrentProcess(), ImageBase );
    TEST_STATUS( "SETUPCL: FileCopy - Failed to UnMapSection on source." );

    Status = NtClose( SectionHandle );
    TEST_STATUS( "SETUPCL: FileCopy - Failed to close sectionhandle on source." );

    NtClose( SourceHandle );
    
    return( Status );
}


NTSTATUS
SetKey(
    IN WCHAR    *KeyName,
    IN WCHAR    *SubKeyName,
    IN CHAR     *Data,
    IN ULONG    DataLength,
    IN ULONG    DATA_TYPE
    )
/*++
===============================================================================
Routine Description:

    This function will set the specified key to the specified value.

Arguments:

    KeyName         - The name of the key we're going to be setting.
    SubKeyName      - The name of the Value key we're setting
    Data            - The value we'll be setting him to.
    DataLength      - How much data are we writing?
    DATA_TYPE       - Type of the registry entry

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
NTSTATUS            Status;
UNICODE_STRING      UnicodeString,
                    ValueName;
OBJECT_ATTRIBUTES   ObjectAttributes;
HANDLE              hKey;

    //
    // Open the parent key.
    //
    INIT_OBJA( &ObjectAttributes,
               &UnicodeString,
               KeyName );
    Status = NtOpenKey( &hKey,
                        KEY_ALL_ACCESS,
                        &ObjectAttributes );


    if( !NT_SUCCESS( Status ) ) {
        DbgPrint( "SETUPCL: SetKey - Failed to open %ws (%lx)\n", KeyName, Status );
        return( Status );
    }

    //
    // Now write the target key.
    //
    RtlInitUnicodeString(&ValueName, SubKeyName );
    Status = NtSetValueKey( hKey,
                            &ValueName,     // SubKeyName
                            0,              // TitleIndex
                            DATA_TYPE,      // Type
                            Data,           // value
                            DataLength );
    if( !NT_SUCCESS( Status ) ) {
        DbgPrint( "SETUPCL: SetKey - Failed to Set %ws\\%ws (%lx)\n", KeyName, SubKeyName, Status );
        //
        // ISSUE-2002/02/26-brucegr,jcohen - If NtSetValueKey fails, hKey is leaked!
        //
        return( Status );
    }


    NtFlushKey( hKey );
    NtClose( hKey );

    return( Status );

}


NTSTATUS
ReadSetWriteKey(
    IN WCHAR    *ParentKeyName,  OPTIONAL
    IN HANDLE   ParentKeyHandle, OPTIONAL
    IN WCHAR    *SubKeyName,
    IN CHAR     *OldData,
    IN CHAR     *NewData,
    IN ULONG    DataLength,
    IN ULONG    DATA_TYPE
    )
/*++
===============================================================================
Routine Description:

    This function will read a value from a key, surgically replace some bits
    in it, then write it back out.

Arguments:

    ParentKeyName   - Parent name of the key we're going to be setting.
    ParentKeyHandle - Parent handle of the key we're going to be setting.
    SubKeyName      - The name of the Value key we're setting
    Data            - The value we'll be setting him to.
    DataLength      - How much data are we writing?
    DATA_TYPE       - Type of the registry entry

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
NTSTATUS            Status;
UNICODE_STRING      UnicodeString,
                    ValueName;
OBJECT_ATTRIBUTES   ObjectAttributes;
HANDLE              hKey;
PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo = NULL;
ULONG               KeyValueLength, LengthNeeded;

    if( ParentKeyHandle == NULL ) {
        //
        // Open the parent key.
        //
        INIT_OBJA( &ObjectAttributes,
                   &UnicodeString,
                   ParentKeyName );
        Status = NtOpenKey( &hKey,
                            KEY_ALL_ACCESS,
                            &ObjectAttributes );


        if( !NT_SUCCESS( Status ) ) {
            DbgPrint( "SETUPCL: ReadSetWriteKey - Failed to open %ws (%lx)\n", ParentKeyName, Status );
            return( Status );
        }
    } else {
        hKey = ParentKeyHandle;
    }

    //
    // Get his data.
    //


    RtlInitUnicodeString( &UnicodeString, SubKeyName );


    //
    // How big is his buffer?
    //
    Status = NtQueryValueKey( hKey,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              NULL,
                              0,
                              &LengthNeeded );
    //
    // ISSUE-2002/02/26-brucegr,jcohen - Check for STATUS_SUCCESS, not assume success on STATUS_OBJECT_NAME_NOT_FOUND
    //
    if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        DbgPrint( "SETUPCL: ReadSetWriteKey - Unable to query subkey %ws size.  Error (%lx)\n", SubKeyName, Status );
        //
        // ISSUE-2002/02/26-brucegr,jcohen - Leaks key if ParentKeyHandle == NULL
        //
        return( Status );
    } else {
        Status = STATUS_SUCCESS;
    }

    //
    // Allocate a block.
    //
    LengthNeeded += 0x10;
    KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)RtlAllocateHeap( RtlProcessHeap(),
                                                                    0,
                                                                    LengthNeeded );

    if( KeyValueInfo == NULL ) {
        DbgPrint( "SETUPCL: ReadSetWriteKey - Unable to allocate buffer\n" );
        //
        // ISSUE-2002/02/26-brucegr,jcohen - Leaks key if ParentKeyHandle == NULL
        //
        return( Status );
    }

    //
    // Get the data.
    //
    Status = NtQueryValueKey( hKey,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              (PVOID)KeyValueInfo,
                              LengthNeeded,
                              &KeyValueLength );
    if( !NT_SUCCESS( Status ) ) {
        DbgPrint( "SETUPCL: ReadSetWriteKey - Failed to query subkey %ws (%lx)\n", SubKeyName, Status );
        //
        // ISSUE-2002/02/26-brucegr,jcohen - Leaks key if ParentKeyHandle == NULL
        // ISSUE-2002/02/26-brucegr,jcohen - Leaks KeyValueInfo
        //
        return( Status );
    }


    //
    // We got it.  Now we need to implant our new Sid into KeyValueInfo and
    // write him back out.  This is really gross...
    //
    // We're not going to rely on this structure being constant.  We'll
    // brute force the replacement via a call to FindAndReplaceBlock.  This
    // should insulate us from changes to this structure.
    //
    if( DATA_TYPE == REG_SZ ) {
        //
        // ISSUE - 2002/03/01-brucegr,acosma: We should handle REG_MULTI_SZ like a string instead of binary data
        //

        //
        // The user sent us a set of strings.  Use StringSwitchString
        // and ignore the DataLength he sent us.
        //
        Status = StringSwitchString( (PWCHAR)&KeyValueInfo->Data,
                                     (DWORD) ( LengthNeeded - FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) ) / sizeof(WCHAR),
                                     (PWCHAR)(OldData),
                                     (PWCHAR)(NewData) );
        //
        // Need to update KeyValueInfo->DataLength because SID string may have changed size!
        //
        if ( NT_SUCCESS( Status ) )
        {
            //
            // StringSwitchString may have changed the length.  Make sure we're in sync.
            //
            KeyValueInfo->DataLength = (wcslen((PWCHAR) KeyValueInfo->Data) + 1) * sizeof(WCHAR);
        }

    } else {
        //
        // Treat it as a some non-string.
        //
        Status = FindAndReplaceBlock( (PUCHAR)&KeyValueInfo->Data,
                                      KeyValueInfo->DataLength,
                                      (PUCHAR)(OldData),
                                      (PUCHAR)(NewData),
                                      DataLength );
    }

    if( NT_SUCCESS( Status ) ) {


        //
        // Now write the structure back into the registry key.
        //
        Status = NtSetValueKey( hKey,
                                &UnicodeString,
                                0,
                                DATA_TYPE,
                                (PVOID)KeyValueInfo->Data,
                                KeyValueInfo->DataLength );

        if( !NT_SUCCESS( Status ) ) {
            DbgPrint( "SETUPCL: ReadSetWriteKey - Failed to set subkey %ws (%lx)\n", SubKeyName, Status );
        } else {
#if 0
            DbgPrint( "SETUPCL: ReadSetWriteKey - We updated key %ws\\%ws.\n", ParentKeyName, SubKeyName );
#endif
        }

        NtFlushKey( hKey );
    }

    //
    // Clean up.
    //
    RtlFreeHeap( RtlProcessHeap(),
                 0,
                 KeyValueInfo );

    //
    // Yuck.  Don't close him if he came in as the ParentKeyHandle.
    //
    if( !ParentKeyHandle ) {
        NtClose( hKey );
    }

    return( Status );
}


NTSTATUS
LoadUnloadHive(
    IN PWSTR        KeyName,
    IN PWSTR        FileName
    )

/*++
===============================================================================
Routine Description:

    This function will load a hive from a file.

Arguments:

    KeyName         - The name of the hive we'll be loading/saving.
    FileName        - The name of the file we'll be loading/saving.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
NTSTATUS            Status;
UNICODE_STRING      KeyNameUString,
                    FileNameUString;
OBJECT_ATTRIBUTES   ObjectAttributesKey,
                    ObjectAttributesFile;


    INIT_OBJA( &ObjectAttributesKey,
               &KeyNameUString,
               KeyName );

    ObjectAttributesKey.RootDirectory = NULL;

    if( FileName == NULL ) {
    
        //
        // Delete the key
        //
        Status = NtUnloadKey( &ObjectAttributesKey );
        TEST_STATUS( "SETUPCL: LoadUnloadHive - Failed to unload the key." );
    } else {

        //
        // Load the key from a file.
        //
        INIT_OBJA( &ObjectAttributesFile, &FileNameUString, FileName );
        ObjectAttributesFile.RootDirectory = NULL;
        Status = NtLoadKey( &ObjectAttributesKey, &ObjectAttributesFile );
        TEST_STATUS( "SETUPCL: LoadUnloadHive - Failed to load the key." );
    }

    return( Status );
}

NTSTATUS
BackupRepairHives(
    )

/*++
===============================================================================
Routine Description:

    Make a double-secret copy of the repair hives in case we
    get halfway through operating on them and something goes wrong.

Arguments:

    None.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
NTSTATUS            Status = STATUS_SUCCESS;

    //
    // We'd like to make a backup copy of the repair hives before we mess with
    // them.  This way, if something goes wrong, we can restore the originals
    // and leave the repair hives with the old SID.
    //

    DbgPrint( "\nAbout to copy repair SAM hive.\n" );
    Status = FileCopy( TEXT( BACKUP_REPAIR_SAM_HIVE ),
                       TEXT( REPAIR_SAM_HIVE ) );
    TEST_STATUS_RETURN( "SETUPCL: BackupRepairHives - Failed to save backup repair SAM hive." );


    DbgPrint( "About to copy repair SECURITY hive.\n" );
    Status = FileCopy( TEXT( BACKUP_REPAIR_SECURITY_HIVE ),
                       TEXT( REPAIR_SECURITY_HIVE ) );
    TEST_STATUS_RETURN( "SETUPCL: BackupRepairHives - Failed to save backup repair SECURITY hive." );


    DbgPrint( "About to copy repair SOFTWARE hive.\n" );
    Status = FileCopy( TEXT( BACKUP_REPAIR_SOFTWARE_HIVE ),
                       TEXT( REPAIR_SOFTWARE_HIVE ) );
    TEST_STATUS_RETURN( "SETUPCL: BackupRepairHives - Failed to save backup repair SOFTWARE hive." );


    DbgPrint( "About to copy repair SYSTEM hive.\n" );
    Status = FileCopy( TEXT( BACKUP_REPAIR_SYSTEM_HIVE ),
                       TEXT( REPAIR_SYSTEM_HIVE ) );
    TEST_STATUS_RETURN( "SETUPCL: BackupRepairHives - Failed to save backup repair SYSTEM hive." );

    return( Status );
}



NTSTATUS
CleanupRepairHives(
    NTSTATUS RepairHivesSuccess
    )

/*++
===============================================================================
Routine Description:

    Decide whether or not to restore the repair hives from the backups
    we made.

    Delete the backups we made.

Arguments:

    None.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
NTSTATUS            Status = STATUS_SUCCESS;

    //
    // See if we need to restore the repair hives from the backups
    // we made.
    //
    if( !NT_SUCCESS(RepairHivesSuccess) ) {

        //
        // Replace the repair hives with the backups.  This will "undo"
        // any problems that happened while we were trying to update
        // the domain SID in the repair hives.
        //
        DbgPrint( "About to restore from backup repair hives.\n" );

        Status = FileCopy( TEXT( REPAIR_SAM_HIVE ),
                           TEXT( BACKUP_REPAIR_SAM_HIVE ) );
        TEST_STATUS_RETURN( "SETUPCL: CleanupRepairHives - Failed to restore SAM hive from backup." );


        Status = FileCopy( TEXT( REPAIR_SECURITY_HIVE ),
                           TEXT( BACKUP_REPAIR_SECURITY_HIVE ) );
        TEST_STATUS_RETURN( "SETUPCL: CleanupRepairHives - Failed to restore SECURITY hive from backup." );


        Status = FileCopy( TEXT( REPAIR_SOFTWARE_HIVE ),
                           TEXT( BACKUP_REPAIR_SOFTWARE_HIVE ) );
        TEST_STATUS_RETURN( "SETUPCL: CleanupRepairHives - Failed to restore SOFTWARE hive from backup." );


        Status = FileCopy( TEXT( REPAIR_SYSTEM_HIVE ),
                           TEXT( BACKUP_REPAIR_SYSTEM_HIVE ) );
        TEST_STATUS_RETURN( "SETUPCL: CleanupRepairHives - Failed to restore SYSTEM hive from backup." );

    }

    //
    // Delete the backups of the repair hives.
    //
    DbgPrint( "About to delete backup repair hives.\n" );

    Status = FileDelete( TEXT( BACKUP_REPAIR_SAM_HIVE ) );
    TEST_STATUS( "SETUPCL: CleanupRepairHives - Failed to delete backup repair SAM hive." );

    Status = FileDelete( TEXT( BACKUP_REPAIR_SECURITY_HIVE ) );
    TEST_STATUS( "SETUPCL: CleanupRepairHives - Failed to delete backup repair SECURITY hive." );

    Status = FileDelete( TEXT( BACKUP_REPAIR_SOFTWARE_HIVE ) );
    TEST_STATUS( "SETUPCL: CleanupRepairHives - Failed to delete backup repair SOFTWARE hive." );

    Status = FileDelete( TEXT( BACKUP_REPAIR_SYSTEM_HIVE ) );
    TEST_STATUS( "SETUPCL: CleanupRepairHives - Failed to delete backup repair SYSTEM hive." );

    return( Status );
}


NTSTATUS
TestSetSecurityObject(
    HANDLE  handle
    )
/*++
===============================================================================
Routine Description:

    This function will read security information from the object.  It
    will then see if that security info contains any instances of the
    old SID.  If we find any, we'll replace them with the new SID.

Arguments:

    hKey         - Handle of the object we're operating on.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
NTSTATUS             Status = STATUS_SUCCESS;
PSECURITY_DESCRIPTOR pSD;
ULONG                ResultLength,
                     ShadowLength;
INT                  i;
                                    
    //
    // Find out how big the descriptor is.
    //
    Status = NtQuerySecurityObject( handle,
                                    ALL_SECURITY_INFORMATION,
                                    NULL,
                                    0,
                                    &ShadowLength );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        DbgPrint( "SETUPCL: TestSetSecurityObject - Failed to query object security for size (%lx)\n", Status);
        return( Status );
    }

    //
    // Allocate our buffer.
    //
    pSD = (PSECURITY_DESCRIPTOR)RtlAllocateHeap( RtlProcessHeap(),
                                                 0,
                                                 ShadowLength + 0x10 );
    if( !pSD ) {
        return STATUS_NO_MEMORY;
    }

    //
    // Load the security info, whack it, and write it back out.
    //
    Status = NtQuerySecurityObject( handle,
                                    ALL_SECURITY_INFORMATION,
                                    pSD,
                                    ShadowLength + 0x10,
                                    &ResultLength );
    TEST_STATUS( "SETUPCL: TestSetSecurityObject - Failed to query security info." );

    Status = FindAndReplaceBlock( (PUCHAR)pSD,
                                  ShadowLength,
                                  (PUCHAR)G_OldSid + (SID_SIZE - 0xC),
                                  (PUCHAR)G_NewSid + (SID_SIZE - 0xC),
                                  0xC );
    if( NT_SUCCESS( Status ) ) {

        //
        // We hit.  Write out the new security info.
        //
        Status = NtSetSecurityObject( handle,
                                      ALL_SECURITY_INFORMATION,
                                      pSD );
        TEST_STATUS( "SETUPCL: TestSetSecurityObject - Failed to set security info." );
    }

    //
    // Clean up.
    //
    RtlFreeHeap( RtlProcessHeap(),
                 0,
                 pSD );

    return( STATUS_SUCCESS );
}


NTSTATUS
SetKeySecurityRecursive(
    HANDLE  hKey
    )
/*++
===============================================================================
Routine Description:

    Set security on a registry tree.

Arguments:

    hKey         - Handle of the key we're operating on.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    PKEY_FULL_INFORMATION   FullKeyInfo;
    PKEY_BASIC_INFORMATION  BasicKeyInfo;
    OBJECT_ATTRIBUTES       Obja;
    UNICODE_STRING          UnicodeString;
    HANDLE                  hKeyChild;
    ULONG                   ResultLength;
    DWORD                   dwNumSubKeys;

    Status = TestSetSecurityObject( hKey );
    TEST_STATUS( "SETUPCL: SetKeySecurityRecursive - Failed call out to TestSetSecurityObject()." );

    //
    // Alocate a buffer for KEY_FULL_INFORMATION
    //
    FullKeyInfo = (PKEY_FULL_INFORMATION)RtlAllocateHeap( RtlProcessHeap(),
                                                      0,
                                                      FULL_INFO_BUFFER_SIZE );
    if (FullKeyInfo)
    {

        Status = NtQueryKey( hKey,
                             KeyFullInformation,
                             FullKeyInfo,
                             FULL_INFO_BUFFER_SIZE,
                             &ResultLength);
        
        //
        // Even if the call above failed this will be caught below.
        //
        dwNumSubKeys = FullKeyInfo->SubKeys;

        //
        // Free the memory right away after getting the number of subkeys.
        //    
        RtlFreeHeap( RtlProcessHeap(),
                     0,
                     FullKeyInfo );

        if (NT_SUCCESS(Status))
        {
            //
            // Alocate a buffer for KEY_BASIC_INFORMATION
            //
            BasicKeyInfo = (PKEY_BASIC_INFORMATION)RtlAllocateHeap( RtlProcessHeap(),
                                                                    0,
                                                                    BASIC_INFO_BUFFER_SIZE );
            if (BasicKeyInfo)
            {
                DWORD dwSubKeyCount;            
                for ( dwSubKeyCount = 0; dwSubKeyCount < dwNumSubKeys; dwSubKeyCount++ )
                {
                    Status = NtEnumerateKey( hKey,
                                             dwSubKeyCount,
                                             KeyBasicInformation,
                                             BasicKeyInfo,
                                             BASIC_INFO_BUFFER_SIZE,
                                             &ResultLength );

                    if (NT_SUCCESS(Status)) 
                    {
                        //
                        // Zero-terminate the subkey name just in case.
                        //
                        BasicKeyInfo->Name[BasicKeyInfo->NameLength/sizeof(WCHAR)] = 0;

                        //
                        // Generate a handle for this child key and call ourselves again.
                        //
                        INIT_OBJA( &Obja, &UnicodeString, BasicKeyInfo->Name );
                        Obja.RootDirectory = hKey;
                        Status = NtOpenKey( &hKeyChild,
                                            KEY_ALL_ACCESS | ACCESS_SYSTEM_SECURITY,
                                            &Obja );

                        if ( NT_SUCCESS(Status) ) 
                        {
                            Status = SetKeySecurityRecursive( hKeyChild );
                            NtClose( hKeyChild );
                        }
                        else
                        {
                            TEST_STATUS( "SETUPCL: SetKeySecurityRecursive - Failed to open child key." );
                        }
                    }
                    else
                    {
                        TEST_STATUS( "SETUPCL: SetKeySecurityRecursive - Failed to enumerate key." );
                    }
                }
            
                //
                // Free the memory held for the children
                //    
                RtlFreeHeap( RtlProcessHeap(),
                             0,
                             BasicKeyInfo );
            }
            else
            {
                TEST_STATUS( "SETUPCL: SetKeySecurityRecursive - Out of memory when allocating BasicKeyInfo." );
            }
        }
        else
        {
            TEST_STATUS( "SETUPCL: SetKeySecurityRecursive - Failed to query full key information." );
        }
    }
    else
    {
        TEST_STATUS( "SETUPCL: SetKeySecurityRecursive - Out of memory when allocating FullKeyInfo." );
    }

    return( Status );
}


NTSTATUS
CopyKeyRecursive(
    HANDLE  hKeyDst,
    HANDLE  hKeySrc
    )
/*++
===============================================================================
Routine Description:

    Copy a registry key (and all its subkeys) to a new key.
Arguments:

    hKeyDst      - Handle of the new key we're going to create.
    hKeySrc      - Handle of the key we're copying.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
    NTSTATUS             Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES    ObjaSrc, 
                         ObjaDst;
    UNICODE_STRING       UnicodeStringSrc, 
                         UnicodeStringDst, 
                         UnicodeStringValue;
    HANDLE               hKeySrcChild = NULL,
                         hKeyDstChild = NULL;
    ULONG                ResultLength, 
                         BufferLength,
                         Index;
    WCHAR                ValueBuffer[FULL_INFO_BUFFER_SIZE],
                         TmpChar;
    PSECURITY_DESCRIPTOR pSD = NULL;

    PKEY_BASIC_INFORMATION      KeyInfo;
    PKEY_VALUE_FULL_INFORMATION ValueInfo;                     
    

    //
    // Enumerate all keys in the source key and recursively create
    // all the subkeys
    //
    KeyInfo = (PKEY_BASIC_INFORMATION) ValueBuffer;
    
    for( Index = 0; ; Index++ ) 
    {
        Status = NtEnumerateKey( hKeySrc, Index, KeyBasicInformation, ValueBuffer, sizeof( ValueBuffer ), &ResultLength );
       
        if ( !NT_SUCCESS(Status) ) 
        {
            if( Status == STATUS_NO_MORE_ENTRIES) 
            {
                Status = STATUS_SUCCESS;
            }
            else 
            {
                PRINT_STATUS( "SETUPCL: CopyKeyRecursive - failed to enumerate src keys." );
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // Generate key handles for these children and call ourselves again.
        //
        INIT_OBJA( &ObjaSrc, &UnicodeStringSrc, KeyInfo->Name );
        ObjaSrc.RootDirectory = hKeySrc;
        
        Status = NtOpenKey( &hKeySrcChild, KEY_ALL_ACCESS | ACCESS_SYSTEM_SECURITY, &ObjaSrc );
        
        if ( NT_SUCCESS(Status) )
        {
            Status = NtQuerySecurityObject( hKeySrcChild, ALL_SECURITY_INFORMATION, NULL, 0, &BufferLength );

            if ( Status == STATUS_BUFFER_TOO_SMALL ) 
            {
                //
                // Allocate our buffer.
                //
                if ( pSD = (PSECURITY_DESCRIPTOR)RtlAllocateHeap( RtlProcessHeap(), 0, BufferLength ) )
                {
                    //
                    // Load the security info from the sources key.
                    //
                    Status = NtQuerySecurityObject( hKeySrcChild,
                                                    ALL_SECURITY_INFORMATION,
                                                    pSD,
                                                    BufferLength,
                                                    &ResultLength );
                }
                else
                {
                    Status = STATUS_NO_MEMORY;
                }
            }
            else
            {
                TEST_STATUS( "SETUPCL: CopyKeyRecursive - Failed to query object security for size.");
            }

            if ( NT_SUCCESS(Status) )
            {
                INIT_OBJA( &ObjaDst, &UnicodeStringDst, KeyInfo->Name );
                
                ObjaDst.RootDirectory       = hKeyDst;
                ObjaDst.SecurityDescriptor  = pSD;
                
                Status = NtCreateKey( &hKeyDstChild,
                                      KEY_ALL_ACCESS | ACCESS_SYSTEM_SECURITY,
                                      &ObjaDst,
                                      0,
                                      NULL,
                                      REG_OPTION_NON_VOLATILE,
                                      NULL );

                if ( NT_SUCCESS(Status) )
                {
                    // Call ourselves to copy the child keys.
                    //
                    Status = CopyKeyRecursive( hKeyDstChild, hKeySrcChild );
                    TEST_STATUS("SETUPCL: CopyKeyRecursive - Recursive call failed.");
                    
                    NtClose( hKeyDstChild );
                }
                else
                {
                    PRINT_STATUS( "SETUPCL: CopyKeyRecursive - Failed to create destination child key." );
                }
            }
            else
            {
                PRINT_STATUS( "SETUPCL: CopyKeyRecursive - Failed to get key security descriptor." );
            }
            
            // If we allocated a buffer for the security descriptor, free it now.
            //
            if ( pSD )
            {
                RtlFreeHeap( RtlProcessHeap(), 0, pSD );
                pSD = NULL;
            }
            
            NtClose( hKeySrcChild );
        }
        else
        {
            PRINT_STATUS( "SETUPCL: CopyKeyRecursive - Failed to open source child key." );
        }
    }

    //
    // We don't really care about the return value here since even if something above failed 
    // for some reason, we should still do the copy for the values in this key.
    //

    //
    // Enumerate all values in the source key and create all the values
    // in the destination key
    //
    ValueInfo = (PKEY_VALUE_FULL_INFORMATION) ValueBuffer;
    
    for( Index = 0; ; Index++ ) 
    {
        // Zero the buffer in between each iteration.
        //
        RtlZeroMemory( ValueBuffer, sizeof(ValueBuffer) ); 

        Status = NtEnumerateValueKey( hKeySrc, Index, KeyValueFullInformation, ValueBuffer, sizeof( ValueBuffer ), &ResultLength );
        
        if ( !NT_SUCCESS(Status) )
        {
            if ( Status == STATUS_NO_MORE_ENTRIES ) 
            {
                Status = STATUS_SUCCESS;
            }
            else 
            {
                PRINT_STATUS( "SETUPCL: CopyKeyRecursive - failed to enumerate src value keys." );
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case, init the
        // unicode string and restore the wchar we whacked.
        //

        //
        // ISSUE-2002/03/11-acosma - This is really funky. If we have a non-NULL terminated
        // string we will end up with a UnicodeString that is not NULL terminated and has an extra
        // character at the end. Maybe we should just increase the size of it by one to use the 
        // space where NULL should be as part of the string.
        //
        TmpChar = ValueInfo->Name[ValueInfo->NameLength/sizeof(WCHAR)];
        ValueInfo->Name[ValueInfo->NameLength/sizeof(WCHAR)] = 0;
        RtlInitUnicodeString( &UnicodeStringValue, ValueInfo->Name );
        ValueInfo->Name[ValueInfo->NameLength/sizeof(WCHAR)] = TmpChar;

        //
        // Create the destination value.
        //
        Status = NtSetValueKey( hKeyDst,
                                &UnicodeStringValue,
                                ValueInfo->TitleIndex,
                                ValueInfo->Type,
                                (PBYTE)ValueInfo + ValueInfo->DataOffset,
                                ValueInfo->DataLength );
        if( !NT_SUCCESS(Status) ) {
            PRINT_STATUS( "SETUPCL: CopyKeyRecursive - failed to set destination value key." );
            break;
        }
    }
    
    return( Status );
}


NTSTATUS
CopyRegKey(
    IN WCHAR    *TargetName,
    IN WCHAR    *SourceName,
    IN HANDLE   hParentKey  OPTIONAL
    )
/*++
===============================================================================
Routine Description:

    Copy a registry key (and all its subkeys) to a new key.
Arguments:

    TargetName      - The name of the new key we're going to create.
    SourceName      - The name of the key we're copying.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
    NTSTATUS             Status = STATUS_SUCCESS;
    HANDLE               hKeySrc,
                         hKeyDst;
    UNICODE_STRING       UnicodeString;
    OBJECT_ATTRIBUTES    ObjaSrc, 
                         ObjaDst;
    ULONG                BufferLength,
                         ResultLength;
    PSECURITY_DESCRIPTOR pSD = NULL;
    
    // Generate key handle for source key.
    //    
    INIT_OBJA( &ObjaSrc, &UnicodeString, SourceName );
    
    if ( hParentKey ) 
    {
        ObjaSrc.RootDirectory = hParentKey;
    }
    Status = NtOpenKey( &hKeySrc, KEY_ALL_ACCESS | ACCESS_SYSTEM_SECURITY, &ObjaSrc );
    
    if ( NT_SUCCESS( Status ) )
    {
        // Find out how big the descriptor is.
        //
        Status = NtQuerySecurityObject( hKeySrc, ALL_SECURITY_INFORMATION, NULL, 0, &BufferLength );

        if ( Status == STATUS_BUFFER_TOO_SMALL ) 
        {
            // Allocate the buffer for the security descriptor.
            //
            if ( pSD = (PSECURITY_DESCRIPTOR)RtlAllocateHeap( RtlProcessHeap(), 0, BufferLength ) )
            {
                // Load the security info into the buffer.
                //
                Status = NtQuerySecurityObject( hKeySrc, ALL_SECURITY_INFORMATION, pSD, BufferLength, &ResultLength );
            }
            else
            {
                Status = STATUS_NO_MEMORY;
            }
        }
        else
        {
            TEST_STATUS( "SETUPCL: CopyRegKey - Failed to query object security for size.");
        }
        
        if ( NT_SUCCESS(Status) )
        {
            INIT_OBJA( &ObjaDst, &UnicodeString, TargetName );
            ObjaDst.SecurityDescriptor = pSD;

            if ( hParentKey ) 
            {
                ObjaDst.RootDirectory = hParentKey;
            }

            // Create the destination key.
            //
            Status = NtCreateKey( &hKeyDst,
                                  KEY_ALL_ACCESS | ACCESS_SYSTEM_SECURITY,
                                  &ObjaDst,
                                  0,
                                  NULL,
                                  REG_OPTION_NON_VOLATILE,
                                  NULL );
            
            if ( NT_SUCCESS(Status) )
            {
                Status = CopyKeyRecursive( hKeyDst, hKeySrc );
                // Close the destination key.
                //
                NtClose( hKeyDst );
            }
            else
            {
                PRINT_STATUS( "SETUPCL: CopyRegKey - Failed to create destination key.");
            }
        }
        else
        {
            PRINT_STATUS("SETUPCL: CopyRegKey - Failed to get key security descriptor.");
        }
        
        // If we allocated a buffer for the security descriptor, free it now.
        //
        if ( pSD )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, pSD );
            pSD = NULL;
        }

        // Close the source key.
        //
        NtClose( hKeySrc );
    }
    else
    {
        PRINT_STATUS( "SETUPCL: CopyRegKey - Failed to open source key." );
    }
    
    return( Status );
}



//
// ISSUE-2002/02/26-brucegr,jcohen - Dead Code!  Nobody calls MoveRegKey!
//
NTSTATUS
MoveRegKey(
    IN WCHAR    *TargetName,
    IN WCHAR    *SourceName
    )
/*++
===============================================================================
Routine Description:

    Move a registry key (and all its subkeys) to a new key.
Arguments:

    TargetName      - The name of the new key we're going to create.
    SourceName      - The name of the key we're copying.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
NTSTATUS            Status;

    //
    // Copy the original..
    //
    Status = CopyRegKey( TargetName, SourceName, NULL );
    TEST_STATUS_RETURN( "SETUPCL: MoveRegKey - CopyRegKey failed!" );

    //
    // Delete the original key.
    //
    Status = DeleteKey( SourceName );
    TEST_STATUS( "SETUPCL: MoveRegKey - DeleteKey failed!" );


    return( Status );
}




NTSTATUS
FindAndReplaceBlock(
    IN PCHAR    Block,
    IN ULONG    BlockLength,
    IN PCHAR    OldValue,
    IN PCHAR    NewValue,
    IN ULONG    ValueLength
    )

/*++
===============================================================================
Routine Description:

    This function will go search Block for any and all instances of OldValue.
    If he finds one, he'll replace that section with NewValue.

Arguments:

    Block           - A block of memory that we'll be searching
    BlockLength     - How big is Block
    OldValue        - What value are we looking for?
    NewValue        - What's the new value we'll be inserting?
    ValueLength     - How long are the Old and New values?

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
ULONG       i;
BOOLEAN     We_Hit = FALSE;

    //
    // Make sure the lengths make sense...  If not, we're done.
    //
    if( BlockLength < ValueLength ) {
#if 0
        DbgPrint( "SETUPCL: FindAndReplaceBlock - Mismatched data lengths!\n\tBlockLength: (%lx)\n\tValueLength: (%lx)\n", BlockLength, ValueLength );
#endif
        return( STATUS_UNSUCCESSFUL );
    }

    //
    // We start at the beginning and search for any instances of OldValue.
    //
    i = 0;
    while( i <= (BlockLength - ValueLength) ) {
        if( !memcmp( (Block + i), OldValue, ValueLength ) ) {

            //
            // Record that we hit at least once.
            //
            We_Hit = TRUE;

            //
            // We got a hit.  Insert NewValue.
            //
            memcpy( (Block + i), NewValue, ValueLength );

            //
            // Let's skip checking this block.  We're asking for trouble
            // if we don't.
            //
            i = i + ValueLength;
        } else {
            i++;
        }
    }

    if( !We_Hit ) {
        //
        // We didn't find a match.  It's likely non-fatal,
        // but we need to tell our caller.
        //
#if 0
        DbgPrint( "SETUPCL: FindAndReplaceBlock - We didn't find any hits in this data block.\n" );
#endif
        return( STATUS_UNSUCCESSFUL );
    } else {
#if 0
        DbgPrint( "SETUPCL: FindAndReplaceBlock - We hit in this data block.\n" );
#endif
        return( STATUS_SUCCESS );
    }

}

NTSTATUS
StringSwitchString(
    PWSTR   BaseString,
    DWORD   cBaseStringLen,
    PWSTR   OldSubString,
    PWSTR   NewSubString
    )

/*++
===============================================================================
Routine Description:

    This function search BaseString for any instance of OldSubString.  If
    found, he'll replace that instance with NewSubString.  Note that
    OldSubString and NewSubString can be different lengths.

Arguments:

    BaseString   - This is the string we'll be operating on.
    OldSubString - String we're looking for
    NewSubString - String we'll be inserting

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
    NTSTATUS            Status = STATUS_SUCCESS;
    PWSTR               Index;
    WCHAR               New_String[MAX_PATH] = {0};
    WCHAR               TmpChar;

    Index = wcsstr( BaseString, OldSubString );

    if( !Index ) {
        //
        // OldSubString isn't present.
        //
        return( STATUS_UNSUCCESSFUL );
    }

    //
    // Copy the first part of the original string into New_String.
    //
    TmpChar = *Index;
    *Index = 0;
    wcsncpy( New_String, BaseString, AS(New_String) - 1 );

    //
    // Now concatenate the new sub string...
    //
    wcsncpy( New_String + wcslen(New_String), NewSubString, AS(New_String) - wcslen(New_String) - 1 );

    //
    // Jump past the OldSubString, and cat the remaining BaseString
    // onto the end.
    //
    Index = Index + wcslen( OldSubString );

    wcsncpy( New_String + wcslen(New_String), Index, AS(New_String) - wcslen(New_String) - 1);
    
    memset( BaseString, 0, cBaseStringLen * sizeof(WCHAR) );
    wcsncpy( BaseString, New_String, cBaseStringLen - 1 );

    return( STATUS_SUCCESS );
}




NTSTATUS
SiftKeyRecursive(
    HANDLE hKey,
    int    indent
    )

/*++
===============================================================================
Routine Description:

    This function check all of the subkeys and any valuekeys for:
    - keys with the old SID name
        In this case, we rename the key with the appropriate new SID name.

    - value keys with the old SID value
        In this case, we substitute the new SID values for the old SID values.

Arguments:

    hKey        - Handle to the key we're about to recurse into.
    indent      - For debug.  Number of spaces to indent any messages.
                  This helps us determine which recurse we're in.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
NTSTATUS            Status = STATUS_SUCCESS;
OBJECT_ATTRIBUTES   Obja;
UNICODE_STRING      UnicodeString;
HANDLE              hKeyChild;
ULONG               ResultLength, Index;
PKEY_BASIC_INFORMATION       KeyInfo;
PKEY_VALUE_BASIC_INFORMATION ValueInfo;
int                 i;


    // DisplayUI
    //
    DisplayUI();

    //
    // Enumerate all keys in the source key and recursively create
    // all the subkeys
    //
    KeyInfo = (PKEY_BASIC_INFORMATION)RtlAllocateHeap( RtlProcessHeap(),
                                                       0,
                                                       BASIC_INFO_BUFFER_SIZE );
    if( KeyInfo == NULL ) {
#if I_AM_MATTH
        DbgPrint( "SETUPCL: SiftKeyRecursive - Call to RtlAllocateHeap failed!\n" );
#endif
        return( STATUS_NO_MEMORY );
    }

    Index = 0;
    while( 1 ) {
        Status = NtEnumerateKey( hKey,
                                 Index,
                                 KeyBasicInformation,
                                 KeyInfo,
                                 BASIC_INFO_BUFFER_SIZE,
                                 &ResultLength );

        if(!NT_SUCCESS(Status)) {
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            } else {
                TEST_STATUS( "SETUPCL: SiftKeyRecursive - Failure during enumeration of subkeys." );
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        KeyInfo->Name[KeyInfo->NameLength/sizeof(WCHAR)] = 0;

        memset( TmpBuffer, 0, sizeof(TmpBuffer) );
        wcsncpy( TmpBuffer, KeyInfo->Name, AS(TmpBuffer) - 1 );
        Status = StringSwitchString( TmpBuffer,
                                     AS( TmpBuffer ),
                                     G_OldSidSubString,
                                     G_NewSidSubString );
        
        if( NT_SUCCESS( Status ) ) {
            //
            // We need to rename this key.  First do the
            // copy, then a delete.
            //
#if I_AM_MATTH
for( i = 0; i < indent; i++ )
    DbgPrint( " " );
            DbgPrint( "SETUPCL: SiftKeyRecursive - About to copy subkey:\n" );
            DbgPrint( "\t%ws\n\tto\n\t%ws\n", KeyInfo->Name, TmpBuffer );
#endif
            Status = CopyRegKey( TmpBuffer,
                                 KeyInfo->Name,
                                 hKey );
            if( !NT_SUCCESS( Status ) ) {
                TEST_STATUS( "SETUPCL: SiftKeyRecursive - failed call to CopyRegKey." );
                break;
            }
            DeleteKeyRecursive( hKey, KeyInfo->Name );
            
            // Flush the key to make sure that everything gets written out to disk. 
            //
            NtFlushKey(hKey);
            //
            // Now reset our index since we've just changed the ordering
            // of keys.
            //
            Index = 0;
            continue;
        }

        //
        // We didn't rename him, so let's recursively call ourselves
        // on the subkey key.
        //
#if I_AM_MATTH
        for( i = 0; i < indent; i++ )
            DbgPrint( " " );
        DbgPrint( "SETUPCL: SiftKeyRecursive - About to check subkey: %ws\n",
                  KeyInfo->Name );
#endif
        
        //
        // Generate a handle for this child key and call ourselves again.
        //
        INIT_OBJA( &Obja, &UnicodeString, KeyInfo->Name );
        Obja.RootDirectory = hKey;
        Status = NtOpenKey( &hKeyChild,
                            KEY_ALL_ACCESS | ACCESS_SYSTEM_SECURITY,
                            &Obja );
        TEST_STATUS_RETURN( "SETUPCL: SiftKeyRecursive - Failed to open child key." );

        Status = SiftKeyRecursive( hKeyChild, indent + 1 );

        NtClose( hKeyChild );

        Index++;
    }

    //
    // Enumerate all values in the key and search for instances
    // of the old SID.
    //
    ValueInfo = (PKEY_VALUE_BASIC_INFORMATION)KeyInfo;
    for( Index = 0; ; Index++ ) {
        Status = NtEnumerateValueKey( hKey,
                                      Index,
                                      KeyValueBasicInformation,
                                      ValueInfo,
                                      BASIC_INFO_BUFFER_SIZE,
                                      &ResultLength );
        if(!NT_SUCCESS(Status)) {
            if(Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            } else {
                TEST_STATUS( "SETUPCL: SiftKeyRecursive - Failure during enumeration of value keys." );
            }
            break;
        }

        //
        // Zero-terminate the subkey name just in case.
        //
        ValueInfo->Name[ValueInfo->NameLength/sizeof(WCHAR)] = 0;

        //
        // ISSUE - 2002/03/01-brucegr,acosma: We don't handle value names containing the old SID.
        //

        //
        // We'll probably fail this call because the key probably
        // doesn't contain any SID info.  For that reason, don't
        // treat failures here as fatal...
        //
        if( ValueInfo->Type == REG_SZ ) {
            //
            // ISSUE - 2002/03/01-brucegr,acosma: We should handle REG_MULTI_SZ like a string instead of binary data
            //
            Status = ReadSetWriteKey( NULL,              // No parent Name.
                                      hKey,              // Parent handle.
                                      ValueInfo->Name,   // SubKey name
                                      (PUCHAR)G_OldSidSubString,
                                      (PUCHAR)G_NewSidSubString,
                                      0xC,
                                      ValueInfo->Type );
            
        } else {
            Status = ReadSetWriteKey( NULL,              // No parent Name.
                                      hKey,              // Parent handle.
                                      ValueInfo->Name,   // SubKey name
                                      (PUCHAR)G_OldSid + (SID_SIZE - 0xC),
                                      (PUCHAR)G_NewSid + (SID_SIZE - 0xC),
                                      0xC,
                                      ValueInfo->Type );
        }

#if I_AM_MATTH
        if( NT_SUCCESS( Status ) ) {
            for( i = 0; i < indent; i++ )
                DbgPrint( " " );
            DbgPrint( "SETUPCL: SiftKeyRecursive - updated subkey: %ws\n",
                      ValueInfo->Name );
#if 0
        } else {
            for( i = 0; i < indent; i++ )
                DbgPrint( " " );
            DbgPrint( "SETUPCL: SiftKeyRecursive - did not update subkey: %ws\n",
                      ValueInfo->Name );
#endif
        }
#endif

    }

    RtlFreeHeap( RtlProcessHeap(),
                 0,
                 KeyInfo );

    return( Status );    
}


NTSTATUS
SiftKey(
    PWSTR   KeyName
    )

/*++
===============================================================================
Routine Description:

    This function opens a handle to the key specified in KeyName, the
    calls SiftKeyRecursive with it.

Arguments:

    KeyName     - Name of the key we're about to operate on.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
NTSTATUS            Status = STATUS_SUCCESS;
HANDLE              hKey;
UNICODE_STRING      UnicodeString;
OBJECT_ATTRIBUTES   Obja;

    //
    // Open the key.
    //
    INIT_OBJA( &Obja, &UnicodeString, KeyName );
    Status = NtOpenKey( &hKey,
                        KEY_ALL_ACCESS | ACCESS_SYSTEM_SECURITY,
                        &Obja );
    TEST_STATUS( "SETUPCL: SiftKey - Failed to open key." );

    //
    // Fix all instances of the SID in this key and all
    // it's children.
    //
    Status = SiftKeyRecursive( hKey, 0 );

    //
    // Now fix ACLs on this key and all its children.
    //
    SetKeySecurityRecursive( hKey );

    NtClose( hKey );

    return( Status );
}


NTSTATUS
DriveLetterToNTPath(
    IN WCHAR      DriveLetter,
    IN OUT PWSTR  NTPath,
    IN DWORD      cNTPathLen
    )

/*++
===============================================================================
Routine Description:

    This function will convert a driveletter to an NT path.

Arguments:

    DriveLetter     - DriveLetter.

    NTPath          - The ntpath that corresponds to the given drive letter.

Return Value:

    NTSTATUS.

===============================================================================
--*/

{
NTSTATUS            Status = STATUS_SUCCESS;
OBJECT_ATTRIBUTES   ObjectAttributes;
HANDLE              DosDevicesDir,
                    Handle;
CHAR                DirInfoBuffer[1024],
                    LinkTargetBuffer[1024];
POBJECT_DIRECTORY_INFORMATION DirInfo;
UNICODE_STRING      UnicodeString,
                    LinkTarget,
                    DesiredPrefix1,
                    DesiredPrefix2,
                    LinkTypeName;
ULONG               Context,
                    Length;


    //
    // Open \DosDevices
    //
    RtlInitUnicodeString(&UnicodeString,L"\\DosDevices");
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE | OBJ_OPENIF | OBJ_PERMANENT,
        NULL,
        NULL
        );

    Status = NtOpenDirectoryObject(&DosDevicesDir,DIRECTORY_QUERY,&ObjectAttributes);
    TEST_STATUS_RETURN( "SETUPCL: DriveLetterToNTPath - Failed to open DosDevices." );

    LinkTarget.Buffer = (PVOID)LinkTargetBuffer;
    RtlInitUnicodeString(&LinkTypeName,L"SymbolicLink");

    DirInfo = (POBJECT_DIRECTORY_INFORMATION)DirInfoBuffer;

    //
    // Query first object in \DosDevices directory
    //
    Status = NtQueryDirectoryObject( DosDevicesDir,
                                     DirInfo,
                                     sizeof(DirInfoBuffer),
                                     TRUE,
                                     TRUE,
                                     &Context,
                                     &Length );

    while(NT_SUCCESS(Status)) {
        //
        // Terminate these guys just in case...
        //
        DirInfo->Name.Buffer[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
        DirInfo->TypeName.Buffer[DirInfo->TypeName.Length/sizeof(WCHAR)] = 0;


//        DbgPrint( "SETUPCL: DriveLetterToNTPath - About to examine an object: %ws\n", DirInfo->Name.Buffer );

        //
        // Make sure he's a drive letter.
        // Make sure he's our drive letter.
        // Make sure he's a symbolic link.
        //
        if( (DirInfo->Name.Buffer[1] == L':')        &&
            (DirInfo->Name.Buffer[0] == DriveLetter) && 
            (RtlEqualUnicodeString(&LinkTypeName,&DirInfo->TypeName,TRUE)) ) {

//            DbgPrint( "\tSETUPCL: DriveLetterToNTPath - Object: %ws is a symbolic link\n", DirInfo->Name.Buffer );

            InitializeObjectAttributes(
                &ObjectAttributes,
                &DirInfo->Name,
                OBJ_CASE_INSENSITIVE,
                DosDevicesDir,
                NULL
                );

            Status = NtOpenSymbolicLinkObject( &Handle,
                                               SYMBOLIC_LINK_ALL_ACCESS,
                                               &ObjectAttributes );
            if(NT_SUCCESS(Status)) {

                LinkTarget.Length = 0;
                LinkTarget.MaximumLength = sizeof(LinkTargetBuffer);

                Status = NtQuerySymbolicLinkObject( Handle,
                                                    &LinkTarget,
                                                    NULL );
                NtClose(Handle);

                TEST_STATUS( "\tSETUPCL: DriveLetterToNTPath - We failed to queried him.\n" );

                LinkTarget.Buffer[LinkTarget.Length/sizeof(WCHAR)] = 0;
//                DbgPrint( "\tSETUPCL: DriveLetterToNTPath - We queried him and his name is %ws.\n", LinkTarget.Buffer );

                //
                // Copy the buffer into out our path and break from the loop.
                //
                //
                // NTRAID#NTBUG9-545988-2002/02/26-brucegr,jcohen - Buffer overrun
                //
                memset( NTPath, 0, cNTPathLen * sizeof(WCHAR) );
                wcsncpy( NTPath, LinkTarget.Buffer, cNTPathLen - 1 );
                break;
            }
        }

        //
        // Query next object in \DosDevices directory
        //
        Status = NtQueryDirectoryObject( DosDevicesDir,
                                         DirInfo,
                                         sizeof(DirInfoBuffer),
                                         TRUE,
                                         FALSE,
                                         &Context,
                                         &Length );
    }

    NtClose(DosDevicesDir);

    return( STATUS_SUCCESS );
}


// If there are any problems with the Japanese build see nt\base\fs\utils\ulib\src\basesys.cxx, around line 150
// to see what they did.

BOOL LoadStringResource(
                       PUNICODE_STRING  pUnicodeString,
                       INT              MsgId
                       )
/*++

Routine Description:

    This is a simple implementation of LoadString().

Arguments:

    usString        - Returns the resource string.
    MsgId           - Supplies the message id of the resource string.
  
Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{

    NTSTATUS        Status;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    ANSI_STRING     AnsiString;
          
    Status = RtlFindMessage( NtCurrentPeb()->ImageBaseAddress,
                             (ULONG_PTR) RT_MESSAGETABLE, 
                             0,
                             (ULONG)MsgId,
                             &MessageEntry
                           );

    if (!NT_SUCCESS( Status )) {
        return FALSE;
    }

    if (!(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE)) {
        RtlInitAnsiString( &AnsiString, (PCSZ)&MessageEntry->Text[ 0 ] );
        Status = RtlAnsiStringToUnicodeString( pUnicodeString, &AnsiString, TRUE );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
        }
    } else {
        //
        // ISSUE-2002/02/26-brucegr,jcohen - Doesn't check return code from RtlCreateUnicodeString
        //
        RtlCreateUnicodeString(pUnicodeString, (PWSTR)MessageEntry->Text);
    }
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\compname.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      compname.c
//
// Description:
//      This file has the dialog procedure for the computer name page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define TEXT_EXTENSION   _T("txt")

static TCHAR* StrTextFiles;
static TCHAR* StrAllFiles;
static TCHAR g_szTextFileFilter[MAX_PATH + 1];

//----------------------------------------------------------------------------
//
// Function: OnComputerNameInitDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnComputerNameInitDialog( IN HWND hwnd )
{
   HRESULT hrPrintf;
    //
    //  Load the resource strings
    //

    StrTextFiles = MyLoadString( IDS_TEXT_FILES );

    StrAllFiles  = MyLoadString( IDS_ALL_FILES  );

    //
    //  Build the text file filter string
    //

    //
    //  The question marks (?) are just placehoders for where the NULL char
    //  will be inserted.
    //

    hrPrintf=StringCchPrintf( g_szTextFileFilter, AS(g_szTextFileFilter),
               _T("%s(*.txt)?*.txt?%s(*.*)?*.*?"),
               StrTextFiles,
               StrAllFiles );

    ConvertQuestionsToNull( g_szTextFileFilter );

    //
    //  Set text limits on the edit boxes
    //

    SendDlgItemMessage(hwnd,
                       IDT_COMPUTERNAME,
                       EM_LIMITTEXT,
                       (WPARAM) MAX_COMPUTERNAME,
                       (LPARAM) 0);


}

//----------------------------------------------------------------------------
//
//  Function: GreyComputerNamePage
//
//  Purpose: This function is called at SETACTIVE time and whenever the
//           user chooses/clears the AutoComputerName check-box.  When
//           AutoComputerName is selected, nothing else is valid and
//           all the other controls must be greyed.
//
//           We also have to grey the RemoveButton if nothing is
//           selected in the list of computernames.
//
//----------------------------------------------------------------------------

VOID GreyComputerNamePage(HWND hwnd)
{
    BOOL bGrey = ! IsDlgButtonChecked(hwnd, IDC_AUTOCOMPUTERNAME);

    //
    // We grey out everything on this page if AutoComputerName is checked
    //

    EnableWindow(GetDlgItem(hwnd, IDC_COMPUTERTEXT),      bGrey);
    EnableWindow(GetDlgItem(hwnd, IDC_REMOVECOMPUTER),    bGrey);
    EnableWindow(GetDlgItem(hwnd, IDT_COMPUTERNAME),      bGrey);
    EnableWindow(GetDlgItem(hwnd, IDC_COMPUTERLIST),      bGrey);

    //
    //  If a computername has already been added and it is a sysprep,
    //  make sure the Add button stays greyed.  Else just do bGrey for them.
    //  Always make sure the import stays greyed on a sysprep.
    //
    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP ) {

        INT_PTR cListBox;

        EnableWindow( GetDlgItem( hwnd, IDC_LOADCOMPUTERNAMES ), FALSE );

        cListBox = SendDlgItemMessage( hwnd,
                                       IDC_COMPUTERLIST,
                                       LB_GETCOUNT,
                                       0,
                                       0 );

        if( cListBox == 0 ) {
            EnableWindow( GetDlgItem( hwnd, IDC_ADDCOMPUTER ), TRUE );
        }
        else {
            EnableWindow( GetDlgItem( hwnd, IDC_ADDCOMPUTER ), FALSE );
        }

    }
    else {

        EnableWindow( GetDlgItem( hwnd, IDC_ADDCOMPUTER ),       bGrey );
        EnableWindow( GetDlgItem( hwnd, IDC_LOADCOMPUTERNAMES ), bGrey );

    }

    //
    // See if the remove button should be greyed because nothing
    // is selected in the computerlist
    //

    if ( bGrey ) {

        INT_PTR idx = SendDlgItemMessage(
                        hwnd,
                        IDC_COMPUTERLIST,
                        LB_GETCURSEL,
                        (WPARAM) 0,
                        (LPARAM) 0);

        EnableWindow(GetDlgItem(hwnd, IDC_REMOVECOMPUTER), idx != LB_ERR);
    }
}

VOID OnComputerSelChange(HWND hwnd)
{
    GreyComputerNamePage(hwnd);

}

//----------------------------------------------------------------------------
//
//  Function: OnAddComputerName
//
//  Purpose: Called when user pushes the Add button or when the OnFinish
//           routine decides to do an auto-add.
//
//  Returns: TRUE if computername is now in the list
//           FALSE if the computername was invalid, the error is reported
//
//----------------------------------------------------------------------------

BOOL OnAddComputerName(HWND hwnd)
{
    TCHAR ComputerNameBuffer[MAX_COMPUTERNAME + 1];
    BOOL  bRet = TRUE;

    //
    // get the computername the user typed in
    //

    GetDlgItemText(hwnd,
                   IDT_COMPUTERNAME,
                   ComputerNameBuffer,
                   MAX_COMPUTERNAME + 1);

    if ( ! IsValidComputerName(ComputerNameBuffer) ) {
        ReportErrorId( hwnd,
                       MSGTYPE_ERR,
                       IDS_ERR_INVALID_COMPUTER_NAME,
                       IllegalNetNameChars );

        bRet = FALSE;

        goto FinishUp;
    }

    //
    // Cannot have dups
    //

    if ( FindNameInNameList(&GenSettings.ComputerNames,
                                            ComputerNameBuffer) >= 0 ) {
        SetDlgItemText(hwnd, IDT_COMPUTERNAME, _T("") );
        goto FinishUp;
    }

    //
    // Add the name to our global storage, display it in the listbox
    // and clear out the name the user typed
    //

    AddNameToNameList(&GenSettings.ComputerNames, ComputerNameBuffer);

    SendDlgItemMessage(hwnd,
                       IDC_COMPUTERLIST,
                       LB_ADDSTRING,
                       (WPARAM) 0,
                       (LPARAM) ComputerNameBuffer);

    SetDlgItemText(hwnd, IDT_COMPUTERNAME, _T("") );

    //
    //  If it is a sysprep, we can only allow one computer name so now that
    //  we have added it, grey out the Add button
    //
    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP ) {

        EnableWindow( GetDlgItem(hwnd, IDC_ADDCOMPUTER), FALSE );

    }

    //
    // Always put the focus back on the edit field
    //

FinishUp:
    SetFocus(GetDlgItem(hwnd, IDT_COMPUTERNAME));
    return bRet;
}

//-------------------------------------------------------------------------
//
//  Function: OnRemoveComputerName
//
//  Purpose: This function is called only by the ComputerName2 page.
//           It is called when the REMOVE button is pushed.
//
//           We figure out which computer name in the list-box is
//           currently selected, then it removes it from both the
//           display and our in-memory computer name list.
//
//-------------------------------------------------------------------------

VOID OnRemoveComputerName(HWND hwnd)
{
    TCHAR ComputerNameBuffer[MAX_COMPUTERNAME + 1];
    INT_PTR   idx, Count;

    //
    // Get users selection of the computername to remove
    //

    idx = SendDlgItemMessage(hwnd,
                             IDC_COMPUTERLIST,
                             LB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0);

    if ( idx == LB_ERR )
        return;

    //
    // Retrieve the name to remove from listbox
    //

    SendDlgItemMessage(hwnd,
                       IDC_COMPUTERLIST,
                       LB_GETTEXT,
                       (WPARAM) idx,
                       (LPARAM) ComputerNameBuffer);

    //
    // Remove the name from the listbox display
    //

    SendDlgItemMessage(hwnd,
                       IDC_COMPUTERLIST,
                       LB_DELETESTRING,
                       (WPARAM) idx,
                       (LPARAM) 0);

    //
    // Remove this computername from our data store
    //

    RemoveNameFromNameList(&GenSettings.ComputerNames, ComputerNameBuffer);

    //
    // Select a new entry
    //

    Count = SendDlgItemMessage(hwnd,
                               IDC_COMPUTERLIST,
                               LB_GETCOUNT,
                               (WPARAM) 0,
                               (LPARAM) 0);

    if ( Count ) {
        if ( idx >= Count )
            idx--;
        SendDlgItemMessage(hwnd,
                           IDC_COMPUTERLIST,
                           LB_SETCURSEL,
                           (WPARAM) idx,
                           (LPARAM) 0);
    }

    //
    // There might be nothing selected now
    //

    GreyComputerNamePage(hwnd);
}

//-------------------------------------------------------------------------
//
//  OnLoadComputerName
//
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//
//  Function: OnLoadComputerName
//
//  Purpose: This function is called only by the ComputerName2 page.
//           It is called when the LOAD button is pushed.
//
//           We query for the file containing a list of computernames
//           and load them into memory, and update the list-box
//           display of computernames.
//
//-------------------------------------------------------------------------

VOID OnLoadComputerNames(HWND hwnd)
{

    FILE          *fp;
    OPENFILENAME  ofn;
    DWORD         dwFlags;
    LPTSTR        lpComputerName;
    INT           iRet;
    INT           iComputerNameCount;


    TCHAR lpDirName[MAX_PATH]                       = _T("");
    TCHAR lpFileNameBuff[MAX_PATH]                  = _T("");
    TCHAR szComputerNameBuffer[MAX_COMPUTERNAME+1]  = _T("");


    dwFlags = OFN_HIDEREADONLY  |
              OFN_PATHMUSTEXIST |
              OFN_FILEMUSTEXIST;

    GetCurrentDirectory( MAX_PATH, lpDirName );

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hwnd;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = g_szTextFileFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0L;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = lpFileNameBuff;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = lpDirName;
    ofn.lpstrTitle        = NULL;
    ofn.Flags             = dwFlags;
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lpstrDefExt       = TEXT_EXTENSION;

    iRet = GetOpenFileName(&ofn);

    if( ! iRet ) {
        // ISSUE-2002/02/28-stelo - signal an error here
        return;
    }

    if ( (fp = _tfopen( lpFileNameBuff, TEXT("r"))) == NULL )
        // ISSUE-2002/02/28-stelo - signal an error here
        return;

    for( iComputerNameCount = 1;
         fgetws(szComputerNameBuffer, MAX_COMPUTERNAME+1, fp) != NULL;
         iComputerNameCount++ ) {

        lpComputerName = CleanSpaceAndQuotes( szComputerNameBuffer );

        if ( ! IsValidComputerName( lpComputerName ) ) {

            iRet = ReportErrorId( hwnd,
                                  MSGTYPE_YESNO,
                                  IDS_ERR_INVALID_COMPUTER_NAME_IN_FILE,
                                  iComputerNameCount,
                                  lpFileNameBuff );

            if( iRet == IDYES ) {
                continue;
            }
            else {
                break;
            }

        }

        //
        //  Make sure it isn't a duplicate, if not then add it to the namelist
        //

        if( FindNameInNameList( &GenSettings.ComputerNames,
                                lpComputerName ) < 0 ) {

            AddNameToNameList( &GenSettings.ComputerNames, lpComputerName );

            SendDlgItemMessage( hwnd,
                                IDC_COMPUTERLIST,
                                LB_ADDSTRING,
                                (WPARAM) 0,
                                (LPARAM) lpComputerName );

        }

    }

    fclose(fp);

}

//----------------------------------------------------------------------------
//
// Function: DisableControlsForSysprep
//
// Purpose:  Hides or shows the Computer name controls depending on if this
//           is a sysprep or not.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//             IN const BOOL bSysprep - whether this is a sysprep or not
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
DisableControlsForSysprep( IN HWND hwnd, IN const BOOL bSysprep )
{

    INT nCmdShow;

    if( bSysprep )
    {
        nCmdShow = SW_HIDE;
    }
    else
    {
        nCmdShow = SW_SHOW;
    }

    // ISSUE-2002/02/28-stelo - need to change the title on this page too depending if it is
    // a sysprep or not

    ShowWindow( GetDlgItem( hwnd, IDC_ADDCOMPUTER ), nCmdShow );
    ShowWindow( GetDlgItem( hwnd, IDC_REMOVECOMPUTER ), nCmdShow );
    ShowWindow( GetDlgItem( hwnd, IDC_LOADCOMPUTERNAMES ), nCmdShow );
    ShowWindow( GetDlgItem( hwnd, IDC_AUTOCOMPUTERNAME ), nCmdShow );
    ShowWindow( GetDlgItem( hwnd, IDC_COMPUTERPAGE_DESC1 ), nCmdShow );
    ShowWindow( GetDlgItem( hwnd, IDC_COMPUTERPAGE_DESC2 ), nCmdShow );
    ShowWindow( GetDlgItem( hwnd, IDC_COMPUTERS_TEXT ), nCmdShow );
    ShowWindow( GetDlgItem( hwnd, IDC_COMPUTERLIST ), nCmdShow );

}

//-------------------------------------------------------------------------
//
//  Function: OnSetActiveComputerName
//
//  Purpose: We empty anything currently in the computername listbox and
//           then re-populates it with the list of computernames in the
//           global structs.
//
//           Emptying and re-filling the computername display is necessary
//           because the user can go BACK and choose to edit a file.  When
//           we re-arrive at this page, we must ensure that the display
//           is re-set.
//
//-------------------------------------------------------------------------

VOID OnSetActiveComputerName(HWND hwnd)
{
    UINT   i, nNames;
    LPTSTR pNextName;


    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
    {
        DisableControlsForSysprep( hwnd, TRUE );
    }
    else
    {
        DisableControlsForSysprep( hwnd, FALSE );
    }


    //
    // Remove everything from the display
    //

    SendDlgItemMessage(hwnd,
                       IDC_COMPUTERLIST,
                       LB_RESETCONTENT,
                       (WPARAM) 0,
                       (LPARAM) 0);

    //
    // Now update the display of computernames
    //

    for ( i = 0, nNames = GetNameListSize(&GenSettings.ComputerNames);
          i < nNames;
          i++ )
    {

        pNextName = GetNameListName(&GenSettings.ComputerNames, i);

        SendDlgItemMessage(hwnd,
                           IDC_COMPUTERLIST,
                           LB_ADDSTRING,
                           (WPARAM) 0,
                           (LPARAM) pNextName);
    }

    //
    // Grey/ungrey stuff and set the AutoComputerName check-box
    //

    if( GenSettings.Organization[0] == _T('\0') ) {

        EnableWindow( GetDlgItem( hwnd, IDC_AUTOCOMPUTERNAME ), FALSE );

    }
    else {

        EnableWindow( GetDlgItem( hwnd, IDC_AUTOCOMPUTERNAME ), TRUE );

    }

    CheckDlgButton(hwnd,
                   IDC_AUTOCOMPUTERNAME,
                   GenSettings.bAutoComputerName ? BST_CHECKED
                                                 : BST_UNCHECKED);
    GreyComputerNamePage(hwnd);

    //
    // Fix wiz buttons
    //

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}

//-------------------------------------------------------------------------
//
//  Function: OnAutoComputerName
//
//  Purpose: Called when the user chooses/clears the AutoComputerName
//           checkbox.
//
//-------------------------------------------------------------------------

VOID OnAutoComputerName(HWND hwnd)
{
    GreyComputerNamePage(hwnd);
}

//-------------------------------------------------------------------------
//
//  Function: OnWizNextComputerName
//
//  Purpose: Called when user is done with the computername page
//
//-------------------------------------------------------------------------

BOOL OnWizNextComputerName(HWND hwnd)
{
    TCHAR ComputerNameBuffer[MAX_COMPUTERNAME + 1];
    BOOL bReturn = TRUE;

    GenSettings.bAutoComputerName =
                        IsDlgButtonChecked(hwnd, IDC_AUTOCOMPUTERNAME);

    if ( ! GenSettings.bAutoComputerName ) {

        GetDlgItemText(hwnd,
                       IDT_COMPUTERNAME,
                       ComputerNameBuffer,
                       MAX_COMPUTERNAME + 1);

        //
        // If there is text in the edit field, auto-add it to the list
        //

        if ( ComputerNameBuffer[0] != _T('\0') ) {
            if ( ! OnAddComputerName(hwnd) ) {
                bReturn = FALSE;
            }
        }
    }

    //
    // If this is a fully unattended answer file, either the auto-computername
    // button has to be checked, or there has to be >= 1 computername listed.
    //

    if ( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED && bReturn) {

        if ( ! GenSettings.bAutoComputerName &&
             GetNameListSize(&GenSettings.ComputerNames) < 1 ) {

            ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_REQUIRE_COMPUTERNAME);
            bReturn = FALSE;
        }
    }

    return ( bReturn );
}

//-------------------------------------------------------------------------
//
//  Function: DlgComputerNamePage
//
//  Purpose: Dialog proc for the ComputerName page.
//
//-------------------------------------------------------------------------

INT_PTR CALLBACK DlgComputerNamePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:

            OnComputerNameInitDialog( hwnd );

            break;

        case WM_COMMAND:
            {
                int nCtrlId;

                switch ( nCtrlId = LOWORD(wParam) ) {

                    case IDC_ADDCOMPUTER:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnAddComputerName(hwnd);
                        break;

                    case IDC_REMOVECOMPUTER:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnRemoveComputerName(hwnd);
                        break;

                    case IDC_LOADCOMPUTERNAMES:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnLoadComputerNames(hwnd);
                        break;

                    case IDC_AUTOCOMPUTERNAME:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnAutoComputerName(hwnd);
                        break;

                    case IDC_COMPUTERLIST:
                        if ( HIWORD(wParam) == LBN_SELCHANGE )
                            OnComputerSelChange(hwnd);
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;

                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_COMP_NAMZ;

                        OnSetActiveComputerName(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextComputerName(hwnd) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\display.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      display.c
//
// Description:
//      This file contains the dialog procedure for the display
//      page (IDD_DISPLAY).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "comres.h"

//
// Max # chars we display in a single entry in the combo-boxes
//

#define DISP_NAME_SIZE 128

//
// These are the max number of digits one is allowed to type into the
// edit fields on the Custom Display Settings popup.
//

#define MAX_DIGITS_COLORBITS   2
#define MAX_DIGITS_RESOLUTION  4
#define MAX_DIGITS_REFRESHRATE 3

//
// If there are 8-bits per pel or lower, we display
//      %d Colors
//
// If there are 9-23 bits per pel, we display
//      High Color (%d bits)
//
// If there are >=24 bits per pel, we display
//      True Color (%d bits)
//

#define NUMCOLORS_THRESH   8
#define HIGH_COLOR_THRESH 23

#define USE_WINDOWS_DEFAULT -1

//
// String constants loaded from the resource.
//

static TCHAR *StrWindowsDefault;
static TCHAR *StrNumColors;
static TCHAR *StrHighColor;
static TCHAR *StrTrueColor;
static TCHAR *StrHertz;

//
//  Strings to pass string data between the wizard page and the pop-up
//
static TCHAR szColorDepth[MAX_STRING_LEN];
static TCHAR szXResolution[MAX_STRING_LEN];
static TCHAR szYResolution[MAX_STRING_LEN];
static TCHAR szRefreshRate[MAX_STRING_LEN];

//
// Types to hold info about colors, resolution and refresh rates
//

typedef struct {
    int   BitsPerPel;
} COLOR_ENTRY;

typedef struct {
    int   xResolution;
    int   yResolution;
} RESOLUTION_ENTRY;

typedef struct {
    int   Rate;
} REFRESH_RATE_ENTRY;

//
// Tables that hold each of the default choices we want in combo_boxes.
//
// -1 is "Use Hardware Default" and means that this setting should not
// be written to the answer file.
//

static COLOR_ENTRY DefaultColorChoices[] = {
    { USE_WINDOWS_DEFAULT },
    {  4 },
    {  8 },
    { 16 },
    { 24 },
    { 32 }
};

static COLOR_ENTRY CustomColor = { USE_WINDOWS_DEFAULT };

static RESOLUTION_ENTRY DefaultResChoices[] = {
    { USE_WINDOWS_DEFAULT,   USE_WINDOWS_DEFAULT },
    {  640,  480 },
    {  800,  600 },
    { 1024,  768 },
    { 1280, 1024 },
    { 1600, 1200 }
};

static RESOLUTION_ENTRY CustomResolution = { USE_WINDOWS_DEFAULT, USE_WINDOWS_DEFAULT };

static REFRESH_RATE_ENTRY DefaultRefreshChoices[] = {
    { USE_WINDOWS_DEFAULT },
    { 60 },
    { 70 },
    { 72 },
    { 75 },
    { 85 }
};

static REFRESH_RATE_ENTRY CustomRefreshRate = { USE_WINDOWS_DEFAULT };

#define NumDefaultColors \
        ( sizeof(DefaultColorChoices) / sizeof(DefaultColorChoices[0]) )

#define NumDefaultResolutions \
        ( sizeof(DefaultResChoices) / sizeof(DefaultResChoices[0]) )

#define NumDefaultRefreshRates \
        ( sizeof(DefaultRefreshChoices) / sizeof(DefaultRefreshChoices[0]) )

//
// Internal Functions
//
VOID UpdateDisplaySelections(HWND);

//----------------------------------------------------------------------------
//
// Functions that take a pointer to the data record for a choice and put
// the DisplayName into the combo-box
//
// A back-pointer from the combo-box entry to the corresponding record
// is always set.
//
// The index of where the entry was placed is returned.
//
//----------------------------------------------------------------------------

int DisplayColorEntry(HWND hwnd, COLOR_ENTRY *Entry)
{
    TCHAR DisplayName[DISP_NAME_SIZE];
    int   idx, BeforeIdx;
   HRESULT hrPrintf;

    //
    // Figure out the display name.
    //
    // For e.g. it should be:
    //      32 Colors               if BitsPerPel <= 8
    //      High Color (9-bits)     if BitsPerPel > 8 && BitsPerPel < 24
    //      True Color (32-bits)    if BitsPerPel >= 24
    //

    if ( Entry->BitsPerPel < 0 )
        lstrcpyn(DisplayName, StrWindowsDefault, AS(DisplayName));

    else if ( Entry->BitsPerPel <= NUMCOLORS_THRESH )
        hrPrintf=StringCchPrintf(DisplayName, AS(DisplayName), StrNumColors, 1 << Entry->BitsPerPel);

    else if ( Entry->BitsPerPel <= HIGH_COLOR_THRESH )
        hrPrintf=StringCchPrintf(DisplayName, AS(DisplayName), StrHighColor, Entry->BitsPerPel);

    else
        hrPrintf=StringCchPrintf(DisplayName, AS(DisplayName), StrTrueColor, Entry->BitsPerPel);

    //
    // Figure out where to insert it.  We want the entries in BitsPerPel order.
    //

    for ( BeforeIdx=0; ; BeforeIdx++ ) {

        COLOR_ENTRY *CurEntry;

        CurEntry = (COLOR_ENTRY *)
                    SendDlgItemMessage(hwnd,
                                       IDC_COLORS,
                                       CB_GETITEMDATA,
                                       (WPARAM) BeforeIdx,
                                       (LPARAM) 0);

        if ( CurEntry == (void*) CB_ERR ) {
            BeforeIdx = -1;
            break;
        }

        if ( Entry->BitsPerPel < CurEntry->BitsPerPel )
            break;
    }

    //
    // Put it in the combo-box along with a pointer back to its data
    //

    idx = (int)SendDlgItemMessage(hwnd,
                             IDC_COLORS,
                             CB_INSERTSTRING,
                             (WPARAM) BeforeIdx,
                             (LPARAM) DisplayName);

    SendDlgItemMessage(hwnd,
                       IDC_COLORS,
                       CB_SETITEMDATA,
                       (WPARAM) idx,
                       (LPARAM) Entry);

    return idx;
}

BOOL DisplayResolutionEntry(HWND hwnd, RESOLUTION_ENTRY *Entry)
{
    TCHAR DisplayName[DISP_NAME_SIZE];
    int   idx, BeforeIdx;
   HRESULT hrPrintf;

    //
    // Figure out the display name.
    //

    if ( Entry->xResolution < 0 || Entry->yResolution < 0 )
        lstrcpyn(DisplayName, StrWindowsDefault, AS(DisplayName));
    else
        hrPrintf=StringCchPrintf(DisplayName, AS(DisplayName),
                 _T("%d X %d"),
                 Entry->xResolution,
                 Entry->yResolution);

    //
    // Figure out where to insert it.  We want the entries in order.
    //

    for ( BeforeIdx=0; ; BeforeIdx++ ) {

        RESOLUTION_ENTRY *CurEntry;

        CurEntry = (RESOLUTION_ENTRY *)
                    SendDlgItemMessage(hwnd,
                                       IDC_RESOLUTIONS,
                                       CB_GETITEMDATA,
                                       (WPARAM) BeforeIdx,
                                       (LPARAM) 0);

        if ( CurEntry == (void*) CB_ERR ) {
            BeforeIdx = -1;
            break;
        }

        if ( Entry->xResolution < CurEntry->xResolution )
            break;
    }

    //
    // Put it in the combo-box along with a pointer back to its data
    //

    idx = (int)SendDlgItemMessage(hwnd,
                             IDC_RESOLUTIONS,
                             CB_INSERTSTRING,
                             (WPARAM) BeforeIdx,
                             (LPARAM) DisplayName);

    SendDlgItemMessage(hwnd,
                       IDC_RESOLUTIONS,
                       CB_SETITEMDATA,
                       (WPARAM) idx,
                       (LPARAM) Entry);

    return idx;
}

BOOL DisplayRefreshEntry(HWND hwnd, REFRESH_RATE_ENTRY *Entry)
{
    TCHAR DisplayName[DISP_NAME_SIZE];
    int   idx, BeforeIdx;
    HRESULT hrPrintf;

    //
    // Figure out the display name.
    //

    if ( Entry->Rate < 0 )
        lstrcpyn(DisplayName, StrWindowsDefault, AS(DisplayName));
    else
        hrPrintf=StringCchPrintf(DisplayName, AS(DisplayName), _T("%d %s"), Entry->Rate, StrHertz);

    //
    // Figure out where to insert it.  We want the entries in order.
    //

    for ( BeforeIdx=0; ; BeforeIdx++ ) {

        REFRESH_RATE_ENTRY *CurEntry;

        CurEntry = (REFRESH_RATE_ENTRY *)
                    SendDlgItemMessage(hwnd,
                                       IDC_REFRESHRATES,
                                       CB_GETITEMDATA,
                                       (WPARAM) BeforeIdx,
                                       (LPARAM) 0);

        if ( CurEntry == (void*) CB_ERR ) {
            BeforeIdx = -1;
            break;
        }

        if ( Entry->Rate < CurEntry->Rate )
            break;
    }

    //
    // Put it in the combo-box along with a pointer back to its data
    //

    idx = (int)SendDlgItemMessage(hwnd,
                             IDC_REFRESHRATES,
                             CB_INSERTSTRING,
                             (WPARAM) BeforeIdx,
                             (LPARAM) DisplayName);

    SendDlgItemMessage(hwnd,
                       IDC_REFRESHRATES,
                       CB_SETITEMDATA,
                       (WPARAM) idx,
                       (LPARAM) Entry);

    return idx;
}


//----------------------------------------------------------------------------
//
//  Function: OnInitDisplay
//
//  Purpose: Called once at WM_INIT.  We put all of the default choices
//           into the combo boxes.
//
//----------------------------------------------------------------------------

VOID OnInitDisplay(HWND hwnd)
{
    int i;

    StrWindowsDefault = MyLoadString(IDS_DISP_WINDOWS_DEFAULT);
    StrNumColors      = MyLoadString(IDS_DISP_NUM_COLORS);
    StrHighColor      = MyLoadString(IDS_DISP_HIGH_COLOR);
    StrTrueColor      = MyLoadString(IDS_DISP_TRUE_COLOR);
    StrHertz          = MyLoadString(IDS_DISP_HERTZ);

    

    for ( i=0; i<NumDefaultColors; i++ )
        DisplayColorEntry(hwnd, &DefaultColorChoices[i]);

    for ( i=0; i<NumDefaultResolutions; i++ )
        DisplayResolutionEntry(hwnd, &DefaultResChoices[i]);

    for ( i=0; i<NumDefaultRefreshRates; i++ )
        DisplayRefreshEntry(hwnd, &DefaultRefreshChoices[i]);

    UpdateDisplaySelections(hwnd);
}


//--------------------------------------------------------------------------
//
//  This section of code supports updating the display settings.
//  UpdateDisplaySettings() is the entry for this section of code.
//  It is called at SETACTIVE time or after user chooses CUSTOM settings.
//
//  We have to find the current selections for each of the 3 combo boxes.
//
//  If we don't find the current settings in the current choices, we
//  enable (or overwrite) the "custom" setting.
//
//  We might not find the current selections in our default list because
//  user pushed the CUSTOM button, or non-standard settings were loaded
//  from an existing answer file.  We also might not find it because
//  we cloned this computer and it's settings are non-standard.
//
//--------------------------------------------------------------------------

int FindCurrentColorIdx(HWND hwnd)
{
    COLOR_ENTRY *Entry;
    int          idx;
    int          nItemCount = 0;

    //
    // Is there an entry in the display where BitsPerPel == the current
    // setting in GenSettings?
    //

    for ( idx=0; ; idx++ ) {

        Entry = (COLOR_ENTRY *)
                SendDlgItemMessage(hwnd,
                                   IDC_COLORS,
                                   CB_GETITEMDATA,
                                   (WPARAM) idx,
                                   (LPARAM) 0);

        if ( Entry == (void*) CB_ERR )
            break;

        if ( Entry->BitsPerPel == GenSettings.DisplayColorBits )
            return idx;
    }

    //
    // It's not there, enable the custom setting.  If it's already been
    // enabled, delete it from the display first.
    //

    if ( CustomColor.BitsPerPel > 0 ) {

        nItemCount = (int) SendDlgItemMessage(hwnd,
                        IDC_COLORS,
                        CB_GETCOUNT,
                        (WPARAM) 0,
                        (LPARAM) 0);

        for ( idx=0; nItemCount < idx ; idx++ ) {

            Entry = (COLOR_ENTRY *)
                     SendDlgItemMessage(hwnd,
                                        IDC_COLORS,
                                        CB_GETITEMDATA,
                                        (WPARAM) idx,
                                        (LPARAM) 0);

            if ( Entry == &CustomColor ) {
                SendDlgItemMessage(hwnd,
                                   IDC_COLORS,
                                   CB_DELETESTRING,
                                   (WPARAM) idx,
                                   (LPARAM) 0);
                break;
            }
        }
    }

    CustomColor.BitsPerPel = GenSettings.DisplayColorBits;

    return DisplayColorEntry(hwnd, &CustomColor);
}

int FindCurrentResolutionIdx(HWND hwnd)
{
    RESOLUTION_ENTRY    *Entry;
    int                 idx;
    int                 nItemCount = 0;

    //
    // Is there already an entry with the current (X,Y) resolution?
    //

    for ( idx=0; ; idx++ ) {

        Entry = (RESOLUTION_ENTRY *)
                SendDlgItemMessage(hwnd,
                                   IDC_RESOLUTIONS,
                                   CB_GETITEMDATA,
                                   (WPARAM) idx,
                                   (LPARAM) 0);

        if ( Entry == (void*) CB_ERR )
            break;

        if ( Entry->xResolution == GenSettings.DisplayXResolution &&
             Entry->yResolution == GenSettings.DisplayYResolution )
            return idx;
    }

    //
    // It's not there, enable the custom setting.  If it's already been
    // enabled, delete it from the display first.
    //

    if ( CustomResolution.xResolution > 0 ) {

        nItemCount = (int) SendDlgItemMessage(hwnd,
                                IDC_RESOLUTIONS,
                                CB_GETCOUNT,
                                (WPARAM) 0,
                                (LPARAM) 0);

        for ( idx=0; idx < nItemCount ; idx++ ) {

            Entry = (RESOLUTION_ENTRY *)
                     SendDlgItemMessage(hwnd,
                                        IDC_RESOLUTIONS,
                                        CB_GETITEMDATA,
                                        (WPARAM) idx,
                                        (LPARAM) 0);

            if ( Entry == &CustomResolution ) {
                SendDlgItemMessage(hwnd,
                                   IDC_RESOLUTIONS,
                                   CB_DELETESTRING,
                                   (WPARAM) idx,
                                   (LPARAM) 0);
                break;
            }
        }
    }

    CustomResolution.xResolution = GenSettings.DisplayXResolution;
    CustomResolution.yResolution = GenSettings.DisplayYResolution;

    return DisplayResolutionEntry(hwnd, &CustomResolution);
}

int FindCurrentRefreshRateIdx(HWND hwnd)
{
    REFRESH_RATE_ENTRY  *Entry;
    int                 idx;
    int                 nItemCount = 0;

    //
    // Is there an entry already in the display where Rate == the current
    // setting in GenSettings?
    //

    for ( idx=0; ; idx++ ) {

        Entry = (REFRESH_RATE_ENTRY *)
                SendDlgItemMessage(hwnd,
                                   IDC_REFRESHRATES,
                                   CB_GETITEMDATA,
                                   (WPARAM) idx,
                                   (LPARAM) 0);

        if ( Entry == (void*) CB_ERR )
            break;

        if ( Entry->Rate == GenSettings.DisplayRefreshRate )
            return idx;
    }

    //
    // It's not there, enable the custom setting.  If it's already been
    // enabled, delete it from the display first.
    //

    if ( CustomRefreshRate.Rate > 0 ) {


        nItemCount = (int) SendDlgItemMessage(hwnd,
                                        IDC_REFRESHRATES,
                                        CB_GETCOUNT,
                                        (WPARAM) 0,
                                        (LPARAM) 0);

        for ( idx=0; idx < nItemCount ; idx++ ) {

            Entry = (REFRESH_RATE_ENTRY *)
                     SendDlgItemMessage(hwnd,
                                        IDC_REFRESHRATES,
                                        CB_GETITEMDATA,
                                        (WPARAM) idx,
                                        (LPARAM) 0);

            if ( Entry == &CustomRefreshRate ) {
                SendDlgItemMessage(hwnd,
                                   IDC_REFRESHRATES,
                                   CB_DELETESTRING,
                                   (WPARAM) idx,
                                   (LPARAM) 0);
                break;
            }
        }
    }

    CustomRefreshRate.Rate = GenSettings.DisplayRefreshRate;

    return DisplayRefreshEntry(hwnd, &CustomRefreshRate);
}

VOID UpdateDisplaySelections(HWND hwnd)
{
    SendDlgItemMessage(hwnd,
                       IDC_COLORS,
                       CB_SETCURSEL,
                       (WPARAM) FindCurrentColorIdx(hwnd),
                       (LPARAM) 0);

    SendDlgItemMessage(hwnd,
                       IDC_RESOLUTIONS,
                       CB_SETCURSEL,
                       (WPARAM) FindCurrentResolutionIdx(hwnd),
                       (LPARAM) 0);

    SendDlgItemMessage(hwnd,
                       IDC_REFRESHRATES,
                       CB_SETCURSEL,
                       (WPARAM) FindCurrentRefreshRateIdx(hwnd),
                       (LPARAM) 0);
}


//---------------------------------------------------------------------------
//
//  SetActive
//
//---------------------------------------------------------------------------

VOID OnSetActiveDisplay(HWND hwnd)
{
    UpdateDisplaySelections(hwnd);

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}


//---------------------------------------------------------------------------
//
//  WizNext.  Get the current selection and remember the settings in
//  GenSettings global.
//
//---------------------------------------------------------------------------

VOID OnWizNextDisplay(HWND hwnd)
{
    INT_PTR Idx;
    COLOR_ENTRY        *ColorEntry;
    RESOLUTION_ENTRY   *ResEntry;
    REFRESH_RATE_ENTRY *RefreshEntry;

    //
    // Get pointer to the COLOR_ENTRY for current selection
    //

    Idx = SendDlgItemMessage(hwnd,
                             IDC_COLORS,
                             CB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0);

    ColorEntry = (COLOR_ENTRY *)
                  SendDlgItemMessage(hwnd,
                                     IDC_COLORS,
                                     CB_GETITEMDATA,
                                     (WPARAM) Idx,
                                     (LPARAM) 0);

    //
    // Get pointer to the RESOLUTION_ENTRY for current selection
    //

    Idx = SendDlgItemMessage(hwnd,
                             IDC_RESOLUTIONS,
                             CB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0);

    ResEntry = (RESOLUTION_ENTRY *)
                SendDlgItemMessage(hwnd,
                                   IDC_RESOLUTIONS,
                                   CB_GETITEMDATA,
                                   (WPARAM) Idx,
                                   (LPARAM) 0);

    //
    // Get pointer to the REFRESH_RATE_ENTRY for current selection
    //

    Idx = SendDlgItemMessage(hwnd,
                             IDC_REFRESHRATES,
                             CB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0);

    RefreshEntry = (REFRESH_RATE_ENTRY *)
                    SendDlgItemMessage(hwnd,
                                       IDC_REFRESHRATES,
                                       CB_GETITEMDATA,
                                       (WPARAM) Idx,
                                       (LPARAM) 0);

    //
    // Remember all these settings
    //

    GenSettings.DisplayColorBits   = ColorEntry->BitsPerPel;
    GenSettings.DisplayXResolution = ResEntry->xResolution;
    GenSettings.DisplayYResolution = ResEntry->yResolution;
    GenSettings.DisplayRefreshRate = RefreshEntry->Rate;
}


//----------------------------------------------------------------------------
//
//  Function: OnCustomDlgOk
//
//  Purpose: Dialog procedure for the Custom settings popup.
//
//----------------------------------------------------------------------------

BOOL OnCustomDlgOk(HWND hwnd)
{
    TCHAR Colors[MAX_DIGITS_COLORBITS+1],
          XRes[MAX_DIGITS_RESOLUTION+1],
          YRes[MAX_DIGITS_RESOLUTION+1],
          Refresh[MAX_DIGITS_REFRESHRATE+1];

    int iColorBits   = 0,
        iXResolution = 0,
        iYResolution = 0,
        iRefreshRate = 0;

    //
    // Get the values user typed in
    //

    GetDlgItemText(hwnd, IDC_BITSPERPEL2,  Colors,  StrBuffSize(Colors));
    GetDlgItemText(hwnd, IDC_XRESOLUTION2, XRes,    StrBuffSize(XRes));
    GetDlgItemText(hwnd, IDC_YRESOLUTION2, YRes,    StrBuffSize(YRes));
    GetDlgItemText(hwnd, IDC_REFRESHRATE2, Refresh, StrBuffSize(Refresh));

    if ( swscanf(Colors,  _T("%d"), &iColorBits) <= 0 )
        iColorBits = 0;
    if ( swscanf(XRes,    _T("%d"), &iXResolution) <= 0 )
        iXResolution = 0;
    if ( swscanf(YRes,    _T("%d"), &iYResolution) <= 0 )
        iYResolution = 0;
    if ( swscanf(Refresh, _T("%d"), &iRefreshRate) <= 0 )
        iRefreshRate = 0;

    //
    // Validate them
    //

    if ( iColorBits < 1 ) {
        ReportErrorId(hwnd, MSGTYPE_ERR, IDS_INVALID_BITS_PER_PEL);
        SetFocus(GetDlgItem(hwnd, IDC_BITSPERPEL2));
        return FALSE;
    }

    if ( iColorBits > 32 ) {
        ReportErrorId(hwnd, MSGTYPE_ERR, IDS_INVALID_BITS_PER_PEL_HIGH);
        SetFocus(GetDlgItem(hwnd, IDC_BITSPERPEL2));
        return FALSE;
    }

    if ( iXResolution < 640 ) {
        ReportErrorId(hwnd, MSGTYPE_ERR, IDS_INVALID_X_RESOLUTION);
        SetFocus(GetDlgItem(hwnd, IDC_XRESOLUTION2));
        return FALSE;
    }

    if ( iYResolution < 480 ) {
        ReportErrorId(hwnd, MSGTYPE_ERR, IDS_INVALID_Y_RESOLUTION);
        SetFocus(GetDlgItem(hwnd, IDC_YRESOLUTION2));
        return FALSE;
    }

    if ( iRefreshRate < 1 ) {
        ReportErrorId(hwnd, MSGTYPE_ERR, IDS_INVALID_REFRESH_RATE);
        SetFocus(GetDlgItem(hwnd, IDC_REFRESHRATE2));
        return FALSE;
    }

    //
    // All is ok, remember them and return success
    //

    GenSettings.DisplayColorBits   = iColorBits;
    GenSettings.DisplayXResolution = iXResolution;
    GenSettings.DisplayYResolution = iYResolution;
    GenSettings.DisplayRefreshRate = iRefreshRate;

    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Function: OnInitCustomDisplayDialog
//
//  Purpose: Sets text limits on the edit boxes and initializes them with
//           their default values.
//
//----------------------------------------------------------------------------
VOID
OnInitCustomDisplayDialog( IN HWND hwnd )
{

    // Disable IME so DBCS characters can not be entered in fields
    //
    ImmAssociateContext(GetDlgItem(hwnd, IDC_BITSPERPEL2), NULL);
    ImmAssociateContext(GetDlgItem(hwnd, IDC_XRESOLUTION2), NULL);
    ImmAssociateContext(GetDlgItem(hwnd, IDC_YRESOLUTION2), NULL);
    ImmAssociateContext(GetDlgItem(hwnd, IDC_REFRESHRATE2), NULL);

    SendDlgItemMessage(hwnd,
                       IDC_BITSPERPEL2,
                       EM_LIMITTEXT,
                       MAX_DIGITS_COLORBITS,
                       0);

    SendDlgItemMessage(hwnd,
                       IDC_XRESOLUTION2,
                       EM_LIMITTEXT,
                       MAX_DIGITS_RESOLUTION,
                       0);

    SendDlgItemMessage(hwnd,
                       IDC_YRESOLUTION2,
                       EM_LIMITTEXT,
                       MAX_DIGITS_RESOLUTION,
                       0);

    SendDlgItemMessage(hwnd,
                       IDC_REFRESHRATE2,
                       EM_LIMITTEXT,
                       MAX_DIGITS_REFRESHRATE,
                       0);

    SetWindowText( GetDlgItem( hwnd, IDC_BITSPERPEL2 ), szColorDepth );

    SetWindowText( GetDlgItem( hwnd, IDC_XRESOLUTION2 ), szXResolution );

    SetWindowText( GetDlgItem( hwnd, IDC_YRESOLUTION2 ), szYResolution );

    SetWindowText( GetDlgItem( hwnd, IDC_REFRESHRATE2 ), szRefreshRate );

}

INT_PTR CALLBACK CustomDisplayDlg(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:

            OnInitCustomDisplayDialog( hwnd );

            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {

                    case IDOK:

                        if ( HIWORD(wParam) == BN_CLICKED ) {
                            if ( OnCustomDlgOk(hwnd) ) {
                                EndDialog(hwnd, TRUE);
                            }
                        }
                        break;

                    case IDCANCEL:
                        if ( HIWORD(wParam) == BN_CLICKED ) {
                            EndDialog(hwnd, FALSE);
                        }
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}

VOID OnCustomButton(HWND hwnd)
{

    INT_PTR iIndex;
    COLOR_ENTRY *ColorDepthEntry;
    RESOLUTION_ENTRY *ResolutionEntry;
    REFRESH_RATE_ENTRY *RefreshRateEntry;

    szColorDepth[0]  = _T('\0');
    szXResolution[0] = _T('\0');
    szYResolution[0] = _T('\0');
    szRefreshRate[0] = _T('\0');

    //
    //  Fill the color depth, resolution and refresh rate strings
    //  so the pop-up can display them
    //  If an entry is set to windows default, then give it some default values
    //

    iIndex = SendDlgItemMessage( hwnd,
                                 IDC_COLORS,
                                 CB_GETCURSEL,
                                 0,
                                 0 );

    if( iIndex != CB_ERR ) {

        ColorDepthEntry = (COLOR_ENTRY *) SendDlgItemMessage( hwnd,
                                                              IDC_COLORS,
                                                              CB_GETITEMDATA,
                                                              iIndex,
                                                              0 );

        if( ColorDepthEntry != (void *) CB_ERR && ColorDepthEntry != NULL ) {

            if( ColorDepthEntry->BitsPerPel != USE_WINDOWS_DEFAULT ) {

                _itot( ColorDepthEntry->BitsPerPel, szColorDepth, 10 );

            }
            else {

                lstrcpyn( szColorDepth, _T("4"), AS(szColorDepth) );

            }

        }

    }

    iIndex = SendDlgItemMessage( hwnd,
                                 IDC_RESOLUTIONS,
                                 CB_GETCURSEL,
                                 0,
                                 0 );

    if( iIndex != CB_ERR ) {

        ResolutionEntry = (RESOLUTION_ENTRY *) SendDlgItemMessage( hwnd,
                                                     IDC_RESOLUTIONS,
                                                     CB_GETITEMDATA,
                                                     iIndex,
                                                     0 );

        if( ResolutionEntry != (void *) CB_ERR && ResolutionEntry != NULL ) {

            if( ResolutionEntry->xResolution != USE_WINDOWS_DEFAULT ) {

                _itot( ResolutionEntry->xResolution, szXResolution, 10 );

            }
            else {

                lstrcpyn( szXResolution, _T("640"), AS(szXResolution) );

            }

            if( ResolutionEntry->yResolution != USE_WINDOWS_DEFAULT ) {

                _itot( ResolutionEntry->yResolution, szYResolution, 10 );

            }
            else {

                lstrcpyn( szYResolution, _T("480"), AS(szYResolution) );

            }

        }

    }

    iIndex = SendDlgItemMessage( hwnd,
                                 IDC_REFRESHRATES,
                                 CB_GETCURSEL,
                                 0,
                                 0 );

    if( iIndex != CB_ERR ) {

        RefreshRateEntry = (REFRESH_RATE_ENTRY *) SendDlgItemMessage( hwnd,
                                                     IDC_REFRESHRATES,
                                                     CB_GETITEMDATA,
                                                     iIndex,
                                                     0 );

        if( RefreshRateEntry != (void *) CB_ERR && RefreshRateEntry != NULL ) {

            if( RefreshRateEntry->Rate != USE_WINDOWS_DEFAULT ) {

                _itot( RefreshRateEntry->Rate, szRefreshRate, 10 );

            }
            else {

                lstrcpyn( szRefreshRate, _T("60"), AS(szRefreshRate) );

            }

        }

    }

    //
    // If user hits ok, update the selections
    //

    if ( DialogBox(FixedGlobals.hInstance,
                   MAKEINTRESOURCE(IDD_DISPLAY2),
                   hwnd,
                   CustomDisplayDlg) ) {
        UpdateDisplaySelections(hwnd);
    }
}

//----------------------------------------------------------------------------
//
//  Function: DlgDisplayPage
//
//  Purpose: Dialog procedure for the display page
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgDisplayPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            OnInitDisplay(hwnd);
            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {

                    case IDC_CUSTOM:

                        if ( HIWORD(wParam) == BN_CLICKED ) {
                            OnCustomButton(hwnd);
                        }
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_DSIP_SETG;

                        OnSetActiveDisplay(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        OnWizNextDisplay(hwnd);
                        bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\license.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      license.c
//
// Description:
//      This file contains the dialog procedure for the license agreement page.
//      (IDD_LICENSEAGREEMENT).  The user only sees this page if they selected
//      a fully automated script.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
// Function: OnWizNextLicense
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
BOOL
OnWizNextLicense( IN HWND hwnd ) {

    if( IsDlgButtonChecked( hwnd, IDC_CB_ACCEPT_LICENSE ) )
    {
        GenSettings.bSkipEulaAndWelcome = TRUE;

    }
    else
    {
        ReportErrorId( hwnd,
                       MSGTYPE_ERR,
                       IDS_ERR_MUST_ACCEPT_EULA );

        return FALSE;
    }

    return TRUE;

}

//----------------------------------------------------------------------------
//
// Function: DlgLicensePage
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
DlgLicensePage( IN HWND     hwnd,
                IN UINT     uMsg,
                IN WPARAM   wParam,
                IN LPARAM   lParam) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            // purposely do nothing

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd); 
                    break;

                case PSN_SETACTIVE: {

                    g_App.dwCurrentHelp = IDH_LIC_AGR;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    if ( GenSettings.iUnattendMode != UMODE_FULL_UNATTENDED )
                        WIZ_SKIP( hwnd );

                    break;

                }
                case PSN_WIZBACK:
                    bStatus = FALSE;
                    break;

                case PSN_WIZNEXT:

                    if (OnWizNextLicense(hwnd) )
                        WIZ_PRESS(hwnd, PSBTN_FINISH);
                    else
                        WIZ_FAIL(hwnd);

                    break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                default:
                    bStatus = FALSE;
                    break;
            }


            break;
        }

        default:
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupcl\setupcl.h ===
//
// ============================================================================
// FREQUENTLY USED REGISTRY KEYS
// ============================================================================
//

//
// registry keys and hive names.
//
#define REG_SAM_KEY                 "\\REGISTRY\\MACHINE\\SAM"
#define REG_SECURITY_KEY            "\\REGISTRY\\MACHINE\\SECURITY"
#define REG_SOFTWARE_KEY            "\\REGISTRY\\MACHINE\\SOFTWARE"
#define REG_SYSTEM_KEY              "\\REGISTRY\\MACHINE\\SYSTEM"
#define REG_SAM_HIVE                "\\SYSTEMROOT\\SYSTEM32\\CONFIG\\SAM"
#define REG_SECURITY_HIVE           "\\SYSTEMROOT\\SYSTEM32\\CONFIG\\SECURITY"
#define REG_SOFTWARE_HIVE           "\\SYSTEMROOT\\SYSTEM32\\CONFIG\\SOFTWARE"
#define REG_SYSTEM_HIVE             "\\SYSTEMROOT\\SYSTEM32\\CONFIG\\SYSTEM"

#define REG_SAM_DOMAINS             "\\REGISTRY\\MACHINE\\SAM\\SAM\\DOMAINS"
#define REG_SECURITY_POLICY         "\\REGISTRY\\MACHINE\\SECURITY\\POLICY"
#define REG_SECURITY_POLACDMS       "\\REGISTRY\\MACHINE\\SECURITY\\POLICY\\POLACDMS"
#define REG_SOFTWARE_PROFILELIST    "\\REGISTRY\\MACHINE\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\PROFILELIST"
#define REG_SOFTWARE_SECEDIT        "\\REGISTRY\\MACHINE\\SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\SECEDIT"
#define REG_SOFTWARE_EFS            "\\REGISTRY\\MACHINE\\SOFTWARE\\POLICIES\\MICROSOFT\\SYSTEMCERTIFICATES\\EFS"
#define REG_SYSTEM_SERVICES         "\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES"
#define REG_SYSTEM_CONTROL          "\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\CONTROL"
#define REG_SYSTEM_CONTROL_PRINT    "\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\CONTROL\\PRINT"
#define REG_SYSTEM_SETUP            "\\REGISTRY\\MACHINE\\SYSTEM\\SETUP"
#define REG_SYSTEM_SESSIONMANAGER   "\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\CONTROL\\SESSION MANAGER"
#define REG_SYSTEM_HIVELIST         "\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\CONTROL\\HIVELIST"
//
// Repair hives
//
#define REPAIR_SAM_KEY              "\\REGISTRY\\MACHINE\\RSAM"
#define REPAIR_SECURITY_KEY         "\\REGISTRY\\MACHINE\\RSECURITY"
#define REPAIR_SOFTWARE_KEY         "\\REGISTRY\\MACHINE\\RSOFTWARE"
#define REPAIR_SYSTEM_KEY           "\\REGISTRY\\MACHINE\\RSYSTEM"
#define REPAIR_SAM_HIVE             "\\SYSTEMROOT\\REPAIR\\SAM"
#define REPAIR_SECURITY_HIVE        "\\SYSTEMROOT\\REPAIR\\SECURITY"
#define REPAIR_SOFTWARE_HIVE        "\\SYSTEMROOT\\REPAIR\\SOFTWARE"
#define REPAIR_SYSTEM_HIVE          "\\SYSTEMROOT\\REPAIR\\SYSTEM"

#define R_REG_SAM_DOMAINS           "\\REGISTRY\\MACHINE\\RSAM\\SAM\\DOMAINS"
#define R_REG_SECURITY_POLICY       "\\REGISTRY\\MACHINE\\RSECURITY\\POLICY"
#define R_REG_SOFTWARE_PROFILELIST  "\\REGISTRY\\MACHINE\\RSOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\PROFILELIST"
#define R_REG_SOFTWARE_SECEDIT      "\\REGISTRY\\MACHINE\\RSOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION\\SECEDIT"
#define R_REG_SOFTWARE_EFS          "\\REGISTRY\\MACHINE\\RSOFTWARE\\POLICIES\\MICROSOFT\\SYSTEMCERTIFICATES\\EFS"
#define R_REG_SYSTEM_CONTROL_PRINT  "\\REGISTRY\\MACHINE\\RSYSTEM\\CURRENTCONTROLSET\\CONTROL\\PRINT"
#define R_REG_SYSTEM_SERVICES       "\\REGISTRY\\MACHINE\\RSYSTEM\\CURRENTCONTROLSET\\SERVICES"
#define R_REG_SETUP_KEYNAME         "\\REGISTRY\\MACHINE\\RSYSTEM\\SETUP"

#define BACKUP_REPAIR_SAM_HIVE      "\\SYSTEMROOT\\REPAIR\\DS_SAM"
#define BACKUP_REPAIR_SECURITY_HIVE "\\SYSTEMROOT\\REPAIR\\DS_SECURITY"
#define BACKUP_REPAIR_SOFTWARE_HIVE "\\SYSTEMROOT\\REPAIR\\DS_SOFTWARE"
#define BACKUP_REPAIR_SYSTEM_HIVE   "\\SYSTEMROOT\\REPAIR\\DS_SYSTEM"


#define REG_CLONETAG_VALUENAME      "CLONETAG"
#define EXECUTE                     "SETUPEXECUTE"
#define REG_SIZE_LIMIT              "REGISTRYSIZELIMIT"
#define PROFILEIMAGEPATH            "PROFILEIMAGEPATH"
#define TMP_HIVE_NAME               "\\REGISTRY\\MACHINE\\TMPHIVE"

//
// ============================================================================
// CONSTANTS
// ============================================================================
//

#define BASIC_INFO_BUFFER_SIZE      (sizeof(KEY_VALUE_BASIC_INFORMATION) + 2048)
// #define PARTIAL_INFO_BUFFER_SIZE    (sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 1536)
#define FULL_INFO_BUFFER_SIZE       (sizeof(KEY_VALUE_FULL_INFORMATION) + 4096)
#define SID_SIZE                    (0x18)
#define REGISTRY_QUOTA_BUMP         (10 * (1024 * 1024))
#define PROGRAM_NAME                "setupcl.exe"

//
// ============================================================================
// USEFUL MACROS
// ============================================================================
//

#define AS(x)   ( sizeof(x) / sizeof(x[0]) )

//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)                       \
                                                                        \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));                \
                                                                        \
    InitializeObjectAttributes(                                         \
        (Obja),                                                         \
        (UnicodeString),                                                \
        OBJ_CASE_INSENSITIVE,                                           \
        NULL,                                                           \
        NULL                                                            \
        )


#define PRINT_BLOCK( Block, BlockSize )                                 \
{                                                                       \
ULONG idx1, idx2, idx3;                                                 \
    idx1 = 0;                                                           \
    while( idx1 < BlockSize ) {                                         \
        DbgPrint( "\t" );                                               \
        for( idx3 = 0; idx3 < 4; idx3++ ) {                             \
            idx2 = 0;                                                   \
            while( ( idx1 < BlockSize ) && ( idx2 < 4 ) ) {             \
                DbgPrint( "%02lx", *(PUCHAR)((PUCHAR)Block + idx1) );   \
                idx1++; idx2++;                                         \
            }                                                           \
            DbgPrint( " " );                                            \
        }                                                               \
        DbgPrint( "\n" );                                               \
    }                                                                   \
}


//
// Helper macro to test the the Status variable.  Print
// a message if it's not NT_SUCCESS
//
#define TEST_STATUS( a )                                                \
    if( !NT_SUCCESS( Status ) ) {                                       \
        DbgPrint( "%s (%lx)\n", a, Status );                            \
    }

//
// Helper macro to test the the Status variable.  Print
// a message if it's not NT_SUCCESS, then retun Status to
// our caller.
//
#define TEST_STATUS_RETURN( a )                                         \
    if( !NT_SUCCESS( Status ) ) {                                       \
        DbgPrint( "%s (%lx)\n", a, Status );                            \
        return Status;                                                  \
    }

//
// Helper macro to print the the Status variable.  Print
// a message and the Status
//
#define PRINT_STATUS( a )                                               \
        {                                                               \
            DbgPrint( "%s (%lx)\n", a, Status );                        \
        }


//
// ============================================================================
// FUNCTION DECLARATIONS
// ============================================================================
//

extern NTSTATUS
DeleteKey(
    PWSTR   Key
    );

extern NTSTATUS
DeleteKeyRecursive(
    HANDLE  hKeyRoot,
    PWSTR   Key
    );

extern NTSTATUS
FileDelete(
    IN WCHAR    *FileName
    );

extern NTSTATUS
FileCopy(
    IN WCHAR    *TargetName,
    IN WCHAR    *SourceName
    );

extern NTSTATUS
SetKey(
    IN WCHAR    *KeyName,
    IN WCHAR    *SubKeyName,
    IN CHAR     *Data,
    IN ULONG    DataLength,
    IN ULONG    DATA_TYPE
    );

extern NTSTATUS
ReadSetWriteKey(
    IN WCHAR    *ParentKeyName,  OPTIONAL
    IN HANDLE   ParentKeyHandle, OPTIONAL
    IN WCHAR    *SubKeyName,
    IN CHAR     *OldData,
    IN CHAR     *NewData,
    IN ULONG    DataLength,
    IN ULONG    DATA_TYPE
    );

extern NTSTATUS
LoadUnloadHive(
    IN PWSTR        KeyName,
    IN PWSTR        FileName
    );

extern NTSTATUS
BackupRepairHives(
    VOID
    );

extern NTSTATUS
CleanupRepairHives(
    NTSTATUS RepairHivesSuccess
    );

extern NTSTATUS
TestSetSecurityObject(
    HANDLE  hKey
    );

extern NTSTATUS
SetKeySecurityRecursive(
    HANDLE  hKey
    );

extern NTSTATUS
CopyKeyRecursive(
    HANDLE  hKeyDst,
    HANDLE  hKeySrc
    );

extern NTSTATUS
CopyRegKey(
    IN WCHAR    *TargetName,
    IN WCHAR    *SourceName,
    IN HANDLE   ParentKeyHandle OPTIONAL
    );

extern NTSTATUS
MoveRegKey(
    IN WCHAR    *TargetName,
    IN WCHAR    *SourceName
    );

extern NTSTATUS
FindAndReplaceBlock(
    IN PCHAR    Block,
    IN ULONG    BlockLength,
    IN PCHAR    OldValue,
    IN PCHAR    NewValue,
    IN ULONG    ValueLength
    );

extern NTSTATUS
StringSwitchString(
    PWSTR   BaseString,
    DWORD   cBaseStringLen,
    PWSTR   OldSubString,
    PWSTR   NewSubString
    );

extern NTSTATUS
SiftKeyRecursive(
    HANDLE hKey,
    int    indent
    );

extern NTSTATUS
SiftKey(
    PWSTR   KeyName
    );

extern NTSTATUS
ProcessSAMHive(
    VOID
    );

extern NTSTATUS
ProcessSECURITYHive(
    VOID
    );

extern NTSTATUS
ProcessSOFTWAREHive(
    VOID
    );

extern NTSTATUS
ProcessSYSTEMHive(
    VOID
    );

extern NTSTATUS
ProcessRepairSAMHive(
    VOID
    );

extern NTSTATUS
ProcessRepairSECURITYHive(
    VOID
    );

extern NTSTATUS
ProcessRepairSOFTWAREHive(
    VOID
    );

extern NTSTATUS
ProcessRepairSYSTEMHive(
    VOID
    );

extern NTSTATUS
RetrieveOldSid(
    VOID
    );

extern NTSTATUS
GenerateUniqueSid(
    IN  DWORD Seed
    );

extern NTSTATUS
EnumerateDrives(
    VOID
    );

extern NTSTATUS
DriveLetterToNTPath(
    IN WCHAR      DriveLetter,
    IN OUT PWSTR  NTPath,
    IN DWORD      cNTPathLen
    );

// ============================================================================
// GLOBAL VARIABLES
// ============================================================================

//
// These globals hold the OldSid (the one prior to the clone)
// and the NewSid (the one we generate and spray into the
// registry).
//
PSID            G_OldSid,
                G_NewSid;
//
// These guys will hold small strings that contain the text character
// versions of the 3 unique numbers that make up the domain SID.
//
WCHAR           G_OldSidSubString[MAX_PATH * 4];
WCHAR           G_NewSidSubString[MAX_PATH * 4];
WCHAR           TmpBuffer[MAX_PATH * 4];


// 
// Disable the DbgPrint for non-debug builds
//
#ifndef DBG
#define DbgPrint DbgPrintSub
void DbgPrintSub(char *szBuffer, ...);
#endif


//
// UI related constants and functions.
//

// 14 seconds in 100ns units. (OOBE wanted 15secs, but it seems like it takes ~1-2 sec to initialize setupcl)
//
#define UITIME 140000000   
#define UIDOTTIME 30000000 // 3 seconds in 100ns units

extern __inline void
DisplayUI();
    
extern BOOL
LoadStringResource(
                   PUNICODE_STRING  pUnicodeString,
                   INT              MsgId
                  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\base.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// Filename:
//    base.h
//
// Description:
//    Shared stuff for the base directory.
//
//----------------------------------------------------------------------------

LPTSTR IsMagicPrinterCmd(LPTSTR pRunOnceCmd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\nameorg.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      nameorg.c
//
// Description:
//      This file contains the dialog procedure for the Name & Org page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//---------------------------------------------------------------------------
//
//  Function: OnSetActiveNameOrg
//
//  Purpose: Called when page is about to display.  Set the controls.
//
//---------------------------------------------------------------------------

VOID OnSetActiveNameOrg(HWND hwnd)
{
    SetDlgItemText(hwnd, IDT_USERNAME,     GenSettings.UserName);
    SetDlgItemText(hwnd, IDT_ORGANIZATION, GenSettings.Organization);

    WIZ_BUTTONS(hwnd, PSWIZB_NEXT);
}

//---------------------------------------------------------------------------
//
//  Function: CheckUserNameOrg
//
//  Purpose: Validates that user supplied good answers on the page.
//
//  Returns: BOOL - advance the wizard or not.
//
//---------------------------------------------------------------------------
static BOOL
CheckUserNameOrg( HWND hwnd )
{

    //
    // If fully automated answer file, default username must be set
    //

    if ( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED &&
         GenSettings.UserName[0] == _T('\0') ) {

        ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_REQUIRE_USERNAME );

        return( FALSE );
    }

    // ISSUE-2002/02/28-stelo - how can I get the localized string of Administrator from the machine I'm running on?
    //         should I disallow the username of Administrator?  It is invalid on a U.S. but is it
    //         valid on say a japanese build?  Or we make the assumption that we are running on
    //         the same language version as the unattend.txt will be installed with?

    return( TRUE );

}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextNameOrg
//
//  Purpose: Called when user pushes the NEXT button.  Stash the data
//           in the GenSettings global.
//
//----------------------------------------------------------------------------

BOOL OnWizNextNameOrg(HWND hwnd)
{
    BOOL bResult = FALSE;

    GetDlgItemText(hwnd,
                   IDT_USERNAME,
                   GenSettings.UserName,
                   MAX_NAMEORG_NAME + 1);

    GetDlgItemText(hwnd,
                   IDT_ORGANIZATION,
                   GenSettings.Organization,
                   MAX_NAMEORG_ORG + 1);

    if ( CheckUserNameOrg(hwnd) )
        bResult = TRUE;
    
    return ( bResult );
        
}

//----------------------------------------------------------------------------
//
// Function: DlgNameOrgPage
//
// Purpose: This is the dialog procedure the name and organization page
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgNameOrgPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd,
                               IDT_USERNAME,
                               EM_LIMITTEXT,
                               (WPARAM) MAX_NAMEORG_NAME,
                               (LPARAM) 0);

            SendDlgItemMessage(hwnd,
                               IDT_ORGANIZATION,
                               EM_LIMITTEXT,
                               (WPARAM) MAX_NAMEORG_ORG,
                               (LPARAM) 0);
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_CUST_SOFT;

                        OnSetActiveNameOrg(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextNameOrg(hwnd) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;

                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\pch.h ===
#include "setupmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\oemstrng.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      oemstrng.c
//
// Description:
//      This file contains the dialog procedure for the OEM Duplicator String.
//      This string is written to the registry on Syspreps.
//      (IDD_OEMDUPSTRING).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
// Function: OnOemDuplicatorStringInitDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnOemDuplicatorStringInitDialog( IN HWND hwnd ) {

    //
    //  Set the text limit on the edit boxes to MAX_OEMDUPSTRING_LENGTH
    //
    SendDlgItemMessage( hwnd,
                        IDC_OEMDUPSTRING,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_OEMDUPSTRING_LENGTH,
                        (LPARAM) 0 );

}

//----------------------------------------------------------------------------
//
// Function: OnOemDuplicatorStringSetActive
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnOemDuplicatorStringSetActive( IN HWND hwnd ) {

    SetWindowText( GetDlgItem( hwnd, IDC_OEMDUPSTRING),
                   GenSettings.szOemDuplicatorString );

}

//----------------------------------------------------------------------------
//
// Function: OnWizNextOemDuplicatorString
//
// Purpose:  Store the setting from the Oem Duplicator String page into the appropriate
//           global variables
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnWizNextOemDuplicatorString( IN HWND hwnd ) {

    GetWindowText( GetDlgItem( hwnd, IDC_OEMDUPSTRING),
                   GenSettings.szOemDuplicatorString,
                   MAX_OEMDUPSTRING_LENGTH + 1);

}

//----------------------------------------------------------------------------
//
// Function: DlgOemDuplicatorStringPage
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
DlgOemDuplicatorStringPage( IN HWND     hwnd,
                            IN UINT     uMsg,
                            IN WPARAM   wParam,
                            IN LPARAM   lParam ) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnOemDuplicatorStringInitDialog( hwnd );

            break;

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:

                    WIZ_CANCEL(hwnd); 
                    break;

                case PSN_SETACTIVE: {

                    g_App.dwCurrentHelp = IDH_OEM_DUPE;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_FINISH);

                    OnOemDuplicatorStringSetActive( hwnd );

                    break;

                }
                case PSN_WIZBACK:

                    bStatus = FALSE; 
                    break;

                case PSN_WIZNEXT:

                    OnWizNextOemDuplicatorString( hwnd );

                    bStatus = FALSE; 
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:

                    break;
            }


            break;
        }

        default:
            bStatus = FALSE;
            break;

    }

    return bStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\printers.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      printers.c
//
// Description:
//      This file has the dlgproc and friends of the printers page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "base.h"
#include "resource.h"
#include <winspool.h>   // needed for printer structs

//
//  This variable is only relevant when the use chose to do a registry load.
//  It keeps track of whether the printers have already been loaded or not.
//
static BOOL bLoadedPrintersForRegLoad = FALSE;

//----------------------------------------------------------------------------
//
// Function: GreyPrinterPage
//
// Purpose: Greys controls on the page
//
//----------------------------------------------------------------------------

VOID GreyPrinterPage(HWND hwnd)
{
    INT_PTR  idx;
    HWND hCtrl = GetDlgItem(hwnd, IDC_REMOVEPRINTER);

    idx = SendDlgItemMessage(hwnd,
                             IDC_PRINTERLIST,
                             LB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0);

    //
    // Grey the remove button unless something is selected
    //

    EnableWindow(hCtrl, idx != LB_ERR);
}

//----------------------------------------------------------------------------
//
// Function: OnPrinterSelChange
//
// Purpose: Called when an entry in the printer list was just selected
//          by the user.
//
//----------------------------------------------------------------------------

VOID OnPrinterSelChange(HWND hwnd)
{
    GreyPrinterPage(hwnd);
}

//----------------------------------------------------------------------------
//
// Function: OnAddPrinter
//
// Purpose: Called when user pushes the ADD button.
//          Also called by WizNext if something still in the edit field
//
// Returns:
//      BOOL indicating whether printer was added or not.
//
//----------------------------------------------------------------------------

BOOL OnAddPrinter(HWND hwnd)
{
    TCHAR PrinterNameBuffer[MAX_PRINTERNAME + 1];
    BOOL bRet = TRUE;

    //
    // get the printername the user typed in
    //

    GetDlgItemText(hwnd,
                   IDT_PRINTERNAME,
                   PrinterNameBuffer,
                   MAX_PRINTERNAME + 1);

    //
    // Is it valid?
    //

    if ( ! IsValidNetShareName(PrinterNameBuffer) ) {
        ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_INVALID_PRINTER_NAME);
        bRet = FALSE;
        goto FinishUp;
    }

    //
    // If this name has already been added, don't add it again
    //

    if ( FindNameInNameList(&GenSettings.PrinterNames,
                                        PrinterNameBuffer) >= 0 ) {
        SetDlgItemText(hwnd, IDT_PRINTERNAME, _T("") );
        goto FinishUp;
    }

    //
    // Add it to our global storage and display it
    //

    AddNameToNameList(&GenSettings.PrinterNames, PrinterNameBuffer);

    SendDlgItemMessage(hwnd,
                       IDC_PRINTERLIST,
                       LB_ADDSTRING,
                       (WPARAM) 0,
                       (LPARAM) PrinterNameBuffer);
    SetDlgItemText(hwnd, IDT_PRINTERNAME, _T("") );

FinishUp:
    SetFocus(GetDlgItem(hwnd, IDT_PRINTERNAME));
    return bRet;
}

//----------------------------------------------------------------------------
//
// Function: OnRemovePrinter
//
// Purpose: Called when user pushes the REMOVE button.
//
//----------------------------------------------------------------------------

VOID OnRemovePrinter(HWND hwnd)
{
    INT_PTR idx, Count;
    TCHAR PrinterNameBuffer[MAX_PRINTERNAME + 1];

    //
    // Get users selection of the printername to remove
    //

    idx = SendDlgItemMessage(hwnd,
                             IDC_PRINTERLIST,
                             LB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0);

    if ( idx == LB_ERR )
        return;

    SendDlgItemMessage(hwnd,
                       IDC_PRINTERLIST,
                       LB_GETTEXT,
                       (WPARAM) idx,
                       (LPARAM) PrinterNameBuffer);

    //
    // Remove it from the listbox display
    //

    SendDlgItemMessage(hwnd,
                       IDC_PRINTERLIST,
                       LB_DELETESTRING,
                       (WPARAM) idx,
                       (LPARAM) 0);

    //
    // Remove this printername from our data store
    //

    RemoveNameFromNameList(&GenSettings.PrinterNames, PrinterNameBuffer);

    //
    // Have to set a new selection.
    //

    Count = SendDlgItemMessage(hwnd,
                               IDC_PRINTERLIST,
                               LB_GETCOUNT,
                               (WPARAM) 0,
                               (LPARAM) 0);
    if ( Count ) {
        if ( idx >= Count )
            idx--;
        SendDlgItemMessage(hwnd,
                           IDC_PRINTERLIST,
                           LB_SETCURSEL,
                           (WPARAM) idx,
                           (LPARAM) 0);
    }

    //
    // There might be nothing selected now.
    //

    GreyPrinterPage(hwnd);
}

//----------------------------------------------------------------------------
//
// Function: OnSetActivePrinterPage
//
// Purpose: Called when the page is about to display.
//
//----------------------------------------------------------------------------

VOID OnSetActivePrinterPage(HWND hwnd)
{
    UINT i, nNames;

    //
    // Remove everything from the display
    //

    SendDlgItemMessage(hwnd,
                       IDC_PRINTERLIST,
                       LB_RESETCONTENT,
                       (WPARAM) 0,
                       (LPARAM) 0);

    //
    // Fill in the listbox with all of the printer names.
    //

    for ( i = 0, nNames = GetNameListSize(&GenSettings.PrinterNames);
          i < nNames;
          i++ ) {

        TCHAR *pNextName = GetNameListName(&GenSettings.PrinterNames, i);

        SendDlgItemMessage(hwnd,
                           IDC_PRINTERLIST,
                           LB_ADDSTRING,
                           (WPARAM) 0,
                           (LPARAM) pNextName);
    }

    GreyPrinterPage(hwnd);

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
// Function: OnWizNextPrinterPage
//
// Purpose: Called when user pushes NEXT button.
//
//----------------------------------------------------------------------------

BOOL OnWizNextPrinterPage(HWND hwnd)
{
    TCHAR  PrinterNameBuffer[MAX_PRINTERNAME + 1];

    //
    // Auto add anything in the edit field that hasn't been added
    // by the user.
    //

    GetDlgItemText(hwnd,
                   IDT_PRINTERNAME,
                   PrinterNameBuffer,
                   MAX_PRINTERNAME + 1);

    if ( PrinterNameBuffer[0] != _T('\0') ) {
        if ( ! OnAddPrinter(hwnd) ) {
            return FALSE;
        }
    }

    return TRUE;
}

//----------------------------------------------------------------------------
//
// Function: DlgPrintersPage
//
// Purpose: The dialog proc for the printers page.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgPrintersPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd,
                               IDT_PRINTERNAME,
                               EM_LIMITTEXT,
                               MAX_PRINTERNAME,
                               0);
            break;

        case WM_COMMAND:
            {
                int nCtrlId;

                switch ( nCtrlId = LOWORD(wParam) ) {

                    case IDC_ADDPRINTER:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnAddPrinter(hwnd);
                        break;

                    case IDC_REMOVEPRINTER:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnRemovePrinter(hwnd);
                        break;

                    case IDC_PRINTERLIST:
                        if ( HIWORD(wParam) == LBN_SELCHANGE )
                            OnPrinterSelChange(hwnd);
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;

                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_INST_PRTR;

                        OnSetActivePrinterPage(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextPrinterPage(hwnd) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\passwd.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      passwd.c
//
// Description:
//      This file contains the dialog procedure for the Administrator
//      password page page (IDD_ADMINPASSWD).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define ADMIN_PASSWORD_SPIN_CONTROL_MIN 1
#define ADMIN_PASSWORD_SPIN_CONTROL_MAX 99

//----------------------------------------------------------------------------
//
//  Function: GreyPasswordPage
//
//  Purpose: Greys controls on this page.
//
//----------------------------------------------------------------------------

VOID GreyPasswordPage(HWND hwnd)
{
    BOOL bSpecify   = IsDlgButtonChecked(hwnd, IDC_SPECIFYPASSWD);
    BOOL bAutoLogon = IsDlgButtonChecked(hwnd, IDC_AUTOLOGON);

    TCHAR pw1[MAX_PASSWORD + 1];
    TCHAR pw2[MAX_PASSWORD + 1];

    BOOL bUnGreyRadio;

    //
    // Get the rest of the pertinent control settings
    //

    GetDlgItemText(hwnd, IDT_PASSWORD, pw1, StrBuffSize(pw1));
    GetDlgItemText(hwnd, IDT_CONFIRM,  pw2, StrBuffSize(pw2));

    //
    // Allow user to type into the edit fields (password & confirm) only
    // if the SpecifyPassword
    //

    EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_TEXT),         bSpecify);
    EnableWindow(GetDlgItem(hwnd, IDC_CONFIRM_PASSWORD_TEXT), bSpecify);

    EnableWindow(GetDlgItem(hwnd, IDT_PASSWORD), bSpecify);
    EnableWindow(GetDlgItem(hwnd, IDT_CONFIRM),  bSpecify);
    
    EnableWindow(GetDlgItem(hwnd, IDC_ENCRYPTADMINPASSWORD), bSpecify);
    
    //
    //  Grey/Ungrey the autologn appropriately
    //

    EnableWindow(GetDlgItem(hwnd, IDC_AUTOLOGON_COUNT_TEXT), bAutoLogon);
    EnableWindow(GetDlgItem(hwnd, IDC_AUTOLOGON_COUNT),      bAutoLogon);
    EnableWindow(GetDlgItem(hwnd, IDC_AUTOLOGON_COUNT_SPIN), bAutoLogon);

    //
    // Only show the "Don't specify a password" option if this is not
    // a fully automated deployment.
    //

    bUnGreyRadio = GenSettings.iUnattendMode != UMODE_FULL_UNATTENDED;
    EnableWindow(GetDlgItem(hwnd, IDC_NOPASSWORD), bUnGreyRadio);

}

//----------------------------------------------------------------------------
//
// Function: OnInitDialogAdminPassword
//
// Purpose:  Sets text limits on the edit boxes and spin control.
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnInitDialogAdminPassword( IN HWND hwnd )
{
    int nButtonId;

    SendDlgItemMessage(hwnd,
                       IDT_PASSWORD,
                       EM_LIMITTEXT,
                       MAX_PASSWORD,
                       0);

    SendDlgItemMessage(hwnd,
                       IDT_CONFIRM,
                       EM_LIMITTEXT,
                       MAX_PASSWORD,
                       0);

    //
    //  Set the range on the spin control: ADMIN_PASSWORD_SPIN_CONTROL_MIN to
    //  ADMIN_PASSWORD_SPIN_CONTROL_MAX
    //

    SendDlgItemMessage( hwnd,
                        IDC_AUTOLOGON_COUNT_SPIN,
                        UDM_SETRANGE32,
                        ADMIN_PASSWORD_SPIN_CONTROL_MIN,
                        ADMIN_PASSWORD_SPIN_CONTROL_MAX );

    //
    //  Set the default value for the spin control
    //

    SendDlgItemMessage( hwnd,
                        IDC_AUTOLOGON_COUNT_SPIN,
                        UDM_SETPOS,
                        0,
                        ADMIN_PASSWORD_SPIN_CONTROL_MIN );

        if ( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED )
        GenSettings.bSpecifyPassword = TRUE;

    //
    //  Make sure the Auto Logon Count is within expected range
    //
    if( GenSettings.nAutoLogonCount < ADMIN_PASSWORD_SPIN_CONTROL_MIN ||
        GenSettings.nAutoLogonCount > ADMIN_PASSWORD_SPIN_CONTROL_MAX )
    {
        SendDlgItemMessage( hwnd,
                            IDC_AUTOLOGON_COUNT_SPIN,
                            UDM_SETPOS,
                            0,
                            ADMIN_PASSWORD_SPIN_CONTROL_MIN );
    }
    else
    {

        TCHAR szAutoLogonCount[10];

        _itot( GenSettings.nAutoLogonCount, szAutoLogonCount, 10 );

        SetWindowText( GetDlgItem( hwnd, IDC_AUTOLOGON_COUNT ),
                       szAutoLogonCount );
    }

    //
    // Set the controls
    //

    nButtonId = GenSettings.bSpecifyPassword ? IDC_SPECIFYPASSWD
                                             : IDC_NOPASSWORD;
    CheckRadioButton(hwnd,
                     IDC_NOPASSWORD,
                     IDC_SPECIFYPASSWD,
                     nButtonId);

    CheckDlgButton(hwnd,
                   IDC_AUTOLOGON,
                   GenSettings.bAutoLogon ? BST_CHECKED : BST_UNCHECKED);

    SetDlgItemText(hwnd, IDT_PASSWORD, GenSettings.AdminPassword);
    SetDlgItemText(hwnd, IDT_CONFIRM,  GenSettings.ConfirmPassword);

    //
    // Grey controls
    //
    GreyPasswordPage(hwnd);
}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextAdminPassword
//
//  Purpose: Called at WIZNEXT time.
//
//----------------------------------------------------------------------------

BOOL OnWizNextAdminPassword(HWND hwnd)
{
    BOOL bReturn = TRUE;
    TCHAR szAutoLogonCount[10];

    GenSettings.bSpecifyPassword =
                    IsDlgButtonChecked(hwnd, IDC_SPECIFYPASSWD);

    GenSettings.bAutoLogon =
                    IsDlgButtonChecked(hwnd, IDC_AUTOLOGON);

    GetDlgItemText(hwnd,
                   IDT_PASSWORD,
                   GenSettings.AdminPassword,
                   StrBuffSize(GenSettings.AdminPassword));

    GetDlgItemText(hwnd,
                   IDT_CONFIRM,
                   GenSettings.ConfirmPassword,
                   StrBuffSize(GenSettings.ConfirmPassword));

    if ( GenSettings.bSpecifyPassword ) {

        if ( lstrcmp(GenSettings.AdminPassword,
                     GenSettings.ConfirmPassword) != 0 ) {
            ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_MISMATCH_PASSWORD);
            bReturn = FALSE;
        }
        
        // See if we should encrypt the password
        GenSettings.bEncryptAdminPassword = 
                    IsDlgButtonChecked(hwnd, IDC_ENCRYPTADMINPASSWORD);

    }

    //
    //  Store the Auto Logon Count
    //
    GetWindowText( GetDlgItem( hwnd, IDC_AUTOLOGON_COUNT ), szAutoLogonCount, 10 );

    GenSettings.nAutoLogonCount = _ttoi( szAutoLogonCount );

    //
    //  Ensure the number of network cards stays within its appropriate
    //  range
    //
    if( GenSettings.nAutoLogonCount < ADMIN_PASSWORD_SPIN_CONTROL_MIN ) {

        GenSettings.nAutoLogonCount = ADMIN_PASSWORD_SPIN_CONTROL_MIN;

    }
    else if( GenSettings.nAutoLogonCount > ADMIN_PASSWORD_SPIN_CONTROL_MAX ) {

        GenSettings.nAutoLogonCount = ADMIN_PASSWORD_SPIN_CONTROL_MAX;

    }

    //
    //  The AutoLogon Count is automatically 1 if they specify a NULL password
    //  so warn them about this.
    //
    if( bReturn && GenSettings.bAutoLogon && GenSettings.nAutoLogonCount > 1 )
    {

        if( GenSettings.AdminPassword[0] == _T('\0') )
        {

            INT nRetVal;

            nRetVal = ReportErrorId( hwnd, MSGTYPE_YESNO, IDS_WARN_NO_PASSWORD_AUTOLOGON );

            if( nRetVal == IDNO )
            {
                bReturn = FALSE;
            }
            else
            {
                GenSettings.nAutoLogonCount = 1;

                _itot( GenSettings.nAutoLogonCount, szAutoLogonCount, 10 );

                SetWindowText( GetDlgItem( hwnd, IDC_AUTOLOGON_COUNT ), szAutoLogonCount );
            }

        }

    }

    return bReturn;
}

//----------------------------------------------------------------------------
//
//  Function: ProcessWmCommandAdminPassword
//
//  Purpose: Called by the dlgproc to process the WM_COMMAND.  On this page
//           we need to grey/ungrey whenever radio buttons change and when
//           user puts text into the edit fields.
//
//----------------------------------------------------------------------------

BOOL ProcessWmCommandAdminPassword(
    IN HWND     hwnd,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch ( HIWORD(wParam) ) {

        case BN_CLICKED:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {

                    case IDC_NOPASSWORD:
                    case IDC_SPECIFYPASSWD:

                        CheckRadioButton(
                                hwnd,
                                IDC_NOPASSWORD,
                                IDC_SPECIFYPASSWD,
                                LOWORD(wParam));

                        GreyPasswordPage(hwnd);
                        break;

                    case IDC_AUTOLOGON:

                        GreyPasswordPage(hwnd);
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }

        case EN_CHANGE:
            {
                switch ( LOWORD(wParam) ) {

                    case IDT_PASSWORD:
                    case IDT_CONFIRM:

                        GreyPasswordPage(hwnd);
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }

    return bStatus;
}

//----------------------------------------------------------------------------
//
//  Function: DlgAdminPasswordPage
//
//  Purpose: This is the dialog procedure for the admin password page.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgAdminPasswordPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:

            OnInitDialogAdminPassword( hwnd );

            break;

        case WM_COMMAND:
            bStatus = ProcessWmCommandAdminPassword(hwnd, wParam, lParam);
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_ADMN_PASS;

                        WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextAdminPassword(hwnd) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by base.rc
//
#define IDD_PID_CD                      6000
#define IDD_COMPUTERNAME                6001
#define IDD_PRINTERS                    6002
#define IDD_TIMEZONE                    6003
#define IDD_RUNONCE                     6004
#define IDD_TARGETPATH                  6005
#define IDD_ADMINPASSWORD               6006
#define IDD_DISPLAY                     6007
#define IDD_SRVLICENSE                  6008
#define IDD_DISPLAY2                    6010
#define IDD_UNATTENDMODE                6011
#define IDD_NAMEORG                     6012
#define IDD_SIFTEXT                     6013
#define IDD_OEMDUPSTRING                6014
#define IDD_LICENSEAGREEMENT            6015
#define IDD_SYSPREPLICENSEAGREEMENT     6016
#define IDD_SYSPREPCOMPUTERNAME         6017
#define IDC_PROVIDE_DEFAULTS            6200
#define IDC_FULLUNATTEND                6201
#define IDC_HIDE_PAGES                  6202
#define IDC_READONLY                    6203
#define IDC_GUI_ATTENDED                6204
#define IDT_USERNAME                    6240
#define IDT_ORGANIZATION                6241
#define IDT_EDIT_PID1                   6260
#define IDT_EDIT_PID2                   6261
#define IDT_EDIT_PID3                   6262
#define IDT_EDIT_PID4                   6263
#define IDT_EDIT_PID5                   6264
#define IDT_COMPUTERNAME                6280
#define IDC_COMPUTERLIST                6281
#define IDC_ADDCOMPUTER                 6282
#define IDC_REMOVECOMPUTER              6283
#define IDC_LOADCOMPUTERNAMES           6284
#define IDC_AUTOCOMPUTERNAME            6285
#define IDC_COMPUTERTEXT                6286
#define IDC_COMPUTERPAGE_DESC1          6287
#define IDC_COMPUTERPAGE_DESC2          6288
#define IDC_COMPUTERS_TEXT              6289
#define IDT_PRINTERNAME                 6300
#define IDC_PRINTERLIST                 6301
#define IDC_ADDPRINTER                  6302
#define IDC_REMOVEPRINTER               6303
#define IDC_TIMEZONES                   6320
#define IDT_COMMAND                     6340
#define IDC_COMMANDLIST                 6341
#define IDC_ADDCOMMAND                  6342
#define IDC_REMOVECOMMAND               6343
#define IDC_BUT_MOVE_UP_RUNONCE         6344
#define IDC_BUT_MOVE_DOWN_RUNONCE       6345
#define IDC_NOTARGETPATH                6360
#define IDC_GENERATEPATH                6361
#define IDC_SPECIFYPATH                 6362
#define IDT_TARGETPATH                  6363
#define IDC_NOPASSWORD                  6380
#define IDC_SPECIFYPASSWD               6381
#define IDT_PASSWORD                    6382
#define IDT_CONFIRM                     6383
#define IDC_AUTOLOGON                   6384
#define IDC_AUTOLOGON_COUNT             6385
#define IDC_AUTOLOGON_COUNT_SPIN        6386
#define IDC_AUTOLOGON_COUNT_TEXT        6387
#define IDC_PASSWORD_TEXT               6388
#define IDC_CONFIRM_PASSWORD_TEXT       6389
#define IDC_ENCRYPTADMINPASSWORD        6390
#define IDC_COLORS                      6400
#define IDC_RESOLUTIONS                 6401
#define IDC_REFRESHRATES                6402
#define IDC_CUSTOM                      6403
#define IDC_BITSPERPEL2                 6420
#define IDC_XRESOLUTION2                6421
#define IDC_YRESOLUTION2                6422
#define IDC_REFRESHRATE2                6423
#define IDC_PERSERVER                   6440
#define IDC_PERSEAT                     6441
#define IDC_NUMCONNECT                  6442
#define IDC_SPIN                        6443
#define IDC_SIF_DESCRIPTION             6460
#define IDC_SIF_HELP_TEXT               6461
#define IDC_OEMDUPSTRING                6500
#define IDC_CB_ACCEPT_LICENSE           6520
#define IDC_RB_YES                      6540
#define IDC_RB_NO                       6541
#define IDC_SYSPREP_LICENSE_TEXT        6542
#define IDC_SYSPREP_AUTO                6543
#define IDC_SYSPREP_SPECIFY             6544
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         6544
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\pid.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      pid.c
//
// Description:
//      This file contains the dialog procedure for Product ID CD page
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "allres.h"

//----------------------------------------------------------------------------
//
//  Function: OnSetActivePid
//
//  Purpose: Called when page is about to display.  Init the controls.
//
//----------------------------------------------------------------------------

VOID OnSetActivePid(HWND hwnd)
{
    SetDlgItemText(hwnd, IDT_EDIT_PID1, GenSettings.ProductId[0]);
    SetDlgItemText(hwnd, IDT_EDIT_PID2, GenSettings.ProductId[1]);
    SetDlgItemText(hwnd, IDT_EDIT_PID3, GenSettings.ProductId[2]);
    SetDlgItemText(hwnd, IDT_EDIT_PID4, GenSettings.ProductId[3]);
    SetDlgItemText(hwnd, IDT_EDIT_PID5, GenSettings.ProductId[4]);

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextPid
//
//  Purpose: Called when user pushes NEXT button.  Get the data off the page.
//
//----------------------------------------------------------------------------

BOOL OnWizNextPid(HWND hwnd)
{
    BOOL bReturn = TRUE;

    //
    // Retrieve the product ID strings.
    //

    GetDlgItemText(hwnd,
                   IDT_EDIT_PID1,
                   GenSettings.ProductId[0],
                   MAX_PID_FIELD + 1);

    GetDlgItemText(hwnd,
                   IDT_EDIT_PID2,
                   GenSettings.ProductId[1],
                   MAX_PID_FIELD + 1);

    GetDlgItemText(hwnd,
                   IDT_EDIT_PID3,
                   GenSettings.ProductId[2],
                   MAX_PID_FIELD + 1);

    GetDlgItemText(hwnd,
                   IDT_EDIT_PID4,
                   GenSettings.ProductId[3],
                   MAX_PID_FIELD + 1);

    GetDlgItemText(hwnd,
                   IDT_EDIT_PID5,
                   GenSettings.ProductId[4],
                   MAX_PID_FIELD + 1);

    //
    // Validate the PID
    //

    if ( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED &&
         ( GenSettings.ProductId[0][0] == _T('\0') ||
           GenSettings.ProductId[1][0] == _T('\0') ||
           GenSettings.ProductId[2][0] == _T('\0') ||
           GenSettings.ProductId[3][0] == _T('\0') ||
           GenSettings.ProductId[4][0] == _T('\0') ) ) {

        ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_REQUIRE_PID);
        bReturn = FALSE;
    }

    return ( bReturn );
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR   szBuffer[MAX_PATH];
    
    if (codeNotify == EN_CHANGE)
    {
        switch ( id )
        {
            case IDT_EDIT_PID1:
                if ( GetDlgItemText(hwnd, IDT_EDIT_PID1, szBuffer, STRSIZE(szBuffer)) == MAX_PID_FIELD )
                    SetFocus(GetDlgItem(hwnd, IDT_EDIT_PID2));

                break;
            case IDT_EDIT_PID2:
                {
                    UINT cb = GetDlgItemText(hwnd, IDT_EDIT_PID2, szBuffer, STRSIZE(szBuffer));
                    if ( cb == MAX_PID_FIELD)
                        SetFocus(GetDlgItem(hwnd, IDT_EDIT_PID3));
                    else if ( cb == 0 )
                        SetFocus(GetDlgItem(hwnd, IDT_EDIT_PID1));
                }
                break;
            case IDT_EDIT_PID3:
                {
                    UINT cb = GetDlgItemText(hwnd, IDT_EDIT_PID3, szBuffer, STRSIZE(szBuffer));
                    if ( cb == MAX_PID_FIELD)
                        SetFocus(GetDlgItem(hwnd, IDT_EDIT_PID4));
                    else if ( cb == 0 )
                        SetFocus(GetDlgItem(hwnd, IDT_EDIT_PID2));
                }
                break;
            case IDT_EDIT_PID4:
                {
                    UINT cb = GetDlgItemText(hwnd, IDT_EDIT_PID4, szBuffer, STRSIZE(szBuffer));
                    if ( cb == MAX_PID_FIELD)
                        SetFocus(GetDlgItem(hwnd, IDT_EDIT_PID5));
                    else if ( cb == 0 )
                        SetFocus(GetDlgItem(hwnd, IDT_EDIT_PID3));
                }
                break;
            case IDT_EDIT_PID5:
                {
                    UINT cb = GetDlgItemText(hwnd, IDT_EDIT_PID5, szBuffer, STRSIZE(szBuffer));
                    if ( cb == MAX_PID_FIELD)
                        SetFocus(GetDlgItem(GetParent(hwnd), ID_MAINT_NEXT));
                    else if ( cb == 0 )
                        SetFocus(GetDlgItem(hwnd, IDT_EDIT_PID4));
                }
                break;
        }
    }


}


//----------------------------------------------------------------------------
//
// Function: DlgProductIdPage
//
// Purpose: This is the dialog procedure the product ID page
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgProductIdPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd,
                               IDT_EDIT_PID1,
                               EM_LIMITTEXT,
                               (WPARAM) MAX_PID_FIELD,
                               (LPARAM) 0);

            SendDlgItemMessage(hwnd,
                               IDT_EDIT_PID2,
                               EM_LIMITTEXT,
                               (WPARAM) MAX_PID_FIELD,
                               (LPARAM) 0);

            SendDlgItemMessage(hwnd,
                               IDT_EDIT_PID3,
                               EM_LIMITTEXT,
                               (WPARAM) MAX_PID_FIELD,
                               (LPARAM) 0);

            SendDlgItemMessage(hwnd,
                               IDT_EDIT_PID4,
                               EM_LIMITTEXT,
                               (WPARAM) MAX_PID_FIELD,
                               (LPARAM) 0);

            SendDlgItemMessage(hwnd,
                               IDT_EDIT_PID5,
                               EM_LIMITTEXT,
                               (WPARAM) MAX_PID_FIELD,
                               (LPARAM) 0);

            // Disable the IME for the PID edit boxes
            //
            ImmAssociateContext(GetDlgItem(hwnd, IDT_EDIT_PID1), NULL);
            ImmAssociateContext(GetDlgItem(hwnd, IDT_EDIT_PID2), NULL);
            ImmAssociateContext(GetDlgItem(hwnd, IDT_EDIT_PID3), NULL);
            ImmAssociateContext(GetDlgItem(hwnd, IDT_EDIT_PID4), NULL);
            ImmAssociateContext(GetDlgItem(hwnd, IDT_EDIT_PID5), NULL);

            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_PROD_KEY;

                        OnSetActivePid(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        
                        if ( !OnWizNextPid(hwnd) )
                            WIZ_FAIL(hwnd);
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\runonce.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      runonce.c
//
// Description:
//      This file contains the dialog procs and friends for the runonce page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//
// This is the generated cmd to add a printer
//

#define MAGIC_PRINTER_COMMAND _T("rundll32 printui.dll,PrintUIEntry /in /n")

//
// This is the cmd we display to the user in the UI.  In English, it is
// 'AddPrinter'
//

TCHAR *StrAddPrinter;

//----------------------------------------------------------------------------
//
//  Function: IsMagicPrinterCmd
//
//  Purpose: Checks the given GuiRunOnce string to see if it is our magic
//           command that installs a network printer.
//
//           There are 2 versions of this function.  This one looks
//           for the rundll32 magic command.  That is the version of the
//           add printer command that we record in the GuiRunOnce list and
//           it is written to the answer file as such.
//
//           The IsMagicPrinterCmd2 (defined below) looks for the magic
//           display string, e.g. AddPrinter \\foo\foo
//
//  Returns: Pointer to where the printer name should be in the string.
//           NULL if this RunOnce command isn't the magic printer cmd.
//
//  Notes:
//      This routine is exported for use by the printers page.
//
//----------------------------------------------------------------------------

LPTSTR IsMagicPrinterCmd(LPTSTR pRunOnceCmd)
{
    int len = lstrlen(MAGIC_PRINTER_COMMAND);
    TCHAR *p = NULL;

    //
    // Is it that magic 'rundll32 printui.dll ...'  If so, return a pointer
    // to the printer name
    //

    if ( lstrncmp(pRunOnceCmd, MAGIC_PRINTER_COMMAND, len) == 0 ) {
        p = pRunOnceCmd + len;
        while ( *p && iswspace(*p) )
            p++;
    }

    return p;
}

LPTSTR IsMagicPrinterCmd2(LPTSTR pRunOnceCmd)
{
    int len = lstrlen(StrAddPrinter);
    TCHAR *p = NULL;

    //
    // Is it the display version of the printer command?  e.g.
    // e.g. 'AddPrinter \\foo\foo'
    //
    // If so, return a pointer to the printer name
    //

    if ( lstrncmp(pRunOnceCmd, StrAddPrinter, len) == 0 ) {
        p = pRunOnceCmd + len;
        while ( *p && iswspace(*p) )
            p++;
    }

    return p;
}

//----------------------------------------------------------------------------
//
//  Function: GreyRunOncePage
//
//  Purpose: Greys controls on this page.  Called on all events where
//           greying might change.
//
//----------------------------------------------------------------------------

VOID GreyRunOncePage(HWND hwnd)
{
    INT_PTR   idx;
    HWND  hCtrl = GetDlgItem(hwnd, IDC_REMOVECOMMAND);
    TCHAR CmdBuffer[MAX_CMDLINE + 1] = _T("");
    BOOL  bGrey = TRUE;

    idx = SendDlgItemMessage(hwnd,
                             IDC_COMMANDLIST,
                             LB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0);

    //
    // Grey the remove button if nothing selected or if it's one of our
    // magic printer commands.
    //

    if ( idx == LB_ERR )
        bGrey = FALSE;

    else {
        SendDlgItemMessage(hwnd,
                           IDC_COMMANDLIST,
                           LB_GETTEXT,
                           (WPARAM) idx,
                           (LPARAM) CmdBuffer);

        if ( IsMagicPrinterCmd2(CmdBuffer) )
            bGrey = FALSE;
    }

    EnableWindow(hCtrl, bGrey);
}

//----------------------------------------------------------------------------
//
//  Function: OnRunOnceSeChange
//
//  Purpose: Called when a selection on the RunOnce list is about to be made.
//
//----------------------------------------------------------------------------

VOID OnRunOnceSelChange(HWND hwnd)
{
    SetArrows( hwnd,
               IDC_COMMANDLIST,
               IDC_BUT_MOVE_UP_RUNONCE,
               IDC_BUT_MOVE_DOWN_RUNONCE );

    GreyRunOncePage(hwnd);
}

//----------------------------------------------------------------------------
//
// Function: OnAddRunOnceCmd
//
// Purpose: This function is called when the user pushes the ADD button.
//
//          It is also called by the OnWizNext in the case that user left
//          some data in the edit field (auto-add).
//
//----------------------------------------------------------------------------

VOID OnAddRunOnceCmd(HWND hwnd)
{
    TCHAR CmdBuffer[MAX_CMDLINE + 1];

    //
    //  Get the edit field and add this command to the list box.  Clear the
    //  edit field.
    //

    GetDlgItemText( hwnd, IDT_COMMAND, CmdBuffer, MAX_CMDLINE + 1 );

    //
    //  Don't add a blank command
    //

    if( CmdBuffer[0] == _T('\0') )
    {
        return;
    }


    SendDlgItemMessage( hwnd,
                        IDC_COMMANDLIST,
                        LB_ADDSTRING,
                        (WPARAM) 0,
                        (LPARAM) CmdBuffer );

    SetDlgItemText( hwnd, IDT_COMMAND, _T("") );

    SetArrows( hwnd,
               IDC_COMMANDLIST,
               IDC_BUT_MOVE_UP_RUNONCE,
               IDC_BUT_MOVE_DOWN_RUNONCE );
}

//----------------------------------------------------------------------------
//
//  Function: OnRemoveRunOnceCmd
//
//  Purpose: This function is called when the user pushes the REMOVE button
//
//----------------------------------------------------------------------------

VOID OnRemoveRunOnceCmd(HWND hwnd)
{
    INT_PTR idx, Count;
    TCHAR CmdBuffer[MAX_CMDLINE + 1];

    //
    // Get users selection of the command to remove
    //

    idx = SendDlgItemMessage(hwnd,
                             IDC_COMMANDLIST,
                             LB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0);

    if ( idx == LB_ERR )
        return;

    //
    // Retrieve the name to remove from listbox
    //

    SendDlgItemMessage(hwnd,
                       IDC_COMMANDLIST,
                       LB_GETTEXT,
                       (WPARAM) idx,
                       (LPARAM) CmdBuffer);

    //
    // Remove it from the listbox display
    //

    SendDlgItemMessage(hwnd,
                       IDC_COMMANDLIST,
                       LB_DELETESTRING,
                       (WPARAM) idx,
                       (LPARAM) 0);

    //
    // Set a new selection
    //

    Count = SendDlgItemMessage(hwnd,
                               IDC_COMMANDLIST,
                               LB_GETCOUNT,
                               (WPARAM) 0,
                               (LPARAM) 0);

    if ( Count ) {
        if ( idx >= Count )
            idx--;
        SendDlgItemMessage(hwnd,
                           IDC_COMMANDLIST,
                           LB_SETCURSEL,
                           (WPARAM) idx,
                           (LPARAM) 0);
    }

    //
    // There might be nothing selected now, and the current selection
    // might be a magic printer command
    //

    GreyRunOncePage(hwnd);

    SetArrows( hwnd,
               IDC_COMMANDLIST,
               IDC_BUT_MOVE_UP_RUNONCE,
               IDC_BUT_MOVE_DOWN_RUNONCE );
}

//----------------------------------------------------------------------------
//
//  Function: CheckThatPrintersAreInstalled
//
//  Purpose: This function is called by the SetActive routine to make
//           sure that the magic rundll32 command is in the GuiRunOnce
//           list for each of the printers the user wants installed.
//
//           Since user can go back/next and change the printer list,
//           we also have to check that there aren't GuiRunOnce commands
//           for printers that the user no longer wants installed.
//
//----------------------------------------------------------------------------

VOID CheckThatPrintersAreInstalled(HWND hwnd)
{
    UINT i, nNames, iRunOnce;

    //
    // Loop over the list of RunOnceCmds and look for those magic
    // printer commands.
    //
    // When you find a magic printer command in RunOnceCmds, check if
    // it is listed in PrinterNames.  If not, delete it from RunOnceCmds.
    //
    // Note, the loop is written as such because we may delete entries
    // from the list while looping over it, thus changing the size
    // of it.
    //

    iRunOnce = 0;

    if ( GetNameListSize(&GenSettings.RunOnceCmds) > 0 ) {

        do {

            TCHAR *pNextName, *pPrinterName;
            BOOL bRemoveThisOne = FALSE;

            pNextName    = GetNameListName(&GenSettings.RunOnceCmds, iRunOnce);
            pPrinterName = IsMagicPrinterCmd(pNextName);

            //
            // Remove this one only if it is a magic add printer command
            // and we cannot find it in the PrinterList
            //

            if ( pPrinterName != NULL &&
                 FindNameInNameList(
                            &GenSettings.PrinterNames,
                            pPrinterName) < 0 )
                bRemoveThisOne = TRUE;

            if ( bRemoveThisOne )
                RemoveNameFromNameListIdx(&GenSettings.RunOnceCmds, iRunOnce);
            else
                iRunOnce++;

        } while ( iRunOnce < GetNameListSize(&GenSettings.RunOnceCmds) );
    }

    //
    // Now loop over the list of printers and be sure that each one
    // has it's own magic command in RunOnceCmds.
    //

    for ( i = 0, nNames = GetNameListSize(&GenSettings.PrinterNames);
          i < nNames;
          i++ ) {

        TCHAR *pNextName, CmdBuffer[MAX_CMDLINE + 1];
        HRESULT hrPrintf;

        pNextName = GetNameListName(&GenSettings.PrinterNames, i);

        hrPrintf=StringCchPrintf(CmdBuffer, AS(CmdBuffer),_T("%s %s"), MAGIC_PRINTER_COMMAND, pNextName);

        if ( FindNameInNameList(&GenSettings.RunOnceCmds, CmdBuffer) < 0 )
            AddNameToNameList(&GenSettings.RunOnceCmds, CmdBuffer);
    }

}

//----------------------------------------------------------------------------
//
// Function: OnInitDialogRunOncePage
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnInitDialogRunOncePage( IN HWND hwnd )
{

    SendDlgItemMessage(hwnd,
                       IDT_COMMAND,
                       EM_LIMITTEXT,
                       (WPARAM) MAX_CMDLINE,
                       (LPARAM) 0);

    StrAddPrinter = MyLoadString(IDS_ADD_PRINTER);

    SetArrows( hwnd,
               IDC_COMMANDLIST,
               IDC_BUT_MOVE_UP_RUNONCE,
               IDC_BUT_MOVE_DOWN_RUNONCE );

}

//----------------------------------------------------------------------------
//
//  Function: OnSetActiveRunOncePage
//
//  Purpose: This function is called when the RunOnce page is about to
//           display.
//
//----------------------------------------------------------------------------

VOID OnSetActiveRunOncePage(HWND hwnd)
{
    UINT  i, nNames;
    TCHAR CmdBuffer[MAX_CMDLINE + 1];
   HRESULT hrPrintf;

    //
    // Remove everything from the display
    //

    SendDlgItemMessage(hwnd,
                       IDC_COMMANDLIST,
                       LB_RESETCONTENT,
                       (WPARAM) 0,
                       (LPARAM) 0);

    //
    // Deal with network printers
    //

    CheckThatPrintersAreInstalled(hwnd);

    //
    // Fill in the listbox with all of the commands.  If it's a magic
    // printer command, translate what is displayed on the screen.
    //

    for ( i = 0, nNames = GetNameListSize(&GenSettings.RunOnceCmds);
          i < nNames;
          i++ ) {

        TCHAR *pNextName, *pPrinterName;

        pNextName = GetNameListName(&GenSettings.RunOnceCmds, i);

        if ( (pPrinterName = IsMagicPrinterCmd(pNextName)) != NULL )
            hrPrintf=StringCchPrintf(CmdBuffer, AS(CmdBuffer), _T("%s %s"), StrAddPrinter, pPrinterName);
        else
            lstrcpyn(CmdBuffer, pNextName, AS ( CmdBuffer ));

        SendDlgItemMessage(hwnd,
                           IDC_COMMANDLIST,
                           LB_ADDSTRING,
                           (WPARAM) 0,
                           (LPARAM) CmdBuffer);
    }

    GreyRunOncePage(hwnd);

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextRunOncePage
//
//  Purpose: This function is called when the user pushes NEXT.
//
//----------------------------------------------------------------------------

VOID OnWizNextRunOncePage(HWND hwnd)
{
    INT_PTR   i;
    INT_PTR   iNumItems;
    INT_PTR   iRetVal;
    TCHAR CmdBuffer[MAX_CMDLINE + 1];
    TCHAR PrinterBuffer[MAX_CMDLINE + 1];
    TCHAR CommandBuffer[MAX_CMDLINE + 1];
    TCHAR *pPrinterName = NULL;
    BOOL  bStayHere = FALSE;

    //
    // If there's a command in the edit field, auto-add it to the list
    // of commands
    //

    GetDlgItemText(hwnd, IDT_COMMAND, CommandBuffer, MAX_CMDLINE + 1);

    if ( CommandBuffer[0] != _T('\0') )
        OnAddRunOnceCmd(hwnd);

    //
    //  Add all the items in the list box to the RunOnce Namelist
    //

    iNumItems = SendDlgItemMessage( hwnd,
                                    IDC_COMMANDLIST,
                                    LB_GETCOUNT,
                                    (WPARAM) 0,
                                    (LPARAM) 0 );

    ResetNameList( &GenSettings.RunOnceCmds );

    for( i = 0; i < iNumItems; i++ )
    {

        iRetVal = SendDlgItemMessage( hwnd,
                                      IDC_COMMANDLIST,
                                      LB_GETTEXT,
                                      (WPARAM) i,
                                      (LPARAM) CmdBuffer );

        if( iRetVal == LB_ERR )
        {
            AssertMsg( FALSE,
                       "Error adding items to namelist." );

            break;
        }

        //
        //  See if it is a command to add a printer
        //

        pPrinterName = IsMagicPrinterCmd2( CmdBuffer );

        if( pPrinterName )
        {
            TCHAR szPrinterName[MAX_PRINTERNAME + 1];
            HRESULT hrPrintf;

            lstrcpyn( szPrinterName, pPrinterName, AS ( szPrinterName ) );

            hrPrintf=StringCchPrintf( CmdBuffer, AS(CmdBuffer), _T("%s %s"), MAGIC_PRINTER_COMMAND, szPrinterName );
        }

        AddNameToNameList( &GenSettings.RunOnceCmds, CmdBuffer );

    }

}

//----------------------------------------------------------------------------
//
//  Function: DlgRunOncePage
//
//  Purpose: This is the dlgproc for the runonce page.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgRunOncePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL  bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:

            OnInitDialogRunOncePage( hwnd );

            break;

        case WM_COMMAND:
            {
                int nCtrlId;

                switch ( nCtrlId = LOWORD(wParam) ) {

                    case IDC_ADDCOMMAND:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnAddRunOnceCmd(hwnd);
                        break;

                    case IDC_REMOVECOMMAND:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnRemoveRunOnceCmd(hwnd);
                        break;

                    case IDC_COMMANDLIST:
                        if ( HIWORD(wParam) == LBN_SELCHANGE )
                            OnRunOnceSelChange(hwnd);
                        break;

                    case IDC_BUT_MOVE_UP_RUNONCE:

                        OnUpButtonPressed( hwnd, IDC_COMMANDLIST );

                        SetArrows( hwnd,
                                   IDC_COMMANDLIST,
                                   IDC_BUT_MOVE_UP_RUNONCE,
                                   IDC_BUT_MOVE_DOWN_RUNONCE );
                        break;

                    case IDC_BUT_MOVE_DOWN_RUNONCE:

                        OnDownButtonPressed( hwnd, IDC_COMMANDLIST );

                        SetArrows( hwnd,
                                   IDC_COMMANDLIST,
                                   IDC_BUT_MOVE_UP_RUNONCE,
                                   IDC_BUT_MOVE_DOWN_RUNONCE );
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;

                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_RUN_ONCE;

                        OnSetActiveRunOncePage(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        OnWizNextRunOncePage(hwnd);
                        bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\siftext.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      siftext.c
//
// Description:
//      This file contains the dialog procedure for the sif text settings
//      (IDD_SIFTEXT).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
// Function: OnSifTextInitDialog
//
// Purpose:  Set max length on the edit boxes
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnSifTextInitDialog( IN HWND hwnd ) {

    SendDlgItemMessage( hwnd,
                        IDC_SIF_DESCRIPTION,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_SIF_DESCRIPTION_LENGTH,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_SIF_HELP_TEXT,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_SIF_HELP_TEXT_LENGTH,
                        (LPARAM) 0 );

}

//----------------------------------------------------------------------------
//
// Function: OnSifTextSetActive
//
// Purpose:  places the SIF text strings from the global variables into the
//           the edit boxes
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnSifTextSetActive( IN HWND hwnd ) {

    SetWindowText( GetDlgItem( hwnd, IDC_SIF_DESCRIPTION),
                   GenSettings.szSifDescription );

    SetWindowText( GetDlgItem( hwnd, IDC_SIF_HELP_TEXT),
                   GenSettings.szSifHelpText );
}

//----------------------------------------------------------------------------
//
// Function: OnWizNextSifText
//
// Purpose:  Store the strings from the SIF text page into the appropriate
//           global variables
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnWizNextSifText( IN HWND hwnd ) {

    GetWindowText( GetDlgItem( hwnd, IDC_SIF_DESCRIPTION),
                   GenSettings.szSifDescription,
                   MAX_SIF_DESCRIPTION_LENGTH+1);

    GetWindowText( GetDlgItem( hwnd, IDC_SIF_HELP_TEXT),
                   GenSettings.szSifHelpText,
                   MAX_SIF_HELP_TEXT_LENGTH+1);

}

//----------------------------------------------------------------------------
//
// Function: DlgSifTextSettingsPage
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
DlgSifTextSettingsPage( IN HWND     hwnd,
                        IN UINT     uMsg,
                        IN WPARAM   wParam,
                        IN LPARAM   lParam) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            // do nothing

            break;

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:

                    WIZ_CANCEL(hwnd); 
                    break;

                case PSN_SETACTIVE: {

                    g_App.dwCurrentHelp = IDH_SIF_RIS;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_FINISH);

                    OnSifTextSetActive( hwnd );

                    break;

                }
                case PSN_WIZBACK:

                    bStatus = FALSE; 
                    break;

                case PSN_WIZNEXT:

                    OnWizNextSifText( hwnd );

                    bStatus = FALSE; 
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:

                    break;
            }


            break;
        }

        default:
            bStatus = FALSE;
            break;

    }

    return bStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\spcomnam.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      spcomnam.c
//
// Description:
//      This file has the dialog procedure for the sysprep computer name page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//-------------------------------------------------------------------------
//
//  Function: EnableControls
//
//  Purpose: Enables/Disables the controls based on what the user has selected
//
//-------------------------------------------------------------------------
static void EnableControls(HWND hwnd)
{
    BOOL fEnable = ( IsDlgButtonChecked(hwnd, IDC_SYSPREP_SPECIFY) == BST_CHECKED );

    EnableWindow(GetDlgItem(hwnd, IDC_COMPUTERTEXT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDT_COMPUTERNAME), fEnable);
}


//-------------------------------------------------------------------------
//
//  Function: OnInitSysprepComputerName
//
//  Purpose: Called when page is first displayed
//
//-------------------------------------------------------------------------
BOOL
OnInitSysprepComputerName(IN HWND hwnd, IN HWND hwndFocus, IN LPARAM lParam)
{
    // Limit the text in the dialog
    //
    SendDlgItemMessage(hwnd,
        IDT_COMPUTERNAME,
        EM_LIMITTEXT,
        (WPARAM) MAX_COMPUTERNAME,
        (LPARAM) 0);

    // Select the correct radio button
    //
    if ( GenSettings.bAutoComputerName )
        CheckRadioButton(hwnd, IDC_SYSPREP_AUTO, IDC_SYSPREP_SPECIFY, IDC_SYSPREP_AUTO);
    else
    {
        // Check the default radio
        //
        CheckRadioButton(hwnd, IDC_SYSPREP_AUTO, IDC_SYSPREP_SPECIFY, IDC_SYSPREP_SPECIFY);

        // Set the default computer name
        //
        if ( GenSettings.ComputerNames.Names )
            SetDlgItemText(hwnd, IDT_COMPUTERNAME, GenSettings.ComputerNames.Names[0]);
    }

    EnableControls(hwnd);

    return FALSE;
}


//-------------------------------------------------------------------------
//
//  Function: OnCommandSysprepComputerName
//
//  Purpose: When user interacts with wizard page
//
//-------------------------------------------------------------------------
VOID
OnCommandSysprepComputerName(IN HWND hwnd, IN INT id, IN HWND hwndCtl, IN UINT codeNotify)
{
    switch ( id )
    {

        case IDC_SYSPREP_SPECIFY:
        case IDC_SYSPREP_AUTO:
            EnableControls(hwnd);
            break;
    }
}

//-------------------------------------------------------------------------
//
//  Function: OnWizNextSysprepComputerName
//
//  Purpose: Called when user is done with the sysprep computername page
//
//-------------------------------------------------------------------------
BOOL
OnWizNextSysprepComputerName(IN HWND hwnd)
{
    TCHAR ComputerNameBuffer[MAX_COMPUTERNAME + 1];

    //
    // Get the computername the user typed in
    //
    if ( IsDlgButtonChecked(hwnd, IDC_SYSPREP_SPECIFY) == BST_CHECKED )
        GetDlgItemText(hwnd, IDT_COMPUTERNAME, ComputerNameBuffer, MAX_COMPUTERNAME + 1);
    else
        lstrcpyn(ComputerNameBuffer, _T("*"),AS(ComputerNameBuffer));

    //
    // If this is a fully unattended answer file, the computer name cannot
    // be left blank.
    //
    if ( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED ) {

        if( ComputerNameBuffer[0] == _T('\0') ) {

            ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_SYSPREP_REQUIRE_COMPNAME );

            return FALSE;
        }
    }

    //
    //  Make sure it is a valid computer name (don't need to check it if it
    //  is blank)
    //

    if( ComputerNameBuffer[0] != _T('\0') ) {

        if(( IsDlgButtonChecked(hwnd, IDC_SYSPREP_SPECIFY) == BST_CHECKED ) && !IsValidComputerName( ComputerNameBuffer )) {

            ReportErrorId( hwnd,
                           MSGTYPE_ERR,
                           IDS_ERR_INVALID_COMPUTER_NAME,
                           IllegalNetNameChars );

            return FALSE;

        }
        else {

            // Clear out the old comptuer names
            //
            ResetNameList(&GenSettings.ComputerNames);

            //  Store the computer name
            //
            AddNameToNameList( &GenSettings.ComputerNames, ComputerNameBuffer );

        }

    }

    return TRUE;    
}

//-------------------------------------------------------------------------
//
//  Function: DlgSysprepComputerNamePage
//
//  Purpose: Dialog proc for the Sysprep ComputerName page.
//
//-------------------------------------------------------------------------

INT_PTR CALLBACK DlgSysprepComputerNamePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitSysprepComputerName);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommandSysprepComputerName);

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;

                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_COMP_NAME;

                        WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextSysprepComputerName(hwnd) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\targpath.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      targpath.c
//
// Description:
//      This file contains the dialog procedure for the TargetPath page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//---------------------------------------------------------------------------
//
//  Function: GreyUnGreyTargPath
//
//  Purpose: Called whenever a radio button selection might have changed
//           to properly grey out the edit field.
//
//---------------------------------------------------------------------------

VOID GreyUnGreyTargPath(HWND hwnd)
{
    BOOL bUnGrey = IsDlgButtonChecked(hwnd, IDC_SPECIFYPATH);

    EnableWindow(GetDlgItem(hwnd, IDT_TARGETPATH), bUnGrey);
}

//---------------------------------------------------------------------------
//
//  Function: OnSetActiveTargPath
//
//  Purpose: Called when SETACTIVE comes.
//
//---------------------------------------------------------------------------

VOID OnSetActiveTargPath(HWND hwnd)
{
    int nButtonId = IDC_NOTARGETPATH;

    switch ( GenSettings.iTargetPath ) {

        case TARGPATH_UNDEFINED:
        case TARGPATH_WINNT:
            nButtonId = IDC_NOTARGETPATH;
            break;

        case TARGPATH_AUTO:
            nButtonId = IDC_GENERATEPATH;
            break;

        case TARGPATH_SPECIFY:
            nButtonId = IDC_SPECIFYPATH;
            break;

        default:
            AssertMsg(FALSE, "Bad targpath");
            break;
    }

    CheckRadioButton(hwnd, IDC_NOTARGETPATH, IDC_SPECIFYPATH, nButtonId);

    SetDlgItemText(hwnd, IDT_TARGETPATH, GenSettings.TargetPath);

    GreyUnGreyTargPath(hwnd);

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
//  Function: OnRadioButtonTargPath
//
//  Purpose: Called when a radio button is pushed.
//
//----------------------------------------------------------------------------

VOID OnRadioButtonTargPath(HWND hwnd, int nButtonId)
{
    CheckRadioButton(hwnd, IDC_NOTARGETPATH, IDC_SPECIFYPATH, nButtonId);
    GreyUnGreyTargPath(hwnd);
}

//---------------------------------------------------------------------------
//
//  Function: ValidateTargPath
//
//  Purpose: Validates whether the pathname passed in is valid or not.
//
//---------------------------------------------------------------------------

BOOL ValidateTargPath(HWND hwnd)
{
    //
    // If user selected IDC_SPECIFYPATH, validate the pathname entered
    //

    if ( GenSettings.iTargetPath == TARGPATH_SPECIFY ) {

        //
        // Give a specific error message for the empty case
        //

        if ( GenSettings.TargetPath[0] == _T('\0') ) {
            ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_SPECIFY_TARGPATH);
            SetFocus(GetDlgItem(hwnd, IDT_TARGETPATH));
            return FALSE;
        }

        //
        // Give user a specific error message if he entered a drive letter.
        // One must use /tempdrive: to specify the target drive.
        //

        if ( towupper(GenSettings.TargetPath[0]) >= _T('A') &&
             towupper(GenSettings.TargetPath[0]) <= _T('Z') &&
             GenSettings.TargetPath[1] == _T(':')           ) {

            ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_DRIVE_IN_TARGPATH);
            SetFocus(GetDlgItem(hwnd, IDT_TARGETPATH));
            return FALSE;
        }

        //
        // See if it is a valid 8.3 path name with no drive letter.
        //

        if ( ! IsValidPathNameNoRoot8_3(GenSettings.TargetPath) ) {
            ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_INVALID_TARGPATH);
            SetFocus(GetDlgItem(hwnd, IDT_TARGETPATH));
            return FALSE;
        }
    }

    return TRUE;
}

//---------------------------------------------------------------------------
//
//  Function: OnWizNextTargPath
//
//  Purpose: Called when NEXT button is pushed.  Retrieve and save
//           settings.
//
//---------------------------------------------------------------------------

BOOL OnWizNextTargPath(HWND hwnd)
{
    //
    // Retrieve the selection
    //

    if ( IsDlgButtonChecked(hwnd, IDC_NOTARGETPATH) )
        GenSettings.iTargetPath = TARGPATH_WINNT;

    else if ( IsDlgButtonChecked(hwnd, IDC_GENERATEPATH) )
        GenSettings.iTargetPath = TARGPATH_AUTO;

    else
        GenSettings.iTargetPath = TARGPATH_SPECIFY;

    //
    // Retrieve any pathname typed in.
    //

    GetDlgItemText(hwnd,
                   IDT_TARGETPATH,
                   GenSettings.TargetPath,
                   MAX_TARGPATH + 1);

    //
    // Validate values on this page.
    //

    if ( ValidateTargPath(hwnd) )
        return TRUE;
    else
        return FALSE;
}

//---------------------------------------------------------------------------
//
//  Function: DlgTargetPathPage
//
//  Purpose: This is the dlg proc for the target path page
//
//---------------------------------------------------------------------------

INT_PTR CALLBACK DlgTargetPathPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd,
                               IDT_TARGETPATH,
                               EM_LIMITTEXT,
                               (WPARAM) MAX_TARGPATH,
                               (LPARAM) 0);
            break;

        case WM_COMMAND:
            {
                UINT nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {

                    case IDC_NOTARGETPATH:
                    case IDC_GENERATEPATH:
                    case IDC_SPECIFYPATH:

                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnRadioButtonTargPath(hwnd, LOWORD(wParam));
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:
                        
                        g_App.dwCurrentHelp = IDH_INST_FLDR;

                        OnSetActiveTargPath(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextTargPath(hwnd) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\umode.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      umode.c
//
// Description:
//      This file contains the unattended mode page (IDD_UNATTENDMODE).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//
// The descriptions displayed on the page, loaded from .res at dlg init time
//

TCHAR *StrDescrProvideDefaults;
TCHAR *StrDescrDefaultHide;
TCHAR *StrDescrReadOnly;
TCHAR *StrDescrGuiAttended;
TCHAR *StrDescrFullUnattend;


//----------------------------------------------------------------------------
//
//  Function: OnSetActiveUnattendMode
//
//  Purpose: Called at SETACTIVE time.
//
//----------------------------------------------------------------------------

VOID
OnSetActiveUnattendMode(HWND hwnd)
{
    int nButtonId = IDC_PROVIDE_DEFAULTS;

    //
    // Translate the enum to a radio button id
    //

    switch ( GenSettings.iUnattendMode ) {

        case UMODE_PROVIDE_DEFAULT:
            nButtonId = IDC_PROVIDE_DEFAULTS;
            break;

        case UMODE_FULL_UNATTENDED:
            nButtonId = IDC_FULLUNATTEND;
            break;

        case UMODE_DEFAULT_HIDE:
            nButtonId = IDC_HIDE_PAGES;
            break;

        case UMODE_READONLY:
            nButtonId = IDC_READONLY;
            break;

        case UMODE_GUI_ATTENDED:
            nButtonId = IDC_GUI_ATTENDED;
            break;

        default:
            AssertMsg(FALSE, "Bad case in SetActiveUnattendMode");
            break;
    }

    CheckRadioButton(hwnd, IDC_PROVIDE_DEFAULTS, IDC_GUI_ATTENDED, nButtonId);

    //
    // Set the wiz buttons
    //

    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextUnattendMode
//
//  Purpose: Called when user pushes NEXT button.  Time to save the selection.
//
//----------------------------------------------------------------------------

VOID
OnWizNextUnattendMode(HWND hwnd)
{
    //
    // Translate the radio button to the enum and remember it in the global
    //

    if ( IsDlgButtonChecked(hwnd, IDC_PROVIDE_DEFAULTS) )
        GenSettings.iUnattendMode = UMODE_PROVIDE_DEFAULT;

    else if ( IsDlgButtonChecked(hwnd, IDC_HIDE_PAGES) )
        GenSettings.iUnattendMode = UMODE_DEFAULT_HIDE;

    else if ( IsDlgButtonChecked(hwnd, IDC_READONLY) )
        GenSettings.iUnattendMode = UMODE_READONLY;

    else if ( IsDlgButtonChecked(hwnd, IDC_GUI_ATTENDED) )
        GenSettings.iUnattendMode = UMODE_GUI_ATTENDED;

    else
        GenSettings.iUnattendMode = UMODE_FULL_UNATTENDED;
}

//----------------------------------------------------------------------------
//
// Function: DlgUnattendModePage
//
// Purpose: This is the dialog procedure the unattend mode page
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK
DlgUnattendModePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            StrDescrProvideDefaults = MyLoadString(IDS_UMODE_PROVIDE_DEFAULTS);
            StrDescrFullUnattend    = MyLoadString(IDS_UMODE_FULLUNATTEND);
            StrDescrDefaultHide     = MyLoadString(IDS_UMODE_DEFAULT_HIDE);
            StrDescrReadOnly        = MyLoadString(IDS_UMODE_READONLY);
            StrDescrGuiAttended     = MyLoadString(IDS_UMODE_GUI_ATTENDED);
            break;

        case WM_COMMAND:
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_USER_INTER;

                        if ( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
                            WIZ_SKIP( hwnd );
                        else
                            OnSetActiveUnattendMode(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:

                        OnWizNextUnattendMode(hwnd);
                        bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\timezone.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      timezone.c
//
// Description:
//      This file contains the dialog procedure for the timezone
//      page (IDD_TIMEZONE).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//--------------------------------------------------------------------------
//
// WM_INIT
//
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Function: OnInitTimeZone
//
//  Purpose: Called at INIT_DIALOG time.  Put each of the timezone choices
//           into the drop-down list.
//
//----------------------------------------------------------------------------

VOID OnInitTimeZone(HWND hwnd)
{
    int i;
    TCHAR *szTempString;

    //
    // The list of available timezones should have been read from the
    // registry at wizard init time
    //

    if ( FixedGlobals.TimeZoneList == NULL ||
         FixedGlobals.TimeZoneList->NumEntries <= 0 ) {

        ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_CANNOT_LOAD_TIMEZONES);
        GenSettings.TimeZoneIdx = TZ_IDX_GMT;
        WIZ_SKIP(hwnd);
    }
}

//--------------------------------------------------------------------------
//
// SETACTIVE
//
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Function: OnSetActiveTimeZone
//
//  Purpose: Called at SETACTIVE time.  Find GenSettings.TimeZoneIdx and
//           display it.
//
//----------------------------------------------------------------------------

VOID OnSetActiveTimeZone(HWND hwnd)
{
    int i;
    INT_PTR  nItems;
    BOOL bSetOne;

    //
    // The wizard reset routine sets the current timezone index to undefined
    // so that we can choose the best SetupMgr default here.
    //
    // It's done this way because the wizard reset routine can't yet know
    // if we're making a RIS or not.
    //
    // Note that the user can't choose TZ_IDX_UNDEFINED, we never put it
    // into the display.
    //

    if ( GenSettings.TimeZoneIdx == TZ_IDX_UNDEFINED ) {

        if ( WizGlobals.iProductInstall == PRODUCT_REMOTEINSTALL )
            GenSettings.TimeZoneIdx = TZ_IDX_SETSAMEASSERVER;
        else
            GenSettings.TimeZoneIdx = TZ_IDX_DONOTSPECIFY;
    }

    //
    // Put each timezone choice into the drop-down list.  Put a back-pointer
    // on each entry to the TIME_ZONE_ENTRY record associatted with it.
    //

    SendDlgItemMessage(hwnd,
                       IDC_TIMEZONES,
                       CB_RESETCONTENT,
                       (WPARAM) 0,
                       (LPARAM) 0);

    for ( i=0; i<FixedGlobals.TimeZoneList->NumEntries; i++ ) {

        TIME_ZONE_ENTRY *Entry = &FixedGlobals.TimeZoneList->TimeZones[i];
        LPTSTR          Name   = Entry->DisplayName;
        INT_PTR         idx;

        //
        // Only the Remote Install case should have "Set Same As Server"
        //

        if ( WizGlobals.iProductInstall != PRODUCT_REMOTEINSTALL &&
             Entry->Index == TZ_IDX_SETSAMEASSERVER )
            continue;

        //
        // The "Do not specify" choice should be hidden if FullyAutomated
        //

        if ( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED &&
             Entry->Index == TZ_IDX_DONOTSPECIFY )
            continue;

        //
        // Put the choice into the drop-down list
        //

        idx = SendDlgItemMessage(hwnd,
                                 IDC_TIMEZONES,
                                 CB_ADDSTRING,
                                 (WPARAM) 0,
                                 (LPARAM) Name);

        //
        // Save a back-pointer to the TIME_ZONE_ENTRY
        //

        SendDlgItemMessage(hwnd,
                           IDC_TIMEZONES,
                           CB_SETITEMDATA,
                           (WPARAM) idx,
                           (LPARAM) Entry);
    }

    //
    // Walk through the items actually in the display and find the one
    // that matches the current timezone and make that one the cur choice.
    //

    nItems = SendDlgItemMessage(hwnd,
                                IDC_TIMEZONES,
                                CB_GETCOUNT,
                                (WPARAM) 0,
                                (LPARAM) 0);

    for ( i=0, bSetOne=FALSE; i<nItems; i++ ) {

        TIME_ZONE_ENTRY *Entry;

        Entry = (TIME_ZONE_ENTRY*) SendDlgItemMessage(hwnd,
                                                      IDC_TIMEZONES,
                                                      CB_GETITEMDATA,
                                                      (WPARAM) i,
                                                      (LPARAM) 0);

        if ( Entry->Index == GenSettings.TimeZoneIdx ) {

            SendDlgItemMessage(hwnd,
                               IDC_TIMEZONES,
                               CB_SETCURSEL,
                               (WPARAM) i,
                               (LPARAM) 0);
            bSetOne = TRUE;
        }
    }

    //
    // If a timezone was never chosen from the list, just pick Greenwich
    // time.  This could happen if the user loaded an invalid answer file
    // with an invalid TimeZoneIdx.
    //

    if ( ! bSetOne ) {

        for ( i=0, bSetOne=FALSE; i<nItems; i++ ) {

            TIME_ZONE_ENTRY *Entry;

            Entry = (TIME_ZONE_ENTRY*) SendDlgItemMessage(hwnd,
                                                          IDC_TIMEZONES,
                                                          CB_GETITEMDATA,
                                                          (WPARAM) i,
                                                          (LPARAM) 0);

            if ( Entry->Index == TZ_IDX_GMT ) {

                SendDlgItemMessage(hwnd,
                                   IDC_TIMEZONES,
                                   CB_SETCURSEL,
                                   (WPARAM) i,
                                   (LPARAM) 0);
                bSetOne = TRUE;
            }
        }

        if( ! bSetOne ) {

            //
            //  If we get to hear then the user hasn't specifed a timezone
            //  and the Greenwich timezone doesn't exist so we got a problem
            //

            AssertMsg( FALSE, "Error no timzone got selected." );

            SendDlgItemMessage(hwnd,
                               IDC_TIMEZONES,
                               CB_SETCURSEL,
                               (WPARAM) 0,
                               (LPARAM) 0);

        }
    }

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}

//--------------------------------------------------------------------------
//
// WIZNEXT
//
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Function: OnWizNextTimeZone
//
//  Purpose: Called when user pushes NEXT button.  Retrieve the selection.
//
//----------------------------------------------------------------------------

BOOL OnWizNextTimeZone(HWND hwnd)
{
    INT_PTR i;
    TIME_ZONE_ENTRY *TimeZoneEntry;

    //
    // Get the timezone the user selected.
    //

    i = SendDlgItemMessage(hwnd,
                           IDC_TIMEZONES,
                           CB_GETCURSEL,
                           (WPARAM) 0,
                           (LPARAM) 0);

    //
    // This should never happen, we always select one from the list.
    // If the list couldn't be built, we should have skipped this page
    // after an error msg.
    //

    if ( i == CB_ERR ) {
        AssertMsg(FALSE, "No timezone selected, programming error");
        return FALSE;
    }

    //
    // Get our pointer to the TIME_ZONE_ENTRY associatted with this entry
    //

    TimeZoneEntry = (TIME_ZONE_ENTRY*) SendDlgItemMessage(hwnd,
                                                          IDC_TIMEZONES,
                                                          CB_GETITEMDATA,
                                                          (WPARAM) i,
                                                          (LPARAM) 0);

    //
    // The "Index" is the number we need to write to unattend.txt
    //

    GenSettings.TimeZoneIdx = TimeZoneEntry->Index;

    return TRUE;
}

//--------------------------------------------------------------------------
//
// Dialog proc
//
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Function: DlgTimeZonePage
//
//  Purpose: This is the dialog procedure for the timezone page
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgTimeZonePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            OnInitTimeZone(hwnd);
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_TIME_ZONE;

                        OnSetActiveTimeZone(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextTimeZone(hwnd) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\syslic.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      syslic.c
//
// Description:
//      This file contains the dialog procedure for the sysprep license
//      agreement page (IDD_SYSPREPLICENSEAGREEMENT).  The user only sees
//      this page if they selected a fully automated script and doing
//      a sysprep.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

static TCHAR *StrSysprepLicenseText;

//----------------------------------------------------------------------------
//
// Function: OnSysprepLicenseInitDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnSysprepLicenseInitDialog( IN HWND hwnd )
{

    CheckRadioButton( hwnd,
                      IDC_RB_YES,
                      IDC_RB_NO,
                      IDC_RB_NO );

    //
    //  Sysprep licese text is more than 256 chars so I can't store it in the
    //  dialog, I have to load it at run-time.
    //

    StrSysprepLicenseText = MyLoadString( IDS_SYSPREP_LICENSE_TEXT );

    SetWindowText( GetDlgItem( hwnd, IDC_SYSPREP_LICENSE_TEXT),
                   StrSysprepLicenseText );

}

//----------------------------------------------------------------------------
//
// Function: OnWizNextSysPrepLicense
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnWizNextSysPrepLicense( IN HWND hwnd ) {

    if( IsDlgButtonChecked( hwnd, IDC_RB_YES ) )
    {
        GenSettings.bSkipEulaAndWelcome = TRUE;

        GenSettings.iUnattendMode = UMODE_FULL_UNATTENDED;
    }
    else
    {
        GenSettings.bSkipEulaAndWelcome = FALSE;

        GenSettings.iUnattendMode = UMODE_PROVIDE_DEFAULT;
    }

}

//----------------------------------------------------------------------------
//
// Function: DlgLicensePage
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
DlgSysprepLicensePage( IN HWND     hwnd,
                       IN UINT     uMsg,
                       IN WPARAM   wParam,
                       IN LPARAM   lParam) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG:

            OnSysprepLicenseInitDialog( hwnd );

            break;

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:

                    WIZ_CANCEL(hwnd); 
                    break;

                case PSN_SETACTIVE: {

                    g_App.dwCurrentHelp = IDH_LIC_AGR;

                    if ( WizGlobals.iProductInstall != PRODUCT_SYSPREP )
                        WIZ_PRESS(hwnd, PSBTN_FINISH);
                    else
                        WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    break;

                }
                case PSN_WIZBACK:

                    bStatus = FALSE;
                    break;

                case PSN_WIZNEXT:

                    OnWizNextSysPrepLicense( hwnd );
                    WIZ_PRESS(hwnd, PSBTN_FINISH);

                    break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                default:

                    break;
            }


            break;
        }

        default:
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\base\srvlic.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      srvlic.c
//
// Description:
//      This is the dlgproc for the server licensing page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define SERVER_LICENSE_MIN 5
#define SERVER_LICENSE_MAX 9999

//----------------------------------------------------------------------------
//
// Function: OnSrvLicenseInitDialog
//
// Purpose: Initialize the spin control.
//
//----------------------------------------------------------------------------
VOID
OnSrvLicenseInitDialog( IN HWND hwnd ) {

    //
    //  Set the range on the spin control: SERVER_LICENSE_MIN to
    //  SERVER_LICENSE_MAX
    //

    SendDlgItemMessage( hwnd,
                        IDC_SPIN,
                        UDM_SETRANGE32,
                        SERVER_LICENSE_MIN,
                        SERVER_LICENSE_MAX );

    //
    //  Set the default value for the spin control
    //

    SendDlgItemMessage( hwnd,
                        IDC_SPIN,
                        UDM_SETPOS,
                        0,
                        SERVER_LICENSE_MIN );

}

//----------------------------------------------------------------------------
//
// Function: OnSrvLicenseWizNext
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
OnSrvLicenseWizNext( IN HWND hwnd )
{

    TCHAR szNumber[10];
    INT   iNumberOfLicenses;

    //
    //  Convert the string number to an int
    //

    GetWindowText( GetDlgItem( hwnd, IDC_NUMCONNECT ), szNumber, 10 );

    iNumberOfLicenses = _ttoi( szNumber );

    //
    //  Ensure the number of server licenses stays within its appropriate
    //  range
    //

    if( iNumberOfLicenses < SERVER_LICENSE_MIN ) {

        iNumberOfLicenses = SERVER_LICENSE_MIN;

    }
    else if( iNumberOfLicenses > SERVER_LICENSE_MAX ) {

        iNumberOfLicenses = SERVER_LICENSE_MAX;

    }

}

//----------------------------------------------------------------------------
//
// Function: DlgSrvLicensePage
//
// Purpose: This is the dialog procedure the server licensing page
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgSrvLicensePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL  bStatus = TRUE;
    TCHAR NumBuff[11];      // big enough for decimal 4 billion
   HRESULT hrPrintf;

    switch (uMsg) {

        case WM_INITDIALOG:

            OnSrvLicenseInitDialog( hwnd );

            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {

                    case IDC_PERSERVER:
                    case IDC_PERSEAT:

                        if ( HIWORD(wParam) == BN_CLICKED ) {
                            CheckRadioButton(
                                    hwnd,
                                    IDC_PERSERVER,
                                    IDC_PERSEAT,
                                    LOWORD(wParam));
                        }
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;

                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        CancelTheWizard(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_LICE_MODE;

                        CheckRadioButton(
                                hwnd,
                                IDC_PERSERVER,
                                IDC_PERSEAT,
                                GenSettings.bPerSeat ?
                                            IDC_PERSEAT : IDC_PERSERVER);

                        hrPrintf=StringCchPrintf(NumBuff, AS(NumBuff), _T("%d"), GenSettings.NumConnections);

                        SendDlgItemMessage(hwnd,
                                           IDC_NUMCONNECT,
                                           WM_SETTEXT,
                                           (WPARAM) StrBuffSize(NumBuff),
                                           (LPARAM) NumBuff);

                        PropSheet_SetWizButtons(
                                GetParent(hwnd),
                                PSWIZB_BACK | PSWIZB_NEXT );

                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:

                        OnSrvLicenseWizNext( hwnd );

                        if ( IsDlgButtonChecked(hwnd, IDC_PERSERVER) )
                            GenSettings.bPerSeat = FALSE;
                        else
                            GenSettings.bPerSeat = TRUE;

                        SendDlgItemMessage(hwnd,
                                           IDC_NUMCONNECT,
                                           WM_GETTEXT,
                                           (WPARAM) StrBuffSize(NumBuff),
                                           (LPARAM) NumBuff);

                        if ( ( swscanf(NumBuff, _T("%d"), &GenSettings.NumConnections) <= 0 ) ||
                             ( GenSettings.NumConnections < MIN_SERVER_CONNECTIONS ) )
                        {
                            //
                            //  Don't let them set the number of server connections
                            //  below the minimum.
                            //
                            GenSettings.NumConnections = MIN_SERVER_CONNECTIONS;
                        }

                        bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\common\cancel.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      cancel.c
//
// Description:
//      This file contains the routine that should be called when the
//      user pushes the cancel button on the wizard.
//
//      Call this routine in response to a PSN_QUERYCANCEL only.  Do not
//      call it under any other circumstances as it sets the DWLP_MSGRESULT
//      in a fashion that is specific to PSN_QUERYCANCEL.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "allres.h"

static TCHAR *StrWarnCancelWizard = NULL;

//----------------------------------------------------------------------------
//
// Function: CancelTheWizard
//
// Purpose: Give the user one last chance to not cancel the wizard.  If they
//          really want to cancel, we route the wizard to the unsuccessful
//          completion page.
//
// Arguments:
//      HWND hwnd - current window
//
// Returns:
//      VOID
//
//----------------------------------------------------------------------------

VOID CancelTheWizard(HWND hwnd)
{
    int iRet;
    HWND hPropSheet = GetParent(hwnd);

    if( StrWarnCancelWizard == NULL )
    {
        StrWarnCancelWizard = MyLoadString( IDS_WARN_CANCEL_WIZARD );
    }

    if( g_StrWizardTitle == NULL )
    {
        g_StrWizardTitle = MyLoadString( IDS_WIZARD_TITLE );
    }

    iRet = MessageBox( hwnd, 
                       StrWarnCancelWizard, 
                       g_StrWizardTitle, 
                       MB_YESNO | MB_DEFBUTTON2 );

    // ISSUE-2002/02/28-stelo -Do a message box here so the default is NO
    //iRet = ReportErrorId(hwnd, MSGTYPE_YESNO, IDS_WARN_CANCEL_WIZARD);

    //
    // Never exit the wizard, we want to jump to the unsuccessful completion
    // page if user says yes.
    //

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);

    //
    // Ok, now go to the unsuccessful completion page is user said yes.
    // Otherwise, we'll stay on the same page.
    //

    if ( iRet == IDYES ) {
        PostMessage(hPropSheet,
                    PSM_SETCURSELID,
                    (WPARAM) 0,
                    (LPARAM) IDD_FINISH2);
    }
}

//----------------------------------------------------------------------------
//
// Function: TerminateTheWizard
//
// Purpose: Unconditionally terminate the wizard due to a fatal error
//
// Arguments:
//      int iErrorID
//
// Returns:
//      VOID
//
//----------------------------------------------------------------------------

VOID TerminateTheWizard
(
    int  iErrorID
)
{
    TCHAR   szTitle[128];
    TCHAR   szMsg[128];
   
    LoadString(FixedGlobals.hInstance, 
               iErrorID, 
               szMsg, 
               sizeof(szMsg)/sizeof(TCHAR));

    LoadString(FixedGlobals.hInstance, 
               IDS_WIZARD_TITLE, 
               szTitle, 
               sizeof(szTitle)/sizeof(TCHAR));

    MessageBox(NULL, szMsg, szTitle, MB_OK);
    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\common\allres.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      allres.h
//
// Description:  
//      This is a header file that is private to the common directory.
//      It includes each of our component resource.h files.
//
//      Note that the component .rc files have only dialog template
//      definitions in them and that they should never ever be shared
//      among one another.
//
//      The common directory does major operations on the behalf of
//      all wizard pages, so it #include's each of the component headers.
//
//      Note that common.rc contains stringid's and a small number of
//      of common resources available to all wizard code.  It is already
//      included in setupmgr.h
//      
//----------------------------------------------------------------------------

#include "..\\main\\resource.h"
#include "..\\base\\resource.h"
#include "..\\net\\resource.h"
#include "..\\oc\\resource.h"
#include "..\\oem\\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\common\pch.h ===
#include "setupmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\common\loadfile.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      loadfile.c
//
// Description:
//
//      This file implements ReadSettingsFromAnswerFile().  It is called
//      from load.c only if the user chose to edit an existing answer file.
//
//      We call GetPrivateProfileString repeatedly to figure out how to
//      initialize GenSettings WizGlobals and NetSettings global vars.
//
// WARNING:
//      This function is called after reset.c in the case we're editting
//      an answer file.  Be very careful how you call GetPrivateProfileString()
//      because if the setting is not present, you do not want to change
//      the default already set in reset.c.  Numerous examples below.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "allres.h"

//
// Misc constants (declared as vars to save space)
//

static WCHAR *StrConstYes   = _T("Yes");
static WCHAR *StrConstNo    = _T("No");
static WCHAR *StrConstStar  = _T("*");

extern BOOL GetCommaDelimitedEntry( OUT TCHAR szIPString[], 
                                    IN OUT TCHAR **pBuffer );


// ISSUE-2002/02/28-stelo- make constants for each key and use them both in the save file and in this load file
const TCHAR c_szFAVORITESEX[] = _T("FavoritesEx");


//
// Local prototypes
//

static VOID ReadRegionalSettings( VOID );

static VOID ReadTapiSettings( VOID );

static VOID ReadIeSettings( VOID );

static VOID ReadIeFavorites( VOID );

static VOID ParseAddressAndPort( LPTSTR pszBufferForProxyAddressAndPort, 
                                 LPTSTR pszAddress, 
                                 DWORD cbAddressLen,
                                 LPTSTR pszPort,
                                 DWORD cbPortLen);

//
// Call out to loadnet.c to load the network settings
//

extern VOID ReadNetworkSettings( HWND );

//----------------------------------------------------------------------------
//
// Function: ReadSettingsFromAnswerFile
//
// Purpose: This function does all of the GetPrivateProfile*() stuff
//          to load up our in-memory settings.
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------

BOOL ReadSettingsFromAnswerFile(HWND hwnd)
{

    INT temp;
    TCHAR Buffer[MAX_INILINE_LEN];

    //
    // Get the UnattendMode.  In case there is garbage in the answer file,
    // let the answer be UMODE_PROVIDE_DEFAULT.
    //

    temp = StrBuffSize(Buffer);

    GetPrivateProfileString(_T("Unattended"),
                            _T("UnattendMode"),
                            _T(""),
                            Buffer,
                            temp,
                            FixedGlobals.ScriptName);

    if ( LSTRCMPI(Buffer, _T("GuiAttended")) == 0 )
        GenSettings.iUnattendMode = UMODE_GUI_ATTENDED;

    else if ( LSTRCMPI(Buffer, _T("DefaultHide")) == 0 )
        GenSettings.iUnattendMode = UMODE_DEFAULT_HIDE;

    else if ( LSTRCMPI(Buffer, _T("Readonly")) == 0 )
        GenSettings.iUnattendMode = UMODE_READONLY;

    else if ( LSTRCMPI(Buffer, _T("FullUnattended")) == 0 )
        GenSettings.iUnattendMode = UMODE_FULL_UNATTENDED;

    else
        GenSettings.iUnattendMode = UMODE_PROVIDE_DEFAULT;

    //
    //  Get the HAL
    //
    GetPrivateProfileString(_T("Unattended"),
                            _T("ComputerType"),
                            _T(""),
                            Buffer,
                            StrBuffSize(Buffer),
                            FixedGlobals.ScriptName);

    //
    //  Have to read in HAL and SCSI drivers a little
    //  differently because of the quotes on the left for the SCSI drivers
    //  and the different formatting with the HAL
    //
    {

        HINF       hUnattendTxt;
        INFCONTEXT UnattendTxtContext;
        BOOL       bKeepReading = TRUE;
        BOOL       bHalFound    = FALSE;
        TCHAR      szTempBuffer[MAX_INILINE_LEN];

        hUnattendTxt = SetupOpenInfFile( FixedGlobals.ScriptName, 
                                         NULL,
                                         INF_STYLE_OLDNT | INF_STYLE_WIN4,
                                         NULL );
   
        if( hUnattendTxt == INVALID_HANDLE_VALUE ) {

            // ISSUE-2002/02/28-stelo - alert an error that we couldn't open the file or just
            //         skip over in this case?
            //return;

        }

        UnattendTxtContext.Inf = hUnattendTxt;
        UnattendTxtContext.CurrentInf = hUnattendTxt;



        bKeepReading = SetupFindFirstLine( hUnattendTxt, 
                                           _T("Unattended"),
                                           NULL,
                                           &UnattendTxtContext );

        //
        //  Look for the ComputerType key to set which HAL to use
        //
        while( bKeepReading &&  ! bHalFound ) {

            SetupGetStringField( &UnattendTxtContext, 
                                 0, 
                                 szTempBuffer, 
                                 MAX_INILINE_LEN, 
                                 NULL );

            if( LSTRCMPI( szTempBuffer, _T("ComputerType") ) == 0 ) {

                SetupGetStringField( &UnattendTxtContext, 
                                     1, 
                                     GenSettings.szHalFriendlyName, 
                                     MAX_INILINE_LEN, 
                                     NULL );

                bHalFound = TRUE;

            }

            //
            // move to the next line of the answer file
            //
            bKeepReading = SetupFindNextLine( &UnattendTxtContext, &UnattendTxtContext );

        }

        //
        //  Read in the SCSI drivers
        //
        bKeepReading = SetupFindFirstLine( hUnattendTxt, 
                                           _T("MassStorageDrivers"),
                                           NULL,
                                           &UnattendTxtContext );
        //
        //  For each MassStorageDriver entry, add it to the MassStorageDriver
        //  namelist
        //

        while( bKeepReading ) {

            TCHAR szScsiFriendlyName[MAX_INILINE_LEN];

            SetupGetStringField( &UnattendTxtContext, 
                                 0, 
                                 szScsiFriendlyName, 
                                 MAX_INILINE_LEN, 
                                 NULL );

            //
            //  Don't allow the adding of a blank name (protection against a bad input file)
            //
            if( szScsiFriendlyName[0] != _T('\0') ) {

                AddNameToNameList( &GenSettings.MassStorageDrivers,
                                   szScsiFriendlyName );

            }

            //
            // move to the next line of the answer file
            //
            bKeepReading = SetupFindNextLine( &UnattendTxtContext, &UnattendTxtContext );

        }

        SetupCloseInfFile( hUnattendTxt );

    }

    //
    //  Not reading from the [OEMBootFiles] section because this gets
    //  generated from whatever SCSI and HAL selections they make so
    //  it is not necessary to read it in.
    //

    //
    //  Get OEM Ads data
    //

    GetPrivateProfileString(_T("OEM_Ads"),
                            _T("Logo"),
                            GenSettings.lpszLogoBitmap,
                            GenSettings.lpszLogoBitmap,
                            StrBuffSize(GenSettings.lpszLogoBitmap),
                            FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("OEM_Ads"),
                            _T("Background"),
                            GenSettings.lpszBackgroundBitmap,
                            GenSettings.lpszBackgroundBitmap,
                            StrBuffSize(GenSettings.lpszBackgroundBitmap),
                            FixedGlobals.ScriptName);

    //
    // Get the product ID
    //

    {
        TCHAR *pStart  = Buffer, *pEnd;
        BOOL  bStop    = FALSE;
        int   CurField = 0;

        GetPrivateProfileString(_T("UserData"),
                                _T("ProductKey"),
                                NULLSTR,
                                Buffer,
                                StrBuffSize(Buffer),
                                FixedGlobals.ScriptName);

        // We did not have a ProductKey, check for the old ProductID
        //
        if ( Buffer[0] == NULLCHR )
        {
            GetPrivateProfileString(_T("UserData"),
                                    _T("ProductID"),
                                    _T("-"),
                                    Buffer,
                                    StrBuffSize(Buffer),
                                    FixedGlobals.ScriptName);
        }

        //
        // Have to parse out the pid1-pid2-pid3-pid4-pid5.
        //

        do {

            if ( (pEnd = wcschr(pStart, _T('-'))) == NULL )
                bStop = TRUE;
            else
                *pEnd++ = _T('\0');

            lstrcpyn(GenSettings.ProductId[CurField++],
                     pStart,
                     MAX_PID_FIELD + 1);

            pStart = pEnd;

        } while ( ! bStop && CurField < NUM_PID_FIELDS );
    }


    //
    // Get the license mode for server.  If we find this section, we
    // force on iProductInstall to be Server.
    //

    GetPrivateProfileString(_T("LicenseFilePrintData"),
                            _T("AutoMode"),
                            _T(""),
                            Buffer,
                            StrBuffSize(Buffer),
                            FixedGlobals.ScriptName);

    if ( Buffer[0] != _T('\0') ) {


        WizGlobals.iProductInstall = PRODUCT_UNATTENDED_INSTALL;

        WizGlobals.iPlatform = PLATFORM_SERVER;

        if ( LSTRCMPI(Buffer, _T("PerSeat")) == 0 ) {
            GenSettings.bPerSeat = TRUE;
        } else {
            GenSettings.bPerSeat = FALSE;
            GenSettings.NumConnections =
                            GetPrivateProfileInt(_T("LicenseFilePrintData"),
                                                 _T("AutoUsers"),
                                                 GenSettings.NumConnections,
                                                 FixedGlobals.ScriptName);
        }
    }

    //
    // Get name&org
    //

    GetPrivateProfileString(_T("UserData"),
                            _T("FullName"),
                            GenSettings.UserName,
                            GenSettings.UserName,
                            StrBuffSize(GenSettings.UserName),
                            FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("UserData"),
                            _T("OrgName"),
                            GenSettings.Organization,
                            GenSettings.Organization,
                            StrBuffSize(GenSettings.Organization),
                            FixedGlobals.ScriptName);


    //
    // Get the computer names.  It can be:
    //      1. ComputerName=*
    //      2. ComputerName=some_name
    //      3. not specified at all
    //      4. multiple computer names
    //
    // In case #4, we wrote out a .UDF, but we won't read the .UDF.  Instead,
    // we get the list from here:
    //
    // [SetupMgr]
    //     ComputerName0=some_name
    //     ComputerName1=another_name
    //

    {
        ResetNameList(&GenSettings.ComputerNames);

        GetPrivateProfileString(_T("UserData"),
                                _T("ComputerName"),
                                _T(""),
                                Buffer,
                                StrBuffSize(Buffer),
                                FixedGlobals.ScriptName);

        if( Buffer[0] != _T('\0') )
        {

            if( lstrcmpi(Buffer, StrConstStar) == 0 )
            {

                //
                //  if ComputerName=*, it is either the auto generate case
                //  or the UDF case
                //
                
                GetPrivateProfileString(_T("SetupMgr"),
                                        _T("ComputerName0"),
                                        _T(""),
                                        Buffer,
                                        StrBuffSize(Buffer),
                                        FixedGlobals.ScriptName);

                if( Buffer[0] == _T('\0') )
                {
                    GenSettings.bAutoComputerName = TRUE;
                }
                else
                {
                    int   i;
                    TCHAR Buffer2[MAX_INILINE_LEN];
                    HRESULT hrPrintf;

                    GenSettings.bAutoComputerName = FALSE;

                    for( i = 0; TRUE; i++ )
                    {
                        hrPrintf=StringCchPrintf(Buffer2, AS(Buffer2),_T("ComputerName%d"), i);

                        GetPrivateProfileString(_T("SetupMgr"),
                                                Buffer2,
                                                _T(""),
                                                Buffer,
                                                StrBuffSize(Buffer),
                                                FixedGlobals.ScriptName);

                        if ( Buffer[0] == _T('\0') )
                            break;

                        AddNameToNameList(&GenSettings.ComputerNames, Buffer);
                    }
                   
                }

            }
            else
            {
                GenSettings.bAutoComputerName = FALSE;
                AddNameToNameList(&GenSettings.ComputerNames, Buffer);
            }

        }

    }

    //
    //  Get the IE settings
    //

    ReadIeSettings();

    //
    // Get the targetpath
    //

    GetPrivateProfileString(_T("Unattended"),
                            _T("TargetPath"),
                            _T(""),
                            Buffer,
                            StrBuffSize(Buffer),
                            FixedGlobals.ScriptName);

    if ( lstrcmpi(Buffer, StrConstStar) == 0 ) {
        GenSettings.iTargetPath = TARGPATH_AUTO;
        GenSettings.TargetPath[0] = _T('\0');
    }

    else if ( lstrcmpi(Buffer, _T("")) == 0 ) {
        GenSettings.iTargetPath = TARGPATH_WINNT;
        GenSettings.TargetPath[0] = _T('\0');
    }

    else {
        GenSettings.iTargetPath = TARGPATH_SPECIFY;
        lstrcpyn(GenSettings.TargetPath, Buffer, MAX_TARGPATH + 1);
    }

    //
    // Get the administrator password.
    //
    //  AdminPassword == * means bSpecifyPassword to blank
    //  AdminPassword[0] == '\0' means !bSpecifyPassword
    //
    // Always set ConfirmPassword == AdminPassword on an edit so that
    // the user can breeze past this page.
    //

    // Check to see if the password is encrypted
    GetPrivateProfileString(_T("GuiUnattended"),
                            _T("EncryptedAdminPassword"),
                            _T(""),
                            Buffer,
                            StrBuffSize(Buffer),
                            FixedGlobals.ScriptName);
    if (lstrcmpi(Buffer, StrConstYes) == 0)
    {
        // If it is encrypted, don't bother reading it, just blank it out
        GenSettings.AdminPassword[0] = _T('\0');
        GenSettings.bSpecifyPassword = TRUE;
    }        

    else
    {
        GetPrivateProfileString(_T("GuiUnattended"),
                                _T("AdminPassword"),
                                GenSettings.AdminPassword,
                                GenSettings.AdminPassword,
                                StrBuffSize(GenSettings.AdminPassword),
                                FixedGlobals.ScriptName);
    
        if ( GenSettings.AdminPassword[0] == _T('\0') )
            GenSettings.bSpecifyPassword = FALSE;
        else
            GenSettings.bSpecifyPassword = TRUE;

        if ( lstrcmpi(GenSettings.AdminPassword, StrConstStar) == 0 )
            GenSettings.AdminPassword[0] = _T('\0');
    }    
    lstrcpyn(GenSettings.ConfirmPassword, GenSettings.AdminPassword, AS(GenSettings.ConfirmPassword));
    
    GetPrivateProfileString(_T("GuiUnattended"),
                            _T("AutoLogon"),
                            _T(""),
                            Buffer,
                            StrBuffSize(Buffer),
                            FixedGlobals.ScriptName);

    if ( lstrcmpi(Buffer, StrConstYes) == 0 )
        GenSettings.bAutoLogon = TRUE;
    else
        GenSettings.bAutoLogon = FALSE;

    GenSettings.nAutoLogonCount = GetPrivateProfileInt(_T("GuiUnattended"),
                                                       _T("AutoLogonCount"),
                                                       GenSettings.nAutoLogonCount,
                                                       FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("GuiUnattended"),
                            _T("OEMDuplicatorstring"),
                            GenSettings.szOemDuplicatorString,
                            GenSettings.szOemDuplicatorString,
                            StrBuffSize(GenSettings.szOemDuplicatorString),
                            FixedGlobals.ScriptName);

    //
    // Get the display settings.
    //

    GenSettings.DisplayColorBits = GetPrivateProfileInt(
                                            _T("Display"),
                                            _T("BitsPerPel"),
                                            GenSettings.DisplayColorBits,
                                            FixedGlobals.ScriptName);

    GenSettings.DisplayXResolution = GetPrivateProfileInt(
                                            _T("Display"),
                                            _T("XResolution"),
                                            GenSettings.DisplayXResolution,
                                            FixedGlobals.ScriptName);

    GenSettings.DisplayYResolution = GetPrivateProfileInt(
                                            _T("Display"),
                                            _T("YResolution"),
                                            GenSettings.DisplayYResolution,
                                            FixedGlobals.ScriptName);

    GenSettings.DisplayRefreshRate = GetPrivateProfileInt(
                                            _T("Display"),
                                            _T("Vrefresh"),
                                            GenSettings.DisplayRefreshRate,
                                            FixedGlobals.ScriptName);

    //
    // Get the runonce commands.  They are listed like this:
    //
    //      [GuiRunOnce]
    //          Command0=some_cmd
    //          Command0=another_cmd
    //
    // ISSUE-2002/02/28-stelo -Need to investigate this biz about running these commands
    //         in sequence or in parrallel.
    //

    {
        int   i;
        TCHAR Buffer2[MAX_INILINE_LEN];
        HRESULT hrPrintf;

        ResetNameList(&GenSettings.RunOnceCmds);

        for ( i=0; TRUE; i++ ) {

            hrPrintf=StringCchPrintf(Buffer2, AS(Buffer2),_T("Command%d"), i);

            GetPrivateProfileString(_T("GuiRunOnce"),
                                    Buffer2,
                                    _T(""),
                                    Buffer,
                                    StrBuffSize(Buffer),
                                    FixedGlobals.ScriptName);

            if ( Buffer[0] == _T('\0') )
                break;

            AddNameToNameList(&GenSettings.RunOnceCmds, Buffer);
        }
    }

    //
    // Loop through the commands and parse out any add printer commands
    //

    //
    // NOTE: This code works if the user never edits the commands.
    //       However, the user might want to modify it and put
    //       different switches on it on the RunOnce page.  The
    //       parsing below could be more robust.
    //
    //       If /n means 'name', then it should parse for /n then
    //       the next arg is the printer name no matter what switches
    //       the user added or re-ordered.
    //

    {
        int   i, NumCmds;
        TCHAR *pName;
        TCHAR PrinterName[MAX_PRINTERNAME + 1];

        NumCmds = GetNameListSize(&GenSettings.RunOnceCmds);

        for ( i=0; i<NumCmds; i++ ) 
        {
            pName = GetNameListName(&GenSettings.RunOnceCmds, i);

            PrinterName[0] = _T('\0');
            if ( ( swscanf(pName,
                           _T("rundll32 printui.dll,PrintUIEntry /in /n %s"),
                           PrinterName) > 0 ) && 
                 ( PrinterName[0] ) )
            {
                AddNameToNameList(&GenSettings.PrinterNames, PrinterName);
            }
        }
    }

    //
    // Get the timezone
    //

    GetPrivateProfileString( _T("GuiUnattended"),
                             _T("TimeZone"),
                             _T(""),
                             Buffer,
                             StrBuffSize(Buffer),
                             FixedGlobals.ScriptName );

    if ( LSTRCMPI(Buffer, _T("%TIMEZONE%")) == 0 ) 
    {
        GenSettings.TimeZoneIdx = TZ_IDX_SETSAMEASSERVER;
    } 
    else if ( ( Buffer[0] == _T('\0') ) || 
              ( swscanf(Buffer, _T("%d"), &GenSettings.TimeZoneIdx) <= 0 ) ) 
    {
        GenSettings.TimeZoneIdx = TZ_IDX_DONOTSPECIFY;
    }

    //
    // Init the settings for the 2 Distribution Folder pages.  OemPreInstall
    // indicates whether the script is stand-alone or not.  The others are
    // saved in the [SetupMgr] section.
    //

    GetPrivateProfileString(_T("Unattended"),
                            _T("OemPreInstall"),
                            _T(""),
                            Buffer,
                            StrBuffSize(Buffer),
                            FixedGlobals.ScriptName );

    if ( lstrcmpi(Buffer, StrConstYes) == 0 )
        WizGlobals.bStandAloneScript = FALSE;
    else
        WizGlobals.bStandAloneScript = TRUE;

    GetPrivateProfileString(_T("SetupMgr"),
                            _T("DistFolder"),
                            WizGlobals.DistFolder,
                            WizGlobals.DistFolder,
                            StrBuffSize(WizGlobals.DistFolder),
                            FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("SetupMgr"),
                            _T("DistShare"),
                            WizGlobals.DistShareName,
                            WizGlobals.DistShareName,
                            StrBuffSize(WizGlobals.DistShareName),
                            FixedGlobals.ScriptName);

    WizGlobals.bCreateNewDistFolder = FALSE;

    //
    // Get tapi & regional settings
    //

    ReadTapiSettings();
    ReadRegionalSettings();

    //
    //  Purposely grabbing the JoinWorkgroup key twice.  Once to determine if
    //  there a value for the key and once to set the value for the global
    //  NetSettings.WorkGroupName string.
    //

    GetPrivateProfileString(_T("Identification"),
                            _T("JoinWorkgroup"),
                            _T(""),
                            Buffer,
                            StrBuffSize(Buffer),
                            FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("Identification"),
                            _T("JoinWorkgroup"),
                            NetSettings.WorkGroupName,
                            NetSettings.WorkGroupName,
                            StrBuffSize(NetSettings.WorkGroupName),
                            FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("Identification"),
                            _T("JoinDomain"),
                            NetSettings.DomainName,
                            NetSettings.DomainName,
                            StrBuffSize(NetSettings.DomainName),
                            FixedGlobals.ScriptName);

    //
    //  If they didn't specify a workgroup in the answerfile and they did
    //  specify a domain, chose to Join a Domain (i.e. not join a workgroup)
    //

    if( Buffer[0] == _T('\0') &&
        NetSettings.DomainName[0] != _T('\0') )
    {
        NetSettings.bWorkgroup = FALSE;
    }

    if( lstrcmp( NetSettings.DomainName, _T("%MACHINEDOMAIN%") ) == 0 )
    {
        WizGlobals.iProductInstall = PRODUCT_REMOTEINSTALL;
    }

    GetPrivateProfileString(_T("Identification"),
                            _T("DomainAdmin"),
                            NetSettings.DomainAccount,
                            NetSettings.DomainAccount,
                            StrBuffSize(NetSettings.DomainAccount),
                            FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("Identification"),
                            _T("DomainAdminPassword"),
                            NetSettings.DomainPassword,
                            NetSettings.DomainPassword,
                            StrBuffSize(NetSettings.DomainPassword),
                            FixedGlobals.ScriptName);

    if( NetSettings.DomainAccount[0] == _T('\0') )
    {
        NetSettings.bCreateAccount = FALSE;
    }
    else
    {
        NetSettings.bCreateAccount = TRUE;
    }

    //
    //  Make the domain password and the confirm the same so user can
    //  breeze past the page if they want to
    //
    lstrcpyn( NetSettings.ConfirmPassword, NetSettings.DomainPassword ,AS(NetSettings.ConfirmPassword));

    //
    //  Read in the Network settings
    //
    ReadNetworkSettings( hwnd );

    return( TRUE );
}

//----------------------------------------------------------------------------
//
// Function: ReadTapiSettings
//
// Purpose:  Read the tapi settings keys from the answerfile.
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
ReadTapiSettings( VOID ) {

    TCHAR Buffer[MAX_INILINE_LEN] = _T("");

    //
    //  Note: if it doesn't find the CountryCode key then it defaults to
    //        "Don't specify setting"
    //
    GenSettings.dwCountryCode = GetPrivateProfileInt(_T("TapiLocation"),
                                                     _T("CountryCode"),
                                                     DONTSPECIFYSETTING,
                                                     FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("TapiLocation"),
                            _T("Dialing"),
                            _T(""),
                            Buffer,
                            StrBuffSize(Buffer),
                            FixedGlobals.ScriptName);

    if ( LSTRCMPI(Buffer, _T("Tone")) == 0 )
        GenSettings.iDialingMethod = TONE;
    else if ( LSTRCMPI(Buffer, _T("Pulse")) == 0 )
        GenSettings.iDialingMethod = PULSE;
    else
        GenSettings.iDialingMethod = DONTSPECIFYSETTING;

    GetPrivateProfileString(_T("TapiLocation"),
                            _T("AreaCode"),
                            GenSettings.szAreaCode,
                            GenSettings.szAreaCode,
                            StrBuffSize(GenSettings.szAreaCode),
                            FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("TapiLocation"),
                            _T("LongDistanceAccess"),
                            GenSettings.szOutsideLine,
                            GenSettings.szOutsideLine,
                            StrBuffSize(GenSettings.szOutsideLine),
                            FixedGlobals.ScriptName);


}

//----------------------------------------------------------------------------
//
// Function: ReadRegionalSettings
//
// Purpose: Read the regional settings keys from the answerfile.
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
ReadRegionalSettings( VOID ) {

    TCHAR Buffer[MAX_INILINE_LEN]          = _T("");
    TCHAR OemSkipBuffer[MAX_INILINE_LEN]   = _T("");
    TCHAR szLanguageGroup[MAX_INILINE_LEN] = _T("");

    TCHAR *pLanguageGroup = NULL;
    
    DWORD dwOemSkipSize   = 0;
    DWORD dwLanguageSize  = 0;
    DWORD dwSystemSize    = 0;
    DWORD dwNumberSize    = 0;
    DWORD dwKeyboardSize  = 0;

    dwOemSkipSize = GetPrivateProfileString(_T("RegionalSettings"),
                                            _T("OEMSkipRegionalSettings"),
                                            _T(""),
                                            OemSkipBuffer,
                                            StrBuffSize(OemSkipBuffer),
                                            FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("RegionalSettings"),
                            _T("LanguageGroup"),
                            _T(""),
                            Buffer,
                            StrBuffSize(Buffer),
                            FixedGlobals.ScriptName);

    //
    //  Loop grabbing the Language Groups and inserting them into
    //  the NameList
    //
    pLanguageGroup = Buffer;
    while( GetCommaDelimitedEntry( szLanguageGroup, &pLanguageGroup ) ) {

        AddNameToNameList( &GenSettings.LanguageGroups,
                           szLanguageGroup );

    }

    dwLanguageSize = GetPrivateProfileString(_T("RegionalSettings"),
                                             _T("Language"),
                                             _T(""),
                                             GenSettings.szLanguage,
                                             StrBuffSize(GenSettings.szLanguage),
                                             FixedGlobals.ScriptName);

    dwSystemSize = GetPrivateProfileString(_T("RegionalSettings"),
                                           _T("SystemLocale"),
                                           _T(""),
                                           GenSettings.szMenuLanguage,
                                           StrBuffSize(GenSettings.szMenuLanguage),
                                           FixedGlobals.ScriptName);

    dwNumberSize = GetPrivateProfileString(_T("RegionalSettings"),
                                           _T("UserLocale"),
                                           _T(""),
                                           GenSettings.szNumberLanguage,
                                           StrBuffSize(GenSettings.szNumberLanguage),
                                           FixedGlobals.ScriptName);

    dwKeyboardSize = GetPrivateProfileString(_T("RegionalSettings"),
                                             _T("InputLocale"),
                                             _T(""),
                                             GenSettings.szKeyboardLayout,
                                             StrBuffSize(GenSettings.szKeyboardLayout),
                                             FixedGlobals.ScriptName);

    //
    //  If the OEMSkipRegionalSettings was specified in the answerfile, set 
    //  its value and return.  Else set the language locales appropriately.
    //
    if( dwOemSkipSize > 0 ) {

        if( lstrcmp( OemSkipBuffer, _T("0") ) == 0  ) {

            GenSettings.iRegionalSettings = REGIONAL_SETTINGS_SKIP;

        }
        else if( lstrcmp( OemSkipBuffer, _T("1") ) == 0 ) {

            GenSettings.iRegionalSettings = REGIONAL_SETTINGS_DEFAULT;

        }
        else {

            // if it was set to some strange settings, just set it to use default
            GenSettings.iRegionalSettings = REGIONAL_SETTINGS_DEFAULT;

        }

    }
    else {

        if( dwLanguageSize != 0 ) {

            GenSettings.iRegionalSettings = REGIONAL_SETTINGS_SPECIFY;

        }
        else if( dwSystemSize != 0 || dwNumberSize != 0 || dwKeyboardSize != 0 ) {

            GenSettings.iRegionalSettings = REGIONAL_SETTINGS_SPECIFY;

            GenSettings.bUseCustomLocales = TRUE;

        }
        else {

            //
            //  If no keys were specified, set it to not specified
            //
            GenSettings.iRegionalSettings = REGIONAL_SETTINGS_NOT_SPECIFIED;

        }

    }

}

//----------------------------------------------------------------------------
//
// Function: ReadIeSettings
//
// Purpose: Read the IE settings keys from the answerfile and store them in
//          the global structs.
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
ReadIeSettings( VOID )
{

    TCHAR szBufferForProxyAddressAndPort[2048 + 1];
    TCHAR szAddress[MAX_PROXY_LEN];
    TCHAR szPort[MAX_PROXY_PORT_LEN];
    TCHAR Buffer[MAX_INILINE_LEN];
    TCHAR *pLocalString;

    GetPrivateProfileString(_T("Branding"),
                            _T("IEBrandingFile"),
                            GenSettings.szInsFile,
                            GenSettings.szInsFile,
                            StrBuffSize(GenSettings.szInsFile),
                            FixedGlobals.ScriptName);

    if( GenSettings.szInsFile[0] != _T('\0') )
    {
        GenSettings.IeCustomizeMethod = IE_USE_BRANDING_FILE;
    }
    else
    {
        GenSettings.IeCustomizeMethod = IE_SPECIFY_SETTINGS;
    }

    GetPrivateProfileString(_T("URL"),
                            _T("AutoConfig"),
                            _T("1"),
                            Buffer,
                            StrBuffSize(Buffer),
                            FixedGlobals.ScriptName);

    if( lstrcmpi( Buffer, _T("1") ) == 0 )
    {
        GenSettings.bUseAutoConfigScript = TRUE;
    }
    else
    {
        GenSettings.bUseAutoConfigScript = FALSE;
    }

    GetPrivateProfileString(_T("URL"),
                            _T("AutoConfigURL"),
                            GenSettings.szAutoConfigUrl,
                            GenSettings.szAutoConfigUrl,
                            StrBuffSize(GenSettings.szAutoConfigUrl),
                            FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("URL"),
                            _T("AutoConfigJSURL"),
                            GenSettings.szAutoConfigUrlJscriptOrPac,
                            GenSettings.szAutoConfigUrlJscriptOrPac,
                            StrBuffSize(GenSettings.szAutoConfigUrlJscriptOrPac),
                            FixedGlobals.ScriptName);

    if( GenSettings.szAutoConfigUrl[0] != _T('\0') || 
        GenSettings.szAutoConfigUrlJscriptOrPac[0] != _T('\0') )
    {
        GenSettings.bUseAutoConfigScript = TRUE;
    }
    else
    {
        GenSettings.bUseAutoConfigScript = FALSE;
    }

    GetPrivateProfileString(_T("Proxy"),
                            _T("Use_Same_Proxy"),
                            _T("0"),
                            Buffer,
                            StrBuffSize(Buffer),
                            FixedGlobals.ScriptName);

    if( lstrcmpi( Buffer, _T("1") ) == 0 )
    {
        GenSettings.bUseSameProxyForAllProtocols = TRUE;
    }
    else
    {
        GenSettings.bUseSameProxyForAllProtocols = FALSE;
    }

    //
    //  Get the HTTP Proxy server
    //

    GetPrivateProfileString(_T("Proxy"),
                            _T("HTTP_Proxy_Server"),
                            _T(""),
                            szBufferForProxyAddressAndPort,
                            StrBuffSize(szBufferForProxyAddressAndPort),
                            FixedGlobals.ScriptName);

    ParseAddressAndPort( szBufferForProxyAddressAndPort, szAddress, AS(szAddress), szPort, AS(szPort));

    lstrcpyn( GenSettings.szHttpProxyAddress, szAddress, AS(GenSettings.szHttpProxyAddress) );
    lstrcpyn( GenSettings.szHttpProxyPort,    szPort, AS(GenSettings.szHttpProxyPort)    );

    if( GenSettings.szHttpProxyAddress[0] != _T('\0') )
    {
        GenSettings.bUseProxyServer = TRUE;
    }
    else
    {
        GenSettings.bUseProxyServer = FALSE;
    }

    //
    //  Get the Secure Proxy server
    //

    GetPrivateProfileString(_T("Proxy"),
                            _T("Secure_Proxy_Server"),
                            _T(""),
                            szBufferForProxyAddressAndPort,
                            StrBuffSize(szBufferForProxyAddressAndPort),
                            FixedGlobals.ScriptName);

    ParseAddressAndPort( szBufferForProxyAddressAndPort, szAddress, AS(szAddress), szPort, AS(szPort) );

    lstrcpyn( GenSettings.szSecureProxyAddress, szAddress, AS(GenSettings.szSecureProxyAddress) );
    lstrcpyn( GenSettings.szSecureProxyPort,    szPort, AS(GenSettings.szSecureProxyPort)  );

    //
    //  Get the FTP Proxy server
    //

    GetPrivateProfileString(_T("Proxy"),
                            _T("FTP_Proxy_Server"),
                            _T(""),
                            szBufferForProxyAddressAndPort,
                            StrBuffSize(szBufferForProxyAddressAndPort),
                            FixedGlobals.ScriptName);

    ParseAddressAndPort( szBufferForProxyAddressAndPort, szAddress, AS(szAddress), szPort, AS(szPort) );

    lstrcpyn( GenSettings.szFtpProxyAddress, szAddress, AS(GenSettings.szFtpProxyAddress) );
    lstrcpyn( GenSettings.szFtpProxyPort,    szPort, AS(GenSettings.szFtpProxyPort)    );

    //
    //  Get the Gopher Proxy server
    //

    GetPrivateProfileString(_T("Proxy"),
                            _T("Gopher_Proxy_Server"),
                            _T(""),
                            szBufferForProxyAddressAndPort,
                            StrBuffSize(szBufferForProxyAddressAndPort),
                            FixedGlobals.ScriptName);

    ParseAddressAndPort( szBufferForProxyAddressAndPort, szAddress, AS(szAddress), szPort, AS(szPort) );

    lstrcpyn( GenSettings.szGopherProxyAddress, szAddress, AS(GenSettings.szGopherProxyAddress) );
    lstrcpyn( GenSettings.szGopherProxyPort,    szPort, AS(GenSettings.szGopherProxyPort)    );

    //
    //  Get the Socks Proxy server
    //

    GetPrivateProfileString(_T("Proxy"),
                            _T("Socks_Proxy_Server"),
                            _T(""),
                            szBufferForProxyAddressAndPort,
                            StrBuffSize(szBufferForProxyAddressAndPort),
                            FixedGlobals.ScriptName);

    ParseAddressAndPort( szBufferForProxyAddressAndPort, szAddress, AS(szAddress), szPort, AS(szPort) );

    lstrcpyn( GenSettings.szSocksProxyAddress, szAddress, AS(GenSettings.szSocksProxyAddress) );
    lstrcpyn( GenSettings.szSocksProxyPort,    szPort, AS(GenSettings.szSocksProxyPort)    );


    GetPrivateProfileString(_T("Proxy"),
                            _T("Proxy_Override"),
                            _T(""),
                            GenSettings.szProxyExceptions,
                            StrBuffSize(GenSettings.szProxyExceptions),
                            FixedGlobals.ScriptName);

    pLocalString = _tcsstr( GenSettings.szProxyExceptions, _T("<local>") );
   

    // Initialize the GenSettings Proxy Bypass boolean value...
    // 
    GenSettings.bBypassProxyForLocalAddresses = FALSE;

    if( pLocalString != NULL )
    {
        TCHAR *pChar;
        TCHAR *pEndLocal;
        LPTSTR lpszExceptionBuffer;
        DWORD cbExceptionBufferLen;

        
        //
        //  Remove the false entry, so it doesn't get added to the exception edit box
        //
        pEndLocal = pLocalString + lstrlen( _T("<local>") );

        //
        // Allocate the exception buffer...
        //
        cbExceptionBufferLen= lstrlen(pEndLocal)+1;
        lpszExceptionBuffer = MALLOC( cbExceptionBufferLen * sizeof(TCHAR) );
        if ( lpszExceptionBuffer )
        {
            GenSettings.bBypassProxyForLocalAddresses = TRUE;

            //
            //  strcpy is undefined if source and dest overlap so I have to go through
            //  an intermediate buffer
            //
            lstrcpyn( lpszExceptionBuffer, pEndLocal, cbExceptionBufferLen);

            lstrcpyn( pLocalString, lpszExceptionBuffer, 
            	 AS(GenSettings.szProxyExceptions)-
              (int)(pLocalString-GenSettings.szProxyExceptions) );

            //
            //  If the first or last char is a semicolon(;) then remove it.
            //

            pChar = GenSettings.szProxyExceptions;

            if( *pChar == _T(';') )
            {
                lstrcpyn( lpszExceptionBuffer, GenSettings.szProxyExceptions, cbExceptionBufferLen);

                pChar = lpszExceptionBuffer;

                pChar++;

                lstrcpyn( GenSettings.szProxyExceptions, pChar, AS(GenSettings.szProxyExceptions) );

            }

            pChar = GenSettings.szProxyExceptions + lstrlen( GenSettings.szProxyExceptions );

            pChar--;

            if( *pChar == _T(';') )
            {
                *pChar = _T('\0');
            }

            FREE( lpszExceptionBuffer );
        }
    }

    GetPrivateProfileString(_T("URL"),
                            _T("Home_Page"),
                            _T(""),
                            GenSettings.szHomePage,
                            StrBuffSize(GenSettings.szHomePage),
                            FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("URL"),
                            _T("Help_Page"),
                            _T(""),
                            GenSettings.szHelpPage,
                            StrBuffSize(GenSettings.szHelpPage),
                            FixedGlobals.ScriptName);

    GetPrivateProfileString(_T("URL"),
                            _T("Search_Page"),
                            _T(""),
                            GenSettings.szSearchPage,
                            StrBuffSize(GenSettings.szSearchPage),
                            FixedGlobals.ScriptName);

    ReadIeFavorites();

}

//----------------------------------------------------------------------------
//
// Function: ReadIeFavorites
//
// Purpose:  
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
ReadIeFavorites( VOID )
{

    const TCHAR c_szTITLE[] = _T("Title");
    const TCHAR c_szURL[]   = _T("URL");
    const INT   c_nMAX_URLS = 1000;

    INT   i = 1;
    TCHAR szTitle[MAX_INILINE_LEN + 1];
    TCHAR szUrl[MAX_INILINE_LEN + 1];
    TCHAR szNumberBuffer[10];
    TCHAR szFavoriteFriendlyName[MAX_INILINE_LEN + 1];
    TCHAR szFavoriteAddress[MAX_INILINE_LEN + 1];
    TCHAR *pszDotUrl;
    HRESULT hrCat;

    //
    //  We really always should hit the break to exit the loop.  The max count
    //  is just to avoid a infinite loop for some strange reason.
    //

    while( i < c_nMAX_URLS )
    {

        _itot( i, szNumberBuffer, 10 );

        i++;

        lstrcpyn( szTitle, c_szTITLE, AS(szTitle) );
        hrCat=StringCchCat( szTitle, AS(szTitle), szNumberBuffer);

        lstrcpyn( szUrl, c_szURL, AS(szUrl) );
        hrCat=StringCchCat( szUrl, AS(szUrl), szNumberBuffer );

        GetPrivateProfileString( c_szFAVORITESEX,
                                 szTitle,
                                 _T(""),
                                 szFavoriteFriendlyName,
                                 StrBuffSize( szFavoriteFriendlyName ),
                                 FixedGlobals.ScriptName );

        if( szFavoriteFriendlyName[0] != _T('\0') )
        {

            //
            //  Strip off the .url portion of the title
            //

            pszDotUrl = _tcsstr( szFavoriteFriendlyName, _T(".url") );

            if( pszDotUrl != NULL )
            {
                *pszDotUrl = _T('\0');
            }
            else
            {
                // skip it if it is a malformed title
                continue;
            }

            GetPrivateProfileString( c_szFAVORITESEX,
                                     szUrl,
                                     _T(""),
                                     szFavoriteAddress,
                                     StrBuffSize( szFavoriteAddress ),
                                     FixedGlobals.ScriptName );

            AddNameToNameList( &GenSettings.Favorites,
                               szFavoriteFriendlyName );

            AddNameToNameList( &GenSettings.Favorites,
                               szFavoriteAddress );

        }
        else
        {
            break;
        }

    }

}

//----------------------------------------------------------------------------
//
// Function: ParseAddressAndPort
//
// Purpose:  LPTCSTR pszBufferForProxyAddressAndPort - the string to parse the
//       web address and port from
//           LPTSTR  pszAddress - web address returned in this string
//           DWORD cbAddressLen - length of adress buffer
//           LPTSTR  pszPort - web port returned in this string
//           DWORD cbPortLen - length of port buffer
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID 
ParseAddressAndPort( LPTSTR pszBufferForProxyAddressAndPort, 
                     LPTSTR pszAddress, 
                     DWORD cbAddressLen,
                     LPTSTR pszPort,
                     DWORD cbPortLen)
{

    INT  i;
    INT  iStrLen;
    BOOL bColonFound = FALSE;

    lstrcpyn( pszAddress, _T(""), cbAddressLen);

    lstrcpyn( pszPort,    _T(""), cbPortLen);


    iStrLen = lstrlen( pszBufferForProxyAddressAndPort );

    for( i = 0; i < iStrLen; i++ )
    {

        if( pszBufferForProxyAddressAndPort[i] == _T(':') )
        {

            //
            //  We have found the colon(:) separating the address and the port
            //  if the next char is a digit.  This prevents the colon in
            //  http://www.someaddress.com from looking like the port.
            //

            if( _istdigit( pszBufferForProxyAddressAndPort[i + 1] ) )
            {
                bColonFound = TRUE;
                break;
            }

        }

    }

    if( bColonFound )
    {
        LPTSTR pPortSection;

        pszBufferForProxyAddressAndPort[i] = _T('\0');

        pPortSection = &( pszBufferForProxyAddressAndPort[i + 1] );

        lstrcpyn( pszAddress, pszBufferForProxyAddressAndPort, cbAddressLen);

        lstrcpyn( pszPort, pPortSection, cbPortLen);
    }
    else
    {

        //
        //  it doesn't contain a colon so it doesn't have a port, the whole
        //  string is the address
        //

        lstrcpyn( pszAddress, pszBufferForProxyAddressAndPort, cbAddressLen);

    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\setupmgr\common\netcfgx_i.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      netcfgx_i.c
//
// Description:
//      Include file for netreg.cpp.  Needed for the IID defines.
//
//----------------------------------------------------------------------------
#include "pch.h"

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.02.0235 */
/* at Wed Apr 07 22:55:12 1999
 */
/* Compiler settings for netcfgx.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IEnumNetCfgBindingInterface,0xC0E8AE90,0x306E,0x11D1,0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E);


MIDL_DEFINE_GUID(IID, IID_IEnumNetCfgBindingPath,0xC0E8AE91,0x306E,0x11D1,0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E);


MIDL_DEFINE_GUID(IID, IID_IEnumNetCfgComponent,0xC0E8AE92,0x306E,0x11D1,0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E);


MIDL_DEFINE_GUID(IID, IID_INetCfg,0xC0E8AE93,0x306E,0x11D1,0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E);


MIDL_DEFINE_GUID(IID, IID_INetCfgLock,0xC0E8AE9F,0x306E,0x11D1,0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E);


MIDL_DEFINE_GUID(IID, IID_INetCfgBindingInterf