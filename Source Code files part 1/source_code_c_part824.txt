 HOUR, MINUTE, SECOND, MONTH, DAY, and YEAR
//  are critical.
//
#define DATETIME_STATIC			  -1
#define DATETIME                  700
#define DATETIME_HOUR             701
#define DATETIME_MINUTE           702
#define DATETIME_SECOND           703
#define DATETIME_MONTH            704
#define DATETIME_DAY              705
#define DATETIME_YEAR             706
#define DATETIME_TSEP1            707
#define DATETIME_TSEP2            708

#define DATETIME_TARROW           709
#define DATETIME_AMPM             710
#define DATETIME_CALENDAR         711
#define DATETIME_CLOCK            712
#define DATETIME_MONTHNAME        713

#define DATETIME_YARROW           714
#define DATETIME_TBORDER          715
#define DATETIME_CURTZ            716

#define DATETIME_AUTOSETFROMINTERNET        720
#define DATETIME_INTERNET_SERVER_EDIT       721
#define DATETIME_INTERNET_SERVER_LABLE      722
#define DATETIME_INFOTEXTTOP                723
#define DATETIME_INFOTEXTPROXY              724
#define DATETIME_INTERNET_ERRORTEXT         725
#define DATETIME_INTERNET_UPDATENOW         726
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\timedate.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    timedate.h

Abstract:

    This module contains the header information for the Date/Time applet.

Revision History:

--*/



#ifndef STRICT
  #define STRICT
#endif



//
//  Include Files.
//

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shlwapi.h>
#include <strsafe.h>



//
//  Constant Declarations.
//

#define CharSizeOf(x)   (sizeof(x) / sizeof(x[0]))

//
//  Index into wDateTime.
//
#define  HOUR       0
#define  MINUTE     1
#define  SECOND     2
#define  MONTH      3
#define  DAY        4
#define  YEAR       5
#define  WEEKDAY    6




//
//  Typedef Declarations.
//

#define TIMESUF_LEN   9         // time suffix length + null terminator

typedef struct
{
    TCHAR  sCountry[24];        // country name
    int    iCountry;            // country code (phone ID)
    int    iDate;               // date mode (0: MDY, 1: DMY, 2: YMD)
    int    iTime;               // time mode (0: 12 hour clock, 1: 24 hour clock)
    int    iTLZero;             // leading zeros for hour (0: no, 1: yes)
    int    iCurFmt;             // currency mode (0: prefix, no separation
                                //                1: suffix, no separation
                                //                2: prefix, 1 char separation
                                //                3: suffix, 1 char separation)
    int    iCurDec;             // currency decimal place
    int    iNegCur;             // negative currency pattern:
                                //     ($1.23), -$1.23, $-1.23, $1.23-, etc.
    int    iLzero;              // leading zeros of decimal (0: no, 1: yes)
    int    iDigits;             // significant decimal digits
    int    iMeasure;            // 0: metric, 1: US
    TCHAR  s1159[TIMESUF_LEN];  // trailing string from 0:00 to 11:59
    TCHAR  s2359[TIMESUF_LEN];  // trailing string from 12:00 to 23:59
    TCHAR  sCurrency[6];        // currency symbol string
    TCHAR  sThousand[4];        // thousand separator string
    TCHAR  sDecimal[4];         // decimal separator string
    TCHAR  sDateSep[4];         // date separator string
    TCHAR  sTime[4];            // time separator string
    TCHAR  sList[4];            // list separator string
    TCHAR  sLongDate[80];       // long date picture string
    TCHAR  sShortDate[80];      // short date picture string
    TCHAR  sLanguage[4];        // language name
    short  iDayLzero;           // day leading zero for short date format
    short  iMonLzero;           // month leading zero for short date format
    short  iCentury;            // display full century in short date format
    short  iLDate;              // long date mode (0: MDY, 1: DMY, 2: YMD)
    LCID   lcid;                // locale id
    TCHAR  sTimeFormat[80];     // time format picture string
    int    iTimeMarker;         // time marker position (0: suffix, 1: prefix)
    int    iNegNumber;          // negative number pattern:
                                //     (1.1), -1.1, - 1.1, 1.1-, 1.1 -
    TCHAR  sMonThousand[4];     // monetary thousand separator string
    TCHAR  sMonDecimal[4];      // monetary decimal separator string

} INTLSTRUCT, *LPINTL;




//
//  Global Variables.
//

extern short wDateTime[7];             // values for first 7 date/time items
extern short wPrevDateTime[7];         // only repaint fields if necessary
extern BOOL  fDateDirty;
EXTERN_C HINSTANCE g_hInst;

extern INTLSTRUCT IntlDef;




//
//  Function Prototypes.
//

void
GetDateTime(void);

void
GetTime(void);

void
SetTime(void);

void
GetDate(void);

void
SetDate(void);

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\vidupgrd\deskcmmn.cpp ===
#include "migrate.h"
#include "..\..\common\deskcmmn.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\worldmap.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    worldmap.c

Abstract:

    This module implements the world map for the Date/Time applet.

Revision History:

--*/



//
//  Include Files.
//

#include "timedate.h"
#include <commctrl.h>
#include "worldmap.h"





////////////////////////////////////////////////////////////////////////////
//
//  ZeroCDC
//
////////////////////////////////////////////////////////////////////////////

static void ZeroCDC(
    LPCDC cdc)
{
    cdc->dc = NULL;
    cdc->bitmap = cdc->defbitmap = NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateCDC
//
////////////////////////////////////////////////////////////////////////////

static BOOL CreateCDC(
    LPCDC cdc,
    HBITMAP bitmap)
{
    cdc->dc = CreateCompatibleDC(NULL);
    cdc->bitmap = cdc->defbitmap = NULL;

    if (!bitmap)
    {
        return (FALSE);
    }

    if (!cdc->dc)
    {
        if (bitmap)
        {
            DeleteBitmap(bitmap);
        }
        return (FALSE);
    }

    if (bitmap)
    {
        SetLayout(cdc->dc, LAYOUT_BITMAPORIENTATIONPRESERVED); // to avoid mirroring on mirrored builds
        cdc->defbitmap = SelectBitmap(cdc->dc, cdc->bitmap = bitmap);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyCDC
//
////////////////////////////////////////////////////////////////////////////

static void DestroyCDC(
    LPCDC cdc)
{
    if (cdc->dc)
    {
        if (cdc->defbitmap)
        {
            SelectBitmap(cdc->dc, cdc->defbitmap);
        }
        if (cdc->bitmap)
        {
            DeleteBitmap(cdc->bitmap);
        }
        DeleteDC(cdc->dc);
        cdc->dc = NULL;
    }

    cdc->bitmap = cdc->defbitmap = NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadWorldMap
//
////////////////////////////////////////////////////////////////////////////

BOOL LoadWorldMap(
    LPWORLDMAP map,
    HINSTANCE instance,
    LPCTSTR resource)
{
    HDC tempdc = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
    BOOL result = FALSE;

    ZeroCDC(&map->original);
    ZeroCDC(&map->prepared);

    map->size.cx = map->size.cy = 0;
    map->rotation = 0;

    if (tempdc)
    {
        if (CreateCDC( &map->original,
                       LoadImage( instance,
                                  resource,
                                  IMAGE_BITMAP,
                                  0,
                                  0,
                                  LR_CREATEDIBSECTION ) ))
        {
            DIBSECTION ds;

            if (GetObject(map->original.bitmap, sizeof(DIBSECTION), &ds))
            {
                map->size.cx = ds.dsBm.bmWidth;
                map->size.cy = ds.dsBm.bmHeight;
                map->bits = (BYTE *)ds.dsBm.bmBits;
                map->scanbytes = ds.dsBm.bmWidthBytes;

                if (( (GetDeviceCaps(tempdc, BITSPIXEL) *
                       GetDeviceCaps(tempdc, PLANES)) > 4 ) ||
                    CreateCDC( &map->prepared,
                               CreateCompatibleBitmap( tempdc,
                                                       ds.dsBm.bmWidth,
                                                       ds.dsBm.bmHeight ) ))
                {
                    RGBQUAD init = { 127, 0, 0, 0 };
                    RGBQUAD *color = map->dirty.colors;
                    int i = WORLDMAP_MAX_COLORS;

                    while (i--)
                    {
                        *color++ = init;
                    }

                    //
                    //  Mark everything as dirty.
                    //
                    map->dirty.first = 0;
                    map->dirty.last = WORLDMAP_MAX_COLORS - 1;
                    map->dirty.spans = NULL;
                    map->dirty.freespans = NULL;

                    map->source = (map->prepared.dc)
                                      ? map->prepared.dc
                                      : map->original.dc;

                    result = TRUE;
                }
            }
            else
            {
                DestroyCDC(&map->original);
            }
        }

        DeleteDC(tempdc);
    }

    return (result);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeWorldMap
//
////////////////////////////////////////////////////////////////////////////

void FreeWorldMap(
    LPWORLDMAP map)
{
    DIRTYSPAN *span = map->dirty.spans;

    while (span)
    {
        DIRTYSPAN *next = span->next;

        LocalFree((HANDLE)span);
        span = next;
    }

    span = map->dirty.freespans;

    while (span)
    {
        DIRTYSPAN *next = span->next;

        LocalFree((HANDLE)span);
        span = next;
    }

    DestroyCDC(&map->original);
    DestroyCDC(&map->prepared);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetWorldMapRotation
//
////////////////////////////////////////////////////////////////////////////

void SetWorldMapRotation(
    LPWORLDMAP map,
    int rotation)
{
    rotation %= (int)map->size.cx;
    if (rotation < 0)
    {
        rotation += (int)map->size.cx;
    }
    map->rotation = rotation;
}


////////////////////////////////////////////////////////////////////////////
//
//  RotateWorldMap
//
////////////////////////////////////////////////////////////////////////////

void RotateWorldMap(
    LPWORLDMAP map,
    int delta)
{
    SetWorldMapRotation(map, map->rotation + delta);
}


////////////////////////////////////////////////////////////////////////////
//
//  WorldMapGetDisplayedLocation
//
////////////////////////////////////////////////////////////////////////////

int WorldMapGetDisplayedLocation(
    LPWORLDMAP map,
    int pos)
{
    return ( (pos + map->rotation) % map->size.cx );
}


////////////////////////////////////////////////////////////////////////////
//
//  EnumWorldMapDirtySpans
//
////////////////////////////////////////////////////////////////////////////

void EnumWorldMapDirtySpans(
    LPWORLDMAP map,
    ENUMSPANPROC proc,
    LPARAM data,
    BOOL rotate)
{
    DIRTYSPAN *span = map->dirty.spans;

    while (span)
    {
        if (rotate)
        {
            int left = (span->left + map->rotation) % map->size.cx;
            int right = left + span->right - span->left;

            if (right > map->size.cx)
            {
                proc(data, left, map->size.cx);

                left = 0;
                right -= map->size.cx;
            }

            proc(data, left, right);
        }
        else
        {
            proc(data, span->left, span->right);
        }

        span = span->next;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetWorldMapColorIndex
//
////////////////////////////////////////////////////////////////////////////

int GetWorldMapColorIndex(
    LPWORLDMAP map,
    int x,
    int y)
{
    //
    //  Protect against faulting.
    //
    if ( !map->bits ||
         (x < 0) || (x >= map->size.cx) ||
         (y < 0) || (y >= map->size.cy) )
    {
        return (-1);
    }

    //
    //  Correct source X coordinate for map's virtual rotation.
    //
    x += 2 * (int)map->size.cx - map->rotation;
    x %= (int)map->size.cx;

    //
    //  Correct for dib origin.
    //
    y = (LONG)map->size.cy - 1 - y;

    return ( map->bits[map->scanbytes * y + x] );
}


////////////////////////////////////////////////////////////////////////////
//
//  NewSpan
//
////////////////////////////////////////////////////////////////////////////

DIRTYSPAN *NewSpan(
    DIRTYSTUFF *dirty,
    DIRTYSPAN *a,
    DIRTYSPAN *b)
{
    DIRTYSPAN *span = dirty->freespans;

    if (span)
    {
        dirty->freespans = span->next;
    }
    else
    {
        if ((span = (DIRTYSPAN *)LocalAlloc(LPTR, sizeof(DIRTYSPAN))) == NULL)
        {
            return (NULL);
        }
    }

    span->next = b;

    if (a)
    {
        a->next = span;
    }
    else
    {
        dirty->spans = span;
    }

    return (span);
}


////////////////////////////////////////////////////////////////////////////
//
//  DeleteSpan
//
////////////////////////////////////////////////////////////////////////////

void DeleteSpan(
    DIRTYSTUFF *dirty,
    DIRTYSPAN *a,
    DIRTYSPAN *b)
{
    if (a)
    {
        a->next = b->next;
    }
    else
    {
        dirty->spans = b->next;
    }

    b->next = dirty->freespans;
    dirty->freespans = b;
}


////////////////////////////////////////////////////////////////////////////
//
//  AddDirtySpan
//
////////////////////////////////////////////////////////////////////////////

void AddDirtySpan(
    DIRTYSTUFF *dirty,
    int left,
    int cx)
{
    int right = left + cx;
    DIRTYSPAN *curr = dirty->spans;
    DIRTYSPAN *temp = NULL;
    DIRTYSPAN *span;

    cx = left - 1;
    while (curr && (cx > curr->right))
    {
        temp = curr;
        curr = curr->next;
    }

    cx = right + 1;
    if (curr && (cx >= curr->left))
    {
        if (left < curr->left)
        {
            curr->left = left;
        }
        span = temp = curr;

        if (right > curr->right)
        {
            curr->right = right;
            curr = curr->next;

            while (curr && (cx >= curr->left))
            {
                span->right = curr->right;

                DeleteSpan(dirty, temp, curr);
                temp = temp->next;
                curr = (temp ? temp->next : NULL);
            }
        }
    }
    else
    {
        if ((span = NewSpan(dirty, temp, curr)) == NULL)
        {
            if (!temp)
            {
                return;
            }
            span = temp;
            left = span->left;
        }

        span->left = left;
        span->right = right;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeWorldMapColor
//
////////////////////////////////////////////////////////////////////////////

void ChangeWorldMapColor(
    LPWORLDMAP map,
    int index,
    const RGBQUAD *color,
    int x,
    int cx)
{
    if ((index >= 0) && (index < WORLDMAP_MAX_COLORS))
    {
        //
        //  Store the new color.
        //
        map->dirty.colors[index] = *color;

        //
        //  Update the dirty markers to include this entry.
        //
        if (index < map->dirty.first)
        {
            map->dirty.first = index;
        }
        if (index > map->dirty.last)
        {
            map->dirty.last = index;
        }
    }

    while (((x + cx) > map->size.cx) && (x >= 0))
    {
        x -= map->size.cx;
    }

    if (x < 0)
    {
        AddDirtySpan(&map->dirty, map->size.cx + x, -x);
        cx += x;
        x = 0;
    }

    AddDirtySpan(&map->dirty, x, cx);
}


////////////////////////////////////////////////////////////////////////////
//
//  CommitChanges
//
////////////////////////////////////////////////////////////////////////////

void CommitChanges(
    LPWORLDMAP map)
{
    if (map->dirty.last >= 0)
    {
        SetDIBColorTable( map->original.dc,
                          map->dirty.first,
                          1 + map->dirty.last - map->dirty.first,
                          map->dirty.colors + map->dirty.first );

        //
        //  Reset the dirty markers.
        //
        map->dirty.first = WORLDMAP_MAX_COLORS;
        map->dirty.last = -1;
    }

    while (map->dirty.spans)
    {
        DIRTYSPAN *span = map->dirty.spans;

        if (map->prepared.dc)
        {
            BitBlt( map->prepared.dc,
                    span->left,
                    0,
                    span->right - span->left,
                    (int)map->size.cy,
                    map->original.dc,
                    span->left,
                    0,
                    SRCCOPY );
        }

        DeleteSpan(&map->dirty, NULL, span);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawWorldMap
//
////////////////////////////////////////////////////////////////////////////

void DrawWorldMap(
    HDC dc,
    int xdst,
    int ydst,
    int cx,
    int cy,
    LPWORLDMAP map,
    int xmap,
    int ymap,
    DWORD rop)
{
    CommitChanges(map);

    //
    //  Lop off extra Y stuff cause there's nothing there.
    //
    if ((ymap + cy) > (int)map->size.cy)
    {
        cy = (int)map->size.cy - ymap;
    }

    //
    //  Clip off extra X so we'll enter the case below only when we need to.
    //
    if (cx > (int)map->size.cx)
    {
        cx = (int)map->size.cx;
    }

    //
    //  Correct source X coordinate for map's virtual rotation.
    //
    xmap += 2 * (int)map->size.cx - map->rotation;
    xmap %= (int)map->size.cx;

    //
    //  See if the blt rect falls off the end of our flat little world.
    //
    if ((xmap + cx) > (int)map->size.cx)
    {
        //
        //  Compute the width of the first blt.
        //
        int firstcx = (int)map->size.cx - xmap;

        //
        //  See bits.  See bits blt.
        //
        BitBlt(dc, xdst, ydst, firstcx, cy, map->source, xmap, ymap, rop);

        //
        //  Adjust the params so the second blt does the right wrapping.
        //
        xdst += firstcx;
        cx -= firstcx;
        xmap = 0;
    }

    //
    //  blt bits blt!
    //
    BitBlt(dc, xdst, ydst, cx, cy, map->source, xmap, ymap, rop);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\worldmap.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    worldmap.h

Abstract:

    This module contains the information for the world map for the
    Date/Time applet.

Revision History:

--*/



#ifndef _WORLDMAP_H
#define _WORLDMAP_H


//
//  Constant Declarations.
//

#define WORLDMAP_MAX_DIRTY_SPANS       4
#define WORLDMAP_MAX_COLORS            256




//
//  Typedef Declarations.
//

typedef struct
{
    HDC dc;
    HBITMAP bitmap;
    HBITMAP defbitmap;

} CDC, *LPCDC;

typedef struct dirtyspan
{
    int left;
    int right;
    struct dirtyspan *next;

} DIRTYSPAN;

typedef struct
{
    int first;
    int last;
    DIRTYSPAN *spans;
    DIRTYSPAN *freespans;
    RGBQUAD colors[WORLDMAP_MAX_COLORS];

} DIRTYSTUFF;

typedef struct tagWORLDMAP
{
    CDC original;
    CDC prepared;
    SIZE size;
    BYTE *bits;
    LONG scanbytes;
    int rotation;
    HDC source;
    DIRTYSTUFF dirty;  // keep at end (>1k)

} WORLDMAP, *LPWORLDMAP;




//
//  Function Prototypes.
//

typedef void (*ENUMSPANPROC)(LPARAM data, int left, int right);

BOOL
LoadWorldMap(
    LPWORLDMAP map,
    HINSTANCE instance,
    LPCTSTR resource);

void
FreeWorldMap(
    LPWORLDMAP map);

void
SetWorldMapRotation(
    LPWORLDMAP map,
    int rotation);

void
RotateWorldMap(
    LPWORLDMAP map,
    int delta);

int
WorldMapGetDisplayedLocation(
    LPWORLDMAP map,
    int pos);

void
EnumWorldMapDirtySpans(
    LPWORLDMAP map,
    ENUMSPANPROC proc,
    LPARAM data,
    BOOL rotate);

void
ChangeWorldMapColor(
    LPWORLDMAP map,
    int index,
    const RGBQUAD *color,
    int x,
    int cx);

int
GetWorldMapColorIndex(
    LPWORLDMAP map,
    int x,
    int y);

void
DrawWorldMap(
    HDC dc,
    int xdst,
    int ydst,
    int cx,
    int cy,
    LPWORLDMAP map,
    int xmap,
    int ymap,
    DWORD rop);


#endif // _WORLDMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\vidupgrd\migrate.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.cpp

Environment:

    WIN32 User Mode

--*/


#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <initguid.h>
#include "migrate.h"
#include <regstr.h>
#include <ccstock.h>

// this will change when the .h is moved to a public location
#include "comp.h"

const TCHAR szWhackDevice[] = TEXT("\\Device");

#define IsRegStringType(x)  (((x) == REG_SZ) || ((x) == REG_EXPAND_SZ) || ((x) == REG_MULTI_SZ))

//
// Data
//

PFN_CM_LOCATE_DEVNODE gpfn_CM_Locate_DevNode = NULL;
PFN_SETUP_DI_ENUM_DEVICES_INTERFACES gpfn_SetupDiEnumDeviceInterfaces = NULL;
PFN_SETUP_DI_GET_DEVICE_INTERFACE_DETAIL gpfn_SetupDiGetDeviceInterfaceDetail = NULL;
PFN_SETUP_DI_CREATE_DEVICE_INTERFACE_REG_KEY gpfn_SetupDiCreateDeviceInterfaceRegKey = NULL;
PFN_SETUP_DI_OPEN_DEVICE_INTERFACE_REG_KEY gpfn_SetupDiOpenDeviceInterfaceRegKey = NULL;
PFN_SETUP_DI_CREATE_DEVICE_INTERFACE gpfn_SetupDiCreateDeviceInterface = NULL;


//
// DllMain
//

extern "C" {

BOOL APIENTRY
DllMain(HINSTANCE hDll,
        DWORD dwReason,
        LPVOID lpReserved)
{
    switch (dwReason) 
    {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
    	break;

    case DLL_THREAD_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    default:
    	break;
    }

    return TRUE;
}

}


BOOL
VideoUpgradeCheck(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
{
    DWORD dwDisposition;
    HKEY hKey = 0;
    OSVERSIONINFO osVer;
    BOOL bSuccess = FALSE;

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       SZ_UPDATE_SETTINGS,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_WRITE,
                       NULL,
                       &hKey,
                       &dwDisposition) != ERROR_SUCCESS) 
    {
        //
        // Oh well, guess we can't write it, no big deal
        //

        hKey = 0;
        goto Cleanup;
    }

    ZeroMemory(&osVer, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(osVer);

    if (!GetVersionEx(&osVer)) 
    {
        //
        // We can't get the version info, no big deal
        //

        goto Cleanup;
    }

    //
    // Get the current device caps and store them away for the
    // display applet to apply later.
    // Do it only if this is not a remote session.
    //

    if (!GetSystemMetrics(SM_REMOTESESSION)) 
    {
        SaveDisplaySettings(hKey, &osVer);
    }

    //
    // Store the OS version we are upgrading from
    //

    SaveOsInfo(hKey, &osVer);

    //
    // Save the video services 
    //

    if ((osVer.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
        (osVer.dwMajorVersion <= 4)) 
    {
        SaveNT4Services(hKey);
    }

    //
    // Save the applet extensions
    //

    if ((osVer.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
        (osVer.dwMajorVersion <= 5)) 
    {
        SaveAppletExtensions(hKey);
    }

    bSuccess = TRUE;

Cleanup:

    if (hKey != 0) 
    {
        RegCloseKey(hKey);
    }

    return bSuccess;
}


VOID
SaveOsInfo(
    HKEY hKey,
    POSVERSIONINFO posVer
    )
{
    DWORD cb;

    //
    // Can't just dump the struct into the registry b/c of the size
    // difference between CHAR and WCHAR (ie, szCSDVersion)
    //

    cb = sizeof(DWORD);
    RegSetValueEx(hKey,
                  SZ_UPGRADE_FROM_PLATFORM,
                  0,
                  REG_DWORD,
                  (PBYTE)&(posVer->dwPlatformId),
                  cb);

    cb = sizeof(DWORD);
    RegSetValueEx(hKey,
                  SZ_UPGRADE_FROM_MAJOR_VERSION,
                  0,
                  REG_DWORD,
                  (PBYTE)&(posVer->dwMajorVersion),
                  cb);

    cb = sizeof(DWORD);
    RegSetValueEx(hKey,
                  SZ_UPGRADE_FROM_MINOR_VERSION,
                  0,
                  REG_DWORD,
                  (PBYTE)&(posVer->dwMinorVersion),
                  cb);

    cb = sizeof(DWORD);
    RegSetValueEx(hKey,
                  SZ_UPGRADE_FROM_BUILD_NUMBER,
                  0,
                  REG_DWORD,
                  (PBYTE)&(posVer->dwBuildNumber),
                  cb);

    cb = lstrlen(posVer->szCSDVersion);
    RegSetValueEx(hKey,
                  SZ_UPGRADE_FROM_VERSION_DESC,
                  0,
                  REG_SZ,
                  (PBYTE)&(posVer->szCSDVersion),
                  cb);
}


BOOL
SaveDisplaySettings(
    HKEY hKey,
    POSVERSIONINFO posVer
    )
{
    PVU_PHYSICAL_DEVICE pPhysicalDevice = NULL;
    BOOL bSuccess = FALSE;

    if ((posVer->dwPlatformId == VER_PLATFORM_WIN32_NT) &&
        (posVer->dwMajorVersion >= 5)) 
    {
        //
        // Try the new way to get the display settings
        //

        CollectDisplaySettings(&pPhysicalDevice);
    }

    if (pPhysicalDevice == NULL) 
    {
        //
        // Try the old way to get the display settings
        //

        LegacyCollectDisplaySettings(&pPhysicalDevice);
    }

    if (pPhysicalDevice != NULL) 
    {
        //
        // Save the display settings to registry
        //

        bSuccess = WriteDisplaySettingsToRegistry(hKey, pPhysicalDevice);

        //
        // Cleanup
        //

        FreeAllNodes(pPhysicalDevice);
    }

    return bSuccess;
}


BOOL
GetDevInfoData(
    IN  LPTSTR pDeviceKey,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfoData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to destroy the device info list returned in phDevInfo

*/

{
    LPWSTR pwInterfaceName = NULL;
    LPWSTR pwInstanceID = NULL;
    BOOL bSuccess = FALSE;

    ASSERT (pDeviceKey != NULL);

    if (AllocAndReadInterfaceName(pDeviceKey, &pwInterfaceName)) 
    {
        bSuccess = GetDevInfoDataFromInterfaceName(pwInterfaceName,
                                                   phDevInfo,
                                                   pDevInfoData);
        LocalFree(pwInterfaceName);

    }

    if ((!bSuccess) &&
        AllocAndReadInstanceID(pDeviceKey, &pwInstanceID)) 
    {
        bSuccess = GetDevInfoDataFromInstanceID(pwInstanceID,
                                                phDevInfo,
                                                pDevInfoData);
        LocalFree(pwInstanceID);

    }

    return bSuccess;
}


BOOL
GetDevInfoDataFromInterfaceName(
    IN  LPWSTR pwInterfaceName,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfoData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to destroy the device info list returned in phDevInfo

*/

{
    LPWSTR pwDevicePath = NULL;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DevInfoData;
    SP_DEVICE_INTERFACE_DATA InterfaceData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pInterfaceDetailData = NULL;
    DWORD InterfaceIndex = 0;
    DWORD InterfaceSize = 0;
    BOOL bMatch = FALSE;

    ASSERT (pwInterfaceName != NULL);
    ASSERT (phDevInfo != NULL);
    ASSERT (pDevInfoData != NULL);

    ASSERT(gpfn_SetupDiEnumDeviceInterfaces != NULL);
    ASSERT(gpfn_SetupDiGetDeviceInterfaceDetail != NULL);

    //
    // Enumerate all display adapter interfaces
    //

    hDevInfo = SetupDiGetClassDevs(&GUID_DISPLAY_ADAPTER_INTERFACE,
                                   NULL,
                                   NULL,
                                   DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (hDevInfo == INVALID_HANDLE_VALUE) 
    {
        goto Cleanup;
    }

    InterfaceData.cbSize = sizeof(InterfaceData);
    while ((*gpfn_SetupDiEnumDeviceInterfaces)(hDevInfo,
                                               NULL,
                                               &GUID_DISPLAY_ADAPTER_INTERFACE,
                                               InterfaceIndex,
                                               &InterfaceData)) 
    {
        //
        // Get the required size for the interface
        //

        InterfaceSize = 0;
        (*gpfn_SetupDiGetDeviceInterfaceDetail)(hDevInfo,
                                                &InterfaceData,
                                                NULL,
                                                0,
                                                &InterfaceSize,
                                                NULL);

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) 
        {
            goto Cleanup;
        }

        //
        // Alloc memory for the interface
        //

        pInterfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA) LocalAlloc(LPTR, InterfaceSize);
        if (pInterfaceDetailData == NULL)
            goto Cleanup;

        //
        // Get the interface
        //

        pInterfaceDetailData->cbSize = sizeof(*pInterfaceDetailData);
        DevInfoData.cbSize = sizeof(DevInfoData);

        if ((*gpfn_SetupDiGetDeviceInterfaceDetail)(hDevInfo,
                                                    &InterfaceData,
                                                    pInterfaceDetailData,
                                                    InterfaceSize,
                                                    &InterfaceSize,
                                                    &DevInfoData)) 
        {
            //
            // Is the InterfaceName the same as the DevicePath?
            //

            pwDevicePath = pInterfaceDetailData->DevicePath;

            //
            // The first 4 characters of the interface name are different
            // between user mode and kernel mode (e.g. "\\?\" vs "\\.\")
            // Therefore, ignore them.
            //

            bMatch = (_wcsnicmp(pwInterfaceName + 4,
                                pwDevicePath + 4,
                                wcslen(pwInterfaceName + 4)) == 0);

            if (bMatch) 
            {
                //
                // We found the device
                //

                *phDevInfo = hDevInfo;
                CopyMemory(pDevInfoData, &DevInfoData, sizeof(*pDevInfoData));

                break;
            }
        }

        //
        // Clean-up
        //

        LocalFree(pInterfaceDetailData);
        pInterfaceDetailData = NULL;

        //
        // Next interface ...
        //

        InterfaceData.cbSize = sizeof(InterfaceData);
        ++InterfaceIndex;
    }

Cleanup:

    if (pInterfaceDetailData != NULL) 
    {
        LocalFree(pInterfaceDetailData);
    }

    //
    // Upon success, the caller is responsible to destroy the list
    //

    if (!bMatch && (hDevInfo != INVALID_HANDLE_VALUE)) 
    {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return bMatch;
}


BOOL
GetDevInfoDataFromInstanceID(
    IN  LPWSTR pwInstanceID,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfoData
    )

/*

    Note: If this function retuns success, the caller is responsible
          to destroy the device info list returned in phDevInfo

*/

{
    LPTSTR pInstanceID = NULL;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    DWORD DeviceIndex = 0;
    SP_DEVINFO_DATA DevInfoData;
    DEVINST DevInst;
    BOOL bSuccess = FALSE, bLocate = FALSE;

    ASSERT (pwInstanceID != NULL);
    ASSERT (phDevInfo != NULL);
    ASSERT (pDevInfoData != NULL);

    ASSERT (gpfn_CM_Locate_DevNode != NULL);

    pInstanceID = pwInstanceID;

    bLocate = ((*gpfn_CM_Locate_DevNode)(&DevInst, pInstanceID, 0) == CR_SUCCESS);

    if (!bLocate) 
    {
        goto Cleanup;
    }

    //
    // Enumerate all display adapters
    //

    hDevInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   DIGCF_PRESENT);

    if (hDevInfo == INVALID_HANDLE_VALUE) 
    {
        goto Cleanup;
    }

    DevInfoData.cbSize = sizeof(DevInfoData);
    while (SetupDiEnumDeviceInfo(hDevInfo, DeviceIndex, &DevInfoData)) 
    {
        if (DevInfoData.DevInst == DevInst) 
        {
            //
            // We found it
            //

            *phDevInfo = hDevInfo;
            CopyMemory(pDevInfoData, &DevInfoData, sizeof(*pDevInfoData));
            bSuccess = TRUE;

            break;
        }

        //
        // Next display adapter
        //

        ++DeviceIndex;
        DevInfoData.cbSize = sizeof(DevInfoData);
    }

Cleanup:

    //
    // Upon success, the caller is responsible to destroy the list
    //

    if (!bSuccess && (hDevInfo != INVALID_HANDLE_VALUE)) 
    {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return bSuccess;
}


VOID
CollectDisplaySettings(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice
    )
{
    DISPLAY_DEVICE DisplayDevice;
    DEVMODE DevMode;
    PVU_LOGICAL_DEVICE pLogicalDevice = NULL;
    DWORD dwEnum = 0;
    BOOL bGoOn = FALSE;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA DevInfoData;
    DWORD BusNumber = 0, Address = 0;
    LPTSTR pDeviceX = NULL, pX = NULL;
    HINSTANCE hinstSetupApi = NULL;
    BOOL bInserted = FALSE;
    HKEY hDeviceKey = NULL;

    hinstSetupApi = LoadLibrary(TEXT("SETUPAPI.DLL"));

    if (hinstSetupApi == NULL) 
    {
        goto Cleanup;
    }

    gpfn_CM_Locate_DevNode = (PFN_CM_LOCATE_DEVNODE)
        GetProcAddress(hinstSetupApi, "CM_Locate_DevNodeW");

    gpfn_SetupDiGetDeviceInterfaceDetail = (PFN_SETUP_DI_GET_DEVICE_INTERFACE_DETAIL)
        GetProcAddress(hinstSetupApi, "SetupDiGetDeviceInterfaceDetailW");

    gpfn_SetupDiCreateDeviceInterfaceRegKey = (PFN_SETUP_DI_CREATE_DEVICE_INTERFACE_REG_KEY)
        GetProcAddress(hinstSetupApi, "SetupDiCreateDeviceInterfaceRegKeyW");

    gpfn_SetupDiCreateDeviceInterface = (PFN_SETUP_DI_CREATE_DEVICE_INTERFACE)
        GetProcAddress(hinstSetupApi, "SetupDiCreateDeviceInterfaceW");

    gpfn_SetupDiEnumDeviceInterfaces = (PFN_SETUP_DI_ENUM_DEVICES_INTERFACES)
        GetProcAddress(hinstSetupApi, "SetupDiEnumDeviceInterfaces");

    gpfn_SetupDiOpenDeviceInterfaceRegKey = (PFN_SETUP_DI_OPEN_DEVICE_INTERFACE_REG_KEY)
        GetProcAddress(hinstSetupApi, "SetupDiOpenDeviceInterfaceRegKey");

    if ((gpfn_CM_Locate_DevNode == NULL) ||
        (gpfn_SetupDiEnumDeviceInterfaces == NULL) ||
        (gpfn_SetupDiGetDeviceInterfaceDetail == NULL) ||
        (gpfn_SetupDiCreateDeviceInterfaceRegKey == NULL) ||
        (gpfn_SetupDiOpenDeviceInterfaceRegKey == NULL) ||
        (gpfn_SetupDiCreateDeviceInterface == NULL)) 
    {
        goto Cleanup;
    }

    //
    // Enumerate all video devices
    //

    DisplayDevice.cb = sizeof(DISPLAY_DEVICE);
    while (EnumDisplayDevices(NULL, dwEnum, &DisplayDevice, 0)) 
    {
        bInserted = FALSE;
        pLogicalDevice = NULL;

        //
        // Get the device info data corresponding to the current
        // video device
        //

        if (!GetDevInfoData(DisplayDevice.DeviceKey,
                            &hDevInfo,
                            &DevInfoData)) 
        {
            goto NextDevice;
        }
        ASSERT (hDevInfo != INVALID_HANDLE_VALUE);

        //
        // Retrieve the bus number and address
        //

        bGoOn = SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                 &DevInfoData,
                                                 SPDRP_BUSNUMBER,
                                                 NULL,
                                                 (PBYTE)&BusNumber,
                                                 sizeof(BusNumber),
                                                 NULL) &&
                SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                 &DevInfoData,
                                                 SPDRP_ADDRESS,
                                                 NULL,
                                                 (PBYTE)&Address,
                                                 sizeof(Address),
                                                 NULL);

        SetupDiDestroyDeviceInfoList(hDevInfo);

        if (!bGoOn) 
        {
            goto NextDevice;
        }

        //
        // Allocate memory for the logical device
        //

        pLogicalDevice = (PVU_LOGICAL_DEVICE) LocalAlloc(LPTR, sizeof(VU_LOGICAL_DEVICE));

        if (pLogicalDevice == NULL) 
        {
            goto NextDevice;
        }

        //
        // DeviceX
        //

        pDeviceX = DisplayDevice.DeviceKey + _tcslen(DisplayDevice.DeviceKey);

        while ((pDeviceX != DisplayDevice.DeviceKey) &&
               (*pDeviceX != TEXT('\\'))) 
        {
            pDeviceX--;
        }

        if (pDeviceX == DisplayDevice.DeviceKey) 
        {
            goto NextDevice;
        }

        pX = SubStrEnd(SZ_DEVICE, pDeviceX);
        
        if (pX == pDeviceX) 
        {
            //
            // The new key is used: CCS\Control\Video\[GUID]\000X
            //

            pX++;
            pLogicalDevice->DeviceX = _ttoi(pX);
        
        } else 
        {
            //
            // The old key is used: CCS\Services\[SrvName]\DeviceX
            //
            
            pLogicalDevice->DeviceX = _ttoi(pX);
        }

        //
        // AttachedToDesktop
        //

        pLogicalDevice->AttachedToDesktop =
            ((DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) != 0);
        pLogicalDevice->ValidFields |= VU_ATTACHED_TO_DESKTOP;

        if (pLogicalDevice->AttachedToDesktop) 
        {
            //
            // Get the current mode
            //

            DevMode.dmSize = sizeof(DEVMODE);
            if (EnumDisplaySettings(DisplayDevice.DeviceName,
                                    ENUM_CURRENT_SETTINGS,
                                    &DevMode)) 
            {
                //
                // RelativeX, RelativeY, BitsPerPel, XResolution,
                // YResolution, VRefresh & Flags
                //

                pLogicalDevice->ValidFields |= VU_RELATIVE_X;
                pLogicalDevice->RelativeX = DevMode.dmPosition.x;

                pLogicalDevice->ValidFields |= VU_RELATIVE_Y;
                pLogicalDevice->RelativeY = DevMode.dmPosition.y;

                pLogicalDevice->ValidFields |= VU_BITS_PER_PEL;
                pLogicalDevice->BitsPerPel = DevMode.dmBitsPerPel;

                pLogicalDevice->ValidFields |= VU_X_RESOLUTION;
                pLogicalDevice->XResolution = DevMode.dmPelsWidth;

                pLogicalDevice->ValidFields |= VU_Y_RESOLUTION;
                pLogicalDevice->YResolution = DevMode.dmPelsHeight;

                pLogicalDevice->ValidFields |= VU_VREFRESH;
                pLogicalDevice->VRefresh = DevMode.dmDisplayFrequency;

                pLogicalDevice->ValidFields |= VU_FLAGS;
                pLogicalDevice->Flags = DevMode.dmDisplayFlags;

                //
                // Ignore the following settings for now:
                //     DefaultSettings.XPanning - DevMode.dmPanningWidth
                //     DefaultSettings.YPanning - DevMode.dmPanningHeight
                //     DefaultSettings.DriverExtra - DevMode.dmDriverExtra
                //
            }
        }

        if (GetDeviceRegKey(DisplayDevice.DeviceKey, 
                            &hDeviceKey))
        {
            DWORD dwTemp, cb;
            
            //
            // Hardware acceleration
            // 

            cb = sizeof(dwTemp);
            if (RegQueryValueEx(hDeviceKey,
                                SZ_HW_ACCELERATION,
                                NULL,
                                NULL,
                                (LPBYTE)&dwTemp,
                                &cb) == ERROR_SUCCESS) 
            {
                pLogicalDevice->ValidFields |= VU_HW_ACCELERATION;
                pLogicalDevice->HwAcceleration = dwTemp;
            }
        
            //
            // Pruning mode
            // 

            cb = sizeof(dwTemp);
            if (RegQueryValueEx(hDeviceKey,
                                SZ_PRUNNING_MODE,
                                NULL,
                                NULL,
                                (LPBYTE)&dwTemp,
                                &cb) == ERROR_SUCCESS) 
            {
                pLogicalDevice->ValidFields |= VU_PRUNING_MODE;
                pLogicalDevice->PruningMode = dwTemp;
            }

            RegCloseKey(hDeviceKey);
        }

        bInserted = InsertNode(ppPhysicalDevice,
                               pLogicalDevice,
                               0,
                               BusNumber,
                               Address);

NextDevice:

        if (!bInserted && (pLogicalDevice != NULL)) 
        {
            LocalFree(pLogicalDevice);
            pLogicalDevice = NULL;
        }

        DisplayDevice.cb = sizeof(DISPLAY_DEVICE);
        ++dwEnum;
    }

Cleanup:

    if (hinstSetupApi != NULL) 
    {
        gpfn_CM_Locate_DevNode = NULL;
        gpfn_SetupDiEnumDeviceInterfaces = NULL;
        gpfn_SetupDiGetDeviceInterfaceDetail = NULL;
        gpfn_SetupDiCreateDeviceInterfaceRegKey = NULL;
        gpfn_SetupDiOpenDeviceInterfaceRegKey = NULL;
        gpfn_SetupDiCreateDeviceInterface = NULL;

        FreeLibrary(hinstSetupApi);
    }
}


BOOL
InsertNode(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice,
    PVU_LOGICAL_DEVICE pLogicalDevice,
    DWORD Legacy,
    DWORD BusNumber,
    DWORD Address
    )
{
    PVU_PHYSICAL_DEVICE pPhysicalDevice = *ppPhysicalDevice;
    BOOL bSuccess = FALSE;
    PVU_LOGICAL_DEVICE pPrevLogicalDevice = NULL;
    PVU_LOGICAL_DEVICE pNextLogicalDevice = NULL;

    ASSERT (pLogicalDevice != NULL);
    ASSERT((Legacy == 0) || (*ppPhysicalDevice == NULL));

    if (Legacy == 0) 
    {
        //
        // If not Legacy, try to find if there is a device
        // with the same bus location
        //

        while (pPhysicalDevice != NULL) 
        {
            if ((pPhysicalDevice->BusNumber == BusNumber) &&
                (pPhysicalDevice->Address == Address)) 
            {
                break;
            }

            pPhysicalDevice = pPhysicalDevice->pNextPhysicalDevice;
        }
    }

    if (pPhysicalDevice != NULL) 
    {
        //
        // There is already a logical device with the same address
        //

        ASSERT (pPhysicalDevice->pFirstLogicalDevice != NULL);

        pPhysicalDevice->CountOfLogicalDevices++;

        pPrevLogicalDevice = pNextLogicalDevice = pPhysicalDevice->pFirstLogicalDevice;

        while (pNextLogicalDevice &&
               (pNextLogicalDevice->DeviceX <= pLogicalDevice->DeviceX)) 
        {
            pPrevLogicalDevice = pNextLogicalDevice;
            pNextLogicalDevice = pNextLogicalDevice->pNextLogicalDevice;
        }

        if (pPrevLogicalDevice == pNextLogicalDevice) 
        {
            ASSERT (pPrevLogicalDevice == pPhysicalDevice->pFirstLogicalDevice);

            pLogicalDevice->pNextLogicalDevice = pPhysicalDevice->pFirstLogicalDevice;
            pPhysicalDevice->pFirstLogicalDevice = pLogicalDevice;

        } else 
        {
            pPrevLogicalDevice->pNextLogicalDevice = pLogicalDevice;
            pLogicalDevice->pNextLogicalDevice = pNextLogicalDevice;
        }

        bSuccess = TRUE;

    } else 
    {
        //
        // This is a new physical device
        //

        pPhysicalDevice = (PVU_PHYSICAL_DEVICE) LocalAlloc(LPTR, sizeof(VU_PHYSICAL_DEVICE));

        if (pPhysicalDevice != NULL) 
        {
            pPhysicalDevice->pNextPhysicalDevice = *ppPhysicalDevice;
            *ppPhysicalDevice = pPhysicalDevice;

            pPhysicalDevice->pFirstLogicalDevice = pLogicalDevice;
            pPhysicalDevice->CountOfLogicalDevices = 1;
            pPhysicalDevice->Legacy = Legacy;
            pPhysicalDevice->BusNumber = BusNumber;
            pPhysicalDevice->Address = Address;

            bSuccess = TRUE;
        }
    }

    return bSuccess;
}


VOID
FreeAllNodes(
    PVU_PHYSICAL_DEVICE pPhysicalDevice
    )
{
    PVU_PHYSICAL_DEVICE pTempPhysicalDevice = NULL;
    PVU_LOGICAL_DEVICE pLogicalDevice = NULL, pTempLogicalDevice = NULL;

    while (pPhysicalDevice != NULL) 
    {
        pTempPhysicalDevice = pPhysicalDevice->pNextPhysicalDevice;
        pLogicalDevice = pPhysicalDevice->pFirstLogicalDevice;

        while (pLogicalDevice != NULL) 
        {
            pTempLogicalDevice = pLogicalDevice->pNextLogicalDevice;
            LocalFree(pLogicalDevice);
            pLogicalDevice = pTempLogicalDevice;
        }

        LocalFree(pPhysicalDevice);
        pPhysicalDevice = pTempPhysicalDevice;
    }
}


BOOL
WriteDisplaySettingsToRegistry(
    HKEY hKey,
    PVU_PHYSICAL_DEVICE pPhysicalDevice
    )
{
    PVU_LOGICAL_DEVICE pLogicalDevice = NULL;
    DWORD CountOfPhysicalDevices = 0;
    DWORD CountOfLogicalDevices = 0;
    HKEY hPysicalDeviceKey = 0;
    HKEY hLogicalDeviceKey = 0;
    BOOL bSuccess = FALSE;
    TCHAR Buffer[20];

    while (pPhysicalDevice != NULL) 
    {
        //
        // Create physical device subkey
        //

        StringCchPrintf(Buffer, ARRAYSIZE(Buffer), TEXT("%s%d"), SZ_VU_PHYSICAL, CountOfPhysicalDevices);
        DeleteKeyAndSubkeys(hKey, Buffer);

        if (RegCreateKeyEx(hKey,
                           Buffer,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hPysicalDeviceKey,
                           NULL) != ERROR_SUCCESS) 
        {
            hPysicalDeviceKey = 0;
            goto NextPhysicalDevice;
        }

        if (pPhysicalDevice->Legacy == 0) 
        {
            //
            // BusNumber
            //

            if (RegSetValueEx(hPysicalDeviceKey,
                              SZ_VU_BUS_NUMBER,
                              0,
                              REG_DWORD,
                              (PBYTE)&pPhysicalDevice->BusNumber,
                              sizeof(pPhysicalDevice->BusNumber)) != ERROR_SUCCESS) 
            {
                goto NextPhysicalDevice;
            }

            //
            // Address
            //

            if (RegSetValueEx(hPysicalDeviceKey,
                              SZ_VU_ADDRESS,
                              0,
                              REG_DWORD,
                              (PBYTE)&pPhysicalDevice->Address,
                              sizeof(pPhysicalDevice->Address)) != ERROR_SUCCESS) 
            {
                goto NextPhysicalDevice;
            }

        }

        pLogicalDevice = pPhysicalDevice->pFirstLogicalDevice;
        CountOfLogicalDevices = 0;

        while (pLogicalDevice != NULL) 
        {
            //
            // Create logical device subkey
            //

            StringCchPrintf(Buffer, ARRAYSIZE(Buffer), TEXT("%s%d"), SZ_VU_LOGICAL, CountOfLogicalDevices);
            if (RegCreateKeyEx(hPysicalDeviceKey,
                               Buffer,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_WRITE,
                               NULL,
                               &hLogicalDeviceKey,
                               NULL) != ERROR_SUCCESS) 
            {
                hLogicalDeviceKey = 0;

                //
                // Cannot go on with this physical device.
                // The order of logical devices DOES matter in the dual-view case.
                //

                break;
            }

            //
            // AttachedToDesktop
            //

            if (pLogicalDevice->ValidFields & VU_ATTACHED_TO_DESKTOP) 
            {
                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_ATTACHED_TO_DESKTOP,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->AttachedToDesktop,
                              sizeof(pLogicalDevice->AttachedToDesktop));
            }

            //
            // RelativeX
            //

            if (pLogicalDevice->ValidFields & VU_RELATIVE_X) 
            {
                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_RELATIVE_X,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->RelativeX,
                              sizeof(pLogicalDevice->RelativeX));
            }

            //
            // RelativeY
            //

            if (pLogicalDevice->ValidFields & VU_RELATIVE_Y) 
            {
                RegSetValueEx(hLogicalDeviceKey,
                            SZ_VU_RELATIVE_Y,
                            0,
                            REG_DWORD,
                            (PBYTE)&pLogicalDevice->RelativeY,
                            sizeof(pLogicalDevice->RelativeY));
            }

            //
            // BitsPerPel
            //

            if (pLogicalDevice->ValidFields & VU_BITS_PER_PEL) 
            {
                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_BITS_PER_PEL,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->BitsPerPel,
                              sizeof(pLogicalDevice->BitsPerPel));
            }

            //
            // XResolution
            //

            if (pLogicalDevice->ValidFields & VU_X_RESOLUTION) 
            {
                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_X_RESOLUTION,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->XResolution,
                              sizeof(pLogicalDevice->XResolution));
            }

            //
            // YResolution
            //

            if (pLogicalDevice->ValidFields & VU_Y_RESOLUTION) 
            {
                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_Y_RESOLUTION,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->YResolution,
                              sizeof(pLogicalDevice->YResolution));
            }

            //
            // VRefresh
            //

            if (pLogicalDevice->ValidFields & VU_VREFRESH) 
            {
                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_VREFRESH,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->VRefresh,
                              sizeof(pLogicalDevice->VRefresh));
            }

            //
            // Flags
            //

            if (pLogicalDevice->ValidFields & VU_FLAGS) 
            {
                RegSetValueEx(hLogicalDeviceKey,
                              SZ_VU_FLAGS,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->Flags,
                              sizeof(pLogicalDevice->Flags));
            }

            //
            // Hardware acceleration
            // 

            if (pLogicalDevice->ValidFields & VU_HW_ACCELERATION) 
            {
                RegSetValueEx(hLogicalDeviceKey,
                              SZ_HW_ACCELERATION,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->HwAcceleration,
                              sizeof(pLogicalDevice->HwAcceleration));
            }

            //
            // Pruning mode
            // 

            if (pLogicalDevice->ValidFields & VU_PRUNING_MODE) 
            {
                RegSetValueEx(hLogicalDeviceKey,
                              SZ_PRUNNING_MODE,
                              0,
                              REG_DWORD,
                              (PBYTE)&pLogicalDevice->PruningMode,
                              sizeof(pLogicalDevice->PruningMode));
            }

            ++CountOfLogicalDevices;

            RegCloseKey(hLogicalDeviceKey);
            hLogicalDeviceKey = 0;

            pLogicalDevice = pLogicalDevice->pNextLogicalDevice;
        }

        if ((CountOfLogicalDevices > 0) &&
            (RegSetValueEx(hPysicalDeviceKey,
                           SZ_VU_COUNT,
                           0,
                           REG_DWORD,
                           (PBYTE)&CountOfLogicalDevices,
                           sizeof(CountOfLogicalDevices)) == ERROR_SUCCESS)) 
        {
            ++CountOfPhysicalDevices;
        }

NextPhysicalDevice:

        if (hPysicalDeviceKey != 0) 
        {
            RegCloseKey(hPysicalDeviceKey);
            hPysicalDeviceKey = 0;
        }

        pPhysicalDevice = pPhysicalDevice->pNextPhysicalDevice;
    }

    if (CountOfPhysicalDevices > 0) 
    {
        bSuccess = (RegSetValueEx(hKey,
                                    SZ_VU_COUNT,
                                    0,
                                    REG_DWORD,
                                    (PBYTE)&CountOfPhysicalDevices,
                                    sizeof(CountOfPhysicalDevices)) != ERROR_SUCCESS);
    }

    return bSuccess;
}


VOID
LegacyCollectDisplaySettings(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice
    )
{
    PVU_LOGICAL_DEVICE pLogicalDevice = NULL;
    INT Width, Height, Index;
    BOOL useVga = FALSE;
    HDC hDisplay;
    POINT Res[] = {
            {  640,  480},
            {  800,  600},
            { 1024,  768},
            { 1152,  900},
            { 1280, 1024},
            { 1600, 1200},
            { 0, 0}         // end of table
        };

    ASSERT (*ppPhysicalDevice == NULL);

    //
    // Allocate memory for the logical device
    //

    pLogicalDevice = (PVU_LOGICAL_DEVICE) LocalAlloc(LPTR, sizeof(VU_LOGICAL_DEVICE));
    if (pLogicalDevice == NULL) 
    {
        return;
    }

    Width = GetSystemMetrics(SM_CXSCREEN);
    Height = GetSystemMetrics(SM_CYSCREEN);

    if (Width == 0 || Height == 0) 
    {
        //
        // Something went wrong, default to lowest common res
        //

        useVga = TRUE;
    }

    //
    // NT 4.0 multimon via driver vendor, not the OS ... adjust the width and height
    // back to normal values.  Once setup is complete, the second card will come
    // on line and it will be taken care of.  In both cases, the video area must
    // be rectangular, not like MM on 5.0 where we can have "holes"
    //

    else if (Width >= 2 * Height) 
    {
        //
        // Wide
        //

        for (Index = 0; Res[Index].x != 0; Index++) 
        {
            if (Res[Index].y == Height) 
            {
                Width = Res[Index].x;
                break;
            }
        }

        useVga = (Res[Index].x == 0);

    } else if (Height > Width) 
    {
        //
        // Tall
        //

        for (Index = 0; Res[Index].x != 0; Index++) 
        {
            if (Res[Index].x == Width) 
            {
                Height = Res[Index].y;
                break;
            }
        }

        useVga = (Res[Index].x == 0);
    }

    if (useVga) 
    {
        //
        // No match, default to VGA
        //

        Width = 640;
        Height = 480;
    }

    pLogicalDevice->ValidFields |= VU_ATTACHED_TO_DESKTOP;
    pLogicalDevice->AttachedToDesktop = 1;

    pLogicalDevice->ValidFields |= VU_X_RESOLUTION;
    pLogicalDevice->XResolution = Width;

    pLogicalDevice->ValidFields |= VU_Y_RESOLUTION;
    pLogicalDevice->YResolution = Height;

    hDisplay = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
    if (hDisplay)
    {
        pLogicalDevice->ValidFields |= VU_BITS_PER_PEL;
        pLogicalDevice->BitsPerPel = GetDeviceCaps(hDisplay, BITSPIXEL);

        pLogicalDevice->ValidFields |= VU_VREFRESH;
        pLogicalDevice->VRefresh = GetDeviceCaps(hDisplay, VREFRESH);
        DeleteDC(hDisplay);
    }

    if (!InsertNode(ppPhysicalDevice,
                    pLogicalDevice,
                    1,
                    0,
                    0)) 
    {
        //
        // Clean-up
        //

        LocalFree(pLogicalDevice);
    }
}


VOID  
SaveNT4Services(
    HKEY hKey
    )
{
    SC_HANDLE hSCManager = NULL;
    ENUM_SERVICE_STATUS* pmszAllServices = NULL;
    QUERY_SERVICE_CONFIG* pServiceConfig = NULL;
    SC_HANDLE hService = NULL;
    DWORD cbBytesNeeded = 0;
    DWORD ServicesReturned = 0;
    DWORD ResumeHandle = 0;
    DWORD ServiceLen = 0, TotalLen = 0, AllocatedLen = 128;
    PTCHAR pmszVideoServices = NULL, pmszTemp = NULL;

    //
    // Allocate initial memory
    //

    pmszVideoServices = (PTCHAR)LocalAlloc(LPTR, AllocatedLen * sizeof(TCHAR));
    if (pmszVideoServices == NULL) 
    {
        goto Fallout;
    }
    
    //
    // Open the service control manager 
    //

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    
    if (hSCManager == NULL) 
    {
        goto Fallout;
    }

    //
    // Get the required size 
    //

    if ((!EnumServicesStatus(hSCManager,
                             SERVICE_DRIVER,
                             SERVICE_STATE_ALL,
                             NULL,
                             0,
                             &cbBytesNeeded,
                             &ServicesReturned,
                             &ResumeHandle)) &&
        (GetLastError() != ERROR_MORE_DATA)) 
    {
        goto Fallout;
    }

    //
    // Allocate the memory
    //

    pmszAllServices = (ENUM_SERVICE_STATUS*)LocalAlloc(LPTR, cbBytesNeeded);

    if (pmszAllServices == NULL) 
    {
        goto Fallout;
    }

    //
    // Get the services 
    //

    ServicesReturned = ResumeHandle = 0;
    if (!EnumServicesStatus(hSCManager,
                            SERVICE_DRIVER,
                            SERVICE_STATE_ALL,
                            pmszAllServices,
                            cbBytesNeeded,
                            &cbBytesNeeded,
                            &ServicesReturned,
                            &ResumeHandle)) 
    {
        goto Fallout;
    }

    while (ServicesReturned--) 
    {
        //
        // Open the service
        //

        hService = OpenService(hSCManager,
                               pmszAllServices[ServicesReturned].lpServiceName,
                               SERVICE_ALL_ACCESS);

        if (hService != NULL) 
        {
            //
            // Get the required size to store the config info 
            //

            cbBytesNeeded = 0;
            if (QueryServiceConfig(hService,
                                   NULL,
                                   0,
                                   &cbBytesNeeded) ||
                (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) 
            {
                //
                // Allocate the memory
                //

                pServiceConfig = (QUERY_SERVICE_CONFIG*) LocalAlloc(LPTR, cbBytesNeeded);

                if (pServiceConfig != NULL) 
                {
                    //
                    // Get the config info 
                    //

                    if (QueryServiceConfig(hService,
                                           pServiceConfig,
                                           cbBytesNeeded,
                                           &cbBytesNeeded) &&
                        (pServiceConfig->dwStartType != SERVICE_DISABLED) &&
                        (_tcsicmp(pServiceConfig->lpLoadOrderGroup, TEXT("Video")) == 0)) 
                    {
                        ServiceLen = _tcslen(pmszAllServices[ServicesReturned].lpServiceName);
                        
                        if (TotalLen + ServiceLen + 2 > AllocatedLen) 
                        {
                            AllocatedLen = TotalLen + ServiceLen + 128;

                            pmszTemp = (PTCHAR)LocalAlloc(LPTR, AllocatedLen * sizeof(TCHAR));

                            if (pmszTemp == NULL) 
                            {
                                goto Fallout;
                            }

                            CopyMemory(pmszTemp, pmszVideoServices, TotalLen * sizeof(TCHAR));

                            LocalFree(pmszVideoServices);

                            pmszVideoServices = pmszTemp;
                            pmszTemp = NULL;
                        }

                        StringCchCopy(pmszVideoServices + TotalLen, AllocatedLen - TotalLen, pmszAllServices[ServicesReturned].lpServiceName);
                        TotalLen += ServiceLen + 1;
                    }

                    LocalFree(pServiceConfig);
                    pServiceConfig = NULL;
                }
            }

            CloseServiceHandle(hService);
            hService = NULL;
        }
    }

    //
    // Save the services to the registry
    //

    pmszVideoServices[TotalLen++] = TEXT('\0');
    RegSetValueEx(hKey,
                  SZ_SERVICES_TO_DISABLE,
                  0,
                  REG_MULTI_SZ,
                  (BYTE*)pmszVideoServices,
                  TotalLen * sizeof(TCHAR));

Fallout:
    
    if (hService != NULL) 
    {
        CloseServiceHandle(hService);
    }

    if (pServiceConfig != NULL) 
    {
        LocalFree(pServiceConfig);
    }

    if (pmszAllServices != NULL) 
    {
        LocalFree(pmszAllServices);
    }

    if (hSCManager != NULL) 
    {
        CloseServiceHandle(hSCManager);
    }

    if (pmszVideoServices != NULL) 
    {
        LocalFree(pmszVideoServices);
    }

} // SaveNT4Services


BOOL
DeleteKeyAndSubkeys(
    HKEY hKey,
    LPCTSTR lpSubKey
    )
{
    HKEY hkDeleteKey;
    TCHAR szChild[MAX_PATH + 1];
    BOOL bReturn = FALSE;

    if (RegOpenKeyEx(hKey,
                     lpSubKey,
                     0,
                     KEY_READ | KEY_WRITE,
                     &hkDeleteKey) == ERROR_SUCCESS) 
    {
        bReturn = TRUE;
        while (RegEnumKey(hkDeleteKey, 0, szChild, ARRAYSIZE(szChild)) == ERROR_SUCCESS) 
        {
            if (!DeleteKeyAndSubkeys(hkDeleteKey, szChild)) 
            {
                bReturn = FALSE;
                break;
            }
        }

        RegCloseKey(hkDeleteKey);

        if (bReturn)
            bReturn = (RegDeleteKey(hKey, lpSubKey) == ERROR_SUCCESS);
    }

    return bReturn;
}


VOID  
SaveAppletExtensions(
    HKEY hKey
    )
{
    PAPPEXT pAppExt = NULL;
    PAPPEXT pAppExtTemp;
    DWORD Len = 0;
    PTCHAR pmszAppExt = NULL;
    DWORD cchAppExt;
    HKEY hkDisplay;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_CONTROLSFOLDER_DISPLAY_SHEX_PROPSHEET,
                     0,
                     KEY_READ,
                     &hkDisplay) == ERROR_SUCCESS) 
    {
        DeskAESnapshot(hkDisplay, &pAppExt);

        if (pAppExt != NULL)
        {
            pAppExtTemp = pAppExt;
            while (pAppExtTemp) 
            {
                Len += lstrlen(pAppExtTemp->szDefaultValue) + 1;
                pAppExtTemp = pAppExtTemp->pNext;
            }

            cchAppExt = (Len + 1);
            pmszAppExt = (PTCHAR)LocalAlloc(LPTR, cchAppExt * sizeof(TCHAR));
            if (pmszAppExt != NULL) {
                
                pAppExtTemp = pAppExt;
                Len = 0;
                while (pAppExtTemp) {

                    StringCchCopy(pmszAppExt + Len, cchAppExt - Len, pAppExtTemp->szDefaultValue);
                    Len += lstrlen(pAppExtTemp->szDefaultValue) + 1;
                    pAppExtTemp = pAppExtTemp->pNext;
                }

                RegSetValueEx(hKey,
                            SZ_APPEXT_TO_DELETE,
                            0,
                            REG_MULTI_SZ,
                            (BYTE*)pmszAppExt,
                            (Len + 1) * sizeof(TCHAR));
            
                LocalFree(pmszAppExt);
            }

            DeskAECleanup(pAppExt);
        }

        RegCloseKey(hkDisplay);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\vidupgrd\sources.inc ===
TARGETNAME=vidupgrd
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETEXT=dll

INCLUDES=$(BASE_INC_PATH)

TARGETLIBS=$(SDK_LIB_PATH)\advapi32.lib     \
           $(SDK_LIB_PATH)\user32.lib       \
           $(SDK_LIB_PATH)\kernel32.lib     \
           $(SDK_LIB_PATH)\gdi32.lib        \
           $(SDK_LIB_PATH)\setupapi.lib     \
           $(SDK_LIB_PATH)\strsafe.lib

USE_MSVCRT=1

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX
C_DEFINES=-DWIN32 -DW3 -DUNICODE -D_UNICODE

SOURCES=..\migrate.cpp   \
        ..\deskcmmn.cpp

DLLDEF=$(O)\vidupgrd.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ddk\makefile.inc ===
!IFDEF PASS0ONLY
BuildDDK:

!ELSE

#
# Process only on the second pass
#

BuildDDK:
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd ddk_shell.ini ddk $(PROJECT_ROOT)
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\atlstuff.h ===
// atlstuff.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma once

// Change these values to use different versions
#define _RICHEDIT_VER	0x0100

#define _ATL_NO_MP_HEAP

#pragma warning(disable: 4530)  // C++ exception handling

#include <atlbase.h>

extern CComModule _Module;


#include <atlcom.h>

#include <hlink.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>

#include <atlapp.h>
#include <atlwin.h>

#include <atlres.h>
#include <atlframe.h>
#include <atlgdi.h>
#include <atlctrls.h>
#include <atldlgs.h>
#include <atlcrack.h>
#include <atlmisc.h>
#include <atlctrlx.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\vidupgrd\migrate.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.h

Environment:

    WIN32 User Mode

--*/


#include <windows.h>
#include <tchar.h>
#include <setupapi.h>
#include <ole2.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <debug.h>
#include "..\common\deskcmmn.h"

#define STRSAFE_LIB
#include <strsafe.h>

#define VU_ATTACHED_TO_DESKTOP 0x00000001
#define VU_RELATIVE_X          0x00000002
#define VU_RELATIVE_Y          0x00000004
#define VU_BITS_PER_PEL        0x00000008
#define VU_X_RESOLUTION        0x00000010
#define VU_Y_RESOLUTION        0x00000020
#define VU_VREFRESH            0x00000040
#define VU_FLAGS               0x00000080
#define VU_HW_ACCELERATION     0x00000100
#define VU_PRUNING_MODE        0x00000200


typedef struct _VU_LOGICAL_DEVICE {
    
    struct _VU_LOGICAL_DEVICE *pNextLogicalDevice;
    DWORD DeviceX;
    DWORD ValidFields;

    DWORD AttachedToDesktop;
    DWORD RelativeX;
    DWORD RelativeY;
    DWORD BitsPerPel;
    DWORD XResolution;
    DWORD YResolution;
    DWORD VRefresh;
    DWORD Flags;
    DWORD HwAcceleration;
    DWORD PruningMode;

} VU_LOGICAL_DEVICE, *PVU_LOGICAL_DEVICE;


typedef struct _VU_PHYSICAL_DEVICE {
    
    struct _VU_PHYSICAL_DEVICE *pNextPhysicalDevice;
    PVU_LOGICAL_DEVICE pFirstLogicalDevice;
    DWORD CountOfLogicalDevices;
    DWORD Legacy;
    DWORD BusNumber;
    DWORD Address;

} VU_PHYSICAL_DEVICE, *PVU_PHYSICAL_DEVICE;


typedef CMAPI CONFIGRET (WINAPI *PFN_CM_LOCATE_DEVNODE)(
    OUT PDEVINST pdnDevInst,
    IN DEVINSTID pDeviceID,    OPTIONAL
    IN ULONG ulFlags
    );


typedef BOOL (WINAPI *PFN_SETUP_DI_ENUM_DEVICES_INTERFACES)(
    IN  HDEVINFO DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,     OPTIONAL
    IN  CONST GUID *InterfaceClassGuid,
    IN  DWORD MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );


typedef BOOL (WINAPI *PFN_SETUP_DI_GET_DEVICE_INTERFACE_DETAIL)(
    IN  HDEVINFO DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA DeviceInterfaceDetailData, OPTIONAL
    IN  DWORD DeviceInterfaceDetailDataSize,
    OUT PDWORD RequiredSize, OPTIONAL
    OUT PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );


typedef HKEY (WINAPI *PFN_SETUP_DI_CREATE_DEVICE_INTERFACE_REG_KEY)(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD Reserved,
    IN REGSAM samDesired,
    IN HINF InfHandle, OPTIONAL
    IN PCTSTR InfSectionName OPTIONAL
    );


typedef HKEY (WINAPI *PFN_SETUP_DI_OPEN_DEVICE_INTERFACE_REG_KEY)(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD Reserved,
    IN REGSAM samDesired
    );


typedef HKEY (WINAPI *PFN_SETUP_DI_CREATE_DEVICE_INTERFACE)(
    IN  HDEVINFO DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  CONST GUID *InterfaceClassGuid,
    IN  PCTSTR ReferenceString, OPTIONAL
    IN  DWORD CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    );


VOID
SaveOsInfo(
    HKEY hKey,
    POSVERSIONINFO posVer
    );

VOID  
SaveLegacyDriver(
    HKEY hKey
    );

VOID  
SaveNT4Services(
    HKEY hKey
    );

VOID  
SaveAppletExtensions(
    HKEY hKey
    );

BOOL
SaveDisplaySettings(
    HKEY hKey,
    POSVERSIONINFO posVer
    );

VOID
CollectDisplaySettings(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice
    );

VOID
LegacyCollectDisplaySettings(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice
    );

BOOL
WriteDisplaySettingsToRegistry(
    HKEY hKey, 
    PVU_PHYSICAL_DEVICE pPhysicalDevice
    );

BOOL
InsertNode(
    PVU_PHYSICAL_DEVICE* ppPhysicalDevice, 
    PVU_LOGICAL_DEVICE pLogicalDevice,
    DWORD Legacy,
    DWORD BusNumber,
    DWORD Address
    );

VOID
FreeAllNodes(
    PVU_PHYSICAL_DEVICE pPhysicalDevice
    );

BOOL 
GetDevInfoData(
    IN  LPTSTR pDeviceKey,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfo
    );

BOOL 
GetDevInfoDataFromInterfaceName(
    IN  LPWSTR pwInterfaceName,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfo
    );

BOOL 
GetDevInfoDataFromInstanceID(
    IN  LPWSTR pwInstanceID,
    OUT HDEVINFO* phDevInfo,
    OUT PSP_DEVINFO_DATA pDevInfo
    );

BOOL
DeleteKeyAndSubkeys(
    HKEY hKey,
    LPCTSTR lpSubKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\bandsite.cpp ===
#include "cabinet.h"
#include "rcids.h"
#include <shguidp.h>
#include "bandsite.h"
#include "shellp.h"
#include "shdguid.h"
#include "taskband.h"
#include "taskbar.h"
#include <regstr.h>
#include "util.h"
#include "strsafe.h"

extern IStream *GetDesktopViewStream(DWORD grfMode, LPCTSTR pszName);

HRESULT PersistStreamLoad(IStream *pstm, IUnknown *punk);
HRESULT PersistStreamSave(IStream *pstm, BOOL fClearDirty, IUnknown *punk);

const TCHAR c_szTaskbar[] = TEXT("Taskbar");

// {69B3F106-0F04-11d3-AE2E-00C04F8EEA99}
static const GUID CLSID_TrayBandSite = { 0x69b3f106, 0xf04, 0x11d3, { 0xae, 0x2e, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99 } };

// {8B4A02DB-97BB-4C1B-BE75-8827A7358CD0}
static const GUID CLSID_TipBand = { 0x8B4A02DB, 0x97BB, 0x4C1B, { 0xBE, 0x75, 0x88, 0x27, 0xA7, 0x35, 0x8C, 0xD0 } };


class CTrayBandSite : public IBandSite
                    , public IClassFactory
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IBandSite methods ***
    STDMETHOD(AddBand)          (THIS_ IUnknown* punk);
    STDMETHOD(EnumBands)        (THIS_ UINT uBand, DWORD* pdwBandID);
    STDMETHOD(QueryBand)        (THIS_ DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName) ;
    STDMETHOD(SetBandState)     (THIS_ DWORD dwBandID, DWORD dwMask, DWORD dwState) ;
    STDMETHOD(RemoveBand)       (THIS_ DWORD dwBandID);
    STDMETHOD(GetBandObject)    (THIS_ DWORD dwBandID, REFIID riid, void ** ppvObj);
    STDMETHOD(SetBandSiteInfo)  (THIS_ const BANDSITEINFO * pbsinfo);
    STDMETHOD(GetBandSiteInfo)  (THIS_ BANDSITEINFO * pbsinfo);

    // *** IClassFactory methods ***
    HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
    {
        if (pUnkOuter != NULL)
            return CLASS_E_NOAGGREGATION;

        return QueryInterface(riid, ppvObj);
    }
    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock)
    {
        return S_OK;
    }
    
    IContextMenu3* GetContextMenu();
    void SetInner(IUnknown* punk);
    void SetLoaded(BOOL fLoaded) {_fLoaded = fLoaded;}
    BOOL HandleMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    
protected:
    CTrayBandSite();
    virtual ~CTrayBandSite();

    BOOL _CreateBandSiteMenu(IUnknown* punk);
    HRESULT _AddRequiredBands();
    void _BroadcastExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    HRESULT _SetWindowTheme(LPWSTR pwzTheme);
    friend IBandSite* BandSite_CreateView();
    friend void BandSite_HandleDelayBootStuff(IUnknown* punk);
    friend void BandSite_Load();
    friend HRESULT BandSite_SetWindowTheme(IBandSite* pbs, LPWSTR pwzTheme);
    
    LONG _cRef;
    IUnknown *_punkInner;
    IBandSite *_pbsInner;

    // bandsite context menu
    IContextMenu3* _pcm;
    HWND _hwnd;
    BOOL _fLoaded;
    BOOL _fDelayBootStuffHandled;
    DWORD _dwClassObject;
    WCHAR* _pwzTheme;
};

CTrayBandSite* IUnknownToCTrayBandSite(IUnknown* punk)
{
    CTrayBandSite* ptbs;
    
    punk->QueryInterface(CLSID_TrayBandSite, (void **)&ptbs);
    ASSERT(ptbs);
    punk->Release();

    return ptbs;
}

CTrayBandSite::CTrayBandSite() : _cRef(1)
{
}

CTrayBandSite::~CTrayBandSite()
{
    if (_pcm)
        _pcm->Release();

    if (_pwzTheme)
        delete[] _pwzTheme;
    
    return;
}

ULONG CTrayBandSite::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTrayBandSite::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        _cRef = 1000;               // guard against recursion
    
        if (_pbsInner) 
        {
            AddRef();
            _pbsInner->Release();
        }
    
        // this must come last
        if (_punkInner)
            _punkInner->Release();  // paired w/ CCI aggregation
    
        ASSERT(_cRef == 1000);

        delete this;
    }
    return cRef;
}

HRESULT CTrayBandSite::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CTrayBandSite, IBandSite),
        QITABENT(CTrayBandSite, IClassFactory),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hr) && IsEqualIID(riid, CLSID_TrayBandSite))
    {
        *ppvObj = this;
        AddRef();
        hr = S_OK;
    }

    if (FAILED(hr) && _punkInner)
    {
        hr = _punkInner->QueryInterface(riid, ppvObj);
    }

    return hr;
}


static BOOL CALLBACK SetTransparency(HWND hwnd, LPARAM lParam)
{
    SetWindowStyleEx(hwnd, WS_EX_TRANSPARENT, (BOOL)lParam);

    return TRUE;
}

// *** IBandSite methods ***

HRESULT CTrayBandSite::AddBand(IUnknown* punk)
{
    CLSID clsid;
    HRESULT hr = S_OK;

    if (!_fDelayBootStuffHandled)
    {
        //
        // Tell the band to go into "delay init" mode.  When the tray
        // timer goes off we'll tell the band to finish up.  (See
        // BandSite_HandleDelayBootStuff).
        //
        IUnknown_Exec(punk, &CGID_DeskBand, DBID_DELAYINIT, 0, NULL, NULL);
    }

    if (c_tray.GetIsNoToolbarsOnTaskbarPolicyEnabled())
    {
        hr = IUnknown_GetClassID(punk, &clsid);
        if (SUCCEEDED(hr))
        {
            hr = IsEqualGUID(clsid, CLSID_TaskBand) ? S_OK : E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = _pbsInner->AddBand(punk);

        if (SUCCEEDED(hr))
        {
            IShellFolderBand *pisfBand;
            HRESULT hrInner = punk->QueryInterface(IID_PPV_ARG(IShellFolderBand, &pisfBand));
            if (SUCCEEDED(hrInner)) 
            {
                BANDINFOSFB bi;
                bi.dwMask = ISFB_MASK_STATE;
                hrInner = pisfBand->GetBandInfoSFB(&bi);
                if (SUCCEEDED(hrInner))
                {
                    bi.dwState |= ISFB_STATE_BTNMINSIZE;
                    hrInner = pisfBand->SetBandInfoSFB(&bi);
                }
                pisfBand->Release();
            }


            // tell the band to use the taskbar theme
            if (_pwzTheme)
            {
                VARIANTARG var;
                var.vt = VT_BSTR;
                var.bstrVal = _pwzTheme;
                IUnknown_Exec(punk, &CGID_DeskBand, DBID_SETWINDOWTHEME, 0, &var, NULL);
            }

            if (GetWindowLong(_hwnd, GWL_EXSTYLE) & WS_EX_TRANSPARENT)
            {
                EnumChildWindows(_hwnd, SetTransparency, (LPARAM)TRUE);
            }
        }
    }

    return hr;
}

HRESULT CTrayBandSite::EnumBands(UINT uBand, DWORD* pdwBandID)
{
    return _pbsInner->EnumBands(uBand, pdwBandID);
}

HRESULT CTrayBandSite::QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName) 
{
    return _pbsInner->QueryBand(dwBandID, ppstb, pdwState, pszName, cchName);
}


HRESULT CTrayBandSite::SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState) 
{
    return _pbsInner->SetBandState(dwBandID, dwMask, dwState);
}


HRESULT CTrayBandSite::RemoveBand(DWORD dwBandID)
{
    return _pbsInner->RemoveBand(dwBandID);
}


HRESULT CTrayBandSite::GetBandObject(DWORD dwBandID, REFIID riid, void ** ppvObj)
{
    return _pbsInner->GetBandObject(dwBandID, riid, ppvObj);
}

HRESULT CTrayBandSite::SetBandSiteInfo (const BANDSITEINFO * pbsinfo)
{
    return _pbsInner->SetBandSiteInfo(pbsinfo);
}

HRESULT CTrayBandSite::GetBandSiteInfo (BANDSITEINFO * pbsinfo)
{
    return _pbsInner->GetBandSiteInfo(pbsinfo);
}

HRESULT CTrayBandSite::_AddRequiredBands()
{
    IDeskBand* pdb;
    HRESULT hr = CoCreateInstance(CLSID_TaskBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDeskBand, &pdb));
    if (SUCCEEDED(hr))
    {
        hr = AddBand(pdb);
        pdb->Release();
    }

    return hr;
}

HRESULT CTrayBandSite::_SetWindowTheme(LPWSTR pwzTheme)
{
    if (_pwzTheme)
    {
        delete[] _pwzTheme;
        _pwzTheme = NULL;
    }

    if (pwzTheme)
    {
        int cchLen = lstrlen(pwzTheme) + 1;
        _pwzTheme = new WCHAR[cchLen];
        if (_pwzTheme)
        {
            StringCchCopy(_pwzTheme, cchLen, pwzTheme);
        }
    }

    return S_OK;
}

HRESULT BandSite_TestBandCLSID(IBandSite *pbs, DWORD idBand, REFIID riid)
{
    HRESULT hr = E_FAIL;
    IPersist *pp;
    if (pbs)
    {
        hr = pbs->GetBandObject(idBand, IID_PPV_ARG(IPersist, &pp));
        if (SUCCEEDED(hr))
        {
            CLSID clsid;
            hr = pp->GetClassID(&clsid);
            if (SUCCEEDED(hr))
            {
                hr = IsEqualGUID(clsid, riid) ? S_OK : S_FALSE;
            }
            pp->Release();
        }
    }
    return hr;
}

HRESULT BandSite_SetWindowTheme(IBandSite* pbs, LPWSTR pwzTheme)
{
    HRESULT hr = E_FAIL;

    if (pbs)
    {
        CTrayBandSite* ptbs = IUnknownToCTrayBandSite(pbs);
        if (ptbs)
        {
            ptbs->_SetWindowTheme(pwzTheme);
        }

        DWORD dwBandID;
        BOOL fFound = FALSE;
        for (int i = 0; !fFound && SUCCEEDED(pbs->EnumBands(i, &dwBandID)); i++)
        {
            IUnknown* punk;
            HRESULT hrInner = pbs->GetBandObject(dwBandID, IID_PPV_ARG(IUnknown, &punk));
            if (SUCCEEDED(hrInner))
            {
                VARIANTARG var;
                var.vt = VT_BSTR;
                var.bstrVal = pwzTheme;

                IUnknown_Exec(punk, &CGID_DeskBand, DBID_SETWINDOWTHEME, 0, &var, NULL);
            }
        }
    }
    return hr;
}

HRESULT BandSite_FindBand(IBandSite* pbs, REFCLSID rclsid, REFIID riid, void **ppv, int *piCount, DWORD* pdwBandID)
{
    HRESULT hr = E_FAIL;

    int iCount = 0;

    if (pbs)
    {
        DWORD dwBandID;
        for (int i = 0; SUCCEEDED(pbs->EnumBands(i, &dwBandID)); i++)
        {
            if (BandSite_TestBandCLSID(pbs, dwBandID, rclsid) == S_OK)
            {
                iCount++;

                if (pdwBandID)
                {
                    *pdwBandID = dwBandID;
                }

                if (ppv)
                    hr = pbs->GetBandObject(dwBandID, riid, ppv);
                else
                    hr = S_OK;
            }
        }
    }

    if (piCount)
    {
        *piCount = iCount;
    }

    return hr;
}

void BandSite_Initialize(IBandSite* pbs)
{
    HWND hwnd = v_hwndTray;
    
    CTaskBar *pow = new CTaskBar();
    if (pow)
    {
        IDeskBarClient* pdbc;
        if (SUCCEEDED(pbs->QueryInterface(IID_PPV_ARG(IDeskBarClient, &pdbc))))
        {
            // we need to set a dummy tray IOleWindow
            pdbc->SetDeskBarSite(SAFECAST(pow, IOleWindow*));
            pdbc->GetWindow(&hwnd);
            if (hwnd)
            {
                // taskbar windows are themed under Taskbar subapp name
                SendMessage(hwnd, RB_SETWINDOWTHEME, 0, (LPARAM)c_wzTaskbarTheme);
                pow->_hwndRebar = hwnd;
            }
            pdbc->Release();
        }
        pow->Release();
    }
}

IContextMenu3* CTrayBandSite::GetContextMenu()
{
    if (!_pcm)
    {
        if (SUCCEEDED(CoCreateInstance(CLSID_BandSiteMenu, NULL,CLSCTX_INPROC_SERVER, 
                         IID_PPV_ARG(IContextMenu3, &_pcm))))
        {
            IShellService* pss;
            if (SUCCEEDED(_pcm->QueryInterface(IID_PPV_ARG(IShellService, &pss))))
            {
                pss->SetOwner(SAFECAST(this, IBandSite*));
                pss->Release();
            }
        }
    }
    if (_pcm)
        _pcm->AddRef();
    
    return _pcm;
}

HRESULT BandSite_AddMenus(IUnknown* punk, HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast)
{
    HRESULT hr = E_FAIL;

    CTrayBandSite* ptbs = IUnknownToCTrayBandSite(punk);
    
    IContextMenu3* pcm = ptbs->GetContextMenu();
    if (pcm)
    {
        hr = pcm->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, CMF_ICM3);
        pcm->Release();
    }

    return hr;
}

void BandSite_HandleMenuCommand(IUnknown* punk, UINT idCmd)
{
    CTrayBandSite* ptbs = IUnknownToCTrayBandSite(punk);
    
    IContextMenu3* pcm = ptbs->GetContextMenu();

    if (pcm)
    {
        CMINVOKECOMMANDINFOEX ici =
        {
            sizeof(CMINVOKECOMMANDINFOEX),
            0L,
            NULL,
            (LPSTR)MAKEINTRESOURCE(idCmd),
            NULL, NULL,
            SW_NORMAL,
        };

        pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
        pcm->Release();
    }
}

void CTrayBandSite::SetInner(IUnknown* punk)
{
    _punkInner = punk;
    
    _punkInner->QueryInterface(IID_PPV_ARG(IBandSite, &_pbsInner));
    Release();
    
    ASSERT(_pbsInner);
}

IBandSite* BandSite_CreateView()
{
    IUnknown *punk;
    HRESULT hr = E_FAIL;

    // aggregate a TrayBandSite (from a RebarBandSite)
    CTrayBandSite *ptbs = new CTrayBandSite;
    if (ptbs)
    {
        hr = CoCreateInstance(CLSID_RebarBandSite, (IBandSite*)ptbs, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
        if (SUCCEEDED(hr))
        {
            ptbs->SetInner(punk);    // paired w/ Release in outer (TBS::Release)
            BandSite_Initialize(ptbs);
            return SAFECAST(ptbs, IBandSite*);
        }
        else
        {
            delete ptbs;
            return NULL;
        }
    }
    return NULL;
}

HRESULT BandSite_SaveView(IUnknown *pbs)
{
    HRESULT hr = E_FAIL;

    IStream *pstm = GetDesktopViewStream(STGM_WRITE, c_szTaskbar);
    if (pstm) 
    {
        hr = PersistStreamSave(pstm, TRUE, pbs);
        pstm->Release();
    }

    return hr;
}

BOOL CTrayBandSite::HandleMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    if (!_hwnd)
    {
        IUnknown_GetWindow(SAFECAST(this, IBandSite*), &_hwnd);
    }

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
        if (_pcm)
        {
            _pcm->HandleMenuMsg2(uMsg, wParam, lParam, plres);
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code)
        {
        case NM_NCHITTEST:
            {
                NMMOUSE *pnm = (LPNMMOUSE)lParam;
                if (_hwnd == pnm->hdr.hwndFrom)
                {
                    if (pnm->dwHitInfo == RBHT_CLIENT || pnm->dwItemSpec == -1)
                    {
                        if (plres)
                            *plres = HTTRANSPARENT;
                    }
                    return TRUE;
                }
            }
            break;

        case RBN_MINMAX:
            *plres = SHRestricted(REST_NOMOVINGBAND);
            return TRUE;
        }
        break;
    }
        
    IWinEventHandler *pweh;
    if (SUCCEEDED(QueryInterface(IID_PPV_ARG(IWinEventHandler, &pweh))))
    {
        HRESULT hr = pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
        pweh->Release();
        return SUCCEEDED(hr);
    }
    ASSERT(0);  // we know we support IWinEventHandler
    
    return FALSE;
}

void CTrayBandSite::_BroadcastExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    // Broadcast an Exec to all child bands

    DWORD dwBandID;
    UINT uBand = 0;
    while (SUCCEEDED(EnumBands(uBand, &dwBandID)))
    {
        IOleCommandTarget* pct;
        if (SUCCEEDED(GetBandObject(dwBandID, IID_PPV_ARG(IOleCommandTarget, &pct))))
        {
            pct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            pct->Release();
        }
        uBand++;
    }
}

void BandSite_HandleDelayBootStuff(IUnknown* punk)
{
    if (punk)
    {
        CTrayBandSite* pbs = IUnknownToCTrayBandSite(punk);
        pbs->_fDelayBootStuffHandled = TRUE;
        pbs->_BroadcastExec(&CGID_DeskBand, DBID_FINISHINIT, 0, NULL, NULL);
    }
}

// returns true or false whether it handled it
BOOL BandSite_HandleMessage(IUnknown *punk, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    if (punk) 
    {
        CTrayBandSite* pbs = IUnknownToCTrayBandSite(punk);
        return pbs->HandleMessage(hwnd, uMsg, wParam, lParam, plres);
    }
    return FALSE;
} 

void BandSite_SetMode(IUnknown *punk, DWORD dwMode)
{
    IBandSite* pbs = (IBandSite*)punk;
    if (pbs) 
    {
        IDeskBarClient *pdbc;
        if (SUCCEEDED(pbs->QueryInterface(IID_PPV_ARG(IDeskBarClient, &pdbc))))
        {
            pdbc->SetModeDBC(dwMode);
            pdbc->Release();
        }
    }
} 

void BandSite_Update(IUnknown *punk)
{
    IBandSite* pbs = (IBandSite*)punk;
    if (pbs) 
    {
        IOleCommandTarget *pct;
        if (SUCCEEDED(pbs->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct))))
        {
            pct->Exec(&CGID_DeskBand, DBID_BANDINFOCHANGED, 0, NULL, NULL);
            pct->Release();
        }
    }
} 

void BandSite_UIActivateDBC(IUnknown *punk, DWORD dwState)
{
    IBandSite* pbs = (IBandSite*)punk;
    if (pbs)
    {
        IDeskBarClient *pdbc;
        if (SUCCEEDED(pbs->QueryInterface(IID_PPV_ARG(IDeskBarClient, &pdbc))))
        {
            pdbc->UIActivateDBC(dwState);
            pdbc->Release();
        }
    }
}

//***   PersistStreamLoad, PersistStreamSave
// NOTES
//  we don't insist on finding IPersistStream iface; absence of it is
//  assumed to mean there's nothing to init.
HRESULT PersistStreamLoad(IStream *pstm, IUnknown *punk)
{
    IPersistStream *pps;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
    if (SUCCEEDED(hr))
    {
        hr = pps->Load(pstm);
        pps->Release();
    }
    else
        hr = S_OK;    // n.b. S_OK not hr (don't insist on IID_IPS)
    return hr;
}

HRESULT PersistStreamSave(IStream *pstm, BOOL fClearDirty, IUnknown *punk)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        hr = S_OK;// n.b. S_OK not hr (don't insist on IID_IPS)
        IPersistStream *pps;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistStream, &pps))))
        {
            hr = pps->Save(pstm, fClearDirty);
            pps->Release();
        }
    }
    return hr;
}

HRESULT IUnknown_SimulateDrop(IUnknown* punk, IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDropTarget* pdt;
        hr = punk->QueryInterface(IID_PPV_ARG(IDropTarget, &pdt));
        if (SUCCEEDED(hr)) 
        {
            hr = pdt->DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
            if (*pdwEffect) 
            {
                hr = pdt->Drop(pdtobj, grfKeyState, pt, pdwEffect);
            } 
            else 
            {
                pdt->DragLeave();
            }
            pdt->Release();
        }
    }

    return hr;
} 

LRESULT BandSite_OnMarshallBS(WPARAM wParam, LPARAM lParam)
{
    GUID *riid = (GUID *) wParam;
    IStream *pstm = NULL;

    // paired w/ matching Unmarshal in shdocvw (TM_MARSHALBS)
    HRESULT hr = CoMarshalInterThreadInterfaceInStream(*riid, c_tray._ptbs, &pstm);
    ASSERT(SUCCEEDED(hr));

    return (LRESULT) pstm;
}

IStream *GetDesktopViewStream(DWORD grfMode, LPCTSTR pszName)
{
    HKEY hkStreams;

    ASSERT(g_hkeyExplorer);

    if (RegCreateKey(g_hkeyExplorer, TEXT("Streams"), &hkStreams) == ERROR_SUCCESS)
    {
        IStream *pstm = OpenRegStream(hkStreams, TEXT("Desktop"), pszName, grfMode);
        RegCloseKey(hkStreams);
        return pstm;
    }
    return NULL;
}


BOOL Reg_GetString(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPTSTR psz, DWORD cb)
{
    BOOL fRet = FALSE;
    if (!g_fCleanBoot)
    {
        fRet = ERROR_SUCCESS == SHGetValue(hkey, pszSubKey, pszValue, NULL, psz, &cb);
    }
    return fRet;
}


void BandSite_Load()
{
    CTrayBandSite* ptbs = IUnknownToCTrayBandSite(c_tray._ptbs);
    HRESULT hr = E_FAIL;
    
    // 1st, try persisted state
    IStream *pstm = GetDesktopViewStream(STGM_READ, c_szTaskbar);
    if (pstm)
    {
        hr = PersistStreamLoad(pstm, (IBandSite*)ptbs);
        pstm->Release();
    }

    // 2nd, if there is none (or if version mismatch or other failure),
    // try settings from setup
    if (FAILED(hr))
    {
        LPTSTR pszValue;
        if (IsOS(OS_PERSONAL) || IsOS(OS_PROFESSIONAL) || SHRestricted(REST_CLASSICSHELL))
        {
            // use the no-quick-launch stream
            pszValue = TEXT("Default Taskbar (Personal)");
        }
        else
        {
            pszValue = TEXT("Default Taskbar");
        }

        // n.b. HKLM not HKCU
        // like GetDesktopViewStream but for HKLM
        pstm = OpenRegStream(HKEY_LOCAL_MACHINE,
            REGSTR_PATH_EXPLORER TEXT("\\Streams\\Desktop"),
            pszValue, STGM_READ);

        if (pstm)
        {
            hr = PersistStreamLoad(pstm, (IBandSite *)ptbs);
            pstm->Release();
        }
    }

    // o.w., throw up our hands and force some hard-coded defaults
    // this is needed for a) unexpected failures; b) debug bootstrap;
    int iCount = 0;
    DWORD dwBandID;
    if (FAILED(hr) || FAILED(BandSite_FindBand(ptbs, CLSID_TaskBand, CLSID_NULL, NULL, &iCount, &dwBandID)))
    {
        //
        // note that for the CheckBands case, we're assuming that
        // a) AddBands adds only the missing guys (for now there's
        // only 1 [TaskBand] so we're ok); and b) AddBands doesn't
        // create dups if only some are missing (again for now there's
        // only 1 so no pblm)
        ptbs->_AddRequiredBands();
    }

    hr = BandSite_FindBand(ptbs, CLSID_TaskBand, CLSID_NULL, NULL, &iCount, &dwBandID);
    while ((iCount > 1) && SUCCEEDED(hr))
    {
        ptbs->RemoveBand(dwBandID);
        hr = BandSite_FindBand(ptbs, CLSID_TaskBand, CLSID_NULL, NULL, &iCount, &dwBandID);
    }

    // And one more: this is needed for the TipBand deskband for the TabletPC.
    iCount = 0;
    if (FAILED(hr) || FAILED(BandSite_FindBand(ptbs, CLSID_TipBand, CLSID_NULL, NULL, &iCount, &dwBandID)))
    {
        IDeskBand* pdb;
        HRESULT hr = CoCreateInstance(CLSID_TipBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDeskBand, &pdb));
        if (SUCCEEDED(hr))
        {
            hr = ptbs->AddBand(pdb);
            pdb->Release();
        }
    } 
    hr = BandSite_FindBand(ptbs, CLSID_TipBand, CLSID_NULL, NULL, &iCount, &dwBandID);
    while ((iCount > 1) && SUCCEEDED(hr))
    {
        ptbs->RemoveBand(dwBandID);
        hr = BandSite_FindBand(ptbs, CLSID_TipBand, CLSID_NULL, NULL, &iCount, &dwBandID);
    }

    ptbs->SetLoaded(TRUE);
}

HRESULT CTrayBandSiteService_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk)
{
    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    if (c_tray._ptbs)
    {
        *ppunk = c_tray._ptbs;
        c_tray._ptbs->AddRef();
        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\bandsite.h ===
#include "tray.h"

#ifndef _bandsite_h
#define _bandsite_h

void BandSite_HandleDelayBootStuff(IUnknown *punk);
BOOL BandSite_HandleMessage(IUnknown *punk, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
void BandSite_SetMode(IUnknown *punk, DWORD dwMode);
void BandSite_Update(IUnknown *punk);
void BandSite_UIActivateDBC(IUnknown *punk, DWORD dwState);
void BandSite_HandleMenuCommand(IUnknown* punk, UINT idCmd);
HRESULT BandSite_AddMenus(IUnknown* punk, HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast);
void BandSite_Load();
HRESULT BandSite_SetWindowTheme(IBandSite* pbs, LPWSTR pwzTheme);
HRESULT BandSite_FindBand(IBandSite* pbs, REFCLSID rclsid, REFIID riid, void **ppv, int* piCount, DWORD* pdwBandID);
HRESULT BandSite_TestBandCLSID(IBandSite *pbs, DWORD idBand, REFIID riid);

HRESULT IUnknown_SimulateDrop(IUnknown* punk, IDataObject* pdtobj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\debug.cpp ===
#include "cabinet.h"
#include "rcids.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "explorer"
#define SZ_MODULE           "EXPLORER"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\dlg.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dlg.rc
//
#define DLG_TRAY_OPTIONS                6
#define DLG_NOTIFY                      7
#define DLG_STARTMENU_CONFIG            9
#define ICO_STARTMENU                   107
#define ICO_DOCMENU                     108
#define DLG_START                       205
#define IDC_GROUPBOX                    300
#define IDC_NO_HELP_1                   650
#define IDC_NO_HELP_2                   651
#define IDC_NO_HELP_3                   652
#define IDC_NO_HELP_4                   653
#define IDC_NOTIFY_OFF                  1000
#define IDS_NOTIFYNAME                  1000
#define IDC_NOTIFYMAN                   1000
#define IDB_RESTORE                     1001
#define IDS_BEHAVIOR                    1001
#define IDS_AUTOMATIC                   1002
#define IDS_HIDDEN                      1003
#define IDS_VISIBLE                     1004
#define IDS_NOTIFY_FIRST                IDS_AUTOMATIC 
#define IDS_NOTIFY_LAST                 (IDS_VISIBLE + 1)
#define IDC_NOTIFY_ITEMS                1005
#define IDC_COMBO_ACTION                1006
#define IDC_CUSTOMIZE                   1007
#define IDC_TRAYOPTONTOP                1101
#define IDC_TRAYOPTAUTOHIDE             1102
#define IDC_TRAYOPTSHOWCLOCK            1103
#define IDC_GROUPITEMS                  1104
#define IDC_ENABLEMOVERESIZE            1105
#define IDC_LOCKTASKBAR                 1105
#define IDC_STATIC_NOTIFY               1106
#define IDC_QUICKLAUNCH                 1107

#define IDC_STARTMENUSETTINGS           1123
#define IDC_RESORT                      1124
#define IDC_KILLDOCUMENTS               1125
#define IDC_ADDSHORTCUT                 1126
#define IDC_DELSHORTCUT                 1127
#define IDC_EXPLOREMENUS                1128
#define IDC_OLDSTARTCUSTOMIZE           1130
#define IDC_NEWSTARTCUSTOMIZE           1131
#define IDC_NEWSCHOOL                   1132
#define IDC_OLDSCHOOL                   1133
#define IDC_STARTMENUPREVIEW            1134
#define IDC_NEWSCHOOLDESCRIPTION        1135

#define DLG_PAGE_SMGENERAL              1135
#define DLG_PAGE_SMADVANCED             1036

#define IDC_SPCUST_ICONSMALL            1300
#define IDC_SPCUST_ICONLARGE            1301
#define IDC_SPCUST_LARGE                1302
#define IDC_SPCUST_SMALL                1303
#define IDC_SPCUST_MINPROGS             1304
#define IDC_SPCUST_MINPROGS_ARROW       1305
#define IDC_SPCUST_HOVEROPEN            1306
// ------- UNUSED --------------------  1307
#define IDC_SPCUST_RECENT               1308
#define IDB_SPCUST_CLEARDOCS            1309
#define IDB_SPCUST_CLEARPROG            1310
#define IDS_SPCUST_TITLE                1311
#define IDC_SPCUST_RECENT_TEXT          1312
#define IDC_SPCUST_RECENT_GROUPBOX      1313
#define IDC_SPCUST_INTERNET             1320
#define IDC_SPCUST_INTERNETCB           1321
#define IDC_SPCUST_EMAIL                1322
#define IDC_SPCUST_EMAILCB              1323
// ------- UNUSED --------------------  1324
// ------- UNUSED --------------------  1325
#define IDC_SPCUST_NOTIFYNEW            1326

#define IDC_NOTIFY_TEXT                 1400
#define IDC_NOTIFY_TEXT2                1401
#define IDB_NOTIFY_RESTOREDEFAULTS	1402
#define IDS_NOTIFY_CURRENTITEMS         1403
#define IDS_NOTIFY_PASTITEMS            1404

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        207
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\classfac.cpp ===
#include "cabinet.h"

///////////////////////////////////////////////////////////////////////////////////////
//
// class factory for explorer.exe
//
// These objects do not exist in the registry but rather are registered dynamically at
// runtime.  Since ClassFactory_Start is called on the the tray's thread, all objects
// will be registered on that thread.
//
///////////////////////////////////////////////////////////////////////////////////////

typedef HRESULT (*LPFNCREATEOBJINSTANCE)(IUnknown* pUnkOuter, IUnknown** ppunk);

class CDynamicClassFactory : public IClassFactory
{                                                                      
public:                                                                
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
    {
        static const QITAB qit[] =
        {
            QITABENT(CDynamicClassFactory, IClassFactory),
            { 0 },
        };

        return QISearch(this, qit, riid, ppv);
    }

    STDMETHODIMP_(ULONG) AddRef() { return ++_cRef; }

    STDMETHODIMP_(ULONG) Release()
    {
        if (--_cRef > 0)
        {
            return _cRef;
        }
        delete this;
        return 0;
    }

    // *** IClassFactory ***
    STDMETHODIMP CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
    {
        *ppv = NULL;

        IUnknown *punk;
        HRESULT hr = _pfnCreate(punkOuter, &punk);
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        return hr;
    }

    STDMETHODIMP LockServer(BOOL) { return S_OK; }

    // *** misc public methods ***
    HRESULT Register()
    {
        return CoRegisterClassObject(*_pclsid, this, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                            REGCLS_MULTIPLEUSE, &_dwClassObject);
    }

    HRESULT Revoke()
    {
        HRESULT hr = CoRevokeClassObject(_dwClassObject);
        _dwClassObject = 0;
        return hr;
    }

    CDynamicClassFactory(CLSID const* pclsid, LPFNCREATEOBJINSTANCE pfnCreate) : _pclsid(pclsid),
                                                                    _pfnCreate(pfnCreate), _cRef(1) {}


private:

    CLSID const* _pclsid;
    LPFNCREATEOBJINSTANCE _pfnCreate;
    DWORD _dwClassObject;
    ULONG _cRef;
};

HRESULT CTaskBand_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk);
HRESULT CTrayBandSiteService_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk);
HRESULT CTrayNotifyStub_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk);

static const struct
{
    CLSID const* pclsid;
    LPFNCREATEOBJINSTANCE pfnCreate;
}
c_ClassParams[] =
{
    { &CLSID_TaskBand,            CTaskBand_CreateInstance },
    { &CLSID_TrayBandSiteService, CTrayBandSiteService_CreateInstance },
    { &CLSID_TrayNotify,          CTrayNotifyStub_CreateInstance },
};

CDynamicClassFactory* g_rgpcf[ARRAYSIZE(c_ClassParams)] = {0};


void ClassFactory_Start()
{
    for (int i = 0; i < ARRAYSIZE(c_ClassParams); i++)
    {
        g_rgpcf[i] = new CDynamicClassFactory(c_ClassParams[i].pclsid, c_ClassParams[i].pfnCreate);
        if (g_rgpcf[i])
        {
            g_rgpcf[i]->Register();
        }
    }
}

void ClassFactory_Stop()
{
    for (int i = 0; i < ARRAYSIZE(c_ClassParams); i++)
    {
        if (g_rgpcf[i])
        {
            g_rgpcf[i]->Revoke();

            g_rgpcf[i]->Release();
            g_rgpcf[i] = NULL;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\cabinet.h ===
#ifndef _CABINET_H
#define _CABINET_H

#include <w4warn.h>
/*
 *   Level 4 warnings to be turned on.
 *   Do not disable any more level 4 warnings.
 */
#pragma warning(disable:4127)    // conditional expression is constant
#pragma warning(disable:4189)    // 'fIoctlSuccess' : local variable is initialized but not referenced
#pragma warning(disable:4201)    // nonstandard extension used : nameless struct/union
#pragma warning(disable:4245)    // conversion signed/unsigned mismatch
#pragma warning(disable:4509)    // nonstandard extension used: 'GetUserAssist' uses SEH and 'debug_crit' has destructor
#pragma warning(disable:4701)    // local variable 'hfontOld' may be used without having been initialized
#pragma warning(disable:4706)    // assignment within conditional expression
#pragma warning(disable:4328)    // indirection alignment of formal parameter 1(4) is greater than the actual argument alignment (1)


#define _WINMM_ // for DECLSPEC_IMPORT

#define STRICT
#define OEMRESOURCE

#define OVERRIDE_SHLWAPI_PATH_FUNCTIONS     // see comment in shsemip.h

#ifdef WINNT
#include <nt.h>         // Some of the NT specific code calls Rtl functions
#include <ntrtl.h>      // which requires all of these header files...
#include <nturtl.h>
#endif

#include <windows.h>
#include <commctrl.h>
#include <shfusion.h>
#include <msginaexports.h>

// if you include atlstuff.h, you don't get windowsx.h.  so we define needed functions here
__inline HBRUSH SelectBrush(HDC hdc, HBRUSH hbr) { return (HBRUSH)SelectObject(hdc, (HGDIOBJ)(HBRUSH)hbr); }
__inline HFONT SelectFont(HDC hdc, HFONT hfont) { return (HFONT)SelectObject(hdc, (HGDIOBJ)(HFONT)hfont); }
__inline HBITMAP SelectBitmap(HDC hdc, HBITMAP hbm)  { return (HBITMAP)SelectObject(hdc, (HGDIOBJ)(HBITMAP)hbm); }
__inline WNDPROC SubclassWindow(HWND hwnd, WNDPROC lpfn) { return (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LPARAM)lpfn); }

#include <windowsx.h>

#include <ole2.h>
#include <wininet.h>
#include <shlobj.h>     // Includes <fcext.h>
#include <shsemip.h>
#include <shellapi.h>
#include <cpl.h>
#include <ddeml.h>
#include <cfgmgr32.h>

#ifdef UNICODE
#define CP_WINNATURAL   CP_WINUNICODE
#else
#define CP_WINNATURAL   CP_WINANSI
#endif

#define DISALLOW_Assert
#include <debug.h>          // our version of Assert etc.
#include <port32.h>
#include <heapaloc.h>
#include <shellp.h>
#include <ccstock.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include "dbt.h"
#include "trayp.h"
#include <shdocvw.h>
#include <uxtheme.h>
#include <tmschema.h>
#include <runonce.h>

#include "shguidp.h"
#include "ieguidp.h"
#include "shdguid.h"

#include "uastrfnc.h"

#include <desktopp.h>

//
// Trace/dump/break flags specific to explorer.
//   (Standard flags defined in shellp.h)
//

// Trace flags
#define TF_DDE              0x00000100      // DDE traces
#define TF_TARGETFRAME      0x00000200      // Target frame
#define TF_TRAYDOCK         0x00000400      // Tray dock
#define TF_TRAY             0x00000800      // Tray 

// "Olde names"
#define DM_DDETRACE         TF_DDE
#define DM_TARGETFRAME      TF_TARGETFRAME
#define DM_TRAYDOCK         TF_TRAYDOCK

// Function trace flags
#define FTF_DDE             0x00000001      // DDE functions
#define FTF_TARGETFRAME     0x00000002      // Target frame methods

// Dump flags
#define DF_DDE              0x00000001      // DDE package
#define DF_DELAYLOADDLL     0x00000002      // Delay load

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//---------------------------------------------------------------------------
// Globals
extern HINSTANCE hinstCabinet;  // Instance handle of the app.

extern HWND v_hwndDesktop;

extern HKEY g_hkeyExplorer;

//
// Is Mirroring APIs enabled (BiDi Memphis and NT5 only)
//
extern BOOL g_bMirroredOS;

// Global System metrics.  the desktop wnd proc will be responsible
// for watching wininichanges and keeping these up to date.

extern int g_fCleanBoot;
extern BOOL g_fFakeShutdown;
extern int g_fDragFullWindows;
extern int g_cxEdge;
extern int g_cyEdge;
extern int g_cySize;
extern int g_cyTabSpace;
extern int g_cxTabSpace;
extern int g_cxBorder;
extern int g_cyBorder;
extern int g_cxPrimaryDisplay;
extern int g_cyPrimaryDisplay;
extern int g_cxDlgFrame;
extern int g_cyDlgFrame;
extern int g_cxFrame;
extern int g_cyFrame;
extern int g_cxMinimized;
extern int g_cxVScroll;
extern int g_cyHScroll;
extern BOOL g_fNoDesktop;
extern UINT g_uDoubleClick;


extern HWND v_hwndTray;
extern HWND v_hwndStartPane;
extern BOOL g_fDesktopRaised;

extern const WCHAR c_wzTaskbarTheme[];

// the order of these is IMPORTANT for move-tracking and profile stuff
// also for the STUCK_HORIZONTAL macro
#define STICK_FIRST     ABE_LEFT
#define STICK_LEFT      ABE_LEFT
#define STICK_TOP       ABE_TOP
#define STICK_RIGHT     ABE_RIGHT
#define STICK_BOTTOM    ABE_BOTTOM
#define STICK_LAST      ABE_BOTTOM
#define STICK_MAX       ABE_MAX
#define STUCK_HORIZONTAL(x)     (x & 0x1)

#if STUCK_HORIZONTAL(STICK_LEFT) || STUCK_HORIZONTAL(STICK_RIGHT) || \
   !STUCK_HORIZONTAL(STICK_TOP)  || !STUCK_HORIZONTAL(STICK_BOTTOM)
#error Invalid STICK_* constants
#endif

#define IsValidSTUCKPLACE(stick) IsInRange(stick, STICK_FIRST, STICK_LAST)

// initcab.cpp
HKEY GetSessionKey(REGSAM samDesired);
void RunStartupApps();
void WriteCleanShutdown(DWORD dwValue);


//
// Debug helper functions
//

void InvokeURLDebugDlg(HWND hwnd);

void Cabinet_InitGlobalMetrics(WPARAM, LPTSTR);


#define REGSTR_PATH_ADVANCED        REGSTR_PATH_EXPLORER TEXT("\\Advanced")
#define REGSTR_PATH_SMADVANCED      REGSTR_PATH_EXPLORER TEXT("\\StartMenu")
#define REGSTR_PATH_RUN_POLICY      REGSTR_PATH_POLICIES TEXT("\\Explorer\\Run")
#define REGSTR_EXPLORER_ADVANCED    REGSTR_PATH_ADVANCED
#define REGSTR_POLICIES_EXPLORER    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer")

#undef WinHelp
#define WinHelp SHWinHelp


#ifdef __cplusplus
};       /* End of extern "C" { */


#endif // __cplusplus

#define PERF_ENABLESETMARK
#ifdef PERF_ENABLESETMARK
void DoSetMark(LPCSTR pszMark, ULONG cbSz);
#define PERFSETMARK(text)   DoSetMark(text, sizeof(text))
#else
#define PERFSETMARK(text)
#endif  // PERF_ENABLESETMARK


#endif  // _CABINET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\dllload.c ===
#include "cabinet.h"
#include <desktray.h>
#include "uemapp.h"

#pragma warning(disable:4229)  // No warnings when modifiers used on data

// Delay loading mechanism.  This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID
//

// These macros produce code that looks like
#if 0

BOOL GetOpenFileNameA(LPOPENFILENAME pof)
{
    static BOOL (*pfnGetOpenFileNameA)(LPOPENFILENAME pof);

    if (ENSURE_LOADED(g_hinstCOMDLG32, "COMDLG32.DLL"))
    {
        if (pfnGetOpenFileNameA == NULL)
            pfnGetOpenFileNameA = (BOOL (*)(LPOPENFILENAME))GetProcAddress(g_hinstCOMDLG32, "GetOpenFileNameA");

        if (pfnGetOpenFileNameA)
            return pfnGetOpenFileNameA(pof);
    }
    return -1;
}
#endif

/**********************************************************************/


#ifdef DEBUG

void _DumpLoading(LPTSTR pszDLL, LPTSTR pszFunc)
{
    if (g_dwDumpFlags & DF_DELAYLOADDLL)
    {
        TraceMsg(TF_ALWAYS, "DLLLOAD: Loading %s for the first time for %s",
                 pszDLL, pszFunc);
    }
}
#define ENSURE_LOADED(_hinst, _dll, pszfn)         (_hinst ? _hinst : (_DumpLoading(TEXT(#_dll), pszfn), _hinst = LoadLibrary(TEXT(#_dll))))

#else

#define ENSURE_LOADED(_hinst, _dll, pszfn)         (_hinst ? _hinst : (_hinst = LoadLibrary(TEXT(#_dll))))

#endif  // DEBUG


#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, TEXT(#_fn)))   \
    {                                   \
        /*ASSERT_MSG((BOOL)_hinst, "LoadLibrary failed on " ## #_dll);*/ \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        /*ASSERT_MSG(NULL != _pfn##_fn, "GetProcAddress failed on " ## #_fn);*/ \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_BOOL(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, BOOL, _fn, _args, _nargs, FALSE)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, TEXT(#_fn)))   \
    {                                   \
        /*AssertMsg((BOOL)_hinst, "LoadLibrary failed on " ## #_dll);*/ \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        /*AssertMsg(NULL != _pfn##_fn, "GetProcAddress failed on " ## #_fn);*/ \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }


//
// For private entrypoints exported by ordinal.
//

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, TEXT("(ordinal ") TEXT(#_ord) TEXT(")")))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR) _ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)


#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll, TEXT("(ordinal ") TEXT(#_ord) TEXT(")")))   \
    {                                   \
        TraceMsg(TF_ERROR, "LoadLibrary failed on " ## #_dll); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, (LPSTR)_ord); \
                                        \
        /* GetProcAddress always returns non-NULL, even for bad ordinals.   \
           But do the check anyways...  */                                  \
                                        \
        if (_pfn##_fn == NULL)          \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
}

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\explorer.inc ===
#
#  Common settings for explorer
#

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DVSTF
!endif

!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL=1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES= $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif

CCSHELL_DIR     = $(PROJECT_ROOT)

USE_STATIC_ATL  = 1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

C_DEFINES       = $(C_DEFINES) -D_USRDLL

MSC_WARNING_LEVEL=/W4

#
# Need hydra headers only on NT
#
!if !defined(TARGET_WIN95)
INCLUDES        = $(INCLUDES);$(TERMSRV_INC_PATH)
!endif

# A bad application loads Explorer.exe as a library and this fails
# if relocations are not present. So for compat reasons we want fixups.
# App Name: Seagate Backup
LINKER_FLAGS    = $(LINKER_FLAGS) -FIXED:NO

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

!if $(FREEBUILD)
# on retail builds we don't want to stack fault, so we reserve 56k of stack
LINKER_STACKCOMMITSIZE = 57344
!else
# on chk builds, we default to 36k so that we can find stack pigs and elimnate them
LINKER_STACKCOMMITSIZE = 36864
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\libx.cpp ===
//***   libx.cpp -- 'source library' inclusions
// DESCRIPTION
//  there are some things that we share in source (rather than .obj or .dll)
// form.  this file builds them in the current directory.

#include "cabinet.h"
#include <shguidp.h>

#include "..\inc\uassist.cpp"       // 'safe' thunks and cache
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\initcab.cpp ===
#include "cabinet.h"
#include "rcids.h"

#include <regstr.h>
#include "startmnu.h"
#include <shdguid.h>    // for IID_IShellService
#include <shlguid.h>
#include <desktray.h>
#include <wininet.h>
#include <trayp.h>
#include "tray.h"
#include "util.h"
#include "atlstuff.h"
#include <strsafe.h>
#include <runonce.c>    // shared runonce processing code
#include <dsrole.h>  // DsRoleGetPrimaryDomainInformation, DsRoleFreeMemory

// global so that it is shared between TS sessions
#define SZ_SCMCREATEDEVENT_NT5  TEXT("Global\\ScmCreatedEvent")
#define SZ_WINDOWMETRICS        TEXT("Control Panel\\Desktop\\WindowMetrics")
#define SZ_APPLIEDDPI           TEXT("AppliedDPI")
#define SZ_CONTROLPANEL         TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel")
#define SZ_ORIGINALDPI          TEXT("OriginalDPI")

// exports from shdocvw.dll
STDAPI_(void) RunInstallUninstallStubs(void);

int ExplorerWinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPTSTR pszCmdLine, int nCmdShow);

BOOL _ShouldFixResolution(void);

#ifdef PERF_ENABLESETMARK
#include <wmistr.h>
#include <ntwmi.h>  // PWMI_SET_MARK_INFORMATION is defined in ntwmi.h
#include <wmiumkm.h>
#define NTPERF
#include <ntperf.h>

void DoSetMark(LPCSTR pszMark, ULONG cbSz)
{
    PWMI_SET_MARK_INFORMATION MarkInfo;
    HANDLE hTemp;
    ULONG cbBufferSize;
    ULONG cbReturnSize;

    cbBufferSize = FIELD_OFFSET(WMI_SET_MARK_INFORMATION, Mark) + cbSz;

    MarkInfo = (PWMI_SET_MARK_INFORMATION) LocalAlloc(LPTR, cbBufferSize);

    // Failed to init, no big deal
    if (MarkInfo == NULL)
        return;

    BYTE *pMarkBuffer = (BYTE *) (&MarkInfo->Mark[0]);

    memcpy(pMarkBuffer, pszMark, cbSz);

    // WMI_SET_MARK_WITH_FLUSH will flush the working set when setting the mark
    MarkInfo->Flag = PerformanceMmInfoMark;

    hTemp = CreateFile(WMIDataDeviceName,
                           GENERIC_READ | GENERIC_WRITE,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL |
                           FILE_FLAG_OVERLAPPED,
                           NULL);

    if (hTemp != INVALID_HANDLE_VALUE)
    {
        // here's the piece that actually puts the mark in the buffer
        BOOL fIoctlSuccess = DeviceIoControl(hTemp,
                                       IOCTL_WMI_SET_MARK,
                                       MarkInfo,
                                       cbBufferSize,
                                       NULL,
                                       0,
                                       &cbReturnSize,
                                       NULL);

        CloseHandle(hTemp);
    }
    LocalFree(MarkInfo);
}
#endif  // PERF_ENABLESETMARK


//Do not change this stock5.lib use this as a BOOL not a bit.
BOOL g_bMirroredOS = FALSE;

HINSTANCE hinstCabinet = 0;

CRITICAL_SECTION g_csDll = { 0 };

HKEY g_hkeyExplorer = NULL;

#define MAGIC_FAULT_TIME    (1000 * 60 * 5)
#define MAGIC_FAULT_LIMIT   (2)
BOOL g_fLogonCycle = FALSE;
BOOL g_fCleanShutdown = TRUE;
BOOL g_fExitExplorer = TRUE; // set to FALSE on WM_ENDSESSION shutdown case
BOOL g_fEndSession = FALSE;             // set to TRUE if we rx a WM_ENDSESSION during RunOnce etc
BOOL g_fFakeShutdown = FALSE;           // set to TRUE if we do Ctrl+Alt+Shift+Cancel shutdown

DWORD g_dwStopWatchMode;                // to minimize impact of perf logging on retail



// helper function to check to see if a given regkey is has any subkeys
BOOL SHKeyHasSubkeys(HKEY hk, LPCTSTR pszSubKey)
{
    HKEY hkSub;
    BOOL bHasSubKeys = FALSE;

    // need to open this with KEY_QUERY_VALUE or else RegQueryInfoKey will fail
    if (RegOpenKeyEx(hk,
                     pszSubKey,
                     0,
                     KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                     &hkSub) == ERROR_SUCCESS)
    {
        DWORD dwSubKeys;

        if (RegQueryInfoKey(hkSub, NULL, NULL, NULL, &dwSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
        {
            bHasSubKeys = (dwSubKeys != 0);
        }

        RegCloseKey(hkSub);
    }

    return bHasSubKeys;
}


#ifdef _WIN64
// helper function to check to see if a given regkey is has values (ignores the default value)
BOOL SHKeyHasValues(HKEY hk, LPCTSTR pszSubKey)
{
    HKEY hkSub;
    BOOL bHasValues = FALSE;

    if (RegOpenKeyEx(hk,
                     pszSubKey,
                     0,
                     KEY_QUERY_VALUE,
                     &hkSub) == ERROR_SUCCESS)
    {
        DWORD dwValues;
        DWORD dwSubKeys;

        if (RegQueryInfoKey(hkSub, NULL, NULL, NULL, &dwSubKeys, NULL, NULL, &dwValues, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
        {
            bHasValues = (dwValues != 0);
        }

        RegCloseKey(hkSub);
    }

    return bHasValues;
}
#endif // _WIN64


void CreateShellDirectories()
{
    TCHAR szPath[MAX_PATH];

    //  Create the shell directories if they don't exist
    SHGetSpecialFolderPath(NULL, szPath, CSIDL_DESKTOPDIRECTORY, TRUE);
    SHGetSpecialFolderPath(NULL, szPath, CSIDL_PROGRAMS, TRUE);
    SHGetSpecialFolderPath(NULL, szPath, CSIDL_STARTMENU, TRUE);
    SHGetSpecialFolderPath(NULL, szPath, CSIDL_STARTUP, TRUE);
    SHGetSpecialFolderPath(NULL, szPath, CSIDL_RECENT, TRUE);
    SHGetSpecialFolderPath(NULL, szPath, CSIDL_FAVORITES, TRUE);
}

// returns:
//      TRUE if the user wants to abort the startup sequence
//      FALSE keep going
//
// note: this is a switch, once on it will return TRUE to all
// calls so these keys don't need to be pressed the whole time
BOOL AbortStartup()
{
    static BOOL bAborted = FALSE;       // static so it sticks!

    if (bAborted)
    {
        return TRUE;    // don't do funky startup stuff
    }
    else 
    {
        bAborted = (g_fCleanBoot || ((GetKeyState(VK_CONTROL) < 0) || (GetKeyState(VK_SHIFT) < 0)));
        return bAborted;
    }
}

BOOL ExecStartupEnumProc(IShellFolder *psf, LPITEMIDLIST pidlItem)
{
    IContextMenu *pcm;
    HRESULT hr = psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&pidlItem, IID_PPV_ARG_NULL(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        HMENU hmenu = CreatePopupMenu();
        if (hmenu)
        {
            pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, CMF_DEFAULTONLY);
            INT idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0);
            if (idCmd)
            {
                CMINVOKECOMMANDINFOEX ici = {0};

                ici.cbSize = sizeof(ici);
                ici.fMask = CMIC_MASK_FLAG_NO_UI;
                ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - CONTEXTMENU_IDCMD_FIRST);
                ici.nShow = SW_NORMAL;

                if (FAILED(pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici)))
                {
                    c_tray.LogFailedStartupApp();
                }
            }
            DestroyMenu(hmenu);
        }
        pcm->Release();
    }

    return !AbortStartup();
}

typedef BOOL (*PFNENUMFOLDERCALLBACK)(IShellFolder *psf, LPITEMIDLIST pidlItem);

void EnumFolder(LPITEMIDLIST pidlFolder, DWORD grfFlags, PFNENUMFOLDERCALLBACK pfn)
{
    IShellFolder *psf;
    if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf))))
    {
        IEnumIDList *penum;
        if (S_OK == psf->EnumObjects(NULL, grfFlags, &penum))
        {
            LPITEMIDLIST pidl;
            ULONG celt;
            while (S_OK == penum->Next(1, &pidl, &celt))
            {
                BOOL bRet = pfn(psf, pidl);

                SHFree(pidl);

                if (!bRet)
                    break;
            }
            penum->Release();
        }
        psf->Release();
    }
}

const UINT c_rgStartupFolders[] = {
    CSIDL_COMMON_STARTUP,
    CSIDL_COMMON_ALTSTARTUP,    // non-localized "Common StartUp" group if exists.
    CSIDL_STARTUP,
    CSIDL_ALTSTARTUP            // non-localized "StartUp" group if exists.
};

void _ExecuteStartupPrograms()
{
    if (!AbortStartup())
    {
        for (int i = 0; i < ARRAYSIZE(c_rgStartupFolders); i++)
        {
            LPITEMIDLIST pidlStartup = SHCloneSpecialIDList(NULL, c_rgStartupFolders[i], FALSE);
            if (pidlStartup)
            {
                EnumFolder(pidlStartup, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, ExecStartupEnumProc);
                ILFree(pidlStartup);
            }
        }
    }
}


// helper function for parsing the run= stuff
BOOL ExecuteOldEqualsLine(LPTSTR pszCmdLine, int nCmdShow)
{
    BOOL bRet = FALSE;
    TCHAR szWindowsDir[MAX_PATH];
    // Load and Run lines are done relative to windows directory.
    if (GetWindowsDirectory(szWindowsDir, ARRAYSIZE(szWindowsDir)))
    {
        BOOL bFinished = FALSE;
        while (!bFinished && !AbortStartup())
        {
            LPTSTR pEnd = pszCmdLine;

            // NOTE: I am guessing from the code below that you can have multiple entries seperated 
            //       by a ' '  or a ',' and we will exec all of them.
            while ((*pEnd) && (*pEnd != TEXT(' ')) && (*pEnd != TEXT(',')))
            {
                pEnd = (LPTSTR)CharNext(pEnd);
            }
            
            if (*pEnd == 0)
            {
                bFinished = TRUE;
            }
            else
            {
                *pEnd = 0;
            }

            if (lstrlen(pszCmdLine) != 0)
            {
                SHELLEXECUTEINFO ei = {0};

                ei.cbSize          = sizeof(ei);
                ei.lpFile          = pszCmdLine;
                ei.lpDirectory     = szWindowsDir;
                ei.nShow           = nCmdShow;

                if (!ShellExecuteEx(&ei))
                {
                    ShellMessageBox(hinstCabinet,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_WINININORUN),
                                    MAKEINTRESOURCE(IDS_DESKTOP),
                                    MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL,
                                    pszCmdLine);
                }
                else
                {
                    bRet = TRUE;
                }
            }
            
            pszCmdLine = pEnd + 1;
        }
    }
    return bRet;
}


// we check for the old "load=" and "run=" from the [Windows] section of the win.ini, which
// is mapped nowadays to HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows
BOOL _ProcessOldRunAndLoadEquals()
{
    BOOL bRet = FALSE;

    // don't do the run= section if are restricted or we are in safemode
    if (!SHRestricted(REST_NOCURRENTUSERRUN) && !g_fCleanBoot)
    {
        HKEY hk;

        if (RegOpenKeyEx(HKEY_CURRENT_USER,
                         TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows"),
                         0,
                         KEY_QUERY_VALUE,
                         &hk) == ERROR_SUCCESS)
        {
            DWORD dwType;
            DWORD cbData;
            TCHAR szBuffer[255];    // max size of load= & run= lines...
            
            // "Load" apps before "Run"ning any.
            cbData = sizeof(szBuffer);
            if ((SHGetValue(hk, NULL, TEXT("Load"), &dwType, (void*)szBuffer, &cbData) == ERROR_SUCCESS) &&
                (dwType == REG_SZ))
            {
                // we want load= to be hidden, so SW_SHOWMINNOACTIVE is needed
                if (ExecuteOldEqualsLine(szBuffer, SW_SHOWMINNOACTIVE))
                {
                    bRet = TRUE;
                }
            }

            cbData = sizeof(szBuffer);
            if ((SHGetValue(hk, NULL, TEXT("Run"), &dwType, (void*)szBuffer, &cbData) == ERROR_SUCCESS) &&
                (dwType == REG_SZ))
            {
                if (ExecuteOldEqualsLine(szBuffer, SW_SHOWNORMAL))
                {
                    bRet = TRUE;
                }
            }

            RegCloseKey(hk);
        }
    }

    return bRet;
}


//---------------------------------------------------------------------------
// Use IERnonce.dll to process RunOnceEx key
//
typedef void (WINAPI *RUNONCEEXPROCESS)(HWND, HINSTANCE, LPSTR, int);

BOOL _ProcessRunOnceEx()
{
    BOOL bRet = FALSE;

    if (SHKeyHasSubkeys(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCEEX))
    {
        PROCESS_INFORMATION pi = {0};
        TCHAR szArgString[MAX_PATH];
        TCHAR szRunDll32[MAX_PATH];
        BOOL fInTSInstallMode = FALSE;

        // See if we are in "Applications Server" mode, if so we need to trigger install mode
        if (IsOS(OS_TERMINALSERVER)) 
        {
            fInTSInstallMode = SHSetTermsrvAppInstallMode(TRUE); 
        }

        // we used to call LoadLibrary("IERNONCE.DLL") and do all of the processing in-proc. Since 
        // ierunonce.dll in turn calls LoadLibrary on whatever is in the registry and those setup dll's
        // can leak handles, we do this all out-of-proc now.

        GetSystemDirectory(szArgString, ARRAYSIZE(szArgString));
        PathAppend(szArgString, TEXT("iernonce.dll"));
        PathQuoteSpaces(szArgString);
        if (SUCCEEDED(StringCchCat(szArgString, ARRAYSIZE(szArgString), TEXT(",RunOnceExProcess"))))
        {
            GetSystemDirectory(szRunDll32, ARRAYSIZE(szRunDll32));
            PathAppend(szRunDll32, TEXT("rundll32.exe"));

            if (CreateProcessWithArgs(szRunDll32, szArgString, NULL, &pi))
            {
                SHProcessMessagesUntilEvent(NULL, pi.hProcess, INFINITE);

                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);

                bRet = TRUE;
            }
        }

        if (fInTSInstallMode)
        {
            SHSetTermsrvAppInstallMode(FALSE);
        } 
    }

#ifdef _WIN64
    //
    // check and see if we need to do 32-bit RunOnceEx processing for wow64
    //
    if (SHKeyHasSubkeys(HKEY_LOCAL_MACHINE, TEXT("Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx")))
    {
        TCHAR szWow64Path[MAX_PATH];

        if (ExpandEnvironmentStrings(TEXT("%SystemRoot%\\SysWOW64"), szWow64Path, ARRAYSIZE(szWow64Path)))
        {
            TCHAR sz32BitRunOnce[MAX_PATH];
            PROCESS_INFORMATION pi = {0};

            if (SUCCEEDED(StringCchPrintf(sz32BitRunOnce, ARRAYSIZE(sz32BitRunOnce), TEXT("%s\\runonce.exe"), szWow64Path)))
            {
                if (CreateProcessWithArgs(sz32BitRunOnce, TEXT("/RunOnceEx6432"), szWow64Path, &pi))
                {
                    // have to wait for the ruonceex processing before we can return
                    SHProcessMessagesUntilEvent(NULL, pi.hProcess, INFINITE);
                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);

                    bRet = TRUE;
                }
            }
        }
    }
#endif // _WIN64

    return bRet;
}


BOOL _ProcessRunOnce()
{
    BOOL bRet = FALSE;

    if (!SHRestricted(REST_NOLOCALMACHINERUNONCE))
    {
        bRet = Cabinet_EnumRegApps(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE, RRA_DELETE | RRA_WAIT, ExecuteRegAppEnumProc, 0);

#ifdef _WIN64
        //
        // check and see if we need to do 32-bit RunOnce processing for wow64
        //
        // NOTE: we do not support per-user (HKCU) 6432 runonce
        //
        if (SHKeyHasValues(HKEY_LOCAL_MACHINE, TEXT("Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce")))
        {
            TCHAR szWow64Path[MAX_PATH];

            if (ExpandEnvironmentStrings(TEXT("%SystemRoot%\\SysWOW64"), szWow64Path, ARRAYSIZE(szWow64Path)))
            {
                TCHAR sz32BitRunOnce[MAX_PATH];
                PROCESS_INFORMATION pi = {0};

                if (SUCCEEDED(StringCchPrintf(sz32BitRunOnce, ARRAYSIZE(sz32BitRunOnce), TEXT("%s\\runonce.exe"), szWow64Path)))
                {
                    // NOTE: since the 32-bit and 64-bit registries are different, we don't wait since it should not affect us
                    if (CreateProcessWithArgs(sz32BitRunOnce, TEXT("/RunOnce6432"), szWow64Path, &pi))
                    {
                        CloseHandle(pi.hProcess);
                        CloseHandle(pi.hThread);

                        bRet = TRUE;
                    }
                }
            }
        }
#endif // _WIN64
    }

    return bRet;
}




typedef DWORD (*DsRoleGetPrimaryDomainInfoFunc)(
   LPCWSTR, DSROLE_PRIMARY_DOMAIN_INFO_LEVEL, PBYTE*);

typedef VOID (*DsRoleFreeMemoryFunc)(PVOID);


   
bool
IsDcInUpgradePurgatory()
{
   bool fResult = false;

   HMODULE hNetapi32 = NULL;

   do
   {
      hNetapi32 = ::LoadLibrary(L"netapi32.dll");
      if (!hNetapi32)
      {
         break;
      }

      DsRoleGetPrimaryDomainInfoFunc pDsRoleGetPrimaryDomainInformation =
         (DsRoleGetPrimaryDomainInfoFunc) ::GetProcAddress(
            hNetapi32,
            "DsRoleGetPrimaryDomainInformation");
      if (!pDsRoleGetPrimaryDomainInformation)
      {
         break;
      }

      DsRoleFreeMemoryFunc pDsRoleFreeMemory =
         (DsRoleFreeMemoryFunc) ::GetProcAddress(
            hNetapi32,
            "DsRoleFreeMemory");
      if (!pDsRoleFreeMemory)
      {
         break;
      }
         
      DSROLE_UPGRADE_STATUS_INFO* pInfo = NULL;
      DWORD dwErr =
         pDsRoleGetPrimaryDomainInformation(
            0,
            ::DsRoleUpgradeStatus,
            (PBYTE*) &pInfo);
      if (dwErr != ERROR_SUCCESS || !pInfo)
      {
         break;
      }

      fResult =
            (pInfo->OperationState & DSROLE_UPGRADE_IN_PROGRESS)
         ?  true
         :  false;
         
      pDsRoleFreeMemory(pInfo);

   }
   while (false);

   if (hNetapi32)
   {
      ::FreeLibrary(hNetapi32);
      hNetapi32 = NULL;
   }
   
   return fResult;
}



#define REGTIPS                     REGSTR_PATH_EXPLORER TEXT("\\Tips")
#define SZ_REGKEY_W2K               TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\Welcome")
#define SZ_REGVAL_W2K               TEXT("srvwiz")
#define SZ_REGKEY_SRVWIZ_ROOT       TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\srvWiz")
#define SZ_REGVAL_SRVWIZ_RUN_ALWAYS TEXT("CYSMustRun")
#define SZ_CYS_COMMAND_LINE	      TEXT("cys.exe")
#define SZ_MYS_COMMAND_LINE	      TEXT("mshta.exe")
#define SZ_CYS_COMMAND_LINE_ARGS    TEXT("/explorer")
#define SZ_MYS_COMMAND_LINE_ARGS    TEXT("res://mys.dll/mys.hta /explorer")
#define SZ_REGKEY_MYS_POLICY        TEXT("SOFTWARE\\Policies\\Microsoft\\Windows NT\\CurrentVersion\\MYS")
#define SZ_REGVAL_MYS_DISABLE_SHOW  TEXT("DisableShowAtLogon")
    
// Srvwiz is the Configure Your Server Wizard that runs on srv and ads skus
// returns whether or not the command should be run, and which command to run

bool _ShouldStartCys(OUT PCWSTR* whichCommand, OUT PCWSTR* commandArgs)
{
   ASSERT(whichCommand);
   ASSERT(commandArgs);

   bool result = false;

   do
   {
      if (!whichCommand || !commandArgs)
      {
         // that would be a bug in the caller, so do nothing.
     
         break;
      }

      *whichCommand = 0;
      *commandArgs  = 0;

      // Only run on srv or ads sku
      // NTRAID#NTBUG9-485488-2001/11/02-JeffJon
      // We have to run CYS on DataCenter if and only if the
      // must run key is set

      if (!IsOS(OS_SERVER) && !IsOS(OS_ADVSERVER) && !IsOS(OS_DATACENTER))
      {
         break;
      }

      if (!IsUserAnAdmin())
      {
         break;
      }

      DWORD dwType = 0;
      DWORD dwData = 0;
      DWORD cbSize = sizeof(dwData);
   
      // if the must-run value is present and non-zero, then we need to
      // start the wizard.
      
      if (
         SHGetValue(
            HKEY_LOCAL_MACHINE,
            SZ_REGKEY_SRVWIZ_ROOT,
            SZ_REGVAL_SRVWIZ_RUN_ALWAYS,
            &dwType,
            reinterpret_cast<BYTE*>(&dwData),
            &cbSize) == ERROR_SUCCESS)
      {
         if (dwData)
         {
            result = true;
            *whichCommand = SZ_CYS_COMMAND_LINE;     
            *commandArgs  = SZ_CYS_COMMAND_LINE_ARGS;
            break;
         }
      }

      dwData = 0;
      cbSize = sizeof(dwData);

      // If group policy is set for "Don't show MYS",
      // then don't show MYS regardless of user setting
      if (
         SHGetValue(
            HKEY_LOCAL_MACHINE,
            SZ_REGKEY_MYS_POLICY,
            SZ_REGVAL_MYS_DISABLE_SHOW,
            &dwType,
            reinterpret_cast<BYTE*>(&dwData),
            &cbSize) == ERROR_SUCCESS)
      {
         if (REG_DWORD == dwType && dwData)
         {
            //"Don't show" policy is set, so bail on rest of checks.
            break; 
         }
      }      

      // If this is DataCenter and the must run key was
      // not set then don't run CYS

      if (IsOS(OS_DATACENTER))
      {
         break;
      }

      // If the user's preference is present and zero, then don't show
      // the wizard, else continue with other tests

      cbSize = sizeof(dwData);

      if (
         !SHGetValue(
            HKEY_CURRENT_USER, 
            REGTIPS, 
            TEXT("Show"), 
            NULL, 
            reinterpret_cast<BYTE*>(&dwData), 
            &cbSize))
      {
         if (!dwData)
         {
            break;
         }
      }

      // This is to check an old W2K regkey that was documented in Q220838.
      // If the key exists and is not zero then don't run the wizard

      dwData = 0;
      cbSize = sizeof(dwData);

      if (
         !SHGetValue(
            HKEY_CURRENT_USER,
            SZ_REGKEY_W2K,
            SZ_REGVAL_W2K,
            NULL,
            reinterpret_cast<BYTE*>(&dwData),
            &cbSize))
      {
         if (!dwData)
         {
            break;
         }
      }

      // If the machine was an NT4 PDC now undergoing upgrade, dcpromo will
      // start automatically. So we should not start.

      if (IsDcInUpgradePurgatory())
      {
         break;
      }

      // If the user's preference is absent or non-zero, then we need to
      // start the wizard.

      dwData = 0;
      cbSize = sizeof(dwData);
      
      if (
         SHGetValue(
            HKEY_CURRENT_USER,
            SZ_REGKEY_SRVWIZ_ROOT,
            NULL,
            &dwType,
            reinterpret_cast<BYTE*>(&dwData),
            &cbSize) != ERROR_SUCCESS)
      {
         result = true;
         *whichCommand = SZ_MYS_COMMAND_LINE;
         *commandArgs  = SZ_MYS_COMMAND_LINE_ARGS;
         break;
      }

      if (dwData)
      {
         result = true;
         *whichCommand = SZ_MYS_COMMAND_LINE;
         *commandArgs  = SZ_MYS_COMMAND_LINE_ARGS;
      }
   }
   while (0);

#ifdef DBG
   if (result)
   {
      ASSERT(*whichCommand);
      ASSERT(*commandArgs);
   }
#endif

   return result;
}
         

         
void _RunWelcome()
{
    PCWSTR command     = 0;
    PCWSTR commandArgs = 0;
    
    if (_ShouldStartCys(&command, &commandArgs))
    {
        // NTRAID #94718: The SHGetValue above should be replaced with an SHRestricted call.  The above is a highly non-standard
        // place for this "policy" to live plus it doesn't allow for per machine and per user settings.

        TCHAR szCmdLine[MAX_PATH];
        PROCESS_INFORMATION pi;

        // launch Configure Your Server for system administrators on Win2000 Server and Advanced Server
        GetSystemDirectory(szCmdLine, ARRAYSIZE(szCmdLine));
        PathAppend(szCmdLine, command);

        if (CreateProcessWithArgs(szCmdLine, commandArgs, NULL, &pi))
        {
            // OLE created a secret window for us, so we can't use
            // WaitForSingleObject or we will deadlock
            SHWaitForSendMessageThread(pi.hProcess, INFINITE);
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }

    // Once that's all done, see if the Start Menu needs to auto-open.
    // Don't auto-open if we are going to offer to fix the user's screen
    // resolution, though, because that causes us to cover up the screen
    // resolution fix wizard!  The screen resolution fix wizard will post
    // this message when the user has finished fixing the screen.
    if (!_ShouldFixResolution())
    {
        PostMessage(v_hwndTray, RegisterWindowMessage(TEXT("Welcome Finished")), 0, 0);
    }

}

// On NT, run the TASKMAN= line from the registry
void _AutoRunTaskMan(void)
{
    HKEY hkeyWinLogon;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                     0, KEY_READ, &hkeyWinLogon) == ERROR_SUCCESS)
    {
        TCHAR szBuffer[MAX_PATH];
        DWORD cbBuffer = sizeof(szBuffer);
        if (RegQueryValueEx(hkeyWinLogon, TEXT("Taskman"), 0, NULL, (LPBYTE)szBuffer, &cbBuffer) == ERROR_SUCCESS)
        {
            if (szBuffer[0])
            {
                PROCESS_INFORMATION pi;
                STARTUPINFO startup = {0};
                startup.cb = sizeof(startup);
                startup.wShowWindow = SW_SHOWNORMAL;

                if (CreateProcess(NULL, szBuffer, NULL, NULL, FALSE, 0,
                                  NULL, NULL, &startup, &pi))
                {
                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);
                }
            }
        }
        RegCloseKey(hkeyWinLogon);
    }
}


// try to create this by sending a wm_command directly to
// the desktop.
BOOL MyCreateFromDesktop(HINSTANCE hInst, LPCTSTR pszCmdLine, int nCmdShow)
{
    NEWFOLDERINFO fi = {0};
    BOOL bRet = FALSE;

    fi.nShow = nCmdShow;

    //  since we have browseui fill out the fi, 
    //  SHExplorerParseCmdLine() does a GetCommandLine()
    if (SHExplorerParseCmdLine(&fi))
        bRet = SHCreateFromDesktop(&fi);

    //  should we also have it cleanup after itself??

    //  SHExplorerParseCmdLine() can allocate this buffer...
    if (fi.uFlags & COF_PARSEPATH)
        LocalFree(fi.pszPath);
        
    ILFree(fi.pidl);
    ILFree(fi.pidlRoot);

    return bRet;
}

BOOL g_fDragFullWindows=FALSE;
int g_cxEdge=0;
int g_cyEdge=0;
int g_cySize=0;
int g_cxTabSpace=0;
int g_cyTabSpace=0;
int g_cxBorder=0;
int g_cyBorder=0;
int g_cxPrimaryDisplay=0;
int g_cyPrimaryDisplay=0;
int g_cxDlgFrame=0;
int g_cyDlgFrame=0;
int g_cxFrame=0;
int g_cyFrame=0;

int g_cxMinimized=0;
int g_fCleanBoot=0;
int g_cxVScroll=0;
int g_cyHScroll=0;
UINT g_uDoubleClick=0;

void Cabinet_InitGlobalMetrics(WPARAM wParam, LPTSTR lpszSection)
{
    BOOL fForce = (!lpszSection || !*lpszSection);

    if (fForce || wParam == SPI_SETDRAGFULLWINDOWS)
    {
        SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &g_fDragFullWindows, 0);
    }

    if (fForce || !lstrcmpi(lpszSection, TEXT("WindowMetrics")) ||
        wParam == SPI_SETNONCLIENTMETRICS)
    {
        g_cxEdge = GetSystemMetrics(SM_CXEDGE);
        g_cyEdge = GetSystemMetrics(SM_CYEDGE);
        g_cxTabSpace = (g_cxEdge * 3) / 2;
        g_cyTabSpace = (g_cyEdge * 3) / 2; // cause the graphic designers really really want 3.
        g_cySize = GetSystemMetrics(SM_CYSIZE);
        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);
        g_cxVScroll = GetSystemMetrics(SM_CXVSCROLL);
        g_cyHScroll = GetSystemMetrics(SM_CYHSCROLL);
        g_cxDlgFrame = GetSystemMetrics(SM_CXDLGFRAME);
        g_cyDlgFrame = GetSystemMetrics(SM_CYDLGFRAME);
        g_cxFrame  = GetSystemMetrics(SM_CXFRAME);
        g_cyFrame  = GetSystemMetrics(SM_CYFRAME);
        g_cxMinimized = GetSystemMetrics(SM_CXMINIMIZED);
        g_cxPrimaryDisplay = GetSystemMetrics(SM_CXSCREEN);
        g_cyPrimaryDisplay = GetSystemMetrics(SM_CYSCREEN);
    }

    if (fForce || wParam == SPI_SETDOUBLECLICKTIME)
    {
        g_uDoubleClick = GetDoubleClickTime();
    }
}

//---------------------------------------------------------------------------

void _CreateAppGlobals()
{
    g_fCleanBoot = GetSystemMetrics(SM_CLEANBOOT);      // also known as "Safe Mode"

    Cabinet_InitGlobalMetrics(0, NULL);

    //
    // Check if the mirroring APIs exist on the current
    // platform.
    //
    g_bMirroredOS = IS_MIRRORING_ENABLED();
}

//
//  This function checks if any of the shell windows is already created by
// another instance of explorer and returns TRUE if so.
//

BOOL IsAnyShellWindowAlreadyPresent()
{
    return GetShellWindow() || FindWindow(TEXT("Proxy Desktop"), NULL);
}


// See if the Shell= line indicates that we are the shell

BOOL ExplorerIsShell()
{
    TCHAR *pszPathName, szPath[MAX_PATH];
    TCHAR *pszModuleName, szModulePath[MAX_PATH];

    ASSERT(!IsAnyShellWindowAlreadyPresent());

    GetModuleFileName(NULL, szModulePath, ARRAYSIZE(szModulePath));
    pszModuleName = PathFindFileName(szModulePath);

    GetPrivateProfileString(TEXT("boot"), TEXT("shell"), pszModuleName, szPath, ARRAYSIZE(szPath), TEXT("system.ini"));

    PathRemoveArgs(szPath);
    PathRemoveBlanks(szPath);
    pszPathName = PathFindFileName(szPath);

    // NB Special case shell=install.exe - assume we are the shell.
    // Symantec un-installers temporarily set shell=installer.exe so
    // we think we're not the shell when we are. They fail to clean up
    // a bunch of links if we don't do this.

    return StrCmpNI(pszPathName, pszModuleName, lstrlen(pszModuleName)) == 0 ||
           lstrcmpi(pszPathName, TEXT("install.exe")) == 0;
}


// Returns TRUE of this is the first time the explorer is run

BOOL ShouldStartDesktopAndTray()
{
    // We need to be careful on which window we look for.  If we look for
    // our desktop window class and Progman is running we will find the
    // progman window.  So Instead we should ask user for the shell window.

    // We can not depend on any values being set here as this is the
    // start of a new process.  This wont be called when we start new
    // threads.
    return !IsAnyShellWindowAlreadyPresent() && ExplorerIsShell();
}

void DisplayCleanBootMsg()
{
    // On server sku's or anytime on ia64, just show a message with
    // an OK button for safe boot
    UINT uiMessageBoxFlags = MB_ICONEXCLAMATION | MB_SYSTEMMODAL | MB_OK;
    UINT uiMessage = IDS_CLEANBOOTMSG;

#ifndef _WIN64
    if (!IsOS(OS_ANYSERVER))
    {
        // On x86 per and pro, also offer an option to start system restore
        uiMessageBoxFlags = MB_ICONEXCLAMATION | MB_SYSTEMMODAL | MB_YESNO;
        uiMessage = IDS_CLEANBOOTMSGRESTORE;
    }
#endif // !_WIN64

    WCHAR szTitle[80];
    WCHAR szMessage[1024];

    LoadString(hinstCabinet, IDS_DESKTOP, szTitle, ARRAYSIZE(szTitle));
    LoadString(hinstCabinet, uiMessage, szMessage, ARRAYSIZE(szMessage));

    // on IA64 the msgbox will always return IDOK, so this "if" will always fail.
    if (IDNO == MessageBox(NULL, szMessage, szTitle, uiMessageBoxFlags))
    {
        TCHAR szPath[MAX_PATH];
        ExpandEnvironmentStrings(TEXT("%SystemRoot%\\system32\\restore\\rstrui.exe"), szPath, ARRAYSIZE(szPath));
        PROCESS_INFORMATION pi;
        STARTUPINFO si = {0};
        if (CreateProcess(szPath, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
        {
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }
    }
}

BOOL IsExecCmd(LPCTSTR pszCmd)
{
    return *pszCmd && !StrStrI(pszCmd, TEXT("-embedding"));
}

// run the cmd line passed up from win.com

void _RunWinComCmdLine(LPCTSTR pszCmdLine, UINT nCmdShow)
{
    if (IsExecCmd(pszCmdLine))
    {
        SHELLEXECUTEINFO ei = { sizeof(ei), 0, NULL, NULL, pszCmdLine, NULL, NULL, nCmdShow};

        ei.lpParameters = PathGetArgs(pszCmdLine);
        if (*ei.lpParameters)
            *((LPTSTR)ei.lpParameters - 1) = 0;     // const -> non const

        ShellExecuteEx(&ei);
    }
}

// stolen from the CRT, used to shirink our code
LPTSTR _SkipCmdLineCrap(LPTSTR pszCmdLine)
{
    if (*pszCmdLine == TEXT('\"'))
    {
        //
        // Scan, and skip over, subsequent characters until
        // another double-quote or a null is encountered.
        //
        while (*++pszCmdLine && (*pszCmdLine != TEXT('\"')))
            ;

        //
        // If we stopped on a double-quote (usual case), skip
        // over it.
        //
        if (*pszCmdLine == TEXT('\"'))
            pszCmdLine++;
    }
    else
    {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    //
    // Skip past any white space preceeding the second token.
    //
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' ')))
        pszCmdLine++;

    return pszCmdLine;
}

STDAPI_(int) ModuleEntry()
{
    PERFSETMARK("ExplorerStartup");

    DoInitialization();

    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail

    SetErrorMode(SEM_FAILCRITICALERRORS);

    LPTSTR pszCmdLine = GetCommandLine();
    pszCmdLine = _SkipCmdLineCrap(pszCmdLine);

    STARTUPINFO si = {0};
    si.cb = sizeof(si);
    GetStartupInfo(&si);

    int nCmdShow = si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT;
    int iRet = ExplorerWinMain(GetModuleHandle(NULL), NULL, pszCmdLine, nCmdShow);

    DoCleanup();

    // Since we now have a way for an extension to tell us when it is finished,
    // we will terminate all processes when the main thread goes away.

    if (g_fExitExplorer)    // desktop told us not to exit
        ExitProcess(iRet);

    return iRet;
}

HANDLE CreateDesktopAndTray()
{
    HANDLE hDesktop = NULL;

    if (g_dwProfileCAP & 0x00008000)
        StartCAPAll();

    if (v_hwndTray || c_tray.Init())
    {
        ASSERT(v_hwndTray);

        if (!v_hwndDesktop)
        {
            // cache the handle to the desktop...
            hDesktop = SHCreateDesktop(c_tray.GetDeskTray());
        }
    }

    if (g_dwProfileCAP & 0x80000000)
        StopCAPAll();

    return hDesktop;
}

// Removes the session key from the registry.
void NukeSessionKey(void)
{
    HKEY hkDummy;
    SHCreateSessionKey(0xFFFFFFFF, &hkDummy);
}

BOOL IsFirstInstanceAfterLogon()
{
    BOOL fResult = FALSE;

    HKEY hkSession;
    HRESULT hr = SHCreateSessionKey(KEY_WRITE, &hkSession);
    if (SUCCEEDED(hr))
    {
        HKEY hkStartup;
        DWORD dwDisposition;
        LONG lRes;
        lRes = RegCreateKeyEx(hkSession, TEXT("StartupHasBeenRun"), 0,
                       NULL,
                       REG_OPTION_VOLATILE,
                       KEY_WRITE,
                       NULL,
                       &hkStartup,
                       &dwDisposition);
        if (lRes == ERROR_SUCCESS)
        {
            RegCloseKey(hkStartup);
            if (dwDisposition == REG_CREATED_NEW_KEY)
                fResult = TRUE;
        }
        RegCloseKey(hkSession);
    }
    return fResult;
}

DWORD ReadFaultCount()
{
    DWORD dwValue = 0;
    DWORD dwSize = sizeof(dwValue);

    RegQueryValueEx(g_hkeyExplorer, TEXT("FaultCount"), NULL, NULL, (LPBYTE)&dwValue, &dwSize);
    return dwValue;
}

void WriteFaultCount(DWORD dwValue)
{
    RegSetValueEx(g_hkeyExplorer, TEXT("FaultCount"), 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
    // If we are clearing the fault count or this is the first fault, clear or set the fault time.
    if (!dwValue || (dwValue == 1))
    {
        if (dwValue)
            dwValue = GetTickCount();
        RegSetValueEx(g_hkeyExplorer, TEXT("FaultTime"), 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
    }
}

// This function assumes it is only called when a fault has occured previously...
BOOL ShouldDisplaySafeMode()
{
    BOOL fRet = FALSE;
    SHELLSTATE ss;

    SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);

    if (ss.fDesktopHTML)
    {
        if (ReadFaultCount() >= MAGIC_FAULT_LIMIT)
        {
            DWORD dwValue = 0;
            DWORD dwSize = sizeof(dwValue);

            RegQueryValueEx(g_hkeyExplorer, TEXT("FaultTime"), NULL, NULL, (LPBYTE)&dwValue, &dwSize);
            fRet = ((GetTickCount() - dwValue) < MAGIC_FAULT_TIME);
            // We had enough faults but they weren't over a sufficiently short period of time.  Reset the fault
            // count to 1 so that we start counting from this fault now.
            if (!fRet)
                WriteFaultCount(1);
        }
    }
    else
    {
        // We don't care about faults that occured if AD is off.
        WriteFaultCount(0);
    }
    
    return fRet;
}

//
//  dwValue is FALSE if this is startup, TRUE if this is shutdown,
//
void WriteCleanShutdown(DWORD dwValue)
{
    RegSetValueEx(g_hkeyExplorer, TEXT("CleanShutdown"), 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));

    // If we are shutting down for real (i.e., not fake), then clean up the
    // session key so we don't leak a bazillion volatile keys into the
    // registry on a TS system when people log on and off and on and off...
    if (dwValue && !g_fFakeShutdown) 
    {
        NukeSessionKey();
    }
}

BOOL ReadCleanShutdown()
{
    DWORD dwValue = 1;  // default: it was clean
    DWORD dwSize = sizeof(dwValue);

    RegQueryValueEx(g_hkeyExplorer, TEXT("CleanShutdown"), NULL, NULL, (LPBYTE)&dwValue, &dwSize);
    return (BOOL)dwValue;
}

//
//  Synopsis:   Waits for the OLE SCM process to finish its initialization.
//              This is called before the first call to OleInitialize since
//              the SHELL runs early in the boot process.
//
//  Arguments:  None.
//
//  Returns:    S_OK - SCM is running. OK to call OleInitialize.
//              CO_E_INIT_SCM_EXEC_FAILURE - timed out waiting for SCM
//              other - create event failed
//
//  History:    26-Oct-95   Rickhi  Extracted from CheckAndStartSCM so
//                                  that only the SHELL need call it.
//
HRESULT WaitForSCMToInitialize()
{
    static BOOL s_fScmStarted = FALSE;

    if (s_fScmStarted)
    {
        return S_OK;
    }

    SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();

    // on NT5 we need a global event that is shared between TS sessions
    HANDLE hEvent = CreateEvent(psa, TRUE, FALSE, SZ_SCMCREATEDEVENT_NT5);

    if (!hEvent && GetLastError() == ERROR_ACCESS_DENIED)
    {
        //
        // Win2K OLE32 has tightened security such that if this object
        // already exists, we aren't allowed to open it with EVENT_ALL_ACCESS
        // (CreateEvent fails with ERROR_ACCESS_DENIED in this case).
        // Fall back by calling OpenEvent requesting SYNCHRONIZE access.
        //
        hEvent = OpenEvent(SYNCHRONIZE, FALSE, SZ_SCMCREATEDEVENT_NT5);
    }
    
    if (hEvent)
    {
        // wait for the SCM to signal the event, then close the handle
        // and return a code based on the WaitEvent result.
        int rc = WaitForSingleObject(hEvent, 60000);

        CloseHandle(hEvent);

        if (rc == WAIT_OBJECT_0)
        {
            s_fScmStarted = TRUE;
            return S_OK;
        }
        else if (rc == WAIT_TIMEOUT)
        {
            return CO_E_INIT_SCM_EXEC_FAILURE;
        }
    }
    return HRESULT_FROM_WIN32(GetLastError());  // event creation failed or WFSO failed.
}

STDAPI OleInitializeWaitForSCM()
{
    HRESULT hr = WaitForSCMToInitialize();
    // SECURITY: Ignore result otherwise a guest could squat on this event
    hr = SHCoInitialize();  // make sure we get no OLE1 DDE crap
    OleInitialize(NULL);
    return hr;
}


// we need to figure out the fFirstShellBoot on a per-user
// basis rather than once per machine.  We want the welcome
// splash screen to come up for every new user.

BOOL IsFirstShellBoot()
{
    DWORD dwDisp;
    HKEY hkey;
    BOOL fFirstShellBoot = TRUE;  // default value

    if (RegCreateKeyEx(HKEY_CURRENT_USER, REGTIPS, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                     NULL, &hkey, &dwDisp) == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(fFirstShellBoot);

        RegQueryValueEx(hkey, TEXT("DisplayInitialTipWindow"), NULL, NULL, (LPBYTE)&fFirstShellBoot, &dwSize);

        if (fFirstShellBoot)
        {
            // Turn off the initial tip window for future shell starts.
            BOOL bTemp = FALSE;
            RegSetValueEx(hkey, TEXT("DisplayInitialTipWindow"), 0, REG_DWORD, (LPBYTE) &bTemp, sizeof(bTemp));
        }
        RegCloseKey(hkey);
    }
    return fFirstShellBoot;
}

// the following locale fixes (for NT5 378948) are dependent on desk.cpl changes
// Since Millennium does not ship updated desk.cpl, we don't want to do this on Millennium
//
//  Given the Locale ID, this returns the corresponding charset
//
UINT  GetCharsetFromLCID(LCID   lcid)
{
    TCHAR szData[6+1]; // 6 chars are max allowed for this lctype
    UINT uiRet;
    if (GetLocaleInfo(lcid, LOCALE_IDEFAULTANSICODEPAGE, szData, ARRAYSIZE(szData)) > 0)
    {
        UINT uiCp = (UINT)StrToInt(szData);
        CHARSETINFO csinfo;

        TranslateCharsetInfo(IntToPtr_(DWORD *, uiCp), &csinfo, TCI_SRCCODEPAGE);
        uiRet = csinfo.ciCharset;
    }
    else
    {
        // at worst non penalty for charset
        uiRet = DEFAULT_CHARSET;
    }

    return uiRet;
}

// In case of system locale change, the only way to update UI fonts is opening
// Desktop->Properties->Appearance.
// If the end user never open it the UI fonts are never changed.
// So compare the charset from system locale with the UI fonts charset then
// call desk.cpl if those are different.

#define MAX_CHARSETS      4
typedef HRESULT (STDAPICALLTYPE *LPUPDATECHARSETCHANGES)();

void CheckDefaultUIFonts()
{
    UINT  uiCharsets[MAX_CHARSETS];
    DWORD dwSize = sizeof(UINT) * MAX_CHARSETS;
    DWORD dwError;

    dwError = SHGetValue(HKEY_CURRENT_USER, TEXT("Control Panel\\Appearance"), TEXT("RecentFourCharsets"), NULL, (void *)uiCharsets, &dwSize);

    if (dwError != ERROR_SUCCESS || uiCharsets[0] != GetCharsetFromLCID(GetSystemDefaultLCID()))
    {
        HINSTANCE   hInst;
        LPUPDATECHARSETCHANGES pfnUpdateCharsetChanges;

        if (hInst = LoadLibrary(TEXT("desk.cpl")))
        {
            // Call desk.cpl to change the UI fonts in case of
            // system locale change.
            if (pfnUpdateCharsetChanges = (LPUPDATECHARSETCHANGES)(GetProcAddress(hInst, "UpdateCharsetChanges")))
            {
                (*pfnUpdateCharsetChanges)();
            }
            FreeLibrary(hInst);
        }
    }
}

//
// This function calls an desk.cpl function to update the UI fonts to use the new DPI value.
// UpdateUIfonts() in desk.cpl checks to see if the DPI value has changed. If not, it returns
// immediately; If the dpi value has changed, it changes the size of all the UI fonts to reflect
// the dpi change and then returns.
//
typedef HRESULT (WINAPI *LPUPDATEUIFONTS)(int, int);
void ChangeUIfontsToNewDPI()
{
    int iNewDPI, iOldDPI;
    
    //Get the current system DPI.
    HDC hdc = GetDC(NULL);
    iNewDPI = GetDeviceCaps(hdc, LOGPIXELSY);
    ReleaseDC(NULL, hdc);

    DWORD dwSize = sizeof(iOldDPI);
    //Get the last saved DPI value for the current user.
    if (SHGetValue(HKEY_CURRENT_USER, SZ_WINDOWMETRICS, SZ_APPLIEDDPI, NULL, (void *)&iOldDPI, &dwSize) != ERROR_SUCCESS)
    {
        //"AppliedDPI" for the current user is missing.
        // Now, see if the "OriginalDPI" value exists under HKLM
        dwSize = sizeof(iOldDPI);
        if (SHGetValue(HKEY_LOCAL_MACHINE, SZ_CONTROLPANEL, SZ_ORIGINALDPI, NULL, (void *)&iOldDPI, &dwSize) != ERROR_SUCCESS)
        {
            //If "OriginalDPI" value is also missing, that means that nobody has changed DPI.
            // Old and New are one and the same!!!
            iOldDPI = iNewDPI;
        }
    }
        
    if (iNewDPI != iOldDPI)  //Has the dpi value changed?
    {
        HINSTANCE hInst = LoadLibrary(TEXT("desk.cpl"));

        if (hInst)
        {
	        LPUPDATEUIFONTS pfnUpdateUIfonts;
            //Call desk.cpl to update the UI fonts to reflect the DPI change.
            if (pfnUpdateUIfonts = (LPUPDATEUIFONTS)(GetProcAddress(hInst, "UpdateUIfontsDueToDPIchange")))
            {
                (*pfnUpdateUIfonts)(iOldDPI, iNewDPI);
            }
            FreeLibrary(hInst);
        }
    }
}


#define SZ_EXPLORERMUTEX    TEXT("ExplorerIsShellMutex")

CComModule _Module;
BEGIN_OBJECT_MAP(ObjectMap)
// add your OBJECT_ENTRY's here
END_OBJECT_MAP()

typedef BOOL (*PFNICOMCTL32)(LPINITCOMMONCONTROLSEX);
void _InitComctl32()
{
    HMODULE hmod = LoadLibrary(TEXT("comctl32.dll"));
    if (hmod)
    {
        PFNICOMCTL32 pfn = (PFNICOMCTL32)GetProcAddress(hmod, "InitCommonControlsEx");
        if (pfn)
        {
            INITCOMMONCONTROLSEX icce;
            icce.dwICC = 0x00003FFF;
            icce.dwSize = sizeof(icce);
            pfn(&icce);
        }
    }
}


BOOL _ShouldFixResolution(void)
{
    BOOL fRet = FALSE;
#ifndef _WIN64  // This feature is not supported on 64-bit machine

    DISPLAY_DEVICE dd;
    ZeroMemory(&dd, sizeof(DISPLAY_DEVICE));
    dd.cb = sizeof(DISPLAY_DEVICE);

    if (SHRegGetBoolUSValue(REGSTR_PATH_EXPLORER TEXT("\\DontShowMeThisDialogAgain"), TEXT("ScreenCheck"), FALSE, TRUE))
    {
        // Don't fix SafeMode or Terminal Clients
        if ((GetSystemMetrics(SM_CLEANBOOT) == 0) && (GetSystemMetrics(SM_REMOTESESSION) == FALSE))
        {
            fRet = TRUE;
            for (DWORD dwMon = 0; EnumDisplayDevices(NULL, dwMon, &dd, 0); dwMon++)
            {
                if (!(dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER))
                {
                    DEVMODE dm = {0};
                    dm.dmSize = sizeof(DEVMODE);

                    if (EnumDisplaySettingsEx(dd.DeviceName, ENUM_CURRENT_SETTINGS, &dm, 0))
                    {
                        if ((dm.dmFields & DM_POSITION) &&
                            ((dm.dmPelsWidth >= 600) &&
                                (dm.dmPelsHeight >= 600) &&
                                (dm.dmBitsPerPel >= 15)))
                        {
                            fRet = FALSE;
                        }
                    }
                }
            }
        }
    }

#endif // _WIN64
    return fRet;
}


BOOL _ShouldOfferTour(void)
{
    BOOL fRet = FALSE;
    
#ifndef _WIN64  // This feature is not supported on 64-bit machine

    // we don't allow guest to get offered tour b/c guest's registry is wiped every time she logs out, 
    //   so she would get tour offered every single she logged in.
    if (!IsOS(OS_ANYSERVER) && !IsOS(OS_EMBEDDED) && !(SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_GUESTS)))
    {
        DWORD dwCount;
        DWORD cbCount = sizeof(DWORD);
        
        // we assume if we can't read the RunCount it's because it's not there (we haven't tried to offer the tour yet), so we default to 3.
        if (ERROR_SUCCESS != SHRegGetUSValue(REGSTR_PATH_SETUP TEXT("\\Applets\\Tour"), TEXT("RunCount"), NULL, &dwCount, &cbCount, FALSE, NULL, 0))
        {
            dwCount = 3;
        }
        
        if (dwCount)
        {
            HUSKEY hkey1;
            if (ERROR_SUCCESS == SHRegCreateUSKey(REGSTR_PATH_SETUP TEXT("\\Applets"), KEY_WRITE, NULL, &hkey1, SHREGSET_HKCU))
            {
                HUSKEY hkey2;
                if (ERROR_SUCCESS == SHRegCreateUSKey(TEXT("Tour"), KEY_WRITE, hkey1, &hkey2, SHREGSET_HKCU))
                {
                    if (ERROR_SUCCESS == SHRegWriteUSValue(hkey2, TEXT("RunCount"), REG_DWORD, &(--dwCount), cbCount, SHREGSET_FORCE_HKCU))
                    {
                        fRet = TRUE;
                    }
                    SHRegCloseUSKey(hkey2);
                }
                SHRegCloseUSKey(hkey1);
            }
        }
    }

#endif // _WIN64
    return fRet;
}

typedef BOOL (*CHECKFUNCTION)(void);

void _ConditionalBalloonLaunch(CHECKFUNCTION pCheckFct, SHELLREMINDER* psr)
{
    if (pCheckFct())
    {
        IShellReminderManager* psrm;
        HRESULT hr = CoCreateInstance(CLSID_PostBootReminder, NULL, CLSCTX_INPROC_SERVER,
                         IID_PPV_ARG(IShellReminderManager, &psrm));

        if (SUCCEEDED(hr))
        {
            psrm->Add(psr);
            psrm->Release();
        }
    }
}


void _CheckScreenResolution(void)
{
    WCHAR szTitle[256];
    WCHAR szText[512];
    SHELLREMINDER sr = {0};

    LoadString(hinstCabinet, IDS_FIXSCREENRES_TITLE, szTitle, ARRAYSIZE(szTitle));
    LoadString(hinstCabinet, IDS_FIXSCREENRES_TEXT, szText, ARRAYSIZE(szText));

    sr.cbSize = sizeof (sr);
    sr.pszName = L"Microsoft.FixScreenResolution";
    sr.pszTitle = szTitle;
    sr.pszText = szText;
    sr.pszIconResource = L"explorer.exe,9";
    sr.dwTypeFlags = NIIF_INFO;
    sr.pclsid = (GUID*)&CLSID_ScreenResFixer; // Try to run the Screen Resolution Fixing code over in ThemeUI
    sr.pszShellExecute = L"desk.cpl"; // Open the Display Control Panel as a backup

    _ConditionalBalloonLaunch(_ShouldFixResolution, &sr);
}


void _OfferTour(void)
{
    WCHAR szTitle[256];
    WCHAR szText[512];
    SHELLREMINDER sr = {0};

    LoadString(hinstCabinet, IDS_OFFERTOUR_TITLE, szTitle, ARRAYSIZE(szTitle));
    LoadString(hinstCabinet, IDS_OFFERTOUR_TEXT, szText, ARRAYSIZE(szText));

    sr.cbSize = sizeof (sr);
    sr.pszName = L"Microsoft.OfferTour";
    sr.pszTitle = szTitle;
    sr.pszText = szText;
    sr.pszIconResource = L"tourstart.exe,0";
    sr.dwTypeFlags = NIIF_INFO;
    sr.pszShellExecute = L"tourstart.exe";
    sr.dwShowTime = 60000;

    _ConditionalBalloonLaunch(_ShouldOfferTour, &sr);
}


void _FixWordMailRegKey(void)
{
    // If we don't have permissions, fine this is just correction code
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, L"Applications", 0, KEY_ALL_ACCESS, &hkey))
    {
        HKEY hkeyTemp;
        if (ERROR_SUCCESS != RegOpenKeyEx(hkey, L"WINWORD.EXE", 0, KEY_ALL_ACCESS, &hkeyTemp))
        {
            HKEY hkeyWinWord;
            DWORD dwResult;
            if (ERROR_SUCCESS == RegCreateKeyEx(hkey, L"WINWORD.EXE", 0, L"", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyWinWord, &dwResult))
            {
                HKEY hkeyTBExcept;
                if (ERROR_SUCCESS == RegCreateKeyEx(hkeyWinWord, L"TaskbarExceptionsIcons", 0, L"", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyTBExcept, &dwResult))
                {
                    HKEY hkeyIcon;
                    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyTBExcept, L"WordMail", 0, L"", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkeyIcon, &dwResult))
                    {
                        const WCHAR szIconPath[] = L"explorer.exe,16";
                        DWORD cbIconPath = sizeof(szIconPath);
                        RegSetValue(hkeyIcon, L"IconPath", REG_SZ, szIconPath, cbIconPath);

                        const WCHAR szNewExeName[] = L"OUTLOOK.EXE";
                        DWORD cbNewExeName = sizeof(szNewExeName);
                        RegSetValue(hkeyIcon, L"NewExeName", REG_SZ, szNewExeName, cbNewExeName);
                        RegCloseKey(hkeyIcon);
                    }
                    RegCloseKey(hkeyTBExcept);
                }
                RegCloseKey(hkeyWinWord);
            }
        }
        else
        {
            RegCloseKey(hkeyTemp);
        }
        RegCloseKey(hkey);
    }
}

//
//  If this is the first logon, check if we have a server
//  administrator.  If so, then change some defaults
//  to match the server administrator UI style.
//

void CheckForServerAdminUI()
{
    DWORD dwServerAdminUI;
    DWORD cb = sizeof(dwServerAdminUI);
    DWORD dwErr = SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\Advanced"),
                             TEXT("ServerAdminUI"), NULL, &dwServerAdminUI, &cb);
    if (dwErr == ERROR_FILE_NOT_FOUND || dwErr == ERROR_PATH_NOT_FOUND)
    {
        //  Determine whether the user should receive server admin UI or not
        dwServerAdminUI = IsOS(OS_ANYSERVER) &&
          (SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS) ||
           SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_SYSTEM_OPS) ||
           SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_BACKUP_OPS) ||
           SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS));

        // In the server admin case, change some defaults to be more serverish
        if (dwServerAdminUI)
        {
            // Install the Server Admin UI
            typedef HRESULT (CALLBACK *DLLINSTALLPROC)(BOOL, LPWSTR);
            DLLINSTALLPROC pfnDllInstall = (DLLINSTALLPROC)GetProcAddress(GetModuleHandle(TEXT("SHELL32")), "DllInstall");
            if (pfnDllInstall)
            {
                pfnDllInstall(TRUE, L"SA");
            }

            // Re-enable keyboard underlines.
            SystemParametersInfo(SPI_SETKEYBOARDCUES, 0, IntToPtr(TRUE), SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);

            // Tell everybody to refresh since we changed some settings
            SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, 0);
        }

        SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\Advanced"),
                   TEXT("ServerAdminUI"), REG_DWORD, &dwServerAdminUI, sizeof(dwServerAdminUI));
    }
}


int ExplorerWinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPTSTR pszCmdLine, int nCmdShow)
{
    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);

    SHFusionInitializeFromModule(hInstance);

    CcshellGetDebugFlags();

    g_dwStopWatchMode = StopWatchMode();

    if (g_dwProfileCAP & 0x00000001)
        StartCAP();

    hinstCabinet = hInstance;

    if (SUCCEEDED(_Module.Init(ObjectMap, hInstance)))
    {
        _CreateAppGlobals();

        // Run IEAK via Wininet initialization if the autoconfig url is present.
        // No need to unload wininet in this case. Also only do this first time
        // Explorer loads (GetShellWindow() returns NULL).
        if (!GetShellWindow() && !g_fCleanBoot && SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\Internet Settings"),
                                             TEXT("AutoConfigURL"),
                                             NULL, NULL, NULL, FALSE, NULL, 0) == ERROR_SUCCESS)
        {
            LoadLibrary(TEXT("WININET.DLL"));
        }


        // Very Important: Make sure to init dde prior to any Get/Peek/Wait().
        InitializeCriticalSection(&g_csDll);

#ifdef FULL_DEBUG
        // Turn off GDI batching so that paints are performed immediately
        GdiSetBatchLimit(1);
#endif

        RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, &g_hkeyExplorer);
        if (g_hkeyExplorer == NULL)
        {
            TraceMsg(TF_ERROR, "ExplorerWinMain: unable to create reg explorer key");
        }

        HANDLE hMutex = NULL;

        BOOL fExplorerIsShell = ShouldStartDesktopAndTray();
        if (fExplorerIsShell)
        {
            // Grab the mutex and do the check again.  We do it this
            // way so that we don't bother with the mutex for the common
            // case of opening a browser window.
            
            hMutex = CreateMutex(NULL, FALSE, SZ_EXPLORERMUTEX);
            if (hMutex)
            {
                WaitForSingleObject(hMutex, INFINITE);
            }

            fExplorerIsShell = ShouldStartDesktopAndTray();
        } 

        if (!fExplorerIsShell)
        {
            // We're not going to be the shell, relinquish the mutex
            if (hMutex)
                ReleaseMutex(hMutex);

            // we purposely do NOT want to init OLE or COM in this case since we are delegating the creation work
            // to an existing explorer and we want to keep from loading lots of extra dlls that would slow us down.
            MyCreateFromDesktop(hInstance, pszCmdLine, nCmdShow);
        }
        else
        {
            MSG msg;

            DWORD dwShellStartTime = GetTickCount();    // Compute shell startup time for perf automation

            ShellDDEInit(TRUE);        // use shdocvw shell DDE code.

            //  Specify the shutdown order of the shell process.  2 means
            //  the explorer should shutdown after everything but ntsd/windbg
            //  (level 0).  (Taskman used to use 1, but is no more.)

            SetProcessShutdownParameters(2, 0);

            _AutoRunTaskMan();

            // NB Make this the primary thread by calling peek message
            // for a message we know we're not going to get.
            // If we don't do it really soon, the notify thread can sometimes
            // become the primary thread by accident. There's a bunch of
            // special code in user to implement DDE hacks by assuming that
            // the primary thread is handling DDE.
            // Also, the PeekMsg() will cause us to set the WaitForInputIdle()
            // event so we better be ready to do all dde.

            PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_NOREMOVE);

            // We do this here, since FileIconInit will call SHCoInitialize anyway
            HRESULT hrInit = OleInitializeWaitForSCM();

            // Make sure we are the first one to call the FileIconInit...
            FileIconInit(TRUE); // Tell the shell we want to play with a full deck

            g_fLogonCycle = IsFirstInstanceAfterLogon();
            g_fCleanShutdown = ReadCleanShutdown();

            CheckDefaultUIFonts();
            ChangeUIfontsToNewDPI(); //Check dpi values and update the fonts if needed.
            CheckForServerAdminUI();

            if (g_fLogonCycle)
            {
                _ProcessRunOnceEx();
                
                _ProcessRunOnce();
            }

            if (g_fCleanBoot)
            {
                // let users know we are in safe mode
                DisplayCleanBootMsg();
            }

            // Create the other special folders.
            CreateShellDirectories();

            // Run install stubs for the current user, mostly to propagate
            // shortcuts to apps installed by another user.
            if (!g_fCleanBoot)
            {
                HANDLE hCanRegister = CreateEvent(NULL, TRUE, TRUE, TEXT("_fCanRegisterWithShellService"));

                RunInstallUninstallStubs();

                if (hCanRegister)
                {
                    CloseHandle(hCanRegister);
                }
            }
            
            if (!g_fCleanShutdown)
            {
                IActiveDesktopP *piadp;
                DWORD dwFaultCount;

                // Increment and store away fault count
                dwFaultCount = ReadFaultCount();
                WriteFaultCount(++dwFaultCount);

                // Put the active desktop in safe mode if we faulted 3 times previously and this is a subsequent instance

                if (ShouldDisplaySafeMode() && SUCCEEDED(CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC, IID_PPV_ARG(IActiveDesktopP, &piadp))))
                {
                    piadp->SetSafeMode(SSM_SET | SSM_UPDATE);
                    piadp->Release();
                }
            }

            WriteCleanShutdown(FALSE);    // assume we will have a bad shutdown

            WinList_Init();

            // If any of the shellwindows are already present, then we want to bail out.
            //
            // NOTE: Compaq shell changes the "shell=" line during RunOnce time and
            // that will make ShouldStartDesktopAndTray() return FALSE

            HANDLE hDesktop = NULL;

            if (!IsAnyShellWindowAlreadyPresent())
            {
                hDesktop = CreateDesktopAndTray();
            }

            // Now that we've had a chance to create the desktop, release the mutex
            if (hMutex)
            {
                ReleaseMutex(hMutex);
            }

            if (hDesktop)
            {
                // Enable display of balloons in the tray...
                PostMessage(v_hwndTray, TM_SHOWTRAYBALLOON, TRUE, 0);

                _CheckScreenResolution();

                _OfferTour();

                _FixWordMailRegKey();

                _RunWinComCmdLine(pszCmdLine, nCmdShow);

                if (g_dwStopWatchMode)
                {
                    // We used to save these off into global vars, and then write them at
                    // WM_ENDSESSION, but that seems too unreliable
                    DWORD dwShellStopTime = GetTickCount();
                    StopWatch_StartTimed(SWID_STARTUP, TEXT("Shell Startup: Start"), SPMODE_SHELL | SPMODE_DEBUGOUT, dwShellStartTime);
                    StopWatch_StopTimed(SWID_STARTUP, TEXT("Shell Startup: Stop"), SPMODE_SHELL | SPMODE_DEBUGOUT, dwShellStopTime);
                }

                if (g_dwProfileCAP & 0x00010000)
                    StopCAP();

                PERFSETMARK("ExplorerStartMsgLoop");

                SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);

                // this must be whomever is the window on this thread
                SHDesktopMessageLoop(hDesktop);

                WriteCleanShutdown(TRUE);    // we made it out ok, record that fact
                WriteFaultCount(0);          // clear our count of faults, we are exiting normally
            }

            WinList_Terminate();    // Turn off our window list processing
            OleUninitialize();
            SHCoUninitialize(hrInit);

            ShellDDEInit(FALSE);    // use shdocvw shell DDE code
        }

        _Module.Term();
    }

    SHFusionUninitialize();
    DebugMsg(DM_TRACE, TEXT("c.App Exit."));

    return TRUE;
}

#ifdef _WIN64
//
// The purpose of this function is to spawn rundll32.exe if we have 32-bit stuff in 
// HKLM\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run that needs to be executed.
//
BOOL _ProcessRun6432()
{
    BOOL bRet = FALSE;

    if (!SHRestricted(REST_NOLOCALMACHINERUN))
    {
        if (SHKeyHasValues(HKEY_LOCAL_MACHINE, TEXT("Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run")))
        {
            TCHAR szWow64Path[MAX_PATH];

            if (ExpandEnvironmentStrings(TEXT("%SystemRoot%\\SysWOW64"), szWow64Path, ARRAYSIZE(szWow64Path)))
            {
                TCHAR sz32BitRunOnce[MAX_PATH];
                PROCESS_INFORMATION pi = {0};

                if (SUCCEEDED(StringCchPrintf(sz32BitRunOnce, ARRAYSIZE(sz32BitRunOnce), TEXT("%s\\runonce.exe"), szWow64Path)))
                {
                    if (CreateProcessWithArgs(sz32BitRunOnce, TEXT("/Run6432"), szWow64Path, &pi))
                    {
                        CloseHandle(pi.hProcess);
                        CloseHandle(pi.hThread);

                        bRet = TRUE;
                    }
                }
            }
        }
    }

    return bRet;
}
#endif  // _WIN64


STDAPI_(BOOL) Startup_ExecuteRegAppEnumProc(LPCTSTR szSubkey, LPCTSTR szCmdLine, RRA_FLAGS fFlags, LPARAM lParam)
{
    BOOL bRet = ExecuteRegAppEnumProc(szSubkey, szCmdLine, fFlags, lParam);
    
    if (!bRet && !(fFlags & RRA_DELETE))
    {
        c_tray.LogFailedStartupApp();
    }

    return bRet;
}


typedef struct
{
    RESTRICTIONS rest;
    HKEY hKey;
    const TCHAR* psz;
    DWORD dwRRAFlags;
}
STARTUPGROUP;

BOOL _RunStartupGroup(const STARTUPGROUP* pGroup, int cGroup)
{
    BOOL bRet = FALSE;

    // make sure SHRestricted is working ok
    ASSERT(!SHRestricted(REST_NONE));

    for (int i = 0; i < cGroup; i++)
    {
        if (!SHRestricted(pGroup[i].rest))
        {
            bRet = Cabinet_EnumRegApps(pGroup[i].hKey, pGroup[i].psz, pGroup[i].dwRRAFlags, Startup_ExecuteRegAppEnumProc, 0);
        }
    }

    return bRet;
}


BOOL _ProcessRun()
{
    static const STARTUPGROUP s_RunTasks [] =
    {
        { REST_NONE,                    HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN_POLICY, RRA_NOUI }, // HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run
        { REST_NOLOCALMACHINERUN,       HKEY_LOCAL_MACHINE, REGSTR_PATH_RUN,        RRA_NOUI }, // HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
        { REST_NONE,                    HKEY_CURRENT_USER,  REGSTR_PATH_RUN_POLICY, RRA_NOUI }, // HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer\\Run
        { REST_NOCURRENTUSERRUN,        HKEY_CURRENT_USER,  REGSTR_PATH_RUN,        RRA_NOUI }, // HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
    };
    
    BOOL bRet = _RunStartupGroup(s_RunTasks, ARRAYSIZE(s_RunTasks));

#ifdef _WIN64
    // see if we need to launch any 32-bit apps under wow64
    _ProcessRun6432();
#endif

    return bRet;
}


BOOL _ProcessPerUserRunOnce()
{
    static const STARTUPGROUP s_PerUserRunOnceTasks [] =
    {
        { REST_NOCURRENTUSERRUNONCE,    HKEY_CURRENT_USER,  REGSTR_PATH_RUNONCE,    RRA_DELETE | RRA_NOUI },    // HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce
    };

    return _RunStartupGroup(s_PerUserRunOnceTasks, ARRAYSIZE(s_PerUserRunOnceTasks));
}


DWORD WINAPI RunStartupAppsThread(void *pv)
{
    // Some of the items we launch during startup assume that com is initialized.  Make this
    // assumption true.
    HRESULT hrInit = SHCoInitialize();

    // These global flags are set once long before our thread starts and are then only
    // read so we don't need to worry about timing issues.
    if (g_fLogonCycle && !g_fCleanBoot)
    {
        // We only run these startup items if g_fLogonCycle is TRUE. This prevents
        // them from running again if the shell crashes and restarts.

        _ProcessOldRunAndLoadEquals();
        _ProcessRun();
        _ExecuteStartupPrograms();
    }

    // As a best guess, the HKCU RunOnce key is executed regardless of the g_fLogonCycle
    // becuase it was once hoped that we could install newer versions of IE without
    // requiring a reboot.  They would place something in the CU\RunOnce key and then
    // shutdown and restart the shell to continue their setup process.  I believe this
    // idea was later abandoned but the code change is still here.  Since that could
    // some day be a useful feature I'm leaving it the same.
    _ProcessPerUserRunOnce();

    // we need to run all the non-blocking items first.  Then we spend the rest of this threads life
    // runing the synchronized objects one after another.
    if (g_fLogonCycle && !g_fCleanBoot)
    {
        _RunWelcome();
    }

    PostMessage(v_hwndTray, TM_STARTUPAPPSLAUNCHED, 0, 0);

    SHCoUninitialize(hrInit);

    return TRUE;
}


void RunStartupApps()
{
    DWORD dwThreadID;
    HANDLE handle = CreateThread(NULL, 0, RunStartupAppsThread, 0, 0, &dwThreadID);
    if (handle)
    {
        CloseHandle(handle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\mixer.h ===
void Mixer_SetCallbackWindow(HWND hwndCallback);
MMRESULT Mixer_ToggleMute(void);
MMRESULT Mixer_SetVolume(int Increment);
MMRESULT Mixer_ToggleBassBoost(void);
MMRESULT Mixer_SetBass(int Increment);
MMRESULT Mixer_SetTreble(int Increment);

void Mixer_Shutdown();
void Mixer_DeviceChange(WPARAM wParam, LPARAM lParam);
void Mixer_ControlChange(WPARAM wParam, LPARAM lParam);
void Mixer_MMDeviceChange(void);

// default step size is 4% of max volume.
#define MIXER_DEFAULT_STEP        ((int)(65535/25))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\mixer.cpp ===
#include "cabinet.h"
#include "mixer.h"
#include <dbt.h>
#include "mmddkp.h"

///////////////////////////////////////
// External interface
//
///////////////////////////////////////
// Definitions
//

#define MMHID_VOLUME_CONTROL    0
#define MMHID_BASS_CONTROL      1
#define MMHID_TREBLE_CONTROL    2
#define MMHID_BALANCE_CONTROL   3
#define MMHID_MUTE_CONTROL      4
#define MMHID_LOUDNESS_CONTROL  5
#define MMHID_BASSBOOST_CONTROL 6
#define MMHID_NUM_CONTROLS      7

typedef struct _LINE_DATA
{
    MIXERLINE           MixerLine;      // The real deal MIXERLINE struct.
    DWORD               ControlType[MMHID_NUM_CONTROLS];
    BOOL                ControlPresent[MMHID_NUM_CONTROLS];
    MIXERCONTROL        Control[MMHID_NUM_CONTROLS];
} LINE_DATA, * PLINE_DATA, FAR * LPLINE_DATA;

typedef struct _MIXER_DATA
{
    HMIXER      hMixer;          // open handle to mixer
    HWND        hwndCallback;    // window to use for mixer callbacks
    LPWSTR      DeviceInterface; // DeviceInterface that implements the mixer
    double*     pdblCacheMix;    // Dynamic array of relative channel level percentages
    LPDWORD     pdwLastVolume;   // Last volume level set on mixer
    MMRESULT    mmr;             // last result      (iff dwReturn == MIXUI_MMSYSERR)
    LINE_DATA   LineData;        // BYDESIGN -  putting this here assumes only one
                                 //          mixer line for now. (first dest. line)

} MIXER_DATA, *PMIXER_DATA, FAR *LPMIXER_DATA;

/*++
 *  Globals
--*/
BOOL       g_fMixerStartup = TRUE;
HWND       g_hwndCallback;
MIXER_DATA g_MixerData;
BOOL       g_fMixerPresent = FALSE;

void Mixer_Close(MIXER_DATA *pMixerData);
BOOL Mixer_CheckMissing(void);

/*****************************************************************************
 *
 *  ACTIVE GET/SET CODE
 *
 *****************************************************************************/
#define VOLUME_MIN  0L
#define VOLUME_MAX  65535L


void RefreshMixCache (PMIXER_DATA pMixerData, LPDWORD padwVolume)
{

    if (pMixerData && padwVolume)
    {

        DWORD cChannels = pMixerData -> LineData.MixerLine.cChannels;
        if (1 > cChannels)
            return; // Weird!

        // Create cache if necessary
        if (!pMixerData -> pdblCacheMix)
            pMixerData -> pdblCacheMix = (double *)LocalAlloc(LPTR, cChannels * sizeof (double));

        // Refresh cache
        if (pMixerData -> pdblCacheMix)
        {

            UINT uiIndx;
            double* pdblMixPercent;
            DWORD dwVolume;

            // Get the maximum volume
            DWORD dwMaxVol = 0;
            for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
                dwMaxVol = max (dwMaxVol, *(padwVolume + uiIndx));

            // Caculate the percentage distance each channel is away from the max
            // value. Creating this cache allows us to maintain the relative distance
            // of the channel levels from each other as the user adjusts the master
            // volume level.
            for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
            {
                dwVolume       = *(padwVolume + uiIndx);
                pdblMixPercent = ((pMixerData -> pdblCacheMix) + uiIndx);

                // Caculate the percentage this value is from the max ...
                if (dwMaxVol == dwVolume)
                {
                    *pdblMixPercent = 1.0F;
                }
                else
                {
                    // Note: if 0 == dwMaxVol all values would be zero and this part
                    //       of the "if" statement will never execute.
                    *pdblMixPercent = ((double) dwVolume / (double) dwMaxVol);
                }
            }
        }
    }
}


static
MMRESULT
Mixer_GetVolume(
    LPMIXER_DATA pMixerData,
    LPDWORD      padwVolume
    )
/*++
Routine Description:

--*/
{
    MIXERCONTROLDETAILS mxcd;
    MMRESULT            mmr;

    if (!pMixerData->LineData.ControlPresent[MMHID_VOLUME_CONTROL]) return MIXERR_INVALCONTROL;

    mxcd.cbStruct       = sizeof(mxcd);
    mxcd.dwControlID    = pMixerData->LineData.Control[MMHID_VOLUME_CONTROL].dwControlID;
    mxcd.cChannels      = pMixerData->LineData.MixerLine.cChannels;
    mxcd.cMultipleItems = 0;
    mxcd.cbDetails      = sizeof(DWORD);
    mxcd.paDetails      = (LPVOID)padwVolume;

    mmr = mixerGetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);
    return mmr;

}

MMRESULT
Mixer_ToggleMute(void)
/*++
Routine Description:

--*/
{
    MIXERCONTROLDETAILS mxcd;
    DWORD               fMute;
    MMRESULT            mmr;
    MIXER_DATA          *pMixerData = &g_MixerData;

    if (Mixer_CheckMissing())
    {
        return MMSYSERR_NODRIVER;
    }

    if (!pMixerData->LineData.ControlPresent[MMHID_MUTE_CONTROL]) return MMSYSERR_NOERROR;

    mxcd.cbStruct         = sizeof(mxcd);
    mxcd.dwControlID      = pMixerData->LineData.Control[MMHID_MUTE_CONTROL].dwControlID ;
    mxcd.cChannels        = 1;
    mxcd.cMultipleItems   = 0;
    mxcd.cbDetails        = sizeof(fMute);
    mxcd.paDetails        = (LPVOID)&fMute;

    mmr = mixerGetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);

    if (!mmr) {

        fMute = fMute ? 0 : 1;

        mmr =  mixerSetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                      &mxcd,
                                      MIXER_OBJECTF_HANDLE | MIXER_SETCONTROLDETAILSF_VALUE);
    }

    return mmr;
}



MMRESULT
Mixer_ToggleLoudness(
    MIXER_DATA *    pMixerData
    )
/*++
Routine Description:

--*/
{
    MIXERCONTROLDETAILS mxcd;
    DWORD               fEnabled;
    MMRESULT            mmr;

    if (!pMixerData->LineData.ControlPresent[MMHID_LOUDNESS_CONTROL]) return MMSYSERR_NOERROR;

    mxcd.cbStruct         = sizeof(mxcd);
    mxcd.dwControlID      = pMixerData->LineData.Control[MMHID_LOUDNESS_CONTROL].dwControlID ;
    mxcd.cChannels        = 1;
    mxcd.cMultipleItems   = 0;
    mxcd.cbDetails        = sizeof(fEnabled);
    mxcd.paDetails        = (LPVOID)&fEnabled;

    mmr = mixerGetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);


    if (!mmr) {

        fEnabled = fEnabled ? 0 : 1;

        mmr =  mixerSetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                      &mxcd,
                                      MIXER_OBJECTF_HANDLE | MIXER_SETCONTROLDETAILSF_VALUE);
    }
    return mmr;
}

MMRESULT Mixer_ToggleBassBoost(void)
/*++
Routine Description:

--*/
{
    MIXERCONTROLDETAILS mxcd;
    DWORD               fEnabled;
    MMRESULT            mmr;
    MIXER_DATA          *pMixerData = &g_MixerData;

    if (Mixer_CheckMissing())
    {
        return MMSYSERR_NODRIVER;
    }

    if (!pMixerData->LineData.ControlPresent[MMHID_BASSBOOST_CONTROL]) return MMSYSERR_NOERROR;

    mxcd.cbStruct         = sizeof(mxcd);
    mxcd.dwControlID      = pMixerData->LineData.Control[MMHID_BASSBOOST_CONTROL].dwControlID ;
    mxcd.cChannels        = 1;
    mxcd.cMultipleItems   = 0;
    mxcd.cbDetails        = sizeof(fEnabled);
    mxcd.paDetails        = (LPVOID)&fEnabled;

    mmr = mixerGetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                  &mxcd,
                                  MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);

    if (!mmr) {

        fEnabled = fEnabled ? 0 : 1;

        mmr =  mixerSetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                      &mxcd,
                                      MIXER_OBJECTF_HANDLE | MIXER_SETCONTROLDETAILSF_VALUE);
    }
    return mmr;
}


MMRESULT
Mixer_SetVolume(
    int          Increment           // amount of volume change
    )
/*++
Routine Description:
    Change a mixerControl in response to a user event
--*/
{
    MMRESULT            mmr;
    MIXERCONTROLDETAILS mxcd;

    LPVOID      pvVolume;
    UINT        uiIndx;
    LPDWORD     pdwVolume;
    double      dblVolume;
    MIXER_DATA  *pMixerData = &g_MixerData;
    PLINE_DATA  pLineData;
    DWORD       cChannels;

    if (Mixer_CheckMissing())
    {
        return MMSYSERR_NODRIVER;
    }

    pLineData = &pMixerData->LineData;
    cChannels = pMixerData -> LineData.MixerLine.cChannels;

    if (!pMixerData->LineData.ControlPresent[MMHID_VOLUME_CONTROL]) return MMSYSERR_NOERROR;

    //
    // get current volume
    //
    ZeroMemory (&mxcd, sizeof (mxcd));
    mxcd.cbDetails = sizeof (DWORD);
    mxcd.paDetails = LocalAlloc(LPTR, cChannels * sizeof (DWORD));
    if (!mxcd.paDetails)
        return MMSYSERR_NOMEM;
    pvVolume = LocalAlloc(LPTR, cChannels * sizeof (DWORD));
    if (!pvVolume)
    {
        LocalFree(mxcd.paDetails);
        return MMSYSERR_NOMEM;
    }

    // Note: From here on, do not return without freeing 'mxcd.paDetails'
    //       and 'pvVolume'.

    // Get the current volume and any mix cache
    mmr = Mixer_GetVolume (pMixerData, (LPDWORD)mxcd.paDetails);
    if (MMSYSERR_NOERROR == mmr)
    {
        // Create cache if we don't already have one
        if (!pMixerData -> pdblCacheMix)
        {
            RefreshMixCache (pMixerData, (LPDWORD)mxcd.paDetails);
            if (!pMixerData -> pdblCacheMix)
                mmr = MMSYSERR_NOMEM;
            else
            {
                // Create last set volume cache
                if (!pMixerData -> pdwLastVolume)
                {
                    pMixerData -> pdwLastVolume = (DWORD *)LocalAlloc(LPTR, cChannels * sizeof (DWORD));
                    if (!pMixerData -> pdwLastVolume)
                        mmr = MMSYSERR_NOMEM;
                }
            }
        }
        else
        {
            //  HHMMM, speculating random ass fix for 167948/174466 since this
            //  is the ONLY branch where pdwLastVolume can be NULL and not
            //  generate an error.  Will have to talk to FrankYe
            //    -Fwong.

            if (!pMixerData -> pdwLastVolume)
            {
                pMixerData -> pdwLastVolume = (DWORD *)LocalAlloc(LPTR, cChannels * sizeof (DWORD));
                if (!pMixerData -> pdwLastVolume)
                    mmr = MMSYSERR_NOMEM;
            }
        }
    }

    // Don't allow incrementing past max volume (channels meet at
    // min volume, so need to test that).
    if (0 < Increment && MMSYSERR_NOERROR == mmr)
    {
        for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
        {
            pdwVolume = (((DWORD*)mxcd.paDetails) + uiIndx);
            dblVolume = (*(pMixerData -> pdblCacheMix + uiIndx) * (double) Increment);
            if (VOLUME_MAX <= (*pdwVolume) + dblVolume)
                Increment = min ((DWORD) Increment, VOLUME_MAX - (*pdwVolume));
        }
    }

    //
    // set the volume
    //
    if (0 != Increment && MMSYSERR_NOERROR == mmr)
    {
        // Back up the current settings
        memcpy (pvVolume, mxcd.paDetails, cChannels * sizeof (DWORD));

        // Caculate the new volume level for each of the channels. For volume levels
        // at the current max, we simply set the newly requested level (in this case
        // the cache value is 1.0). For those less than the max, we set a value that
        // is a percentage of the max. This maintains the relative distance of the
        // channel levels from each other.
        for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
        {
            pdwVolume = (((DWORD*)mxcd.paDetails) + uiIndx);
            dblVolume = (*(pMixerData -> pdblCacheMix + uiIndx) * (double) Increment);
            // Ensure positive result
            if (VOLUME_MIN >= ((double)(*pdwVolume) + dblVolume))
                (*pdwVolume) = VOLUME_MIN;
            else
                (*pdwVolume) = (DWORD)((double)(*pdwVolume) + dblVolume);

            // Ensure that the new value is in range
            (*pdwVolume) = (DWORD) min (VOLUME_MAX, (*pdwVolume));

            // Disables pesky warning...
#if (VOLUME_MIN != 0L)
            (*pdwVolume) = (DWORD) max (VOLUME_MIN, (*pdwVolume));
#endif
        }

        // Cache last caculated volume..
        memcpy (pMixerData -> pdwLastVolume, mxcd.paDetails, cChannels * sizeof (DWORD));

        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pLineData->Control[MMHID_VOLUME_CONTROL].dwControlID;
        mxcd.cChannels      = cChannels;
        mxcd.cMultipleItems = 0;

        // Apply new value only if it is different. This prevents unessary calls to
        // mixerSetControlDetails() when we are pegged.
        if (memcmp (pvVolume, mxcd.paDetails, cChannels * sizeof (DWORD)))
        {
            //
            // Set the volume control at the mixer.
            //
            mmr = mixerSetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                         &mxcd,
                                         MIXER_OBJECTF_HANDLE | MIXER_SETCONTROLDETAILSF_VALUE);
        }
    }


    // Free 'mxcd.paDetails' and 'pvVolume'
    LocalFree(mxcd.paDetails);
    LocalFree(pvVolume);

    return mmr;
}


#define BASS_MIN  0L
#define BASS_MAX  65535L

MMRESULT
Mixer_SetBass(
    int          Increment           // amount of change
    )
/*++
Routine Description:
    Change a mixerControl in response to a user event
--*/
{
    MMRESULT            mmr;
    MIXERCONTROLDETAILS mxcd;
    MIXER_DATA          *pMixerData = &g_MixerData;
    PLINE_DATA  pLineData;

    if (Mixer_CheckMissing())
    {
        return MMSYSERR_NODRIVER;
    }

    pLineData = &pMixerData->LineData;

    LONG lLevel = 0;

    if (!pMixerData->LineData.ControlPresent[MMHID_BASS_CONTROL]) return MMSYSERR_NOERROR;

    mxcd.cbStruct       = sizeof(mxcd);
    mxcd.dwControlID    = pLineData->Control[MMHID_BASS_CONTROL].dwControlID;

    //
    // get current setting
    //
    mxcd.cChannels        = 1;
    mxcd.cMultipleItems   = 0;
    mxcd.cbDetails        = sizeof(lLevel);
    mxcd.paDetails        = (LPVOID)&lLevel;

    mmr = mixerGetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);

    if (mmr) return mmr;

    lLevel += Increment;
    lLevel = min( BASS_MAX, lLevel);
    lLevel = max( BASS_MIN, lLevel);


    mxcd.cChannels      = 1;
    mxcd.cMultipleItems = 0;
    mxcd.cbDetails      = sizeof(lLevel);
    mxcd.paDetails      = (LPVOID)&lLevel;

    //
    // Set the bass control at the mixer.
    //
    mmr = mixerSetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_SETCONTROLDETAILSF_VALUE);

    return mmr;
}


#define TREBLE_MIN  0L
#define TREBLE_MAX  65535L

MMRESULT
Mixer_SetTreble(
    int          Increment
    )
/*++
Routine Description:
    Change a mixerControl in response to a user event
--*/
{
    MMRESULT            mmr;
    MIXERCONTROLDETAILS mxcd;
    MIXER_DATA          *pMixerData = &g_MixerData;
    PLINE_DATA  pLineData;

    if (Mixer_CheckMissing())
    {
        return MMSYSERR_NODRIVER;
    }

    pLineData = &pMixerData->LineData;

    LONG lLevel = 0;

    if (!pMixerData->LineData.ControlPresent[MMHID_TREBLE_CONTROL]) return MMSYSERR_NOERROR;

    mxcd.cbStruct       = sizeof(mxcd);
    mxcd.dwControlID    = pLineData->Control[MMHID_TREBLE_CONTROL].dwControlID;

    //
    // get current setting
    //
    mxcd.cChannels        = 1;
    mxcd.cMultipleItems   = 0;
    mxcd.cbDetails        = sizeof(lLevel);
    mxcd.paDetails        = (LPVOID)&lLevel;

    mmr = mixerGetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);

    if (mmr) return mmr;

    lLevel += Increment;
    lLevel = min( TREBLE_MAX, lLevel);
    lLevel = max( TREBLE_MIN, lLevel);

    mxcd.cChannels      = 1;
    mxcd.cMultipleItems = 0;
    mxcd.cbDetails      = sizeof(lLevel);
    mxcd.paDetails      = (LPVOID)&lLevel;

    //
    // Set the bass control at the mixer.
    //
    mmr = mixerSetControlDetails((HMIXEROBJ)pMixerData->hMixer,
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_SETCONTROLDETAILSF_VALUE);

    return mmr;
}

/*****************************************************************************
 *
 *
 *
 *****************************************************************************/

MMRESULT
Mixer_GetDefaultMixerID(
    int         *pid
    )
/*++
Routine Description:
     Get the default mixer id.  We only appear if there is a mixer associated
     with the default wave.
--*/
{
    MMRESULT    mmr;
    UINT        uWaveID, uMxID;
    DWORD       dwFlags;

    if (0 == waveOutGetNumDevs()) return MMSYSERR_NODRIVER;

    mmr = waveOutMessage((HWAVEOUT)(UINT_PTR)WAVE_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&uWaveID, (DWORD_PTR)&dwFlags);
    if (MMSYSERR_NOERROR == mmr)
    {
        if (WAVE_MAPPER != uWaveID)
        {
            mmr = mixerGetID((HMIXEROBJ)(UINT_PTR)uWaveID, &uMxID, MIXER_OBJECTF_WAVEOUT);
            if (mmr == MMSYSERR_NOERROR)
            {
                *pid = uMxID;
            }
        } else {
            //  Don't return a default mixer id if we don't have a default
            //  audio driver
            mmr =  MMSYSERR_NODRIVER;
        }
    }

    return mmr;
}



BOOL
Mixer_GetDestLine(
    MIXER_DATA * pMixerData
    )
/*++
Routine Description:

--*/
{

    MIXERLINE * mlDst = &pMixerData->LineData.MixerLine;
    MMRESULT  mmr;

    mlDst->cbStruct      = sizeof ( MIXERLINE );
    mlDst->dwComponentType = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;

    mmr = mixerGetLineInfo((HMIXEROBJ)pMixerData->hMixer,
                           mlDst,
                           MIXER_OBJECTF_HANDLE | MIXER_GETLINEINFOF_COMPONENTTYPE);

    if (mmr != MMSYSERR_NOERROR){
        return FALSE;
    }

    return TRUE;
}



void
Mixer_GetLineControls(
    MIXER_DATA * pMixerData,
    LINE_DATA * pLineData
    )
/*++
Routine Description:

--*/
{
    MIXERLINECONTROLS LineControls;
    MMRESULT  mmr;
    DWORD   i;

    for(i=0; i<MMHID_NUM_CONTROLS; i++){
        LineControls.cbStruct = sizeof(LineControls);
        LineControls.dwLineID = pLineData->MixerLine.dwLineID;
        LineControls.dwControlType = pLineData->ControlType[i];
        LineControls.cControls = 1;
        LineControls.cbmxctrl = sizeof(MIXERCONTROL);
        LineControls.pamxctrl = &pLineData->Control[i];

        mmr = mixerGetLineControls((HMIXEROBJ)pMixerData->hMixer,
                                   &LineControls,
                                   MIXER_OBJECTF_HANDLE | MIXER_GETLINECONTROLSF_ONEBYTYPE);

        pLineData->ControlPresent[i] = (MMSYSERR_NOERROR == mmr) ? TRUE : FALSE;

        if (mmr != MMSYSERR_NOERROR){
            //return mmr;
        }
    }

    return;
}


///////////////////////////////////////
//

BOOL
Mixer_Open(
    MIXER_DATA * pMixerData
    )
/*++
Routine Description:
    Finds the default mixer, opens it, and initializes
    all data.

--*/
{
    PWSTR    pwstrDeviceInterface;
    ULONG    cbDeviceInterface;
    int      MixerId;
    MMRESULT mmr;
    BOOL     result;

    ASSERT(!pMixerData->hMixer);

    // Get console mixer ID and open it.
    mmr = Mixer_GetDefaultMixerID(&MixerId);
    if(mmr) return FALSE;

    mmr = mixerOpen(&pMixerData->hMixer, MixerId, (DWORD_PTR)pMixerData->hwndCallback, 0, CALLBACK_WINDOW);
    if (!mmr) {
        //
        // Get our controls for the default destination line.
        //
        if (Mixer_GetDestLine(pMixerData)) {
            Mixer_GetLineControls(pMixerData, &pMixerData->LineData);

            // Free any mix cache & volume cache
            if (pMixerData->pdblCacheMix) LocalFree(pMixerData->pdblCacheMix);
            pMixerData->pdblCacheMix = NULL;
            if (pMixerData -> pdwLastVolume) LocalFree(pMixerData -> pdwLastVolume);
            pMixerData -> pdwLastVolume = NULL;

            // Get the DeviceInterface of the mixer in order to listen
            // for relevant PnP device messages
            if (pMixerData->DeviceInterface) LocalFree(pMixerData->DeviceInterface);
                pMixerData->DeviceInterface = NULL;

            mmr = (MMRESULT)mixerMessage(pMixerData->hMixer, DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbDeviceInterface, 0);
            if (!mmr && (0 != cbDeviceInterface)) {
                pwstrDeviceInterface = (PWSTR)LocalAlloc(LPTR, cbDeviceInterface);
                if (pwstrDeviceInterface) {
                    mmr = (MMRESULT)mixerMessage(pMixerData->hMixer, DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)pwstrDeviceInterface, cbDeviceInterface);
                    if (!mmr) {
                        pMixerData->DeviceInterface = pwstrDeviceInterface;
                    } else {
                        LocalFree(pwstrDeviceInterface);
                    }
                }
            }

            result = TRUE;

        } else {
            mixerClose(pMixerData->hMixer);
            pMixerData->hMixer = NULL;
            TraceMsg(TF_WARNING, "Mixer_Open : Could not find mixer destination line");
            result = FALSE;
        }
    }

    return result;

}

void Mixer_Close(MIXER_DATA *pMixerData)
/*++
Routine Description:
    Closes the mixer handle.
--*/
{
    if (pMixerData->DeviceInterface) LocalFree(pMixerData->DeviceInterface);
    pMixerData->DeviceInterface = NULL;
    if (pMixerData->pdblCacheMix) LocalFree(pMixerData->pdblCacheMix);
    pMixerData->pdblCacheMix = NULL;
    if (pMixerData->pdwLastVolume) LocalFree(pMixerData->pdwLastVolume);
    pMixerData->pdwLastVolume = NULL;

    if (pMixerData->hMixer){
        MMRESULT mmr;
        mmr = mixerClose(pMixerData->hMixer);
        if (mmr) TraceMsg(TF_ERROR, "Mixer_Close : error: mixerClose returned mmr=%08Xh", mmr);
        
        ASSERT(MMSYSERR_NOERROR == mmr);
        pMixerData->hMixer = NULL;
    }
    return;
}


void
Mixer_Refresh(void)
/*++
Routine Description:
    Closes the current mixer handle (if one is open), then opens mixer
    again.
--*/
{
    Mixer_Close(&g_MixerData);
    g_fMixerPresent = Mixer_Open(&g_MixerData);
}

void Mixer_SetCallbackWindow(HWND hwndCallback)
{
    g_hwndCallback = hwndCallback;
}

void Mixer_Startup(HWND hwndCallback)
/*++
Routine Description:
--*/
{
    MIXER_DATA *pMixerData = &g_MixerData;

    pMixerData->hMixer = NULL;

    pMixerData->hwndCallback = hwndCallback;

    pMixerData->DeviceInterface = NULL;
    pMixerData->pdblCacheMix = NULL;
    pMixerData->pdwLastVolume = NULL;

    pMixerData->LineData.ControlType[MMHID_VOLUME_CONTROL]    = MIXERCONTROL_CONTROLTYPE_VOLUME;
    pMixerData->LineData.ControlType[MMHID_BASS_CONTROL]      = MIXERCONTROL_CONTROLTYPE_BASS;
    pMixerData->LineData.ControlType[MMHID_TREBLE_CONTROL]    = MIXERCONTROL_CONTROLTYPE_TREBLE;
    pMixerData->LineData.ControlType[MMHID_BALANCE_CONTROL]   = MIXERCONTROL_CONTROLTYPE_PAN;
    pMixerData->LineData.ControlType[MMHID_MUTE_CONTROL]      = MIXERCONTROL_CONTROLTYPE_MUTE;
    pMixerData->LineData.ControlType[MMHID_LOUDNESS_CONTROL]  = MIXERCONTROL_CONTROLTYPE_LOUDNESS;
    pMixerData->LineData.ControlType[MMHID_BASSBOOST_CONTROL] = MIXERCONTROL_CONTROLTYPE_BASS_BOOST;

    pMixerData->LineData.ControlPresent[MMHID_VOLUME_CONTROL]    = FALSE;
    pMixerData->LineData.ControlPresent[MMHID_BASS_CONTROL]      = FALSE;
    pMixerData->LineData.ControlPresent[MMHID_TREBLE_CONTROL]    = FALSE;
    pMixerData->LineData.ControlPresent[MMHID_BALANCE_CONTROL]   = FALSE;
    pMixerData->LineData.ControlPresent[MMHID_MUTE_CONTROL]      = FALSE;
    pMixerData->LineData.ControlPresent[MMHID_LOUDNESS_CONTROL]  = FALSE;
    pMixerData->LineData.ControlPresent[MMHID_BASSBOOST_CONTROL] = FALSE;

    Mixer_Refresh();

    return;
}

BOOL Mixer_CheckMissing(void)
{
    if (g_fMixerStartup)
    {
        Mixer_Startup(g_hwndCallback);
        g_fMixerStartup = FALSE;
    }
    return !g_fMixerPresent;
}

void Mixer_Shutdown(void)
/*++
Routine Description:
    Frees storage for mixer's DeviceInterface, then Mixer_Close().
--*/
{
    MIXER_DATA *pMixerData = &g_MixerData;

    if (pMixerData->DeviceInterface) LocalFree(pMixerData->DeviceInterface);
    pMixerData->DeviceInterface = NULL;
    if (pMixerData->pdblCacheMix) LocalFree(pMixerData->pdblCacheMix);
    pMixerData->pdblCacheMix = NULL;
    if (pMixerData->pdwLastVolume) LocalFree(pMixerData->pdwLastVolume);
    pMixerData->pdwLastVolume = NULL;

    Mixer_Close(pMixerData);

    return;
}

void Mixer_DeviceChange(WPARAM wParam, LPARAM lParam)
{
    PDEV_BROADCAST_DEVICEINTERFACE dbdi = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;

    if (!g_MixerData.DeviceInterface) return;

    switch (wParam) {
    case DBT_DEVICEQUERYREMOVE:
    case DBT_DEVICEREMOVEPENDING:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) return;
        if (lstrcmpi(dbdi->dbcc_name, g_MixerData.DeviceInterface)) return;
        Mixer_Close(&g_MixerData);
        return;

    case DBT_DEVICEQUERYREMOVEFAILED:
        if (dbdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) return;
        if (lstrcmpi(dbdi->dbcc_name, g_MixerData.DeviceInterface)) return;
        Mixer_Refresh();
        return;
    }
    return;
}

void Mixer_ControlChange(
    WPARAM wParam,
    LPARAM lParam )
/*++
Routine Description:
    Handles mixer callback control change messages.  Watches for changes on the
    master volume control and recalculates the last mix values.
--*/
{
    LPDWORD  pdwVolume;
    HMIXER hMixer = (HMIXER)wParam;
    DWORD dwControlID = lParam;

    if (g_MixerData.hMixer != hMixer) return;
    if (dwControlID != g_MixerData.LineData.Control[MMHID_VOLUME_CONTROL].dwControlID) return;

    // DPF(1, "WinmmShellMixerControlChange");

    //
    // get current volume
    //
    pdwVolume = (DWORD *)LocalAlloc(LPTR, g_MixerData.LineData.MixerLine.cChannels * sizeof (DWORD));
    if (!pdwVolume)
        return;

    if (MMSYSERR_NOERROR == Mixer_GetVolume (&g_MixerData, pdwVolume))
    {
        // Refresh cache only if the volume values have changed (i.e. they
        // were set outside of Mixer_SetVolume()).
        if (!g_MixerData.pdwLastVolume || memcmp (g_MixerData.pdwLastVolume, pdwVolume, g_MixerData.LineData.MixerLine.cChannels * sizeof (DWORD)))
            RefreshMixCache (&g_MixerData, pdwVolume);
    }
    LocalFree(pdwVolume);

}


void Mixer_MMDeviceChange( void )
{
    Mixer_Refresh();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\mfulist.h ===
/*
 *  mfulist.h - The default MFU lists
 *
 *  The MFU lists need to be replicated for MUI purposes, so we centralize
 *  them here.
 *
 */

#define MFU_SETDEFAULTS "%ALLUSERSPROFILE%\\Start Menu\\Set Program Access and Defaults.lnk"

//
//  32-bit Client for all user types
//
#define MFU_PRO32ALL_00 "%USERPROFILE%\\Start Menu\\Programs\\Internet Explorer.lnk"
#define MFU_PRO32ALL_01 "%ALLUSERSPROFILE%\\Start Menu\\Programs\\Accessories\\Media Center\\Media Center.lnk"
#define MFU_PRO32ALL_02 "%ALLUSERSPROFILE%\\Start Menu\\Programs\\Windows Journal.lnk"
#define MFU_PRO32ALL_03 "%ALLUSERSPROFILE%\\Start Menu\\Set Program Access and Defaults.lnk"
#define MFU_PRO32ALL_04 "%ALLUSERSPROFILE%\\Start Menu\\Programs\\Get Going with Tablet PC.lnk"
#define MFU_PRO32ALL_05 "%ALLUSERSPROFILE%\\Start Menu\\Programs\\Get Online with MSN.lnk"
#define MFU_PRO32ALL_06 "%ALLUSERSPROFILE%\\Start Menu\\Programs\\MSN Explorer.lnk"
#define MFU_PRO32ALL_07 "%USERPROFILE%\\Start Menu\\Programs\\Windows Media Player.lnk"
#define MFU_PRO32ALL_08 "%ALLUSERSPROFILE%\\Start Menu\\Programs\\Windows Messenger.lnk"
#define MFU_PRO32ALL_09 "%USERPROFILE%\\Start Menu\\Programs\\Accessories\\Tour Windows XP.lnk"
#define MFU_PRO32ALL_10 "%ALLUSERSPROFILE%\\Start Menu\\Programs\\Accessories\\Windows Movie Maker.lnk"
#define MFU_PRO32ALL_11 "%ALLUSERSPROFILE%\\Start Menu\\Programs\\Accessories\\System Tools\\Files and Settings Transfer Wizard.lnk"
#define MFU_PRO32ALL_12 ""
#define MFU_PRO32ALL_13 ""
#define MFU_PRO32ALL_14 ""
#define MFU_PRO32ALL_15 ""

//
//  64-bit Client for all user types
//
#define MFU_PRO64ALL_00 "%ALLUSERSPROFILE%\\Start Menu\\Programs\\Accessories\\Media Center\\Media Center.lnk"
#define MFU_PRO64ALL_01 "%ALLUSERSPROFILE%\\Start Menu\\Programs\\Windows Journal.lnk"
#define MFU_PRO64ALL_02 "%ALLUSERSPROFILE%\\Start Menu\\Set Program Access and Defaults.lnk"
#define MFU_PRO64ALL_03 "%ALLUSERSPROFILE%\\Start Menu\\Programs\\Get Going with Tablet PC.lnk"
#define MFU_PRO64ALL_04 "%USERPROFILE%\\Start Menu\\Programs\\Accessories\\Command Prompt.lnk"
#define MFU_PRO64ALL_05 "%USERPROFILE%\\Start Menu\\Programs\\Accessories\\Notepad.lnk"
#define MFU_PRO64ALL_06 ""
#define MFU_PRO64ALL_07 ""
#define MFU_PRO64ALL_08 ""
#define MFU_PRO64ALL_09 ""
#define MFU_PRO64ALL_10 ""
#define MFU_PRO64ALL_11 ""
#define MFU_PRO64ALL_12 ""
#define MFU_PRO64ALL_13 ""
#define MFU_PRO64ALL_14 ""
#define MFU_PRO64ALL_15 ""

//
//  32-bit Server for administrators
//
#define MFU_SRV32ADM_00 "%USERPROFILE%\\Start Menu\\Programs\\Accessories\\Command Prompt.lnk"
#define MFU_SRV32ADM_01 "%USERPROFILE%\\Start Menu\\Programs\\Accessories\\Notepad.lnk"
#define MFU_SRV32ADM_02 ""
#define MFU_SRV32ADM_03 ""
#define MFU_SRV32ADM_04 ""
#define MFU_SRV32ADM_05 ""
#define MFU_SRV32ADM_06 ""
#define MFU_SRV32ADM_07 ""
#define MFU_SRV32ADM_08 ""
#define MFU_SRV32ADM_09 ""
#define MFU_SRV32ADM_10 ""
#define MFU_SRV32ADM_11 ""
#define MFU_SRV32ADM_12 ""
#define MFU_SRV32ADM_13 ""
#define MFU_SRV32ADM_14 ""
#define MFU_SRV32ADM_15 ""

//
//  64-bit Server for administrators
//
#define MFU_SRV64ADM_00 "%USERPROFILE%\\Start Menu\\Programs\\Accessories\\Command Prompt.lnk"
#define MFU_SRV64ADM_01 "%USERPROFILE%\\Start Menu\\Programs\\Accessories\\Notepad.lnk"
#define MFU_SRV64ADM_02 ""
#define MFU_SRV64ADM_03 ""
#define MFU_SRV64ADM_04 ""
#define MFU_SRV64ADM_05 ""
#define MFU_SRV64ADM_06 ""
#define MFU_SRV64ADM_07 ""
#define MFU_SRV64ADM_08 ""
#define MFU_SRV64ADM_09 ""
#define MFU_SRV64ADM_10 ""
#define MFU_SRV64ADM_11 ""
#define MFU_SRV64ADM_12 ""
#define MFU_SRV64ADM_13 ""
#define MFU_SRV64ADM_14 ""
#define MFU_SRV64ADM_15 ""

//
//  Macros
//
#define MFU_ENUM(fn, type)             \
    fn(type##_00, MFU_##type##_00)     \
    fn(type##_01, MFU_##type##_01)     \
    fn(type##_02, MFU_##type##_02)     \
    fn(type##_03, MFU_##type##_03)     \
    fn(type##_04, MFU_##type##_04)     \
    fn(type##_05, MFU_##type##_05)     \
    fn(type##_06, MFU_##type##_06)     \
    fn(type##_07, MFU_##type##_07)     \
    fn(type##_08, MFU_##type##_08)     \
    fn(type##_09, MFU_##type##_09)     \
    fn(type##_10, MFU_##type##_10)     \
    fn(type##_11, MFU_##type##_11)     \
    fn(type##_12, MFU_##type##_12)     \
    fn(type##_13, MFU_##type##_13)     \
    fn(type##_14, MFU_##type##_14)     \
    fn(type##_15, MFU_##type##_15)     \

#define MFUENUM_CSTR(nm, val)   TEXT(val),
#define MFUENUM_RCSTR(nm, val)  IDS_MFU_##nm val

#define MFU_ENUMRC(type)        MFU_ENUM(MFUENUM_RCSTR, type)
#define MFU_ENUMC(type)         MFU_ENUM(MFUENUM_CSTR,  type)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\muext.c ===
/*************************************************************************
*
* muext.c
*
* HYDRA EXPLORER Multi-User extensions
*
* copyright notice: Copyright 1997, Microsoft
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "cabinet.h"
#include "rcids.h"
#include "startmnu.h"

#ifdef WINNT // this file is hydra specific

#include <winsta.h>

/*=============================================================================
==   defines
=============================================================================*/

/*=============================================================================
==   Global data
=============================================================================*/

//****************************************

BOOL
InitWinStationFunctionsPtrs()

{
    return TRUE;
}

/*****************************************************************************
 *
 *  MuSecurity
 *
 *  Invoke security dialogue box
 *
 * ENTRY:
 *   nothing
 *
 * EXIT:
 *   nothing
 *
 ****************************************************************************/

VOID
MuSecurity( VOID )
{
    //
    // Do nothing on the console
    //

    if (SHGetMachineInfo(GMI_TSCLIENT))
    {
            WinStationSetInformation( SERVERNAME_CURRENT,
                                          LOGONID_CURRENT,
                                          WinStationNtSecurity,
                                          NULL, 0 );
    }
}

#endif // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\rcids.h ===
//---------------------------------------------------------------------------
// Defines for the rc file.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Command IDs
//---------------------------------------------------------------------------
// Menu defines...

// Our command ID range includes the global and browser ranges
//
#define FCIDM_FIRST             FCIDM_GLOBALFIRST
#define FCIDM_LAST              FCIDM_BROWSERLAST

// these are also defined in shlobj.h so views can mess with them
#define FCIDM_TOOLBAR           (FCIDM_BROWSERFIRST + 0)
#define FCIDM_STATUS            (FCIDM_BROWSERFIRST + 1)
#define FCIDM_DRIVELIST         (FCIDM_BROWSERFIRST + 2)        /* ;Internal */
#define FCIDM_TREE              (FCIDM_BROWSERFIRST + 3)        /* ;Internal */
#define FCIDM_TABS              (FCIDM_BROWSERFIRST + 4)        /* ;Internal */


//---------------------------------------------------------------------------
#define FCIDM_BROWSER_FILE      (FCIDM_BROWSERFIRST+0x0020)

#define FCIDM_FILECLOSE         (FCIDM_BROWSER_FILE+0x0001)
#define FCIDM_PREVIOUSFOLDER    (FCIDM_BROWSER_FILE+0x0002)
#define FCIDM_DELETE            (FCIDM_BROWSER_FILE+0x0003)
#define FCIDM_RENAME            (FCIDM_BROWSER_FILE+0x0004)
#define FCIDM_PROPERTIES        (FCIDM_BROWSER_FILE+0x0005)

// these aren't real menu commands, but they map to accelerators or other things
#define FCIDM_NEXTCTL           (FCIDM_BROWSER_FILE+0x0010)
#define FCIDM_DROPDRIVLIST      (FCIDM_BROWSER_FILE+0x0011)
#define FCIDM_CONTEXTMENU       (FCIDM_BROWSER_FILE+0x0012)     // REVIEW: I assume used by help

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_EDIT      (FCIDM_BROWSERFIRST+0x0040)

#define FCIDM_MOVE              (FCIDM_BROWSER_EDIT+0x0001)
#define FCIDM_COPY              (FCIDM_BROWSER_EDIT+0x0002)
#define FCIDM_LINK              (FCIDM_BROWSER_EDIT+0x0003)     // create shortcut
#define FCIDM_PASTE             (FCIDM_BROWSER_EDIT+0x0004)

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_VIEW      (FCIDM_BROWSERFIRST+0x0060)

#define FCIDM_VIEWMENU          (FCIDM_BROWSER_VIEW+0x0001)
#define FCIDM_VIEWTOOLBAR       (FCIDM_BROWSER_VIEW+0x0002)
#define FCIDM_VIEWSTATUSBAR     (FCIDM_BROWSER_VIEW+0x0003)
#define FCIDM_OPTIONS           (FCIDM_BROWSER_VIEW+0x0004)
#define FCIDM_REFRESH           (FCIDM_BROWSER_VIEW+0x0005)
#define FCIDM_VIEWITBAR         (FCIDM_BROWSER_VIEW+0x0007)

#define FCIDM_VIEWNEW           (FCIDM_BROWSER_VIEW+0x0012)

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_TOOLS     (FCIDM_BROWSERFIRST+0x0080)

#define FCIDM_CONNECT           (FCIDM_BROWSER_TOOLS+0x0001)
#define FCIDM_DISCONNECT        (FCIDM_BROWSER_TOOLS+0x0002)
#define FCIDM_CONNECT_SEP       (FCIDM_BROWSER_TOOLS+0x0003)
#define FCIDM_GOTO              (FCIDM_BROWSER_TOOLS+0x0004)
#define FCIDM_FINDFILES         (FCIDM_BROWSER_TOOLS+0x0005)
#define FCIDM_FINDCOMPUTER      (FCIDM_BROWSER_TOOLS+0x0006)
#define FCIDM_MENU_TOOLS_FINDFIRST (FCIDM_BROWSER_TOOLS+0x0007)
#define FCIDM_MENU_TOOLS_FINDLAST  (FCIDM_BROWSER_TOOLS+0x0040)

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_HELP      (FCIDM_BROWSERFIRST+0x0100)

#define FCIDM_HELPSEARCH        (FCIDM_BROWSER_HELP+0x0001)
#define FCIDM_HELPABOUT         (FCIDM_BROWSER_HELP+0x0002)


//----------------------------------------------------------------
#define FCIDM_BROWSER_EXPLORE   (FCIDM_BROWSERFIRST + 0x0110)
#define FCIDM_NAVIGATEBACK      (FCIDM_BROWSER_EXPLORE+0x0001)
#define FCIDM_NAVIGATEFORWARD   (FCIDM_BROWSER_EXPLORE+0x0002)
#define FCIDM_RECENTMENU        (FCIDM_BROWSER_EXPLORE+0x0010)
#define FCIDM_RECENTFIRST       (FCIDM_BROWSER_EXPLORE+0x0011)
#define FCIDM_RECENTLAST        (FCIDM_BROWSER_EXPLORE+0x0050)

#define FCIDM_FAVS_FIRST        (FCIDM_BROWSER_EXPLORE+0x0055)
#define FCIDM_FAVS_MANAGE       (FCIDM_FAVS_FIRST + 0)
#define FCIDM_FAVS_ADDTO        (FCIDM_FAVS_FIRST + 1)
#define FCIDM_FAVS_MORE         (FCIDM_FAVS_FIRST + 2)
#define FCIDM_FAVS_ITEMFIRST    (FCIDM_FAVS_FIRST + 10)
#define FCIDM_FAVS_ITEM         (FCIDM_FAVS_ITEMFIRST + 0)
#define FCIDM_FAVS_ITEMLAST     (FCIDM_FAVS_FIRST + 300)
#define FCIDM_FAVS_LAST         (FCIDM_FAVS_ITEMLAST)

// menu help and tooltip defines for the string resources

#define MH_POPUPS               700
#define MH_ITEMS                (800 - FCIDM_FIRST)
#define MH_TTBASE               (MH_ITEMS - (FCIDM_LAST - FCIDM_FIRST))

#define IDM_CLOSE               FCIDM_LAST + 0x0011


//---------------------------------------------------------------------------
// Icon defines...

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// NOTE: If you are adding new icons, give them #defines at the END, do not use "unused"
// slots in the middle or you will mess up all of the explorer.exe icon indexes that
// are hardcoded and persisted in vaious places.
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#define ICO_FIRST                   100
#define ICO_MYCOMPUTER              100
#define ICO_TREEUP_EXPLORER         101     // old printer tray icon
#define ICO_OLD_PRINTER             102
#define ICO_DESKTOP                 103
#define ICO_OLD_PRINTER_ERROR       104     // old printer error tray icon
#define ICO_STARTMENU               107
#define ICO_DOCMENU                 108
#define ICO_OLD_INFO                109
#define ICO_OLD_WARNING             110
#define ICO_OLD_ERROR               111
#define ICO_SHOWALL                 200
#define ICO_HIDEHIDDEN              201
#define ICO_HIDESYSTEM              202
#define ICO_MULTWIN                 203
#define ICO_OLD_MYCOMPUTER          205     // old my computer icon
#define ICO_SHOWDEMOTED             250
#define ICO_HIDEDEMOTED             251
#define ICO_TRAYPROP_PLACEHOLDER    252
#define ICO_INTERNETBROWSER         253
#define ICO_INTERNETMAIL            254
#define ICO_MEDIAPLAYER             255
#define ICO_WORDMAIL                256
#define ICO_CLASSICSM               257

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// ADD NEW ICONS ABOVE THIS LINE 
// (see comment at the top of of the list of ICO_xxx defines)
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


#define IDB_START                   143

#define IDB_TAAUTOHIDE              145
#define IDB_TAQLLOCKGROUP           146
#define IDB_TAQLNOLOCKGROUP         147
#define IDB_TAQLLOCKNOGROUP         148
#define IDB_TAQLNOLOCKNOGROUP       149
#define IDB_TALOCKGROUP             150
#define IDB_TANOLOCKGROUP           151
#define IDB_TALOCKNOGROUP           152
#define IDB_TANOLOCKNOGROUP         153

#define IDB_SERVERSTARTBKG          158
#define IDB_TABLETPCSTARTBKG        159
#define IDB_TERMINALSERVICESBKG     162
#define IDB_ADVSERVERSTARTBKG       163
#define IDB_DCSERVERSTARTBKG        164
#define IDB_EMBEDDED                165
#define IDB_PERSONALSTARTBKG        166
#define IDB_PROFESSIONALSTARTBKG    167
#define IDB_EMBEDDEDSERVER          168
#define IDB_PROFESSIONAL64STARTBKG  169
#define IDB_BLADESTARTBKG           184
#define IDB_SMALLBUSINESSSTARTBKG   185
#define IDB_APPLIANCESTARTBKG       186

#define IDB_STARTPREVIEWNEW         170
#define IDB_STARTPREVIEWCLASSIC     171

#define IDB_TRAYCHEVRONHORIZ        172
#define IDB_TRAYCHEVRONHORIZOPEN    173
#define IDB_TRAYCHEVRONVERT         174
#define IDB_TRAYCHEVRONVERTOPEN     175

#define IDB_STARTCLASSIC            176
#define IDB_START16                 178
#define IDB_START16MASK             179

#define IDB_NACLOCKCLEAN            180
#define IDB_NANOCLOCKCLEAN          181
#define IDB_NACLOCKNOCLEAN          182
#define IDB_NANOCLOCKNOCLEAN        183

//---------------------------------------------------------------------------
// Menu IDs
#define MENU_CABINET                200
#define MENU_TRAY                   203
#define MENU_START                  204
#define MENU_TRAYCONTEXT            205
#define MENU_COMBINEDTASKS          209
#define MENU_GROUPCONTEXT           210
#define MENU_STARTPANECONTEXT       211

//---------------------------------------------------------------------------
// Accelerators...
#define ACCEL_TRAY                  251

//---------------------------------------------------------------------------
// Dialog template IDs
#define DLG_TRAY_VIEW_OPTIONS   6
#define DLG_NOTIFY              7
#define DLG_STARTMENU_CONFIG    9

#define DLG_PROGRAMFILECONFLICT         20

// global ids
#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif
#define IDC_GROUPBOX                    300
#define IDC_GROUPBOX_2                  301
#define IDC_GROUPBOX_3                  302

// ids to disable context Help
#define IDC_NO_HELP_1                   650
#define IDC_NO_HELP_2                   651
#define IDC_NO_HELP_3                   652
#define IDC_NO_HELP_4                   653

// ids for DLG_FOLDEROPTIONS
#define IDC_ALWAYS                      700
#define IDC_NEVER                       701

// ids for DLG_VIEWOPTIONS
#define IDC_SHOWALL                     750
#define IDC_SHOWSYS                     751
#define IDC_SHOWSOME                    752

#define IDC_SHOWFULLPATH                753
#define IDC_HIDEEXTS                    754
#define IDC_SHOWDESCBAR                 755
#define IDC_SHOWCOMPCOLOR               756

#define IDC_TOP                         1001
#define IDC_BOTTOM                      1002
#define IDC_LEFT                        1003
#define IDC_RIGHT                       1004

// ids for DLG_PROGRAMFILECONFLICT
#define IDC_RENAME                      1006
#define IDC_MSG                         1007

// Now define controls for Tray options property sheet page
#define IDC_TRAYOPTONTOP                1101
#define IDC_TRAYOPTAUTOHIDE             1102
#define IDC_TRAYOPTSHOWCLOCK            1103

#define IDC_TASKBARAPPEARANCE           1111
#define IDC_NOTIFYAPPEARANCE            1112

#define IDC_STARTMENUSETTINGS           1123
#define IDC_RESORT                      1124
#define IDC_KILLDOCUMENTS               1125

#define IDC_ADDSHORTCUT                 1126
#define IDC_DELSHORTCUT                 1127
#define IDC_EXPLOREMENUS                1128

// and the startmenu view prop sheet
#define IDC_PICTSMICONS                 1131

#define IDC_STARTMENUSETTINGSTEXT       1132
#define IDC_PERSONALIZEDMENUS           1500

#define IDC_TRAYNOTIFY_CHEVRON          1502

//---------------------------------------------------------------------------
// String IDs
#define IDS_CABINET             509
#define IDS_STARTMENU           510

#define IDS_WINDOWS             513
#define IDS_CLOSE               514
#define IDS_WINININORUN         515
#define IDS_TASKBAR             518

#define IDS_CONTENTSOF          523
#define IDS_DESKTOP             524
#define IDS_SUSPENDERROR1       525
#define IDS_SUSPENDERROR2       526

#define IDS_OUTOFMEM            529
#define IDS_CANTFINDSPECIALDIR  530
#define IDS_NOTINITED           531

#define IDS_STARTBUTTONTIP      533
#define IDS_UNDOTEMPLATE        534
#define IDS_CASCADE             535
#define IDS_TILE                536
#define IDS_MINIMIZEALL         537

// The next items are used to build the clean boot message...
#define IDS_CLEANBOOTMSG        538
#define IDS_CLEANBOOTMSGRESTORE 539
// 540, 541 available

#define IDS_HIDEDEMOTEDTIP      542
#define IDS_SHOWDEMOTEDTIP      543

#define IDS_BANNERFIRST         544
#define IDS_BANNERLAST          575
// reserve 544-575 for the banner

#define IDS_START               578
#define IDS_EXCEPTIONMSG        579

#define IDS_RESTRICTIONSTITLE   580
#define IDS_RESTRICTIONS        581

#define IDS_BANGICONINFOTITLE   590
#define IDS_BANGICONINFOTIP1    591
#define IDS_TRAYNOTIFYTITLE     593
#define IDS_TASKBANDTITLE       594

#define IDS_STARTCLASSIC        595

// Strings for App Terminate

#define IDS_OKTOKILLAPP1      603
#define IDS_OKTOKILLAPP2      604

#define IDC_CLOCK           303
#define IDC_START           304
#define IDC_KBSTART         305
#define IDC_ASYNCSTART      306
#define IDC_RAISEDESKTOP    307

// SYSPOPUP menu IDs
#define IDSYSPOPUP_CLOSE            1
#define IDSYSPOPUP_FIRST            2
#define IDSYSPOPUP_LAST             0x7fef
#define IDSYSPOPUP_OPENCOMMON       0x7ff0
#define IDSYSPOPUP_EXPLORECOMMON    0x7ff1
#define IDSYSPOPUP_STARTMENUPROP    0x7ff2

// Display change errors.
#define IDS_DISPLAY_ERROR       701
#define IDS_DISPLAY_WARN        702

#define IDS_ALREADYAUTOHIDEBAR  705

#define IDS_TASKDROP_ERROR      711

#define IDS_COMMON              716
#define IDS_BETAEXPIRED         717

// Open / Explore Common strings
#define IDS_OPENCOMMON          718
#define IDS_EXPLORECOMMON       719

// "Start Menu properties"
#define IDS_STARTMENUPROP       720

#define IDS_RUNDLGTITLE         722

#define IDS_LOGOFFNOUSER        730
#define IDS_TURNOFFCOMPUTER     731

#define IDS_HELP_CMD            732

#define IDS_NOTITLE             733

// Start Button
#define IDS_STARTMENUBALLOON_TITLE  800
#define IDS_STARTMENUBALLOON_TIP    801

#define IDS_STARTMENUANDTASKBAR     810
#define IDS_FIXSCREENRES_TITLE      811
#define IDS_FIXSCREENRES_TEXT       812

// Offer tour
#define IDS_OFFERTOUR_TITLE         821
#define IDS_OFFERTOUR_TEXT          822

// Context Menu Strings
#define IDS_HIDEDESKTOP             850

// For Taskband
#define IDS_BOGUSLABELS             851

// For default MFU - see defaultmfu.h

#define IDS_MFU_PRO32ALL_00         2048
#define IDS_MFU_PRO32ALL_01         2049
#define IDS_MFU_PRO32ALL_02         2050
#define IDS_MFU_PRO32ALL_03         2051
#define IDS_MFU_PRO32ALL_04         2052
#define IDS_MFU_PRO32ALL_05         2053
#define IDS_MFU_PRO32ALL_06         2054
#define IDS_MFU_PRO32ALL_07         2055
#define IDS_MFU_PRO32ALL_08         2056
#define IDS_MFU_PRO32ALL_09         2057
#define IDS_MFU_PRO32ALL_10         2058
#define IDS_MFU_PRO32ALL_11         2059
#define IDS_MFU_PRO32ALL_12         2060
#define IDS_MFU_PRO32ALL_13         2061
#define IDS_MFU_PRO32ALL_14         2062
#define IDS_MFU_PRO32ALL_15         2063
#define IDS_MFU_PRO64ALL_00         2064
#define IDS_MFU_PRO64ALL_01         2065
#define IDS_MFU_PRO64ALL_02         2066
#define IDS_MFU_PRO64ALL_03         2067
#define IDS_MFU_PRO64ALL_04         2068
#define IDS_MFU_PRO64ALL_05         2069
#define IDS_MFU_PRO64ALL_06         2070
#define IDS_MFU_PRO64ALL_07         2071
#define IDS_MFU_PRO64ALL_08         2072
#define IDS_MFU_PRO64ALL_09         2073
#define IDS_MFU_PRO64ALL_10         2074
#define IDS_MFU_PRO64ALL_11         2075
#define IDS_MFU_PRO64ALL_12         2076
#define IDS_MFU_PRO64ALL_13         2077
#define IDS_MFU_PRO64ALL_14         2078
#define IDS_MFU_PRO64ALL_15         2079
#define IDS_MFU_SRV32ADM_00         2080
#define IDS_MFU_SRV32ADM_01         2081
#define IDS_MFU_SRV32ADM_02         2082
#define IDS_MFU_SRV32ADM_03         2083
#define IDS_MFU_SRV32ADM_04         2084
#define IDS_MFU_SRV32ADM_05         2085
#define IDS_MFU_SRV32ADM_06         2086
#define IDS_MFU_SRV32ADM_07         2087
#define IDS_MFU_SRV32ADM_08         2088
#define IDS_MFU_SRV32ADM_09         2089
#define IDS_MFU_SRV32ADM_10         2090
#define IDS_MFU_SRV32ADM_11         2091
#define IDS_MFU_SRV32ADM_12         2092
#define IDS_MFU_SRV32ADM_13         2093
#define IDS_MFU_SRV32ADM_14         2094
#define IDS_MFU_SRV32ADM_15         2095
#define IDS_MFU_SRV64ADM_00         2096
#define IDS_MFU_SRV64ADM_01         2097
#define IDS_MFU_SRV64ADM_02         2098
#define IDS_MFU_SRV64ADM_03         2099
#define IDS_MFU_SRV64ADM_04         2100
#define IDS_MFU_SRV64ADM_05         2101
#define IDS_MFU_SRV64ADM_06         2102
#define IDS_MFU_SRV64ADM_07         2103
#define IDS_MFU_SRV64ADM_08         2104
#define IDS_MFU_SRV64ADM_09         2105
#define IDS_MFU_SRV64ADM_10         2106
#define IDS_MFU_SRV64ADM_11         2107
#define IDS_MFU_SRV64ADM_12         2108
#define IDS_MFU_SRV64ADM_13         2109
#define IDS_MFU_SRV64ADM_14         2110
#define IDS_MFU_SRV64ADM_15         2111

#ifdef DEBUG
#define IDM_SIZEUP              427
#define IDM_SIZEDOWN            428
#endif

#define IDM_RESTORE                 310
#define IDM_MINIMIZE                311
#define IDM_MAXIMIZE                312

// WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! 
// shell\lib\sdspatch\sdmain.cpp has a copy of these IDs!

#define IDM_TRAYCONTEXTFIRST        400
#define IDM_FILERUN                 401
#define IDM_LOGOFF                  402
#define IDM_CASCADE                 403
#define IDM_HORIZTILE               404
#define IDM_VERTTILE                405
#define IDM_DESKTOPARRANGEGRID      406
#define IDM_TOGGLEDESKTOP           407
#define IDM_SETTIME                 408
#define IDM_SUSPEND                 409
#define IDM_EJECTPC                 410
#define IDM_SETTINGSASSIST          411
#define IDM_TASKLIST                412
#define IDM_TRAYPROPERTIES          413

#define IDM_MINIMIZEALL             415
#define IDM_UNDO                    416
#define IDM_RETURN                  417
#define IDM_PRINTNOTIFY_FOLDER      418
#define IDM_MINIMIZEALLHOTKEY       419
#define IDM_SHOWTASKMAN             420

// END WARNING! END WARNING! END WARNING! END WARNING! END WARNING!

#define IDM_NOTIFYCUST              421
#define IDM_UNGROUP                 422

#define IDM_LOCKTASKBAR             424

#define IDM_SEP2                    450

#ifdef WINNT // hydra specific ids
// unused                           5000
#define IDM_MU_SECURITY             5001
#endif

//Start menu IDS have been moved to inc/startids.h, to share with shdocvw.dll
#include <startids.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\startmnu.cpp ===
#include "cabinet.h"
#include "rcids.h"
#include <shguidp.h>
#include <lmcons.h>
#include "bandsite.h"
#include "shellp.h"
#include "shdguid.h"
#include <regstr.h> 
#include "startmnu.h"
#include "trayp.h"      // for WMTRAY_*
#include "tray.h"
#include "util.h"
#include <strsafe.h>

HMENU GetStaticStartMenu(BOOL fEdit);

// *** IUnknown methods ***
STDMETHODIMP CStartMenuHost::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENTMULTI(CStartMenuHost, IOleWindow, IMenuPopup),
        QITABENTMULTI(CStartMenuHost, IDeskBarClient, IMenuPopup),
        QITABENT(CStartMenuHost, IMenuPopup),
        QITABENT(CStartMenuHost, ITrayPriv),
        QITABENT(CStartMenuHost, IShellService),
        QITABENT(CStartMenuHost, IServiceProvider),
        QITABENT(CStartMenuHost, IOleCommandTarget),
        QITABENT(CStartMenuHost, IWinEventHandler),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CStartMenuHost::AddRef ()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CStartMenuHost::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

/*----------------------------------------------------------
Purpose: ITrayPriv::ExecItem method

*/
STDMETHODIMP CStartMenuHost::ExecItem (IShellFolder* psf, LPCITEMIDLIST pidl)
{
    // ShellExecute will display errors (if any). No need
    // to show errors here.
    return SHInvokeDefaultCommand(v_hwndTray, psf, pidl);
}


/*----------------------------------------------------------
Purpose: ITrayPriv::GetFindCM method

*/
STDMETHODIMP CStartMenuHost::GetFindCM(HMENU hmenu, UINT idFirst, UINT idLast, IContextMenu** ppcmFind)
{
    *ppcmFind = SHFind_InitMenuPopup(hmenu, v_hwndTray, TRAY_IDM_FINDFIRST, TRAY_IDM_FINDLAST);
    if(*ppcmFind)
        return NOERROR;
    else
        return E_FAIL;
}


/*----------------------------------------------------------
Purpose: ITrayPriv::GetStaticStartMenu method

*/
STDMETHODIMP CStartMenuHost::GetStaticStartMenu(HMENU* phmenu)
{
    *phmenu = ::GetStaticStartMenu(TRUE);

    if(*phmenu)
        return NOERROR;
    else
        return E_FAIL;
}

// *** IServiceProvider ***
STDMETHODIMP CStartMenuHost::QueryService (REFGUID guidService, REFIID riid, void ** ppvObject)
{
    if(IsEqualGUID(guidService,SID_SMenuPopup))
        return QueryInterface(riid,ppvObject);
    else
        return E_NOINTERFACE;
}


// *** IShellService ***

STDMETHODIMP CStartMenuHost::SetOwner (struct IUnknown* punkOwner)
{
    return E_NOTIMPL;
}


// *** IOleWindow methods ***
STDMETHODIMP CStartMenuHost::GetWindow(HWND * lphwnd)
{
    *lphwnd = v_hwndTray;
    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IMenuPopup::Popup method

*/
STDMETHODIMP CStartMenuHost::Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

*/
STDMETHODIMP CStartMenuHost::OnSelect(DWORD dwSelectType)
{
    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubMenu method

*/

STDMETHODIMP CStartMenuHost::SetSubMenu(IMenuPopup* pmp, BOOL fSet)
{
    if (!fSet)
    {
        Tray_OnStartMenuDismissed();
    }
    return NOERROR;
}


// *** IOleCommandTarget ***
STDMETHODIMP  CStartMenuHost::QueryStatus (const GUID * pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return E_NOTIMPL;
}

STDMETHODIMP  CStartMenuHost::Exec (const GUID * pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (IsEqualGUID(CGID_MENUDESKBAR,*pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case MBCID_GETSIDE:
            pvarargOut->vt = VT_I4;
            pvarargOut->lVal = MENUBAR_TOP;
            break;
        default:
            break;
        }
    }

    return NOERROR;
}

// *** IWinEventHandler ***
STDMETHODIMP CStartMenuHost::OnWinEvent(HWND h, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    //Forward events to the tray winproc?
    return E_NOTIMPL;
}

STDMETHODIMP CStartMenuHost::IsWindowOwner(HWND hwnd)
{
    return E_NOTIMPL;
}

CStartMenuHost::CStartMenuHost() : _cRef(1)
{ 
}


HRESULT StartMenuHost_Create(IMenuPopup** ppmp, IMenuBand** ppmb)
{
    HRESULT hres = E_OUTOFMEMORY;
    IMenuPopup * pmp = NULL;
    IMenuBand * pmb = NULL;

    CStartMenuHost *psmh = new CStartMenuHost();
    if (psmh)
    {
        hres = CoCreateInstance(CLSID_StartMenuBar, NULL, CLSCTX_INPROC_SERVER, 
                                IID_IMenuPopup, (LPVOID*)&pmp);
        if (SUCCEEDED(hres))
        {
            IObjectWithSite* pows;

            hres = pmp->QueryInterface(IID_IObjectWithSite, (void**)&pows);
            if(SUCCEEDED(hres))
            {
                IInitializeObject* pio;

                pows->SetSite(SAFECAST(psmh, ITrayPriv*));

                hres = pmp->QueryInterface(IID_IInitializeObject, (void**)&pio);
                if(SUCCEEDED(hres))
                {
                    hres = pio->Initialize();
                    pio->Release();
                }

                if (SUCCEEDED(hres))
                {
                    IUnknown* punk;

                    hres = pmp->GetClient(&punk);
                    if (SUCCEEDED(hres))
                    {
                        IBandSite* pbs;

                        hres = punk->QueryInterface(IID_IBandSite, (void**)&pbs);
                        if(SUCCEEDED(hres))
                        {
                            DWORD dwBandID;

                            pbs->EnumBands(0, &dwBandID);
                            hres = pbs->GetBandObject(dwBandID, IID_IMenuBand, (void**)&pmb);
                            pbs->Release();
                            // Don't release pmb
                        }
                        punk->Release();
                    }
                }

                if (FAILED(hres))
                    pows->SetSite(NULL);

                pows->Release();
            }

            // Don't release pmp
        }
        psmh->Release();
    }

    if (FAILED(hres))
    {
        ATOMICRELEASE(pmp);
        ATOMICRELEASE(pmb);
    }

    *ppmp = pmp;
    *ppmb = pmb;

    return hres;
}



HRESULT IMenuPopup_SetIconSize(IMenuPopup* pmp,DWORD iIcon)
{
    IBanneredBar* pbb;
    if (pmp == NULL)
        return E_FAIL;

    HRESULT hres = pmp->QueryInterface(IID_IBanneredBar,(void**)&pbb);
    if (SUCCEEDED(hres))
    {
        pbb->SetIconSize(iIcon);
        pbb->Release();
    }
    return hres;
}

void CreateInitialMFU(BOOL fReset);

//
//  "Delayed per-user install".
//
//  StartMenuInit is the value that tells us what version of the shell
//  this user has seen most recently.
//
//  missing = has never run explorer before, or pre-IE4
//  1 = IE4 or later
//  2 = XP or later
//
void HandleFirstTime()
{
    DWORD dwStartMenuInit = 0;
    DWORD cb = sizeof(dwStartMenuInit);
    SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_ADVANCED, TEXT("StartMenuInit"), NULL, &dwStartMenuInit, &cb);

    if (dwStartMenuInit < 2)
    {
        DWORD dwValue;
        switch (dwStartMenuInit)
        {
        case 0: // Upgrade from 0 to latest
            {
                // If this is the first boot of the shell for this user, then we need to see if it's an upgrade.
                // If it is, then we need set the Logoff option.    PM Decision to have a different
                // look for upgraded machines...
                TCHAR szPath[MAX_PATH];
                TCHAR szPathExplorer[MAX_PATH];
                DWORD cbSize = ARRAYSIZE(szPath);
                DWORD dwType;

                // Is this an upgrade (Does WindowsUpdate\UpdateURL Exist?)
                PathCombine(szPathExplorer, REGSTR_PATH_EXPLORER, TEXT("WindowsUpdate"));
                if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, szPathExplorer, TEXT("UpdateURL"),
                        &dwType, szPath, &cbSize) &&
                        szPath[0] != TEXT('\0'))
                {
                    // Yes; Then write the option out to the registry.
                    dwValue = 1;
                    SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_ADVANCED, TEXT("StartMenuLogoff"), REG_DWORD, &dwValue, sizeof(DWORD));
                }
            }

            // FALL THROUGH

        case 1: // Upgrade from 1 to latest
            // User has never seen XP before.
            // PMs in certain groups insist on getting free advertising
            // even on upgrades, so we do it.
            CreateInitialMFU(dwStartMenuInit == 0);

            // FALL THROUGH

        default:
            break;
        }

        // If AuditInProgress is set; that means that we are in the
        // OEM sysprep stage and not running as an end user, in which
        // case don't set the flag saying "don't do this again" because
        // we do want to do this again when the retail end user logs
        // on for the first time.
        //
        // (We need to do all this work even in Audit mode so the OEM
        // gets a warm fuzzy feeling.)

        if (!SHRegGetBoolUSValue(TEXT("System\\Setup"), TEXT("AuditinProgress"), TRUE, FALSE))
        {
            // Mark this so that we know we've been launched once.
            dwValue = 2;
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_ADVANCED, TEXT("StartMenuInit"), REG_DWORD, &dwValue, sizeof(DWORD));
        }
    }
}

BOOL GetLogonUserName(LPTSTR pszUsername, DWORD* pcchUsername)
{
    BOOL fSuccess = FALSE;

    HKEY hkeyExplorer = NULL;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, 0, KEY_QUERY_VALUE, &hkeyExplorer))
    {
        DWORD dwType;
        DWORD dwSize = (*pcchUsername) * sizeof(TCHAR);

        if (ERROR_SUCCESS == RegQueryValueEx(hkeyExplorer, TEXT("Logon User Name"), 0, &dwType,
            (LPBYTE) pszUsername, &dwSize))
        {
            if ((REG_SZ == dwType) && (*pszUsername))
            {
                fSuccess = TRUE;
            }
        }

        RegCloseKey(hkeyExplorer);
    }

    // Fall back on GetUserName if the Logon User Name isn't set.
    if (!fSuccess)
    {
        fSuccess = GetUserName(pszUsername, pcchUsername);

        if (fSuccess)
        {
            CharUpperBuff(pszUsername, 1);
        }
    }

    return fSuccess;
}

BOOL _ShowStartMenuLogoff()
{
    // We want the Logoff menu on the start menu if:
    //  These MUST both be true
    // 1) It's not restricted
    // 2) We have Logged On.
    //  Any of these three.
    // 3) We've Upgraded from IE4 
    // 4) The user has specified that it should be present
    // 5) It's been "Restricted" On.

    // Behavior also depends on whether we are a remote session or not (dsheldon):
    // Remote session: Logoff brings up shutdown dialog
    // Console session: Logoff directly does logoff

    DWORD dwRest = SHRestricted(REST_STARTMENULOGOFF);
    SHELLSTATE ss = {0};

    SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE); // if the new start menu is on, always show logoff

    BOOL fUserWantsLogoff = ss.fStartPanelOn || GetExplorerUserSetting(HKEY_CURRENT_USER, TEXT("Advanced"), TEXT("StartMenuLogoff")) > 0;
    BOOL fAdminWantsLogoff = (BOOL)(dwRest == 2) || SHRestricted(REST_FORCESTARTMENULOGOFF);
    BOOL fIsFriendlyUIActive = IsOS(OS_FRIENDLYLOGONUI);
    BOOL fIsTS = GetSystemMetrics(SM_REMOTESESSION);

    if ((dwRest != 1 && (GetSystemMetrics(SM_NETWORK) & RNC_LOGON) != 0) &&
        ( fUserWantsLogoff || fAdminWantsLogoff || fIsFriendlyUIActive || fIsTS))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL _ShowStartMenuEject()
{
    if(SHRestricted(REST_NOSMEJECTPC))  //Is there a policy restriction?
        return FALSE;
        
    // CanShowEject Queries the user's permission to eject,
    // IsEjectAllowed queries the hardware.
    return SHTestTokenPrivilege(NULL, SE_UNDOCK_NAME) &&
           IsEjectAllowed(FALSE) &&
           !GetSystemMetrics(SM_REMOTESESSION);
}

BOOL _ShowStartMenuRun()
{
    return !IsRestrictedOrUserSetting(HKEY_CURRENT_USER, REST_NORUN, TEXT("Advanced"), TEXT("StartMenuRun"), ROUS_KEYALLOWS | ROUS_DEFAULTALLOW);
}

BOOL _ShowStartMenuHelp()
{
    return !IsRestrictedOrUserSetting(HKEY_CURRENT_USER, REST_NOSMHELP, TEXT("Advanced"), TEXT("NoStartMenuHelp"), ROUS_KEYRESTRICTS | ROUS_DEFAULTALLOW);
}

BOOL _ShowStartMenuShutdown()
{
    return  !SHRestricted(REST_NOCLOSE) &&
            (IsOS(OS_ANYSERVER) ||
                (!GetSystemMetrics(SM_REMOTESESSION) &&
                    (!IsOS(OS_FRIENDLYLOGONUI) || SHTestTokenPrivilege(NULL, SE_SHUTDOWN_NAME))));
    // if friendly logon is active, then don't show shutdown unless they have privileges, since shutdown "only" shuts you down.
    // if they're not using friendly logon ui, then shutdown also contains options to log you off/hibernate, so show it...
}

//  If remote and not disabled by administrator then show "Disconnect".
//  Don't show on Server SKUs because they already have Turn Off Computer.
BOOL _ShowStartMenuDisconnect()
{
    return GetSystemMetrics(SM_REMOTESESSION) &&
           !SHRestricted(REST_NODISCONNECT) &&
           !IsOS(OS_ANYSERVER);
}


BOOL _ShowStartMenuSearch()
{
    return !SHRestricted(REST_NOFIND);
}

HMENU GetStaticStartMenu(BOOL fEdit)
{
#define CITEMSMISSING 4

    HMENU hStartMenu = LoadMenuPopup(MAKEINTRESOURCE(MENU_START));

    // If no editing requested, then we're done, lickity-split
    if (!fEdit)
        return hStartMenu;

    HMENU hmenu;
    UINT iSep2ItemsMissing = 0;

    //
    // Default to the Win95/NT4 version of the Settings menu.
    //

    // Restictions
    if (!_ShowStartMenuRun())
    {
        DeleteMenu(hStartMenu, IDM_FILERUN, MF_BYCOMMAND);
    }

    if (!_ShowStartMenuHelp())
    {
        DeleteMenu(hStartMenu, IDM_HELPSEARCH, MF_BYCOMMAND);
    }


    if (IsRestrictedOrUserSetting(HKEY_LOCAL_MACHINE, REST_NOCSC, TEXT("Advanced"), TEXT("StartMenuSyncAll"), ROUS_KEYALLOWS | ROUS_DEFAULTRESTRICT))
    {
        DeleteMenu(hStartMenu, IDM_CSC, MF_BYCOMMAND);
        iSep2ItemsMissing++;     
    }

    BOOL fIsFriendlyUIActive = IsOS(OS_FRIENDLYLOGONUI);

    if (_ShowStartMenuLogoff())
    {
        UINT idMenuRenameToLogoff = IDM_LOGOFF;

        TCHAR szUserName[200];
        TCHAR szTemp[256];
        TCHAR szMenuText[256];
        DWORD dwSize = ARRAYSIZE(szUserName);
        MENUITEMINFO mii;

        mii.cbSize = sizeof(MENUITEMINFO);
        mii.dwTypeData = szTemp;
        mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_SUBMENU | MIIM_STATE | MIIM_DATA;
        mii.cch = ARRAYSIZE(szTemp);
        mii.hSubMenu = NULL;
        mii.fType = MFT_SEPARATOR;                // to avoid ramdom result.
        mii.dwItemData = 0;

        GetMenuItemInfo(hStartMenu,idMenuRenameToLogoff,MF_BYCOMMAND,&mii);

        if (GetLogonUserName(szUserName, &dwSize))
        {
            if (fIsFriendlyUIActive)
            {
                dwSize = ARRAYSIZE(szUserName);

                if (FAILED(SHGetUserDisplayName(szUserName, &dwSize)))
                {
                    dwSize = ARRAYSIZE(szUserName);
                    GetLogonUserName(szUserName, &dwSize);
                }
            }
            StringCchPrintf(szMenuText,ARRAYSIZE(szMenuText), szTemp, szUserName);
        }
        else if (!LoadString(hinstCabinet, IDS_LOGOFFNOUSER, 
                                          szMenuText, ARRAYSIZE(szMenuText)))
        {
            // mem error, use the current string.
            szUserName[0] = 0;
            StringCchPrintf(szMenuText, ARRAYSIZE(szMenuText), szTemp, szUserName);
        }    

        mii.dwTypeData = szMenuText;
        mii.cch = ARRAYSIZE(szMenuText);
        SetMenuItemInfo(hStartMenu,idMenuRenameToLogoff,MF_BYCOMMAND,&mii);
    }
    else
    {
        DeleteMenu(hStartMenu, IDM_LOGOFF, MF_BYCOMMAND);
        iSep2ItemsMissing++;
    }

    //  If restricted, then user cannot shut down at all.
    //  If friendly UI is active change "Shut Down..." to "Turn Off Computer..."

    if (!_ShowStartMenuShutdown())
    {
        DeleteMenu(hStartMenu, IDM_EXITWIN, MF_BYCOMMAND);
        iSep2ItemsMissing++;     
    }
    else if (fIsFriendlyUIActive)
    {

        //  If the user has the SE_SHUTDOWN_NAME privilege
        //  then rename the menu item.

        if (SHTestTokenPrivilege(NULL, SE_SHUTDOWN_NAME) && !GetSystemMetrics(SM_REMOTESESSION))
        {
            MENUITEMINFO    mii;
            TCHAR           szMenuText[256];

            (int)LoadString(hinstCabinet, IDS_TURNOFFCOMPUTER, szMenuText, ARRAYSIZE(szMenuText));
            ZeroMemory(&mii, sizeof(mii));
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_TYPE;
            mii.fType = MFT_STRING;
            mii.dwTypeData = szMenuText;
            mii.cch = ARRAYSIZE(szMenuText);
            TBOOL(SetMenuItemInfo(hStartMenu, IDM_EXITWIN, FALSE, &mii));
        }

        //  Otherwise delete the menu item.

        else
        {
            DeleteMenu(hStartMenu, IDM_EXITWIN, MF_BYCOMMAND);
            iSep2ItemsMissing++;
        }
    }

    if (!_ShowStartMenuDisconnect())
    {
        DeleteMenu(hStartMenu, IDM_MU_DISCONNECT, MF_BYCOMMAND);
        iSep2ItemsMissing++;     
    }

    if (iSep2ItemsMissing == CITEMSMISSING)
    {
        DeleteMenu(hStartMenu, IDM_SEP2, MF_BYCOMMAND);
    }

    if (!_ShowStartMenuEject())
    {
        DeleteMenu(hStartMenu, IDM_EJECTPC, MF_BYCOMMAND);
    }

    // Setting stuff.
    hmenu = SHGetMenuFromID(hStartMenu, IDM_SETTINGS);
    if (hmenu)
    {
        int iMissingSettings = 0;

#define CITEMS_SETTINGS     5   // Number of items in settings menu

        
        if (SHRestricted(REST_NOSETTASKBAR))
        {
            DeleteMenu(hStartMenu, IDM_TRAYPROPERTIES, MF_BYCOMMAND);
            iMissingSettings++;
        }

        if (SHRestricted(REST_NOSETFOLDERS) || SHRestricted(REST_NOCONTROLPANEL))
        {
            DeleteMenu(hStartMenu, IDM_CONTROLS, MF_BYCOMMAND);

            // For the separator that now on top
            DeleteMenu(hmenu, 0, MF_BYPOSITION);   
            iMissingSettings++;
        }

        if (SHRestricted(REST_NOSETFOLDERS))
        {
            DeleteMenu(hStartMenu, IDM_PRINTERS, MF_BYCOMMAND);
            iMissingSettings++;
        }

        if (SHRestricted(REST_NOSETFOLDERS) || SHRestricted(REST_NONETWORKCONNECTIONS) )
        {
            DeleteMenu(hStartMenu, IDM_NETCONNECT, MF_BYCOMMAND);
            iMissingSettings++;
        }

        if (!SHGetMachineInfo(GMI_TSCLIENT) || SHRestricted(REST_NOSECURITY))
        {
            DeleteMenu(hStartMenu, IDM_MU_SECURITY, MF_BYCOMMAND);
            iMissingSettings++;     
        }

        // Are all the items missing?
        if (iMissingSettings == CITEMS_SETTINGS)
        {
            // Yes; don't bother showing the menu at all
            DeleteMenu(hStartMenu, IDM_SETTINGS, MF_BYCOMMAND);
        }
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("c.fm_rui: Settings menu couldn't be found. Restricted items may not have been removed."));
    }

    // Find menu.
    if (!_ShowStartMenuSearch())
    {
        DeleteMenu(hStartMenu, IDM_MENU_FIND, MF_BYCOMMAND);
    }

    // Documents menu.
    if (SHRestricted(REST_NORECENTDOCSMENU))
    {
        DeleteMenu(hStartMenu, IDM_RECENT, MF_BYCOMMAND);
    }

    // Favorites menu.
    if (IsRestrictedOrUserSetting(HKEY_CURRENT_USER, REST_NOFAVORITESMENU, TEXT("Advanced"), TEXT("StartMenuFavorites"), ROUS_KEYALLOWS | ROUS_DEFAULTRESTRICT))
    {
        DeleteMenu(hStartMenu, IDM_FAVORITES, MF_BYCOMMAND);
    }

    return hStartMenu;
}



//
//  CHotKey class
//


// constructor
CHotKey::CHotKey() : _cRef(1)
{
}


STDMETHODIMP CHotKey::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IShellHotKey))
    {
        *ppvObj = SAFECAST(this, IShellHotKey *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}


STDMETHODIMP_(ULONG) CHotKey::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CHotKey::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT Tray_RegisterHotKey(WORD wHotkey, LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl)
{
    if (wHotkey)
    {
        int i = c_tray.HotkeyAdd(wHotkey, (LPITEMIDLIST)pidlParent, (LPITEMIDLIST)pidl, TRUE);
        if (i != -1)
        {
            // Register in the context of the tray's thread.
            PostMessage(v_hwndTray, WMTRAY_REGISTERHOTKEY, i, 0);
        }
    }
    return S_OK;
}

/*----------------------------------------------------------
Purpose: IShellHotKey::RegisterHotKey method

*/
STDMETHODIMP CHotKey::RegisterHotKey(IShellFolder * psf, LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl)
{
    WORD wHotkey;
    HRESULT hr = S_OK;

    wHotkey = _GetHotkeyFromFolderItem(psf, pidl);
    if (wHotkey)
    {
        hr = ::Tray_RegisterHotKey(wHotkey, pidlParent, pidl);
    }
    return hr;
}

STDAPI CHotKey_Create(IShellHotKey ** ppshk)
{
    HRESULT hres = E_OUTOFMEMORY;
    CHotKey * photkey = new CHotKey;

    if (photkey)
    {
        hres = S_OK;
    }

    *ppshk = SAFECAST(photkey, IShellHotKey *);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\ssomgr.h ===
#ifndef _SHSRVOBJ_H
#define _SHSRVOBJ_H

#include "dpa.h"

//
// class to manage shell service objects
//

typedef struct
{
    CLSID              clsid;
    IOleCommandTarget* pct;
}
SHELLSERVICEOBJECT, *PSHELLSERVICEOBJECT;


class CShellServiceObjectMgr
{
public:
    HRESULT Init();
    void Destroy();
    HRESULT LoadRegObjects();
    HRESULT EnableObject(const CLSID *pclsid, DWORD dwFlags);

    virtual ~CShellServiceObjectMgr();

private:
    static int WINAPI DestroyItemCB(SHELLSERVICEOBJECT *psso, CShellServiceObjectMgr *pssomgr);
    HRESULT _LoadObject(REFCLSID rclsid, DWORD dwFlags);
    int _FindItemByCLSID(REFCLSID rclsid);

    static BOOL WINAPI EnumRegAppProc(LPCTSTR pszSubkey, LPCTSTR pszCmdLine, RRA_FLAGS fFlags, LPARAM lParam);

    CDSA<SHELLSERVICEOBJECT> _dsaSSO;
};

#endif  // _SHSRVOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\srcc.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\explorer\explorer.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\explorer\explorer.inc

NO_BROWSER_FILE = 1
USE_STATIC_ATL  = 1
USE_WTL         = 1
WTL_VER         =10

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

DELAYLOAD       = setupapi.dll;winsta.dll;winmm.dll;oleacc.dll;userenv.dll
DLOAD_ERROR_HANDLER = kernel32

INCLUDES        = $(INCLUDES);$(O);$(INETCORE_INC_PATH);$(DS_INC_PATH);$(MULTIMEDIA_INC_PATH)

TARGETNAME      = explorer
TARGETPATH      = obj
TARGETTYPE      = PROGRAM

TARGETLIBS      = $(LIBRARY_PLATFORM_PATH)\*\gdi32.lib      \
                  $(LIBRARY_PLATFORM_PATH)\*\kernel32.lib   \
                  $(LIBRARY_PLATFORM_PATH)\*\kernl32p.lib   \
                  $(SDK_LIB_PATH)\ntdll.lib                 \
                  $(WINDOWS_LIB_PATH)\user32p.lib           \
                  $(SDK_LIB_PATH)\advapi32.lib              \
                  $(SDK_LIB_PATH)\mpr.lib                   \
                  $(SDK_LIB_PATH)\psapi.lib                 \
                  $(SHELL_LIB_PATH)\shlwapip.lib            \
                  $(SDK_LIB_PATH)\uuid.lib                  \
                  $(SHELL_LIB_PATH)\shell32p.lib            \
                  $(CCSHELL_DIR)\lib\$(O)\shguid.lib        \
                  $(CCSHELL_DIR)\lib\$(O)\shguidp.lib       \
                  $(CCSHELL_DIR)\lib\$(O)\ieguidp.lib       \
                  $(SDK_LIB_PATH)\ole32.lib                 \
                  $(SDK_LIB_PATH)\oleaut32.lib              \
                  $(SDK_LIB_PATH)\winmm.lib                 \
                  $(SHELL_LIB_PATH)\shdocvw.lib             \
                  $(CCSHELL_DIR)\lib\$(O)\browseui.lib      \
                  $(CCSHELL_DIR)\lib\$(O)\browseuip.lib     \
                  $(SHELL_LIB_PATH)\shdocvwp.lib            \
                  $(SDK_LIB_PATH)\uxtheme.lib               \
                  $(SHELL_LIB_PATH)\uxthemep.lib            \
                  $(SDK_LIB_PATH)\setupapi.lib              \
                  $(CCSHELL_DIR)\lib\$(O)\shfusion.lib      \
                  $(CCSHELL_DIR)\lib\$(O)\stock.lib         \
                  $(SDK_LIB_PATH)\winsta.lib                \
                  $(SDK_LIB_PATH)\oleacc.lib                \
                  $(DS_LIB_PATH)\msgina.lib                 \
                  $(SDK_LIB_PATH)\userenv.lib               \
                  $(SDK_LIB_PATH)\dxguid.lib                  \
                  $(SDK_LIB_PATH)\strsafe.lib               \
                  ..\desktop2\$(O)\dv2host.lib


USE_MSVCRT      = 1

UMENTRYABS      = ModuleEntry

SOURCES         = ..\explorer.rc    \
                  ..\bandsite.cpp   \
                  ..\classfac.cpp   \
                  ..\debug.cpp      \
                  ..\dllload.c      \
                  ..\initcab.cpp    \
                  ..\libx.cpp       \
                  ..\mixer.cpp      \
                  ..\muext.c        \
                  ..\ssomgr.cpp     \
                  ..\startmnu.cpp   \
                  ..\taskband.cpp   \
                  ..\taskbar.cpp    \
                  ..\tray.cpp       \
                  ..\trayclok.cpp   \
                  ..\traycmn.cpp    \
                  ..\trayitem.cpp   \
                  ..\trayreg.cpp    \
                  ..\traynot.cpp    \
                  ..\trayprop.cpp   \
                  ..\util.cpp

PRECOMPILED_INCLUDE = ..\cabinet.h
 
# 
# Fusionized
# 
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=WindowsShell.manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\startmnu.h ===
#ifndef _STARTMNU_H
#define _STARTMNU_H

//--------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

#define SBM_CANCELMENU                (WM_USER + 12)
#define SBM_REBUILDMENU               (WM_USER + 13)


HRESULT StartMenuHost_Create(IMenuPopup** ppmp, IMenuBand** ppmb);
HRESULT IMenuPopup_SetIconSize(IMenuPopup* punk,DWORD iIcon);

STDAPI  CHotKey_Create(IShellHotKey ** ppshk);

#ifdef __cplusplus

BOOL _ShowStartMenuLogoff();
BOOL _ShowStartMenuRun();
BOOL _ShowStartMenuEject();
BOOL _ShowStartMenuHelp();
BOOL _ShowStartMenuShutdown();
BOOL _ShowStartMenuDisconnect();
BOOL _ShowStartMenuSearch();

class CStartMenuHost : public ITrayPriv,
                        public IServiceProvider,
                        public IShellService,
                        public IMenuPopup,
                        public IOleCommandTarget,
                        public IWinEventHandler

{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();

    // *** ITrayPriv methods ***
    STDMETHODIMP ExecItem (IShellFolder* psf, LPCITEMIDLIST pidl);
    STDMETHODIMP GetFindCM(HMENU hmenu, UINT idFirst, UINT idLast, IContextMenu** ppcmFind);
    STDMETHODIMP GetStaticStartMenu(HMENU* phmenu);

    // *** IServiceProvider ***
    STDMETHODIMP QueryService (REFGUID guidService, REFIID riid, void ** ppvObject);

    // *** IShellService ***
    STDMETHODIMP SetOwner (struct IUnknown* punkOwner);

    // *** IOleWindow methods ***
    STDMETHODIMP GetWindow         (HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp  (THIS_ BOOL fEnterMode) { return E_NOTIMPL; }

    // *** IDeskBarClient methods ***
    STDMETHODIMP SetClient         (IUnknown* punkClient) { return E_NOTIMPL; }
    STDMETHODIMP GetClient         (IUnknown** ppunkClient) { return E_NOTIMPL; }
    STDMETHODIMP OnPosRectChangeDB (LPRECT prc) { return E_NOTIMPL; }

    // *** IMenuPopup methods ***
    STDMETHODIMP Popup             (POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);
    STDMETHODIMP OnSelect          (DWORD dwSelectType);
    STDMETHODIMP SetSubMenu        (IMenuPopup* pmp, BOOL fSet);

    // *** IOleCommandTarget ***
    STDMETHODIMP QueryStatus(const GUID * pguidCmdGroup,
                             ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID * pguidCmdGroup,
                             DWORD nCmdID, DWORD nCmdexecopt, 
                             VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IWinEventHandler ***
    STDMETHODIMP OnWinEvent(HWND h, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    STDMETHODIMP IsWindowOwner (HWND hwnd);

    // *** IBanneredBar ***

protected:
    CStartMenuHost();

    friend HRESULT StartMenuHost_Create(IMenuPopup** ppmp, IMenuBand** ppmb);

    int    _cRef;
};


class CHotKey : public IShellHotKey
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();

    // *** IShellHotKey methods ***
    STDMETHODIMP RegisterHotKey(IShellFolder * psf, LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl);

protected:
    CHotKey();
    
    friend HRESULT CHotKey_Create(IShellHotKey ** ppshk);

    int    _cRef;
};

#endif //C++

#ifdef WINNT // hydra specific functions
STDAPI_(void) MuSecurity(void);
#endif

#endif //_START_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\ssomgr.cpp ===
#include "cabinet.h"
#include "tray.h"
#include "ssomgr.h"
#include <regstr.h>

HRESULT CShellServiceObjectMgr::_LoadObject(REFCLSID rclsid, DWORD dwFlags)
{
    ASSERT(dwFlags & LIPF_ENABLE);

    HRESULT hr = E_FAIL;

    if (dwFlags & LIPF_HOLDREF)
    {
        if (_dsaSSO)
        {
            SHELLSERVICEOBJECT sso = {0};
            sso.clsid = rclsid;

            // SECURITY: this clsid was given to us by another application and we are pulling them into
            // our process
            hr = CoCreateInstance(rclsid, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
                                    IID_PPV_ARG(IOleCommandTarget, &sso.pct));

            if (SUCCEEDED(hr))
            {
                if (_dsaSSO.AppendItem(&sso) != -1)
                {
                    sso.pct->Exec(&CGID_ShellServiceObject, SSOCMDID_OPEN, 0, NULL, NULL);
                }
                else
                {
                    sso.pct->Release();
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    else
    {
        // just ask for IUnknown for these dudes
        IUnknown *punk;
        hr = CoCreateInstance(rclsid, NULL, CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER,
                                IID_PPV_ARG(IUnknown, &punk));
        if (SUCCEEDED(hr))
        {
            punk->Release();
        }
    }

    return hr;
}

// The following code manages shell service objects.  We load inproc dlls
// from the registry key and QI them for IOleCommandTarget. Note that all
// Shell Service Objects are loaded on the desktop thread.
// CGID_ShellServiceObject notifications are sent to these objects letting
// them know about shell status.

STDAPI_(BOOL) CShellServiceObjectMgr::EnumRegAppProc(LPCTSTR pszSubkey, LPCTSTR pszCmdLine, RRA_FLAGS fFlags, LPARAM lParam)
{
    CShellServiceObjectMgr* pssomgr = (CShellServiceObjectMgr*)lParam;

    CLSID clsid;
    HRESULT hr = SHCLSIDFromString(pszCmdLine, &clsid);
    if (SUCCEEDED(hr))
    {
        hr = pssomgr->_LoadObject(clsid, LIPF_ENABLE | LIPF_HOLDREF);
    }

    if (FAILED(hr))
    {
        c_tray.LogFailedStartupApp();
    }

    return SUCCEEDED(hr);
}

HRESULT CShellServiceObjectMgr::LoadRegObjects()
{
    Cabinet_EnumRegApps(HKEY_LOCAL_MACHINE, REGSTR_PATH_SHELLSERVICEOBJECTDELAYED, 0,
                            EnumRegAppProc, (LPARAM)this);
    Cabinet_EnumRegApps(HKEY_CURRENT_USER, REGSTR_PATH_SHELLSERVICEOBJECTDELAYED, 0,
                            EnumRegAppProc, (LPARAM)this);

    return S_OK;
}

HRESULT CShellServiceObjectMgr::EnableObject(const CLSID *pclsid, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;

    if (dwFlags & LIPF_ENABLE)
    {
        hr = _LoadObject(*pclsid, dwFlags);
    }
    else
    {
        int i = _FindItemByCLSID(*pclsid);
        if (i != -1)
        {
            PSHELLSERVICEOBJECT psso = _dsaSSO.GetItemPtr(i);

            DestroyItemCB(psso, this);
            _dsaSSO.DeleteItem(i);

            hr = S_OK;
        }
    }

    return hr;
}

int CShellServiceObjectMgr::_FindItemByCLSID(REFCLSID rclsid)
{
    if (_dsaSSO)
    {
        for (int i = _dsaSSO.GetItemCount() - 1; i >= 0; i--)
        {
            PSHELLSERVICEOBJECT psso = _dsaSSO.GetItemPtr(i);
            if (IsEqualCLSID(psso->clsid, rclsid))
            {
                return i;
            }
        }
    }
    return -1;
}

HRESULT CShellServiceObjectMgr::Init()
{
    ASSERT(!_dsaSSO);
    return _dsaSSO.Create(2) ? S_OK : E_FAIL;
}

CShellServiceObjectMgr::~CShellServiceObjectMgr()
{
    Destroy();
}

int WINAPI CShellServiceObjectMgr::DestroyItemCB(SHELLSERVICEOBJECT *psso, CShellServiceObjectMgr *pssomgr)
{
    psso->pct->Exec(&CGID_ShellServiceObject, SSOCMDID_CLOSE, 0, NULL, NULL);
    psso->pct->Release();
    return 1;
}

void CShellServiceObjectMgr::Destroy()
{
    if (_dsaSSO)
    {
        _dsaSSO.DestroyCallbackEx<CShellServiceObjectMgr*>(DestroyItemCB, this);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\taskband.h ===
#ifndef TASKBAND_H_
#define TASKBAND_H_

#ifdef __cplusplus

#include "atlstuff.h"
#include "cwndproc.h"
#include <dpa.h>
#include "commoncontrols.h"

class CTray;
class CGroupItemContextMenu;

class TASKITEM
{
public:
    TASKITEM() {};
    TASKITEM(TASKITEM* pti);
    ~TASKITEM();
    HWND hwnd;  // NULL if this item is a group of application entries
    DWORD dwFlags;
    class TaskShortcut *ptsh;
    DWORD dwTimeLastClicked;
    DWORD dwTimeFirstOpened;
    WCHAR* pszExeName;
    int iIconPref;
    BOOL fMarkedFullscreen;
    BOOL fHungApp;
};

typedef TASKITEM *PTASKITEM;

typedef struct
{
    PTASKITEM   pti; 
    UINT        fState;
    int         iIndex; // used to cache toolbar index
}
ANIMATIONITEMINFO, *PANIMATIONITEMINFO;

class CTaskBandSMC;

class CTaskBand : public IDeskBand
                , public IObjectWithSite
                , public IDropTarget
                , public IInputObject
                , public IPersistStream
                , public IWinEventHandler
                , public IOleCommandTarget
                , public CImpWndProc
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IOleWindow methods ***
    STDMETHODIMP GetWindow(HWND * lphwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode)  { return E_NOTIMPL; }

    // *** IDockingWindow methods ***
    STDMETHODIMP ShowDW(BOOL fShow)         { return S_OK; }
    STDMETHODIMP CloseDW(DWORD dwReserved)  { return S_OK; }
    STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved) { return E_NOTIMPL; }

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown* punkSite);
    STDMETHODIMP GetSite(REFIID riid, void** ppvSite) { return E_NOTIMPL; };

    // *** IDeskBand methods ***
    STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi);

    // *** IDropTarget methods ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** IInputObject methods ***
    STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg) { return E_NOTIMPL; }
    STDMETHODIMP HasFocusIO();
    STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);

    // *** IWinEventHandler methods ***
    STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IPersistStream methods ***
    STDMETHODIMP GetClassID(LPCLSID pClassID);
    STDMETHODIMP IsDirty(void)                  { return S_FALSE; }
    STDMETHODIMP Load(IStream *ps);
    STDMETHODIMP Save(LPSTREAM, BOOL)           { return S_OK; }
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER*)    { return E_NOTIMPL; }

    // *** IOleCommandTarget methods ***
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

protected:
    static void IconAsyncProc(HWND hwnd, UINT uMsg, ULONG_PTR dwData, LRESULT lResult);

    typedef struct
    {
        HWND hwnd;
        LPTSTR pszExeName;
        int iImage;
    }
    ICONCBPARAM, *PICONCBPARAM;

    typedef int (*PICONCALLBACK)(CTaskBand* ptb, PICONCBPARAM pip, LPARAM lParam, int iPref);

    static int GetIconCB(CTaskBand* ptb, PICONCBPARAM pip, LPARAM lParam, int iPref);
    static int GetSHILIconCB(CTaskBand* ptb, PICONCBPARAM pip, LPARAM lParam, int);
    static int GetDefaultIconCB(CTaskBand* ptb, PICONCBPARAM pip, LPARAM, int);
    static int GetClassIconCB(CTaskBand* ptb, PICONCBPARAM pip, LPARAM lParam, int);
    
    void _MoveGroup(HWND hwnd, WCHAR* szNewExeName);
    void _SetWindowIcon(HWND hwnd, HICON hicon, int iPref);
    static BOOL _ShouldMinimize(HWND hwnd);
    BOOL _CanMinimizeAll();
    BOOL _MinimizeAll(HWND hwndTray, BOOL fPostRaiseDesktop);
    int _HitTest(POINTL ptl);
    void _FreePopupMenu();

    void _RealityCheck();
    int  _FindIndexByHwnd(HWND hwnd);
    void _CheckNeedScrollbars(int cyRow, int cItems, int iCols, int iRows,
                                     int iItemWidth, LPRECT lprcView);
    void _NukeScrollbar(int fnBar);
    void _SetItemWidth(int iItem, int iWidth);
    int  _GetItemWidth(int iItem);
    int  _GetLastVisibleItem();
    int  _GetVisibleItemCount();
    int  _GetGroupWidth(int iIndexGroup);
    int  _GetIdealWidth(int *iRemainder);
    void _GetNumberOfRowsCols(int* piRows, int* piCols, BOOL fCurrentSize);
    int  _GetTextSpace();
    void _GetToolbarMetrics(LPTBMETRICS ptbm);
    void _CheckSize(void);
    void _SizeItems(int iButtonWidth, int iRemainder = 0);
    BOOL _AddWindow(HWND hwnd);
    BOOL _CheckButton(int iIndex, BOOL fCheck);
    BOOL _IsButtonChecked(int iIndex);
    int  _GetCurSel();
    void _SetCurSel(int iIndex, BOOL fIgnoreCtrlKey);
    int  _SelectWindow(HWND hwnd);
    void _SwitchToWindow(HWND hwnd);

    int  _GetSelectedItems(CDSA<PTASKITEM>* pdsa);
    int  _GetGroupItems(int iIndexGroup, CDSA<PTASKITEM>* pdsa);
    void _OnGroupCommand(int iRet, CDSA<PTASKITEM>* pdsa);
    void _SysMenuForItem(int i, int x, int y);
    static void CALLBACK FakeSystemMenuCB(HWND hwnd, UINT uMsg, ULONG_PTR dwData, LRESULT lres);
    HWND _CreateFakeWindow(HWND hwndOwner);
    void _HandleSysMenuTimeout();
    void _HandleSysMenu(HWND hwnd);
    void _FakeSystemMenu(HWND hwndTask, DWORD dwPos);
    BOOL _ContextMenu(DWORD dwPos);

    void _HandleCommand(WORD wCmd, WORD wID, HWND hwnd);
    void _DrawNumber(HDC hdc, int iValue, BOOL fCalcRect, LPRECT prc);
    LRESULT _HandleCustomDraw(LPNMTBCUSTOMDRAW ptbcd, PTASKITEM pti = NULL);
    void _RemoveImage(int iImage);
    void _OnButtonPressed(int iIndex, PTASKITEM pti, BOOL fForceRestore);
    LRESULT _HandleNotify(LPNMHDR lpnm);
    void _SwitchToItem(int iItem, HWND hwnd, BOOL fIgnoreCtrlKey);
    LRESULT _HandleCreate();
    LRESULT _HandleDestroy();
    LRESULT _HandleScroll(BOOL fHoriz, UINT code, int nPos);
    void _ScrollIntoView(int iItem);
    LRESULT _HandleSize(WPARAM fwSizeType);
    LRESULT _HandleActivate(HWND hwndActive);
    void _UpdateItemUsage(PTASKITEM pti);
    void _HandleOtherWindowDestroyed(HWND hwndDestroyed);
    void _HandleGetMinRect(HWND hwndShell, LPPOINTS lprc);
    void _HandleChangeNotify(WPARAM wParam, LPARAM lParam);
    LRESULT _HandleHardError(HARDERRORDATA *phed, DWORD cbData);
    BOOL _IsItemActive(HWND hwndActive);
    void _CreateTBImageLists();
    int _AddIconToNormalImageList(HICON hicon, int iImage);

    void _UpdateItemText(int iItem);
    void _UpdateItemIcon(int iItem);
    void _GetDispInfo(LPNMTBDISPINFO lptbdi);

    void _DoRedrawWhereNeeded();
    void _RedrawItem(HWND hwndShell, WPARAM code, int i = -1);
    void _SetActiveAlt(HWND hwndAlt);
    HWND _EnumForRudeWindow(HWND hwndSelected);
    HWND _FindRudeApp(HWND hwndPossible);
    LRESULT _OnAppCommand(int cmd);
    PTASKITEM _FindItemByHwnd(HWND hwnd);
    void _OnWindowActivated(HWND hwnd, BOOL fSuspectFullscreen);
    LRESULT _HandleShellHook(int iCode, LPARAM lParam);
    void _VerifyButtonHeight();
    void _InitFonts();
    void _SetItemImage(int iItem, int iImage, int iPref);
    void _UpdateAllIcons();
    LRESULT _HandleWinIniChange(WPARAM wParam, LPARAM lParam, BOOL fOnCreate);
    void _OnSetFocus();
    BOOL _RegisterWindowClass();
    void _UpdateFlashingFlag();
    void _ExecuteMenuOption(HWND hwnd, int iCmd);
    TASKITEM* _GetItem(int i, TBBUTTONINFO* ptbb = NULL, BOOL fByIndex = TRUE);

    static BOOL WINAPI BuildEnumProc(HWND hwnd, LPARAM lParam);
    static BOOL WINAPI IsRudeEnumProc(HWND hwnd, LPARAM lParam);
    static DWORD WINAPI MinimizeAllThreadProc(LPVOID lpv);
    void _OpenTheme();

    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    int _GetGroupSize(int iIndexGroup);
    int _GetGroupIndex(int iIndexApp);
    DWORD _GetGroupAge(int iIndexGroup);
    int _GetGroupIndexFromExeName(WCHAR* szExeName);

    BOOL _IsHidden(int i);
    void _GetItemTitle(int iIndex, WCHAR* pszTitle, int cbTitle, BOOL fCustom);
    void _RefreshSettings();
    void _LoadSettings();
    void _Glom(int iIndexGroup, BOOL fGlom);
    void _HideGroup(int iIndexGroup, BOOL fHide);
    BOOL _AutoGlomGroup(BOOL fGlom, int iOpenSlots);
    void _DeleteTaskItem(int index, BOOL fDeletePTI);
    void _RealityCheckGroup(PTASKITEM pti);
    HRESULT _CreatePopupMenu(POINTL* ppt, RECTL* prcl);
    void _AddItemToDropDown(int iIndex);
    void _RemoveItemFromDropDown(int iIndex);
    void _RefreshItemFromDropDown(int iIndex, int iNewIndex, BOOL fRefresh);
    void _ClosePopupMenus();
    void _HandleDropDown(int index);
    void _UpdateProgramCount();
    BOOL _AddToTaskbar(PTASKITEM pti, int indexTaskbar, BOOL fVisible, BOOL fForceGetIcon);
    BOOL _InsertItem(HWND hwndTask, PTASKITEM ptiOveride = NULL, BOOL fForceGetIcon = FALSE);
    void _DeleteItem(HWND hWnd, int index = -1);
    void _AttachTaskShortcut(PTASKITEM pti, LPCTSTR pszExeName);
    void _ReattachTaskShortcut();
    void _BuildTaskList(CDPA<TASKITEM>* pDPA);

    // *** Async-Animation 
    BOOL _fAnimate;
    CDSA<ANIMATIONITEMINFO> _dsaAII;

    // animation methods
    BOOL _AnimateItems(int iIndex, BOOL fExpand, BOOL fGlomAnimation);
    void _AsyncAnimateItems();
    void _ResizeAnimationItems();
    int  _CheckAnimationSize();
    void _SizeNonAnimatingItems();

    // animation helpers
    void  _UpdateAnimationIndices();
    void  _UpdateAnimationIndicesSlow();
    int   _FindItem(PTASKITEM pti);
    void  _RemoveItemFromAnimationList(PTASKITEM ptiRemove);
    void  _SetAnimationState(PANIMATIONITEMINFO paii, BOOL fExpand, BOOL fGlomAnimation);
    int   _GetAnimationInsertPos(int iIndex);
    void  _SetAnimationItemWidth(PANIMATIONITEMINFO paii, int cxStep);
    int   _GetAnimationDistLeft(PANIMATIONITEMINFO paii, int iNormalWidth);
    void  _FinishAnimation(PANIMATIONITEMINFO paii);
    int   _GetAnimationWidth();
    int   _GetAnimationStep();
    DWORD _GetStepTime(int iStep);
    int _GetCurButtonHeight();

    void _SetThreadPriority(int iPriority, DWORD dwWakeupTime);
    void _RestoreThreadPriority();

    BOOL _IsHorizontal() { return !(_dwViewMode & DBIF_VIEWMODE_VERTICAL); }

    BOOL _fGlom;
    int _iGroupSize;
    CToolBarCtrl _tb;
    UINT WM_ShellHook;
    int _iSysMenuCount;
    int _iIndexActiveAtLDown;
    HWND    _hwndSysMenu;
    HWND    _hwndLastRude;
    HWND    _hwndPrevFocus;
    HWND    _hwndReplacing;
    BOOL _fIgnoreTaskbarActivate;
    BOOL _fFlashing;
    BOOL _fDenyHotItemChange;
    CTray* _ptray;
    HFONT _hfontSave;
    int _iTextSpace;
    DWORD _dwPos;
    DWORD _dwViewMode;
    HFONT _hfontCapNormal;
    HFONT _hfontCapBold;
    HTHEME _hTheme;
    int _iOldPriority;
    int _iNewPriority;

    ULONG _cRef;

    // Drag & drop stuff
    int _iDropItem;
    DWORD _dwTriggerStart;
    DWORD _dwTriggerDelay;

    // Variables for the ASYNC popup menu
    IShellMenu2* _psmPopup;
    IMenuPopup* _pmpPopup;
    IMenuBand*  _pmbPopup;
    int         _iIndexPopup;
    int         _iIndexLastPopup;
    CMenu       _menuPopup;

    IImageList* _pimlSHIL;

    // Rarely-used stuff
    ULONG       _uShortcutInvokeNotify;
    UINT        _uCDHardError;

        
    CTaskBand();
    ~CTaskBand();
    HRESULT Init(CTray* ptray);

    HRESULT _BandInfoChanged();

    DWORD _dwBandID;

    IUnknown *  _punkSite;

    friend HRESULT CTaskBand_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk);
    friend class CTaskBandSMC;
};

#endif  // __cplusplus

#endif //TASKBAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\taskbar.cpp ===
#include "cabinet.h"
#include "taskbar.h"
#include "bandsite.h"
#include "rcids.h"
#include "tray.h"


CSimpleOleWindow::~CSimpleOleWindow()
{
}

CSimpleOleWindow::CSimpleOleWindow(HWND hwnd) : _cRef(1), _hwnd(hwnd)
{
}

ULONG CSimpleOleWindow::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CSimpleOleWindow::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CSimpleOleWindow::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IOleWindow))
    {
        *ppvObj = SAFECAST(this, IOleWindow*);
    } 
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        
    }
    
    AddRef();
    return S_OK;
}


HRESULT CSimpleOleWindow::GetWindow(HWND * lphwnd) 
{
    *lphwnd = _hwnd; 
    if (_hwnd)
        return S_OK; 
    return E_FAIL;
        
}


CTaskBar::CTaskBar() : CSimpleOleWindow(v_hwndTray)
{
    _fRestrictionsInited = FALSE;
}


HRESULT CTaskBar::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CTaskBar, IContextMenu),
        QITABENT(CTaskBar, IServiceProvider),
        QITABENT(CTaskBar, IRestrict),
        QITABENT(CTaskBar, IDeskBar),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
    {
        return CSimpleOleWindow::QueryInterface(riid, ppvObj);
    }

    return S_OK;
}

HRESULT CTaskBar::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    int idCmd = -1;

    if (IS_INTRESOURCE(pici->lpVerb))
        idCmd = LOWORD(pici->lpVerb);

    c_tray.ContextMenuInvoke(idCmd);

    return S_OK;
}

HRESULT CTaskBar::GetCommandString(UINT_PTR idCmd,
                            UINT        uType,
                            UINT      * pwReserved,
                            LPSTR       pszName,
                            UINT        cchMax)
{
    return E_NOTIMPL;
}


HRESULT CTaskBar::QueryContextMenu(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags)
{
    int i = 0;
    HMENU hmenuSrc = c_tray.BuildContextMenu(FALSE);

    if (hmenuSrc)
    {
        //
        // We know that the tray context menu commands start at IDM_TRAYCONTEXTFIRST, so we
        // can get away with passing the same idCmdFirst to each merge.
        //
        i = Shell_MergeMenus(hmenu, hmenuSrc, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR) - idCmdFirst;
        DestroyMenu(hmenuSrc);

        BandSite_AddMenus(c_tray._ptbs, hmenu, indexMenu, idCmdFirst, idCmdFirst + (IDM_TRAYCONTEXTFIRST - 1));
    }

    return i;
}


// *** IServiceProvider ***
HRESULT CTaskBar::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (ppvObj)
        *ppvObj = NULL;

    if (IsEqualGUID(guidService, SID_SRestrictionHandler))
    {
        return QueryInterface(riid, ppvObj);
    }

    return E_FAIL;
}


// *** IRestrict ***
HRESULT CTaskBar::IsRestricted(const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, DWORD * pdwRestrictionResult)
{
    HRESULT hr = S_OK;

    if (!EVAL(pguidID) || !EVAL(pdwRestrictionResult))
        return E_INVALIDARG;

    *pdwRestrictionResult = RR_NOCHANGE;
    if (IsEqualGUID(RID_RDeskBars, *pguidID))
    {
        if (!_fRestrictionsInited)
        {
            _fRestrictionsInited = TRUE;
            if (SHRestricted(REST_NOCLOSE_DRAGDROPBAND))
                _fRestrictDDClose = TRUE;
            else
                _fRestrictDDClose = FALSE;

            if (SHRestricted(REST_NOMOVINGBAND))
                _fRestrictMove = TRUE;
            else
                _fRestrictMove = FALSE;
        }

        switch(dwRestrictAction)
        {
        case RA_DRAG:
        case RA_DROP:
        case RA_ADD:
        case RA_CLOSE:
            if (_fRestrictDDClose)
                *pdwRestrictionResult = RR_DISALLOW;
            break;
        case RA_MOVE:
            if (_fRestrictMove)
                *pdwRestrictionResult = RR_DISALLOW;
            break;
        }
    }

    // TODO: If we have or get a parent, we should ask them if they want to restrict.
//    if (RR_NOCHANGE == *pdwRestrictionResult)    // If we don't handle it, let our parents have a wack at it.
//        hr = IUnknown_HandleIRestrict(_punkParent, pguidID, dwRestrictAction, pvarArgs, pdwRestrictionResult);

    return hr;
}

// *** IDeskBar ***
HRESULT CTaskBar::OnPosRectChangeDB(LPRECT prc)
{
    // if we haven't fully initialized the tray, don't resize in response to (bogus) rebar sizes
    // OR we're in the moving code, don't do this stuff..
    if (!c_tray._hbmpStartBkg || c_tray._fDeferedPosRectChange) 
    {
        return S_FALSE;
    }

    BOOL fHiding = (c_tray._uAutoHide & AH_HIDING);

    if (fHiding) 
    {
        c_tray.InvisibleUnhide(FALSE);
    }

    if ((c_tray._uAutoHide & (AH_ON | AH_HIDING)) != (AH_ON | AH_HIDING))
    {
        // during 'bottom up' resizes (e.g. isfband View.Large), we don't
        // get WM_ENTERSIZEMOVE/WM_EXITSIZEMOVE.  so we send it here.
        // this fixes two bugs:
        // - nt5:168643: btm-of-screen on-top tray mmon clipping not updated
        // after view.large
        // - nt5:175287: top-of-screen on-top tray doesn't resize workarea
        // (obscuring top of 'my computer' icon) after view.large
        if (!g_fInSizeMove)
        {
            c_tray._fSelfSizing = TRUE;
            RECT rc;
            GetWindowRect(v_hwndTray, &rc);
            SendMessage(v_hwndTray, WM_SIZING, WMSZ_TOP, (LPARAM)&rc);
            SetWindowPos(v_hwndTray, NULL, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, SWP_NOZORDER | SWP_NOACTIVATE);
            c_tray._fSelfSizing = FALSE;
        }
    }

    if (fHiding) 
    {
        c_tray.InvisibleUnhide(TRUE);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\taskband.cpp ===
#include "cabinet.h"
#include "taskband.h"
#include <shguidp.h>
#include "bandsite.h"
#include "util.h"
#include "tray.h"
#include "rcids.h"
#include "bandsite.h"
#include "startmnu.h"
#include "mixer.h"
#include <regstr.h>
#include "uemapp.h"
#include "strsafe.h"

#define TIF_RENDERFLASHED       0x000000001
#define TIF_SHOULDTIP           0x000000002
#define TIF_ACTIVATEALT         0x000000004
#define TIF_EVERACTIVEALT       0x000000008
#define TIF_FLASHING            0x000000010
#define TIF_TRANSPARENT         0x000000020
#define TIF_CHECKED             0x000000040
#define TIF_ISGLOMMING          0x000000080
#define TIF_NEEDSREDRAW         0x000000100


#define IDT_SYSMENU             2
#define IDT_ASYNCANIMATION      3
#define IDT_REDRAW              4
#define IDT_RECHECKRUDEAPP1     5
#define IDT_RECHECKRUDEAPP2     6
#define IDT_RECHECKRUDEAPP3     7
#define IDT_RECHECKRUDEAPP4     8
#define IDT_RECHECKRUDEAPP5     9

#define TIMEOUT_SYSMENU         2000
#define TIMEOUT_SYSMENU_HUNG    125

#define GLOM_OLDEST             0
#define GLOM_BIGGEST            1
#define GLOM_SIZE               2

#define ANIMATE_INSERT          0
#define ANIMATE_DELETE          1
#define ANIMATE_GLOM            2

#define IL_NORMAL   0
#define IL_SHIL     1

#define MAX_WNDTEXT     80      // arbitrary, matches NMTTDISPINFO.szText

#define INVALID_PRIORITY        (THREAD_PRIORITY_LOWEST - 1)

const TCHAR c_szTaskSwClass[] = TEXT("MSTaskSwWClass");
const TCHAR c_wzTaskBandTheme[] = TEXT("TaskBand");
const TCHAR c_wzTaskBandThemeVert[] = TEXT("TaskBandVert");
const TCHAR c_wzTaskBandGroupMenuTheme[] = TEXT("TaskBandGroupMenu");

typedef struct
{
    WCHAR szExeName[MAX_PATH];
} EXCLUDELIST;

static const EXCLUDELIST g_rgNoGlom[] = 
{
    { L"rundll32.exe" } 
    // Add any future apps that shouldn't be glommed
};

void _RestoreWindow(HWND hwnd, DWORD dwFlags);
HMENU _GetSystemMenu(HWND hwnd);
BOOL _IsRudeWindowActive(HWND hwnd);

////////////////////////////////////////////////////////////////////////////
//
// BEGIN CTaskBandSMC
//
// CTaskBand can't implement IShellMenuCallback itself because menuband
// sets itself as the callback's site.  Hence this class.
//
//
////////////////////////////////////////////////////////////////////////////

class CTaskBandSMC : public IShellMenuCallback
                   , public IContextMenu
                   , public IObjectWithSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
    {
        static const QITAB qit[] =
        {
            QITABENT(CTaskBandSMC, IShellMenuCallback),
            QITABENT(CTaskBandSMC, IContextMenu),
            QITABENT(CTaskBandSMC, IObjectWithSite),
            { 0 },
        };
        return QISearch(this, qit, riid, ppvObj);
    }

    STDMETHODIMP_(ULONG) AddRef() { return ++_cRef; }
    STDMETHODIMP_(ULONG) Release()
    {
        ASSERT(_cRef > 0);
        if (--_cRef > 0)
        {
            return _cRef;
        }
        delete this;
        return 0;
    }

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA smd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** IContextMenu methods ***
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT iIndexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax) { return E_NOTIMPL; }

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown* punkSite)
    {
        ATOMICRELEASE(_punkSite);
        if (punkSite != NULL)
        {
            _punkSite = punkSite;
            _punkSite->AddRef();
        }
        return S_OK;
    }
    STDMETHODIMP GetSite(REFIID riid, void** ppvSite) { return E_NOTIMPL; };

    CTaskBandSMC(CTaskBand* ptb) : _cRef(1)
    {
        _ptb = ptb;
        _ptb->AddRef();
    }

private:

    virtual ~CTaskBandSMC() { ATOMICRELEASE(_ptb); }

    ULONG _cRef;
    CTaskBand* _ptb;
    IUnknown* _punkSite;
    HWND _hwndSelected;
};

STDMETHODIMP CTaskBandSMC::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    ASSERT(_ptb);

    HRESULT hres = S_FALSE;

    if (!_ptb->_IsButtonChecked(_ptb->_iIndexPopup) && (SMC_EXITMENU != uMsg))
    {
        _ptb->_SetCurSel(_ptb->_iIndexPopup, TRUE);
    }

    switch (uMsg)
    {
    case SMC_EXEC:
        {
            PTASKITEM pti = _ptb->_GetItem(psmd->uId);
            if (pti)
            {
                _ptb->_SetCurSel(psmd->uId, FALSE);
                _ptb->_OnButtonPressed(psmd->uId, pti, lParam);
                hres = S_OK;
            }
        }
        break;

    case SMC_GETINFO:
        {
            SMINFO* psminfo = (SMINFO*)lParam;
            hres = S_OK;

            if (psminfo->dwMask & SMIM_TYPE)
            {
                psminfo->dwType = SMIT_STRING;
            }

            if (psminfo->dwMask & SMIM_FLAGS)
            {
                psminfo->dwFlags = SMIF_ICON | SMIF_DRAGNDROP;
            }

            if (psminfo->dwMask & SMIM_ICON)
            {
                TBBUTTONINFO tbbi;
                tbbi.iImage = I_IMAGENONE;
                PTASKITEM pti = _ptb->_GetItem(psmd->uId, &tbbi);
                if (pti && tbbi.iImage == I_IMAGECALLBACK)
                {
                    _ptb->_UpdateItemIcon(psmd->uId);
                    _ptb->_GetItem(psmd->uId, &tbbi);
                }
                psminfo->iIcon = tbbi.iImage;
            }
        }
        break;

    case SMC_CUSTOMDRAW:
        {
            PTASKITEM pti = _ptb->_GetItem(psmd->uId);
            if (pti)
            {
                *(LRESULT*)wParam = _ptb->_HandleCustomDraw((NMTBCUSTOMDRAW*)lParam, pti);
                hres = S_OK;
            }
        }
        break;

    case SMC_SELECTITEM:
        {
            PTASKITEM pti = _ptb->_GetItem(psmd->uId);
            _hwndSelected = pti ? pti->hwnd : NULL;
        }
        break;

    case SMC_GETOBJECT:
        {
            GUID *pguid = (GUID*)wParam;
            if (IsEqualIID(*pguid, IID_IContextMenu) && !SHRestricted(REST_NOTRAYCONTEXTMENU))
            {
                hres = QueryInterface(*pguid, (void **)lParam);
            }
            else
            {
                hres = E_FAIL;
            }
        }
        break;

    case SMC_GETINFOTIP:
        {
            PTASKITEM pti = _ptb->_GetItem(psmd->uId);
            if (pti)
            {
                _ptb->_GetItemTitle(psmd->uId, (TCHAR*)wParam, (int)lParam, TRUE);
                hres = S_OK;
            }
        }
        break;

    case SMC_GETIMAGELISTS:
        {
            HIMAGELIST himl = (HIMAGELIST)_ptb->_tb.SendMessage(TB_GETIMAGELIST, psmd->uId, 0);
            if (himl)
            {
                *((HIMAGELIST*)lParam) = *((HIMAGELIST*)wParam) = himl;
                hres = S_OK;
            }
        }
        break;

    case SMC_EXITMENU:
        {
            _hwndSelected = NULL;
            CToolTipCtrl ttc = _ptb->_tb.GetToolTips();
            ttc.Activate(TRUE);
            _ptb->_iIndexPopup = -1;
        }
        break;
    } 

    return hres;
}

// *** IContextMenu methods ***
STDMETHODIMP CTaskBandSMC::QueryContextMenu(HMENU hmenu, UINT iIndexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    ASSERT(_ptb);

    HRESULT hr = ResultFromShort(0);

    if (_hwndSelected != NULL)
    {
        HMENU hmenuTemp = _GetSystemMenu(_hwndSelected);
        if (hmenuTemp)
        {
            if (Shell_MergeMenus(hmenu, hmenuTemp, 0, iIndexMenu, idCmdLast, uFlags))
            {
                SetMenuDefaultItem(hmenu, 0, MF_BYPOSITION);
                hr = ResultFromShort(GetMenuItemCount(hmenuTemp));
            }

            DestroyMenu(hmenuTemp);
        }
    }
    
    return hr;
}

STDMETHODIMP CTaskBandSMC::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    ASSERT(_ptb);

    PTASKITEM pti = _ptb->_FindItemByHwnd(_hwndSelected);
    if (pti)
    {
        int iCommand = LOWORD(lpici->lpVerb);
        if (iCommand)
        {
            _RestoreWindow(pti->hwnd, pti->dwFlags);
            _ptb->_ExecuteMenuOption(pti->hwnd, iCommand);
        }
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////
//
// END CTaskBandSMC
//
////////////////////////////////////////////////////////////////////////////


ULONG CTaskBand::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTaskBand::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTaskBand::GetWindow(HWND * lphwnd) 
{
    *lphwnd = _hwnd; 
    if (_hwnd)
        return S_OK; 
    return E_FAIL;
        
}

CTaskBand::CTaskBand() : _dwBandID((DWORD)-1), _iDropItem(-2), _iIndexActiveAtLDown(-1), _cRef(1), _iOldPriority(INVALID_PRIORITY)
{
}

CTaskBand::~CTaskBand()
{
    ATOMICRELEASE(_punkSite);
    ATOMICRELEASE(_pimlSHIL);

    if (_dsaAII)
        _dsaAII.Destroy();

    if (_hfontCapNormal)
        DeleteFont(_hfontCapNormal);

    if (_hfontCapBold)
        DeleteFont(_hfontCapBold);
}

HRESULT CTaskBand::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENTMULTI(CTaskBand, IDockingWindow, IDeskBand),
        QITABENTMULTI(CTaskBand, IOleWindow, IDeskBand),
        QITABENT(CTaskBand, IDeskBand),
        QITABENT(CTaskBand, IObjectWithSite),
        QITABENT(CTaskBand, IDropTarget),
        QITABENT(CTaskBand, IInputObject),
        QITABENTMULTI(CTaskBand, IPersist, IPersistStream),
        QITABENT(CTaskBand, IPersistStream),
        QITABENT(CTaskBand, IWinEventHandler),
        QITABENT(CTaskBand, IOleCommandTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CTaskBand::Init(CTray* ptray)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (_dsaAII.Create(2))
    {
        _ptray = ptray;
         hr = S_OK;
    }

    return hr;
}

// *** IPersistStream methods ***

HRESULT CTaskBand::GetClassID(LPCLSID pClassID)
{
    *pClassID = CLSID_TaskBand;
    return S_OK;
}

HRESULT CTaskBand::_BandInfoChanged()
{
    if (_dwBandID != (DWORD)-1)
    {
        VARIANTARG var = {0};
        var.vt = VT_I4;
        var.lVal = _dwBandID;

        return IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_BANDINFOCHANGED, 0, &var, NULL);
    }
    else
        return S_OK;
}

HRESULT CTaskBand::Load(IStream *ps)
{
    return S_OK;
}

// *** IOleCommandTarget ***

STDMETHODIMP CTaskBand::Exec(const GUID *pguidCmdGroup,DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;
    return hr;
}

STDMETHODIMP CTaskBand::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (pguidCmdGroup)
    {
        if (IsEqualIID(*pguidCmdGroup, IID_IDockingWindow))
        {
            for (UINT i = 0; i < cCmds; i++)
            {
                switch (rgCmds[i].cmdID)
                {
                case DBID_PERMITAUTOHIDE:
                    rgCmds[i].cmdf = OLECMDF_SUPPORTED;
                    if (!_fFlashing)
                    {
                        rgCmds[i].cmdf |= OLECMDF_ENABLED;
                    }
                    break;
                }
            }
            return S_OK;
        }
    }
    return OLECMDERR_E_UNKNOWNGROUP;
}

//*** IInputObject methods ***

HRESULT CTaskBand::HasFocusIO()
{
    BOOL f;
    HWND hwndFocus = GetFocus();

    f = IsChildOrHWND(_hwnd, hwndFocus);
    ASSERT(hwndFocus != NULL || !f);
    ASSERT(_hwnd != NULL || !f);

    return f ? S_OK : S_FALSE;
}

HRESULT CTaskBand::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    if (fActivate)
    {
        // don't show a hot item if we weren't properly tabbed
        // into/clicked on, in which case we have a NULL lpMsg,
        // e.g. if the tray just decided to activate us for lack of
        // anyone better.

        _fDenyHotItemChange = !lpMsg;

        IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
        ::SetFocus(_hwnd);

        _fDenyHotItemChange = FALSE;
    }
    else
    {
        // if we don't have focus, we're fine;
        // if we do have focus, there's nothing we can do about it...
    }

    return S_OK;
}

HRESULT CTaskBand::SetSite(IUnknown* punk)
{
    if (punk && !_hwnd)
    {
        _LoadSettings();

        _RegisterWindowClass();

        HWND hwndParent;
        IUnknown_GetWindow(punk, &hwndParent);

        HWND hwnd = CreateWindowEx(0, c_szTaskSwClass, NULL,
                WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                0, 0, 0, 0, hwndParent, NULL, hinstCabinet, (void*)(CImpWndProc*)this);

        SetWindowTheme(hwnd, c_wzTaskBandTheme, NULL);
    }

    ATOMICRELEASE(_punkSite);
    if (punk)
    {
        _punkSite = punk;
        punk->AddRef();
    }

    return S_OK;
}


HRESULT CTaskBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) 
{
    _dwBandID = dwBandID;

    pdbi->ptMaxSize.y = -1;
    pdbi->ptActual.y =  g_cySize + 2*g_cyEdge;

    LONG lButHeight = _GetCurButtonHeight();

    if (fViewMode & DBIF_VIEWMODE_VERTICAL)
    {
        pdbi->ptMinSize.x = lButHeight;
        // The 1.2 gives us enough space for the dropdown arrow
        pdbi->ptMinSize.y = lButHeight * (_fGlom ? 1.2 : 1);
        pdbi->ptIntegral.y = 1;
    }
    else
    {
        TBMETRICS tbm;
        _GetToolbarMetrics(&tbm);

        pdbi->ptMinSize.x = lButHeight * 3;
        pdbi->ptMinSize.y = lButHeight;
        pdbi->ptIntegral.y = lButHeight + tbm.cyButtonSpacing;
    }

    pdbi->dwModeFlags = DBIMF_VARIABLEHEIGHT | DBIMF_UNDELETEABLE | DBIMF_TOPALIGN;
    pdbi->dwMask &= ~DBIM_TITLE;    // no title for us (ever)

    DWORD dwOldViewMode = _dwViewMode;
    _dwViewMode = fViewMode;

    if (_tb && (_dwViewMode != dwOldViewMode))
    {
        SendMessage(_tb, TB_SETWINDOWTHEME, 0, (LPARAM)(_IsHorizontal() ? c_wzTaskBandTheme : c_wzTaskBandThemeVert));
        _CheckSize();
    }

    return S_OK;
}


void _RaiseDesktop(BOOL fRaise)
{
    SendMessage(v_hwndTray, TM_RAISEDESKTOP, fRaise, 0);
}

// *** IDropTarget methods ***

STDMETHODIMP CTaskBand::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    _DragEnter(_hwnd, ptl, pdtobj);

    IUnknown_DragEnter(_punkSite, pdtobj, grfKeyState, ptl, pdwEffect);

    _iDropItem = -2;    // reset to no target

    *pdwEffect = DROPEFFECT_LINK;
    return S_OK;
}

STDMETHODIMP CTaskBand::DragLeave()
{
    IUnknown_DragLeave(_punkSite);
    DAD_DragLeave();
    return S_OK;
}

STDMETHODIMP CTaskBand::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    int iHitNew = _HitTest(ptl);
    if (iHitNew == -1)
    {
        DWORD dwEffect = *pdwEffect;
        IUnknown_DragOver(_punkSite, grfKeyState, ptl, &dwEffect);
    }

    *pdwEffect = DROPEFFECT_LINK;

    _DragMove(_hwnd, ptl);

    if (_iDropItem != iHitNew)
    {
        _iDropItem = iHitNew;
        _dwTriggerStart = GetTickCount();
        _dwTriggerDelay = 250;
        if (iHitNew == -1)
        {
            _dwTriggerDelay += 250;    // make a little longer for minimize all
        }
    }
    else if (GetTickCount() - _dwTriggerStart > _dwTriggerDelay)
    {
        DAD_ShowDragImage(FALSE);       // unlock the drag sink if we are dragging.

        if (_iDropItem == -1)
        {
            _RaiseDesktop(TRUE);
        }
        else if (_iDropItem >= 0 && _iDropItem < _tb.GetButtonCount())
        {
            _iIndexLastPopup = -1;
            _SwitchToItem(_iDropItem, _GetItem(_iDropItem)->hwnd, TRUE);
            UpdateWindow(v_hwndTray);
        }

        DAD_ShowDragImage(TRUE);        // restore the lock state.

        _dwTriggerDelay += 10000;   // don't let this happen again for 10 seconds
                                    // simulate a single shot event
    }

    if (_iDropItem != -1)
        *pdwEffect = DROPEFFECT_MOVE;   // try to get the move cursor
    else
        *pdwEffect = DROPEFFECT_NONE;

    return S_OK;
}

STDMETHODIMP CTaskBand::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    IUnknown_DragLeave(_punkSite);
    DAD_DragLeave();

    //
    // post ourselves a message to put up a message box to explain that you
    // can't drag to the taskbar.  we need to return from the Drop method
    // now so the DragSource isn't hung while our box is up
    //
    PostMessage(_hwnd, TBC_WARNNODROP, 0, 0L);

    // be sure to clear DROPEFFECT_MOVE so apps don't delete their data
    *pdwEffect = DROPEFFECT_NONE;

    return S_OK;
}

// *** IWinEventHandler methods ***
HRESULT CTaskBand::OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    *plres = 0;
    
    switch (dwMsg) 
    {
    case WM_WININICHANGE:
        _HandleWinIniChange(wParam, lParam, FALSE);
        break;

    case WM_NOTIFY:
        if (lParam)
        {
            switch (((LPNMHDR)lParam)->code)
            {
            case NM_SETFOCUS:
                IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
                break;
            }
        }
        break;
    }

    return S_OK;
}

HRESULT CTaskBand::IsWindowOwner(HWND hwnd)
{
    BOOL bRet = IsChildOrHWND(_hwnd, hwnd);
    ASSERT (_hwnd || !bRet);
    ASSERT (hwnd || !bRet);
    return bRet ? S_OK : S_FALSE;
}

//-----------------------------------------------------------------------------
// DESCRIPTION:  Returns whether or not the button is hidden
//
// PARAMETERS:   1. hwndToolBar - handle to the toolbar window
//               2. iIndex - item index
//   
// RETURN:       TRUE = Item is visible, FALSE = Item is hidden.
//-----------------------------------------------------------------------------
BOOL ToolBar_IsVisible(HWND hwndToolBar, int iIndex)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_STATE | TBIF_BYINDEX;
    SendMessage(hwndToolBar, TB_GETBUTTONINFO, iIndex, (LPARAM) &tbbi);

    return !(tbbi.fsState & TBSTATE_HIDDEN);
}

//*****************************************************************************
//
// ITEM ANIMATION FUNCTIONS
//
//*****************************************************************************

//-----------------------------------------------------------------------------
// DESCRIPTION:  Inserts item(s) into the animation list
//
// PARAMETERS:   1. iIndex - index for item, group index for a group
//               2. fExpand - TRUE = Insert or Unglom, FALSE = Delete or Glom
//               3. fGlomAnimation - TRUE = this is a glom or unglom animation
//-----------------------------------------------------------------------------
BOOL CTaskBand::_AnimateItems(int iIndex, BOOL fExpand, BOOL fGlomAnimation)
{
    ANIMATIONITEMINFO aii;
    _SetAnimationState(&aii, fExpand, fGlomAnimation);

    // Is item being inserted into glomming group?
    if (aii.fState == ANIMATE_INSERT)
    {
        int iIndexGroup = _GetGroupIndex(iIndex);
        if (_GetItem(iIndexGroup)->dwFlags & TIF_ISGLOMMING)
        {
            aii.fState = ANIMATE_GLOM;        
        }
    }
    else if (aii.fState == ANIMATE_GLOM)
    {
        _GetItem(iIndex)->dwFlags |= TIF_ISGLOMMING;
    }
    
    // Number of items to animate
    int cItems = 1;
    if (fGlomAnimation)
    {
        // insert the group
        cItems = _GetGroupSize(iIndex);
        iIndex++;
    }

    // Insert items into animation list
    while(cItems)
    {
        aii.iIndex = iIndex;
        aii.pti = _GetItem(iIndex);
        if (aii.fState == ANIMATE_DELETE)
        {
            // NOTE: HWND_TOPMOST is used here to indicate that the deleted 
            // button is being animated. This allows the button to stay 
            // around after its hwnd becomes invalid 
            aii.pti->hwnd = HWND_TOPMOST;
            aii.pti->dwFlags |= TIF_TRANSPARENT;
        }

        //sorts left to right && removes redundant items
        int iAnimationPos = _GetAnimationInsertPos(iIndex); 
        _dsaAII.InsertItem(iAnimationPos++, &aii);

        cItems--;
        iIndex++;
    }

    SetTimer(_hwnd, IDT_ASYNCANIMATION, 100, NULL);
    return TRUE;
}


//-----------------------------------------------------------------------------
//  DESCRIPTION:  Animates the items in the animtation list by one step.
//-----------------------------------------------------------------------------
void CTaskBand::_AsyncAnimateItems()
{
    BOOL fRedraw = (BOOL)SendMessage(_tb, WM_SETREDRAW, FALSE, 0);
    // Glomming is turned off here because in the middle of the animation we
    // may call _DeleteItem which could cause an unglom\glom.
    // This is bad because it would modify the contents of animation list that 
    // we are in the middle of processing. 
    BOOL fGlom = _fGlom;
    _fGlom = FALSE;

    _UpdateAnimationIndices();
    _ResizeAnimationItems();
    int iDistanceLeft = _CheckAnimationSize();

    _fGlom = fGlom;

    _CheckSize();
    SendMessage(_tb, WM_SETREDRAW, fRedraw, 0);
    UpdateWindow(_tb);

    if (_dsaAII.GetItemCount())
    {             
        SetTimer(_hwnd, IDT_ASYNCANIMATION, _GetStepTime(iDistanceLeft), NULL);
    }
    else
    {
        KillTimer(_hwnd, IDT_ASYNCANIMATION);

        if (_ptray->_hwndLastActive)
        {
            int iIndex = _FindIndexByHwnd(_ptray->_hwndLastActive);
            if ((iIndex != -1) && (_IsButtonChecked(iIndex)))
            {
                _ScrollIntoView(iIndex);
            }
        }

        _RestoreThreadPriority();

        // Make sure no one was glommed into a group of one
        // there are certain race conditions where this can happen
        for (int i = _tb.GetButtonCount() - 1; i >= 0; i--)
        {
            PTASKITEM pti = _GetItem(i);
            if (!pti->hwnd)
            {
                int iSize = _GetGroupSize(i);
                if ((iSize < 2) && (!_IsHidden(i)))
                {
                    _Glom(i, FALSE);
                }
            }
        }
    }
}


//-----------------------------------------------------------------------------
//  DESCRIPTION:  Adjusts the widths of the animating items by the animation 
//                step.
//
//  RETURN:       The Total width of all animating items.
//-----------------------------------------------------------------------------
void CTaskBand::_ResizeAnimationItems()
{
    int cxStep = _GetAnimationStep();

    for (int i = _dsaAII.GetItemCount() - 1; i >= 0; i--)
    {
        PANIMATIONITEMINFO paii = _dsaAII.GetItemPtr(i);
        _SetAnimationItemWidth(paii, cxStep);
    }
}


//-----------------------------------------------------------------------------
//  DESCRIPTION:  Checks if animation items have reached their target animation
//                width
//
//  RETURN:       The total distance left to animate
//-----------------------------------------------------------------------------
int CTaskBand::_CheckAnimationSize()
{
    PANIMATIONITEMINFO paii;
    int iTotDistLeft = 0;
    int iRemainder = 0;
    int iNormalWidth = _GetIdealWidth(&iRemainder); 
    int cAnimatingItems = _dsaAII.GetItemCount();

    for (int i = cAnimatingItems - 1; i >= 0; i--)
    {
        paii = _dsaAII.GetItemPtr(i);

        if (paii)
        {
            int iDistLeft = _GetAnimationDistLeft(paii, iNormalWidth);
            if (!iDistLeft)
            {
                ANIMATIONITEMINFO aiiTemp = *paii;
                _dsaAII.DeleteItem(i);
                _FinishAnimation(&aiiTemp);
            }
            else
            {
                iTotDistLeft += iDistLeft;
            }
        }
#ifdef DEBUG
        else
        {
            int nCurrentCount = _dsaAII.GetItemCount();
            if (i >= nCurrentCount)            
                TraceMsg(TF_ERROR, "Invalid counter %x in the loop, size = %x", i, nCurrentCount);
            else
                TraceMsg(TF_ERROR, "NULL paii for %x.", i);
        }
#endif
    }

    return iTotDistLeft;
}


//-----------------------------------------------------------------------------
// DESCRIPTION:  Sets the animation state for an ANIMATIONITEMINFO struct.
//
// PARAMETERS:   1. paii - PANIMATIONITEMINFO for the animation item
//               2. fExpand - TRUE = Insert or Unglom, FALSE = Delete or Glom
//               3. fGlomAnimation - TRUE = this is a glom or unglom animation
//-----------------------------------------------------------------------------
void CTaskBand::_SetAnimationState(PANIMATIONITEMINFO paii, BOOL fExpand, 
                                BOOL fGlomAnimation)
{
    if (fExpand)
    {
        paii->fState = ANIMATE_INSERT;
    }
    else
    {
        if (fGlomAnimation)
        {
            paii->fState = ANIMATE_GLOM;
        }
        else
        {
            paii->fState = ANIMATE_DELETE;
        }
    }
}


//-----------------------------------------------------------------------------
// DESCRIPTION:  Determines the animation list index that keeps the list in the
//               same order as the toolbar indexes. 
//               (Duplicate toolbar items are removed from the animation list.)
//
// PARAMETERS:   1. iIndex - item's index in the toolbar
//   
// RETURN:       The position the item should be inserted into the animation list
//-----------------------------------------------------------------------------
int CTaskBand::_GetAnimationInsertPos(int iIndex)
{
    int iPos = 0;

    if (_dsaAII.GetItemCount())
    {
        _UpdateAnimationIndices();

        for (int i = _dsaAII.GetItemCount() - 1; i >= 0; i--)
        {
            PANIMATIONITEMINFO paii = _dsaAII.GetItemPtr(i);

            if (paii->iIndex == iIndex)
            {
                // remove duplicate
                _dsaAII.DeleteItem(i);
                iPos = i;
                break;
            }
            else if (paii->iIndex < iIndex)
            {
                iPos = i + 1;
                break;
            }
        }
    }
    return iPos;
}

void CTaskBand::_RemoveItemFromAnimationList(PTASKITEM ptiRemove)
{
    for (int i = _dsaAII.GetItemCount() - 1; i >= 0; i--)
    {
        PANIMATIONITEMINFO paii = _dsaAII.GetItemPtr(i);
        if (paii->pti == ptiRemove)
        {
            _dsaAII.DeleteItem(i);
            break;
        }
    }
}

//-----------------------------------------------------------------------------
// DESCRIPTION:  Adjusts the width of the animating item by the animation step.
//      
// PARAMETERS:   1. paii - PANIMATIONITEMINFO for the animation item
//               2. cxStep - animation step used to adjust the item's width
//   
// RETURN:       the new width
//-----------------------------------------------------------------------------
#define ANIM_SLOWSTEPS  3
#define ANIM_SLOWZONE   15
void CTaskBand::_SetAnimationItemWidth(PANIMATIONITEMINFO paii, int cxStep)
{
    int iWidth = _GetItemWidth(paii->iIndex);
    
    switch (paii->fState)
    {
    case ANIMATE_INSERT:
        iWidth += cxStep;  
        break;
    case ANIMATE_DELETE:
        //slow animation towards end
        if (((iWidth / cxStep) <= ANIM_SLOWSTEPS) && 
            ((iWidth - cxStep) < ANIM_SLOWZONE - _GetVisibleItemCount()))
        {
            // The last step takes 3 times as long
            cxStep = cxStep / 3;
        }
        iWidth -= cxStep;   
        iWidth = max(iWidth, 0);
        break;
     case ANIMATE_GLOM:
        iWidth -= cxStep;   
        iWidth = max(iWidth, 1); //toolbar sizes 0 width to full size
        break;
    }

    _SetItemWidth(paii->iIndex, iWidth);
}


//-----------------------------------------------------------------------------
// DESCRIPTION:  Returns the distance the items must travel to end the 
//               animation
//
// PARAMETERS:   1. paii - pointer to the ANIMATIONITEMINFO for the item
//               2. iNormalWidth - width of a non-animation item
//  
// RETURN:       the distance the items must travel to end the animation
//-----------------------------------------------------------------------------
int CTaskBand::_GetAnimationDistLeft(PANIMATIONITEMINFO paii, int iNormalWidth)
{
    int cxDistLeft = 0;
    int iWidth = _GetItemWidth(paii->iIndex);

    switch (paii->fState)
    {
    case ANIMATE_INSERT:
        cxDistLeft = max(0, iNormalWidth - iWidth);
        break;

    case ANIMATE_DELETE:
        if ((paii->iIndex == _GetLastVisibleItem()) && (iNormalWidth == g_cxMinimized))
        {
            cxDistLeft = 0;
        }
        else
        {
            cxDistLeft = max(0, iWidth);
        }
        break;

    case ANIMATE_GLOM:
        {
            int iGroupIndex = _GetGroupIndex(paii->iIndex);

            if (!ToolBar_IsVisible(_tb, iGroupIndex))
            {
                int cGroupSize = _GetGroupSize(iGroupIndex);
                if (cGroupSize)
                {
                    int iGroupWidth = _GetGroupWidth(iGroupIndex);
                    cxDistLeft = max(0, iGroupWidth - iNormalWidth);
                    if (iGroupWidth == cGroupSize)
                    {
                        cxDistLeft = 0;
                    }
                    cxDistLeft = cxDistLeft/cGroupSize;
                }
            }
        }
        break;

    }
    return cxDistLeft;
}


//-----------------------------------------------------------------------------
// DESCRIPTION:  Completes tasks to finish an animation
//
// PARAMETERS:   1. paii - pointer to the ANIMATIONITEMINFO for the item
//  
// RETURN:       the distance the items must travel to end the animation
//-----------------------------------------------------------------------------
void CTaskBand::_FinishAnimation(PANIMATIONITEMINFO paii)
{
    switch (paii->fState)
    {
    case ANIMATE_DELETE:
        _DeleteItem(NULL, paii->iIndex);
        break;

    case ANIMATE_GLOM:
        {
            int iGroupIndex = _GetGroupIndex(paii->iIndex);
         
            if (!ToolBar_IsVisible(_tb, iGroupIndex))
            {
                // Turn off glomming flag
                _GetItem(iGroupIndex)->dwFlags &= ~TIF_ISGLOMMING;
                _HideGroup(iGroupIndex, TRUE);
            }

            // NOTE: HWND_TOPMOST is used to indicate that the deleted button 
            // is being animated. This allows the button to stay around after 
            // its real hwnd becomes invalid
            if (paii->pti->hwnd == HWND_TOPMOST)
            {
                // The button was deleting before it was glommed
                // Now that the glomming is done, delete it.
                _DeleteItem(NULL, paii->iIndex);
            }

        }
        break;
    }
}

//-----------------------------------------------------------------------------
//  DESCRIPTION:  Returns the width of all the animating buttons
//
//  RETURN:       The total animation width
//-----------------------------------------------------------------------------
int CTaskBand::_GetAnimationWidth()
{
    int iTotAnimationWidth = 0;

    _UpdateAnimationIndices();

    for (int i = _dsaAII.GetItemCount() - 1; i >= 0; i--)
    {
        PANIMATIONITEMINFO paii = _dsaAII.GetItemPtr(i);
        iTotAnimationWidth += _GetItemWidth(paii->iIndex);
    }

    return iTotAnimationWidth;
}

//-----------------------------------------------------------------------------
// DESCRIPTION:  Synchronizes the indexes held by the animating items to the 
//               true toolbar indexes.
//               Note: This function may cause the number of animating items to
//               change.
//-----------------------------------------------------------------------------
void CTaskBand::_UpdateAnimationIndices()
{
    int cAnimatingItems = _dsaAII.GetItemCount();

    if (cAnimatingItems)
    {
        // NOTE: items in the animation list are in the same order as the 
        // toolbar
        int iCurrAnimationItem = cAnimatingItems - 1;
        PANIMATIONITEMINFO paii = _dsaAII.GetItemPtr(iCurrAnimationItem);
    
        for (int i = _tb.GetButtonCount() - 1; i >=0 ; i--)
        {
            if (_GetItem(i) == paii->pti)
            {
                paii->iIndex = i;
                iCurrAnimationItem--;
                if (iCurrAnimationItem < 0)
                {
                    break;   
                }
                paii = _dsaAII.GetItemPtr(iCurrAnimationItem);
            }
        }

        // If animation items are not in the same order as the items in the 
        // toolbar then iCurrAnimationItem not be -1
        //ASSERT(iCurrAnimationItem == -1);
        if (iCurrAnimationItem != -1)
        {
            _UpdateAnimationIndicesSlow();
        }
    }
}

void CTaskBand::_UpdateAnimationIndicesSlow()
{
#ifdef DEBUG
    int cAnimatingItems = _dsaAII.GetItemCount();
    TraceMsg(TF_WARNING, "CTaskBand::_UpdateAnimationIndicesSlow: enter");
#endif

    for (int i = _dsaAII.GetItemCount() - 1; i >= 0; i--)
    {
        PANIMATIONITEMINFO paii = _dsaAII.GetItemPtr(i);
        int iIndex = _FindItem(paii->pti);
        if (iIndex == -1)
        {
            _dsaAII.DeleteItem(i);
        }
        else
        {
            paii->iIndex = i;
        }
    }

#ifdef DEBUG
    // Being in this function means that either an animating item is no longer in the
    // toolbar, or that the animating items are in a different order than the toolbar.
    // If the animating items are only in a different order (bad), the number of animating
    // items will remain the same.
    if (cAnimatingItems == _dsaAII.GetItemCount())
    {
        TraceMsg(TF_WARNING, "CTaskBand::_UpdateAnimationIndicesSlow: Animating items are in diff order than toolbar");
    }
#endif
    
}

int CTaskBand::_FindItem(PTASKITEM pti)
{
    int iIndex = -1;

    if (pti)
    {
        for (int i = _tb.GetButtonCount() - 1; i >= 0; i--)
        {
            if (pti == _GetItem(i))
            {
                iIndex = i;
                break;
            }
        }
    }

    return iIndex;
}

//-----------------------------------------------------------------------------
// DESCRIPTION: Animation Step Constants
//-----------------------------------------------------------------------------
#define  ANIM_STEPFACTOR 9 
#define  ANIM_STEPMAX 40 // max size of an animation step
#define  ANIM_STEPMIN 11 // min size of an animation step 

//-----------------------------------------------------------------------------
// DESCRIPTION:  Determines an animation step based on the number of items
//               visible in the toolbar.
//
// PARAMETERS:   1. iTotalItems - number of visible items in toolbar
//   
// RETURN:       The animation step
//-----------------------------------------------------------------------------
int CTaskBand::_GetAnimationStep()
{   
    DWORD dwStep;
    int iVisibleItems = _GetVisibleItemCount();

    int iRows;
    _GetNumberOfRowsCols(&iRows, NULL, TRUE); // _GetNumberOfRows will never return < 1
    int iTotalItems = iVisibleItems - _dsaAII.GetItemCount();

    // The step must be large when there are many items, but can be very small
    // when there are few items. This is achieved by cubing the total items.
    dwStep = (DWORD)(iTotalItems * iTotalItems * iTotalItems) / ANIM_STEPFACTOR;
    dwStep = min(dwStep, ANIM_STEPMAX);
    dwStep = max(dwStep, ANIM_STEPMIN);

    return dwStep;
}


//-----------------------------------------------------------------------------
// DESCRIPTION: Animation Sleep Constants
//-----------------------------------------------------------------------------
#define ANIM_PAUSE  1000
#define ANIM_MAXPAUSE 30

//-----------------------------------------------------------------------------
// DESCRIPTION:  Returns the amount of time to sleep
//
// PARAMETERS:   1. iStep - current animation step
//               2. cSteps - total animation steps 
//               3. iStepSize - step size for the animation
// 
// RETURN:       time to sleep
//-----------------------------------------------------------------------------
DWORD CTaskBand::_GetStepTime(int cx)
{
    // NOTE: The cx is decrementing to ZERO.
    // As the cx gets smaller we want to 
    // increment the sleep time. 

    // don't let cx be zero
    cx = max(1, cx);
    cx = min(32767, cx);

    // x^2 curve gives a larger pause at the end.
    int iDenominator = cx * cx;

    return min(ANIM_MAXPAUSE, ANIM_PAUSE / iDenominator);
}

//*****************************************************************************
// END OF ANIMATION FUNCTIONS
//*****************************************************************************

void CTaskBand::_SetItemWidth(int iItem, int iWidth)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_SIZE | TBIF_BYINDEX; 

    tbbi.cx = (WORD)iWidth;

     _tb.SetButtonInfo(iItem, &tbbi);  
}


int CTaskBand::_GetItemWidth(int iItem)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_SIZE | TBIF_BYINDEX; 

     _tb.GetButtonInfo(iItem, &tbbi);

    return tbbi.cx;
}

//-----------------------------------------------------------------------------
//  DESCRIPTION:  Retrives the index of the last visible button on the toolbar
//   
//  RETURN:       Index of the last visible item on the toolbar.
//-----------------------------------------------------------------------------
int CTaskBand::_GetLastVisibleItem()
{
    int iLastIndex = -1;

    for (int i = _tb.GetButtonCount() - 1; i >=0 ; i--)
    {
        if (ToolBar_IsVisible(_tb, i))
        {
            iLastIndex = i;
            break;
        }
    }

    return iLastIndex;
}

//-----------------------------------------------------------------------------
//  DESCRIPTION:  Retrives the total width of all buttons in the group
//
//  PARAMETERS:   1. iIndexGroup - the index of the group
//   
//  RETURN:       the total width of all buttons in the group
//-----------------------------------------------------------------------------
int CTaskBand::_GetGroupWidth(int iIndexGroup)
{
    int iGroupWidth = 0;

    int cButtons = _tb.GetButtonCount();
    for (int i = iIndexGroup + 1; i < cButtons; i++)
    {
        PTASKITEM pti = _GetItem(i);
        if (!pti->hwnd)
        {
            break;
        }
        iGroupWidth += _GetItemWidth(i);
    }

    return iGroupWidth;
}

//-----------------------------------------------------------------------------
// DESCRIPTION:  Retrives the number of visible buttons on the toolbar
   
// RETURN:       the number of visible buttons on the toolbar
//-----------------------------------------------------------------------------
int CTaskBand::_GetVisibleItemCount()
{
    int cItems = 0;

    // Count the number of visible buttons before the animated item(s)
    for (int i = _tb.GetButtonCount() - 1; i >=0 ; i--)
    {
        if (ToolBar_IsVisible(_tb, i))
        {
            cItems++;
        }
    }

    return cItems;
}

//-----------------------------------------------------------------------------
//  DESCRIPTION:  Retrives the ideal width of a non-animating button
//
//  PARAMETERS:   1. iRemainder[OUT] - width needed for the total item width
//                   to equal the window width. (set to zero unless the ideal 
//                   width is less than the maximum button width. 
//   
//  RETURN:       the total width of all buttons in the group
//-----------------------------------------------------------------------------
int CTaskBand::_GetIdealWidth(int *iRemainder)
{  
    int iIdeal = 0;
    *iRemainder = 0;

    RECT  rcWin;
    GetWindowRect(_hwnd, &rcWin);
    int iWinWidth = RECTWIDTH(rcWin);
    int iRows;
    _GetNumberOfRowsCols(&iRows, NULL, TRUE);
    int cItems = _GetVisibleItemCount();

    // button spacing
    TBMETRICS tbm;
    _GetToolbarMetrics(&tbm);
      
    if (iRows == 1)
    {
        // window width that can be used for non-animating items
        iWinWidth -= (_GetAnimationWidth() + (_dsaAII.GetItemCount() * tbm.cxButtonSpacing));
        iWinWidth = max(0, iWinWidth);

        // find number of non-animating items
        cItems -= _dsaAII.GetItemCount();
        cItems = max(1, cItems);
    }
        
    // We need to round up so that iCols is the smallest number such that
    // iCols*iRows >= cItems
    int iCols = (cItems + iRows - 1) / iRows;
    iCols = max(1, iCols);

    // calculate the ideal width
    iIdeal = (iWinWidth / iCols);
    if (iCols > 1)
    {
        iIdeal -= tbm.cxButtonSpacing;
    }

    // adjust ideal width
    int iMax = _IsHorizontal() ? g_cxMinimized : iWinWidth;
    int iMin = g_cySize + 2*g_cxEdge;
    if (_IsHorizontal())
    {
        iMin *= 1.8;
    }
    iMin += _GetTextSpace();
    iIdeal = min(iMax, iIdeal);
   
    // calculate the remainder
    if (_IsHorizontal() && (iIdeal != iMax) && (iRows == 1) && (iIdeal >= iMin))
    {
        *iRemainder = iWinWidth - (iCols * (iIdeal + tbm.cxButtonSpacing));
        *iRemainder = max(0, *iRemainder);
    }
    
    return iIdeal;
}


void CTaskBand::_GetNumberOfRowsCols(int* piRows, int* piCols, BOOL fCurrentSize)
{
    RECT  rcWin;
    RECT  rcItem;
    RECT  rcTB;
    int   iIndexVisible = _GetLastVisibleItem();

    GetWindowRect(_hwnd, &rcWin);
    int cxTB = RECTWIDTH(rcWin);
    int cyTB = RECTHEIGHT(rcWin);

    if (fCurrentSize)
    {
        GetWindowRect(_tb, &rcTB);
        DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
        if (dwStyle & WS_HSCROLL)
        {
            cyTB = RECTHEIGHT(rcTB);
        }
        else if (dwStyle & WS_VSCROLL)
        {
            cxTB = RECTWIDTH(rcTB);
        }
    }

    _tb.GetItemRect(iIndexVisible, &rcItem);

    TBMETRICS tbm;
    _GetToolbarMetrics(&tbm);

    if (piRows)
    {
        int cyRow = RECTHEIGHT(rcItem) + tbm.cyButtonSpacing;
        *piRows = (cyTB + tbm.cyButtonSpacing) / cyRow;
        *piRows = max(*piRows, 1);
    }

    if (piCols && RECTWIDTH(rcItem))
    {
        int cxCol = RECTWIDTH(rcItem) + tbm.cxButtonSpacing;
        *piCols = (cxTB + tbm.cxButtonSpacing) / cxCol;
        *piCols = max(*piCols, 1);
    }
}

//-----------------------------------------------------------------------------
//  DESCRIPTION:  Retrives the minimum text width for a button. (used only to
//                determine when task items should be glommed.)
//   
//  RETURN:       the minimum text width for a button
//-----------------------------------------------------------------------------
int CTaskBand::_GetTextSpace()
{
    int iTextSpace = 0;

    if (_fGlom && _IsHorizontal() && (_iGroupSize < GLOM_SIZE))
    {
        if (!_iTextSpace)
        {
            HFONT hfont = (HFONT)SendMessage(_tb, WM_GETFONT, 0, 0);
            if (hfont)
            {
                HDC hdc = GetDC(_tb);
                TEXTMETRIC tm;
                GetTextMetrics(hdc, &tm);
                
                _iTextSpace = tm.tmAveCharWidth * 8;
                ReleaseDC(_tb, hdc);
            }
        }
        iTextSpace = _iTextSpace;
    }
    return iTextSpace;
}

//-----------------------------------------------------------------------------
//  DESCRIPTION:  Retrieves the toolbar metrics requested by the mask
//   
//  RETURN:       toolbar metrics
//-----------------------------------------------------------------------------
void CTaskBand::_GetToolbarMetrics(TBMETRICS *ptbm)
{
    ptbm->cbSize = sizeof(*ptbm);
    ptbm->dwMask = TBMF_PAD | TBMF_BARPAD | TBMF_BUTTONSPACING;
    _tb.SendMessage(TB_GETMETRICS, 0, (LPARAM)ptbm);
}


//-----------------------------------------------------------------------------
//  DESCRIPTION:  Sizes the non-animating buttons to the taskbar. Shrinks 
//                and/or gloms items so that all visible items fit on window.
//-----------------------------------------------------------------------------
void CTaskBand::_CheckSize()
{
    if (_dsaAII)
    {
        int cItems = _GetVisibleItemCount();
        // Check for non-animating buttons to size
        if (cItems > _dsaAII.GetItemCount())
        {
            // Handle grouping by size
            if (_fGlom && (_iGroupSize >= GLOM_SIZE))
            {
                _AutoGlomGroup(TRUE, 0);
            }

            RECT rc;
            GetWindowRect(_hwnd, &rc);
            if (!IsRectEmpty(&rc) && (_tb.GetWindowLong(GWL_STYLE) & WS_VISIBLE))
            {
                int iRemainder = 0;
                int iIdeal = _GetIdealWidth(&iRemainder);
                BOOL fHoriz = _IsHorizontal();

                int iMin = g_cySize + 2*g_cxEdge;
                if (fHoriz)
                {
                    iMin *= 1.8;
                }
                iMin += _GetTextSpace();
                iIdeal = max(iIdeal, iMin);

                _SizeItems(iIdeal, iRemainder);
                _tb.SetButtonWidth(iIdeal, iIdeal);

                int iRows;
                int iCols;
                _GetNumberOfRowsCols(&iRows, &iCols, FALSE);
                
                BOOL fAllowUnGlom = TRUE;

                if (_fGlom && fHoriz && (iIdeal == iMin))
                {
                    _AutoGlomGroup(TRUE, 0);

                    iMin = (g_cySize + 2*g_cxEdge) * 1.8;
                    iIdeal = _GetIdealWidth(&iRemainder);
                    iIdeal = max(iIdeal, iMin);

                    _SizeItems(iIdeal, iRemainder);
                    _tb.SetButtonWidth(iIdeal, iIdeal);

                    fAllowUnGlom = FALSE;
                }

                // if we're forced to the minimum size, then we may need some scrollbars
                if ((fHoriz && (iIdeal == iMin)) || (!fHoriz && (cItems > (iRows * iCols))))
                {
                    if (!(_fGlom && _AutoGlomGroup(TRUE, 0)))
                    {
                        TBMETRICS tbm;
                        _GetToolbarMetrics(&tbm);
              
                        RECT  rcItem;
                        _tb.GetItemRect(_GetLastVisibleItem(), &rcItem);
                        int cyRow = RECTHEIGHT(rcItem) + tbm.cyButtonSpacing;
                        int iColsInner = (cItems + iRows - 1) / iRows;

                        _CheckNeedScrollbars(cyRow, cItems, iColsInner, iRows, iIdeal + tbm.cxButtonSpacing, &rc);
                    }
                }
                else
                {
                    if (_fGlom && fHoriz)
                    {
                        // iMin is reset above to handle the two-stage minimum. The first minimum size forces glomming, and the second minimum size
                        // enforces hard limit for minimum button size.
                        // In the case, of unglomming we need unglom base on the first minimum size
                        iMin = (g_cySize + 2*g_cxEdge) * 1.8 + _GetTextSpace();
                    }

                    int cOpenSlots = fHoriz ? ((RECTWIDTH(rc) - _GetAnimationWidth()) - 
                                    (iMin * (cItems - _dsaAII.GetItemCount()))) / iMin : iRows - cItems;
                    if (!(_fGlom && (cOpenSlots >= 2) && fAllowUnGlom && _AutoGlomGroup(FALSE, cOpenSlots)))
                    {
                        _NukeScrollbar(SB_HORZ);
                        _NukeScrollbar(SB_VERT);
                        _tb.SetWindowPos(0, 0, 0, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOACTIVATE | SWP_NOZORDER);
                    }
                }

                // force wrap recalc
                _tb.AutoSize();
            }
            else
            {
                _SizeItems(g_cxMinimized);
                _tb.SetButtonWidth(g_cxMinimized, g_cxMinimized);
            }
        }
    }
}

//-----------------------------------------------------------------------------
//  DESCRIPTION:  Set the sizes of non-animating buttons
//
//  PARAMETERS:   1. iButtonWidth - width to assign each non-animating item
//                2. IRemainder - extra width to keep total width constant. 
//   
//-----------------------------------------------------------------------------
void CTaskBand::_SizeItems(int iButtonWidth, int iRemainder)
{
   
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_SIZE | TBIF_BYINDEX; 

    int iAnimCount = _dsaAII.GetItemCount();
    
    for (int i = _tb.GetButtonCount() - 1; i >=0 ; i--)
    {
        if (ToolBar_IsVisible(_tb, i))
        { 
            BOOL fResize = TRUE;

            if (iAnimCount)
            { 
                for (int j = 0; (j < iAnimCount) && fResize; j++)
                {
                    PANIMATIONITEMINFO paii = _dsaAII.GetItemPtr(j);
                    if (paii->iIndex == i)
                    {
                        fResize = FALSE;
                    }
                }
            }

            if (fResize)
            {
                tbbi.cx = (WORD) iButtonWidth;

                if (iRemainder) 
                {
                    tbbi.cx++;
                    iRemainder--;
                }

                _tb.SetButtonInfo(i, &tbbi);
            }
        }
    }
}



//---------------------------------------------------------------------------

//
//  Track which shortcut launched a particular task.
//  Every so often, we tickle the file's entry in the UEM database
//  to indicate that the program has been running for a long time.
//
//  These structures are used only by the taskbar thread, hence do
//  not need to be thread-safe.
//
class TaskShortcut
{
public:

    TaskShortcut(LPCTSTR pszExeName, DWORD pid);

    void AddRef() { _cRef++; }
    void Release() { if (--_cRef == 0) delete this; }
    void Tickle();
    void Promote();
    static BOOL _PromotePidl(LPCITEMIDLIST pidl, BOOL fForce);
    inline BOOL MatchesCachedPid(PTASKITEM pti)
    {
        return _pid == s_pidCache;
    }
    static BOOL MatchesCachedExe(PTASKITEM pti)
    {
        return  pti->pszExeName &&
                lstrcmpiW(pti->pszExeName, s_szTargetNameCache) == 0;
    }
    inline BOOL MatchesPid(DWORD pid) const { return pid == _pid; }
    void SetInfoFromCache();
    static BOOL _HandleShortcutInvoke(LPSHShortcutInvokeAsIDList psidl);

    //
    //  Note that the session time is now hard-coded to 4 hours and is not
    //  affected by the browseui session time.
    //
    enum {
        s_msSession = 4 * 3600 * 1000 // 4 hours - per DCR
    };

private:
    static DWORD s_pidCache;
    static int   s_csidlCache;
    static WCHAR s_szShortcutNameCache[MAX_PATH];
    static WCHAR s_szTargetNameCache[MAX_PATH];

private:
    ~TaskShortcut() { SHFree(_pszShortcutName); }

    ULONG   _cRef;              // reference count
    DWORD   _pid;               // process id
    DWORD   _tmTickle;          // time of last tickle
    int     _csidl;             // csidl we are a child of
    LPWSTR  _pszShortcutName;   // Which shortcut launched us? (NULL = don't know)
};

//---------------------------------------------------------------------------
//
DWORD TaskShortcut::s_pidCache;
int   TaskShortcut::s_csidlCache;
WCHAR TaskShortcut::s_szShortcutNameCache[MAX_PATH];
WCHAR TaskShortcut::s_szTargetNameCache[MAX_PATH];

TaskShortcut::TaskShortcut(LPCTSTR pszExeName, DWORD pid)
    : _cRef(1), _pid(pid), _tmTickle(GetTickCount()), _pszShortcutName(NULL)
{
    // If this app was recently launched from a shortcut,
    // save the shortcut name.
    if (s_pidCache == pid &&
        pszExeName &&
        pszExeName[0] &&
        lstrcmpi(pszExeName, s_szTargetNameCache) == 0)
    {
        SetInfoFromCache();
    }
}

void TaskShortcut::SetInfoFromCache()
{
    _csidl = s_csidlCache;
    SHStrDup(s_szShortcutNameCache, &_pszShortcutName);
}


//---------------------------------------------------------------------------

void CTaskBand::_AttachTaskShortcut(PTASKITEM pti, LPCTSTR pszExeName)
{
    DWORD pid = 0;
    GetWindowThreadProcessId(pti->hwnd, &pid);

    int i;
    for (i = _tb.GetButtonCount() - 1; i >= 0; i--)
    {
        PTASKITEM ptiT = _GetItem(i);
        if (ptiT->ptsh && ptiT->ptsh->MatchesPid(pid))
        {
            pti->ptsh = ptiT->ptsh;
            pti->ptsh->AddRef();
            return;
        }
    }

    // Wow, the first window associated with this pid.  Need to create
    // a new entry.

    // Make sure nobody tries to do this in a multithreaded way
    // since we're not protecting the cache with a critical section
    ASSERT(GetCurrentThreadId() == GetWindowThreadProcessId(_hwnd, NULL));

    pti->ptsh = new TaskShortcut(pszExeName, pid);
}

//
//  There is a race condition between app startup and our receiving the
//  change notification.  If the app starts up first, the
//  _AttachTaskShortcut will fail because we haven't received the change
//  notification yet.
//
//  _ReattachTaskShortcut looks back through the taskbar and checks if
//  the program for which we received the change notification is already
//  on the taskbar, in which case we update his information retroactively.
//
void CTaskBand::_ReattachTaskShortcut()
{
    // Make sure nobody tries to do this in a multithreaded way
    // since we're not protecting the cache with a critical section
    ASSERT(GetCurrentThreadId() == GetWindowThreadProcessId(_hwnd, NULL));

    int i;
    for (i = _tb.GetButtonCount() - 1; i >= 0; i--)
    {
        PTASKITEM ptiT = _GetItem(i);
        if (ptiT->ptsh && ptiT->ptsh->MatchesCachedPid(ptiT))
        {
            int iIndexGroup = _GetGroupIndex(i);
            PTASKITEM ptiGroup = _GetItem(iIndexGroup);
            if (ptiT->ptsh->MatchesCachedExe(ptiGroup))
            {
                ptiT->ptsh->SetInfoFromCache();
                // Stop after finding the first match, since all apps
                // with the same pid share the same TaskShortcut, so
                // updating one entry fixes them all.
                return;
            }
        }
    }

}

//---------------------------------------------------------------------------

void TaskShortcut::Tickle()
{
    if (_pszShortcutName)
    {
        DWORD tmNow = GetTickCount();
        if (tmNow - _tmTickle > s_msSession)
        {
            _tmTickle = tmNow;

            // Note that we promote only once, even if multiple tickle intervals
            // have elapsed.  That way, if you leave Outlook running while you
            // go on a two-week vacation, then click on Outlook when you get
            // back, we treat this as one usage, not dozens.
            //
            Promote();
        }
    }
}

//---------------------------------------------------------------------------
// Returns whether or not we actually promoted anybody

BOOL TaskShortcut::_PromotePidl(LPCITEMIDLIST pidl, BOOL fForce)
{
    BOOL fPromoted = FALSE;
    IShellFolder *psf;
    LPCITEMIDLIST pidlChild;
    if (SUCCEEDED(SHBindToFolderIDListParent(NULL, pidl,
                        IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
    {
        if (!fForce)
        {
            // Don't fire the event if somebody else ran the
            // shortcut within the last session.  We want to bump
            // the usage count only once per session even if there
            // are multiple apps running that use the shortcut.

            FILETIME ftSession;         // start of current session
            GetSystemTimeAsFileTime(&ftSession);
            DecrementFILETIME(&ftSession, (__int64)10000 * s_msSession);

            UEMINFO uei;
            uei.cbSize = sizeof(uei);
            uei.dwMask = UEIM_FILETIME;
            SetFILETIMEfromInt64(&uei.ftExecute, 0);

            // If this query fails, then uei.ftExecute stays 0
            UEMQueryEvent(&UEMIID_SHELL, UEME_RUNPIDL,
                         (WPARAM)psf, (LPARAM)pidlChild, &uei);

            fForce = CompareFileTime(&uei.ftExecute, &ftSession) < 0;
        }

        if (fForce)
        {
            UEMFireEvent(&UEMIID_SHELL, UEME_RUNPIDL, UEMF_XEVENT,
                         (WPARAM)psf, (LPARAM)pidlChild);
            fPromoted = TRUE;
        }
        psf->Release();
    }
    return fPromoted;
}

//---------------------------------------------------------------------------

void TaskShortcut::Promote()
{
    // Use SHSimpleIDListFromPath so we don't spin up drives or
    // hang Explorer if the drive is unavailable
    LPITEMIDLIST pidl = SHSimpleIDListFromPath(_pszShortcutName);
    if (pidl)
    {
        if (_PromotePidl(pidl, FALSE))
        {
            // Now we have to walk back up the tree to the root of our
            // csidl, because that's what the Start Menu does.
            // (Promoting a child entails promoting all his parents.
            // Otherwise you can get into a weird state where a child
            // has been promoted but his ancestors haven't.)

            LPITEMIDLIST pidlParent;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, _csidl, &pidlParent)))
            {
                for (ILRemoveLastID(pidl);
                     ILIsParent(pidlParent, pidl, FALSE); ILRemoveLastID(pidl))
                {
                    _PromotePidl(pidl, TRUE);
                }
            }
        }
        ILFree(pidl);
    }
}

//---------------------------------------------------------------------------

BOOL _IsChildOfCsidl(int csidl, LPCWSTR pwszPath)
{
    WCHAR wszCsidl[MAX_PATH];

    // Explicitly check S_OK.  S_FALSE means directory doesn't exist,
    // so no point in checking for prefix.
    if (S_OK == SHGetFolderPathW(NULL, csidl, NULL, SHGFP_TYPE_CURRENT, wszCsidl))
    {
        return PathIsPrefixW(wszCsidl, pwszPath);
    }
    return FALSE;
}

const int c_rgCsidlShortcutInvoke[] = {
    CSIDL_DESKTOPDIRECTORY,
    CSIDL_PROGRAMS,
    CSIDL_COMMON_DESKTOPDIRECTORY,
    CSIDL_COMMON_PROGRAMS,
};

BOOL TaskShortcut::_HandleShortcutInvoke(LPSHShortcutInvokeAsIDList psidl)
{
    // The shortcut must reside in one of the directories that the Start Page
    // cares about
    int i;
    for (i = 0; i < ARRAYSIZE(c_rgCsidlShortcutInvoke); i++)
    {
        if (_IsChildOfCsidl(c_rgCsidlShortcutInvoke[i], psidl->szShortcutName))
        {
            // Yes it is -- cache it
            s_pidCache = psidl->dwPid;
            s_csidlCache = c_rgCsidlShortcutInvoke[i];
            StringCchCopy(s_szShortcutNameCache, ARRAYSIZE(s_szShortcutNameCache), psidl->szShortcutName);
            StringCchCopy(s_szTargetNameCache, ARRAYSIZE(s_szTargetNameCache), psidl->szTargetName);
            return TRUE;
        }
    }
    return FALSE;
}

TASKITEM::TASKITEM(TASKITEM* pti)
{
    hwnd = pti->hwnd;
    dwFlags = pti->dwFlags;
    ptsh = NULL;
    dwTimeLastClicked = pti->dwTimeLastClicked;
    dwTimeFirstOpened = pti->dwTimeFirstOpened;

    if (pti->pszExeName)
    {
        int cchExeName = lstrlen(pti->pszExeName) + 1;
        pszExeName = new WCHAR[cchExeName];
        if (pszExeName)
        {
            StringCchCopy(pszExeName, cchExeName, pti->pszExeName);
        }
    }
}

TASKITEM::~TASKITEM()
{
    if (ptsh) ptsh->Release();
    if (pszExeName)
    {
        delete [] pszExeName;
    }
}

BOOL IsSmallerThanScreen(HWND hwnd)
{
    HMONITOR hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY);
    MONITORINFO mi;
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);

    WINDOWINFO wi;
    wi.cbSize = sizeof(wi);
    GetWindowInfo(hwnd, &wi);

    int dxMax = mi.rcWork.right - mi.rcWork.left;
    int dyMax = mi.rcWork.bottom - mi.rcWork.top;

    return ((wi.rcWindow.right - wi.rcWindow.left < dxMax) ||
            (wi.rcWindow.bottom - wi.rcWindow.top < dyMax));
}

HMENU _GetSystemMenu(HWND hwnd)
{
    // We have to make a copy of the menu because the documentation for
    // GetSystemMenu blatantly lies, it does not give you a copy of the hmenu
    // and you are not at liberty to alter said menu
    HMENU hmenu = CreatePopupMenu();

    Shell_MergeMenus(hmenu, GetSystemMenu(hwnd, FALSE), 0, 0, 0xffff, 0);

    if (hmenu)
    {
        /* Stolen from Core\ntuser\kernel\mnsys.c xxxSetSysMenu */
        UINT wSize;
        UINT wMinimize;
        UINT wMaximize;
        UINT wMove;
        UINT wRestore;
        UINT wDefault;
        LONG lStyle = GetWindowLong(hwnd, GWL_STYLE);

        /*
         * System modal window: no size, icon, zoom, or move.
         */

        wSize = wMaximize = wMinimize = wMove =  0;
        wRestore = MFS_GRAYED;

        //
        // Default menu command is close.
        //
        wDefault = SC_CLOSE;

        /*
         * Minimized exceptions: no minimize, restore.
         */

        // we need to reverse these because VB has a "special" window
        // that is both minimized but without a minbox.
        if (IsIconic(hwnd))
        {
            wRestore  = 0;
            wMinimize = MFS_GRAYED;
            wSize     = MFS_GRAYED;
            wDefault  = SC_RESTORE;
        }
        else if (!(lStyle & WS_MINIMIZEBOX))
            wMinimize = MFS_GRAYED;

        /*
         * Maximized exceptions: no maximize, restore.
         */
        if (!(lStyle & WS_MAXIMIZEBOX))
            wMaximize = MFS_GRAYED;
        else if (IsZoomed(hwnd)) {
            wRestore = 0;

            /*
             * If the window is maximized but it isn't larger than the
             * screen, we allow the user to move the window around the
             * desktop (but we don't allow resizing).
             */
            wMove = MFS_GRAYED;
            if (!(lStyle & WS_CHILD)) {
                if (IsSmallerThanScreen(hwnd)) {
                    wMove = 0;
                }
            }

            wSize     = MFS_GRAYED;
            wMaximize = MFS_GRAYED;
        }

        if (!(lStyle & WS_SIZEBOX))
            wSize = MFS_GRAYED;

        /*
         * Are we dealing with a framed dialog box with a sys menu?
         * Dialogs with min/max/size boxes get a regular system menu
         *  (as opposed to the dialog menu)
         */
        if (!(lStyle & WS_DLGFRAME) || (lStyle & (WS_SIZEBOX | WS_MINIMIZEBOX | WS_MAXIMIZEBOX))) {
            EnableMenuItem(hmenu, (UINT)SC_SIZE, wSize);
            EnableMenuItem(hmenu, (UINT)SC_MINIMIZE, wMinimize);
            EnableMenuItem(hmenu, (UINT)SC_MAXIMIZE, wMaximize);
            EnableMenuItem(hmenu, (UINT)SC_RESTORE, wRestore);
        }

        EnableMenuItem(hmenu, (UINT)SC_MOVE, wMove);

        SetMenuDefaultItem(hmenu, wDefault, MF_BYCOMMAND);
    }

    return hmenu;
}

void CTaskBand::_ExecuteMenuOption(HWND hwnd, int iCmd)
{
    if (iCmd == SC_SIZE || iCmd == SC_MOVE)
    {
        _FreePopupMenu();
        SwitchToThisWindow(hwnd, TRUE);
    }

    PostMessage(hwnd, WM_SYSCOMMAND, iCmd, 0);
}

BOOL _IsWindowNormal(HWND hwnd)
{
    return (hwnd != v_hwndTray) && (hwnd != v_hwndDesktop) && IsWindow(hwnd);
}

void _RestoreWindow(HWND hwnd, DWORD dwFlags)
{
    HWND hwndTask = hwnd;
    HWND hwndProxy = hwndTask;
    if (g_fDesktopRaised) 
    {
        _RaiseDesktop(FALSE);
    }

    // set foreground first so that we'll switch to it.
    if (IsIconic(hwndTask) && 
        (dwFlags & TIF_EVERACTIVEALT)) 
    {
        HWND hwndProxyT = (HWND) GetWindowLongPtr(hwndTask, 0);
        if (hwndProxyT != NULL && IsWindow(hwndProxyT))
            hwndProxy = hwndProxyT;
    }

    SetForegroundWindow(GetLastActivePopup(hwndProxy));
    if (hwndProxy != hwndTask)
        SendMessage(hwndTask, WM_SYSCOMMAND, SC_RESTORE, -2);
}

PTASKITEM CTaskBand::_GetItem(int i, TBBUTTONINFO* ptbb /*= NULL*/, BOOL fByIndex /*= TRUE*/)
{
    if (i >= 0 && i < _tb.GetButtonCount())
    {
        TBBUTTONINFO tbb;

        if (ptbb == NULL)
        {
            ptbb = &tbb;
            ptbb->dwMask = TBIF_LPARAM;
        }
        else
        {
            ptbb->dwMask = TBIF_COMMAND | TBIF_IMAGE | TBIF_LPARAM |
                            TBIF_SIZE | TBIF_STATE | TBIF_STYLE;
        }

        if (fByIndex)
        {
            ptbb->dwMask |= TBIF_BYINDEX;
        }

        ptbb->cbSize = sizeof(*ptbb);

        _tb.GetButtonInfo(i, ptbb);

        ASSERT(ptbb->lParam);   // we check for NULL before insertion, so shouldn't be NULL here

        return (PTASKITEM)ptbb->lParam;
    }
    return NULL;
}

int CTaskBand::_FindIndexByHwnd(HWND hwnd)
{
    if (hwnd)
    {
        for (int i = _tb.GetButtonCount() - 1; i >= 0; i--)
        {
            PTASKITEM pti = _GetItem(i);

            if (pti && pti->hwnd == hwnd)
            {
                return i;
            }
        }
    }

    return -1;
}

void CTaskBand::_CheckNeedScrollbars(int cyRow, int cItems, int iCols, int iRows,
                                     int iItemWidth, LPRECT prcView)
{
    int cxRow = iItemWidth;
    int iVisibleColumns = RECTWIDTH(*prcView) / cxRow;
    int iVisibleRows = RECTHEIGHT(*prcView) / cyRow;

    int x,y, cx,cy;

    RECT rcTabs;
    rcTabs = *prcView;

    iVisibleColumns = max(iVisibleColumns, 1);
    iVisibleRows = max(iVisibleRows, 1);

    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE | SIF_RANGE;
    si.nMin = 0;
    si.nPage = 0;
    si.nPos = 0;

    if (_IsHorizontal())
    {
        // do vertical scrollbar
        // -1 because it's 0 based.
        si.nMax = (cItems + iVisibleColumns - 1) / iVisibleColumns  -1 ;
        si.nPage = iVisibleRows;

        // we're actually going to need the scrollbars
        if (si.nPage <= (UINT)si.nMax)
        {
            // this effects the vis columns and therefore nMax and nPage
            rcTabs.right -= g_cxVScroll;
            iVisibleColumns = RECTWIDTH(rcTabs) / cxRow;
            if (!iVisibleColumns)
                iVisibleColumns = 1;
            si.nMax = (cItems + iVisibleColumns - 1) / iVisibleColumns  -1 ;
        }

        SetScrollInfo(_hwnd, SB_VERT, &si, TRUE);
        si.fMask = SIF_POS | SIF_PAGE | SIF_RANGE;
        GetScrollInfo(_hwnd, SB_VERT, &si);
        x = 0;
        y = -si.nPos * cyRow;
        if (iRows == 1)
        {
            cx = RECTWIDTH(rcTabs);        
        }
        else
        {
            cx = cxRow * iVisibleColumns;
        }
        // +1 because si.nMax is zero based
        cy = cyRow * (si.nMax +1);

        // nuke the other scroll bar
        _NukeScrollbar(SB_HORZ);
    }
    else
    {
        // do horz scrollbar
        si.nMax = iCols -1;
        si.nPage = iVisibleColumns;

        // we're actually going to need the scrollbars
        if (si.nPage <= (UINT)si.nMax)
        {
            // this effects the vis columns and therefore nMax and nPage
            rcTabs.bottom -= g_cyHScroll;
            iVisibleRows = RECTHEIGHT(rcTabs) / cyRow;
            if (!iVisibleRows)
                iVisibleRows = 1;
            si.nMax = (cItems + iVisibleRows - 1) / iVisibleRows  -1 ;
        }

        SetScrollInfo(_hwnd, SB_HORZ, &si, TRUE);
        si.fMask = SIF_POS | SIF_PAGE | SIF_RANGE;
        GetScrollInfo(_hwnd, SB_HORZ, &si);
        y = 0;
        x = -si.nPos * cxRow;

        cx = cxRow * (si.nMax + 1);
        cy = cyRow * iVisibleRows;

        // nuke the other scroll bar
        _NukeScrollbar(SB_VERT);
    }

    _tb.SetWindowPos(0, x,y, cx, cy, SWP_NOACTIVATE| SWP_NOZORDER);
}

void CTaskBand::_NukeScrollbar(int fnBar)
{
    SCROLLINFO si;
    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
    si.cbSize = sizeof(si);
    si.nMin = 0;
    si.nMax = 0;
    si.nPage = 0;
    si.nPos = 0;

    SetScrollInfo(_hwnd, fnBar, &si, TRUE);
}

BOOL CTaskBand::_IsHidden(int i)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_STATE | TBIF_BYINDEX;
    _tb.GetButtonInfo(i, &tbbi);
    if (tbbi.fsState & TBSTATE_HIDDEN)
    {
        return TRUE;
    }

    return FALSE;
}

int CTaskBand::_GetGroupIndexFromExeName(WCHAR* pszExeName)
{
    for (int i = _tb.GetButtonCount() - 1; i >=0; i--)
    {
        PTASKITEM pti = _GetItem(i);
        if ((!pti->hwnd) && (lstrcmpi(pti->pszExeName, pszExeName) == 0))
        {
            return i;
        }
    }

    return -1;
}

DWORD CTaskBand::_GetGroupAge(int iIndexGroup)
{
    int iGroupSize = _GetGroupSize(iIndexGroup);
    DWORD dwTimeLastClicked = _GetItem(iIndexGroup + 1)->dwTimeLastClicked;

    for (int i = iIndexGroup + 2; i <= iIndexGroup + iGroupSize; i++)
    {
        PTASKITEM pti = _GetItem(i);
        if (pti->dwTimeLastClicked > dwTimeLastClicked)
        {
            dwTimeLastClicked = pti->dwTimeLastClicked;
        }
    }

    return dwTimeLastClicked;
}

//
// _GetGroupSize: returns size of group *not including* the group button
//
int CTaskBand::_GetGroupSize(int iIndexGroup)
{
    int iGroupSize = 0;

    PTASKITEM ptiGroup = _GetItem(iIndexGroup);
    if (ptiGroup)
    {
        ASSERT(!ptiGroup->hwnd);
        int cButtons = _tb.GetButtonCount();
        for (int i = iIndexGroup + 1; i < cButtons; i++)
        {
            PTASKITEM pti = _GetItem(i);
            if (!pti->hwnd)
            {
                break;
            }

            iGroupSize++;
        }
    }

    return iGroupSize;
}

int CTaskBand::_GetGroupIndex(int iIndexApp)
{
    int i = iIndexApp;
    while ((i > 0) && (_GetItem(i)->hwnd))
    {
        i--;
    }

    return i;
}

void CTaskBand::_UpdateFlashingFlag()
{
    // Loop through the tab items, see if any have TIF_FLASHING
    // set, and update the flashing flag.
    _fFlashing = FALSE;

    int iCount = _tb.GetButtonCount();
    for (int i = 0; i < iCount; i++)
    {
        PTASKITEM pti = _GetItem(i);

        if (!pti->hwnd)
        {
            pti->dwFlags &= ~(TIF_FLASHING | TIF_RENDERFLASHED);
        }
        else
        {
            int iGroupIndex = _GetGroupIndex(i);
            PTASKITEM ptiGroup = _GetItem(iGroupIndex);

            if (pti->dwFlags & TIF_FLASHING)
            {
                ptiGroup->dwFlags |= TIF_FLASHING;
                _fFlashing = TRUE;
            }

            if (pti->dwFlags & TIF_RENDERFLASHED)
            {
                ptiGroup->dwFlags |= TIF_RENDERFLASHED;
            }
        }
    }
}

void CTaskBand::_RealityCheck()
{
    //
    // Delete any buttons corresponding to non-existent windows.
    //
    for (int i = 0; i < _tb.GetButtonCount(); i++)
    {
        PTASKITEM pti = _GetItem(i);
        // NOTE: HWND_TOPMOST is used to indicate that the deleted button 
        // is being animated. This allows the button to stay around after 
        // its real hwnd becomes invalid
        if (pti->hwnd && !IsWindow(pti->hwnd) && 
           ((pti->hwnd != HWND_TOPMOST) || !_dsaAII.GetItemCount()))
        {
#ifdef DEBUG
            PTASKITEM ptiGroup = _GetItem(_GetGroupIndex(i));
            TraceMsg(TF_WARNING, "CTaskBand::_RealityCheck: window %x (%s) no longer valid", pti->hwnd, ptiGroup->pszExeName);
#endif
            _DeleteItem(pti->hwnd, i);
        }
    }
}

class ICONDATA
{
public:
    ICONDATA(int i, CTaskBand* p) : iPref(i), ptb(p) { ptb->AddRef(); }
    virtual ~ICONDATA() { ptb->Release(); }

    int iPref;
    CTaskBand* ptb;
};

typedef ICONDATA* PICONDATA;

void CALLBACK CTaskBand::IconAsyncProc(HWND hwnd, UINT uMsg, ULONG_PTR dwData, LRESULT lResult)
{
    PICONDATA pid = (PICONDATA)dwData;
    if (pid)
    {
        pid->ptb->_SetWindowIcon(hwnd, (HICON)lResult, pid->iPref);
        delete pid;
    }
}

int CTaskBand::GetIconCB(CTaskBand* ptb, PICONCBPARAM pip, LPARAM lParam, int iPref)
{
    int iRet = I_IMAGENONE;
    
    if (IsWindow(pip->hwnd))
    {
        PICONDATA pid = new ICONDATA(iPref, ptb);
        if (pid)
        {
            if (!SendMessageCallback(pip->hwnd, WM_GETICON, lParam, 0, CTaskBand::IconAsyncProc, (ULONG_PTR)pid))
            {
                delete pid;
            }
        }
    }

    return iRet;
}

int CTaskBand::GetSHILIconCB(CTaskBand* ptb, PICONCBPARAM pip, LPARAM lParam, int)
{
    int iRet = I_IMAGENONE;
    TCHAR szIcon[MAX_PATH];
    DWORD cb = sizeof(szIcon);

    HKEY hkeyApp;
    if (SUCCEEDED(AssocQueryKey(ASSOCF_OPEN_BYEXENAME | ASSOCF_VERIFY, ASSOCKEY_APP, pip->pszExeName, NULL, &hkeyApp)))
    {
        if (ERROR_SUCCESS == SHGetValue(hkeyApp, NULL, TEXT("TaskbarGroupIcon"), NULL, szIcon, &cb))
        {
            int iIcon = PathParseIconLocation(szIcon);
            int iIndex = Shell_GetCachedImageIndex(szIcon, iIcon, 0);
            if (iIndex >= 0)
            {
                iRet = MAKELONG(iIndex, IL_SHIL);
            }
        }
        RegCloseKey(hkeyApp);
    }

    if (iRet == I_IMAGENONE)
    {
        int iIndex = Shell_GetCachedImageIndex(pip->pszExeName, 0, 0);
        if (iIndex >= 0)
        {
            iRet = MAKELONG(iIndex, IL_SHIL);
        }
    }

    return iRet;    
}

int CTaskBand::GetDefaultIconCB(CTaskBand* ptb, PICONCBPARAM pip, LPARAM, int)
{
    HICON hicon = LoadIcon(NULL, IDI_WINLOGO);
    return ptb->_AddIconToNormalImageList(hicon, pip->iImage);
}

int CTaskBand::GetClassIconCB(CTaskBand* ptb, PICONCBPARAM pip, LPARAM lParam, int)
{
    if (IsWindow(pip->hwnd))
    {
        HICON hicon = (HICON)GetClassLongPtr(pip->hwnd, (int)lParam);
        return ptb->_AddIconToNormalImageList(hicon, pip->iImage);
    }
    return I_IMAGENONE;
}

void CTaskBand::_UpdateItemIcon(int iIndex)
{
    static const struct
    {
        PICONCALLBACK pfnCB;
        LPARAM lParam;
    }
    c_IconCallbacks[] =
    {
        { CTaskBand::GetIconCB,         ICON_SMALL2     },
        { CTaskBand::GetIconCB,         ICON_SMALL      },
        { CTaskBand::GetIconCB,         ICON_BIG        },
        { CTaskBand::GetClassIconCB,    GCLP_HICONSM    },
        { CTaskBand::GetClassIconCB,    GCLP_HICON      },
        { CTaskBand::GetSHILIconCB,     0,              },
        { CTaskBand::GetDefaultIconCB,  0,              },
    };

    TBBUTTONINFO tbbi;
    PTASKITEM pti = _GetItem(iIndex, &tbbi);

    if (pti)
    {
        int iIndexGroup = _GetGroupIndex(iIndex);
        PTASKITEM ptiGroup = _GetItem(iIndexGroup);
        if (ptiGroup)
        {
            ICONCBPARAM ip;
            ip.hwnd = pti->hwnd;
            ip.pszExeName = ptiGroup->pszExeName;
            ip.iImage = tbbi.iImage;

            for (int i = 0; i < ARRAYSIZE(c_IconCallbacks); i++)
            {
                int iPref = (ARRAYSIZE(c_IconCallbacks) - i) + 1;
                if (iPref >= pti->iIconPref)
                {
                    PTASKITEM ptiTemp = _GetItem(iIndex);
                    if (ptiTemp == pti)
                    {
                        int iImage = c_IconCallbacks[i].pfnCB(this, &ip, c_IconCallbacks[i].lParam, iPref);
                        if (iImage != I_IMAGENONE)
                        {
                            _SetItemImage(iIndex, iImage, iPref);
                            break;
                        }
                    }
                }
            }
        }
    }
}

BOOL IsValidHICON(HICON hicon)
{
    BOOL fIsValid = FALSE;

    if (hicon)
    {
        // Check validity of icon returned
        ICONINFO ii = {0};
        fIsValid = GetIconInfo(hicon, &ii);

        if (ii.hbmMask)
        {
            DeleteObject(ii.hbmMask);
        }

        if (ii.hbmColor)
        {
            DeleteObject(ii.hbmColor);
        }
    }

    return fIsValid;
}

void CTaskBand::_MoveGroup(HWND hwnd, WCHAR* szNewExeName)
{
    BOOL fRedraw = (BOOL)_tb.SendMessage(WM_SETREDRAW, FALSE, 0);

    int iIndexNewGroup = _GetGroupIndexFromExeName(szNewExeName);
    int iIndexOld = _FindIndexByHwnd(hwnd);
    int iIndexOldGroup = _GetGroupIndex(iIndexOld);

    if (iIndexNewGroup != iIndexOldGroup)
    {
        if (iIndexOld >= 0)
        {
            PTASKITEM pti = _GetItem(iIndexOld);

            if (iIndexNewGroup < 0)
            {
                PTASKITEM ptiGroup = new TASKITEM;
                if (ptiGroup)
                {
                    ptiGroup->hwnd = NULL;
                    ptiGroup->dwTimeLastClicked = 0;
                    int cchExeName = lstrlen(szNewExeName) + 1;
                    ptiGroup->pszExeName = new WCHAR[cchExeName];
                    if (ptiGroup->pszExeName)
                    {
                        StringCchCopy(ptiGroup->pszExeName, cchExeName, szNewExeName);

                        iIndexNewGroup = _AddToTaskbar(ptiGroup, -1, FALSE, FALSE);
                        if (iIndexNewGroup < 0)
                        {
                            delete[] ptiGroup->pszExeName;
                            delete ptiGroup;
                        }
                        else if (iIndexNewGroup <= iIndexOldGroup)
                        {
                            iIndexOld++;
                            iIndexOldGroup++;
                        }
                    }
                    else
                    {
                        delete ptiGroup;
                    }
                }
            }

            if (iIndexNewGroup >= 0)
            {
                int iIndexNew = _AddToTaskbar(pti, iIndexNewGroup + _GetGroupSize(iIndexNewGroup) + 1, _IsHidden(iIndexNewGroup), FALSE);

                if (iIndexNew >= 0)
                {
                    _CheckButton(iIndexNew, pti->dwFlags & TIF_CHECKED);

                    if (iIndexNew <= iIndexOldGroup)
                    {
                        iIndexOld++;
                        iIndexOldGroup++;
                    }

                    // Copy the old icon to prevent re-getting the icon
                    TBBUTTONINFO tbbiOld;
                    _GetItem(iIndexOld, &tbbiOld);

                    TBBUTTONINFO tbbiNew;
                    _GetItem(iIndexNew, &tbbiNew);

                    tbbiNew.iImage = tbbiOld.iImage;
                    tbbiNew.dwMask = TBIF_BYINDEX | TBIF_IMAGE;
                    _tb.SetButtonInfo(iIndexNew, &tbbiNew);

                    tbbiOld.iImage = I_IMAGENONE;
                    tbbiOld.dwMask = TBIF_BYINDEX | TBIF_IMAGE;
                    _tb.SetButtonInfo(iIndexOld, &tbbiOld);

                    _DeleteTaskItem(iIndexOld, FALSE);
                    int iSize = _GetGroupSize(iIndexOldGroup);
                    if (iSize == 0)
                    {
                        _DeleteTaskItem(iIndexOldGroup, TRUE);
                    }
                    else if (iSize == 1)
                    {
                        _Glom(iIndexOldGroup, FALSE);
                    }
                }
            }
        }
    }

    _tb.SetRedraw(fRedraw);

    _CheckSize();
}

void CTaskBand::_SetWindowIcon(HWND hwnd, HICON hicon, int iPref)
{
    int iIndex = _FindIndexByHwnd(hwnd);
    if (iIndex >= 0)
    {
        TBBUTTONINFO tbbi;
        PTASKITEM pti = _GetItem(iIndex, &tbbi);
        if (iPref >= pti->iIconPref && IsValidHICON(hicon))
        {
            int iImage = _AddIconToNormalImageList(hicon, tbbi.iImage);
            if (iImage >= 0)
            {
                _SetItemImage(iIndex, iImage, iPref);

                if (pti->hwnd)
                {
                    int iIndexGroup = _GetGroupIndex(iIndex);
                    PTASKITEM ptiGroup = _GetItem(iIndexGroup);

                    HKEY hkeyApp;
                    if (SUCCEEDED(AssocQueryKey(ASSOCF_OPEN_BYEXENAME | ASSOCF_VERIFY, ASSOCKEY_APP, ptiGroup->pszExeName, NULL, &hkeyApp)))
                    {
                        HKEY hkeyIcons;
                        if (ERROR_SUCCESS == RegOpenKeyEx(hkeyApp, TEXT("TaskbarExceptionsIcons"), 0, KEY_READ, &hkeyIcons))
                        {
                            int      iKey = 0;
                            WCHAR    szKeyName[MAX_PATH];
                            DWORD    cchKeyName = ARRAYSIZE(szKeyName);
                            FILETIME ftBogus;
                            while (ERROR_SUCCESS == RegEnumKeyEx(hkeyIcons, iKey, szKeyName, &cchKeyName, NULL, NULL, NULL, &ftBogus))
                            {
                                HKEY hkeyNewGroup;
                                if (ERROR_SUCCESS == RegOpenKeyEx(hkeyIcons, szKeyName, 0, KEY_READ, &hkeyNewGroup))
                                {
                                    WCHAR szIconName[MAX_PATH];
                                    DWORD cbIconName = sizeof(szIconName);
                                    if (ERROR_SUCCESS == RegQueryValueEx(hkeyNewGroup, L"IconPath", NULL, NULL, (LPBYTE)szIconName, &cbIconName))
                                    {
                                        HICON hiconDll = NULL;

                                        int iIconIndex = PathParseIconLocation(szIconName);
                                        ExtractIconEx(szIconName, iIconIndex, NULL, &hiconDll, 1);

                                        if (hiconDll)
                                        {
                                            if (SHAreIconsEqual(hiconDll, hicon))
                                            {
                                                WCHAR szNewGroup[MAX_PATH];
                                                DWORD cbNewGroup = sizeof(szNewGroup);
                                                if (ERROR_SUCCESS == RegQueryValueEx(hkeyNewGroup, L"NewExeName", NULL, NULL, (LPBYTE)szNewGroup, &cbNewGroup))
                                                {
                                                    for (int i = _tb.GetButtonCount() - 1; i >=0; i--)
                                                    {
                                                        PTASKITEM pti = _GetItem(i);
                                                        if (!pti->hwnd)
                                                        {
                                                            WCHAR* pszGroupExe = PathFindFileName(pti->pszExeName);
                                                            if (pszGroupExe && (lstrcmpi(pszGroupExe, szNewGroup) == 0))
                                                            {
                                                                DWORD dwType;
                                                                // Make it is an exe and that it exists
                                                                if (GetBinaryType(pti->pszExeName, &dwType))
                                                                {
                                                                    _MoveGroup(hwnd, pti->pszExeName);
                                                                }
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            DestroyIcon(hiconDll);
                                        }
                                    }
                                    RegCloseKey(hkeyNewGroup);
                                }

                                cchKeyName = ARRAYSIZE(szKeyName);
                                iKey++;
                            }
                            RegCloseKey(hkeyIcons);
                        }
                        RegCloseKey(hkeyApp);
                    }
                }
            }
        }
    }
}

void CTaskBand::_Glom(int iIndexGroup, BOOL fGlom)
{
    BOOL fRedraw = (BOOL)_tb.SendMessage(WM_SETREDRAW, FALSE, 0);

    if ((!fGlom) && (iIndexGroup == _iIndexPopup))
    {
        _FreePopupMenu();
    }

    if (fGlom == _IsHidden(iIndexGroup))
    {
        if (_fAnimate && _IsHorizontal())
        {
            int iGroupSize = _GetGroupSize(iIndexGroup);

            if (!fGlom)
            {
                _HideGroup(iIndexGroup, FALSE);

                if (iGroupSize)
                { 
                    int iWidth = _GetItemWidth(iIndexGroup) / iGroupSize;
                    iWidth = max(iWidth, 1);
                    for(int i = iIndexGroup + iGroupSize; i > iIndexGroup; i--)
                    {
                        _SetItemWidth(i, iWidth);
                    } 
                }
            }

            if (!(fGlom && (_GetItem(iIndexGroup)->dwFlags & TIF_ISGLOMMING)))
            {
                _AnimateItems(iIndexGroup, !fGlom, TRUE);      
            }
        }
        else
        {
            _HideGroup(iIndexGroup, fGlom);
            _CheckSize();
        }
    }

    _tb.SetRedraw(fRedraw);
}


void CTaskBand::_HideGroup(int iIndexGroup, BOOL fHide)
{
    int iGroupSize = _GetGroupSize(iIndexGroup);

    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_STATE | TBIF_BYINDEX;

    // Glom button
    _tb.GetButtonInfo(iIndexGroup, &tbbi);
    tbbi.fsState = fHide ? (tbbi.fsState & ~TBSTATE_HIDDEN) : (tbbi.fsState | TBSTATE_HIDDEN);
    _tb.SetButtonInfo(iIndexGroup, &tbbi);

    // Group buttons
    for (int i = iIndexGroup + iGroupSize; i > iIndexGroup; i--)
    {
        _tb.GetButtonInfo(i, &tbbi);
        tbbi.fsState = fHide ? (tbbi.fsState | TBSTATE_HIDDEN) : (tbbi.fsState & ~TBSTATE_HIDDEN);
        _tb.SetButtonInfo(i, &tbbi);
    }
}

BOOL CTaskBand::_AutoGlomGroup(BOOL fGlom, int iOpenSlots)
{
    int iIndex = -1;
    DWORD dwTimeLastClicked = 0;
    int iSize = 0;

    int i = 0;
    while (i < _tb.GetButtonCount())
    {
        PTASKITEM pti = _GetItem(i);
        int iGroupSize = _GetGroupSize(i);
        // Don't mess with the blank group
        if ((pti->pszExeName && (pti->pszExeName[0] != 0)) &&
            (fGlom || (!fGlom && ((_iGroupSize >= GLOM_SIZE) || (iGroupSize < iOpenSlots)))) &&
            ((iGroupSize > 1) && (fGlom == _IsHidden(i))))
        {
            BOOL fMatch;
            DWORD dwGroupTime = 0;

            switch (_iGroupSize)
            {
            case GLOM_OLDEST:
                dwGroupTime = _GetGroupAge(i);
                fMatch = (dwTimeLastClicked == 0) ||
                         (fGlom && (dwGroupTime < dwTimeLastClicked)) ||
                         (!fGlom && (dwGroupTime > dwTimeLastClicked));
                break;
            case GLOM_BIGGEST:
                fMatch = (fGlom && (iGroupSize > iSize)) ||
                         (!fGlom && ((iGroupSize < iSize) || (iSize == 0)));
                break;
            default:
                fMatch = (fGlom && (iGroupSize >= _iGroupSize)) ||
                         (!fGlom && (iGroupSize < _iGroupSize));
                break;
            }

            if (fMatch)
            {
                dwTimeLastClicked = dwGroupTime;
                iSize = iGroupSize;
                iIndex = i;
            }
        }
        i += iGroupSize + 1;
    }

    if ((iIndex != -1) &&
       (fGlom || (!fGlom && (iSize < iOpenSlots))))
    {
        _Glom(iIndex, fGlom);
        return TRUE;
    }

    return FALSE;
}


void CTaskBand::_GetItemTitle(int iIndex, WCHAR* pszTitle, int cchTitle, BOOL fCustom)
{
    PTASKITEM pti = _GetItem(iIndex);

    if (pti->hwnd)
    {
        if (InternalGetWindowText(pti->hwnd, pszTitle, cchTitle))
        {
            if (fCustom)
            {
                WCHAR szGrpText[MAX_PATH] = L" - ";
                int iIndexGroup = _GetGroupIndex(iIndex);
                _GetItemTitle(iIndexGroup, &szGrpText[3], MAX_PATH - 3, TRUE);
                int iLenGrp = lstrlen(szGrpText);
                int iLenWnd = lstrlen(pszTitle);

                if (iLenWnd > iLenGrp)
                {
                    if (StrCmp(&pszTitle[iLenWnd - iLenGrp], szGrpText) == 0)
                    {
                        pszTitle[iLenWnd - iLenGrp] = 0;
                    }
                }
            } 
        }
    }
    else
    {
        if ((pti->pszExeName) && (pti->pszExeName[0] != 0))
        {
            DWORD cchOut = cchTitle;

            AssocQueryString(ASSOCF_INIT_BYEXENAME | ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, pti->pszExeName, NULL, pszTitle, &cchOut);
        }
        else
        {
            pszTitle[0] = 0;
        }
    }
}

int CTaskBand::_AddToTaskbar(PTASKITEM pti, int iIndexTaskbar, BOOL fVisible, BOOL fForceGetIcon)
{
    ASSERT(IS_VALID_WRITE_PTR(pti, TASKITEM));

    int iIndex = -1;
    TBBUTTON tbb = {0};
    BOOL fRedraw = (BOOL)_tb.SendMessage(WM_SETREDRAW, FALSE, 0);

    if (fForceGetIcon)
    {
        tbb.iBitmap = I_IMAGENONE;
    }
    else
    {
        tbb.iBitmap = I_IMAGECALLBACK;
    }
    tbb.fsState = TBSTATE_ENABLED;
    if (!fVisible)
        tbb.fsState |= TBSTATE_HIDDEN;
    tbb.fsStyle = BTNS_CHECK | BTNS_NOPREFIX;
    if (!pti->hwnd)
        tbb.fsStyle |= BTNS_DROPDOWN | BTNS_WHOLEDROPDOWN;
    tbb.dwData = (DWORD_PTR)pti;
    tbb.idCommand = Toolbar_GetUniqueID(_tb);

    if (_tb.InsertButton(iIndexTaskbar, &tbb))
    {
        iIndex = iIndexTaskbar;
        if (iIndex == -1)
        {
            iIndex = _tb.GetButtonCount() - 1;
        }

        if (fForceGetIcon)
        {
            _UpdateItemIcon(iIndex);
        }

        _UpdateItemText(iIndex);
    }

    _tb.SetRedraw(fRedraw);
    return (iIndex);
}

void CTaskBand::_DeleteTaskItem(int iIndex, BOOL fDeletePTI)
{
    if (iIndex >= 0 && iIndex < _tb.GetButtonCount())
    {
        TBBUTTONINFO tbbi;
        PTASKITEM pti = _GetItem(iIndex, &tbbi);

        _tb.DeleteButton(iIndex);

        _RemoveItemFromAnimationList(pti);

        if (fDeletePTI)
        {
            delete pti;
        }

        _RemoveImage(tbbi.iImage);
    }
}

void CTaskBand::_SetThreadPriority(int iPriority, DWORD dwWakeupTime)
{
    if (_iOldPriority == INVALID_PRIORITY)
    {
        HANDLE hThread = GetCurrentThread();

        int iCurPriority = GetThreadPriority(hThread);
        // Make sure we are actually changed the thread priority
        if (iCurPriority != iPriority)
        {
            _iOldPriority = iCurPriority;
            _iNewPriority = iPriority;


            if (dwWakeupTime)
            {
                // Make sure that we are guaranteed to wakeup, by having the desktop thread up our thread priority
                SendMessage(GetShellWindow(), CWM_TASKBARWAKEUP, GetCurrentThreadId(), MAKELONG(dwWakeupTime, _iOldPriority));
            }

            SetThreadPriority(hThread, _iNewPriority);
            TraceMsg(TF_WARNING, "CTaskBand:: Thread Priority was changed from %d to %d", _iOldPriority, _iNewPriority);
        }
    }
}

void CTaskBand::_RestoreThreadPriority()
{
    if (_iOldPriority != INVALID_PRIORITY)
    {
        HANDLE hThread = GetCurrentThread();

        int iCurPriority = GetThreadPriority(hThread);
        // Make sure no one has changed our priority since that last time we did
        if (iCurPriority == _iNewPriority)
        {
            SetThreadPriority(hThread, _iOldPriority);
            SendMessage(GetShellWindow(), CWM_TASKBARWAKEUP, 0, 0);
            TraceMsg(TF_WARNING, "CTaskBand:: Thread Priority was restored from %d to %d", _iNewPriority, _iOldPriority);
        }

        _iOldPriority = INVALID_PRIORITY;
        _iNewPriority = INVALID_PRIORITY;
    }
}

void CTaskBand::_UpdateProgramCount()
{
    DWORD dwDisposition;
    HKEY hKey;

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, TEXT("SessionInformation"),
                                        0, NULL, REG_OPTION_VOLATILE, KEY_SET_VALUE,
                                        NULL, &hKey, &dwDisposition))
    {
        DWORD dwProgramCount = _ptray->CountOfRunningPrograms();
        RegSetValueEx(hKey, TEXT("ProgramCount"),
                           0, REG_DWORD, reinterpret_cast<LPBYTE>(&dwProgramCount),
                           sizeof(dwProgramCount));
        RegCloseKey(hKey);
    }
}

int CTaskBand::_InsertItem(HWND hwndTask, PTASKITEM pti, BOOL fForceGetIcon)
{
    _SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL, 5000);

    BOOL fRestoreThreadPriority = TRUE;
    PTASKITEM ptiGroup = NULL;
    WCHAR szExeName[MAX_PATH];
    int iRet = _FindIndexByHwnd(hwndTask);
    int iIndexGroup = -1;

    if (iRet != -1)
        return iRet;

    SHExeNameFromHWND(hwndTask, szExeName, ARRAYSIZE(szExeName));

    WCHAR* pszNoPath = PathFindFileName(szExeName);
    if (pszNoPath)
    {
        for (int i = 0; i < ARRAYSIZE(g_rgNoGlom); i++)
        {
            if (lstrcmpi(pszNoPath, g_rgNoGlom[i].szExeName) == 0)
            {
                StringCchPrintf(szExeName, ARRAYSIZE(szExeName), L"HWND%x", hwndTask);
            }
        }
    }

    // Initialize Taskbar entry, this entry will go into a group on the taskbar or onto the taskbar 
    if (!pti)
    {
        pti = new TASKITEM;
        if (!pti)
            goto Failure;
        pti->hwnd = hwndTask;
        pti->dwTimeFirstOpened = pti->dwTimeLastClicked = GetTickCount();
    }

    _AttachTaskShortcut(pti, szExeName);

    // Find the last taskbar entry with a given Exe Name
    if (_fGlom)
    {
        iIndexGroup = _GetGroupIndexFromExeName(szExeName);
    }

    if (iIndexGroup == -1)
    {
        ptiGroup = new TASKITEM;
        if (!ptiGroup)
            goto Failure;
        ptiGroup->hwnd = NULL;
        ptiGroup->dwTimeLastClicked = 0;
        int cchExeName = lstrlen(szExeName) + 1;
        ptiGroup->pszExeName = new WCHAR[cchExeName];
        if (!ptiGroup->pszExeName)
            goto Failure;
        StringCchCopy(ptiGroup->pszExeName, cchExeName, szExeName);

        iRet = _AddToTaskbar(ptiGroup, -1, FALSE, fForceGetIcon);
        if (iRet == -1)
            goto Failure;
        int iRetLast = iRet;
        iRet = _AddToTaskbar(pti, -1, TRUE, fForceGetIcon);
        if (iRet == -1)
        {
            _DeleteTaskItem(iRetLast, TRUE);
            ptiGroup = NULL;
        }
    }
    else
    {
        iRet = _AddToTaskbar(pti, iIndexGroup + _GetGroupSize(iIndexGroup) + 1, _IsHidden(iIndexGroup), fForceGetIcon);
    }

    // If _AddToTaskbar fails (iRet == -1) don't try to add this item anywhere else
    if ((iIndexGroup == _iIndexPopup) && (iRet != -1))
    {
        _AddItemToDropDown(iRet);
    }

Failure:
    if (iRet == -1)
    {
        if (ptiGroup)
        {
            delete ptiGroup;
        }
        if (pti)
        {
            delete pti;
        }
    }
    else
    {
        if (_fAnimate && _IsHorizontal() && 
            ToolBar_IsVisible(_tb, iRet) && !c_tray.IsTaskbarFading())
        {
            _SetItemWidth(iRet, 1); // cannot be zero or toolbar will resize it.

            // If this operation is successful then _AsyncAnimateItems will raise thread priority
            // after the animation is complete
            fRestoreThreadPriority = !_AnimateItems(iRet, TRUE, FALSE);
        }
    }
    
    _UpdateProgramCount();

    _CheckSize();

    if (fRestoreThreadPriority)
    {
        _RestoreThreadPriority();
    }

    return iRet;
}

//---------------------------------------------------------------------------
// Delete an item from the listbox but resize the buttons if needed.
void CTaskBand::_DeleteItem(HWND hwnd, int iIndex)
{
    if (iIndex == -1)
        iIndex = _FindIndexByHwnd(hwnd);

    if (iIndex != -1)
    {
        int iIndexGroup = _GetGroupIndex(iIndex);
        int iGroupSize = _GetGroupSize(iIndexGroup) - 1;

        if (iGroupSize == 0)
        {
            _FreePopupMenu();
            _DeleteTaskItem(iIndex, TRUE);
            _DeleteTaskItem(iIndexGroup, TRUE);
        }
        else if ((iGroupSize == 1) || (_fGlom && (_iGroupSize >= GLOM_SIZE) && (iGroupSize < _iGroupSize)))
        {
            _FreePopupMenu();
            _DeleteTaskItem(iIndex, TRUE);
            _Glom(iIndexGroup, FALSE);
        }
        else 
        {
            if (iIndexGroup == _iIndexPopup)
                _RemoveItemFromDropDown(iIndex);
            _DeleteTaskItem(iIndex, TRUE);
        }
        
        _CheckSize();
        // Update the flag that says, "There is an item flashing."
        _UpdateFlashingFlag();

        _UpdateProgramCount();
    }
}

//---------------------------------------------------------------------------
// Adds the given window to the task list.
// Returns TRUE/FALSE depending on whether the window was actually added.
// NB No check is made to see if it's already in the list.
BOOL CTaskBand::_AddWindow(HWND hwnd)
{
    if (_IsWindowNormal(hwnd))
    {
        return _InsertItem(hwnd);
    }

    return FALSE;
}

BOOL CTaskBand::_CheckButton(int iIndex, BOOL fCheck)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_STATE | TBIF_BYINDEX;
    _tb.GetButtonInfo(iIndex, &tbbi);
    if (fCheck)
        tbbi.fsState |= TBSTATE_CHECKED;
    else
        tbbi.fsState &= ~TBSTATE_CHECKED;
    return _tb.SetButtonInfo(iIndex, &tbbi);
}

BOOL CTaskBand::_IsButtonChecked(int iIndex)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_STATE | TBIF_BYINDEX;
    _tb.GetButtonInfo(iIndex, &tbbi);
    return BOOLIFY(tbbi.fsState & TBSTATE_CHECKED);
}

int CTaskBand::_GetCurSel()
{
    for (int i = _tb.GetButtonCount() - 1; i >= 0; i--)
    {
        if (_IsButtonChecked(i))
        {
            return i;
        }
    }
    return -1;
}

void CTaskBand::_SetCurSel(int iIndex, BOOL fIgnoreCtrlKey)
{
    // Under certain very rare circumstances someone will call us with an invalid index
    // Case #1: CallbackSM is called with a no longer valid uID with maps to a bogus index
    // Case #2: _SelectWindow creates a new button, but before calling this function another button is removed causing
    //          the index of the new button to be invalid
    if (iIndex == -1 || (iIndex >= 0 && iIndex < _tb.GetButtonCount()))
    {
        int iIndexGroup = (iIndex == -1) ? -1 : _GetGroupIndex(iIndex);
        BOOL fControlKey = (GetKeyState(VK_CONTROL) < 0) && (!fIgnoreCtrlKey);

        if (fControlKey)
        {
            if (GetForegroundWindow() != (HWND)_tb)
            {
                _fIgnoreTaskbarActivate = TRUE;
                _tb.SetFocus();
            }
        }

        for (int i = _tb.GetButtonCount() - 1; i >= 0; i--)
        {
            PTASKITEM pti = _GetItem(i);
            if (fControlKey)
            {
                if ((i == iIndex) || (i == iIndexGroup))
                {
                    pti->dwFlags = (pti->dwFlags & TIF_CHECKED) ? (pti->dwFlags & (~TIF_CHECKED)) : pti->dwFlags | TIF_CHECKED;
                }
            }
            else
            {
                pti->dwFlags = ((i == iIndex) || (i == iIndexGroup)) ? pti->dwFlags | TIF_CHECKED : (pti->dwFlags & (~TIF_CHECKED));
            }

            _CheckButton(i, pti->dwFlags & TIF_CHECKED);
        }
    }
}


//---------------------------------------------------------------------------
// If the given window is in the task list then it is selected.
// If it's not in the list then it is added.
int CTaskBand::_SelectWindow(HWND hwnd)
{
    int i;      // Initialize to zero for the empty case
    int iCurSel;

    // Are there any items?

    // Some item has the focus, is it selected?
    iCurSel = _GetCurSel();
    i = -1;

    // We aren't highlighting the correct task. Find it.
    if (IsWindow(hwnd))
    {
        i = _FindIndexByHwnd(hwnd);
        
        if ( i == -1 )
        {
            // Didn't find it - better add it now.
            i = _InsertItem(hwnd);
        }
        else if (i == iCurSel)
        {
            return i; // the current one is already selected
        }
    }

    // passing -1 is ok
    _SetCurSel(i, TRUE);
    if (i != -1)
    {
        _ScrollIntoView(i);
    }
    
    return i;
}


//---------------------------------------------------------------------------
// Set the focus to the given window
// If fAutomin is set the old task will be re-minimising if it was restored
// during the last switch_to.
void CTaskBand::_SwitchToWindow(HWND hwnd)
{
    // use GetLastActivePopup (if it's a visible window) so we don't change
    // what child had focus all the time
    HWND hwndLastActive = GetLastActivePopup(hwnd);

    if ((hwndLastActive) && (IsWindowVisible(hwndLastActive)))
        hwnd = hwndLastActive;

    int iIndex = _FindIndexByHwnd(hwnd);
    if (iIndex != -1)
    {
        PTASKITEM pti = _GetItem(iIndex);
        if (pti)
        {
            pti->dwTimeLastClicked = GetTickCount();
        }
    }

    SwitchToThisWindow(hwnd, TRUE);
}

int CTaskBand::_GetSelectedItems(CDSA<PTASKITEM>* pdsa)
{
    int cSelected = 0;
    for (int i = _tb.GetButtonCount() - 1; i >= 0; i--)
    {
        TBBUTTONINFO tbbi;
        PTASKITEM pti = _GetItem(i, &tbbi);
        if ((tbbi.fsState & TBSTATE_CHECKED) && !(tbbi.fsState & TBSTATE_HIDDEN))
        {
            if (pti->hwnd)
            {
                cSelected++;
                if (pdsa)
                    pdsa->AppendItem(&pti);
            }
            else
            {
                cSelected += _GetGroupItems(i, pdsa);
            }
        }
    }

    return cSelected;
}

void CTaskBand::_OnGroupCommand(int iRet, CDSA<PTASKITEM>* pdsa)
{
    // turn off animations during this
    ANIMATIONINFO ami;
    ami.cbSize = sizeof(ami);
    SystemParametersInfo(SPI_GETANIMATION, sizeof(ami), &ami, FALSE);
    LONG iAnimate = ami.iMinAnimate;
    ami.iMinAnimate = FALSE;
    SystemParametersInfo(SPI_SETANIMATION, sizeof(ami), &ami, FALSE);

    switch (iRet)
    {
    case IDM_CASCADE:
    case IDM_VERTTILE:
    case IDM_HORIZTILE:
        {
            int cbHWND = pdsa->GetItemCount();
            HWND* prgHWND = new HWND[cbHWND];

            if (prgHWND)
            {
                for (int i = 0; i < cbHWND; i++)
                {
                    PTASKITEM pti;
                    pdsa->GetItem(i, &pti);
                    prgHWND[i] = pti->hwnd;

                    if (IsIconic(pti->hwnd))
                    {
                        // this needs to by synchronous with the arrange
                        ShowWindow(prgHWND[i], SW_RESTORE);
                    }

                    BringWindowToTop(pti->hwnd);
                }

                if (iRet == IDM_CASCADE)
                {
                    CascadeWindows(GetDesktopWindow(), MDITILE_ZORDER, NULL, cbHWND, prgHWND);
                }
                else
                {
                    UINT wHow = (iRet == IDM_VERTTILE ? MDITILE_VERTICAL : MDITILE_HORIZONTAL);
                    TileWindows(GetDesktopWindow(), wHow, NULL, cbHWND, prgHWND);
                }
                SetForegroundWindow(prgHWND[cbHWND - 1]);

                delete[] prgHWND;
            }
        }
        break;

    case IDM_CLOSE:
    case IDM_MINIMIZE:
        {
            int idCmd;
            switch (iRet)
            {
            case IDM_MINIMIZE:  idCmd = SC_MINIMIZE;    break;
            case IDM_CLOSE:     idCmd = SC_CLOSE;       break;
            }

            for (int i = pdsa->GetItemCount() - 1; i >= 0; i--)
            {
                PTASKITEM pti;
                pdsa->GetItem(i, &pti);
                PostMessage(pti->hwnd, WM_SYSCOMMAND, idCmd, 0L);
            }

            _SetCurSel(-1, TRUE);
        }
        break;
    }

    // restore animations  state
    ami.iMinAnimate = iAnimate;
    SystemParametersInfo(SPI_SETANIMATION, sizeof(ami), &ami, FALSE);
}

int CTaskBand::_GetGroupItems(int iIndexGroup, CDSA<PTASKITEM>* pdsa)
{
    int iGroupSize = _GetGroupSize(iIndexGroup);

    if (pdsa)
    {
        for (int i = iIndexGroup + 1; i < iIndexGroup + iGroupSize + 1; i++)
        {
            PTASKITEM ptiTemp = _GetItem(i);
            pdsa->AppendItem(&ptiTemp);
        }
    }

    return iGroupSize;
}

void CTaskBand::_SysMenuForItem(int i, int x, int y)
{
    _iSysMenuCount++;
    CDSA<PTASKITEM> dsa;
    dsa.Create(4);
    PTASKITEM pti = _GetItem(i);
    int cSelectedItems = _GetSelectedItems(&dsa);

    if (((cSelectedItems > 1) && _IsButtonChecked(i)) || !pti->hwnd)
    {
        HMENU hmenu = LoadMenuPopup(MAKEINTRESOURCE(MENU_GROUPCONTEXT));

        if (cSelectedItems <= 1)
        {
            dsa.Destroy();
            dsa.Create(4);
            _GetGroupItems(i, &dsa);
        }

        // OFFICESDI: Is this an office app doing its taskbar fakery
        BOOL fMinimize = FALSE;
        BOOL fOfficeApp = FALSE;

        for (int iIndex = (int)(dsa.GetItemCount()) - 1; iIndex >= 0; iIndex--)
        {
            PTASKITEM pti;
            dsa.GetItem(iIndex, &pti);
            if (pti->dwFlags & TIF_EVERACTIVEALT)
            {
                fOfficeApp = TRUE;
            }

            if (_ShouldMinimize(pti->hwnd))
                fMinimize = TRUE;
        }

        // OFFICESDI: If it is an office app disable pretty much everything
        if (fOfficeApp)
        {
            EnableMenuItem(hmenu, IDM_CLOSE, MF_DISABLED | MF_GRAYED | MF_BYCOMMAND);
            EnableMenuItem(hmenu, IDM_CASCADE, MF_DISABLED | MF_GRAYED | MF_BYCOMMAND);
            EnableMenuItem(hmenu, IDM_HORIZTILE, MF_DISABLED | MF_GRAYED | MF_BYCOMMAND);
            EnableMenuItem(hmenu, IDM_VERTTILE, MF_DISABLED | MF_GRAYED | MF_BYCOMMAND);
            EnableMenuItem(hmenu, IDM_MINIMIZE, MF_DISABLED | MF_GRAYED | MF_BYCOMMAND);
        }
        else if (!fMinimize)
        {
            EnableMenuItem(hmenu, IDM_MINIMIZE, MF_DISABLED | MF_GRAYED | MF_BYCOMMAND);
        }

        CToolTipCtrl ttc = _tb.GetToolTips();
        ttc.Activate(FALSE);
        int iRet = TrackPopupMenuEx(hmenu, TPM_RETURNCMD | TPM_RIGHTBUTTON,
                        x, y, _tb, NULL);
        ttc.Activate(TRUE);

        _OnGroupCommand(iRet, &dsa);
    }
    else
    {
        LPARAM lParam = MAKELPARAM(x, y);
        _RestoreWindow(pti->hwnd, pti->dwFlags);
        _SelectWindow(pti->hwnd);
        PostMessage(_hwnd, TBC_POSTEDRCLICK, (WPARAM)pti->hwnd, (LPARAM)lParam);
    }

    dsa.Destroy();
    _iSysMenuCount--;
}

void CALLBACK CTaskBand::FakeSystemMenuCB(HWND hwnd, UINT uMsg, ULONG_PTR dwData, LRESULT lres)
{
    CTaskBand* ptasks = (CTaskBand*)dwData;
    KillTimer(ptasks->_hwnd, IDT_SYSMENU);

    if (uMsg == WM_GETICON)
    {
        SendMessageCallback(hwnd, WM_SYSMENU, 0, ptasks->_dwPos, (SENDASYNCPROC)CTaskBand::FakeSystemMenuCB, (ULONG_PTR)ptasks);
    }
    else
    {
        //
        // Since we fake system menu's sometimes, we can come through here
        // 1 or 2 times per system menu request (once for the real one and
        // once for the fake one).  Only decrement it down to 0. Don't go neg.
        //
        if (ptasks->_iSysMenuCount)      // Decrement it if any outstanding...
            ptasks->_iSysMenuCount--;

        ptasks->_dwPos = 0;          // Indicates that we aren't doing a menu now
        if (ptasks->_iSysMenuCount <= 0)
        {
            CToolTipCtrl ttc = ptasks->_tb.GetToolTips();
            ttc.Activate(TRUE);
        }
    }
}

HWND CTaskBand::_CreateFakeWindow(HWND hwndOwner)
{
    WNDCLASSEX wc;

    if (!GetClassInfoEx(hinstCabinet, TEXT("_ExplorerFakeWindow"), &wc))
    {
        ZeroMemory(&wc, sizeof(wc));
        wc.cbSize = sizeof(wc);
        wc.lpfnWndProc = DefWindowProc;
        wc.hInstance = hinstCabinet;
        wc.lpszClassName = TEXT("_ExplorerFakeWindow");
        RegisterClassEx(&wc);
    }
    return CreateWindow(TEXT("_ExplorerFakeWindow"), NULL, WS_POPUP | WS_SYSMENU, 
            0, 0, 0, 0, hwndOwner, NULL, hinstCabinet, NULL);
}

void CTaskBand::_HandleSysMenuTimeout()
{
    HWND    hwndTask = _hwndSysMenu;
    DWORD   dwPos = _dwPos;
    HWND    hwndFake = NULL;

    KillTimer(_hwnd, IDT_SYSMENU);

    HMENU hPopup = GetSystemMenu(hwndTask, FALSE);

    // This window doesn't have the system menu. Since this window
    // is hung, let's fake one so the user can still close it.
    if (hPopup == NULL) 
    {
        if ((hwndFake = _CreateFakeWindow(_hwnd)) != NULL) 
        {
            hPopup = GetSystemMenu(hwndFake, FALSE);
        }
    }

    if (hPopup)
    {
        // Disable everything on the popup menu _except_ close

        int cItems = GetMenuItemCount(hPopup);
        BOOL fMinimize = _ShouldMinimize(hwndTask);
        for (int iItem  = 0; iItem < cItems; iItem++)
        {
            UINT ID = GetMenuItemID(hPopup, iItem);
            // Leave the minimize item as is. NT allows
            // hung-window minimization.

            if (ID == SC_MINIMIZE && fMinimize) 
            {
                continue;
            }
            if (ID != SC_CLOSE)
            {
                EnableMenuItem(hPopup, iItem, MF_BYPOSITION | MF_GRAYED);
            }

        }

        // workaround for user bug, we must be the foreground window
        SetForegroundWindow(_hwnd);
        ::SetFocus(_hwnd);

        if (SC_CLOSE == TrackPopupMenu(hPopup,
                       TPM_RIGHTBUTTON | TPM_RETURNCMD,
                       GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos),
                       0,
                       _hwnd,
                       NULL))
        {
            EndTask(hwndTask, NULL, NULL);
        }

    }

    // Destroy the fake window
    if (hwndFake != NULL) 
    {
        DestroyWindow(hwndFake);
    }

    // Turn back on tooltips
    FakeSystemMenuCB(hwndTask, WM_SYSMENU, (ULONG_PTR)this, 0);
}

void CTaskBand::_HandleSysMenu(HWND hwnd)
{
    //
    // At this point, USER32 just told us that the app is now about to bring
    // up its own system menu.  We can therefore put away our fake system
    // menu.
    //
    DefWindowProc(_hwnd, WM_CANCELMODE, 0, 0);   // Close menu
    KillTimer(_hwnd, IDT_SYSMENU);
}

void CTaskBand::_FakeSystemMenu(HWND hwndTask, DWORD dwPos)
{
    if (_iSysMenuCount <= 0) 
    {
        CToolTipCtrl ttc = _tb.GetToolTips();
        ttc.Activate(FALSE);
    }

    // HACKHACK: sleep to give time to switch to them.  (user needs this... )
    Sleep(20);

    DWORD dwTimeout = TIMEOUT_SYSMENU;

    //
    // ** Advanced System Menu functionality **
    //
    // If the app doesn't put up its system menu within a reasonable timeout,
    // then we popup a fake menu for it anyway.  Suppport for this is required
    // in USER32 (basically it needs to tell us when to turn off our timeout
    // timer).
    //
    // If the user-double right-clicks on the task bar, they get a really
    // short timeout.  If the app is already hung, then they get a really
    // short timeout.  Otherwise, they get the relatively long timeout.
    //
    if (_dwPos != 0)     // 2nd right-click (on a double-right click)
        dwTimeout = TIMEOUT_SYSMENU_HUNG;

    //
    // We check to see if the app in question is hung, and if so, simulate
    // speed up the timeout process.  It will happen soon enough.
    //
    _hwndSysMenu = hwndTask;
    _dwPos = dwPos;
    _iSysMenuCount++;

    PTASKITEM pti = NULL;
    int iIndex = _FindIndexByHwnd(hwndTask);
    if (iIndex != -1)
    {
        pti = _GetItem(iIndex);
    }
    
    if (IsHungAppWindow(hwndTask) || (pti && pti->fHungApp))
    {
        _HandleSysMenuTimeout();
    }
    else
    {
        SetTimer(_hwnd, IDT_SYSMENU, dwTimeout, NULL);
        if (!SendMessageCallback(hwndTask, WM_GETICON, 0, ICON_SMALL2, (SENDASYNCPROC)FakeSystemMenuCB, (ULONG_PTR)this))
        {
            _HandleSysMenuTimeout();
        }
    }
}


BOOL CTaskBand::_ContextMenu(DWORD dwPos)
{
    int i, x, y;

    if (dwPos != (DWORD)-1)
    {
        x = GET_X_LPARAM(dwPos);
        y = GET_Y_LPARAM(dwPos);
        POINT pt = {x, y};
        _tb.ScreenToClient(&pt);
        i = _tb.HitTest(&pt);
    }
    else
    {
        RECT rc;
        i = _tb.GetHotItem();
        _tb.GetItemRect(i, &rc);
        _tb.ClientToScreen((POINT*)&rc);
        x = rc.left;
        y = rc.top;
    }

    if ((i >= 0) && (i < _tb.GetButtonCount()))
    {
        if (!_IsButtonChecked(i))
        {
            _SetCurSel(i, FALSE);
        }
        _SysMenuForItem(i, x, y);
    }

    return (i >= 0);
}

void CTaskBand::_HandleCommand(WORD wCmd, WORD wID, HWND hwnd)
{
    if (hwnd != _tb)
    {
        switch (wCmd)
        {
        case SC_CLOSE:
            {
                BOOL fForce = (GetKeyState(VK_CONTROL) < 0) ? TRUE : FALSE;
                EndTask(_hwndSysMenu, FALSE , fForce);
            }
            break;

        case SC_MINIMIZE:
            ShowWindow(_hwndSysMenu, SW_FORCEMINIMIZE);
            break;
        }
    }
    else if (wCmd == BN_CLICKED)
    {
        int iIndex = _tb.CommandToIndex(wID);

        if (GetKeyState(VK_CONTROL) < 0)
        {
            _SetCurSel(iIndex, FALSE);
        }
        else 
        {
            PTASKITEM pti = _GetItem(iIndex);
            if (pti->hwnd)
            {
                _OnButtonPressed(iIndex, pti, FALSE);
            }
            else
            {
                if (_iIndexPopup == -1)
                {
                    _SetCurSel(iIndex, FALSE);
                    _HandleDropDown(iIndex);
                }
            }
        }
    }
}

BOOL _IsChineseLanguage()
{
    WORD wLang = GetUserDefaultLangID();
    return (PRIMARYLANGID(wLang) == LANG_CHINESE &&
       ((SUBLANGID(wLang) == SUBLANG_CHINESE_TRADITIONAL) ||
        (SUBLANGID(wLang) == SUBLANG_CHINESE_SIMPLIFIED)));
}

void CTaskBand::_DrawNumber(HDC hdc, int iValue, BOOL fCalcRect, LPRECT prc)
{
    DWORD uiStyle = DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX | DT_CENTER;
    WCHAR szCount[14];
    _itow(iValue, szCount, 10);
    if (fCalcRect)
    {
        StringCchCat(szCount, ARRAYSIZE(szCount), L"0");
    }

    uiStyle |= fCalcRect ? DT_CALCRECT : 0;

    if (_hTheme)
    {
        if (fCalcRect)
        {
            GetThemeTextExtent(_hTheme, hdc, TDP_GROUPCOUNT, 0, szCount, -1, uiStyle, NULL, prc);
        }
        else
        {
            DrawThemeText(_hTheme, hdc, TDP_GROUPCOUNT, 0, szCount, -1, uiStyle, 0, prc);
        }
    }
    else
    {
        HFONT hfont = SelectFont(hdc, _hfontCapBold);
        SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
        SetBkMode(hdc, TRANSPARENT);
        DrawText(hdc, (LPTSTR)szCount, -1, prc, uiStyle);
        SelectFont(hdc, hfont);
    }
}

LRESULT CTaskBand::_HandleCustomDraw(LPNMTBCUSTOMDRAW ptbcd, PTASKITEM pti)
{
    if (!pti)
    {
        pti = (PTASKITEM)ptbcd->nmcd.lItemlParam;
    }

    LRESULT lres = CDRF_DODEFAULT;
    switch (ptbcd->nmcd.dwDrawStage)
    {
    case CDDS_PREPAINT:
        lres = CDRF_NOTIFYITEMDRAW;
        break;
        
    case CDDS_ITEMPREPAINT:
        {
            if (ptbcd->nmcd.uItemState & CDIS_CHECKED)
            {
                // set bold text, unless on chinese language system (where bold text is illegible)
                if (!_IsChineseLanguage())
                {
                    _hfontSave = SelectFont(ptbcd->nmcd.hdc, _hfontCapBold);
                    lres |= CDRF_NOTIFYPOSTPAINT | CDRF_NEWFONT;
                }
            }

            if (pti->dwFlags & TIF_RENDERFLASHED)
            {
                if (_hTheme)
                {
                    DrawThemeBackground(_hTheme, ptbcd->nmcd.hdc, (ptbcd->nmcd.hdr.hwndFrom == _tb) ? TDP_FLASHBUTTON : TDP_FLASHBUTTONGROUPMENU, 0, &(ptbcd->nmcd.rc), 0);
                    lres |= TBCDRF_NOBACKGROUND;
                }
                else
                {
                    // set blue background
                    ptbcd->clrHighlightHotTrack = GetSysColor(COLOR_HIGHLIGHT);
                    ptbcd->clrBtnFace = GetSysColor(COLOR_HIGHLIGHT);
                    ptbcd->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                    if (!(ptbcd->nmcd.uItemState & CDIS_HOT))
                    {
                        ptbcd->nmcd.uItemState |= CDIS_HOT;
                        lres |= TBCDRF_NOEDGES;
                    }
                    lres |= TBCDRF_HILITEHOTTRACK;
                }
            }

            if (pti->dwFlags & TIF_TRANSPARENT)
            {
                lres = CDRF_SKIPDEFAULT;
            }

            if (!pti->hwnd)
            {
                
                lres |= CDRF_NOTIFYPOSTPAINT;

                RECT rc;
                int iIndex = _tb.CommandToIndex((int)ptbcd->nmcd.dwItemSpec);
                _DrawNumber(ptbcd->nmcd.hdc, _GetGroupSize(iIndex), TRUE, &rc);
                ptbcd->iListGap = RECTWIDTH(rc);
            }
        }
        break;

    case CDDS_ITEMPOSTPAINT:
        {
            if (!pti->hwnd)
            {
                int iIndex = _tb.CommandToIndex((int)ptbcd->nmcd.dwItemSpec);

                if (ptbcd->nmcd.rc.right >= ptbcd->rcText.left)
                {
                    RECT rc = ptbcd->rcText;
                    rc.right = rc.left;
                    rc.left -= ptbcd->iListGap;
                    _DrawNumber(ptbcd->nmcd.hdc, _GetGroupSize(iIndex), FALSE, &rc);
                }
            }

            if (ptbcd->nmcd.uItemState & CDIS_CHECKED)
            {
                // restore font
                ASSERT(!_IsChineseLanguage());
                SelectFont(ptbcd->nmcd.hdc, _hfontSave);
            }
        }
        break;
    }
    return lres;
}

void CTaskBand::_RemoveImage(int iImage)
{
    if (iImage >= 0 && HIWORD(iImage) == IL_NORMAL)
    {
        CImageList il = CImageList(_tb.GetImageList());
        if (il)
        {
            BOOL fRedraw = (BOOL)_tb.SendMessage(WM_SETREDRAW, FALSE, 0);

            il.Remove(iImage);

            // Removing image bumps all subsequent indices down by 1.  Iterate
            // through the buttons and patch up their indices as necessary.

            TBBUTTONINFO tbbi;
            tbbi.cbSize = sizeof(tbbi);
            tbbi.dwMask = TBIF_BYINDEX | TBIF_IMAGE;
            for (int i = _tb.GetButtonCount() - 1; i >= 0; i--)
            {
                _tb.GetButtonInfo(i, &tbbi);
                if (tbbi.iImage > iImage && HIWORD(tbbi.iImage) == IL_NORMAL)
                {
                    --tbbi.iImage;
                    _tb.SetButtonInfo(i, &tbbi);
                }
            }

            _tb.SetRedraw(fRedraw);
        }
    }
}

void CTaskBand::_OnButtonPressed(int iIndex, PTASKITEM pti, BOOL fForceRestore)
{
    ASSERT(pti);

    if (iIndex == _iIndexActiveAtLDown)
    {
        if (pti->dwFlags & TIF_EVERACTIVEALT)
        {
            PostMessage(pti->hwnd, WM_SYSCOMMAND, SC_RESTORE, -1);
            _SetCurSel(-1, FALSE);
        }
        else if (IsIconic(pti->hwnd) || fForceRestore)
        {
            if (pti->hwnd == GetForegroundWindow())
            {
                ShowWindowAsync(pti->hwnd, SW_RESTORE);
            }
            else
            {
                _SwitchToItem(iIndex, pti->hwnd, TRUE);
            }
        }
        else if (_ShouldMinimize(pti->hwnd))
        {
            SHAllowSetForegroundWindow(pti->hwnd);
            PostMessage(pti->hwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);
            _SetCurSel(-1, FALSE);

        }
    }
    else
    {
        _SwitchToItem(iIndex, pti->hwnd, TRUE);
    }
}

void CTaskBand::_GetDispInfo(LPNMTBDISPINFO lptbdi)
{
    if (lptbdi->dwMask & TBNF_IMAGE)
    {
        int iIndex = _tb.CommandToIndex(lptbdi->idCommand);
        _UpdateItemIcon(iIndex);

        TBBUTTONINFO tbbi;
        tbbi.cbSize = sizeof(tbbi);
        tbbi.dwMask = TBIF_BYINDEX | TBIF_IMAGE;
        _tb.GetButtonInfo(iIndex, &tbbi);

        lptbdi->iImage = tbbi.iImage;
        lptbdi->dwMask |= TBNF_DI_SETITEM;
    }
}

LRESULT CTaskBand::_HandleNotify(LPNMHDR lpnm)
{
    switch (lpnm->code)
    {
    case NM_LDOWN:
        {
            int iIndex = _tb.CommandToIndex(((LPNMTOOLBAR)lpnm)->iItem);
            PTASKITEM pti = _GetItem(iIndex);
            if (pti && pti->hwnd)
            {
                _iIndexActiveAtLDown = _GetCurSel();
            }
        }
        break;


    case NM_KEYDOWN:
        {
            LPNMKEY pnmk = (LPNMKEY)lpnm;
            switch (pnmk->nVKey)
            {
            case VK_SPACE:
            case VK_RETURN:
                // need to toggle checked state, toolbar doesn't do it for us
                {
                    int iItem = _tb.GetHotItem();
                    if (iItem >= 0)
                    {
                        TBBUTTONINFO tbbi;
                        tbbi.cbSize = sizeof(tbbi);
                        tbbi.dwMask = TBIF_BYINDEX | TBIF_STATE;
                        _tb.GetButtonInfo(iItem, &tbbi);
                        tbbi.fsState ^= TBSTATE_CHECKED;
                        _tb.SetButtonInfo(iItem, &tbbi);

                        PTASKITEM pti = _GetItem(iItem);
                        _OnButtonPressed(iItem, pti, FALSE);
                    }
                }
                return TRUE;
            }
        }
        break;

    case TBN_DELETINGBUTTON:
        break;

    case TBN_HOTITEMCHANGE:
        if (_fDenyHotItemChange)
        {
            return 1;
        }
        else
        {
            LPNMTBHOTITEM pnmhot = (LPNMTBHOTITEM)lpnm;
            if (pnmhot->dwFlags & HICF_ARROWKEYS)
            {
                // If this change came from a mouse then the hot item is already in view
                _ScrollIntoView(_tb.CommandToIndex(pnmhot->idNew));
            }
        }
        break;

    case TBN_DROPDOWN:
        {
            int iIndex = _tb.CommandToIndex(((LPNMTOOLBAR)lpnm)->iItem);
            int iCurIndex = _GetCurSel();
            _iIndexActiveAtLDown = iCurIndex;

            if ((iCurIndex == -1) || (_GetGroupIndex(iCurIndex) != iIndex) || (GetKeyState(VK_CONTROL) < 0))
            {
                _SetCurSel(iIndex, FALSE);
            }

            if (!(GetKeyState(VK_CONTROL) < 0))
            {
                _SetCurSel(iIndex, FALSE);
                _HandleDropDown(iIndex);
            }
        }
        break;

    case TBN_GETDISPINFO:
        {
            LPNMTBDISPINFO lptbdi = (LPNMTBDISPINFO)lpnm;
            _GetDispInfo(lptbdi);
        }
        break;

    case NM_CUSTOMDRAW:
        return _HandleCustomDraw((LPNMTBCUSTOMDRAW)lpnm);

    case TTN_NEEDTEXT:
        {
            int iIndex = _tb.CommandToIndex((int)lpnm->idFrom);
            LPTOOLTIPTEXT pttt = (LPTOOLTIPTEXT)lpnm;

            int cchLen = 0;
            PTASKITEM pti = _GetItem(iIndex);
            if (pti && !pti->hwnd)
            {
                StringCchPrintf(pttt->szText, ARRAYSIZE(pttt->szText), L"(%d) ", _GetGroupSize(iIndex));
                cchLen = lstrlen(pttt->szText);
            }
            _GetItemTitle(iIndex, &(pttt->szText[cchLen]), ARRAYSIZE(pttt->szText) - cchLen, FALSE);
        }
        break;

    case NM_THEMECHANGED:
        {
            _VerifyButtonHeight();
        }
        break;

    }

    return 0;
}

void CTaskBand::_SwitchToItem(int iItem, HWND hwnd, BOOL fIgnoreCtrlKey)
{
    if (_IsWindowNormal(hwnd))
    {
        _RaiseDesktop(FALSE);

        if (_pmpPopup)
            _pmpPopup->OnSelect(MPOS_FULLCANCEL);
        
        _SetCurSel(iItem, fIgnoreCtrlKey);
        if (!(GetKeyState(VK_CONTROL) < 0) || fIgnoreCtrlKey)
        {
            _SwitchToWindow(hwnd);
        }
    }
    else if (!hwnd)
    {
        // I know what you are thinking, why would we ever get a NM_CLICK message for a dropdown button.
        // Ok, sit back and enjoy
        // 1) Click on a group button
        // 2) All window messages are funnelled through the menuband currently being used for the group menu
        // 3) User clicks on another group button
        // 4) The WM_LBUTTONDOWN message is captured and eaten by menuband, then menuband dismisses itself causing a TBC_FREEPOPUPMENU
        // 5) Then the toolbar button for the other group button gets an WM_LBUTTONUP message
        // 6) Guess what, dropdown button notifications are sent during WM_LBUTTONDOWN not UP
        // 7) Thus we don't get an TBN_DROPDOWN we get an NM_CLICK
        // 8) We need to make sure the user didn't click on the same group button as before
        // 9) However, the previous group menu has been dismissed, so I create _iIndexLastPopup which persists after a group menu is dismissed

        if (iItem != _iIndexLastPopup)
        {
            _SetCurSel(iItem, fIgnoreCtrlKey);
            if (!(GetKeyState(VK_CONTROL) < 0) || fIgnoreCtrlKey)
            {
                _HandleDropDown(iItem);
            }
        }
    }
    // NOTE: HWND_TOPMOST is used to indicate that the deleted button 
    // is being animated. This allows the button to stay around after 
    // its real hwnd becomes invalid
    else if (hwnd != HWND_TOPMOST)
    {
        // Window went away?
        _DeleteItem(hwnd);
        _SetCurSel(-1, fIgnoreCtrlKey);
    }
}

BOOL WINAPI CTaskBand::BuildEnumProc(HWND hwnd, LPARAM lParam)
{
    CTaskBand* ptasks = (CTaskBand*)lParam;
    if (IsWindow(hwnd) && IsWindowVisible(hwnd) && !::GetWindow(hwnd, GW_OWNER) &&
        (!(GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_TOOLWINDOW)))
    {
        ptasks->_AddWindow(hwnd);

    }
    return TRUE;
}

//---------------------------------------------------------------------------
// Work around a toolbar bug where it goes wacko if you press both mouse
// buttons.   The reason is that the second mouse button doing down tries
// to reassert capture.  This causes the toolbar to receive WM_CAPTURECHANGED
// with its own hwnd as lParam.  Toolbar doesn't realize that it's being told
// that it is stealing capture from itself and thinks somebody else is
// trying to steal capture, so it posts a message to itself to clean up.
// The posted message arrives, and toolbar cleans up the capture, thinking
// it's cleaning up the old capture that it lost, but in fact it's cleaning
// up the NEW capture it just finished setting!
//
// So filter out WM_CAPTURECHANGED messages that are effectively NOPs.
//

LRESULT CALLBACK s_FilterCaptureSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    UINT_PTR uIdSubclass,
    DWORD_PTR dwRefData)
{
    switch (uMsg)
    {

    case WM_CAPTURECHANGED:
        if (hwnd == (HWND)lParam)
        {
            // Don't let toolbar be fooled into cleaning up capture
            // when it shouldn't.
            return 0;
        }
        break;

    case WM_NCDESTROY:
        RemoveWindowSubclass(hwnd, s_FilterCaptureSubclassProc, uIdSubclass);
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}


//---------------------------------------------------------------------------
LRESULT CTaskBand::_HandleCreate()
{
    ASSERT(_hwnd);

    _uCDHardError = RegisterWindowMessage( TEXT(COPYDATA_HARDERROR) );

    RegisterDragDrop(_hwnd, this);

    _tb.Create(_hwnd, NULL, NULL, WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE | CCS_NODIVIDER |
                            TBSTYLE_LIST | TBSTYLE_TOOLTIPS | TBSTYLE_WRAPABLE | CCS_NORESIZE | TBSTYLE_TRANSPARENT);
    if (_tb)
    {
        SendMessage(_tb, TB_ADDSTRING, (WPARAM)hinstCabinet, (LPARAM)IDS_BOGUSLABELS);

        _OpenTheme();
        SendMessage(_tb, TB_SETWINDOWTHEME, 0, (LPARAM)(_IsHorizontal() ? c_wzTaskBandTheme : c_wzTaskBandThemeVert));
        
        SetWindowSubclass(_tb, s_FilterCaptureSubclassProc, 0, 0);

        _tb.SetButtonStructSize();

        // initial size
        SIZE size = {0, 0};
        _tb.SetButtonSize(size);

        _tb.SetExtendedStyle( TBSTYLE_EX_TRANSPARENTDEADAREA | 
                                TBSTYLE_EX_FIXEDDROPDOWN | 
                                TBSTYLE_EX_DOUBLEBUFFER |
                                TBSTYLE_EX_TOOLTIPSEXCLUDETOOLBAR);

        // version info
        _tb.SendMessage(CCM_SETVERSION, COMCTL32_VERSION, 0);

        _CreateTBImageLists();

        HWND hwndTT = _tb.GetToolTips();
        if (hwndTT)
        {
            SHSetWindowBits(hwndTT, GWL_STYLE, TTS_ALWAYSTIP | TTS_NOPREFIX,
                                               TTS_ALWAYSTIP | TTS_NOPREFIX);
        }

        // set shell hook
        WM_ShellHook = RegisterWindowMessage(TEXT("SHELLHOOK"));
        RegisterShellHook(_hwnd, 3); // 3 = magic flag

        // force getting of font, calc of metrics
        _HandleWinIniChange(0, 0, TRUE);

        // populate the toolbar
        EnumWindows(BuildEnumProc, (LPARAM)this);

        SHChangeNotifyEntry fsne;
        fsne.fRecursive = FALSE;
        fsne.pidl = NULL;
        _uShortcutInvokeNotify = SHChangeNotifyRegister(_hwnd,
                    SHCNRF_NewDelivery | SHCNRF_ShellLevel,
                    SHCNE_ASSOCCHANGED |
                    SHCNE_EXTENDED_EVENT | SHCNE_UPDATEIMAGE,
                    TBC_CHANGENOTIFY,
                    1, &fsne);

        // set window text to give accessibility apps something to read
        TCHAR szTitle[80];
        LoadString(hinstCabinet, IDS_TASKBANDTITLE, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(_hwnd, szTitle);
        SetWindowText(_tb, szTitle);

        return 0;       // success
    }

    // Failure.
    return -1;
}

void CTaskBand::_FreePopupMenu()
{
    _iIndexPopup = -1;

    ATOMICRELEASE(_psmPopup);
    if (_pmpPopup)
    {
        IUnknown_SetSite(_pmpPopup, NULL);
        _pmpPopup->OnSelect(MPOS_FULLCANCEL);
    }
    ATOMICRELEASE(_pmpPopup);
    ATOMICRELEASE(_pmbPopup);

    SendMessage(v_hwndTray, TM_SETPUMPHOOK, NULL, NULL);

    _menuPopup.Detach();
}

HRESULT CTaskBand::_CreatePopupMenu(POINTL* ppt, RECTL* prcl)
{
    HRESULT hr = E_FAIL;

    CToolTipCtrl ttc = _tb.GetToolTips();
    ttc.Activate(FALSE);
    SetActiveWindow(v_hwndTray);

    CTaskBandSMC* ptbc = new CTaskBandSMC(this);
    if (ptbc)
    {
        if (SUCCEEDED(CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellMenu2, &_psmPopup))) &&
            SUCCEEDED(_psmPopup->Initialize(ptbc, 0, 0, SMINIT_CUSTOMDRAW | SMINIT_VERTICAL | SMINIT_TOPLEVEL | SMINIT_USEMESSAGEFILTER)) &&
            SUCCEEDED(CoCreateInstance(CLSID_MenuDeskBar, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMenuPopup, &_pmpPopup))) &&
            SUCCEEDED(_psmPopup->SetMenu(_menuPopup, _hwnd, SMSET_USEPAGER | SMSET_NOPREFIX)) &&
            SUCCEEDED(_psmPopup->QueryInterface(IID_PPV_ARG(IMenuBand, &_pmbPopup))))
        {
            _psmPopup->SetMinWidth(RECTWIDTH(*prcl));

            IBandSite* pbs;
            if (SUCCEEDED(CoCreateInstance(CLSID_MenuBandSite, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBandSite, &pbs))))
            {
                if (SUCCEEDED(_pmpPopup->SetClient(pbs)))
                {
                    IDeskBand* pdb;
                    if (SUCCEEDED(_psmPopup->QueryInterface(IID_PPV_ARG(IDeskBand, &pdb))))
                    {
                        pbs->AddBand(pdb);
                        pdb->Release();

                        SendMessage(v_hwndTray, TM_SETPUMPHOOK, (WPARAM)_pmbPopup, (LPARAM)_pmpPopup);

                        if (_hTheme)
                        {
                            HWND hwndTB;
                            IUnknown_GetWindow(_psmPopup, &hwndTB);
                            if (hwndTB)
                            {
                                SendMessage(hwndTB, TB_SETWINDOWTHEME, 0, (LPARAM)c_wzTaskBandGroupMenuTheme);
                            }
                            _psmPopup->SetNoBorder(TRUE);
                        }

                        hr = _pmpPopup->Popup(ppt, prcl, MPPF_BOTTOM);
                    }
                }
                pbs->Release();
            }
        }
        ptbc->Release();
    }

    if (FAILED(hr))
    {
        ttc.Activate(TRUE);
        _FreePopupMenu();
    }

    return hr;
}

void CTaskBand::_AddItemToDropDown(int iIndex)
{
    PTASKITEM pti = _GetItem(iIndex);

    WCHAR szWndText[MAX_WNDTEXT];
    _GetItemTitle(iIndex, szWndText, ARRAYSIZE(szWndText), TRUE);

    if ((HMENU)_menuPopup)
    {
        _menuPopup.InsertMenu(0, MF_BYCOMMAND, iIndex, szWndText);
    }

    if (_psmPopup)
    {
        _psmPopup->InvalidateItem(NULL, SMINV_REFRESH);
    }
}

void CTaskBand::_RemoveItemFromDropDown(int iIndex)
{
    _menuPopup.DeleteMenu(iIndex, MF_BYCOMMAND);
    int iGroupSize = _GetGroupSize(_iIndexPopup);

    for (int i = iIndex + 1; i <= _iIndexPopup + iGroupSize + 1; i++)
    {
        _RefreshItemFromDropDown(i, i - 1, FALSE);
    }

    if (_psmPopup)
    {
        _psmPopup->InvalidateItem(NULL, SMINV_REFRESH);
    }
}

void CTaskBand::_RefreshItemFromDropDown(int iIndex, int iNewIndex, BOOL fRefresh)
{
    PTASKITEM pti = _GetItem(iNewIndex);
    WCHAR szWndText[MAX_WNDTEXT];
    _GetItemTitle(iNewIndex, szWndText, ARRAYSIZE(szWndText), TRUE);
    _menuPopup.ModifyMenu(iIndex, MF_BYCOMMAND, iNewIndex, szWndText);

    if (fRefresh && _psmPopup)
    {
        if (iIndex == iNewIndex)
        {
            SMDATA smd;
            smd.uId = iIndex;
            _psmPopup->InvalidateItem(&smd, SMINV_REFRESH | SMINV_POSITION);
        }
        else
            _psmPopup->InvalidateItem(NULL, SMINV_REFRESH);
    }
}

void CTaskBand::_ClosePopupMenus()
{
    SendMessage(v_hwndTray, SBM_CANCELMENU, 0, 0);
    _FreePopupMenu();
}

void CTaskBand::_HandleDropDown(int iIndex)
{
    _ClosePopupMenus();

    PTASKITEM pti = _GetItem(iIndex);

    if (pti)
    {
        _iIndexLastPopup = _iIndexPopup = iIndex;
        _menuPopup.CreatePopupMenu();

        for (int i = _GetGroupSize(iIndex) + iIndex; i > iIndex; i--)
        {
            _AddItemToDropDown(i);
        }
        
        RECT rc;
        _tb.GetItemRect(iIndex, &rc);
        MapWindowPoints(_tb, HWND_DESKTOP, (LPPOINT)&rc, 2);

        POINTL pt = {rc.left, rc.top};
        RECTL rcl;
        RECTtoRECTL(&rc, &rcl);

        CToolTipCtrl ttc = _tb.GetToolTips();
        ttc.Activate(FALSE);
        _CreatePopupMenu(&pt, &rcl);
    }
}

LRESULT CTaskBand::_HandleDestroy()
{
    _UnregisterNotify(_uShortcutInvokeNotify);

    RevokeDragDrop(_hwnd);

    RegisterShellHook(_hwnd, FALSE);

    _hwnd = NULL;

    if (_hTheme)
    {
        CloseThemeData(_hTheme);
        _hTheme = NULL;
    }

    if (_tb)
    {
        ASSERT(_tb.IsWindow());

        for (int i = _tb.GetButtonCount() - 1; i >= 0; i--)
        {
            PTASKITEM pti = _GetItem(i);
            if (pti)
            {
                delete pti;
            }
        }
        CImageList il = CImageList(_tb.GetImageList());
        if (il)
        {
            il.Destroy();
        }
    }

    return 1;
}

LRESULT CTaskBand::_HandleScroll(BOOL fHoriz, UINT code, int nPos)
{
    TBMETRICS tbm;
    _GetToolbarMetrics(&tbm);

    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
    GetScrollInfo(_hwnd, fHoriz ? SB_HORZ : SB_VERT, &si);
    si.nMax -= (si.nPage -1);

    switch (code)
    {
        case SB_BOTTOM:     nPos = si.nMax;             break;
        case SB_TOP:        nPos = 0;                   break;
        case SB_ENDSCROLL:  nPos = si.nPos;             break;
        case SB_LINEDOWN:   nPos = si.nPos + 1;         break;
        case SB_LINEUP:     nPos = si.nPos - 1;         break;
        case SB_PAGEDOWN:   nPos = si.nPos + si.nPage;  break;
        case SB_PAGEUP:     nPos = si.nPos - si.nPage;  break;
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:                             break;
    }

    if (nPos > (int)(si.nMax))
        nPos = si.nMax;
    if (nPos < 0 )
        nPos = 0;

    SetScrollPos(_hwnd, fHoriz ? SB_HORZ : SB_VERT, nPos, TRUE);

    DWORD dwSize = _tb.GetButtonSize();
    if (fHoriz)
    {
        int cxRow = LOWORD(dwSize) + tbm.cxButtonSpacing;
        _tb.SetWindowPos(0, -nPos * cxRow, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE |SWP_NOZORDER);
    }
    else
    {
        int cyRow = HIWORD(dwSize) + tbm.cyButtonSpacing;
        _tb.SetWindowPos(0, 0, -nPos * cyRow , 0, 0, SWP_NOACTIVATE | SWP_NOSIZE |SWP_NOZORDER);
    }

    return 0;
}

// after a selection is made, scroll it into view
void CTaskBand::_ScrollIntoView(int iItem)
{
    DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    if (dwStyle & (WS_HSCROLL | WS_VSCROLL))
    {
        int cVisible = 0;
        for (int i = 0; i < iItem; i++)
        {
            if (!_IsHidden(i))
                cVisible++;
        }

        if (_IsHidden(i))
        {
            PTASKITEM pti = _GetItem(iItem);
            if (pti->hwnd)
            {
                cVisible--;
            }
        }

        int iRows, iCols;
        _GetNumberOfRowsCols(&iRows, &iCols, TRUE);
        _HandleScroll((dwStyle & WS_HSCROLL), SB_THUMBPOSITION, (dwStyle & WS_HSCROLL) ? cVisible / iRows : cVisible / iCols);
    }
}


//---------------------------------------------------------------------------
LRESULT CTaskBand::_HandleSize(WPARAM fwSizeType)
{
    // Make the listbox fill the parent;
    if (fwSizeType != SIZE_MINIMIZED)
    {
        _CheckSize();
    }
    return 0;
}

//---------------------------------------------------------------------------
// Have the task list show the given window.
// NB Ignore taskman itself.
LRESULT CTaskBand::_HandleActivate(HWND hwndActive)
{
    //
    // App-window activation change is a good time to do a reality
    // check (make sure there are no ghost buttons, etc).
    //
    _RealityCheck();

    if (hwndActive && _IsWindowNormal(hwndActive))
    {
        _RaiseDesktop(FALSE);

        int i = _SelectWindow(hwndActive);
        if (i != -1)
        {
            PTASKITEM pti = _GetItem(i);

            if (pti)
            {
                // Strip off TIF_FLASHING
                pti->dwFlags &= ~TIF_FLASHING;

                // Update the flag that says, "There is an item flashing."
                _UpdateFlashingFlag();

                // if it's flashed blue, turn it off.
                if (pti->dwFlags & TIF_RENDERFLASHED)
                    _RedrawItem(hwndActive, HSHELL_REDRAW);

                // Switching to an application counts as "usage"
                // similar to launching it.  This solves the "long-running
                // app treated as if it is rarely run" problem
                if (pti->ptsh)
                {
                    pti->ptsh->Tickle();
                }
            }
        }
    }
    else
    {
        // Activate taskbar
        if (!(_fIgnoreTaskbarActivate && GetForegroundWindow() == v_hwndTray) && (_iIndexPopup == -1))
        {
            _SetCurSel(-1, TRUE);
        }
        else
        {
            _fIgnoreTaskbarActivate = FALSE;
        }
    }

    if (hwndActive)
        _ptray->_hwndLastActive = hwndActive;

    return TRUE;
}

//---------------------------------------------------------------------------
void CTaskBand::_HandleOtherWindowDestroyed(HWND hwndDestroyed)
{
    int i;

    // Look for the destoyed window. 
    int iItemIndex = _FindIndexByHwnd(hwndDestroyed);
    if (iItemIndex >= 0)
    {
        if (_fAnimate && _IsHorizontal() && 
            ToolBar_IsVisible(_tb, iItemIndex))
        {
           _AnimateItems(iItemIndex, FALSE, FALSE); 
        }
        else
        {
           _DeleteItem(hwndDestroyed, iItemIndex);
        }
    }
    else
    {
        // If the item doesn't exist in the task list, make sure it isn't part
        // of somebody's fake SDI implementation.  Otherwise Minimize All will
        // break.
        for (i = _tb.GetButtonCount() - 1; i >= 0; i--)
        {
            PTASKITEM pti = _GetItem(i);
            if ((pti->dwFlags & TIF_EVERACTIVEALT) &&
                (HWND) GetWindowLongPtr(pti->hwnd, 0) ==
                       hwndDestroyed)
            {
                goto NoDestroy;
            }
        }
    }

    _ptray->HandleWindowDestroyed(hwndDestroyed);

NoDestroy:
    // This might have been a rude app.  Figure out if we've
    // got one now and have the tray sync up.
    HWND hwndRudeApp = _FindRudeApp(NULL);
    _ptray->HandleFullScreenApp(hwndRudeApp);
    if (hwndRudeApp)
    {
        DWORD dwStyleEx = GetWindowLongPtr(hwndRudeApp, GWL_EXSTYLE);
        if (!(dwStyleEx & WS_EX_TOPMOST) && !_IsRudeWindowActive(hwndRudeApp))
        {
            SwitchToThisWindow(hwndRudeApp, TRUE);
        }
    }

    if (_ptray->_hwndLastActive == hwndDestroyed)
    {
        if (_ptray->_hwndLastActive == hwndDestroyed)
            _ptray->_hwndLastActive = NULL;
    }
}

void CTaskBand::_HandleGetMinRect(HWND hwndShell, POINTS * prc)
{
    RECT rc;
    RECT rcTask;

    int i = _FindIndexByHwnd(hwndShell);
    if (i == -1)
        return;

    // Is this button grouped
    if (_IsHidden(i))
    {
        // Yes, get the index for the group button and use its size
        i = _GetGroupIndex(i);
    }

    // Found it in our list.
    _tb.GetItemRect(i, &rc);

    //
    // If the Tab is mirrored then let's retreive the screen coordinates
    // by calculating from the left edge of the screen since screen coordinates 
    // are not mirrored so that minRect will prserve its location. [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(GetDesktopWindow()))
    {
        RECT rcTab;

        _tb.GetWindowRect(&rcTab);
        rc.left   += rcTab.left;
        rc.right  += rcTab.left;
        rc.top    += rcTab.top;
        rc.bottom += rcTab.top;
    }
    else
    {
        _tb.MapWindowPoints(HWND_DESKTOP, (LPPOINT)&rc, 2);
    }

    prc[0].x = (short)rc.left;
    prc[0].y = (short)rc.top;
    prc[1].x = (short)rc.right;
    prc[1].y = (short)rc.bottom;

    // make sure the rect is within out client area
    GetClientRect(_hwnd, &rcTask);
    MapWindowPoints(_hwnd, HWND_DESKTOP, (LPPOINT)&rcTask, 2);
    if (prc[0].x < rcTask.left)
    {
        prc[1].x = prc[0].x = (short)rcTask.left;
        prc[1].x++;
    }
    if (prc[0].x > rcTask.right)
    {
        prc[1].x = prc[0].x = (short)rcTask.right;
        prc[1].x++;
    }
    if (prc[0].y < rcTask.top)
    {
        prc[1].y = prc[0].y = (short)rcTask.top;
        prc[1].y++;
    }
    if (prc[0].y > rcTask.bottom)
    {
        prc[1].y = prc[0].y = (short)rcTask.bottom;
        prc[1].y++;
    }
}

BOOL CTaskBand::_IsItemActive(HWND hwndItem)
{
    HWND hwnd = GetForegroundWindow();

    return (hwnd && hwnd == hwndItem);
}

void CTaskBand::_CreateTBImageLists()
{
    CImageList il = CImageList(_tb.GetImageList());

    ATOMICRELEASE(_pimlSHIL);
    SHGetImageList(SHIL_SYSSMALL, IID_PPV_ARG(IImageList, &_pimlSHIL));
    
    il.Destroy();
    int cx = GetSystemMetrics(SM_CXSMICON);
    int cy = GetSystemMetrics(SM_CYSMICON);

    il.Create(cx, cy, SHGetImageListFlags(_tb), 4, 4);

    _tb.SendMessage(TB_SETIMAGELIST, IL_NORMAL, (LPARAM)(HIMAGELIST)il);
    _tb.SendMessage(TB_SETIMAGELIST, IL_SHIL, (LPARAM)IImageListToHIMAGELIST(_pimlSHIL));
}

int CTaskBand::_AddIconToNormalImageList(HICON hicon, int iImage)
{
    if (hicon)
    {
        CImageList il = CImageList(_tb.GetImageList());
        if (il)
        {
            int iRet;

            if (iImage < 0 || HIWORD(iImage) != IL_NORMAL)
                iRet = il.ReplaceIcon(-1, hicon);
            else
                iRet = il.ReplaceIcon(iImage, hicon);

            if (iRet == -1)
            {
                TraceMsg(TF_WARNING, "ReplaceIcon failed for iImage %x hicon %x", iImage, hicon);
                iRet = iImage;
            }

            return MAKELONG(iRet, IL_NORMAL);
        }
    }
    return I_IMAGENONE;
}

void CTaskBand::_UpdateItemText(int iItem)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_BYINDEX | TBIF_TEXT;

    // get current button text
    TCHAR szWndText[MAX_WNDTEXT];
    *szWndText = 0;
    _GetItemTitle(iItem, szWndText, ARRAYSIZE(szWndText), FALSE);
    tbbi.pszText = szWndText;

    _tb.SetButtonInfo(iItem, &tbbi);
}

void CTaskBand::_DoRedrawWhereNeeded()
{
    int i;
    for (i = _tb.GetButtonCount() - 1; i >= 0; i--)
    {
        PTASKITEM pti = _GetItem(i);
        if (pti->dwFlags & TIF_NEEDSREDRAW)
        {
            pti->dwFlags &= ~TIF_NEEDSREDRAW;
            _RedrawItem(pti->hwnd, HSHELL_REDRAW, i);
        }
    }
}

void CTaskBand::_RedrawItem(HWND hwndShell, WPARAM code, int i)
{
    if (i == -1)
    {
        i = _FindIndexByHwnd(hwndShell);
    }

    if (i != -1)
    {
        TOOLINFO ti;
        ti.cbSize = sizeof(ti);

        PTASKITEM pti = _GetItem(i);
        // set the bit saying whether we should flash or not
        if ((code == HSHELL_FLASH) != BOOLIFY(pti->dwFlags & TIF_RENDERFLASHED))
        {
            // only do the set if this bit changed.
            if (code == HSHELL_FLASH)
            {
                // TIF_RENDERFLASHED means, "Paint the background blue."
                // TIF_FLASHING means, "This item is flashing."

                pti->dwFlags |= TIF_RENDERFLASHED;

                // Only set TIF_FLASHING and unhide the tray if the app is inactive.
                // Some apps (e.g., freecell) flash themselves while active just for
                // fun.  It's annoying for the autohid tray to pop out in that case.

                if (!_IsItemActive(pti->hwnd))
                {
                    pti->dwFlags |= TIF_FLASHING;

                    // unhide the tray whenever we get a flashing app.
                    _ptray->Unhide();
                }
            }
            else
            {
                // Don't clear TIF_FLASHING.  We clear that only when the app
                // is activated.
                pti->dwFlags &= ~TIF_RENDERFLASHED;
            }

            // Update the flag that says, "There is an item flashing."
            _UpdateFlashingFlag();
        }

        // Don't change the name of a group button
        if (pti->hwnd)
        {
            // update text and icon
            _UpdateItemText(i);
            _UpdateItemIcon(i);
        }
        
        int iGroupIndex = _GetGroupIndex(i);
        if ((iGroupIndex == _iIndexPopup) && hwndShell)
        {
            _RefreshItemFromDropDown(i, i, TRUE);
        }

        RECT rc;
        if (_tb.GetItemRect(i, &rc))
        {
            InvalidateRect(_tb, &rc, TRUE);
        }

        if (_tb.GetItemRect(iGroupIndex, &rc))
        {
            InvalidateRect(_tb, &rc, TRUE);
        }

        ti.hwnd = _tb;
        ti.uId = i;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        SendMessage(_ptray->GetTrayTips(), TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);
    }
}


void CTaskBand::_SetActiveAlt(HWND hwndAlt)
{
    int iMax;
    int i;

    iMax = _tb.GetButtonCount();
    for ( i = 0; i < iMax; i++)
    {
        PTASKITEM pti = _GetItem(i);

        if (pti->hwnd == hwndAlt)
            pti->dwFlags |= TIF_ACTIVATEALT | TIF_EVERACTIVEALT;
        else
            pti->dwFlags &= ~TIF_ACTIVATEALT;
    }
}

BOOL _IsRudeWindowActive(HWND hwnd)
{
    // A rude window is considered "active" if it is:
    // - in the same thread as the foreground window, or
    // - in the same window hierarchy as the foreground window
    //
    HWND hwndFore = GetForegroundWindow();

    DWORD dwID = GetWindowThreadProcessId(hwnd, NULL);
    DWORD dwIDFore = GetWindowThreadProcessId(hwndFore, NULL);

    if (dwID == dwIDFore)
        return TRUE;
    else if (SHIsParentOwnerOrSelf(hwnd, hwndFore) == S_OK)
        return TRUE;

    return FALSE;
}

//   _IsRudeWindow -- is given HWND 'rude' (fullscreen) on given monitor
//
BOOL _IsRudeWindow(HMONITOR hmon, HWND hwnd, HMONITOR hmonTask, BOOL fSkipActiveCheck)
{
    ASSERT(hmon);
    ASSERT(hwnd);

    //
    // Don't count the desktop as rude
    // also filter out hidden windows (such as the desktop browser's raised window)
    //
    if (IsWindowVisible(hwnd) && hwnd != v_hwndDesktop)
    {
        RECT rcMon, rcApp, rcTmp;
        DWORD dwStyle;

        //
        // NB: User32 will sometimes send us spurious HSHELL_RUDEAPPACTIVATED
        // messages.  When this happens, and we happen to have a maximized
        // app up, the old version of this code would think there was a rude app
        // up.  This mistake would break tray always-on-top and autohide.
        //
        //
        // The old logic was:
        //
        // If the app's window rect takes up the whole monitor, then it's rude.
        // (This check could mistake normal maximized apps for rude apps.)
        //
        //
        // The new logic is:
        //
        // If the app window does not have WS_DLGFRAME and WS_THICKFRAME,
        // then do the old check.  Rude apps typically lack one of these bits
        // (while normal apps usually have them), so do the old check in
        // this case to avoid potential compat issues with rude apps that
        // have non-fullscreen client areas.
        //
        // Otherwise, get the client rect rather than the window rect
        // and compare that rect against the monitor rect.
        //

        // If (mon U app) == app, then app is filling up entire monitor
        GetMonitorRect(hmon, &rcMon);

        dwStyle = GetWindowLong(hwnd, GWL_STYLE);
        if ((dwStyle & (WS_CAPTION | WS_THICKFRAME)) == (WS_CAPTION | WS_THICKFRAME))
        {
            // Doesn't match rude app profile; use client rect
            GetClientRect(hwnd, &rcApp);
            MapWindowPoints(hwnd, HWND_DESKTOP, (LPPOINT)&rcApp, 2);
        }
        else
        {
            // Matches rude app profile; use window rect
            GetWindowRect(hwnd, &rcApp);
        }
        UnionRect(&rcTmp, &rcApp, &rcMon);
        if (EqualRect(&rcTmp, &rcApp))
        {
            // Looks like a rude app.  Is it active?
            if ((hmonTask == hmon) && (fSkipActiveCheck || _IsRudeWindowActive(hwnd)))
            {
                return TRUE;
            }
        }
    }

    // No, not rude
    return FALSE;
}

struct iradata
{
    HMONITOR    hmon;   // IN hmon we're checking against
    HWND        hwnd;   // INOUT hwnd of 1st rude app found
    HMONITOR    hmonTask;
    HWND        hwndSelected;
};

BOOL WINAPI CTaskBand::IsRudeEnumProc(HWND hwnd, LPARAM lParam)
{
    struct iradata *pira = (struct iradata *)lParam;
    HMONITOR hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);

    if (hmon && (pira->hmon == NULL || pira->hmon == hmon))
    {
        if (_IsRudeWindow(hmon, hwnd, pira->hmonTask, (hwnd == pira->hwndSelected)))
        {
            // We're done
            pira->hwnd = hwnd;
            return FALSE;
        }
    }

    // Keep going
    return TRUE;
}

HWND CTaskBand::_EnumForRudeWindow(HWND hwndSelected)
{
    struct iradata irad = { NULL, 0, MonitorFromWindow(_hwnd, MONITOR_DEFAULTTONEAREST), hwndSelected };
    // First try our cache
    if (IsWindow(_hwndLastRude))
    {
        if (!IsRudeEnumProc(_hwndLastRude, (LPARAM)&irad))
        {
            // Cache hit
            return irad.hwnd;
        }
    }

    // No luck, gotta do it the hard way
    EnumWindows(IsRudeEnumProc, (LPARAM)&irad);

    // Cache it for next time
    _hwndLastRude = irad.hwnd;

    return irad.hwnd;
}

HWND CTaskBand::_FindRudeApp(HWND hwndPossible)
{
    //
    // Search through:
    //
    // (a) the toplevel windows for an "active" one that "looks" fullscreen, and
    // (b) the task items for one that is "active" and is marked fullscreen
    //

    HWND hwndSelected = hwndPossible;

    if (!hwndSelected)
    {
        int iCurSel = _GetCurSel();
        if (iCurSel != -1)
        {
            PTASKITEM pti = _GetItem(iCurSel);
            hwndSelected = pti->hwnd;
        }
    }

    HWND hwnd = _EnumForRudeWindow(hwndSelected);
    for (int i = _tb.GetButtonCount() - 1; hwnd == NULL && i >= 0; i--)
    {
        PTASKITEM pti = _GetItem(i);
        if (pti->fMarkedFullscreen && ((pti->hwnd == hwndSelected) || _IsRudeWindowActive(pti->hwnd)))
        {
            hwnd = pti->hwnd;
        }
    }

    return hwnd;
}

// handle WM_APPCOMMAND, special case off those that we know are global 
// to the system, these really are not "App" commands ;-)

LRESULT CTaskBand::_OnAppCommand(int cmd)
{
    BOOL bHandled = FALSE;
    switch (cmd)
    {
    // skip all of these, they are either handled by the system volume control
    // or by the media player, don't let these fall through to the registry
    // based app command handling
    case APPCOMMAND_MEDIA_NEXTTRACK:
    case APPCOMMAND_MEDIA_PREVIOUSTRACK:
    case APPCOMMAND_MEDIA_STOP:
    case APPCOMMAND_MEDIA_PLAY_PAUSE:
        break;

    case APPCOMMAND_VOLUME_MUTE:
        Mixer_ToggleMute();
        return 0;
    case APPCOMMAND_VOLUME_DOWN:
        Mixer_SetVolume(-MIXER_DEFAULT_STEP);
        return 0;
    case APPCOMMAND_VOLUME_UP:
        Mixer_SetVolume(MIXER_DEFAULT_STEP);
        return 0;
    case APPCOMMAND_BASS_BOOST:
        Mixer_ToggleBassBoost();
        return 0;
    case APPCOMMAND_BASS_DOWN:
        Mixer_SetBass(-MIXER_DEFAULT_STEP);
        return 0;
    case APPCOMMAND_BASS_UP:
        Mixer_SetBass(MIXER_DEFAULT_STEP);
        return 0;
    case APPCOMMAND_TREBLE_DOWN:
        Mixer_SetTreble(-MIXER_DEFAULT_STEP);
        return 0;
    case APPCOMMAND_TREBLE_UP:
        Mixer_SetTreble(MIXER_DEFAULT_STEP);
        return 0;

    default:
        bHandled = AppCommandTryRegistry(cmd);
        if (!bHandled)
        {
            switch (cmd)
            {
            case APPCOMMAND_BROWSER_SEARCH:
                SHFindFiles(NULL, NULL);
                bHandled = TRUE;
                break;
            }
        }
    }
    return bHandled;
}

PTASKITEM CTaskBand::_FindItemByHwnd(HWND hwnd)
{
    int iIndex = _FindIndexByHwnd(hwnd);
    return _GetItem(iIndex);
}

void CTaskBand::_OnWindowActivated(HWND hwnd, BOOL fSuspectFullscreen)
{
    //
    // First see if we consider this window fullscreen
    //
    HWND hwndRude;

    PTASKITEM pti = _FindItemByHwnd(hwnd);
    if (pti && pti->fMarkedFullscreen)
    {
        //
        // Yes, marked by the app as fullscreen
        //
        hwndRude = hwnd;
    }
    else if (fSuspectFullscreen)
    {
        //
        // Possibly, but we need to double-check for ourselves
        //

        //
        // We shouldn't need to do this but we're getting rude-app activation
        // msgs when there aren't any.
        //
        // Also, the hwnd that user tells us about is just the foreground window --
        // _FindRudeApp will return the window that's actually sized fullscreen.
        //

        hwndRude = _FindRudeApp(hwnd);
    }
    else
    {
        //
        // No, not fullscreen
        //
        hwndRude = NULL;
    }

    SetTimer(_hwnd, IDT_RECHECKRUDEAPP1, 1000, NULL);

    //
    // Okay, now do that weird hwnd futzing for ACTIVEALT apps
    //
    if (pti == NULL)
    {
        BOOL fFoundBackup = FALSE;
        BOOL fDone = FALSE;

        int iMax = _tb.GetButtonCount();
        for (int i = 0; (i < iMax) && (!fDone); i++)
        {
            PTASKITEM ptiT = _GetItem(i);
            if (ptiT->hwnd)
            {
                DWORD dwFlags = ptiT->dwFlags;
                if ((dwFlags & TIF_ACTIVATEALT) ||
                    (!fFoundBackup && (dwFlags & TIF_EVERACTIVEALT)))
                {
                    DWORD dwpid1, dwpid2;

                    GetWindowThreadProcessId(hwnd, &dwpid1);
                    GetWindowThreadProcessId(ptiT->hwnd, &dwpid2);

                    // Only change if they're in the same process
                    if (dwpid1 == dwpid2)
                    {
                        hwnd = ptiT->hwnd;
                        if (dwFlags & TIF_ACTIVATEALT)
                        {
                            fDone = TRUE;
                            break;
                        }
                        else
                            fFoundBackup = TRUE;
                    }
                }
            }
        }
    } 

    //
    // Now do the actual check/uncheck the button stuff
    //
    _HandleActivate(hwnd);

    //
    // Finally, let the tray know about any fullscreen windowage
    //
    _ptray->HandleFullScreenApp(hwndRude);
}

// We get notification about activation etc here. This saves having
// a fine-grained timer.
LRESULT CTaskBand::_HandleShellHook(int iCode, LPARAM lParam)
{
    HWND hwnd = (HWND)lParam;

    switch (iCode)
    {
    case HSHELL_GETMINRECT:
        {
            SHELLHOOKINFO * pshi = (SHELLHOOKINFO *)lParam;
            _HandleGetMinRect(pshi->hwnd, (POINTS *)&pshi->rc);
        }
        return TRUE;

    case HSHELL_RUDEAPPACTIVATED:
    case HSHELL_WINDOWACTIVATED:
        _OnWindowActivated(hwnd, TRUE);
        break;

    case HSHELL_WINDOWREPLACING:
        _hwndReplacing = hwnd;
        break;

    case HSHELL_WINDOWREPLACED:
        if (_hwndReplacing)
        {
            // If we already created a button for this dude, remove it now.
            // We might have one if user sent an HSHELL_WINDOWACTIVATED before
            // the HSHELL_WINDOWREPLACING/HSHELL_WINDOWREPLACED pair.
            _DeleteItem(_hwndReplacing, -1);

            // Swap in _hwndReplacing for hwnd in hwnd's button
            int iItem = _FindIndexByHwnd(hwnd);
            if (iItem != -1)
            {
                PTASKITEM pti = _GetItem(iItem);
                pti->hwnd = _hwndReplacing;

                WCHAR szExeName[MAX_PATH];
                SHExeNameFromHWND(_hwndReplacing, szExeName, ARRAYSIZE(szExeName));
                int iIndexGroup = _GetGroupIndex(iItem);
                PTASKITEM ptiGroup = _GetItem(iIndexGroup);
                pti->fHungApp = (lstrcmpi(ptiGroup->pszExeName, szExeName) != 0);
            }
            _hwndReplacing = NULL;
        }
        break;

    case HSHELL_WINDOWCREATED:
        _AddWindow(hwnd);
        break;

    case HSHELL_WINDOWDESTROYED:
        _HandleOtherWindowDestroyed(hwnd);
        break;

    case HSHELL_ACTIVATESHELLWINDOW:
        SwitchToThisWindow(v_hwndTray, TRUE);
        SetForegroundWindow(v_hwndTray);
        break;

    case HSHELL_TASKMAN:

        // winlogon/user send a -1 lParam to indicate that the 
        // task list should be displayed (normally the lParam is the hwnd)

        if (-1 == lParam)
        {
            RunSystemMonitor();
        }
        else
        {
            // if it wasn't invoked via control escape, then it was the win key
            if (!_ptray->_fStuckRudeApp && GetAsyncKeyState(VK_CONTROL) >= 0)
            {
                HWND hwndForeground = GetForegroundWindow();
                BOOL fIsTrayForeground = hwndForeground == v_hwndTray;
                if (v_hwndStartPane && hwndForeground == v_hwndStartPane)
                {
                    fIsTrayForeground = TRUE;
                }
                if (!_hwndPrevFocus)
                {
                    if (!fIsTrayForeground)
                    {
                        _hwndPrevFocus = hwndForeground;
                    }
                }
                else if (fIsTrayForeground)
                {
                    // _hwndPrevFocus will be wiped out by the MPOS_FULLCANCEL
                    // so save it before we lose it
                    HWND hwndPrevFocus = _hwndPrevFocus;

                    _ClosePopupMenus();

                    // otherwise they're just hitting the key again.
                    // set focus away
                    SHAllowSetForegroundWindow(hwndPrevFocus);
                    SetForegroundWindow(hwndPrevFocus);
                    _hwndPrevFocus = NULL;
                    return TRUE;
                }
            }
            PostMessage(v_hwndTray, TM_ACTASTASKSW, 0, 0L);
        }
        return TRUE;

    case HSHELL_REDRAW:
        {
            int i = _FindIndexByHwnd(hwnd);
            if (i != -1)
            {
                PTASKITEM pti = _GetItem(i);
                pti->dwFlags |= TIF_NEEDSREDRAW;
                SetTimer(_hwnd, IDT_REDRAW, 100, 0);
            }
        }
        break;
    case HSHELL_FLASH:
        _RedrawItem(hwnd, iCode);
        break;

    case HSHELL_ENDTASK:
        EndTask(hwnd, FALSE, FALSE);
        break;

    case HSHELL_APPCOMMAND:
        // shell gets last shot at WM_APPCOMMAND messages via our shell hook 
        // RegisterShellHookWindow() is called in shell32/.RegisterShellHook()
        return _OnAppCommand(GET_APPCOMMAND_LPARAM(lParam));
    }
    return 0;
}

void CTaskBand::_InitFonts()
{
    HFONT hfont;
    NONCLIENTMETRICS ncm;

    ncm.cbSize = sizeof(ncm);
    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
    {
        // Create the bold font
        ncm.lfCaptionFont.lfWeight = FW_BOLD;
        hfont = CreateFontIndirect(&ncm.lfCaptionFont);
        if (hfont) 
        {
            if (_hfontCapBold)
                DeleteFont(_hfontCapBold);

            _hfontCapBold = hfont;
        }

        // Create the normal font
        ncm.lfCaptionFont.lfWeight = FW_NORMAL;
        hfont = CreateFontIndirect(&ncm.lfCaptionFont);
        if (hfont) 
        {
            if (_hfontCapNormal)
                DeleteFont(_hfontCapNormal);

            _hfontCapNormal = hfont;
        }
    }
}

void CTaskBand::_SetItemImage(int iItem, int iImage, int iPref)
{
    TBBUTTONINFO tbbi;

    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_BYINDEX | TBIF_IMAGE;
    tbbi.iImage = iImage;

    _tb.SetButtonInfo(iItem, &tbbi);

    PTASKITEM pti = _GetItem(iItem);
    pti->iIconPref = iPref;
}

void CTaskBand::_UpdateAllIcons()
{
    BOOL fRedraw = (BOOL)_tb.SendMessage(WM_SETREDRAW, FALSE, 0);

    // Set all of icon indices in the toolbar to image none
    for (int i = _tb.GetButtonCount() - 1; i >= 0; i--)
    {
        _SetItemImage(i, I_IMAGENONE, 0);
    }

    // Create a new image list
    _CreateTBImageLists();

    for (i = _tb.GetButtonCount() - 1; i >= 0; i--)
    {
        _UpdateItemIcon(i);
    }

    _tb.SetRedraw(fRedraw);
}

//---------------------------------------------------------------------------
LRESULT CTaskBand::_HandleWinIniChange(WPARAM wParam, LPARAM lParam, BOOL fOnCreate)
{
    _tb.SendMessage(WM_WININICHANGE, wParam, lParam);

    if (wParam == SPI_SETNONCLIENTMETRICS ||
        ((!wParam) && (!lParam || (lstrcmpi((LPTSTR)lParam, TEXT("WindowMetrics")) == 0)))) 
    {
        //
        // On creation, don't bother creating the fonts if someone else
        // (such as the clock control) has already done it for us.
        //
        if (!fOnCreate || !_hfontCapNormal)
            _InitFonts();

        if (_tb)
        {
            _tb.SetFont(_hfontCapNormal);
        }

        // force _TextSpace to be recalculated
        _iTextSpace = 0;

        if (fOnCreate)
        {
            //
            // On creation, we haven't been inserted into bandsite yet,
            // so we need to defer size validation.
            //
            PostMessage(_hwnd, TBC_VERIFYBUTTONHEIGHT, 0, 0);
        }
        else
        {
            _VerifyButtonHeight();
        }
    }

    if (lParam == SPI_SETMENUANIMATION || lParam == SPI_SETUIEFFECTS || (!wParam && 
        (!lParam || (lstrcmpi((LPTSTR)lParam, TEXT("Windows")) == 0) || 
                    (lstrcmpi((LPTSTR)lParam, TEXT("VisualEffects")) == 0))))
    {
        _fAnimate = ShouldTaskbarAnimate();
    }

    if (!wParam && (!lParam || (0 == lstrcmpi((LPCTSTR)lParam, TEXT("TraySettings")))))
    {
        _RefreshSettings();
    }

    return 0;
}

void CTaskBand::_VerifyButtonHeight()
{
    // force toolbar to get new sizes
    SIZE size = {0, 0};
    _tb.SetButtonSize(size);

    _BandInfoChanged();
}

int CTaskBand::_GetCurButtonHeight()
{
    TBMETRICS tbm;
    _GetToolbarMetrics(&tbm);

    int cyButtonHeight = HIWORD(_tb.GetButtonSize());
    if (!cyButtonHeight)
        cyButtonHeight = tbm.cyPad + g_cySize;

    return cyButtonHeight;
}

void CTaskBand::_HandleChangeNotify(WPARAM wParam, LPARAM lParam)
{
    LPITEMIDLIST *ppidl;
    LONG lEvent;
    LPSHChangeNotificationLock pshcnl;

    pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);

    if (pshcnl)
    {
        switch (lEvent)
        {
        case SHCNE_EXTENDED_EVENT:
            {
                LPSHShortcutInvokeAsIDList psidl = (LPSHShortcutInvokeAsIDList)ppidl[0];
                if (psidl && psidl->dwItem1 == SHCNEE_SHORTCUTINVOKE)
                {
                    // Make sure nobody tries to do this in a multithreaded way
                    // since we're not protecting the cache with a critical section
                    ASSERT(GetCurrentThreadId() == GetWindowThreadProcessId(_hwnd, NULL));
                    if (TaskShortcut::_HandleShortcutInvoke(psidl))
                    {
                        _ReattachTaskShortcut();
                    }
                }
            }
            break;

        case SHCNE_UPDATEIMAGE:
            {
                int iImage = ppidl[0] ? *(int UNALIGNED *)((BYTE *)ppidl[0] + 2) : -1;
                if (iImage == -1)
                {
                   _UpdateAllIcons();
                }
            }
            break;

        // The tray doesn't have a changenotify registered so we piggyback
        // off this one.  If associations change, icons may have changed,
        // so we have to go rebuild.  (Also if the user changes between
        // small and large system icons we will get an AssocChanged.)
        case SHCNE_ASSOCCHANGED:
            PostMessage(v_hwndTray, SBM_REBUILDMENU, 0, 0);
            break;
        }

        SHChangeNotification_Unlock(pshcnl);
    }
}

DWORD WINAPI HardErrorBalloonThread(PVOID pv)
{
    HARDERRORDATA *phed = (HARDERRORDATA *)pv;
    DWORD dwError;
    WCHAR *pwszTitle = NULL;
    WCHAR *pwszText = NULL;

    ASSERT(NULL != phed);
    dwError = phed->dwError;

    if (phed->uOffsetTitleW != 0)
    {
        pwszTitle = (WCHAR *)((BYTE *)phed + phed->uOffsetTitleW);
    }
    if (phed->uOffsetTextW != 0)
    {
        pwszText  = (WCHAR *)((BYTE *)phed + phed->uOffsetTextW);
    }

    TCHAR szMutexName[32];
    HANDLE hMutex;
    StringCchPrintf(szMutexName, ARRAYSIZE(szMutexName), TEXT("HardError_%08lX"), dwError);
    hMutex = CreateMutex(NULL, FALSE, szMutexName);

    if (NULL != hMutex)
    {
        DWORD dwWaitResult = WaitForSingleObject(hMutex, 0);         // Just test it
        if (dwWaitResult == WAIT_OBJECT_0)
        {
            IUserNotification *pun;
            HRESULT hr;
            hr = CoCreateInstance(CLSID_UserNotification, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUserNotification, &pun));
            if (SUCCEEDED(hr))
            {
                pun->SetBalloonRetry(120 * 1000, 0, 0);
                pun->SetBalloonInfo(pwszTitle, pwszText, NIIF_WARNING);
                pun->SetIconInfo(NULL, pwszTitle);

                hr = pun->Show(NULL, 0);

                pun->Release();
            }
            ReleaseMutex(hMutex);
        }
        CloseHandle(hMutex);
    }
    LocalFree(pv);
    return 0;
}

LRESULT CTaskBand::_HandleHardError(HARDERRORDATA *phed, DWORD cbData)
{
    DWORD dwError;
    BOOL fHandled;
    BOOL fBalloon;

    dwError = phed->dwError;
    fHandled = FALSE;
    fBalloon = TRUE;

    // Check if we're on the right desktop
    HDESK hdeskInput = OpenInputDesktop(0, FALSE, STANDARD_RIGHTS_REQUIRED | DESKTOP_READOBJECTS);
    if (NULL == hdeskInput)
    {
        // Couldn't open desktop, we must not be getting the hard error while on
        // the default desktop.  Lets not handle that case.  Its silly to have
        // balloons on the wrong desktop, or not where the user can see them.
        fBalloon = FALSE;
    }
    else
    {
        CloseDesktop(hdeskInput);
    }

    if (fBalloon)
    {
        HARDERRORDATA *phedCopy;

        phedCopy = (HARDERRORDATA *)LocalAlloc(LPTR, cbData);
        if (NULL != phedCopy)
        {
            CopyMemory(phedCopy,phed,cbData);
            if (SHCreateThread(HardErrorBalloonThread,phedCopy,CTF_COINIT,NULL))
            {
                fHandled = TRUE;
            }
            else
            {
                LocalFree(phedCopy);
            }
        }
    }

    return fHandled;
}

void CTaskBand::_OnSetFocus()
{
    NMHDR nmhdr;

    _tb.SetFocus();

    nmhdr.hwndFrom = _hwnd;
    nmhdr.code = NM_SETFOCUS;
    SendMessage(GetParent(_hwnd), WM_NOTIFY, (WPARAM)NULL, (LPARAM)&nmhdr);
}

void CTaskBand::_OpenTheme()
{
    if (_hTheme)
    {
        CloseThemeData(_hTheme);
        _hTheme = NULL;
    }

    _hTheme = OpenThemeData(_hwnd, c_wzTaskBandTheme);

    TBMETRICS tbm;
    _GetToolbarMetrics(&tbm);
    tbm.cxPad = _hTheme ? 20 : 8;
    tbm.cyBarPad = 0;
    tbm.cxButtonSpacing = _hTheme ? 0 : 3;
    tbm.cyButtonSpacing = _hTheme ? 0 : 3;
    _tb.SendMessage(TB_SETMETRICS, 0, (LPARAM)&tbm);

    _CheckSize();
}

LRESULT CTaskBand::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;

    INSTRUMENT_WNDPROC(SHCNFI_MAIN_WNDPROC, hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_CREATE:
        return _HandleCreate();

    case WM_DESTROY:
        return _HandleDestroy();

    case WM_WINDOWPOSCHANGED:
        {
            LRESULT lres = _HandleSize(wParam);
            SetTimer(_hwnd, IDT_RECHECKRUDEAPP1, 1000, NULL);
            return lres;
        }

    case WM_PAINT:
    case WM_PRINTCLIENT:
        {
            PAINTSTRUCT ps;
            LPRECT prc = NULL;
            HDC hdc = (HDC)wParam;

            if (uMsg == WM_PAINT)
            {
                BeginPaint(hwnd, &ps);
                prc = &ps.rcPaint;
                hdc = ps.hdc;
            }

            if (_hTheme)
            {
                DrawThemeParentBackground(hwnd, hdc, prc);
            }
            else
            {
                RECT rc;
                GetClientRect(hwnd, &rc);
                FillRect(hdc, &rc, (HBRUSH)(COLOR_3DFACE + 1));
            }

            if (uMsg == WM_PAINT)
            {
                EndPaint(hwnd, &ps);
            }
        }
        break;

    case WM_ERASEBKGND:
        {
            if (_hTheme)
            {
                return 1;
            }
            else
            {
                RECT rc;
                GetClientRect(hwnd, &rc);
                FillRect((HDC)wParam, &rc, (HBRUSH)(COLOR_3DFACE + 1));
            }
        }

    // this keeps our window from comming to the front on button down
    // instead, we activate the window on the up click
    // we only want this for the tree and the view window
    // (the view window does this itself)
    case WM_MOUSEACTIVATE:
        {
            POINT pt;
            RECT rc;

            GetCursorPos(&pt);
            GetWindowRect(_hwnd, &rc);

            if ((LOWORD(lParam) == HTCLIENT) && PtInRect(&rc, pt))
                return MA_NOACTIVATE;
            else
                goto DoDefault;
        }

    case WM_SETFOCUS: 
        _OnSetFocus();
        break;

    case WM_VSCROLL:
        return _HandleScroll(FALSE, LOWORD(wParam), HIWORD(wParam));

    case WM_HSCROLL:
        return _HandleScroll(TRUE, LOWORD(wParam), HIWORD(wParam));

    case WM_NOTIFY:
        return _HandleNotify((LPNMHDR)lParam);

    case WM_NCHITTEST:
        lres = DefWindowProc(hwnd, uMsg, wParam, lParam);
        if (lres == HTVSCROLL || lres == HTHSCROLL)
            return lres;
        else
            return HTTRANSPARENT;

    case WM_TIMER:
        switch (wParam)
        {
        case IDT_RECHECKRUDEAPP1:
        case IDT_RECHECKRUDEAPP2:
        case IDT_RECHECKRUDEAPP3:
        case IDT_RECHECKRUDEAPP4:
        case IDT_RECHECKRUDEAPP5:
            {
                HWND hwnd = _FindRudeApp(NULL);
                _ptray->HandleFullScreenApp(hwnd);
                if (hwnd)
                {
                    DWORD dwStyleEx = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
                    if (!(dwStyleEx & WS_EX_TOPMOST) && !_IsRudeWindowActive(hwnd))
                    {
                        SwitchToThisWindow(hwnd, TRUE);
                    }
                }

                KillTimer(_hwnd, wParam);
                if (!hwnd && (wParam < IDT_RECHECKRUDEAPP5))
                {
                    SetTimer(_hwnd, wParam + 1, 1000, NULL);
                }
            }
            break;
        case IDT_ASYNCANIMATION:
            _AsyncAnimateItems();
            break;
        case IDT_REDRAW:
            _DoRedrawWhereNeeded();
            KillTimer(hwnd, IDT_REDRAW);
            break;
        case IDT_SYSMENU:
            KillTimer(_hwnd, IDT_SYSMENU);
            _HandleSysMenuTimeout();
            break;
        }
        break;

    case WM_COMMAND:
        _HandleCommand(GET_WM_COMMAND_CMD(wParam, lParam), GET_WM_COMMAND_ID(wParam, lParam), GET_WM_COMMAND_HWND(wParam, lParam));
        break;

    case WM_THEMECHANGED:
        _OpenTheme();
        break;

    case TBC_POSTEDRCLICK:
        _FakeSystemMenu((HWND)wParam, (DWORD)lParam);
        break;

    case TBC_BUTTONHEIGHT:
        return _GetCurButtonHeight();

    case WM_CONTEXTMENU:
        if (SHRestricted(REST_NOTRAYCONTEXTMENU))
        {
            break;
        }

        // if we didn't find an item to put the sys menu up for, then
        // pass on the WM_CONTExTMENU message
        if (!_ContextMenu((DWORD)lParam))
            goto DoDefault;
        break;

    case TBC_SYSMENUCOUNT:
        return _iSysMenuCount;

    case TBC_CHANGENOTIFY:
        _HandleChangeNotify(wParam, lParam);
        break;

    case TBC_VERIFYBUTTONHEIGHT:
        _VerifyButtonHeight();
        break;
        
    case TBC_SETACTIVEALT:
        _SetActiveAlt((HWND) lParam);
        break;

    case TBC_CANMINIMIZEALL:
        return _CanMinimizeAll();

    case TBC_MINIMIZEALL:
        return _MinimizeAll((HWND) wParam, (BOOL) lParam);
        break;

    case TBC_WARNNODROP:
        //
        // tell the user they can't drop objects on the taskbar
        //
        ShellMessageBox(hinstCabinet, _hwnd,
            MAKEINTRESOURCE(IDS_TASKDROP_ERROR), MAKEINTRESOURCE(IDS_TASKBAR),
            MB_ICONHAND | MB_OK);
        break;

    case TBC_SETPREVFOCUS:
        _hwndPrevFocus = (HWND)lParam;
        break;

    case TBC_FREEPOPUPMENUS:
        DAD_ShowDragImage(FALSE);
        _FreePopupMenu();
        _SetCurSel(-1, TRUE);
        DAD_ShowDragImage(TRUE);
        break;

    case TBC_MARKFULLSCREEN:
        {
            HWND hwndFS = (HWND)lParam;
            if (IsWindow(hwndFS))
            {
                //
                // look for the item they're talking about
                //
                PTASKITEM pti = _FindItemByHwnd(hwndFS);
                if (pti == NULL)
                {
                    //
                    // we didn't find it, so insert it now
                    //
                    pti = _GetItem(_InsertItem(hwndFS));
                }
                if (pti)
                {
                    //
                    // mark it fullscreen/not fullscreen
                    //
                    pti->fMarkedFullscreen = BOOLIFY(wParam);
                    if (_IsRudeWindowActive(hwndFS))
                    {
                        //
                        // it's active, so tell the tray to hide/show
                        //
                        HWND hwndRude = pti->fMarkedFullscreen ? hwndFS : NULL;
                        _ptray->HandleFullScreenApp(hwndRude);
                    }
                }
            }
        }
        break;

    case TBC_TASKTAB:
        {
            _tb.SetFocus();

            int iNewIndex = 0;
            int iCurIndex = max(_tb.GetHotItem(), 0);
            int iCount = _tb.GetButtonCount();
            if (iCount >= 2)
            {
                iNewIndex = iCurIndex;
                
                do
                {
                    iNewIndex += (int)wParam;
                    if (iNewIndex >= iCount)
                    {
                        iNewIndex = 0;
                    }
                    if (iNewIndex < 0)
                    {
                        iNewIndex = iCount - 1;
                    }
                } while (_IsHidden(iNewIndex));
            }

            _tb.SetHotItem(iNewIndex);
        }
        break;

    case WM_COPYDATA:
        {
            COPYDATASTRUCT *pcd;

            pcd = (PCOPYDATASTRUCT)lParam;
            if (pcd && pcd->dwData == _uCDHardError)
            {
                HARDERRORDATA *phed = (HARDERRORDATA *)pcd->lpData;;
                if (phed)
                {
                    return _HandleHardError(phed, pcd->cbData);
                }
                return 0;       // 0 = not handled
            }
        }
        //
        // If its not our hard error data, then just
        // fall through to default processing
        //

    default:
DoDefault:

        if (uMsg == WM_ShellHook)
            return _HandleShellHook((int)wParam, lParam);
        else
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

BOOL CTaskBand::_RegisterWindowClass()
{
    WNDCLASSEX wc = {0};
    wc.cbSize = sizeof(wc);

    if (GetClassInfoEx(hinstCabinet, c_szTaskSwClass, &wc))
        return TRUE;

    wc.lpszClassName    = c_szTaskSwClass;
    wc.lpfnWndProc      = s_WndProc;
    wc.cbWndExtra       = sizeof(LONG_PTR);
    wc.hInstance        = hinstCabinet;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE + 1);

    return RegisterClassEx(&wc);
}

int TimeSortCB(PTASKITEM p1, PTASKITEM p2, LPARAM lParam)
{
    if (p1->dwTimeFirstOpened > p2->dwTimeFirstOpened)
        return -1;
    else
        return 1;
}

int DestroyCB(PTASKITEM pti, LPVOID pData)
{
    if (pti)
        delete pti;

    return 0;
}

void CTaskBand::_RefreshSettings()
{
    BOOL fOldGlom = _fGlom;
    int iOldGroupSize = _iGroupSize;
    _LoadSettings();

    if ((fOldGlom != _fGlom) || (iOldGroupSize != _iGroupSize))
    {
        CDPA<TASKITEM> dpa;
        _BuildTaskList(&dpa);

        if (dpa)
        {
            int i;

            dpa.Sort(TimeSortCB, 0);
            
            BOOL fRedraw = (BOOL)_tb.SendMessage(WM_SETREDRAW, FALSE, 0);
            BOOL fAnimate = _fAnimate;
            _fAnimate = FALSE;

            for (i = _tb.GetButtonCount() - 1; i >= 0; i--)
            {
                _DeleteTaskItem(i, TRUE);
            }

            for (i = dpa.GetPtrCount() - 1; i >= 0 ; i--)
            {
                PTASKITEM pti = dpa.FastGetPtr(i);
                // NOTE: HWND_TOPMOST is used to indicate that the deleted button 
                // is being animated. This allows the button to stay around after 
                // its real hwnd becomes invalid.
                // Don't re-insert a button that was deleting.
                if (pti->hwnd != HWND_TOPMOST)
                {
                    _InsertItem(pti->hwnd, pti, TRUE);
                }
            }
            dpa.Destroy();

            _tb.SendMessage(WM_SETREDRAW, fRedraw, 0);
            _fAnimate = fAnimate;
        }

        _BandInfoChanged();
    }
}

void CTaskBand::_LoadSettings()
{
    if (SHRestricted(REST_NOTASKGROUPING) == 0)
    {
        _fGlom = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("TaskbarGlomming"),
                    FALSE, TRUE);
        if (_fGlom)
        {
            DWORD cbSize = sizeof(_fGlom);
            DWORD dwDefault = GLOM_OLDEST;
            SHRegGetUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("TaskbarGroupSize"),
                NULL, &_iGroupSize, &cbSize, FALSE, (LPBYTE)&dwDefault, sizeof(dwDefault));
            
        }
    }
    else
    {
        _fGlom = FALSE;
    }
}


BOOL CTaskBand::_ShouldMinimize(HWND hwnd)
{
    BOOL fRet = FALSE;

    DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
    if (IsWindowVisible(hwnd) &&
        !IsMinimized(hwnd) && IsWindowEnabled(hwnd))
    {
        if (dwStyle & WS_MINIMIZEBOX)
        {
            if ((dwStyle & (WS_CAPTION | WS_SYSMENU)) == (WS_CAPTION | WS_SYSMENU))
            {
                HMENU hmenu = GetSystemMenu(hwnd, FALSE);
                if (hmenu)
                {
                    // is there a sys menu and is the sc_min/maximize part enabled?
                    fRet = !(GetMenuState(hmenu, SC_MINIMIZE, MF_BYCOMMAND) & MF_DISABLED);
                }
            }
            else
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

BOOL CTaskBand::_CanMinimizeAll()
{
    int i;

    for ( i = _tb.GetButtonCount() - 1; i >= 0; i--)
    {
        PTASKITEM pti = _GetItem(i);
        if (_ShouldMinimize(pti->hwnd) || (pti->dwFlags & TIF_EVERACTIVEALT))
            return TRUE;
    }

    return FALSE;
}

typedef struct MINALLDATAtag
{
    CDPA<TASKITEM> dpa;
    CTray* pTray;
    HWND hwndDesktop;
    HWND hwndTray;
    BOOL fPostRaiseDesktop;
} MINALLDATA;

DWORD WINAPI CTaskBand::MinimizeAllThreadProc(void* pv)
{
    LONG iAnimate;
    ANIMATIONINFO ami;
    MINALLDATA* pminData = (MINALLDATA*)pv;

    if (pminData)
    {
        // turn off animiations during this
        ami.cbSize = sizeof(ami);
        SystemParametersInfo(SPI_GETANIMATION, sizeof(ami), &ami, FALSE);
        iAnimate = ami.iMinAnimate;
        ami.iMinAnimate = FALSE;
        SystemParametersInfo(SPI_SETANIMATION, sizeof(ami), &ami, FALSE);

        //
        //EnumWindows(MinimizeEnumProc, 0);
        // go through the tab control and minimize them.
        // don't do enumwindows because we only want to minimize windows
        // that are restorable via the tray

        for (int i = pminData->dpa.GetPtrCount() - 1; i >= 0 ; i--)
        {
            PTASKITEM pti = pminData->dpa.FastGetPtr(i);
            if (pti)
            {
                // we do the whole minimize on its own thread, so we don't do the showwindow
                // async.  this allows animation to be off for the full minimize.
                if (_ShouldMinimize(pti->hwnd))
                {
                    ShowWindow(pti->hwnd, SW_SHOWMINNOACTIVE);
                }
                else if (pti->dwFlags & TIF_EVERACTIVEALT)
                {
                    SHAllowSetForegroundWindow(pti->hwnd);
                    SendMessage(pti->hwnd, WM_SYSCOMMAND, SC_MINIMIZE, -1);
                }
            }
        }

        pminData->pTray->CheckWindowPositions();
        pminData->dpa.DestroyCallback(DestroyCB, NULL);

        if (pminData->fPostRaiseDesktop)
        {
            PostMessage(pminData->hwndDesktop, DTM_RAISE, (WPARAM)pminData->hwndTray, DTRF_RAISE);
        }

        delete pminData;

        // restore animations  state
        ami.iMinAnimate = iAnimate;
        SystemParametersInfo(SPI_SETANIMATION, sizeof(ami), &ami, FALSE);
    }
    return 0;
}

void CTaskBand::_BuildTaskList(CDPA<TASKITEM>* pdpa )
{
    if (pdpa && _tb)
    {
        if (pdpa->Create(5))
        {
            for (int i = _tb.GetButtonCount() - 1; (i >= 0) && ((HDPA)pdpa); i--)
            {
                PTASKITEM pti = _GetItem(i);
                if (pti->hwnd)
                {
                    PTASKITEM ptiNew = new TASKITEM(pti);
                    if (ptiNew)
                    {
                        pdpa->AppendPtr(ptiNew);
                    }
                    else
                    {
                        pdpa->DestroyCallback(DestroyCB, NULL);
                    }
                }
            }
        }
        else
        {
            pdpa->Destroy();
        }
    }
}

BOOL CTaskBand::_MinimizeAll(HWND hwndTray, BOOL fPostRaiseDesktop)
{
    BOOL fFreeMem = TRUE;
    // might want to move this into MinimizeAllThreadProc (to match
    // _ptray->CheckWindowPositions).  but what if CreateThread fails?

    _ptray->SaveWindowPositions(IDS_MINIMIZEALL);

    MINALLDATA* pminData = new MINALLDATA;
    if (pminData)
    {
        _BuildTaskList(&(pminData->dpa));
        if (pminData->dpa)
        {
            pminData->pTray = _ptray;
            pminData->fPostRaiseDesktop = fPostRaiseDesktop;
            pminData->hwndDesktop = v_hwndDesktop;
            pminData->hwndTray = hwndTray;
            // MinimizeAllThreadProc is responsible for freeing this data
            fFreeMem = !SHCreateThread(MinimizeAllThreadProc, (void*)pminData, CTF_INSIST, NULL);
        }
    }

    if (fFreeMem)
    {
        if (pminData)
        {
            pminData->dpa.DestroyCallback(DestroyCB, NULL);
            delete pminData;
        }
    }

    return !fFreeMem;
}

int CTaskBand::_HitTest(POINTL ptl)
{
    POINT pt = {ptl.x,ptl.y};
    _tb.ScreenToClient(&pt);

    int iIndex = _tb.HitTest(&pt);

    if ((iIndex >= _tb.GetButtonCount()) || (iIndex < 0))
        iIndex = -1;

    return iIndex;
}

HRESULT CTaskBand_CreateInstance(IUnknown* punkOuter, IUnknown** ppunk)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    CTaskBand* ptb = new CTaskBand();
    if (ptb)
    {
        hr = ptb->Init(&c_tray);
        if (SUCCEEDED(hr))
        {
            *ppunk = static_cast<IDeskBand*>(ptb);
            hr = S_OK;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\taskbar.h ===
#include "taskband.h"
#include "tray.h"

#ifdef __cplusplus

class CSimpleOleWindow : public IDeskBar // public IOleWindow, 
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IDeskBar ***
    STDMETHOD(OnPosRectChangeDB)(THIS_ LPRECT prc)
        { ASSERT(0); return E_NOTIMPL; }
    STDMETHOD(SetClient)          (THIS_ IUnknown* punkClient)
        { return E_NOTIMPL; }
    STDMETHOD(GetClient)          (THIS_ IUnknown** ppunkClient)
        { return E_NOTIMPL; }

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    CSimpleOleWindow(HWND hwnd);
    
protected:
    
    virtual ~CSimpleOleWindow();
    
    UINT _cRef;
    HWND _hwnd;
};


class CTaskBar : public CSimpleOleWindow 
               , public IContextMenu
               , public IServiceProvider
               , public IRestrict
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CSimpleOleWindow::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void){ return CSimpleOleWindow::Release();};

    // *** IContextMenu methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax);
    
    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObj);

    // *** IRestrict ***
    virtual STDMETHODIMP IsRestricted(const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, DWORD * pdwRestrictionResult);
    
    // *** CSimpleOleWindow - IDeskBar ***
    STDMETHOD(OnPosRectChangeDB)(LPRECT prc);

    CTaskBar();
    HWND _hwndRebar;

protected:
    //virtual ~CTaskBar();

    BOOL _fRestrictionsInited;          // Have we read in the restrictions?
    BOOL _fRestrictDDClose;             // Restrict: Add, Close, Drag & Drop
    BOOL _fRestrictMove;                // Restrict: Move
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\tray.h ===
#ifndef _TRAY_H
#define _TRAY_H

#include "trayp.h"
#include "cwndproc.h"

#ifdef __cplusplus

#include "traynot.h"
#include "ssomgr.h"

typedef struct tagHWNDANDPLACEMENT
{
    HWND hwnd;
    BOOL fRestore;
    WINDOWPLACEMENT wp;
}
HWNDANDPLACEMENT, *LPHWNDANDPLACEMENT;


typedef struct tagAPPBAR
{
    HWND hwnd;
    UINT uCallbackMessage;
    RECT rc;
    UINT uEdge;
}
APPBAR, *PAPPBAR;


typedef struct tagWINDOWPOSITIONS
{
    UINT idRes;
    HDSA hdsaWP;
}
WINDOWPOSITIONS, *LPWINDOWPOSITIONS;

typedef struct tagTRAYVIEWOPTS
{
    BOOL fAlwaysOnTop;
    BOOL fSMSmallIcons;
    BOOL fHideClock;
    BOOL fNoTrayItemsDisplayPolicyEnabled;
    BOOL fNoAutoTrayPolicyEnabled;
    BOOL fAutoTrayEnabledByUser;
    BOOL fShowQuickLaunch;
    UINT uAutoHide;     // AH_HIDING , AH_ON
}
TRAYVIEWOPTS;

// TVSD Flags.
#define TVSD_NULL               0x0000
#define TVSD_AUTOHIDE           0x0001
#define TVSD_TOPMOST            0x0002
#define TVSD_SMSMALLICONS       0x0004
#define TVSD_HIDECLOCK          0x0008

// old Win95 TVSD struct
typedef struct _TVSD95
{
    DWORD   dwSize;
    LONG    cxScreen;
    LONG    cyScreen;
    LONG    dxLeft;
    LONG    dxRight;
    LONG    dyTop;
    LONG    dyBottom;
    DWORD   uAutoHide;
    RECTL   rcAutoHide;
    DWORD   uStuckPlace;
    DWORD   dwFlags;
} TVSD95;

// Nashville tray save data
typedef struct _TVSD
{
    DWORD   dwSize;
    LONG    lSignature;     // signature (must be negative)

    DWORD   dwFlags;        // TVSD_ flags

    DWORD   uStuckPlace;    // current stuck edge
    SIZE    sStuckWidths;   // widths of stuck rects
    RECT    rcLastStuck;    // last stuck position in pixels

} TVSD;

// convenient union for reading either
typedef union _TVSDCOMPAT
{
    TVSD t;         // new format
    TVSD95 w95;     // old format

} TVSDCOMPAT;
#define TVSDSIG_CURRENT     (-1L)
#define IS_CURRENT_TVSD(t)  ((t.dwSize >= sizeof(TVSD)) && (t.lSignature < 0))
#define MAYBE_WIN95_TVSD(t) (t.dwSize == sizeof(TVSD95))
DWORD _GetDefaultTVSDFlags();


class CTray;

class CDropTargetBase : public IDropTarget
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    // *** IDropTarget methods ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);

    CDropTargetBase(CTray* ptray) : _ptray(ptray) {}

protected:

    CTray* _ptray;
};

class CTrayDropTarget : public CDropTargetBase
{
public:
    // *** IDropTarget methods ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    CTrayDropTarget();
};

class CStartDropTarget : public CDropTargetBase
{
public:
    // *** IDropTarget methods ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    CStartDropTarget();

protected:
    HRESULT _GetStartMenuDropTarget(IDropTarget** pptgt);
    void _StartAutoOpenTimer(POINTL *pptl);

    DWORD _dwEffectsAllowed;
};

class CDeskTray : public IDeskTray
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG)AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IDeskTray methods ***
    STDMETHODIMP_(UINT) AppBarGetState();
    STDMETHODIMP GetTrayWindow(HWND* phwndTray);
    STDMETHODIMP SetDesktopWindow(HWND hwndDesktop);
    STDMETHODIMP SetVar(int var, DWORD value);

protected:
    CDeskTray();    // noone but tray should instantiate
    CTray* _ptray;
    friend class CTray;
};

EXTERN_C void Tray_OnStartMenuDismissed();
EXTERN_C void Tray_SetStartPaneActive(BOOL fActive);


#define TPF_TASKBARPAGE     0x00000001
#define TPF_STARTMENUPAGE   0x00000002
#define TPF_INVOKECUSTOMIZE 0x00000004   // start with the "Customize..." sub-dialog open

EXTERN_C void Tray_DoProperties(DWORD dwFlags);

#define AH_OFF          0x00
#define AH_ON           0x01
#define AH_HIDING       0x02

class CTray : public CImpWndProc
{
public:

    //
    // miscellaneous public methods
    //
    CTray();
    void HandleWindowDestroyed(HWND hwnd);
    void HandleFullScreenApp(HWND hwnd);
    void RealityCheck();
    DWORD getStuckPlace() { return _uStuckPlace; }
    void InvisibleUnhide(BOOL fShowWindow);
    void ContextMenuInvoke(int idCmd);
    HMENU BuildContextMenu(BOOL fIncludeTime);
    void AsyncSaveSettings();
    BOOL Init();
    void Unhide();
    void VerifySize(BOOL fWinIni, BOOL fRoundUp = FALSE);
    void SizeWindows();
    int HotkeyAdd(WORD wHotkey, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem, BOOL fClone);
    void CheckWindowPositions();
    void SaveWindowPositions(UINT idRes);
    void ForceStartButtonUp();
    void DoProperties(DWORD dwFlags);
    void LogFailedStartupApp();
    HWND GetTaskWindow() { return _hwndTasks; }
    HWND GetTrayTips() { return _hwndTrayTips; }
    IDeskTray* GetDeskTray() { return &_desktray; }
    IMenuPopup* GetStartMenu() { return _pmpStartMenu; };
    void StartMenuContextMenu(HWND hwnd, DWORD dwPos);
    BOOL IsTaskbarFading() { return _fTaskbarFading; };

    DWORD CountOfRunningPrograms();
    void ClosePopupMenus();
    HWND GetTrayNotifyHWND()
    {
        return _hwndNotify;
    }

    void CreateStartButtonBalloon(UINT idsTitle, UINT idsMessage);

    void GetTrayViewOpts(TRAYVIEWOPTS* ptvo)
    {
        ptvo->fAlwaysOnTop        = _fAlwaysOnTop;
        ptvo->fSMSmallIcons       = _fSMSmallIcons;
        ptvo->fHideClock          = _fHideClock;
        ptvo->fNoTrayItemsDisplayPolicyEnabled = _trayNotify.GetIsNoTrayItemsDisplayPolicyEnabled();
        ptvo->fNoAutoTrayPolicyEnabled = _trayNotify.GetIsNoAutoTrayPolicyEnabled();
        ptvo->fAutoTrayEnabledByUser = _trayNotify.GetIsAutoTrayEnabledByUser();
        ptvo->uAutoHide           = _uAutoHide;     // AH_HIDING , AH_ON
        ptvo->fShowQuickLaunch    = (-1 != SendMessage(_hwnd, WMTRAY_TOGGLEQL, 0, (LPARAM)-1));
    }
    void SetTrayViewOpts(const TRAYVIEWOPTS* ptvo)
    {
        _UpdateAlwaysOnTop(ptvo->fAlwaysOnTop);
        SendMessage(_hwnd, WMTRAY_TOGGLEQL, 0, (LPARAM)ptvo->fShowQuickLaunch);
        _fSMSmallIcons       = ptvo->fSMSmallIcons;
        _fHideClock          = ptvo->fHideClock;
        _uAutoHide           = ptvo->uAutoHide;     // AH_HIDING , AH_ON

        // There is no necessity to save the fNoAutoTrayPolicyEnabled, 
        // fNoTrayItemsDisplayPolicyEnabled, fAutoTrayEnabledByUser settings...
    }

    BOOL GetIsNoToolbarsOnTaskbarPolicyEnabled() const
    {
        return _fNoToolbarsOnTaskbarPolicyEnabled;
    }

    STDMETHODIMP_(ULONG) AddRef() { return 2; }
    STDMETHODIMP_(ULONG) Release() { return 1; }

    //
    // miscellaneous public data
    //

    // from TRAYSTUFF
    BOOL _fCoolTaskbar;
    BOOL _bMainMenuInit;
    BOOL _fFlashing;    // currently flashing (HSHELL_FLASH)
    BOOL _fStuckRudeApp;
    BOOL _fDeferedPosRectChange;
    BOOL _fSelfSizing;
    BOOL _fBalloonUp; // true if balloon notification is up
    BOOL _fIgnoreDoneMoving;
    BOOL _fShowSizingBarAlways;
    BOOL _fSkipErase;

    BOOL _fIsLogoff;

    HWND _hwndStart;
    HWND _hwndLastActive;

    IBandSite *_ptbs;

    UINT _uAutoHide;     // AH_HIDING , AH_ON

    HBITMAP _hbmpStartBkg;
    HFONT   _hFontStart;

    RECT _arStuckRects[4];   // temporary for hit-testing

    CTrayNotify _trayNotify;

protected:
    // protected methods
    friend class CTaskBarPropertySheet;

    static DWORD WINAPI SyncThreadProc(void *pv);
    DWORD _SyncThreadProc();
    static DWORD WINAPI MainThreadProc(void *pv);

    int _GetPart(BOOL fSizingBar, UINT uStuckPlace);
    void _UpdateVertical(UINT uStuckPlace, BOOL fForce = FALSE);
    void _RaiseDesktop(BOOL fRaise, BOOL fRestoreWindows);

    BOOL _RestoreWindowPositions(BOOL fPostLowerDesktop);
    void _RestoreWindowPos();

    static BOOL SavePosEnumProc(HWND hwnd, LPARAM lParam);

    BOOL _IsPopupMenuVisible();
    BOOL _IsActive();
    void _AlignStartButton();
    void _GetWindowSizes(UINT uStuckPlace, PRECT prcClient, PRECT prcView, PRECT prcNotify);
    void _GetStuckDisplayRect(UINT uStuckPlace, LPRECT prcDisplay);
    void _Hide();
    HWND _GetClockWindow(void);
    HRESULT _LoadInProc(PCOPYDATASTRUCT pcds);

    LRESULT _CreateWindows();
    LRESULT _InitStartButtonEtc();
    void _AdjustMinimizedMetrics();
    void _MessageLoop();

    void _BuildStartMenu();
    void _DestroyStartMenu();
    int _TrackMenu(HMENU hmenu);

    static DWORD WINAPI RunDlgThreadProc(void *pv);
    DWORD _RunDlgThreadProc(HANDLE hdata);

    int  _GetQuickLaunchID();
    int  _ToggleQL(int iVisible);

    static BOOL TileEnumProc(HWND hwnd, LPARAM lParam);
    BOOL _CanTileAnyWindows()
    {
        return !EnumWindows(TileEnumProc, (LPARAM)this);
    }

    void _RegisterDropTargets();
    void _RevokeDropTargets();

    BOOL _UpdateAlwaysOnTop(BOOL fAlwaysOnTop);

    HMONITOR _GetDisplayRectFromRect(LPRECT prcDisplay, LPCRECT prcIn, UINT uFlags);
    HMONITOR _GetDisplayRectFromPoint(LPRECT prcDisplay, POINT pt, UINT uFlags);
    void _AdjustRectForSizingBar(UINT uStuckPlace, LPRECT prc, int iIncrement);
    void _MakeStuckRect(LPRECT prcStick, LPCRECT prcBound, SIZE size, UINT uStick);
    void _ScreenSizeChange(HWND hwnd);
    void _ContextMenu(DWORD dwPos, BOOL fSetTime);
    void _StuckTrayChange();
    void _ResetZorder();
    void _HandleSize();
    BOOL _HandleSizing(WPARAM code, LPRECT lprc, UINT uStuckPlace);
    void _RegisterGlobalHotkeys();
    void _UnregisterGlobalHotkeys();
    void _HandleGlobalHotkey(WPARAM wParam);
    void _SetAutoHideTimer();
    void _ComputeHiddenRect(LPRECT prc, UINT uStuck);
    UINT _GetDockedRect(LPRECT prc, BOOL fMoving);
    void _CalcClipCoords(RECT *prcClip, const RECT *prcMonitor, const RECT *prcNew);
    void _ClipInternal(const RECT *prcClip);
    void _ClipWindow(BOOL fEnableClipping);
    UINT _CalcDragPlace(POINT pt);
    UINT _RecalcStuckPos(LPRECT prc);
    void _AutoHideCollision();
    LRESULT _HandleMeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT lpmi);
    void _OnDesktopState(LPARAM lParam);
    BOOL _ToggleLanguageBand(BOOL fShowIt);

    LRESULT _OnDeviceChange(HWND hwnd, WPARAM wParam, LPARAM lParam);
    DWORD _PtOnResizableEdge(POINT pt, LPRECT prcClient);
    BOOL _MapNCToClient(LPARAM* plParam);
    BOOL _TryForwardNCToClient(UINT uMsg, LPARAM lParam);
    LRESULT _OnSessionChange(WPARAM wParam, LPARAM lParam);
    LRESULT _NCPaint(HRGN hrgn);
    LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL _CanMinimizeAll();
    BOOL _MinimizeAll(BOOL fPostRaiseDesktop);
    void _Command(UINT idCmd);
    LONG _SetAutoHideState(BOOL fAutoHide);
    BOOL _ShouldWeShowTheStartButtonBalloon();
    void _DontShowTheStartButtonBalloonAnyMore();
    void _DestroyStartButtonBalloon();
    void _ShowStartButtonToolTip();
    void _ToolbarMenu();
    HFONT _CreateStartFont(HWND hwndTray);
    void _SaveTrayStuff(void);
    void _SaveTray(void);
    void _SaveTrayAndDesktop(void);
    void _SlideStep(HWND hwnd, const RECT *prcMonitor, const RECT *prcOld, const RECT *prcNew);
    void _DoExitWindows(HWND hwnd);

    static LRESULT WINAPI StartButtonSubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _StartButtonSubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void _ResizeStuckRects(RECT *arStuckRects);

    static DWORD WINAPI PropertiesThreadProc(void* pv);
    DWORD _PropertiesThreadProc(DWORD dwFlags);

    int _RecomputeWorkArea(HWND hwndCause, HMONITOR hmon, LPRECT prcWork);

    void _StartButtonReset();
    void _RefreshStartMenu();
    void _ExploreCommonStartMenu(BOOL bExplore);

    BOOL _CreateClockWindow();
    void _CreateTrayTips();
    HWND _CreateStartButton();
    BOOL _InitTrayClass();
    void _SetStuckMonitor();
    void _GetSaveStateAndInitRects();
    LRESULT _OnCreateAsync();
    LRESULT _OnCreate(HWND hwnd);
    void _UpdateBandSiteStyle();
    void _InitBandsite();
    void _InitNonzeroGlobals();
    void _CreateTrayWindow();
    void _DoneMoving(LPWINDOWPOS lpwp);
    void _SnapshotStuckRectSize(UINT uPlace);
    void _RecomputeAllWorkareas();
    void _SlideWindow(HWND hwnd, RECT *prc, BOOL fShow);
    void _UnhideNow();
    void _HandleEnterMenuLoop();
    void _HandleExitMenuLoop();
    void _SetUnhideTimer(LONG x, LONG y);
    void _OnNewSystemSizes();
    static int WINAPI CheckWndPosEnumProc(void *pItem, void *pData);
    void _HandleTimer(WPARAM wTimerID);
    void _KickStartAutohide();
    void _HandleMoving(WPARAM wParam, LPRECT lprc);
    LRESULT _HandleDestroy();
    void _SetFocus(HWND hwnd);
    void _ActAsSwitcher();
    void _OnWinIniChange(HWND hwnd, WPARAM wParam, LPARAM lParam);
    LRESULT _ShortcutRegisterHotkey(HWND hwnd, WORD wHotkey, ATOM atom);
    LRESULT _SetHotkeyEnable(HWND hwnd, BOOL fEnable);
    void _HandleWindowPosChanging(LPWINDOWPOS lpwp);
    void _HandlePowerStatus(UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    void _DesktopCleanup_GetFileTimeNDaysFromGivenTime(const FILETIME *pftGiven, FILETIME * pftReturn, int iDays);
    BOOL _DesktopCleanup_ShouldRun();
    void _CheckDesktopCleanup(void);

    static BOOL_PTR WINAPI RogueProgramFileDlgProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
    void _CheckForRogueProgramFile();
    void _OnWaitCursorNotify(LPNMHDR pnm);
    void _HandlePrivateCommand(LPARAM lParam);
    void _OnFocusMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
    int _OnFactoryMessage(WPARAM wParam, LPARAM lParam);
    int _OnTimerService(UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _HandleDelayBootStuff();
    void _HandleChangeNotify(WPARAM wParam, LPARAM lParam);
    void _CheckStagingAreaOnTimer();

    BOOL _IsTopmost();
    void _RefreshSettings();

    static BOOL PropagateEnumProc(HWND hwnd, LPARAM lParam);
    void _PropagateMessage(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    
    BOOL _IsAutoHide()  { return _uAutoHide & AH_ON; }
    void _RunDlg();

    static void WINAPI SettingsUIPropSheetCallback(DWORD nStartPage);
    static DWORD WINAPI SettingsUIThreadProc(void *pv);

    static BOOL WINAPI FullScreenEnumProc(HMONITOR hmon, HDC hdc, LPRECT prc, LPARAM dwData);

    static BOOL WINAPI MonitorEnumProc(HMONITOR hMonitor, HDC hdc, LPRECT lprc, LPARAM lData);

    // appbar stuff
    HRESULT _AppBarSetState(UINT uFlags);
    void _AppBarActivationChange(PTRAYAPPBARDATA ptabd);
    BOOL _AppBarSetAutoHideBar(PTRAYAPPBARDATA ptabd);
    BOOL _AppBarSetAutoHideBar2(HWND hwnd, BOOL fAutoHide, UINT uEdge);
    void _AppBarActivationChange2(HWND hwnd, UINT uEdge);
    HWND _AppBarGetAutoHideBar(UINT uEdge);
    LRESULT _OnAppBarMessage(PCOPYDATASTRUCT pcds);
    void _AppBarSubtractRect(PAPPBAR pab, LPRECT lprc);
    void _AppBarSubtractRects(HMONITOR hmon, LPRECT lprc);
    void _StuckAppChange(HWND hwndCause, LPCRECT prcOld, LPCRECT prcNew, BOOL bTray);
    void _AppBarNotifyAll(HMONITOR hmon, UINT uMsg, HWND hwndExclude, LPARAM lParam);
    void _AppBarGetTaskBarPos(PTRAYAPPBARDATA ptabd);
    void _NukeAppBar(int i);
    void _AppBarRemove(PTRAYAPPBARDATA ptabd);
    PAPPBAR _FindAppBar(HWND hwnd);
    BOOL _AppBarNew(PTRAYAPPBARDATA ptabd);
    BOOL _AppBarOutsideOf(PAPPBAR pabReq, PAPPBAR pab);
    void _AppBarQueryPos(PTRAYAPPBARDATA ptabd);
    void _AppBarSetPos(PTRAYAPPBARDATA ptabd);


    // hotkey stuff
    void _HandleHotKey(int nID);
    LRESULT _ShortcutUnregisterHotkey(HWND hwnd, WORD wHotkey);
    LRESULT _RegisterHotkey(HWND hwnd, int i);
    LRESULT _UnregisterHotkey(HWND hwnd, int i);
    HWND _HotkeyInUse(WORD wHK);
    int _RestoreHotkeyList(HWND hwnd);
    UINT _HotkeyGetFreeItemIndex(void);
    int _HotkeyAddCached(WORD wGHotkey, LPITEMIDLIST pidl);
    int _HotkeySave(void);
    int _HotkeyRemove(WORD wHotkey);
    int _HotkeyRemoveCached(WORD wGHotkey);
    BOOL _HotkeyCreate(void);

    // Startup troubleshooter stuff
    static void WINAPI TroubleShootStartupCB(HWND hwnd, UINT uMsg, UINT_PTR idTimer, DWORD dwTime);
    void _OnHandleStartupFailed();

    // App compat stuff
    static void CALLBACK _MigrateOldBrowserSettingsCB(PVOID lpParameter, BOOLEAN);
    void _MigrateOldBrowserSettings();

    // protected data
    HWND _hwndNotify;     // clock window
    HWND _hwndStartBalloon;
    HWND _hwndRude;
    HWND _hwndTrayTips;
    HWND _hwndTasks;

    HMENU _hmenuStart;

    SIZE _sizeStart;  // height/width of the start button
    SIZE _sizeSizingBar;
    int  _iAlpha;

    HIMAGELIST _himlStartFlag;

    CShellServiceObjectMgr _ssomgr;
    CStartDropTarget _dtStart;
    CTrayDropTarget _dtTray;
    CDeskTray _desktray;

#define MM_OTHER    0x01
#define MM_SHUTDOWN 0x02
    UINT _uModalMode;

    BOOL _fAlwaysOnTop;
    BOOL _fSMSmallIcons;
    BOOL _fGlobalHotkeyDisable;
    BOOL _fThreadTerminate;
    BOOL _fSysSizing;      // being sized by user; hold off on recalc
    BOOL _fHideClock;
    BOOL _fShouldResize;
    BOOL _fMonitorClipped;
    BOOL _fHandledDelayBootStuff;
    BOOL _fUndoEnabled;
    BOOL _fProcessingDesktopRaise;
    BOOL _fFromStart;      // Track when context menu popping up from Start button
    BOOL _fTaskbarFading;
    BOOL _fNoToolbarsOnTaskbarPolicyEnabled;
            
    POINT _ptLastHittest;

    HWND _hwndRun;
    HWND _hwndProp;
    HWND _hwndRebar;

    HACCEL _hMainAccel;     // Main accel table
    int _iWaitCount;

    HDPA _hdpaAppBars;  // app bar info
    HDSA _hdsaHKI;  // hotkey info

    CRITICAL_SECTION _csHotkey; // Protects _hdsaHKI, hotkey info

    LPWINDOWPOSITIONS _pPositions;  // saved windows positions (for undo of minimize all)

    UINT _uStuckPlace;       // the stuck place
    SIZE _sStuckWidths;      // width/height of tray
    UINT _uMoveStuckPlace;   // stuck status during a move operation

    // these two must  go together for save reasons
    RECT _rcOldTray;     // last place we stuck ourselves (for work area diffs)
    HMONITOR _hmonStuck; // The current HMONITOR we are on
    HMONITOR _hmonOld;   // The last hMonitor we were on 
    IMenuBand*  _pmbStartMenu;  //For Message translation.
    IMenuPopup* _pmpStartMenu;  //For start menu cache
    IMenuBand*  _pmbStartPane; // For Message translation.
    IMenuPopup* _pmpStartPane; // For navigating the start pane
    void *      _pvStartPane;  // For delayed initilization
    IStartMenuPin *_psmpin;    // For drag/drop to Start Button
    IMenuBand*  _pmbTasks;      //For Message translation.
    IMenuPopup* _pmpTasks;

    IDeskBand* _pdbTasks;

    WNDPROC _pfnButtonProc;    // Button subclass.
    UINT _uDown;
    BOOL _fAllowUp;            // Is the start button allowed to be in the up position?
    UINT _uStartButtonState;   // crazy state machine -- see Tray_SetStartPaneActive
    DWORD _tmOpen;             // time the Start Menu was opened (for debouncing)


    int _cHided;
    int _cyTrayBorders;

    HTHEME _hTheme;

    //
    // amount of time to show/hide the tray
    // to turn sliding off set these to 0
    //
    int _dtSlideHide;
    int _dtSlideShow;

    HWND _hwndFocusBeforeRaise;
    BOOL _fMinimizedAllBeforeRaise;

    BOOL _fCanSizeMove; // can be turned off by user setting
    RECT _rcSizeMoveIgnore;

    // event to tell the services on NT5 that we are done with boot
    // and they can do their stuff
    HANDLE _hShellReadyEvent;

    // BOGUS: nuke this (multiple monitors...)
    HWND _aHwndAutoHide[ABE_MAX];

    // Users and Passwords must send this message to get the "real" logged on user to log off.
    // This is required since sometimes U&P runs in the context of a different user and logging this
    // other user off does no good. See ext\netplwiz for the other half of this...-dsheldon.
    UINT _uLogoffUser;
    UINT _uStartButtonBalloonTip;
    UINT _uWinMM_DeviceChange;

    BOOL _fEarlyStartupFailure;
    BOOL _fStartupTroubleshooterLaunched;

    ULONG _uNotify;
    BOOL _fUseChangeNotifyTimer, _fChangeNotifyTimerRunning;

    BOOL _fIsDesktopLocked;
    BOOL _fIsDesktopConnected;

    // These member variables are used to keep track of downlevel apps
    // which attempt to take over as default web browser
    HKEY _hkHTTP;
    HANDLE _hHTTPEvent;
    HANDLE _hHTTPWait;

    friend class CDeskTray;
    friend class CStartDropTarget;
    friend class CTrayDropTarget;
    friend class CDropTargetBase;

    friend void Tray_OnStartMenuDismissed();
    friend void Tray_SetStartPaneActive(BOOL fActive);
    friend void Tray_DoProperties(DWORD dwFlags);
};

extern CTray c_tray;

extern BOOL g_fInSizeMove;
extern UINT g_uStartButtonAllowPopup;

BOOL _IsSizeMoveEnabled();
BOOL _IsSizeMoveRestricted();


#endif  // __cplusplus

#endif  // _TRAY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\trayclok.cpp ===
#include "cabinet.h"
#include "trayclok.h"
#include "tray.h"
#include "util.h"
#include "strsafe.h"

class CClockCtl : public CImpWndProc
{
public:
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    CClockCtl() : _cRef(1) {}

protected:
    // Create & Destroy
    LRESULT         _HandleCreate();
    LRESULT         _HandleDestroy();

    // Paint helpers
    LRESULT         _DoPaint(BOOL fPaint);
    void            _EnsureFontsInitialized(BOOL fForce);
    void            _GetTextExtent(HDC hdc, TCHAR* pszText, int cchText, LPRECT prcText);
    void            _DrawText(HDC hdc, TCHAR* pszText, int cchText, LPRECT prcText);

    // Time/Date calc helpers
    void            _Reset();
    void            _UpdateLastHour();
    DWORD         _RecalcCurTime();
    void            _EnableTimer(DWORD dtNextTick);

    // Message handlers
    void             _HandleThemeChanged(WPARAM wParam);
    LRESULT         _HandleIniChange(WPARAM wParam, LPTSTR pszSection);
    LRESULT         _HandleTimeChange();

    // Text extent helpers
    void            _GetMaxTimeSize(HDC hdc, LPSIZE pszTime);
    void            _GetMaxDateSize(HDC hdc, LPSIZE pszTime);
    void            _GetMaxDaySize(HDC hdc, LPSIZE pszTime);
    LRESULT        _CalcMinSize(int cxMax, int cyMax);

    // Tooltip text handler
    LRESULT         _OnNeedText(LPTOOLTIPTEXT lpttt);

    // Window procedure
    LRESULT         v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    ULONG           _cRef;

    int               _cchCurDate;
    TCHAR           _szDateFmt[40];   // The format string to pass to GetFormatTime
    TCHAR           _szCurDate[40];   // The current Date string.

    int               _cchCurTime;
    TCHAR           _szTimeFmt[40];   // The format string to pass to GetFormatTime
    TCHAR           _szCurTime[40];   // The current Time string.

    int               _cchCurDay;
    TCHAR           _szCurDay[40];      // The current Day string.

    WORD            _wLastHour;       // wHour from local time of last clock tick
    WORD            _wLastMinute;     // wMinute from local time of last clock tick
    
    HTHEME          _hTheme;
    HFONT           _hfontCapNormal;

    BOOL             _fClockRunning;
    BOOL             _fClockClipped;
    BOOL             _fHasFocus;

    friend BOOL ClockCtl_Class(HINSTANCE hinst);
};

ULONG CClockCtl::AddRef()
{
    return ++_cRef;
}

ULONG CClockCtl::Release()
{
    if (--_cRef == 0)
    {
        delete this;
        return 0;
    }
    return _cRef;
}

void CClockCtl::_UpdateLastHour()
{
    SYSTEMTIME st;

    // Grab the time
    GetLocalTime(&st);
    _wLastHour = st.wHour;
    _wLastMinute = st.wMinute;
}

void CClockCtl::_EnableTimer(DWORD dtNextTick)
{
    if (dtNextTick)
    {
        SetTimer(_hwnd, 0, dtNextTick, NULL);
        _fClockRunning = TRUE;
    }
    else if (_fClockRunning)
    {
        _fClockRunning = FALSE;
        KillTimer(_hwnd, 0);
    }
}

LRESULT CClockCtl::_HandleCreate()
{
    AddRef();

    _EnsureFontsInitialized(FALSE);

    _hTheme = OpenThemeData(_hwnd, L"Clock");

    _UpdateLastHour();
    return 1;
}

LRESULT CClockCtl::_HandleDestroy()
{
    Release();  // safe because cwndproc is holding a ref across call to v_wndproc

    if (_hTheme)
    {
        CloseThemeData(_hTheme);
        _hTheme = NULL;
    }

    if (_hfontCapNormal)
    {
        DeleteFont(_hfontCapNormal);
        _hfontCapNormal = NULL;
    }

    _EnableTimer(0);
    return 1;
}

DWORD CClockCtl::_RecalcCurTime()
{
    SYSTEMTIME st;

    //
    // Current time.
    //
    GetLocalTime(&st);

    //
    // Don't recalc the text if the time hasn't changed yet.
    //
    if ((st.wMinute != _wLastMinute) || (st.wHour != _wLastHour) || !*_szCurTime)
    {
        _wLastMinute = st.wMinute;
        _wLastHour = st.wHour;

        //
        // Text for the current time.
        //
        _cchCurTime = GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS,
            &st, _szTimeFmt, _szCurTime, ARRAYSIZE(_szCurTime));

        BOOL fRTL = IS_WINDOW_RTL_MIRRORED(_hwnd);
        _cchCurDate = GetDateFormat(LOCALE_USER_DEFAULT, fRTL ? DATE_RTLREADING : 0,
            &st, _szDateFmt, _szCurDate, ARRAYSIZE(_szCurDate));

        _cchCurDay = GetDateFormat(LOCALE_USER_DEFAULT, fRTL ? DATE_RTLREADING : 0,
            &st, TEXT("dddd"), _szCurDay, ARRAYSIZE(_szCurDay));

        // Don't count the NULL terminator.
        if (_cchCurTime > 0)
            _cchCurTime--;

        if (_cchCurDate > 0)
            _cchCurDate--;

        if (_cchCurDay > 0)
            _cchCurDay--;
        //
        // Update our window text so accessibility apps can see.  Since we
        // don't have a caption USER won't try to paint us or anything, it
        // will just set the text and fire an event if any accessibility
        // clients are listening...
        //
        SetWindowText(_hwnd, _szCurTime);
    }

    //
    // Return number of milliseconds till we need to be called again.
    //
    return 1000UL * (60 - st.wSecond);
}

void CClockCtl::_EnsureFontsInitialized(BOOL fForce)
{
    if (fForce || !_hfontCapNormal)
    {
        HFONT hfont;
        NONCLIENTMETRICS ncm;

        ncm.cbSize = sizeof(ncm);
        if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
        {
            // Create the normal font
            ncm.lfCaptionFont.lfWeight = FW_NORMAL;
            hfont = CreateFontIndirect(&ncm.lfCaptionFont);
            if (hfont) 
            {
                if (_hfontCapNormal)
                    DeleteFont(_hfontCapNormal);
                
                _hfontCapNormal = hfont;
            }
        }
    }
}

void CClockCtl::_GetTextExtent(HDC hdc, TCHAR* pszText, int cchText, LPRECT prcText)
{
    if (_hTheme)
    {
        GetThemeTextExtent(_hTheme, hdc, CLP_TIME, 0, pszText, cchText, 0, prcText, prcText);
    }
    else
    {
        SIZE size;
        GetTextExtentPoint(hdc, pszText, cchText, &size);
        SetRect(prcText, 0, 0, size.cx, size.cy);
    }
}

void CClockCtl::_DrawText(HDC hdc, TCHAR* pszText, int cchText, LPRECT prcText)
{
    if (_hTheme)
    {
        DrawThemeText(_hTheme, hdc, CLP_TIME, 0, pszText, cchText, 0, 0, prcText);
    }
    else
    {
        ExtTextOut(hdc, prcText->left, prcText->top, ETO_OPAQUE, NULL, pszText, cchText, NULL);
    }
}

LRESULT CClockCtl::_DoPaint(BOOL fPaint)
{
    PAINTSTRUCT ps;
    RECT rcClient, rcClip = {0};
    DWORD dtNextTick = 0;
    BOOL fDoTimer;
    HDC hdc;
    HBITMAP hMemBm, hOldBm;

    //
    // If we are asked to paint and the clock is not running then start it.
    // Otherwise wait until we get a clock tick to recompute the time etc.
    //
    fDoTimer = !fPaint || !_fClockRunning;

    //
    // Get a DC to paint with.
    //
    if (fPaint)
    {
        BeginPaint(_hwnd, &ps);
    }
    else
    {
        ps.hdc = GetDC(_hwnd);
        GetClipBox(ps.hdc, &ps.rcPaint);
    }

    // Create memory surface and map rendering context if double buffering
    // Only make large enough for clipping region
    hdc = CreateCompatibleDC(ps.hdc);
    if (hdc)
    {
        hMemBm = CreateCompatibleBitmap(ps.hdc, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint));
        if (hMemBm)
        {
            hOldBm = (HBITMAP) SelectObject(hdc, hMemBm);

            // Offset painting to paint in region
            OffsetWindowOrgEx(hdc, ps.rcPaint.left, ps.rcPaint.top, NULL);
        }
        else
        {
            DeleteDC(hdc);
            hdc = NULL;
        }
    }

    if (hdc)
    {
        SHSendPrintRect(GetParent(_hwnd), _hwnd, hdc, &ps.rcPaint);

        _EnsureFontsInitialized(FALSE);

        //
        // Update the time if we need to.
        //
        if (fDoTimer || !*_szCurTime)
        {
            dtNextTick = _RecalcCurTime();

            ASSERT(dtNextTick);
        }

        //
        // Paint the clock face if we are not clipped or if we got a real
        // paint message for the window.  We want to avoid turning off the
        // timer on paint messages (regardless of clip region) because this
        // implies the window is visible in some way. If we guessed wrong, we
        // will turn off the timer next timer tick anyway so no big deal.
        //
        if (GetClipBox(hdc, &rcClip) != NULLREGION || fPaint)
        {
            //
            // Draw the text centered in the window.
            //
            GetClientRect(_hwnd, &rcClient);

            HFONT hfontOld;

            if (_hfontCapNormal)
                hfontOld = SelectFont(hdc, _hfontCapNormal);

            SetBkColor(hdc, GetSysColor(COLOR_3DFACE));
            SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));

            BOOL fShowDate = FALSE;
            BOOL fShowDay = FALSE;
            RECT rcTime = {0};
            RECT rcDate = {0};
            RECT rcDay = {0};

            _GetTextExtent(hdc, _szCurTime, _cchCurTime, &rcTime);
            _GetTextExtent(hdc, _szCurDate, _cchCurDate, &rcDate);
            _GetTextExtent(hdc, _szCurDay,  _cchCurDay,  &rcDay);

            int cySpace = RECTHEIGHT(rcTime) / 2;

            int cy = RECTHEIGHT(rcTime) + cySpace;
            if ((cy + RECTHEIGHT(rcDay) < rcClient.bottom) && (RECTWIDTH(rcDay) < rcClient.right))
            {
                fShowDay = TRUE;
                cy += RECTHEIGHT(rcDay) + cySpace;
                if ((cy + RECTHEIGHT(rcDate) < rcClient.bottom) && (RECTWIDTH(rcDate) < rcClient.right))
                {
                    fShowDate = TRUE;
                    cy += RECTHEIGHT(rcDate) + cySpace;
                }
            }
            cy -= cySpace;

            int yOffset = max((rcClient.bottom - cy) / 2, 0);
            RECT rcDraw = rcTime;
            OffsetRect(&rcDraw, max((rcClient.right - RECTWIDTH(rcTime)) / 2, 0), yOffset);
            _DrawText(hdc, _szCurTime, _cchCurTime, &rcDraw);
            yOffset += RECTHEIGHT(rcTime) + cySpace;

            if (fShowDay)
            {
                rcDraw = rcDay;
                OffsetRect(&rcDraw, max((rcClient.right - RECTWIDTH(rcDay)) / 2, 0), yOffset);
                _DrawText(hdc, _szCurDay, _cchCurDay, &rcDraw);
                yOffset += RECTHEIGHT(rcDay) + cySpace;
                if (fShowDate)
                {
                    rcDraw = rcDate;
                    OffsetRect(&rcDraw, max((rcClient.right - RECTWIDTH(rcDate)) / 2, 0), yOffset);
                    _DrawText(hdc, _szCurDate, _cchCurDate, &rcDraw);
                }
            }

            //  figure out if the time is clipped
            _fClockClipped = (RECTWIDTH(rcTime) > rcClient.right || RECTHEIGHT(rcTime) > rcClient.bottom);

            if (_hfontCapNormal)
                SelectObject(hdc, hfontOld);

            if (_fHasFocus)
            {
                LRESULT lRes = SendMessage(_hwnd, WM_QUERYUISTATE, 0, 0);
                if (!(LOWORD(lRes) & UISF_HIDEFOCUS))
                {
                    RECT rcFocus = rcClient;
                    InflateRect(&rcFocus, -2, 0);
                    DrawFocusRect(hdc, &rcFocus);
                }
            }
        }
        else
        {
            //
            // We are obscured so make sure we turn off the clock.
            //
            dtNextTick = 0;
            fDoTimer = TRUE;
        }

        BitBlt(ps.hdc, ps.rcPaint.left, ps.rcPaint.top, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint), hdc, ps.rcPaint.left, ps.rcPaint.top, SRCCOPY);

        SelectObject(hdc, hOldBm);

        DeleteObject(hMemBm);
        DeleteDC(hdc);

        //
        // Release our paint DC.
        //
        if (fPaint)
            EndPaint(_hwnd, &ps);
        else
            ReleaseDC(_hwnd, ps.hdc);
    }

    //
    // Reset/Kill the timer.
    //
    if (fDoTimer)
    {
        _EnableTimer(dtNextTick);

        //
        // If we just killed the timer because we were clipped when it arrived,
        // make sure that we are really clipped by invalidating ourselves once.
        //
        if (hdc)
        {
            if (!dtNextTick && !fPaint)
                InvalidateRect(_hwnd, NULL, FALSE);
            else
            {
                InvalidateRect(_hwnd, NULL, TRUE);
            }
        }
    }

    return 0;
}

void CClockCtl::_Reset()
{
    //
    // Reset the clock by killing the timer and invalidating.
    // Everything will be updated when we try to paint.
    //
    _EnableTimer(0);
    InvalidateRect(_hwnd, NULL, FALSE);
}

LRESULT CClockCtl::_HandleTimeChange()
{
    *_szCurTime = 0;   // Force a text recalc.
    _UpdateLastHour();
    _Reset();
    return 1;
}

static const TCHAR c_szSlop[] = TEXT("00");

void CClockCtl::_GetMaxTimeSize(HDC hdc, LPSIZE pszTime)
{
    SYSTEMTIME st={0};  // Initialize to 0...
    RECT rcAM = {0};
    RECT rcPM = {0};
    TCHAR szTime[40];

    // We need to get the AM and the PM sizes...
    // We append Two 0s at end to add slop into size

    // first AM
    st.wHour=11;
    int cch = GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st,
            _szTimeFmt, szTime, ARRAYSIZE(szTime) - ARRAYSIZE(c_szSlop));
    if (cch)
        cch--; // don't count the NULL
    StringCchCat(szTime, ARRAYSIZE(szTime), c_szSlop);

    _GetTextExtent(hdc, szTime, cch+2, &rcAM);

    // then PM
    st.wHour=23;
    cch = GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st,
            _szTimeFmt, szTime, ARRAYSIZE(szTime) - ARRAYSIZE(c_szSlop));
    if (cch)
        cch--; // don't count the NULL
    StringCchCat(szTime, ARRAYSIZE(szTime), c_szSlop);

    _GetTextExtent(hdc, szTime, cch+2, &rcPM);

    pszTime->cx = max(rcAM.right, rcPM.right);
    pszTime->cy = max(rcAM.bottom, rcPM.bottom);
}

void CClockCtl::_GetMaxDateSize(HDC hdc, LPSIZE pszTime)
{
    SYSTEMTIME st={0};  // Initialize to 0...
    TCHAR szDate[43];

    st.wYear = 2001;
    st.wMonth = 5;
    st.wDay = 5;

    BOOL fRTL = IS_WINDOW_RTL_MIRRORED(_hwnd);
    int cch = GetDateFormat(LOCALE_USER_DEFAULT, fRTL ? DATE_RTLREADING : 0,
        &st, _szDateFmt, szDate, ARRAYSIZE(szDate) - ARRAYSIZE(c_szSlop));
    if (cch > 0)
        cch--; // don't count the NULL
    StringCchCat(szDate, ARRAYSIZE(szDate), c_szSlop);

    RECT rc = {0};
    _GetTextExtent(hdc, szDate, cch+2, &rc);
    pszTime->cx = rc.right;
    pszTime->cy = rc.bottom;
}


void CClockCtl::_GetMaxDaySize(HDC hdc, LPSIZE pszTime)
{
    SYSTEMTIME st={0};  // Initialize to 0...
    TCHAR szDay[40];

    pszTime->cx = 0;
    pszTime->cy = 0;

    // Use a fake date, otherwise GetDateFormat complains about invalid args
    // BTW, the date is the day I fixed this bug for those of you reading this comment
    // in the year 2025.
    st.wYear = 2001;
    st.wMonth = 3;
    for (WORD wDay = 1; wDay <= 7; wDay++)
    {
        st.wDay = wDay;
        int cch = GetDateFormat(LOCALE_USER_DEFAULT, 0,
            &st, TEXT("dddd"), szDay, ARRAYSIZE(szDay) - ARRAYSIZE(c_szSlop));
        if (cch)
            cch--; // don't count the NULL
        StringCchCat(szDay, ARRAYSIZE(szDay), c_szSlop);

        RECT rc = {0};
        _GetTextExtent(hdc, szDay, cch+2, &rc);
        pszTime->cx = max(pszTime->cx, rc.right);
        pszTime->cy = max(pszTime->cy, rc.bottom);
    }
}

LRESULT CClockCtl::_CalcMinSize(int cxMax, int cyMax)
{
    RECT rc;
    HDC  hdc;
    HFONT hfontOld;

    if (!(GetWindowLong(_hwnd, GWL_STYLE) & WS_VISIBLE))
        return 0L;

    if (_szTimeFmt[0] == TEXT('\0'))
    {
        if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIMEFORMAT, _szTimeFmt,
            ARRAYSIZE(_szTimeFmt)) == 0)
        {
            TraceMsg(TF_ERROR, "c.ccms: GetLocalInfo Failed %d.", GetLastError());
        }

        *_szCurTime = 0; // Force the text to be recomputed.
    }

    if (_szDateFmt[0] == TEXT('\0'))
    {
        if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SSHORTDATE, _szDateFmt,
            ARRAYSIZE(_szDateFmt)) == 0)
        {
            TraceMsg(TF_ERROR, "c.ccms: GetLocalInfo Failed %d.", GetLastError());
        }

        *_szCurDate = 0; // Force the text to be recomputed.
    }

    hdc = GetDC(_hwnd);
    if (!hdc)
        return(0L);


    _EnsureFontsInitialized(FALSE);

    if (_hfontCapNormal)
        hfontOld = SelectFont(hdc, _hfontCapNormal);

    SIZE size = {0};
    SIZE sizeTemp = {0};
    _GetMaxTimeSize(hdc, &sizeTemp);
    int cySpace = sizeTemp.cy / 2;
    size.cy += sizeTemp.cy;
    size.cx = max(sizeTemp.cx, size.cx);

    _GetMaxDaySize(hdc, &sizeTemp);
    if ((size.cy + sizeTemp.cy + cySpace < cyMax) && (sizeTemp.cx < cxMax))
    {
        size.cy += sizeTemp.cy + cySpace;
        size.cx = max(sizeTemp.cx, size.cx);

        _GetMaxDateSize(hdc, &sizeTemp);
        if ((size.cy + sizeTemp.cy + cySpace < cyMax) && (sizeTemp.cx < cxMax))
        {
            size.cy += sizeTemp.cy + cySpace;
            size.cx = max(sizeTemp.cx, size.cx);
        }
    }

    if (_hfontCapNormal)
        SelectObject(hdc, hfontOld);

    ReleaseDC(_hwnd, hdc);

    // Now lets set up our rectangle...
    // The width is 6 digits (a digit slop on both ends + size of
    // : or sep and max AM or PM string...)
    SetRect(&rc, 0, 0, size.cx,
            size.cy + 4 * g_cyBorder);

    AdjustWindowRectEx(&rc, GetWindowLong(_hwnd, GWL_STYLE), FALSE,
            GetWindowLong(_hwnd, GWL_EXSTYLE));

    // make sure we're at least the size of other buttons:
    if (rc.bottom - rc.top <  g_cySize + g_cyEdge)
        rc.bottom = rc.top + g_cySize + g_cyEdge;

    return MAKELRESULT((rc.right - rc.left),
            (rc.bottom - rc.top));
}

LRESULT CClockCtl::_HandleIniChange(WPARAM wParam, LPTSTR pszSection)
{
    if ((pszSection == NULL) || (lstrcmpi(pszSection, TEXT("WindowMetrics")) == 0) ||
        wParam == SPI_SETNONCLIENTMETRICS)
    {
        _EnsureFontsInitialized(TRUE);
    }

    // Only process certain sections...
    if ((pszSection == NULL) || (lstrcmpi(pszSection, TEXT("intl")) == 0) ||
        (wParam == SPI_SETICONTITLELOGFONT))
    {
        TOOLINFO ti;

        _szTimeFmt[0] = TEXT('\0');      // Go reread the format.
        _szDateFmt[0] = TEXT('\0');      // Go reread the format.

        // And make sure we have it recalc...
        RECT rc;
        GetClientRect(_hwnd, &rc);
        //
        // When the time/locale is changed, we get a WM_WININICHANGE.
        // But the WM_WININICHANGE comes *AFTER* the "sizing" messages. By the time
        // we are here, we have calculated the min. size of the clock window based
        // on the *PREVIOUS* time. The tray sets the clock window size based on 
        // this "previous" size, but NOW we get the WININICHANGE, and can calculate
        // the new size of the clock. So we have to tell the tray to change our 
        // size now, and then redraw ourselves.
        c_tray.SizeWindows();

        ti.cbSize = sizeof(ti);
        ti.uFlags = 0;
        ti.hwnd = v_hwndTray;
        ti.uId = (UINT_PTR)_hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        SendMessage(c_tray.GetTrayTips(), TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);

        _Reset();
    }

    return 0;
}

LRESULT CClockCtl::_OnNeedText(LPTOOLTIPTEXT lpttt)
{
    int iDateFormat = DATE_LONGDATE;

    //
    //  This code is really squirly.  We don't know if the time has been
    //  clipped until we actually try to paint it, since the clip logic
    //  is in the WM_PAINT handler...  Go figure...
    //
    if (!*_szCurTime)
    {
        InvalidateRect(_hwnd, NULL, FALSE);
        UpdateWindow(_hwnd);
    }

    //
    // If the current user locale is any BiDi locale, then
    // Make the date reading order it RTL. SetBiDiDateFlags only adds
    // DATE_RTLREADING if the locale is BiDi. [samera]
    //
    SetBiDiDateFlags(&iDateFormat);

    if (_fClockClipped)
    {
        // we need to put the time in here too
        TCHAR sz[80];
        GetDateFormat(LOCALE_USER_DEFAULT, iDateFormat, NULL, NULL, sz, ARRAYSIZE(sz));
        StringCchPrintf(lpttt->szText, ARRAYSIZE(lpttt->szText), TEXT("%s %s"), _szCurTime, sz);
    }
    else
    {
        GetDateFormat(LOCALE_USER_DEFAULT, iDateFormat, NULL, NULL, lpttt->szText, ARRAYSIZE(lpttt->szText));
    }

    return TRUE;
}

void CClockCtl::_HandleThemeChanged(WPARAM wParam)
{
    if (_hTheme)
    {
        CloseThemeData(_hTheme);
        _hTheme = NULL;
    }

    if (wParam)
    {
        _hTheme = OpenThemeData(_hwnd, L"Clock");
    }
    InvalidateRect(_hwnd, NULL, TRUE);
}

LRESULT CClockCtl::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_CALCMINSIZE:
        return _CalcMinSize((int)wParam, (int)lParam);

    case WM_NCCREATE:
        return _HandleCreate();

    case WM_NCDESTROY:
        return _HandleDestroy();

    case WM_ERASEBKGND:
        return 1;

    case WM_TIMER:
    case WM_PAINT:
        return _DoPaint((uMsg == WM_PAINT));

    case WM_WININICHANGE:
        return _HandleIniChange(wParam, (LPTSTR)lParam);

    case WM_POWER:
        //
        // a critical resume does not generate a WM_POWERBROADCAST
        // to windows for some reason, but it does generate a old
        // WM_POWER message.
        //
        if (wParam != PWR_CRITICALRESUME)
            break;
        // 
        // Fall through...
        //
    case WM_TIMECHANGE:
        return _HandleTimeChange();

    case WM_NCHITTEST:
        return(HTTRANSPARENT);

    case WM_SHOWWINDOW:
        if (wParam)
            break;
        // fall through
    case TCM_RESET:
        _Reset();
        break;

    case WM_NOTIFY:
    {
        NMHDR *pnm = (NMHDR*)lParam;
        switch (pnm->code)
        {
        case TTN_NEEDTEXT:
            return _OnNeedText((LPTOOLTIPTEXT)lParam);
            break;
        }
        break;
    }

    case WM_THEMECHANGED:
        _HandleThemeChanged(wParam);
        break;

    case WM_SETFOCUS:
    case WM_KILLFOCUS:
        _fHasFocus = (uMsg == WM_SETFOCUS);
        InvalidateRect(_hwnd, NULL, TRUE);
        break;

    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_CHAR:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
    case WM_SYSCHAR:
        //
        // forward all keyboard input to parent
        //
        if (SendMessage(GetParent(_hwnd), uMsg, wParam, lParam) == 0)
        {
            // The message has been handled...
            break;
        }
        //
        // else Fall through...
        //

    case WM_GETTEXT:
        //
        // Update the text if we are not running and somebody wants it.
        //
        if (uMsg == WM_GETTEXT)
        {
            if (!_fClockRunning)
                _RecalcCurTime();
        }

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}

// Register the clock class.
BOOL ClockCtl_Class(HINSTANCE hinst)
{
    WNDCLASS wc = {0};

    wc.lpszClassName = WC_TRAYCLOCK;
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = CClockCtl::s_WndProc;
    wc.hInstance = hinst;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.cbWndExtra = sizeof(CClockCtl*);

    return RegisterClass(&wc);
}


HWND ClockCtl_Create(HWND hwndParent, UINT uID, HINSTANCE hInst)
{
    HWND hwnd = NULL;

    CClockCtl* pcc = new CClockCtl();
    if (pcc)
    {
        hwnd = CreateWindowEx(0, WC_TRAYCLOCK,
            NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE, 0, 0, 0, 0,
            hwndParent, IntToPtr_(HMENU, uID), hInst, pcc);

        pcc->Release();
    }
    return hwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\trayclok.h ===
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation 1991-1992
//
// Put a clock in a window.
//---------------------------------------------------------------------------

#define WC_TRAYCLOCK TEXT("TrayClockWClass")

BOOL ClockCtl_Class(HINSTANCE hinst);

HWND ClockCtl_Create(HWND hwndParent, UINT uID, HINSTANCE hInst);

// Message to calculate the minimum size
#define WM_CALCMINSIZE   (WM_USER + 100)
#define TCM_RESET        (WM_USER + 101)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\traycmn.h ===
#ifndef _TRAYCMN_H
#define _TRAYCMN_H

//
// CNotificationItem - encapsulate the data needed to communicate between the tray
// and the tray properties dialog
//
#include <shpriv.h>

typedef struct tagTNPersistStreamData TNPersistStreamData;

class CNotificationItem : public NOTIFYITEM
{
public:
    CNotificationItem();
    CNotificationItem(const NOTIFYITEM& no);
    CNotificationItem(const CNotificationItem& no);
    CNotificationItem(const TNPersistStreamData* ptnpd);

    ~CNotificationItem();

    inline void _Init();
    void _Free();

    const CNotificationItem& operator=(const TNPersistStreamData* ptnpd);
    const CNotificationItem& operator=(const CNotificationItem& ni);
    BOOL operator==(CNotificationItem& ni) const;

    void CopyNotifyItem(const NOTIFYITEM& no, BOOL bInsert = TRUE);    
    void CopyPTNPD(const TNPersistStreamData* ptnpd);

    inline void CopyBuffer(LPCTSTR lpszSrc, LPTSTR * plpszDest);
    inline void SetExeName(LPCTSTR lpszExeName);
    inline void SetIconText(LPCTSTR lpszIconText);
};

#endif // _TRAYCMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\traycmn.cpp ===
#include "traycmn.h"
#include "trayreg.h"

#include "strsafe.h"

//
// CNotificationItem - encapsulate the data needed to communicate between the tray
// and the tray properties dialog
//

CNotificationItem::CNotificationItem()
{
    _Init();
}

CNotificationItem::CNotificationItem(const NOTIFYITEM& no)
{
    _Init();
    CopyNotifyItem(no);
}

CNotificationItem::CNotificationItem(const CNotificationItem& no)
{
    _Init();
    CopyNotifyItem(no);
}

CNotificationItem::CNotificationItem(const TNPersistStreamData* ptnpd)
{
    _Init();
    CopyPTNPD(ptnpd);
}

inline void CNotificationItem::_Init()
{
    hIcon = NULL;
    pszExeName = NULL;
    pszIconText = NULL;
    guidItem = GUID_NULL;
}

void CNotificationItem::CopyNotifyItem(const NOTIFYITEM& no, BOOL bInsert /* = TRUE */)
{
    hWnd            =   no.hWnd;
    uID             =   no.uID;
    if (bInsert)
        dwUserPref      =   no.dwUserPref;
    hIcon           =   CopyIcon(no.hIcon);
    SetExeName(no.pszExeName);
    SetIconText(no.pszIconText);
    memcpy(&guidItem, &(no.guidItem), sizeof(no.guidItem));
}

const CNotificationItem& CNotificationItem::operator=(const TNPersistStreamData* ptnpd)
{
    if (ptnpd)
    {
        _Free();
        _Init();
        CopyPTNPD(ptnpd);
    }            

    return *this;
}

const CNotificationItem& CNotificationItem::operator=(const CNotificationItem& ni)
{
    _Free();
    _Init();
    CopyNotifyItem(ni, FALSE);

    return *this;
}

void CNotificationItem::CopyPTNPD(const TNPersistStreamData* ptnpd)
{
    if (ptnpd)
    {
        hWnd        =   NULL;       // ptnpd's dont have any hWnd
        uID         =   ptnpd->uID;
        dwUserPref  =   ptnpd->dwUserPref;
        hIcon       =   NULL;       // TO DO : Save and load icon 
        SetExeName(ptnpd->szExeName);
        SetIconText(ptnpd->szIconText);
        memcpy(&guidItem, &(ptnpd->guidItem), sizeof(ptnpd->guidItem));
    }
}

inline void CNotificationItem::CopyBuffer(LPCTSTR lpszSrc, LPTSTR * plpszDest)
{
    if (*plpszDest)
    {
        delete[] *plpszDest;
        *plpszDest = NULL;
    }
        
    int nStringLen = (lpszSrc == NULL) ? 0 : lstrlen(lpszSrc);
    if (nStringLen)
    {
        *plpszDest = new TCHAR[(nStringLen+1)];
        if (*plpszDest)
        {
            if (SUCCEEDED(StringCchCopy(*plpszDest, nStringLen+1, lpszSrc)))
                return;
            else
                delete [] *plpszDest;
        }
    }
    *plpszDest = NULL;
}

inline void CNotificationItem::SetExeName(LPCTSTR lpszExeName)
{
    CopyBuffer(lpszExeName, &pszExeName);
}

inline void CNotificationItem::SetIconText(LPCTSTR lpszIconText)
{
    CopyBuffer(lpszIconText, &pszIconText);
}

CNotificationItem::~CNotificationItem()
{
    _Free();
}

void CNotificationItem::_Free()
{
    if (hIcon != NULL)
        DestroyIcon(hIcon);
    if (pszExeName)
        delete [] pszExeName;
    if (pszIconText)
        delete [] pszIconText;
}

BOOL CNotificationItem::operator==(CNotificationItem& ni) const
{
    if (uID == ni.uID)
    {
        if ((hWnd != NULL && hWnd == ni.hWnd) ||
            (hWnd == NULL && pszExeName && lstrcmpi(pszExeName, ni.pszExeName) == 0))
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\tray.cpp ===
#include "cabinet.h"

#include <wtsapi32.h>   // for NOTIFY_FOR_THIS_SESSION
#include <winsta.h>     // for disconnect and reconnect messages from terminal server
#include "mmsysp.h"

#include "rcids.h"
#include "dlg.h"

#include <atlstuff.h>

#include <shlapip.h>
#include "trayclok.h"
#include <help.h>       // help ids
#include <desktray.h>

#include "util.h"
#include "tray.h"

#if defined(FE_IME)
#include <immp.h>
#endif

#include <regstr.h>

#include "bandsite.h"

#include "startmnu.h"
#include "uemapp.h"
#include <uxthemep.h>

#define NO_NOTIFYSUBCLASSWNDPROC
#include "cwndproc.cpp"

#include "desktop2.h"
#include "mixer.h"

#include "strsafe.h"

#define DM_FOCUS        0           // focus
#define DM_SHUTDOWN     TF_TRAY     // shutdown
#define DM_UEMTRACE     TF_TRAY     // timer service, other UEM stuff
#define DM_MISC         0           // miscellany

const GUID CLSID_MSUTBDeskBand = {0x540d8a8b, 0x1c3f, 0x4e32, 0x81, 0x32, 0x53, 0x0f, 0x6a, 0x50, 0x20, 0x90};

// From Desktop2\proglist.cpp
HRESULT AddMenuItemsCacheTask(IShellTaskScheduler* pSystemScheduler, BOOL fKeepCacheWhenFinished);

// import the WIN31 Compatibility HACKs from the shell32.dll
STDAPI_(void) CheckWinIniForAssocs(void);

// hooks to Shell32.dll
STDAPI CheckDiskSpace();
STDAPI CheckStagingArea();

// startmnu.cpp
void HandleFirstTime();

HWND v_hwndDesktop = NULL;
HWND v_hwndTray = NULL;
HWND v_hwndStartPane = NULL;

BOOL g_fDesktopRaised = FALSE;
BOOL g_fInSizeMove = FALSE;

UINT _uMsgEnableUserTrackedBalloonTips = 0;

void ClearRecentDocumentsAndMRUStuff(BOOL fBroadcastChange);
void DoTaskBarProperties(HWND hwnd, DWORD dwFlags);

void ClassFactory_Start();
void ClassFactory_Stop();

//
// Settings UI entry point types.
//
typedef void (WINAPI *PTRAYPROPSHEETCALLBACK)(DWORD nStartPage);
typedef void (WINAPI *PSETTINGSUIENTRY)(PTRAYPROPSHEETCALLBACK);

// Shell perf automation
extern DWORD g_dwShellStartTime;
extern DWORD g_dwShellStopTime;
extern DWORD g_dwStopWatchMode;

CTray c_tray;

// from explorer\desktop2
STDAPI DesktopV2_Create(
    IMenuPopup **ppmp, IMenuBand **ppmb, void **ppvStartPane);
STDAPI DesktopV2_Build(void *pvStartPane);

// dyna-res change for multi-config hot/warm-doc
void HandleDisplayChange(int x, int y, BOOL fCritical);
DWORD GetMinDisplayRes(void);

// timer IDs
#define IDT_AUTOHIDE            2
#define IDT_AUTOUNHIDE          3
#ifdef DELAYWININICHANGE
#define IDT_DELAYWININICHANGE   5
#endif
#define IDT_DESKTOP             6
#define IDT_PROGRAMS            IDM_PROGRAMS
#define IDT_RECENT              IDM_RECENT
#define IDT_REBUILDMENU         7
#define IDT_HANDLEDELAYBOOTSTUFF 8
#define IDT_REVERTPROGRAMS      9
#define IDT_REVERTRECENT        10
#define IDT_REVERTFAVORITES     11

#define IDT_STARTMENU           12

#define IDT_ENDUNHIDEONTRAYNOTIFY 13

#define IDT_SERVICE0            14
#define IDT_SERVICE1            15
#define IDT_SERVICELAST         IDT_SERVICE1
#define IDT_SAVESETTINGS        17
#define IDT_ENABLEUNDO          18
#define IDT_STARTUPFAILED       19
#define IDT_CHECKDISKSPACE      21
#define IDT_STARTBUTTONBALLOON  22
#define IDT_CHANGENOTIFY        23
#define IDT_COFREEUNUSED        24
#define IDT_DESKTOPCLEANUP      25

#define FADEINDELAY             100
#define BALLOONTIPDELAY         10000 // default balloon time copied from traynot.cpp


// INSTRUMENTATION WARNING: If you change anything here, make sure to update instrument.c
// we need to start at 500 because we're now sharing the hotkey handler
// with shortcuts..  they use an index array so they need to be 0 based
// NOTE, this constant is also in desktop.cpp, so that we can forward hotkeys from the desktop for
// NOTE, app compatibility.
#define GHID_FIRST 500
enum
{
    GHID_RUN = GHID_FIRST,
    GHID_MINIMIZEALL,
    GHID_UNMINIMIZEALL,
    GHID_HELP,
    GHID_EXPLORER,
    GHID_FINDFILES,
    GHID_FINDCOMPUTER,
    GHID_TASKTAB,
    GHID_TASKSHIFTTAB,
    GHID_SYSPROPERTIES,
    GHID_DESKTOP,
    GHID_TRAYNOTIFY,
    GHID_MAX
};

const DWORD GlobalKeylist[] =
{
    MAKELONG(TEXT('R'), MOD_WIN),
    MAKELONG(TEXT('M'), MOD_WIN),
    MAKELONG(TEXT('M'), MOD_SHIFT|MOD_WIN),
    MAKELONG(VK_F1,MOD_WIN),
    MAKELONG(TEXT('E'),MOD_WIN),
    MAKELONG(TEXT('F'),MOD_WIN),
    MAKELONG(TEXT('F'), MOD_CONTROL|MOD_WIN),
    MAKELONG(VK_TAB, MOD_WIN),
    MAKELONG(VK_TAB, MOD_WIN|MOD_SHIFT),
    MAKELONG(VK_PAUSE,MOD_WIN),
    MAKELONG(TEXT('D'),MOD_WIN),
    MAKELONG(TEXT('B'),MOD_WIN),
};

CTray::CTray() : _fCanSizeMove(TRUE), _fIsLogoff(FALSE), _fIsDesktopConnected(TRUE)
{
}

void CTray::ClosePopupMenus()
{
    if (_pmpStartMenu)
        _pmpStartMenu->OnSelect(MPOS_FULLCANCEL);
    if (_pmpStartPane)
        _pmpStartPane->OnSelect(MPOS_FULLCANCEL);
}

BOOL Tray_StartPanelEnabled()
{
    SHELLSTATE  ss = {0};
    SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);
    return ss.fStartPanelOn;
}

//
//  The StartButtonBalloonTip registry value can have one of these values:
//
//  0 (or nonexistent): User has never clicked the Start Button.
//  1: User has clicked the Start Button on a pre-Whistler system.
//  2: User has clicked the Start Button on a Whistler system.
//
//  In case 0, we always want to show the balloon tip regardless of whether
//  the user is running Classic or Personal.
//
//  In case 1, we want to show the balloon tip if the user is using the
//  Personal Start Menu, but not if using Classic (since he's already
//  seen the Classic Start Menu).  In the Classic case, upgrade the counter
//  to 2 so the user won't be annoyed when they switch from Classic to
//  Personal.
//
//  In case 2, we don't want to show the balloon tip at all since the
//  user has seen all we have to offer.
//
BOOL CTray::_ShouldWeShowTheStartButtonBalloon()
{
    DWORD dwType;
    DWORD dwData = 0;
    DWORD cbSize = sizeof(DWORD);
    SHGetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, 
            TEXT("StartButtonBalloonTip"), &dwType, (BYTE*)&dwData, &cbSize);

    if (Tray_StartPanelEnabled())
    {
        // Personal Start Menu is enabled, so show the balloon if the
        // user has never logged on to a Whistler machine before.
        return dwData < 2;
    }
    else
    {
        // Classic Start Menu is enabled.
        switch (dwData)
        {
        case 0:
            // User has never seen the Start Menu before, not even the
            // classic one.  So show the tip.
            return TRUE;

        case 1:
            // User has already seen the Classic Start Menu, so don't
            // prompt them again.  Note that this means that they aren't
            // prompted when they turn on the Personal Start Menu, but
            // that's okay, because by the time they switch to Personal,
            // they clearly have demonstrated that they know how the
            // Start Button works and don't need a tip.
            _DontShowTheStartButtonBalloonAnyMore();
            return FALSE;

        default:
            // User has seen Whistler Start menu before, so don't show tip.
            return FALSE;
        }
    }
}

//
//  Set the value to 2 to indicate that the user has seen a Whistler
//  Start Menu (either Classic or Personal).
//
void CTray::_DontShowTheStartButtonBalloonAnyMore()
{
    DWORD dwData = 2;
    SHSetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, 
        TEXT("StartButtonBalloonTip"), REG_DWORD, (BYTE*)&dwData, sizeof(dwData));
}

void CTray::_DestroyStartButtonBalloon()
{
    if (_hwndStartBalloon)
    {
        DestroyWindow(_hwndStartBalloon);
        _hwndStartBalloon = NULL;
    }
    KillTimer(_hwnd, IDT_STARTBUTTONBALLOON);
}

void CTray::CreateStartButtonBalloon(UINT idsTitle, UINT idsMessage)
{
    if (!_hwndStartBalloon)
    {

        _hwndStartBalloon = CreateWindow(TOOLTIPS_CLASS, NULL,
                                             WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
                                             CW_USEDEFAULT, CW_USEDEFAULT,
                                             CW_USEDEFAULT, CW_USEDEFAULT,
                                             _hwnd, NULL, hinstCabinet,
                                             NULL);

        if (_hwndStartBalloon)
        {
            // set the version so we can have non buggy mouse event forwarding
            SendMessage(_hwndStartBalloon, CCM_SETVERSION, COMCTL32_VERSION, 0);
            SendMessage(_hwndStartBalloon, TTM_SETMAXTIPWIDTH, 0, (LPARAM)300);

            // taskbar windows are themed under Taskbar subapp name
            SendMessage(_hwndStartBalloon, TTM_SETWINDOWTHEME, 0, (LPARAM)c_wzTaskbarTheme);

            // Tell the Start Menu that this is a special balloon tip
            SetProp(_hwndStartBalloon, PROP_DV2_BALLOONTIP, DV2_BALLOONTIP_STARTBUTTON);
        }
    }

    if (_hwndStartBalloon)
    {
        TCHAR szTip[MAX_PATH];
        szTip[0] = TEXT('\0');
        LoadString(hinstCabinet, idsMessage, szTip, ARRAYSIZE(szTip));
        if (szTip[0])
        {
            RECT rc;
            TOOLINFO ti = {0};

            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_IDISHWND | TTF_TRACK | TTF_TRANSPARENT;
            ti.hwnd = _hwnd;
            ti.uId = (UINT_PTR)_hwndStart;
            //ti.lpszText = NULL;
            SendMessage(_hwndStartBalloon, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
            SendMessage(_hwndStartBalloon, TTM_TRACKACTIVATE, (WPARAM)FALSE, (LPARAM)0);

            ti.lpszText = szTip;
            SendMessage(_hwndStartBalloon, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);

            LoadString(hinstCabinet, idsTitle, szTip, ARRAYSIZE(szTip));
            if (szTip[0])
            {
                SendMessage(_hwndStartBalloon, TTM_SETTITLE, TTI_INFO, (LPARAM)szTip);
            }

            GetWindowRect(_hwndStart, &rc);

            SendMessage(_hwndStartBalloon, TTM_TRACKPOSITION, 0, MAKELONG((rc.left + rc.right)/2, rc.top));

            SetWindowZorder(_hwndStartBalloon, HWND_TOPMOST);

            SendMessage(_hwndStartBalloon, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&ti);

            SetTimer(_hwnd, IDT_STARTBUTTONBALLOON, BALLOONTIPDELAY, NULL);
        }
    }
}

void CTray::_ShowStartButtonToolTip()
{
    if (!_ShouldWeShowTheStartButtonBalloon() || SHRestricted(REST_NOSMBALLOONTIP))
    {
        PostMessage(_hwnd, TM_SHOWTRAYBALLOON, TRUE, 0);
        return;
    }

    if (Tray_StartPanelEnabled())
    {
        // In order to display the Start Menu, we need foreground activation
        // so keyboard focus will work properly.
        if (SetForegroundWindow(_hwnd))
        {
            // Inform the tray that start button is auto-popping, so the tray
            // can hold off on showing balloons.
            PostMessage(_hwnd, TM_SHOWTRAYBALLOON, FALSE, 0);

            // This pushes the start button and causes the start menu to popup.
            SendMessage(GetDlgItem(_hwnd, IDC_START), BM_SETSTATE, TRUE, 0);

            // Once successfully done once, don't do it again.
            _DontShowTheStartButtonBalloonAnyMore();
        }
    }
    else 
    {
        PostMessage(_hwnd, TM_SHOWTRAYBALLOON, TRUE, 0);
        CreateStartButtonBalloon(IDS_STARTMENUBALLOON_TITLE, IDS_STARTMENUBALLOON_TIP);
    }
}


BOOL CTray::_CreateClockWindow()
{
    _hwndNotify = _trayNotify.TrayNotifyCreate(_hwnd, IDC_CLOCK, hinstCabinet);
    SendMessage(_hwndNotify, TNM_UPDATEVERTICAL, 0, !STUCK_HORIZONTAL(_uStuckPlace));

    return BOOLFROMPTR(_hwndNotify);
}

BOOL CTray::_InitTrayClass()
{
    WNDCLASS wc = {0};

    wc.lpszClassName = TEXT(WNDCLASS_TRAYNOTIFY);
    wc.style = CS_DBLCLKS;
    wc.lpfnWndProc = s_WndProc;
    wc.hInstance = hinstCabinet;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE+1);
    wc.cbWndExtra = sizeof(LONG_PTR);

    return RegisterClass(&wc);
}


HFONT CTray::_CreateStartFont(HWND hwndTray)
{
    HFONT hfontStart = NULL;
    NONCLIENTMETRICS ncm;

    ncm.cbSize = sizeof(ncm);
    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE))
    {
        WORD wLang = GetUserDefaultLangID();

        // Select normal weight font for chinese language.
        if (PRIMARYLANGID(wLang) == LANG_CHINESE &&
           ((SUBLANGID(wLang) == SUBLANG_CHINESE_TRADITIONAL) ||
             (SUBLANGID(wLang) == SUBLANG_CHINESE_SIMPLIFIED)))
            ncm.lfCaptionFont.lfWeight = FW_NORMAL;
        else
            ncm.lfCaptionFont.lfWeight = FW_BOLD;

        hfontStart = CreateFontIndirect(&ncm.lfCaptionFont);
    }

    return hfontStart;
}

// Set the stuck monitor for the tray window
void CTray::_SetStuckMonitor()
{
    // use STICK_LEFT because most of the multi-monitors systems are set up
    // side by side. use DEFAULTTONULL because we don't want to get the wrong one
    // use the center point to call again in case we failed the first time.
    _hmonStuck = MonitorFromRect(&_arStuckRects[STICK_LEFT],
                                     MONITOR_DEFAULTTONULL);
    if (!_hmonStuck)
    {
        POINT pt;
        pt.x = (_arStuckRects[STICK_LEFT].left + _arStuckRects[STICK_LEFT].right)/2;
        pt.y = (_arStuckRects[STICK_LEFT].top + _arStuckRects[STICK_LEFT].bottom)/2;
        _hmonStuck = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
    }

    _hmonOld = _hmonStuck;
}

DWORD _GetDefaultTVSDFlags()
{
    DWORD dwFlags = TVSD_TOPMOST;

    // if we are on a remote hydra session and if there is no previous saved value,
    // do not display the clock.
    if (SHGetMachineInfo(GMI_TSCLIENT))
    {
        dwFlags |= TVSD_HIDECLOCK;
    }
    return dwFlags;
}

void CTray::_GetSaveStateAndInitRects()
{
    TVSDCOMPAT tvsd;
    RECT rcDisplay;
    DWORD dwTrayFlags;
    UINT uStick;
    SIZE size;

    // first fill in the defaults
    SetRect(&rcDisplay, 0, 0, g_cxPrimaryDisplay, g_cyPrimaryDisplay);

    // size gets defaults
    size.cx = _sizeStart.cx + 2 * (g_cxDlgFrame + g_cxBorder);
    size.cy = _sizeStart.cy + 2 * (g_cyDlgFrame + g_cyBorder);

    // sStuckWidths gets minimum
    _sStuckWidths.cx = 2 * (g_cxDlgFrame + g_cxBorder);
    _sStuckWidths.cy = _sizeStart.cy + 2 * (g_cyDlgFrame + g_cyBorder);

    _uStuckPlace = STICK_BOTTOM;
    dwTrayFlags = _GetDefaultTVSDFlags();

    _uAutoHide = 0;

    // now try to load saved vaules
    
    // BUG : 231077
    // Since Tasbar properties don't roam from NT5 to NT4, (NT4 -> NT5 yes) 
    // Allow roaming from NT4 to NT5 only for the first time the User logs
    // on to NT5, so that future changes to NT5 are not lost when the user
    // logs on to NT4 after customizing the taskbar properties on NT5.

    DWORD cbData1 = sizeof(tvsd);
    DWORD cbData2 = sizeof(tvsd);
    if (Reg_GetStruct(g_hkeyExplorer, TEXT("StuckRects2"), TEXT("Settings"), 
        &tvsd, &cbData1) 
        ||
        Reg_GetStruct(g_hkeyExplorer, TEXT("StuckRects"), TEXT("Settings"),
        &tvsd, &cbData2))
    {
        if (IS_CURRENT_TVSD(tvsd.t) && IsValidSTUCKPLACE(tvsd.t.uStuckPlace))
        {
            _GetDisplayRectFromRect(&rcDisplay, &tvsd.t.rcLastStuck,
                MONITOR_DEFAULTTONEAREST);

            size = tvsd.t.sStuckWidths;
            _uStuckPlace = tvsd.t.uStuckPlace;

            dwTrayFlags = tvsd.t.dwFlags;
        }
        else if (MAYBE_WIN95_TVSD(tvsd.w95) &&
                 IsValidSTUCKPLACE(tvsd.w95.uStuckPlace))
        {
            _uStuckPlace = tvsd.w95.uStuckPlace;
            dwTrayFlags = tvsd.w95.dwFlags;
            if (tvsd.w95.uAutoHide & AH_ON)
                dwTrayFlags |= TVSD_AUTOHIDE;

            switch (_uStuckPlace)
            {
            case STICK_LEFT:
                size.cx = tvsd.w95.dxLeft;
                break;

            case STICK_RIGHT:
                size.cx = tvsd.w95.dxRight;
                break;

            case STICK_BOTTOM:
                size.cy = tvsd.w95.dyBottom;
                break;

            case STICK_TOP:
                size.cy = tvsd.w95.dyTop;
                break;
            }
        }
    }
    

    ASSERT(IsValidSTUCKPLACE(_uStuckPlace));

    //
    // use the size only if it is not bogus
    //
    if (_sStuckWidths.cx < size.cx)
        _sStuckWidths.cx = size.cx;

    if (_sStuckWidths.cy < size.cy)
        _sStuckWidths.cy = size.cy;

    //
    // set the tray flags
    //
    _fAlwaysOnTop  = BOOLIFY(dwTrayFlags & TVSD_TOPMOST);
    _fSMSmallIcons = BOOLIFY(dwTrayFlags & TVSD_SMSMALLICONS);
    _fHideClock    = SHRestricted(REST_HIDECLOCK) || BOOLIFY(dwTrayFlags & TVSD_HIDECLOCK);
    _uAutoHide     = (dwTrayFlags & TVSD_AUTOHIDE) ? AH_ON | AH_HIDING : 0;
    _RefreshSettings();

    //
    // initialize stuck rects
    //
    for (uStick = STICK_LEFT; uStick <= STICK_BOTTOM; uStick++)
        _MakeStuckRect(&_arStuckRects[uStick], &rcDisplay, _sStuckWidths, uStick);

    _UpdateVertical(_uStuckPlace);
    // Determine which monitor the tray is on using its stuck rectangles
    _SetStuckMonitor();
}

IBandSite * BandSite_CreateView();
HRESULT BandSite_SaveView(IUnknown *pbs);
LRESULT BandSite_OnMarshallBS(WPARAM wParam, LPARAM lParam);

void CTray::_SaveTrayStuff(void)
{
    TVSD tvsd;

    tvsd.dwSize = sizeof(tvsd);
    tvsd.lSignature = TVSDSIG_CURRENT;

    // position
    CopyRect(&tvsd.rcLastStuck, &_arStuckRects[_uStuckPlace]);
    tvsd.sStuckWidths = _sStuckWidths;
    tvsd.uStuckPlace = _uStuckPlace;

    tvsd.dwFlags = 0;
    if (_fAlwaysOnTop)      tvsd.dwFlags |= TVSD_TOPMOST;
    if (_fSMSmallIcons)     tvsd.dwFlags |= TVSD_SMSMALLICONS;
    if (_fHideClock && !SHRestricted(REST_HIDECLOCK))        tvsd.dwFlags |= TVSD_HIDECLOCK;
    if (_uAutoHide & AH_ON) tvsd.dwFlags |= TVSD_AUTOHIDE;

    // Save in Stuck rects.
    Reg_SetStruct(g_hkeyExplorer, TEXT("StuckRects2"), TEXT("Settings"), &tvsd, sizeof(tvsd));

    BandSite_SaveView(_ptbs);

    return;
}

// align toolbar so that buttons are flush with client area
// and make toolbar's buttons to be MENU style
void CTray::_AlignStartButton()
{
    HWND hwndStart = _hwndStart;
    if (hwndStart)
    {
        TCHAR szStart[50];
        LoadString(hinstCabinet, _hTheme ? IDS_START : IDS_STARTCLASSIC, szStart, ARRAYSIZE(szStart));
        SetWindowText(_hwndStart, szStart);

        RECT rcClient;
        if (!_sizeStart.cx)
        {
            Button_GetIdealSize(hwndStart, &_sizeStart);
        }
        GetClientRect(_hwnd, &rcClient);

        if (rcClient.right < _sizeStart.cx)
        {
            SetWindowText(_hwndStart, L"");
        }

        int cyStart = _sizeStart.cy;

        if (_hwndTasks)
        {
            if (_hTheme)
            {
                cyStart = max(cyStart, SendMessage(_hwndTasks, TBC_BUTTONHEIGHT, 0, 0));
            }
            else
            {
                cyStart = SendMessage(_hwndTasks, TBC_BUTTONHEIGHT, 0, 0);
            }
        }

        SetWindowPos(hwndStart, NULL, 0, 0, min(rcClient.right, _sizeStart.cx),
                     cyStart, SWP_NOZORDER | SWP_NOACTIVATE);
    }
}

//  Helper function for CDesktopHost so clicking twice on the Start Button
//  treats the second click as a dismiss rather than a redisplay.
//
//  The crazy state machine goes like this:
//
//  SBSM_NORMAL - normal state, nothing exciting
//
//  When user opens Start Pane, we become
//
//  SBSM_SPACTIVE - start pane is active
//
//  If user clicks Start Button while SBSM_SPACTIVE, then we become
//
//      SBSM_EATING - eat mouse clicks
//
//      Until we receive a WM_MOUSEFIRST/WM_MOUSELAST message, and then
//      we return to SBSM_NORMAL.
//
//  If user dismisses Start Pane, we go straight to SBSM_NORMAL.
//
//
//      We eat the mouse clicks so that the click that the user made
//      to "unclick" the start button doesn't cause it to get pushed down
//      again (and cause the Start Menu to reopen).
//
#define SBSM_NORMAL         0
#define SBSM_SPACTIVE       1
#define SBSM_EATING         2

void Tray_SetStartPaneActive(BOOL fActive)
{
    if (fActive)
    {   // Start Pane appearing
        c_tray._uStartButtonState = SBSM_SPACTIVE;
    }
    else if (c_tray._uStartButtonState != SBSM_EATING)
    {   // Start Pane dismissing, not eating messages -> return to normal
        c_tray._uStartButtonState = SBSM_NORMAL;
    }
}

// Allow us to do stuff on a "button-down".

LRESULT WINAPI CTray::StartButtonSubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return c_tray._StartButtonSubclassWndProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CTray::_StartButtonSubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet;

    ASSERT(_pfnButtonProc)

    // Is the button going down?
    if (uMsg == BM_SETSTATE)
    {
        // Is it going Down?
        if (wParam) 
        {
            // DebugMsg(DM_TRACE, "c.stswp: Set state %d", wParam);
            // Yes - proceed if it's currently up and it's allowed to be down
            if (!_uDown)
            {
                // Nope.
                INSTRUMENT_STATECHANGE(SHCNFI_STATE_START_DOWN);
                _uDown = 1;

                // If we are going down, then we do not want to popup again until the Start Menu is collapsed
                _fAllowUp = FALSE;

                SendMessage(_hwndTrayTips, TTM_ACTIVATE, FALSE, 0L);

                // Show the button down.
                lRet = CallWindowProc(_pfnButtonProc, hwnd, uMsg, wParam, lParam);
                // Notify the parent.
                SendMessage(GetParent(hwnd), WM_COMMAND, (WPARAM)LOWORD(GetDlgCtrlID(hwnd)), (LPARAM)hwnd);
                _tmOpen = GetTickCount();
                return lRet;
            }
            else
            {
                // Yep. Do nothing.
                // fDown = FALSE;
                return DefWindowProc(hwnd, uMsg, wParam, lParam);
            }
        }
        else
        {
            // DebugMsg(DM_TRACE, "c.stswp: Set state %d", wParam);
            // Nope, buttons coming up.

            // Is it supposed to be down?   Is it not allowed to be up?
            if (_uDown == 1 || !_fAllowUp)
            {
                INSTRUMENT_STATECHANGE(SHCNFI_STATE_START_UP);

                // Yep, do nothing.
                _uDown = 2;
                return DefWindowProc(hwnd, uMsg, wParam, lParam);
            }
            else
            {
                SendMessage(_hwndTrayTips, TTM_ACTIVATE, TRUE, 0L);
                // Nope, Forward it on.
                _uDown = 0;
                return CallWindowProc(_pfnButtonProc, hwnd, uMsg, wParam, lParam);
            }
        }
    }
    else
    {
        if (_uStartButtonState == SBSM_EATING &&
            uMsg >= WM_MOUSEFIRST && uMsg <= WM_MOUSELAST)
        {
            _uStartButtonState = SBSM_NORMAL;

            // Explicitly dismiss the Start Panel because it might be
            // stuck in this limbo state where it is open but not the
            // foreground window (_ShowStartButtonToolTip does this)
            // so it doesn't know that it needs to go away.
            ClosePopupMenus();
        }

        switch (uMsg) {
        case WM_LBUTTONDOWN:
            // The button was clicked on, then we don't need no stink'n focus rect.
            SendMessage(GetParent(hwnd), WM_UPDATEUISTATE, MAKEWPARAM(UIS_SET, 
                UISF_HIDEFOCUS), 0);

            goto ProcessCapture;
            break;


        case WM_KEYDOWN:
            // The user pressed enter or return or some other bogus key combination when
            // the start button had keyboard focus, so show the rect....
            SendMessage(GetParent(hwnd), WM_UPDATEUISTATE, MAKEWPARAM(UIS_CLEAR, 
                UISF_HIDEFOCUS), 0);

            if (wParam == VK_RETURN)
                PostMessage(_hwnd, WM_COMMAND, IDC_KBSTART, 0);

            // We do not need the capture, because we do all of our button processing
            // on the button down. In fact taking capture for no good reason screws with
            // drag and drop into the menus. We're overriding user.
ProcessCapture:
            lRet = CallWindowProc(_pfnButtonProc, hwnd, uMsg, wParam, lParam);
            SetCapture(NULL);
            return lRet;
            break;

        case WM_MOUSEMOVE:
        {
            MSG msg;

            msg.lParam = lParam;
            msg.wParam = wParam;
            msg.message = uMsg;
            msg.hwnd = hwnd;
            SendMessage(_hwndTrayTips, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)& msg);

            break;
        }

        case WM_MOUSEACTIVATE:
            if (_uStartButtonState != SBSM_NORMAL)
            {
                _uStartButtonState = SBSM_EATING;
                return MA_ACTIVATEANDEAT;
            }
            break;

        //
        //  Debounce the Start Button.  Usability shows that lots of people
        //  double-click the Start Button, resulting in the menu opening
        //  and then immediately closing...
        //
        case WM_NCHITTEST:
            if (GetTickCount() - _tmOpen < GetDoubleClickTime())
            {
                return HTNOWHERE;
            }
            break;


        case WM_NULL:
                break;
        }

        return CallWindowProc(_pfnButtonProc, hwnd, uMsg, wParam, lParam);
    }
}

EXTERN_C const WCHAR c_wzTaskbarTheme[] = L"Taskbar";
EXTERN_C const WCHAR c_wzTaskbarVertTheme[] = L"TaskbarVert";

// create the toolbar with the three buttons and align windows

HWND CTray::_CreateStartButton()
{
    DWORD dwStyle = 0;//BS_BITMAP;

    _uStartButtonBalloonTip = RegisterWindowMessage(TEXT("Welcome Finished")); 

    _uLogoffUser = RegisterWindowMessage(TEXT("Logoff User"));

    // Register for MM device changes
    _uWinMM_DeviceChange = RegisterWindowMessage(WINMMDEVICECHANGEMSGSTRING);


    HWND hwnd = CreateWindowEx(0, WC_BUTTON, TEXT("Start"),
        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS |
        BS_PUSHBUTTON | BS_LEFT | BS_VCENTER | dwStyle,
        0, 0, 0, 0, _hwnd, (HMENU)IDC_START, hinstCabinet, NULL);
    if (hwnd)
    {
        // taskbar windows are themed under Taskbar subapp name
        SetWindowTheme(hwnd, L"Start", NULL);

        SendMessage(hwnd, CCM_DPISCALE, TRUE, 0);

        // Subclass it.
        _hwndStart = hwnd;
        _pfnButtonProc = SubclassWindow(hwnd, StartButtonSubclassWndProc);

        _StartButtonReset();
    }
    return hwnd;
}

void CTray::_GetWindowSizes(UINT uStuckPlace, PRECT prcClient, PRECT prcView, PRECT prcNotify)
{
    prcView->top = 0;
    prcView->left = 0;
    prcView->bottom = prcClient->bottom;
    prcView->right = prcClient->right;

    if (STUCK_HORIZONTAL(uStuckPlace))
    {
        DWORD_PTR dwNotifySize = SendMessage(_hwndNotify, WM_CALCMINSIZE, prcClient->right / 2, prcClient->bottom);
        prcNotify->top = 0;
        prcNotify->left = prcClient->right - LOWORD(dwNotifySize);
        prcNotify->bottom = HIWORD(dwNotifySize);
        prcNotify->right = prcClient->right;

        prcView->left = _sizeStart.cx + g_cxFrame + 1;
        prcView->right = prcNotify->left;
    }
    else
    {
        DWORD_PTR dwNotifySize = SendMessage(_hwndNotify, WM_CALCMINSIZE, prcClient->right, prcClient->bottom / 2);
        prcNotify->top = prcClient->bottom - HIWORD(dwNotifySize);
        prcNotify->left = 0;
        prcNotify->bottom = prcClient->bottom;
        prcNotify->right = LOWORD(dwNotifySize);

        prcView->top = _sizeStart.cy + g_cyTabSpace;
        prcView->bottom = prcNotify->top;
    }
}

void CTray::_RestoreWindowPos()
{
    WINDOWPLACEMENT wp;

    //first restore the stuck postitions
    _GetSaveStateAndInitRects();

    wp.length = sizeof(wp);
    wp.showCmd = SW_HIDE;

    _uMoveStuckPlace = (UINT)-1;
    _GetDockedRect(&wp.rcNormalPosition, FALSE);

    SendMessage(_hwndNotify, TNM_TRAYHIDE, 0, _fHideClock);
    SetWindowPlacement(_hwnd, &wp);
}

// Get the display (monitor) rectangle from the given arbitrary point
HMONITOR CTray::_GetDisplayRectFromPoint(LPRECT prcDisplay, POINT pt, UINT uFlags)
{
    RECT rcEmpty = {0};
    HMONITOR hmon = MonitorFromPoint(pt, uFlags);
    if (hmon && prcDisplay)
        GetMonitorRect(hmon, prcDisplay);
    else if (prcDisplay)
        *prcDisplay = rcEmpty;

    return hmon;
}

// Get the display (monitor) rectangle from the given arbitrary rectangle
HMONITOR CTray::_GetDisplayRectFromRect(LPRECT prcDisplay, LPCRECT prcIn, UINT uFlags)
{
    RECT rcEmpty = {0};
    HMONITOR hmon = MonitorFromRect(prcIn, uFlags);
    if (hmon && prcDisplay)
        GetMonitorRect(hmon, prcDisplay);
    else if (prcDisplay)
        *prcDisplay = rcEmpty;

    return hmon;
}

// Get the display (monitor) rectangle where the taskbar is currently on,
// if that monitor is invalid, get the nearest one.
void CTray::_GetStuckDisplayRect(UINT uStuckPlace, LPRECT prcDisplay)
{
    ASSERT(prcDisplay);
    BOOL fValid = GetMonitorRect(_hmonStuck, prcDisplay);

    if (!fValid)
        _GetDisplayRectFromRect(prcDisplay, &_arStuckRects[uStuckPlace], MONITOR_DEFAULTTONEAREST);
}

void CTray::_AdjustRectForSizingBar(UINT uStuckPlace, LPRECT prc, int iIncrement)
{
    if (iIncrement != 0)
    {
        switch (uStuckPlace)
        {
        case STICK_BOTTOM: prc->top -= iIncrement * _sizeSizingBar.cy; break;
        case STICK_TOP:    prc->bottom += iIncrement * _sizeSizingBar.cy;  break;
        case STICK_LEFT:   prc->right += iIncrement * _sizeSizingBar.cx;  break;
        case STICK_RIGHT:  prc->left -= iIncrement * _sizeSizingBar.cx;  break;
        }
    }
    else
    {
        if (IS_BIDI_LOCALIZED_SYSTEM())
        {
            switch (uStuckPlace)
            {
            case STICK_BOTTOM: prc->bottom = prc->top + _sizeSizingBar.cy; break;
            case STICK_TOP:    prc->top = prc->bottom - _sizeSizingBar.cy; break;
            case STICK_LEFT:   prc->right = prc->left + _sizeSizingBar.cx; break;
            case STICK_RIGHT:  prc->left = prc->right - _sizeSizingBar.cx; break;
            }
        }
        else
        {
            switch (uStuckPlace)
            {
            case STICK_BOTTOM: prc->bottom = prc->top + _sizeSizingBar.cy; break;
            case STICK_TOP:    prc->top = prc->bottom - _sizeSizingBar.cy; break;
            case STICK_LEFT:   prc->left = prc->right - _sizeSizingBar.cx; break;
            case STICK_RIGHT:  prc->right = prc->left + _sizeSizingBar.cx; break;
            }
        }
    }
}

// Snap a StuckRect to the edge of a containing rectangle
// fClip determines whether to clip the rectangle if it's off the display or move it onto the screen
void CTray::_MakeStuckRect(LPRECT prcStick, LPCRECT prcBound, SIZE size, UINT uStick)
{
    CopyRect(prcStick, prcBound);

    if (_hTheme && (_fCanSizeMove || _fShowSizingBarAlways))
    {
        _AdjustRectForSizingBar(uStick, prcStick, 1);
    }

    if (!_hTheme)
    {
        InflateRect(prcStick, g_cxEdge, g_cyEdge);
    }

    if (size.cx < 0) size.cx *= -1;
    if (size.cy < 0) size.cy *= -1;

    switch (uStick)
    {
    case STICK_LEFT:   prcStick->right  = (prcStick->left   + size.cx); break;
    case STICK_TOP:    prcStick->bottom = (prcStick->top    + size.cy); break;
    case STICK_RIGHT:  prcStick->left   = (prcStick->right  - size.cx); break;
    case STICK_BOTTOM: prcStick->top    = (prcStick->bottom - size.cy); break;
    }
}

// the screen size has changed, so the docked rectangles need to be
// adjusted to the new screen.
void CTray::_ResizeStuckRects(RECT *arStuckRects)
{
    RECT rcDisplay;
    _GetStuckDisplayRect(_uStuckPlace, &rcDisplay);
    for (UINT uStick = STICK_LEFT; uStick <= STICK_BOTTOM; uStick++)
    {
        _MakeStuckRect(&arStuckRects[uStick], &rcDisplay, _sStuckWidths, uStick);
    }
}


//***   CTray::InvisibleUnhide -- temporary 'invisible' un-autohide
// DESCRIPTION
//  various tray resize routines need the tray to be un-autohide'd for
// stuff to be calculated correctly.  so we un-autohide it (invisibly...)
// here.  note the WM_SETREDRAW to prevent flicker (nt5:182340).
//  note that this is kind of a hack -- ideally the tray code would do
// stuff correctly even if hidden.
//
void CTray::InvisibleUnhide(BOOL fShowWindow)
{
    if (fShowWindow == FALSE)
    {
        if (_cHided++ == 0)
        {
            SendMessage(_hwnd, WM_SETREDRAW, FALSE, 0);
            ShowWindow(_hwnd, SW_HIDE);
            Unhide();
        }
    }
    else
    {
        ASSERT(_cHided > 0);       // must be push/pop
        if (--_cHided == 0)
        {
            _Hide();
            ShowWindow(_hwnd, SW_SHOWNA);
            SendMessage(_hwnd, WM_SETREDRAW, TRUE, 0);
        }
    }
}

void CTray::VerifySize(BOOL fWinIni, BOOL fRoundUp /* = FALSE */)
{
    RECT rc;
    BOOL fHiding;

    fHiding = (_uAutoHide & AH_HIDING);
    if (fHiding)
    {
        // force it visible so various calculations will happen relative
        // to unhidden size/position.
        //
        // fixes (e.g.) ie5:154536, where dropping a large-icon ISFBand
        // onto hidden tray didn't do size negotiation.
        //
        InvisibleUnhide(FALSE);
    }

    rc = _arStuckRects[_uStuckPlace];
    _HandleSizing(0, NULL, _uStuckPlace);

    if (!EqualRect(&rc, &_arStuckRects[_uStuckPlace]))
    {
        if (fWinIni)
        {
            // if we're changing size or position, we need to be unhidden
            Unhide();
            SizeWindows();
        }
        rc = _arStuckRects[_uStuckPlace];

        if (EVAL((_uAutoHide & (AH_ON | AH_HIDING)) != (AH_ON | AH_HIDING)))
        {
            _fSelfSizing = TRUE;
            SetWindowPos(_hwnd, NULL,
                rc.left, rc.top,
                RECTWIDTH(rc),RECTHEIGHT(rc),
                SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS);

            _fSelfSizing = FALSE;
        }

        _StuckTrayChange();
    }

    if (fWinIni)
        SizeWindows();

    if (fHiding)
    {
        InvisibleUnhide(TRUE);
    }
}

HWND CTray::_GetClockWindow(void)
{
    return (HWND)SendMessage(_hwndNotify, TNM_GETCLOCK, 0, 0L);
}

UINT _GetStartIDB()
{
    UINT id;

    if (IsOS(OS_TABLETPC))
    {
        id = IDB_TABLETPCSTARTBKG;
    }
    else if (IsOS(OS_EMBEDDED))
    {
        if (IsOS(OS_ANYSERVER))
            id = IDB_EMBEDDEDSERVER;
        else
            id = IDB_EMBEDDED;
    }
    else if (IsOS(OS_DATACENTER))
    {
        id = IDB_DCSERVERSTARTBKG;
    }
    else if (IsOS(OS_ADVSERVER))
    {
        id = IDB_ADVSERVERSTARTBKG;
    }
    else if (IsOS(OS_SERVER))
    {
        id = IDB_SERVERSTARTBKG;
    }
    else if (IsOS(OS_PERSONAL))
    {
        id = IDB_PERSONALSTARTBKG;
    }
    else if (IsOS(OS_BLADE))
    {
        id = IDB_BLADESTARTBKG;
    }
    else if (IsOS(OS_SMALLBUSINESSSERVER))
    {
        id = IDB_SMALLBUSINESSSTARTBKG;
    }
    else if (IsOS(OS_APPLIANCE))
    {
        id = IDB_APPLIANCESTARTBKG;
    }
    else
    {
#ifdef _WIN64
        id = IDB_PROFESSIONAL64STARTBKG;
#else
        id = IDB_PROFESSIONALSTARTBKG;
#endif
    }

    return id;
}

void CTray::_CreateTrayTips()
{
    _hwndTrayTips = CreateWindowEx(WS_EX_TRANSPARENT, TOOLTIPS_CLASS, NULL,
                                     WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
                                     CW_USEDEFAULT, CW_USEDEFAULT,
                                     CW_USEDEFAULT, CW_USEDEFAULT,
                                     _hwnd, NULL, hinstCabinet,
                                     NULL);

    if (_hwndTrayTips)
    {
        // taskbar windows are themed under Taskbar subapp name
        SendMessage(_hwndTrayTips, TTM_SETWINDOWTHEME, 0, (LPARAM)c_wzTaskbarTheme);

        SetWindowZorder(_hwndTrayTips, HWND_TOPMOST);

        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_IDISHWND | TTF_EXCLUDETOOLAREA;
        ti.hwnd = _hwnd;
        ti.uId = (UINT_PTR)_hwndStart;
        ti.lpszText = (LPTSTR)MAKEINTRESOURCE(IDS_STARTBUTTONTIP);
        ti.hinst = hinstCabinet;
        SendMessage(_hwndTrayTips, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);

        HWND hwndClock = _GetClockWindow();
        if (hwndClock)
        {
            ti.uFlags = TTF_EXCLUDETOOLAREA;
            ti.uId = (UINT_PTR)hwndClock;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.rect.left = ti.rect.top = ti.rect.bottom = ti.rect.right = 0;
            SendMessage(_hwndTrayTips, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
        }
    }
}

#define SHCNE_STAGINGAREANOTIFICATIONS (SHCNE_CREATE | SHCNE_MKDIR | SHCNE_UPDATEDIR | SHCNE_UPDATEITEM)
LRESULT CTray::_CreateWindows()
{
    if (_CreateStartButton() &&  _CreateClockWindow())
    {
        //
        //  We need to set the tray position, before creating
        // the view window, because it will call back our
        // GetWindowRect member functions.
        //
        _RestoreWindowPos();

        _CreateTrayTips();

        SendMessage(_hwndNotify, TNM_HIDECLOCK, 0, _fHideClock);

        _ptbs = BandSite_CreateView();
        if (_ptbs)
        {
            IUnknown_GetWindow(_ptbs, &_hwndRebar);
            SetWindowStyle(_hwndRebar, RBS_BANDBORDERS, FALSE);

            // No need to check the disk space thing for non-privileged users, this reduces activity in the TS case
            // and only admins can properly free disk space anyways.
            if (IsUserAnAdmin() && !SHRestricted(REST_NOLOWDISKSPACECHECKS))
            {
                SetTimer(_hwnd, IDT_CHECKDISKSPACE, 60 * 1000, NULL);   // 60 seconds poll
            }

            if (IsOS(OS_PERSONAL) || IsOS(OS_PROFESSIONAL))
            {
                SetTimer(_hwnd, IDT_DESKTOPCLEANUP, 24 * 60 * 60 * 1000, NULL);   // 24 hour poll
            }

            if (!SHRestricted(REST_NOCDBURNING))
            {
                LPITEMIDLIST pidlStaging;
                if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_CDBURN_AREA | CSIDL_FLAG_CREATE, NULL, 0, &pidlStaging)))
                {
                    SHChangeNotifyEntry fsne;
                    fsne.fRecursive = FALSE;
                    fsne.pidl = pidlStaging;
                    _uNotify = SHChangeNotifyRegister(_hwnd, SHCNRF_NewDelivery | SHCNRF_ShellLevel | SHCNRF_InterruptLevel,
                                                      SHCNE_STAGINGAREANOTIFICATIONS, TM_CHANGENOTIFY, 1, &fsne);

                    // start off by checking the first time.
                    _CheckStagingAreaOnTimer();

                    ILFree(pidlStaging);
                }
            }
            return 1;
        }
    }

    return -1;
}

LRESULT CTray::_InitStartButtonEtc()
{
    // NOTE: This bitmap is used as a flag in CTaskBar::OnPosRectChangeDB to
    // tell when we are done initializing, so we don't resize prematurely
    _hbmpStartBkg = LoadBitmap(hinstCabinet, MAKEINTRESOURCE(_GetStartIDB()));

    if (_hbmpStartBkg)
    {
        UpdateWindow(_hwnd);
        _BuildStartMenu();
        _RegisterDropTargets();

        if (_CheckAssociations())
            CheckWinIniForAssocs();

        SendNotifyMessage(HWND_BROADCAST,
            RegisterWindowMessage(TEXT("TaskbarCreated")), 0, 0);

        return 1;
    }

    return -1;
}

void CTray::_AdjustMinimizedMetrics()
{
    MINIMIZEDMETRICS mm;

    mm.cbSize = sizeof(mm);
    SystemParametersInfo(SPI_GETMINIMIZEDMETRICS, sizeof(mm), &mm, FALSE);
    mm.iArrange |= ARW_HIDE;
    SystemParametersInfo(SPI_SETMINIMIZEDMETRICS, sizeof(mm), &mm, FALSE);
}

void CTray::_UpdateBandSiteStyle()
{
    if (_ptbs)
    {
        BANDSITEINFO bsi;
        bsi.dwMask = BSIM_STYLE;
        _ptbs->GetBandSiteInfo(&bsi);

        BOOL fCanMoveBands = _fCanSizeMove && !SHRestricted(REST_NOMOVINGBAND);

        DWORD dwStyleNew;
        if (fCanMoveBands)
        {
            dwStyleNew = (bsi.dwStyle & ~(BSIS_NOGRIPPER | BSIS_LOCKED)) | BSIS_AUTOGRIPPER
                | BSIS_PREFERNOLINEBREAK;
        }
        else
        {
            dwStyleNew = (bsi.dwStyle & ~BSIS_AUTOGRIPPER) | BSIS_NOGRIPPER | BSIS_LOCKED
                | BSIS_PREFERNOLINEBREAK;
        }

        // only bother with refresh if something's changed
        if (bsi.dwStyle ^ dwStyleNew)
        {
            bsi.dwStyle = dwStyleNew;
            _ptbs->SetBandSiteInfo(&bsi);
            IUnknown_Exec(_ptbs, &CGID_DeskBand, DBID_BANDINFOCHANGED, 0, NULL, NULL);
        }
    }
}

BOOL _IsSizeMoveRestricted()
{
    return SHRegGetBoolUSValue(REGSTR_POLICIES_EXPLORER, TEXT("LockTaskbar"), FALSE, FALSE);
}

BOOL _IsSizeMoveEnabled()
{
    BOOL fCanSizeMove;

    if (_IsSizeMoveRestricted())
    {
        fCanSizeMove = FALSE;
    }
    else
    {
        fCanSizeMove = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("TaskbarSizeMove"), FALSE, TRUE);
    }

    return fCanSizeMove;
}

void CTray::_RefreshSettings()
{
    BOOL fOldCanSizeMove = _fCanSizeMove;
    _fCanSizeMove = _IsSizeMoveEnabled();
    BOOL fOldShowSizingBarAlways = _fShowSizingBarAlways;
    _fShowSizingBarAlways = (_uAutoHide & AH_ON) ? TRUE : FALSE;

    if ((fOldCanSizeMove != _fCanSizeMove) || (_fShowSizingBarAlways != fOldShowSizingBarAlways))
    {
        BOOL fHiding = (_uAutoHide & AH_HIDING);
        if (fHiding)
        {
            InvisibleUnhide(FALSE);
        }

        RECT rc;
        GetWindowRect(_hwnd, &rc);

        if (_hTheme && !_fShowSizingBarAlways)
        {
            if (_fCanSizeMove)
            {
                _AdjustRectForSizingBar(_uStuckPlace, &rc, 1);
            }
            else
            {
                _AdjustRectForSizingBar(_uStuckPlace, &rc, -1);
            }
        }

        _ClipWindow(FALSE);
        _fSelfSizing = TRUE;
        SetWindowPos(_hwnd, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER | SWP_FRAMECHANGED);
        _fSelfSizing = FALSE;
        _ClipWindow(TRUE);

        _arStuckRects[_uStuckPlace] = rc;
        _StuckTrayChange();

        if (fHiding)
        {
            InvisibleUnhide(TRUE);
        }

        if (!_fCanSizeMove)
        {
            SetWindowPos(_hwnd, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER);
        }
    }
}

LRESULT CTray::_OnCreateAsync()
{
    LRESULT lres;

    if (g_dwProfileCAP & 0x00000004)
    {
        StartCAP();
    }

    lres = _InitStartButtonEtc();

    if (g_dwProfileCAP & 0x00000004)
    {
        StopCAP();
    }

    _hMainAccel = LoadAccelerators(hinstCabinet, MAKEINTRESOURCE(ACCEL_TRAY));

    _RegisterGlobalHotkeys();

    // We spin a thread that will process "Load=", "Run=", CU\Run, and CU\RunOnce
    RunStartupApps();

    // If there were any startup failures that occurred before we were
    // ready to handle them, re-raise the failure now that we're ready.
    if (_fEarlyStartupFailure)
        LogFailedStartupApp();

    // we run the tray thread that handles Ctrl-Esc with a high priority
    // class so that it can respond even on a stressed system.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

    return lres;
}

LRESULT CTray::_OnCreate(HWND hwnd)
{
    LRESULT lres = -1;
    v_hwndTray = hwnd;

    Mixer_SetCallbackWindow(hwnd);
    SendMessage(_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);

    _AdjustMinimizedMetrics();

    _hTheme = OpenThemeData(hwnd, c_wzTaskbarTheme);

    _fShowSizingBarAlways = (_uAutoHide & AH_ON) ? TRUE : FALSE;
    if (_hTheme)
    {
        GetThemeBool(_hTheme, 0, 0, TMT_ALWAYSSHOWSIZINGBAR, &_fShowSizingBarAlways);
    }

    SetWindowStyle(_hwnd, WS_BORDER | WS_THICKFRAME, !_hTheme);

    // Force Refresh of frame
    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOSIZE | SWP_NOMOVE);

    if (_HotkeyCreate())
    {
        lres =  _CreateWindows();
    }
    return lres;
}

typedef struct tagFSEPDATA
{
    LPRECT prc;
    HMONITOR hmon;
    CTray* ptray;
}
FSEPDATA, *PFSEPDATA;

BOOL WINAPI CTray::FullScreenEnumProc(HMONITOR hmon, HDC hdc, LPRECT prc, LPARAM dwData)
{
    BOOL fFullScreen;   // Is there a rude app on this monitor?

    PFSEPDATA pd = (PFSEPDATA)dwData;
    if (pd->hmon == hmon)
    {
        fFullScreen = TRUE;
    }
    else if (pd->prc)
    {
        RECT rc, rcMon;
        GetMonitorRect(hmon, &rcMon);
        IntersectRect(&rc, &rcMon, pd->prc);
        fFullScreen = EqualRect(&rc, &rcMon);
    }
    else
    {
        fFullScreen = FALSE;
    }

    if (hmon == pd->ptray->_hmonStuck)
    {
        pd->ptray->_fStuckRudeApp = fFullScreen;
    }

    //
    // Tell all the appbars on the same display to get out of the way too
    //
    pd->ptray->_AppBarNotifyAll(hmon, ABN_FULLSCREENAPP, NULL, fFullScreen);

    return TRUE;
}

void CTray::HandleFullScreenApp(HWND hwnd)
{
    //
    // First check to see if something has actually changed
    //
    _hwndRude = hwnd;

    //
    // Enumerate all the monitors, see if the app is rude on each, adjust
    // app bars and _fStuckRudeApp as necessary.  (Some rude apps, such
    // as the NT Logon Screen Saver, span multiple monitors.)
    //
    FSEPDATA d = {0};
    RECT rc;
    if (hwnd && GetWindowRect(hwnd, &rc))
    {
        d.prc = &rc;
        d.hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONULL);
    }
    d.ptray = this;

    EnumDisplayMonitors(NULL, NULL, FullScreenEnumProc, (LPARAM)&d);

    //
    // Now that we've set _fStuckRudeApp, update the tray's z-order position
    //
    _ResetZorder();

    //
    // stop the clock so we don't eat cycles and keep tons of code paged in
    //
    SendMessage(_hwndNotify, TNM_TRAYHIDE, 0, _fStuckRudeApp);

    //
    // Finally, let traynot know about whether the tray is hiding
    //
    SendMessage(_hwndNotify, TNM_RUDEAPP, _fStuckRudeApp, 0);
}

BOOL CTray::_IsTopmost()
{
    return BOOLIFY(GetWindowLong(_hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST);
}

BOOL CTray::_IsPopupMenuVisible()
{
    HWND hwnd;
    return ((SUCCEEDED(IUnknown_GetWindow(_pmpStartMenu, &hwnd)) && IsWindowVisible(hwnd)) ||
            (SUCCEEDED(IUnknown_GetWindow(_pmpStartPane, &hwnd)) && IsWindowVisible(hwnd)) ||
            (SUCCEEDED(IUnknown_GetWindow(_pmpTasks, &hwnd)) && IsWindowVisible(hwnd)));
}

BOOL CTray::_IsActive()
{
    //
    // We say the tray is "active" iff:
    //
    // (a) the foreground window is the tray or a window owned by the tray, or
    // (b) the start menu is showing
    //

    BOOL fActive = FALSE;
    HWND hwnd = GetForegroundWindow();

    if (hwnd != NULL &&
        (hwnd == _hwnd || (GetWindowOwner(hwnd) == _hwnd)))
    {
        fActive = TRUE;
    }
    else if (_IsPopupMenuVisible())
    {
        fActive = TRUE;
    }

    return fActive;
}

void CTray::_ResetZorder()
{
    HWND hwndZorder, hwndZorderCurrent;

    if (g_fDesktopRaised || _fProcessingDesktopRaise || (_fAlwaysOnTop && !_fStuckRudeApp))
    {
        hwndZorder = HWND_TOPMOST;
    }
    else if (_IsActive())
    {
        hwndZorder = HWND_TOP;
    }
    else if (_fStuckRudeApp)
    {
        hwndZorder = HWND_BOTTOM;
    }
    else
    {
        hwndZorder = HWND_NOTOPMOST;
    }

    //
    // We don't have to worry about the HWND_BOTTOM current case -- it's ok
    // to keep moving ourselves down to the bottom when there's a rude app.
    //
    // Nor do we have to worry about the HWND_TOP current case -- it's ok
    // to keep moving ourselves up to the top when we're active.
    //
    hwndZorderCurrent = _IsTopmost() ? HWND_TOPMOST : HWND_NOTOPMOST;

    if (hwndZorder != hwndZorderCurrent)
    {
        // only do this if somehting has changed.
        // this keeps us from popping up over menus as desktop async
        // notifies us of it's state

        SHForceWindowZorder(_hwnd, hwndZorder);
    }
}

void CTray::_MessageLoop()
{
    for (;;)
    {
        MSG  msg;
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
            {
                if (_hwnd && IsWindow(_hwnd))
                {
                    // Tell the tray to save everything off if we got here
                    // without it being destroyed.
                    SendMessage(_hwnd, WM_ENDSESSION, 1, 0);
                }
                return;  // break all the way out of the main loop
            }

            if (_pmbTasks)
            {
                HRESULT hr = _pmbTasks->IsMenuMessage(&msg);
                if (hr == E_FAIL)
                {
                    if (_hwndTasks)
                        SendMessage(_hwndTasks, TBC_FREEPOPUPMENUS, 0, 0);
                }
                else if (hr == S_OK)
                {
                    continue;
                }
            }

            // Note that this needs to come before _pmbStartMenu since
            // the start pane sometimes hosts the start menu and it needs
            // to handle the start menu messages in that case.
            if (_pmbStartPane &&
                _pmbStartPane->IsMenuMessage(&msg) == S_OK)
            {
                continue;
            }

            if (_pmbStartMenu &&
                _pmbStartMenu->IsMenuMessage(&msg) == S_OK)
            {
                continue;
            }

            if (_hMainAccel && TranslateAccelerator(_hwnd, _hMainAccel, &msg))
            {
                continue;
            }

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        else
        {
            WaitMessage();
        }
    }
}

BOOL CTray::Init()
{
    // use _COINIT to make sure COM is inited disabling the OLE1 support
    return SHCreateThread(MainThreadProc, this, CTF_COINIT, SyncThreadProc) && (_hwnd != NULL);
}

int CTray::_GetPart(BOOL fSizingBar, UINT uStuckPlace)
{
    if (fSizingBar)
    {
        switch (uStuckPlace)
        {
        case STICK_BOTTOM: return TBP_SIZINGBARBOTTOM;
        case STICK_LEFT: return TBP_SIZINGBARLEFT;
        case STICK_TOP: return TBP_SIZINGBARTOP;
        case STICK_RIGHT: return TBP_SIZINGBARRIGHT;
        }
    }
    else
    {
        switch (uStuckPlace)
        {
        case STICK_BOTTOM: return TBP_BACKGROUNDBOTTOM;
        case STICK_LEFT: return TBP_BACKGROUNDLEFT;
        case STICK_TOP: return TBP_BACKGROUNDTOP;
        case STICK_RIGHT: return TBP_BACKGROUNDRIGHT;
        }
    }

    return 0;
}

void CTray::_UpdateVertical(UINT uStuckPlace, BOOL fForce)
{
    static UINT _uOldStuckPlace = STICK_MAX + 1;

    if ((_uOldStuckPlace != uStuckPlace) || fForce)
    {
        _uOldStuckPlace = uStuckPlace;

        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_uv tray is now %s"), STUCK_HORIZONTAL(uStuckPlace) ? TEXT("HORIZONTAL") : TEXT("VERTICAL"));

        if (_ptbs)
        {
            // This following function will cause a WINDOWPOSCHANGING which will call DoneMoving
            // DoneMoving will then go a screw up all of the window sizing
            _fIgnoreDoneMoving = TRUE;  
            BandSite_SetMode(_ptbs, STUCK_HORIZONTAL(uStuckPlace) ? 0 : DBIF_VIEWMODE_VERTICAL);
            BandSite_SetWindowTheme(_ptbs, (LPWSTR)(STUCK_HORIZONTAL(uStuckPlace) ? c_wzTaskbarTheme : c_wzTaskbarVertTheme));
            _fIgnoreDoneMoving = FALSE;  
        }

        SendMessage(_hwndNotify, TNM_UPDATEVERTICAL, 0, !STUCK_HORIZONTAL(uStuckPlace));

        if (_hTheme)
        {
            HDC hdc = GetDC(_hwnd);
            GetThemePartSize(_hTheme, hdc, _GetPart(TRUE, uStuckPlace), 0, NULL, TS_TRUE, &_sizeSizingBar);
            ReleaseDC(_hwnd, hdc);
        }
    }
}

void CTray::_InitBandsite()
{
    ASSERT(_hwnd);

    // we initilize the contents after all the infrastructure is created and sized properly
    // need to notify which side we're on.
    // nt5:211881: set mode *before* load, o.w. Update->RBAutoSize messed up
    _UpdateBandSiteStyle();

    BandSite_Load();
    // now that the mode is set, we need to force an update because we
    // explicitly avoided the update during BandSite_Load
    _UpdateVertical(_uStuckPlace, TRUE);
    BandSite_Update(_ptbs);
    BandSite_UIActivateDBC(_ptbs, DBC_SHOW);

    BandSite_FindBand(_ptbs, CLSID_TaskBand, IID_PPV_ARG(IDeskBand, &_pdbTasks), NULL, NULL);
    IUnknown_GetWindow(_pdbTasks, &_hwndTasks);

    // Now that bandsite is ready, set the correct size
    VerifySize(FALSE, TRUE);
}

void CTray::_KickStartAutohide()
{
    if (_uAutoHide & AH_ON)
    {
        // tray always starts out hidden on autohide
        _uAutoHide = AH_ON | AH_HIDING;

        // we and many apps rely upon us having calculated the size correctly
        Unhide();

        // register it
        if (!_AppBarSetAutoHideBar2(_hwnd, TRUE, _uStuckPlace))
        {
            // don't bother putting up UI in this case
            // if someone is there just silently convert to normal
            // (the shell is booting who would be there anyway?)
            _SetAutoHideState(FALSE);
        }
    }
}

void CTray::_InitNonzeroGlobals()
{
    // initalize globals that need to be non-zero

    if (GetSystemMetrics(SM_SLOWMACHINE))
    {
        _dtSlideHide = 0;       // dont slide the tray out
        _dtSlideShow = 0;
    }
    else
    {
        _dtSlideHide = 400;
        _dtSlideShow = 200;
    }

    _RefreshSettings();
}

void CTray::_CreateTrayWindow()
{
    _InitTrayClass();

    _uMsgEnableUserTrackedBalloonTips = RegisterWindowMessage(ENABLE_BALLOONTIP_MESSAGE);

    _fNoToolbarsOnTaskbarPolicyEnabled = (SHRestricted(REST_NOTOOLBARSONTASKBAR) != 0);

    DWORD dwExStyle = WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW;
    // Don't fadein because layered windows suck
    // If you create a layered window on a non-active desktop then the window goes black
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;

    CreateWindowEx(dwExStyle, TEXT(WNDCLASS_TRAYNOTIFY), NULL,
                   WS_CLIPCHILDREN | WS_POPUP,
                   0, 0, 0, 0, NULL, NULL, hinstCabinet, (void*)this);

}

DWORD WINAPI CTray::SyncThreadProc(void *pv)
{
    CTray* ptray = (CTray*)pv;
    return ptray->_SyncThreadProc();
}

DWORD CTray::_SyncThreadProc()
{
    if (g_dwStopWatchMode)
        StopWatch_StartTimed(SWID_STARTUP, TEXT("_SyncThreadProc"), SPMODE_SHELL | SPMODE_DEBUGOUT, GetPerfTime());

    if (g_dwProfileCAP & 0x00000002)
        StartCAP();


    InitializeCriticalSection(&_csHotkey);

    OleInitialize(NULL);    // matched in MainThreadProc()
    ClassFactory_Start();

    _InitNonzeroGlobals();
    _ssomgr.Init();

    //
    //  Watch the registry key that tells us which app is the default
    //  web browser, so we can track it in
    //  HKLM\Software\Clients\StartMenuInternet.  We have to track it
    //  ourselves because downlevel browsers won't know about it.
    //
    //  We need to do this only if we have write access to the key.
    //  (If we don't have write access, then we can't change it,
    //  so there's no point watching for it to change...)
    //
    //  Well, okay, even if we only have read access, we have to do
    //  it once in case it changed while we were logged off.
    //
    //  The order of these operations is important...
    //
    //      1.  Migrate browser settings.
    //      2.  Build default MFU.  (Depends on browser settings.)
    //      3.  Create tray window.  (Relies on value MFU.)
    //

    _hHTTPEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
    if (_hHTTPEvent)
    {
        //  Make one migration pass immediately so HandleFirstTime
        //  sees good information.  This also kick-starts the
        //  registry change notification process if the current user
        //  has write permission.
        _MigrateOldBrowserSettings();

        if (RegisterWaitForSingleObject(&_hHTTPWait, _hHTTPEvent,
                                        _MigrateOldBrowserSettingsCB, this,
                                        INFINITE, WT_EXECUTEDEFAULT))
        {
            // Yay, everything is fine.
        }
    }

    // Build the default MFU if necessary
    HandleFirstTime();

    _CreateTrayWindow();

    if (_hwnd && _ptbs)
    {
        _ResetZorder(); // obey the "always on top" flag
        _KickStartAutohide();

        _InitBandsite();

        _ClipWindow(TRUE);  // make sure we clip the taskbar to the current monitor before showing it

        // it looks really strange for the tray to pop up and rehide at logon
        // if we are autohide don't activate the tray when we show it
        // if we aren't autohide do what Win95 did (tray is active by default)
        ShowWindow(_hwnd, (_uAutoHide & AH_HIDING) ? SW_SHOWNA : SW_SHOW);

        UpdateWindow(_hwnd);
        _StuckTrayChange();

        // get the system background scheduler thread
        IShellTaskScheduler* pScheduler;
        if (SUCCEEDED(CoCreateInstance(CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC,
                                       IID_PPV_ARG(IShellTaskScheduler, &pScheduler))))
        {
            AddMenuItemsCacheTask(pScheduler, Tray_StartPanelEnabled());
            pScheduler->Release();
        }

        SetTimer(_hwnd, IDT_HANDLEDELAYBOOTSTUFF, 5 * 1000, NULL);
    }

    if (g_dwProfileCAP & 0x00020000)
        StopCAP();

    if (g_dwStopWatchMode)
        StopWatch_StopTimed(SWID_STARTUP, TEXT("_SyncThreadProc"), SPMODE_SHELL | SPMODE_DEBUGOUT, GetPerfTime());

    return FALSE;
}

// the rest of the thread proc that includes the message loop
DWORD WINAPI CTray::MainThreadProc(void *pv)
{
    CTray* ptray = (CTray*)pv;

    if (!ptray->_hwnd)
        return FALSE;

    ptray->_OnCreateAsync();

    PERFSETMARK("ExplorerStartMenuReady");

    ptray->_MessageLoop();

    ClassFactory_Stop();
    OleUninitialize();      // matched in _SyncThreadProc()

    return FALSE;
}

#define DM_IANELHK 0

#define HKIF_NULL               0
#define HKIF_CACHED             1
#define HKIF_FREEPIDLS          2

typedef struct
{
    LPITEMIDLIST pidlFolder;
    LPITEMIDLIST pidlItem;
    WORD wGHotkey;
    WORD wFlags;
} HOTKEYITEM;


UINT CTray::_HotkeyGetFreeItemIndex(void)
{
    int i, cItems;
    HOTKEYITEM *phki;

    ASSERT(IS_VALID_HANDLE(_hdsaHKI, DSA));

    cItems = DSA_GetItemCount(_hdsaHKI);
    for (i=0; i<cItems; i++)
    {
        phki = (HOTKEYITEM *)DSA_GetItemPtr(_hdsaHKI, i);
        if (!phki->wGHotkey)
        {
            ASSERT(!phki->pidlFolder);
            ASSERT(!phki->pidlItem);
            break;
        }
    }
    return i;
}

// Weird, Global hotkeys use different flags for modifiers than window hotkeys
// (and hotkeys returned by the hotkey control)
WORD _MapHotkeyToGlobalHotkey(WORD wHotkey)
{
    UINT nMod = 0;

    // Map the modifiers.
    if (HIBYTE(wHotkey) & HOTKEYF_SHIFT)
        nMod |= MOD_SHIFT;
    if (HIBYTE(wHotkey) & HOTKEYF_CONTROL)
        nMod |= MOD_CONTROL;
    if (HIBYTE(wHotkey) & HOTKEYF_ALT)
        nMod |= MOD_ALT;
    UINT nVirtKey = LOBYTE(wHotkey);
    return (WORD)((nMod*256) + nVirtKey);
}

// NB This takes a regular window hotkey not a global hotkey (it does
// the convertion for you).
int CTray::HotkeyAdd(WORD wHotkey, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem, BOOL fClone)
{
    if (wHotkey)
    {
        LPCITEMIDLIST pidl1, pidl2;

        HOTKEYITEM hki;

        EnterCriticalSection(&_csHotkey);

        int i = _HotkeyGetFreeItemIndex();

        ASSERT(IS_VALID_HANDLE(_hdsaHKI, DSA));

        // DebugMsg(DM_IANELHK, "c.hl_a: Hotkey %x with id %d.", wHotkey, i);

        if (fClone)
        {
            pidl1 = ILClone(pidlFolder);
            pidl2 = ILClone(pidlItem);
            hki.wFlags = HKIF_FREEPIDLS;
        }
        else
        {
            pidl1 = pidlFolder;
            pidl2 = pidlItem;
            hki.wFlags = HKIF_NULL;
        }

        hki.pidlFolder = (LPITEMIDLIST)pidl1;
        hki.pidlItem = (LPITEMIDLIST)pidl2;
        hki.wGHotkey = _MapHotkeyToGlobalHotkey(wHotkey);
        DSA_SetItem(_hdsaHKI, i, &hki);

        LeaveCriticalSection(&_csHotkey);
        return i;
    }

    return -1;
}

// NB Cached hotkeys have their own pidls that need to be free but
// regular hotkeys just keep a pointer to pidls used by the startmenu and
// so don't.
int CTray::_HotkeyAddCached(WORD wGHotkey, LPITEMIDLIST pidl)
{
    int i = -1;

    if (wGHotkey)
    {
        LPITEMIDLIST pidlItem = ILClone(ILFindLastID(pidl));

        ASSERT(IS_VALID_HANDLE(_hdsaHKI, DSA));

        if (pidlItem)
        {
            if (ILRemoveLastID(pidl))
            {
                HOTKEYITEM hki;

                EnterCriticalSection(&_csHotkey);

                i = _HotkeyGetFreeItemIndex();

                // DebugMsg(DM_IANELHK, "c.hl_ac: Hotkey %x with id %d.", wGHotkey, i);

                hki.pidlFolder = pidl;
                hki.pidlItem = pidlItem;
                hki.wGHotkey = wGHotkey;
                hki.wFlags = HKIF_CACHED | HKIF_FREEPIDLS;
                DSA_SetItem(_hdsaHKI, i, &hki);

                LeaveCriticalSection(&_csHotkey);
            }
        }
    }

    return i;
}

// NB Again, this takes window hotkey not a Global one.
// NB This doesn't delete cached hotkeys.
int CTray::_HotkeyRemove(WORD wHotkey)
{
    int iRet = -1;
    if (EVAL(_hdsaHKI))
    {
        int i, cItems;
        HOTKEYITEM *phki;
        WORD wGHotkey;

        ASSERT(IS_VALID_HANDLE(_hdsaHKI, DSA));

        // DebugMsg(DM_IANELHK, "c.hl_r: Remove hotkey for %x" , wHotkey);

        // Unmap the modifiers.
        wGHotkey = _MapHotkeyToGlobalHotkey(wHotkey);
        
        EnterCriticalSection(&_csHotkey);

        cItems = DSA_GetItemCount(_hdsaHKI);
        for (i=0; i<cItems; i++)
        {
            phki = (HOTKEYITEM *)DSA_GetItemPtr(_hdsaHKI, i);
            if (phki && !(phki->wFlags & HKIF_CACHED) && (phki->wGHotkey == wGHotkey))
            {
                // DebugMsg(DM_IANELHK, "c.hl_r: Invalidating %d", i);
                if (phki->wFlags & HKIF_FREEPIDLS)
                {
                    if (phki->pidlFolder)
                        ILFree(phki->pidlFolder);
                    if (phki->pidlItem)
                        ILFree(phki->pidlItem);
                }
                phki->wGHotkey = 0;
                phki->pidlFolder = NULL;
                phki->pidlItem = NULL;
                phki->wFlags &= ~HKIF_FREEPIDLS;
                iRet = i;
                break;
            }
        }
        LeaveCriticalSection(&_csHotkey);
    }

    return iRet;
}

// NB This takes a global hotkey.
int CTray::_HotkeyRemoveCached(WORD wGHotkey)
{
    int iRet = -1;
    int i, cItems;
    HOTKEYITEM *phki;

    ASSERT(IS_VALID_HANDLE(_hdsaHKI, DSA));

    // DebugMsg(DM_IANELHK, "c.hl_rc: Remove hotkey for %x" , wGHotkey);

    EnterCriticalSection(&_csHotkey);

    cItems = DSA_GetItemCount(_hdsaHKI);
    for (i=0; i<cItems; i++)
    {
        phki = (HOTKEYITEM *)DSA_GetItemPtr(_hdsaHKI, i);
        if (phki && (phki->wFlags & HKIF_CACHED) && (phki->wGHotkey == wGHotkey))
        {
            // DebugMsg(DM_IANELHK, "c.hl_r: Invalidating %d", i);
            if (phki->wFlags & HKIF_FREEPIDLS)
            {
                if (phki->pidlFolder)
                    ILFree(phki->pidlFolder);
                if (phki->pidlItem)
                    ILFree(phki->pidlItem);
            }
            phki->pidlFolder = NULL;
            phki->pidlItem = NULL;
            phki->wGHotkey = 0;
            phki->wFlags &= ~(HKIF_CACHED | HKIF_FREEPIDLS);
            iRet = i;
            break;
        }
    }
    LeaveCriticalSection(&_csHotkey);

    return iRet;
}

// NB Some (the ones not marked HKIF_FREEPIDLS) of the items in the list of hotkeys
// have pointers to idlists used by the filemenu so they are only valid for
// the lifetime of the filemenu.
BOOL CTray::_HotkeyCreate(void)
{
    if (!_hdsaHKI)
    {
        // DebugMsg(DM_TRACE, "c.hkl_c: Creating global hotkey list.");
        _hdsaHKI = DSA_Create(sizeof(HOTKEYITEM), 0);
    }

    if (_hdsaHKI)
        return TRUE;

    return FALSE;
}

void CTray::_BuildStartMenu()
{
    HRESULT hr;

    ClosePopupMenus();

    //
    //  Avoid redundant rebuilds: Peek out any pending SBM_REBUILDMENU messages
    //  since the rebuild we're about to do will take care of it.  Do this
    //  before destroying the Start Menu so we never yield while there isn't
    //  a Start Menu.
    //
    MSG msg;
    while (PeekMessage(&msg, _hwnd, SBM_REBUILDMENU, SBM_REBUILDMENU, PM_REMOVE | PM_NOYIELD))
    {
        // Keep sucking them out
    }


    _DestroyStartMenu();

    if (Tray_StartPanelEnabled())
    {
        hr = DesktopV2_Create(&_pmpStartPane, &_pmbStartPane, &_pvStartPane);
        DesktopV2_Build(_pvStartPane);
    }
    else
    {
        hr = StartMenuHost_Create(&_pmpStartMenu, &_pmbStartMenu);
        if (SUCCEEDED(hr))
        {
            IBanneredBar* pbb;

            hr = _pmpStartMenu->QueryInterface(IID_PPV_ARG(IBanneredBar, &pbb));
            if (SUCCEEDED(hr))
            {
                pbb->SetBitmap(_hbmpStartBkg);
                if (_fSMSmallIcons)
                    pbb->SetIconSize(BMICON_SMALL);
                else
                    pbb->SetIconSize(BMICON_LARGE);

                pbb->Release();
            }
        }
    }

    if (FAILED(hr))
    {
        TraceMsg(TF_ERROR, "Could not create StartMenu");
    }
}

void CTray::_DestroyStartMenu()
{
    IUnknown_SetSite(_pmpStartMenu, NULL);
    ATOMICRELEASET(_pmpStartMenu, IMenuPopup);
    ATOMICRELEASET(_pmbStartMenu, IMenuBand);
    IUnknown_SetSite(_pmpStartPane, NULL);
    ATOMICRELEASET(_pmpStartPane, IMenuPopup);
    ATOMICRELEASET(_pmbStartPane, IMenuBand);
    ATOMICRELEASET(_pmpTasks, IMenuPopup);
    ATOMICRELEASET(_pmbTasks, IMenuBand);
}

void CTray::ForceStartButtonUp()
{
    MSG msg;
    // don't do that check message pos because it gets screwy with
    // keyboard cancel.  and besides, we always want it cleared after
    // track menu popup is done.
    // do it twice to be sure it's up due to the _uDown cycling twice in
    // the subclassing stuff
    // pull off any button downs
    PeekMessage(&msg, _hwndStart, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE);
    SendMessage(_hwndStart, BM_SETSTATE, FALSE, 0);
    SendMessage(_hwndStart, BM_SETSTATE, FALSE, 0);

    if (_hwndTasks)
        SendMessage(_hwndTasks, TBC_SETPREVFOCUS, 0, NULL);

    PostMessage(_hwnd, TM_STARTMENUDISMISSED, 0, 0);
}

void Tray_OnStartMenuDismissed()
{
    c_tray._bMainMenuInit = FALSE;
    // Tell the Start Button that it's allowed to be in the up position now. This
    // prevents the problem where the start menu is displayed but the button is
    // in the up position... This happens when dialog boxes are displayed
   c_tray._fAllowUp = TRUE;

    // Now tell it to be in the up position
    c_tray.ForceStartButtonUp();

    PostMessage(v_hwndTray, TM_SHOWTRAYBALLOON, TRUE, 0);
}

int CTray::_TrackMenu(HMENU hmenu)
{
    TPMPARAMS tpm;
    int iret;

    tpm.cbSize = sizeof(tpm);
    GetClientRect(_hwndStart, &tpm.rcExclude);

    RECT rcClient;
    GetClientRect(_hwnd, &rcClient);
    tpm.rcExclude.bottom = min(tpm.rcExclude.bottom, rcClient.bottom);

    MapWindowPoints(_hwndStart, NULL, (LPPOINT)&tpm.rcExclude, 2);

    SendMessage(_hwndTrayTips, TTM_ACTIVATE, FALSE, 0L);
    iret = TrackPopupMenuEx(hmenu, TPM_VERTICAL | TPM_BOTTOMALIGN | TPM_RETURNCMD,
                            tpm.rcExclude.left, tpm.rcExclude.bottom, _hwnd, &tpm);

    SendMessage(_hwndTrayTips, TTM_ACTIVATE, TRUE, 0L);
    return iret;
}

/*------------------------------------------------------------------
** Respond to a button's pressing by bringing up the appropriate menu.
** Clean up the button depression when the menu is dismissed.
**------------------------------------------------------------------*/
void CTray::_ToolbarMenu()
{
    RECTL    rcExclude;
    POINTL   ptPop;
    DWORD dwFlags = MPPF_KEYBOARD;      // Assume that we're popuping
                                        // up because of the keyboard
                                        // This is for the underlines on NT5

    if (_hwndTasks)
        SendMessage(_hwndTasks, TBC_FREEPOPUPMENUS, 0, 0);

    if (_hwndStartBalloon)
    {
        _DontShowTheStartButtonBalloonAnyMore();
        ShowWindow(_hwndStartBalloon, SW_HIDE);
        _DestroyStartButtonBalloon();
    }

    SetActiveWindow(_hwnd);
    _bMainMenuInit = TRUE;

    // Exclude rect is the VISIBLE portion of the Start Button.
    {
        RECT rcParent;
        GetClientRect(_hwndStart, (RECT *)&rcExclude);
        MapWindowRect(_hwndStart, HWND_DESKTOP, &rcExclude);

        GetClientRect(_hwnd, &rcParent);
        MapWindowRect(_hwnd, HWND_DESKTOP, &rcParent);

        IntersectRect((RECT*)&rcExclude, (RECT*)&rcExclude, &rcParent);
    }
    ptPop.x = rcExclude.left;
    ptPop.y = rcExclude.top;

    // Close any Context Menus
    SendMessage(_hwnd, WM_CANCELMODE, 0, 0);

    // Is the "Activate" button down (If the buttons are swapped, then it's the
    // right button, otherwise the left button)
    if (GetKeyState(GetSystemMetrics(SM_SWAPBUTTON)?VK_RBUTTON:VK_LBUTTON) < 0)
    {
        dwFlags = 0;    // Then set to the default
    }

    IMenuPopup **ppmpToDisplay = &_pmpStartMenu;

    if (_pmpStartPane)
    {
        ppmpToDisplay = &_pmpStartPane;
    }

    // Close race window:  The user can click on the Start Button
    // before we get a chance to rebuild the Start Menu in its new
    // form.  In such case, rebuild it now.
    if (!*ppmpToDisplay)
    {
        TraceMsg(TF_WARNING, "e.tbm: Rebuilding Start Menu");
        _BuildStartMenu();
    }


    if (*ppmpToDisplay && SUCCEEDED((*ppmpToDisplay)->Popup(&ptPop, &rcExclude, dwFlags)))
    {
        // All is well - the menu is up
        TraceMsg(DM_MISC, "e.tbm: dwFlags=%x (0=mouse 1=key)", dwFlags);
    }
    else
    {
        TraceMsg(TF_WARNING, "e.tbm: %08x->Popup failed", *ppmpToDisplay);
        // Start Menu failed to display -- reset the Start Button
        // so the user can click it again to try again
        Tray_OnStartMenuDismissed();
    }

    if (dwFlags == MPPF_KEYBOARD)
    {
        // Since the user has launched the start button by Ctrl-Esc, or some other worldly
        // means, then turn the rect on.
        SendMessage(_hwndStart, WM_UPDATEUISTATE, MAKEWPARAM(UIS_CLEAR,
            UISF_HIDEFOCUS), 0);
    }
}


HRESULT CTray::_AppBarSetState(UINT uFlags)
{
    if (uFlags & ~(ABS_AUTOHIDE | ABS_ALWAYSONTOP))
    {
        return E_INVALIDARG;
    }
    else
    {
        _SetAutoHideState(uFlags & ABS_AUTOHIDE);
        _UpdateAlwaysOnTop(uFlags & ABS_ALWAYSONTOP);
        return S_OK;
    }
}

//
// can't use SubtractRect sometimes because of inclusion limitations
//
void CTray::_AppBarSubtractRect(PAPPBAR pab, LPRECT lprc)
{
    switch (pab->uEdge) {
    case ABE_TOP:
        if (pab->rc.bottom > lprc->top)
            lprc->top = pab->rc.bottom;
        break;

    case ABE_LEFT:
        if (pab->rc.right > lprc->left)
            lprc->left = pab->rc.right;
        break;

    case ABE_BOTTOM:
        if (pab->rc.top < lprc->bottom)
            lprc->bottom = pab->rc.top;
        break;

    case ABE_RIGHT:
        if (pab->rc.left < lprc->right)
            lprc->right = pab->rc.left;
        break;
    }
}

void CTray::_AppBarSubtractRects(HMONITOR hmon, LPRECT lprc)
{
    int i;

    if (!_hdpaAppBars)
        return;

    i = DPA_GetPtrCount(_hdpaAppBars);

    while (i--)
    {
        PAPPBAR pab = (PAPPBAR)DPA_GetPtr(_hdpaAppBars, i);

        //
        // autohide bars are not in our DPA or live on the edge
        // don't subtract the appbar if it's on a different display
        // don't subtract the appbar if we are in a locked desktop
        //
        // if (hmon == MonitorFromRect(&pab->rc, MONITOR_DEFAULTTONULL))
        if (hmon == MonitorFromRect(&pab->rc, MONITOR_DEFAULTTONULL) && !_fIsDesktopLocked)
            _AppBarSubtractRect(pab, lprc);
    }
}

#define RWA_NOCHANGE      0
#define RWA_CHANGED       1
#define RWA_BOTTOMMOSTTRAY 2

// (dli) This is a hack put in because bottommost tray is wierd, once
// it becomes a toolbar, this code should go away.
// In the bottommost tray case, even though the work area has not changed,
// we should notify the desktop.
int CTray::_RecomputeWorkArea(HWND hwndCause, HMONITOR hmon, LPRECT prcWork)
{
    int iRet = RWA_NOCHANGE;
    MONITORINFO mi;
    mi.cbSize = sizeof(mi);

    if (_fIsLogoff)
    {
        if (GetMonitorInfo(hmon, &mi))
        {
            *prcWork = mi.rcMonitor;
            iRet = RWA_CHANGED;
        }
        return iRet;
    }

    ASSERT(!_fIsLogoff);

    //
    // tell everybody that this window changed positions _on_this_monitor_
    // note that this notify happens even if we don't change the work area
    // since it may cause another app to change the work area...
    //
    PostMessage(_hwnd, TM_RELAYPOSCHANGED, (WPARAM)hwndCause, (LPARAM)hmon);
    
    //
    // get the current info for this monitor
    // we subtract down from the display rectangle to build the work area
    //
    if (GetMonitorInfo(hmon, &mi))
    {
        //
        // don't subtract the tray if it is autohide
        // don't subtract the tray if it is not always on top
        // don't subtract the tray if it's on a different display
        // don't subtract the tray if it is on a different desktop
        //
        if (!(_uAutoHide & AH_ON) && _fAlwaysOnTop &&
            (hmon == _hmonStuck) && !_fIsDesktopLocked)
        {
            SubtractRect(prcWork, &mi.rcMonitor,
                         &_arStuckRects[_uStuckPlace]);
        }
        else
            *prcWork = mi.rcMonitor;

        //
        // now subtract off all the appbars on this display
        //
       _AppBarSubtractRects(hmon, prcWork);

        //
        // return whether we changed anything
        //
        if (!EqualRect(prcWork, &mi.rcWork))
            iRet = RWA_CHANGED;
        else if (!(_uAutoHide & AH_ON) && (!_fAlwaysOnTop) &&
                 (!IsRectEmpty(&_arStuckRects[_uStuckPlace])))
            // NOTE: This is the bottommost case, it only applies for the tray.
            // this should be taken out when bottommost tray becomes toolbar
            iRet = RWA_BOTTOMMOSTTRAY;
    }
    else
    {
        iRet = RWA_NOCHANGE;
    }
    
    return iRet;
}

void RedrawDesktop(RECT *prcWork)
{
    // This rect point should always be valid (dli)
    RIP(prcWork);
    
    if (v_hwndDesktop && g_fCleanBoot)
    {
        MapWindowRect(NULL, v_hwndDesktop, prcWork);

        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.sac invalidating desktop rect {%d,%d,%d,%d}"), prcWork->left, prcWork->top, prcWork->right, prcWork->bottom);
        RedrawWindow(v_hwndDesktop, prcWork, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
    }
}

void CTray::_StuckAppChange(HWND hwndCause, LPCRECT prcOld, LPCRECT prcNew, BOOL bTray)
{
    RECT rcWork1, rcWork2;
    HMONITOR hmon1, hmon2 = 0;
    int iChange = 0;

    //
    // PERF FEATURE:
    // there are cases where we end up setting the work area multiple times
    // we need to keep a static array of displays that have changed and a
    //  reenter count so we can avoid pain of sending notifies to the whole
    //  planet...
    //
    DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.sac from_AppBar %08X"), hwndCause);

    //
    // see if the work area changed on the display containing prcOld
    //
    if (prcOld)
    {
        if (bTray)
            hmon1 = _hmonOld;
        else
            hmon1 = MonitorFromRect(prcOld, MONITOR_DEFAULTTONEAREST);

        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.sac old pos {%d,%d,%d,%d} on monitor %08X"), prcOld->left, prcOld->top, prcOld->right, prcOld->bottom, hmon1);

        if (hmon1)
        {
            int iret = _RecomputeWorkArea(hwndCause, hmon1, &rcWork1);
            if (iret == RWA_CHANGED)
                iChange = 1;
            if (iret == RWA_BOTTOMMOSTTRAY)
                iChange = 4;
        }
    }
    else
        hmon1 = NULL;

    //
    // see if the work area changed on the display containing prcNew
    //
    if (prcNew)
    {
        hmon2 = MonitorFromRect(prcNew, MONITOR_DEFAULTTONULL);

        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.sac new pos {%d,%d,%d,%d} on monitor %08X"), prcNew->left, prcNew->top, prcNew->right, prcNew->bottom, hmon2);

        if (hmon2 && (hmon2 != hmon1))
        {
            int iret = _RecomputeWorkArea(hwndCause, hmon2, &rcWork2);
            if (iret == RWA_CHANGED)
                iChange |= 2;
            else if (iret == RWA_BOTTOMMOSTTRAY && (!iChange))
                iChange = 4;
        }
    }

    //
    // did the prcOld's display's work area change?
    //
    if (iChange & 1)
    {
        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.sac changing work area for monitor %08X"), hmon1);

        // only send SENDWININICHANGE if the desktop has been created (otherwise
        // we will hang the explorer because the main thread is currently blocked)
        SystemParametersInfo(SPI_SETWORKAREA, TRUE, &rcWork1,
                             (iChange == 1 && v_hwndDesktop)? SPIF_SENDWININICHANGE : 0);

        RedrawDesktop(&rcWork1);
    }

    //
    // did the prcOld's display's work area change?
    //
    if (iChange & 2)
    {
        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.sac changing work area for monitor %08X"), hmon2);

        // only send SENDWININICHANGE if the desktop has been created (otherwise
        // we will hang the explorer because the main thread is currently blocked)
        SystemParametersInfo(SPI_SETWORKAREA, TRUE, &rcWork2,
                             v_hwndDesktop ? SPIF_SENDWININICHANGE : 0);

        RedrawDesktop(&rcWork2);
    }

    // only send if the desktop has been created...
    // need to send if it's from the tray or any outside app that causes size change
    // from the tray because autohideness will affect desktop size even if it's not always on top
    if ((bTray || iChange == 4) && v_hwndDesktop)
        SendMessage(v_hwndDesktop, WM_SIZE, 0, 0);
}

void CTray::_StuckTrayChange()
{
    // We used to blow off the _StuckAppChange when the tray was in autohide
    // mode, since moving or resizing an autohid tray doesn't change the
    // work area.  Now we go ahead with the _StuckAppChange in this case
    // too.  The reason is that we can get into a state where the work area
    // size is incorrect, and we want the taskbar to always be self-repairing
    // in this case (so that resizing or moving the taskbar will correct the
    // work area size).

    //
    // pass a NULL window here since we don't want to hand out our window and
    // the tray doesn't get these anyway (nobody cares as long as its not them)
    //
    _StuckAppChange(NULL, &_rcOldTray,
        &_arStuckRects[_uStuckPlace], TRUE);

    //
    // save off the new tray position...
    //
    _rcOldTray = _arStuckRects[_uStuckPlace];
}

UINT CTray::_RecalcStuckPos(LPRECT prc)
{
    RECT rcDummy;
    POINT pt;

    if (!prc)
    {
        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_rsp no rect supplied, using window rect"));

        prc = &rcDummy;
        GetWindowRect(_hwnd, prc);
    }

    // use the center of the original drag rect as a staring point
    pt.x = prc->left + RECTWIDTH(*prc) / 2;
    pt.y = prc->top + RECTHEIGHT(*prc) / 2;

    DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_rsp rect is {%d, %d, %d, %d} point is {%d, %d}"), prc->left, prc->top, prc->right, prc->bottom, pt.x, pt.y);

    // reset this so the drag code won't give it preference
    _uMoveStuckPlace = (UINT)-1;

    // simulate a drag back to figure out where we originated from
    // you may be tempted to remove this.  before you do think about dragging
    // the tray across monitors and then hitting ESC...
    return _CalcDragPlace(pt);
}

/*------------------------------------------------------------------
** the position is changing in response to a move operation.
**
** if the docking status changed, we need to get a new size and
** maybe a new frame style.  change the WINDOWPOS to reflect
** these changes accordingly.
**------------------------------------------------------------------*/
void CTray::_DoneMoving(LPWINDOWPOS lpwp)
{
    RECT rc, *prc;

    if ((_uMoveStuckPlace == (UINT)-1) || (_fIgnoreDoneMoving))
        return;

    if (_fSysSizing)
        _fDeferedPosRectChange = TRUE;

    rc.left   = lpwp->x;
    rc.top    = lpwp->y;
    rc.right  = lpwp->x + lpwp->cx;
    rc.bottom = lpwp->y + lpwp->cy;

    prc = &_arStuckRects[_uMoveStuckPlace];

    if (!EqualRect(prc, &rc))
    {
        _uMoveStuckPlace = _RecalcStuckPos(&rc);
        prc = &_arStuckRects[_uMoveStuckPlace];
    }

    // Get the new hmonitor
    _hmonStuck = MonitorFromRect(prc, MONITOR_DEFAULTTONEAREST);

    lpwp->x = prc->left;
    lpwp->y = prc->top;
    lpwp->cx = RECTWIDTH(*prc);
    lpwp->cy = RECTHEIGHT(*prc);

    lpwp->flags &= ~(SWP_NOMOVE | SWP_NOSIZE);

    // if we were autohiding, we need to update our appbar autohide rect
    if (_uAutoHide & AH_ON)
    {
        // unregister us from the old side
        _AppBarSetAutoHideBar2(_hwnd, FALSE, _uStuckPlace);
    }

    // All that work might've changed _uMoveStuckPlace (since there
    // was a lot of message traffic), so check one more time.
    // Somehow, NT Stress manages to get us in here with an invalid
    // uMoveStuckPlace.
    if (IsValidSTUCKPLACE(_uMoveStuckPlace))
    {
        // remember the new state
        _uStuckPlace = _uMoveStuckPlace;
    }
    _uMoveStuckPlace = (UINT)-1;
    _UpdateVertical(_uStuckPlace);

    _HandleSizing(0, prc, _uStuckPlace);
    if ((_uAutoHide & AH_ON) &&
        !_AppBarSetAutoHideBar2(_hwnd, TRUE, _uStuckPlace))
    {
        _AutoHideCollision();
    }
}

UINT CTray::_CalcDragPlace(POINT pt)
{
    UINT uPlace = _uMoveStuckPlace;

    DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_cdp starting point is {%d, %d}"), pt.x, pt.y);

    //
    // if the mouse is currently over the tray position leave it alone
    //
    if ((uPlace == (UINT)-1) || !PtInRect(&_arStuckRects[uPlace], pt))
    {
        HMONITOR hmonDrag;
        SIZE screen, error;
        UINT uHorzEdge, uVertEdge;
        RECT rcDisplay, *prcStick;

        //
        // which display is the mouse on?
        //
        hmonDrag = _GetDisplayRectFromPoint(&rcDisplay, pt,
            MONITOR_DEFAULTTOPRIMARY);

        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_cdp monitor is %08X"), hmonDrag);

        //
        // re-origin at zero to make calculations simpler
        //
        screen.cx =  RECTWIDTH(rcDisplay);
        screen.cy = RECTHEIGHT(rcDisplay);
        pt.x -= rcDisplay.left;
        pt.y -= rcDisplay.top;

        //
        // are we closer to the left or right side of this display?
        //
        if (pt.x < (screen.cx / 2))
        {
            uVertEdge = STICK_LEFT;
            error.cx = pt.x;
        }
        else
        {
            uVertEdge = STICK_RIGHT;
            error.cx = screen.cx - pt.x;
        }

        //
        // are we closer to the top or bottom side of this display?
        //
        if (pt.y < (screen.cy / 2))
        {
            uHorzEdge = STICK_TOP;
            error.cy = pt.y;
        }
        else
        {
            uHorzEdge = STICK_BOTTOM;
            error.cy = screen.cy - pt.y;
        }

        //
        // closer to a horizontal or vertical edge?
        //
        uPlace = ((error.cy * screen.cx) > (error.cx * screen.cy))?
            uVertEdge : uHorzEdge;

        // which StuckRect should we use?
        prcStick = &_arStuckRects[uPlace];

        //
        // need to recalc stuck rect for new monitor?
        //
        if ((hmonDrag != _GetDisplayRectFromRect(NULL, prcStick,
            MONITOR_DEFAULTTONULL)))
        {
            DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_cdp re-snapping rect for new display"));
            _MakeStuckRect(prcStick, &rcDisplay, _sStuckWidths, uPlace);
        }
    }

    DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_cdp edge is %d, rect is {%d, %d, %d, %d}"), uPlace, _arStuckRects[uPlace].left, _arStuckRects[uPlace].top, _arStuckRects[uPlace].right, _arStuckRects[uPlace].bottom);
    ASSERT(IsValidSTUCKPLACE(uPlace));
    return uPlace;
}

void CTray::_HandleMoving(WPARAM wParam, LPRECT lprc)
{
    POINT ptCursor;
    GetCursorPos(&ptCursor);

    // If the cursor is not far from its starting point, then ignore it.
    // A very common problem is the user clicks near the corner of the clock,
    // twitches the mouse 5 pixels, and BLAM, their taskbar is now vertical
    // and they don't know what they did or how to get it back.

    if (g_fInSizeMove && PtInRect(&_rcSizeMoveIgnore, ptCursor))
    {
        // Ignore -- user is merely twitching
        _uMoveStuckPlace = _uStuckPlace;
    }
    else
    {
        _uMoveStuckPlace = _CalcDragPlace(ptCursor);
    }

    *lprc = _arStuckRects[_uMoveStuckPlace];
    _HandleSizing(wParam, lprc, _uMoveStuckPlace);
}

// store the tray size when dragging is finished
void CTray::_SnapshotStuckRectSize(UINT uPlace)
{
    RECT rcDisplay, *prc = &_arStuckRects[uPlace];

    //
    // record the width of this stuck rect
    //
    if (STUCK_HORIZONTAL(uPlace))
        _sStuckWidths.cy = RECTHEIGHT(*prc);
    else
        _sStuckWidths.cx = RECTWIDTH(*prc);

    //
    // we only present a horizontal or vertical size to the end user
    // so update the StuckRect on the other side of the screen to match
    //
    _GetStuckDisplayRect(uPlace, &rcDisplay);

    uPlace += 2;
    uPlace %= 4;
    prc = &_arStuckRects[uPlace];

    _MakeStuckRect(prc, &rcDisplay, _sStuckWidths, uPlace);
}


// Size the icon area to fill as much of the tray window as it can.

void CTray::SizeWindows()
{
    RECT rcView, rcNotify, rcClient;
    int fHiding;

    if (!_hwndRebar || !_hwnd || !_hwndNotify)
        return;

    fHiding = (_uAutoHide & AH_HIDING);
    if (fHiding)
    {
        InvisibleUnhide(FALSE);
    }

    // remember our current size
    _SnapshotStuckRectSize(_uStuckPlace);

    GetClientRect(_hwnd, &rcClient);
    _AlignStartButton();

    _GetWindowSizes(_uStuckPlace, &rcClient, &rcView, &rcNotify);

    InvalidateRect(_hwndStart, NULL, TRUE);
    InvalidateRect(_hwnd, NULL, TRUE);

    // position the view
    SetWindowPos(_hwndRebar, NULL, rcView.left, rcView.top,
                 RECTWIDTH(rcView), RECTHEIGHT(rcView),
                 SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS);
    UpdateWindow(_hwndRebar);

    // And the clock
    SetWindowPos(_hwndNotify, NULL, rcNotify.left, rcNotify.top,
                 RECTWIDTH(rcNotify), RECTHEIGHT(rcNotify),
                 SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS);

    {
        TOOLINFO ti;
        HWND hwndClock = _GetClockWindow();

        ti.cbSize = sizeof(ti);
        ti.uFlags = 0;
        ti.hwnd = _hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        ti.uId = (UINT_PTR)hwndClock;
        GetWindowRect(hwndClock, &ti.rect);
        MapWindowPoints(HWND_DESKTOP, _hwnd, (LPPOINT)&ti.rect, 2);
        SendMessage(_hwndTrayTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
    }

    if (fHiding)
    {
        InvisibleUnhide(TRUE);
    }
}


void CTray::_HandleSize()
{
    //
    // if somehow we got minimized go ahead and un-minimize
    //
    if (((GetWindowLong(_hwnd, GWL_STYLE)) & WS_MINIMIZE))
    {
        ASSERT(FALSE);
        ShowWindow(_hwnd, SW_RESTORE);
    }

    //
    // if we are in the move/size loop and are visible then
    // re-snap the current stuck rect to the new window size
    //
#ifdef DEBUG
    if (_fSysSizing && (_uAutoHide & AH_HIDING)) {
        TraceMsg(DM_TRACE, "fSysSize && hiding");
        ASSERT(0);
    }
#endif
    if (_fSysSizing &&
        ((_uAutoHide & (AH_ON | AH_HIDING)) != (AH_ON | AH_HIDING)))
    {
        _uStuckPlace = _RecalcStuckPos(NULL);
        _UpdateVertical(_uStuckPlace);
    }

    //
    // if we are in fulldrag or we are not in the middle of a move/size then
    // we should resize all our child windows to reflect our new size
    //
    if (g_fDragFullWindows || !_fSysSizing)
        SizeWindows();

    //
    // if we are just plain resized and we are visible we may need re-dock
    //
    if (!_fSysSizing && !_fSelfSizing && IsWindowVisible(_hwnd))
    {
        if (_uAutoHide & AH_ON)
        {
            UINT uPlace = _uStuckPlace;
            HWND hwndOther =_AppBarGetAutoHideBar(uPlace);

            //
            // we sometimes defer checking for this until after a move
            // so as to avoid interrupting a full-window-drag in progress
            // if there is a different autohide window in our slot then whimper
            //
            if (hwndOther?
                (hwndOther != _hwnd) :
                !_AppBarSetAutoHideBar2(_hwnd, TRUE, uPlace))
            {
                _AutoHideCollision();
            }
        }

        _StuckTrayChange();

        //
        // make sure we clip to tray to the current monitor (if necessary)
        //
        _ClipWindow(TRUE);
    }

    if (_hwndStartBalloon)
    {
        RECT rc;
        GetWindowRect(_hwndStart, &rc);
        SendMessage(_hwndStartBalloon, TTM_TRACKPOSITION, 0, MAKELONG((rc.left + rc.right)/2, rc.top));
        SetWindowZorder(_hwndStartBalloon, HWND_TOPMOST);
    }
}

BOOL _IsSliverHeight(int cy)
{
    //
    // Is this height clearly bigger than the pure-border height that you
    // get when you resize the taskbar as small as it will go?
    //
    return (cy < (3 * (g_cyDlgFrame + g_cyBorder)));
}

BOOL CTray::_HandleSizing(WPARAM code, LPRECT lprc, UINT uStuckPlace)
{
    BOOL fChangedSize = FALSE;
    RECT rcDisplay;
    SIZE sNewWidths;
    RECT rcTemp;
    BOOL fHiding;

    if (!lprc)
    {
        rcTemp = _arStuckRects[uStuckPlace];
        lprc = &rcTemp;
    }

    fHiding = (_uAutoHide & AH_HIDING);
    if (fHiding)
    {
        InvisibleUnhide(FALSE);
    }

    //
    // get the a bunch of relevant dimensions
    //
    // (dli) need to change this funciton or get rid of it
    _GetDisplayRectFromRect(&rcDisplay, lprc, MONITOR_DEFAULTTONEAREST);

    if (code)
    {
        // if code != 0, this is the user sizing.
        // make sure they clip it to the screen.
        RECT rcMax = rcDisplay;
        if (!_hTheme)
        {
            InflateRect(&rcMax, g_cxEdge, g_cyEdge);
        }
        // don't do intersect rect because of sizing up from the bottom 
        // (when taskbar docked on bottom) confuses people
        switch (uStuckPlace)
        {
            case STICK_LEFT:   
                lprc->left = rcMax.left; 
                break;

            case STICK_TOP:    
                lprc->top = rcMax.top; 
                break;

            case STICK_RIGHT:  
                lprc->right = rcMax.right; 
                break;

            case STICK_BOTTOM: 
                lprc->top += (rcMax.bottom-lprc->bottom);
                lprc->bottom = rcMax.bottom; 
                break;
        }
    }

    //
    // compute the new widths
    // don't let either be more than half the screen
    //
    sNewWidths.cx = min(RECTWIDTH(*lprc), RECTWIDTH(rcDisplay) / 2);
    sNewWidths.cy = min(RECTHEIGHT(*lprc), RECTHEIGHT(rcDisplay) / 2);

    if (_hTheme && (_fCanSizeMove || _fShowSizingBarAlways))
    {
        sNewWidths.cy = max(_sizeSizingBar.cy, sNewWidths.cy);
    }

    //
    // compute an initial size
    //
    _MakeStuckRect(lprc, &rcDisplay, sNewWidths, uStuckPlace);
    DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_hs starting rect is {%d, %d, %d, %d}"), lprc->left, lprc->top, lprc->right, lprc->bottom);

    //
    // negotiate the exact size with our children
    //
    DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_hs tray is being calculated for %s"), STUCK_HORIZONTAL(uStuckPlace) ? TEXT("HORIZONTAL") : TEXT("VERTICAL"));

    _UpdateVertical(uStuckPlace);
    if (_ptbs)
    {
        IDeskBarClient* pdbc;
        if (SUCCEEDED(_ptbs->QueryInterface(IID_PPV_ARG(IDeskBarClient, &pdbc))))
        {
            RECT rcClient = *lprc;
            RECT rcOldClient = _arStuckRects[uStuckPlace];

            // Go from a Window Rect to Client Rect
            if (_hTheme && (_fCanSizeMove || _fShowSizingBarAlways))
            {
                _AdjustRectForSizingBar(uStuckPlace, &rcClient, -1);
                _AdjustRectForSizingBar(uStuckPlace, &rcOldClient, -1);
            }
            else if (!_hTheme)
            {
                InflateRect(&rcClient, -g_cxFrame, -g_cyFrame);
                InflateRect(&rcOldClient, -g_cxFrame, -g_cyFrame);
            }
            // Make rcClient start at 0,0, Rebar only used the right and bottom values of this rect
            OffsetRect(&rcClient, -rcClient.left, -rcClient.top);
            OffsetRect(&rcOldClient, -rcOldClient.left, -rcOldClient.top);
            DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_hs starting client rect is {%d, %d, %d, %d}"), rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);

            RECT rcNotify;
            RECT rcView;
            RECT rcOldView;
            // Go from the taskbar's client rect to the rebar's client rect
            _GetWindowSizes(uStuckPlace, &rcClient, &rcView, &rcNotify);
            _GetWindowSizes(uStuckPlace, &rcOldClient, &rcOldView, &rcNotify);
            // Make rcView start at 0,0, Rebar only used the right and bottom values of this rect
            OffsetRect(&rcView, -rcView.left, -rcView.top);
            OffsetRect(&rcOldView, -rcOldView.left, -rcOldView.top);
            if (!_fCanSizeMove || (RECTHEIGHT(rcView) && RECTWIDTH(rcView)))
            {
                // This following function will cause a WINDOWPOSCHAGING which will call DoneMoving
                // DoneMoving will then go a screw up all of the window sizing
                _fIgnoreDoneMoving = TRUE;  
                pdbc->GetSize(DBC_GS_SIZEDOWN, &rcView);
                _fIgnoreDoneMoving = FALSE;
            }

            // Go from a Client Rect to Window Rect
            if (STUCK_HORIZONTAL(uStuckPlace))
            {
                rcClient.top = rcView.top;
                rcClient.bottom = rcView.bottom;
            }
            else
            {
                rcClient.left = rcView.left;
                rcClient.right = rcView.right;
            }

            DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_hs ending client rect is {%d, %d, %d, %d}"), rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);
            if (_hTheme && (_fCanSizeMove || _fShowSizingBarAlways))
            {
                _AdjustRectForSizingBar(uStuckPlace, &rcClient, 1);
                _AdjustRectForSizingBar(uStuckPlace, &rcOldClient, 1);
            }
            else if (!_hTheme)
            {
                InflateRect(&rcClient, g_cxFrame, g_cyFrame);
                InflateRect(&rcOldClient, g_cxFrame, g_cyFrame);
            }

            // Prevent huge growth of taskbar, caused by bugs in the rebar sizing code
            if (RECTHEIGHT(rcView) && RECTHEIGHT(rcOldView) && (RECTHEIGHT(rcClient) > (3 * RECTHEIGHT(rcOldClient))))
            {
                rcClient = rcOldClient;
            }

            if (STUCK_HORIZONTAL(uStuckPlace) && sNewWidths.cy != RECTHEIGHT(rcClient))
            {
                sNewWidths.cy = RECTHEIGHT(rcClient);
                fChangedSize = TRUE;
            }
            if (!STUCK_HORIZONTAL(uStuckPlace) && sNewWidths.cx != RECTWIDTH(rcClient))
            {
                sNewWidths.cx = RECTWIDTH(rcClient);
                fChangedSize = TRUE;
            }

            pdbc->Release();
        }
    }


    //
    // was there a change?
    //
    if (fChangedSize)
    {
        //
        // yes, update the final rectangle
        //
        _MakeStuckRect(lprc, &rcDisplay, sNewWidths, uStuckPlace);
    }

    DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_hs final rect is {%d, %d, %d, %d}"), lprc->left, lprc->top, lprc->right, lprc->bottom);

    //
    // store the new size in the appropriate StuckRect
    //
    _arStuckRects[uStuckPlace] = *lprc;

    if (fHiding)
    {
        InvisibleUnhide(TRUE);
    }

    if (_hwndStartBalloon)
    {
        RECT rc;
        GetWindowRect(_hwndStart, &rc);
        SendMessage(_hwndStartBalloon, TTM_TRACKPOSITION, 0, MAKELONG((rc.left + rc.right)/2, rc.top));
        SetWindowZorder(_hwndStartBalloon, HWND_TOPMOST);
    }

    return fChangedSize;
}

/*-------------------------------------------------------------------
** the screen size changed, and we need to adjust some stuff, mostly
** globals.  if the tray was docked, it needs to be resized, too.
**
** TRICKINESS: the handling of WM_WINDOWPOSCHANGING is used to
** actually do all the real sizing work.  this saves a bit of
** extra code here.
**-------------------------------------------------------------------*/

BOOL WINAPI CTray::MonitorEnumProc(HMONITOR hMonitor, HDC hdc, LPRECT lprc, LPARAM lData)
{
    CTray* ptray = (CTray*)lData;

    RECT rcWork;
    int iRet = ptray->_RecomputeWorkArea(NULL, hMonitor, &rcWork);

    if (iRet == RWA_CHANGED)
    {
        // only send SENDWININICHANGE if the desktop has been created (otherwise
        // we will hang the explorer because the main thread is currently blocked)

        // PERF FEATURE: it will be nice to send WININICHANGE only once, but we can't
        // because each time the rcWork is different, and there is no way to do it all
        SystemParametersInfo(SPI_SETWORKAREA, TRUE, &rcWork, v_hwndDesktop ? SPIF_SENDWININICHANGE : 0);
        RedrawDesktop(&rcWork);
    }

    return TRUE;
}

void CTray::_RecomputeAllWorkareas()
{
    EnumDisplayMonitors(NULL, NULL, MonitorEnumProc, (LPARAM)this);
}

void CTray::_ScreenSizeChange(HWND hwnd)
{
    // Set our new HMONITOR in case there is some change
    {
        MONITORINFO mi = {0};
        mi.cbSize = sizeof(mi);

        // Is our old HMONITOR still valid?
        // NOTE: This test is used to tell whether somethings happened to the
        // HMONITOR's or just the screen size changed
        if (!GetMonitorInfo(_hmonStuck, &mi))
        {
            // No, this means the HMONITORS changed, our monitor might have gone away
            _SetStuckMonitor();
            _fIsLogoff = FALSE;
            _RecomputeAllWorkareas();
        }
    }

    // screen size changed, so we need to adjust globals
    g_cxPrimaryDisplay = GetSystemMetrics(SM_CXSCREEN);
    g_cyPrimaryDisplay = GetSystemMetrics(SM_CYSCREEN);

    _ResizeStuckRects(_arStuckRects);

    if (hwnd)
    {
        //
        // set a bogus windowpos and actually repaint with the right
        // shape/size in handling the WINDOWPOSCHANGING message
        //
        SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOACTIVATE);
    }

    SizeWindows();
    
    RECT rc = _arStuckRects[_uStuckPlace];
    _HandleSizing(0, &rc, _uStuckPlace);
    // In the multi-monitor case, we need to turn on clipping for the dynamic
    // monitor changes i.e. when the user add monitors or remove them from the
    // control panel.
    _ClipWindow(TRUE);
}

BOOL CTray::_UpdateAlwaysOnTop(BOOL fAlwaysOnTop)
{
    BOOL fChanged = ((_fAlwaysOnTop == 0) != (fAlwaysOnTop == 0));
    //
    // The user clicked on the AlwaysOnTop menu item, we should now toggle
    // the state and update the window accordingly...
    //
    _fAlwaysOnTop = fAlwaysOnTop;
    _ResetZorder();

    // Make sure the screen limits are update to the new state.
    _StuckTrayChange();
    return fChanged;
}



void CTray::_SaveTrayAndDesktop(void)
{
    _SaveTray();

    if (v_hwndDesktop)
        SendMessage(v_hwndDesktop, DTM_SAVESTATE, 0, 0);

    if (_hwndNotify)
        SendMessage(_hwndNotify, TNM_SAVESTATE, 0, 0);
}

void CTray::_SlideStep(HWND hwnd, const RECT *prcMonitor, const RECT *prcOld, const RECT *prcNew)
{
    SIZE sizeOld = {prcOld->right - prcOld->left, prcOld->bottom - prcOld->top};
    SIZE sizeNew = {prcNew->right - prcNew->left, prcNew->bottom - prcNew->top};
    BOOL fClipFirst = FALSE;
    UINT flags;

    DAD_ShowDragImage(FALSE);   // Make sure this is off - client function must turn back on!!!
    if (prcMonitor)
    {
        RECT rcClip, rcClipSafe, rcClipTest;

        _CalcClipCoords(&rcClip, prcMonitor, prcNew);

        rcClipTest = rcClip;

        OffsetRect(&rcClipTest, prcOld->left, prcOld->top);
        IntersectRect(&rcClipSafe, &rcClipTest, prcMonitor);

        fClipFirst = EqualRect(&rcClipTest, &rcClipSafe);

        if (fClipFirst)
            _ClipInternal(&rcClip);
    }

    flags = SWP_NOZORDER|SWP_NOACTIVATE;
    if ((sizeOld.cx == sizeNew.cx) && (sizeOld.cy == sizeNew.cy))
        flags |= SWP_NOSIZE;

    SetWindowPos(hwnd, NULL,
        prcNew->left, prcNew->top, sizeNew.cx, sizeNew.cy, flags);

    if (prcMonitor && !fClipFirst)
    {
        RECT rcClip;

        _CalcClipCoords(&rcClip, prcMonitor, prcNew);
        _ClipInternal(&rcClip);
    }
}

void CTray::_SlideWindow(HWND hwnd, RECT *prc, BOOL fShow)
{
    RECT rcLast;
    RECT rcMonitor;
    const RECT *prcMonitor;
    DWORD dt;
    BOOL fAnimate;

    if (!IsWindowVisible(hwnd))
    {
        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.sw window is hidden, just moving"));
        MoveWindow(_hwnd, prc->left, prc->top, RECTWIDTH(*prc), RECTHEIGHT(*prc), FALSE);
        return;
    }

    DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.sw -----------------BEGIN-----------------"));

    if (GetSystemMetrics(SM_CMONITORS) > 1)
    {
        _GetStuckDisplayRect(_uStuckPlace, &rcMonitor);
        prcMonitor = &rcMonitor;
    }
    else
        prcMonitor = NULL;

    GetWindowRect(hwnd, &rcLast);

    dt = fShow? _dtSlideShow : _dtSlideHide;

    // See if we can use animation effects.
    SystemParametersInfo(SPI_GETMENUANIMATION, 0, &fAnimate, 0);

    if (g_fDragFullWindows && fAnimate && (dt > 0))
    {
        RECT rcOld, rcNew, rcMove;
        int  dx, dy, priority;
        DWORD t, t2, t0;
        HANDLE me;

        rcOld = rcLast;
        rcNew = *prc;

        dx = ((rcNew.left + rcNew.right) - (rcOld.left + rcOld.right)) / 2;
        dy = ((rcNew.top + rcNew.bottom) - (rcOld.top + rcOld.bottom)) / 2;
        ASSERT(dx == 0 || dy == 0);

        me = GetCurrentThread();
        priority = GetThreadPriority(me);
        SetThreadPriority(me, THREAD_PRIORITY_HIGHEST);

        t2 = t0 = GetTickCount();

        rcMove = rcOld;
        while ((t = GetTickCount()) - t0 < dt)
        {
            int dtdiff;
            if (t != t2)
            {
                rcMove.right -= rcMove.left;
                rcMove.left = rcOld.left + (dx) * (t - t0) / dt;
                rcMove.right += rcMove.left;

                rcMove.bottom -= rcMove.top;
                rcMove.top  = rcOld.top  + (dy) * (t - t0) / dt;
                rcMove.bottom += rcMove.top;

                _SlideStep(hwnd, prcMonitor, &rcLast, &rcMove);

                if (fShow)
                    UpdateWindow(hwnd);

                rcLast = rcMove;
                t2 = t;
            }

            // don't draw frames faster than user can see, e.g. 20ms
            #define ONEFRAME 20
            dtdiff = GetTickCount();
            if ((dtdiff - t) < ONEFRAME)
                Sleep(ONEFRAME - (dtdiff - t));

            // try to give desktop a chance to update
            // only do it on hide because desktop doesn't need to paint on taskbar show
            if (!fShow)
            {
                DWORD_PTR lres;
                SendMessageTimeout(v_hwndDesktop, DTM_UPDATENOW, 0, 0, SMTO_ABORTIFHUNG, 50, &lres);
            }
        }

        SetThreadPriority(me, priority);
    }

    _SlideStep(hwnd, prcMonitor, &rcLast, prc);

    if (fShow)
        UpdateWindow(hwnd);

    DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.sw ------------------END------------------"));
}

void CTray::_UnhideNow()
{
    if (_uModalMode == MM_SHUTDOWN)
        return;

    _fSelfSizing = TRUE;
    DAD_ShowDragImage(FALSE);   // unlock the drag sink if we are dragging.
    _SlideWindow(_hwnd, &_arStuckRects[_uStuckPlace], _dtSlideShow);
    DAD_ShowDragImage(TRUE);    // restore the lock state.
    _fSelfSizing = FALSE;

    SendMessage(_hwndNotify, TNM_TRAYHIDE, 0, FALSE);
}

void CTray::_ComputeHiddenRect(LPRECT prc, UINT uStuck)
{
    int dwh;
    HMONITOR hMon;
    RECT rcMon;
    
    hMon = MonitorFromRect(prc, MONITOR_DEFAULTTONULL);
    if (!hMon)
        return;
    GetMonitorRect(hMon, &rcMon);
 
    if (STUCK_HORIZONTAL(uStuck))
        dwh = prc->bottom - prc->top;
    else
        dwh = prc->right - prc->left;

    switch (uStuck)
    {
    case STICK_LEFT:
        prc->right = rcMon.left + (g_cxFrame / 2);
        prc->left = prc->right - dwh;
        break;

    case STICK_RIGHT:
        prc->left = rcMon.right - (g_cxFrame / 2);
        prc->right = prc->left + dwh;
        break;

    case STICK_TOP:
        prc->bottom = rcMon.top + (g_cyFrame / 2);
        prc->top = prc->bottom - dwh;
        break;

    case STICK_BOTTOM:
        prc->top = rcMon.bottom - (g_cyFrame / 2);
        prc->bottom = prc->top + dwh;
        break;
    }
}

UINT CTray::_GetDockedRect(LPRECT prc, BOOL fMoving)
{
    UINT uPos;

    if (fMoving && (_uMoveStuckPlace != (UINT)-1))
        uPos = _uMoveStuckPlace;
    else
        uPos = _uStuckPlace;

    *prc = _arStuckRects[uPos];

    if ((_uAutoHide & (AH_ON | AH_HIDING)) == (AH_ON | AH_HIDING))
    {
        _ComputeHiddenRect(prc, uPos);
    }

    return uPos;
}

void CTray::_CalcClipCoords(RECT *prcClip, const RECT *prcMonitor, const RECT *prcNew)
{
    RECT rcMonitor;
    RECT rcWindow;

    if (!prcMonitor)
    {
        _GetStuckDisplayRect(_uStuckPlace, &rcMonitor);
        prcMonitor = &rcMonitor;
    }

    if (!prcNew)
    {
        GetWindowRect(_hwnd, &rcWindow);
        prcNew = &rcWindow;
    }

    IntersectRect(prcClip, prcMonitor, prcNew);
    OffsetRect(prcClip, -prcNew->left, -prcNew->top);
}

void CTray::_ClipInternal(const RECT *prcClip)
{
    HRGN hrgnClip;

    // don't worry about clipping if there's only one monitor
    if (GetSystemMetrics(SM_CMONITORS) <= 1)
        prcClip = NULL;

    if (prcClip)
    {
        _fMonitorClipped = TRUE;
        hrgnClip = CreateRectRgnIndirect(prcClip);
    }
    else
    {
        // SetWindowRgn is expensive, skip ones that are NOPs
        if (!_fMonitorClipped)
            return;

        _fMonitorClipped = FALSE;
        hrgnClip = NULL;
    }

    SetWindowRgn(_hwnd, hrgnClip, TRUE);
}

void CTray::_ClipWindow(BOOL fClipState)
{
    RECT rcClip;
    RECT *prcClip;

    if (_fSelfSizing || _fSysSizing)
    {
        TraceMsg(TF_WARNING, "_ClipWindow: _fSelfSizing %x, _fSysSizing %x", _fSelfSizing, _fSysSizing);
        return;
    }

    if ((GetSystemMetrics(SM_CMONITORS) <= 1) || _hTheme)
        fClipState = FALSE;

    if (fClipState)
    {
        prcClip = &rcClip;
        _CalcClipCoords(prcClip, NULL, NULL);
    }
    else
        prcClip = NULL;

    _ClipInternal(prcClip);
}

void CTray::_Hide()
{
    RECT rcNew;

    // if we're in shutdown or if we're on boot up
    // don't hide
    if (_uModalMode == MM_SHUTDOWN)
    {
        TraceMsg(TF_TRAY, "e.th: suppress hide (shutdown || Notify)");
        return;
    }

    KillTimer(_hwnd, IDT_AUTOHIDE);

    _fSelfSizing = TRUE;

    //
    // update the flags here to prevent race conditions
    //
    _uAutoHide = AH_ON | AH_HIDING;
    _GetDockedRect(&rcNew, FALSE);

    DAD_ShowDragImage(FALSE);   // unlock the drag sink if we are dragging.
    _SlideWindow(_hwnd, &rcNew, _dtSlideHide);
    DAD_ShowDragImage(FALSE);   // Another thread could have locked while we were gone
    DAD_ShowDragImage(TRUE);    // restore the lock state.

    SendMessage(_hwndNotify, TNM_TRAYHIDE, 0, TRUE);

    _fSelfSizing = FALSE;
}

void CTray::_AutoHideCollision()
{
    DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_ahc COLLISION! (posting UI request)"));

    PostMessage(_hwnd, TM_WARNNOAUTOHIDE, ((_uAutoHide & AH_ON) != 0),
        0L);
}

LONG CTray::_SetAutoHideState(BOOL fAutoHide)
{
    //
    // make sure we have something to do
    //
    if ((fAutoHide != 0) == ((_uAutoHide & AH_ON) != 0))
    {
        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.sahs nothing to do"));
        return MAKELONG(FALSE, TRUE);
    }

    //
    // make sure we can do it
    //
    if (!_AppBarSetAutoHideBar2(_hwnd, fAutoHide, _uStuckPlace))
    {
        _AutoHideCollision();
        return MAKELONG(FALSE, FALSE);
    }

    //
    // do it
    //
    if (fAutoHide)
    {
        _uAutoHide = AH_ON;
        _RefreshSettings();
        _Hide();
#ifdef DEBUG
        // _Hide updates the flags for us (sanity)
        if (!(_uAutoHide & AH_ON))
        {
            TraceMsg(DM_WARNING, "e.sahs: !AH_ON"); // ok to fail on boot/shutdown
        }
#endif
    }
    else
    {
        _uAutoHide = 0;
        KillTimer(_hwnd, IDT_AUTOHIDE);
        _UnhideNow();
        _RefreshSettings();
    }

    //
    // brag about it
    //
    _StuckTrayChange();
    return MAKELONG(TRUE, TRUE);
}

void CTray::_HandleEnterMenuLoop()
{
    // kill the timer when we're in the menu loop so that we don't
    // pop done while browsing the menus.
    if (_uAutoHide & AH_ON)
    {
        KillTimer(_hwnd,  IDT_AUTOHIDE);
    }
}

void CTray::_SetAutoHideTimer()
{
    if (_uAutoHide & AH_ON)
    {
        SetTimer(_hwnd, IDT_AUTOHIDE, 500, NULL);
    }
}

void CTray::_HandleExitMenuLoop()
{
    // when we leave the menu stuff, start checking again.
    _SetAutoHideTimer();
}

void CTray::Unhide()
{
    // handle autohide
    if ((_uAutoHide & AH_ON) &&
        (_uAutoHide & AH_HIDING))
    {
        _UnhideNow();
        _uAutoHide &= ~AH_HIDING;
        _SetAutoHideTimer();

        if (_fShouldResize)
        {
            ASSERT(0);
            ASSERT(!(_uAutoHide & AH_HIDING));
            SizeWindows();
            _fShouldResize = FALSE;
        }
    }
}

void CTray::_SetUnhideTimer(LONG x, LONG y)
{
    // handle autohide
    if ((_uAutoHide & AH_ON) &&
        (_uAutoHide & AH_HIDING))
    {
        LONG dx = x-_ptLastHittest.x;
        LONG dy = y-_ptLastHittest.y;
        LONG rr = dx*dx + dy*dy;
        LONG dd = GetSystemMetrics(SM_CXDOUBLECLK) * GetSystemMetrics(SM_CYDOUBLECLK);

        if (rr > dd) 
        {
            SetTimer(_hwnd, IDT_AUTOUNHIDE, 50, NULL);
            _ptLastHittest.x = x;
            _ptLastHittest.y = y;
        }
    }
}

void CTray::_StartButtonReset()
{
    // Get an idea about how big we need everyhting to be.
    TCHAR szStart[50];
    LoadString(hinstCabinet, _hTheme ? IDS_START : IDS_STARTCLASSIC, szStart, ARRAYSIZE(szStart));
    SetWindowText(_hwndStart, szStart);

    if (_hFontStart)
        DeleteObject(_hFontStart);

    _hFontStart = _CreateStartFont(_hwndStart);

    int idbStart = IDB_START16;
    
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        int bpp = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);
        if (bpp > 8)
        {
            idbStart = _hTheme ? IDB_START : IDB_STARTCLASSIC;
        }

        ReleaseDC(NULL, hdc);
    }

    HBITMAP hbmFlag = (HBITMAP)LoadImage(hinstCabinet, MAKEINTRESOURCE(idbStart), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    if (hbmFlag)
    {
        BITMAP bm;
        if (GetObject(hbmFlag, sizeof(BITMAP), &bm))
        {
            BUTTON_IMAGELIST biml = {0};
            if (_himlStartFlag)
                ImageList_Destroy(_himlStartFlag);

            
            DWORD dwFlags = ILC_COLOR32;
            HBITMAP hbmFlagMask = NULL;
            if (idbStart == IDB_START16)
            {
                dwFlags = ILC_COLOR8 | ILC_MASK;
                hbmFlagMask = (HBITMAP)LoadImage(hinstCabinet, MAKEINTRESOURCE(IDB_START16MASK), IMAGE_BITMAP, 0, 0, LR_MONOCHROME);
            }

            if (IS_WINDOW_RTL_MIRRORED(_hwndStart))
            {
                dwFlags |= ILC_MIRROR;
            }
            biml.himl = _himlStartFlag = ImageList_Create(bm.bmWidth, bm.bmHeight, dwFlags, 1, 1);
            ImageList_Add(_himlStartFlag, hbmFlag, hbmFlagMask);

            if (hbmFlagMask)
            {
                DeleteObject(hbmFlagMask);
            }

            biml.uAlign = BUTTON_IMAGELIST_ALIGN_LEFT;

            Button_SetImageList(_hwndStart, &biml);
        }
        DeleteObject(hbmFlag);
    }

    if (_hFontStart)
    {
        SendMessage(_hwndStart, WM_SETFONT, (WPARAM)_hFontStart, TRUE);
        _sizeStart.cx = 0;
    }

    _AlignStartButton();

}

void CTray::_OnNewSystemSizes()
{
    TraceMsg(TF_TRAY, "Handling win ini change.");
    _StartButtonReset();
    VerifySize(TRUE);
}

//***   CheckWindowPositions -- flag which windows actually changed
// ENTRY/EXIT
//  _pPositions->hdsaWP[*]->fRestore modified
// NOTES
//  in order to correctly implement 'Undo Minimize-all(Cascade/Tile)',
// we need to tell which windows were changed by the 'Do' operation.
// (nt5:183421: we used to restore *every* top-level window).
int WINAPI CTray::CheckWndPosEnumProc(void *pItem, void *pData)
{
    HWNDANDPLACEMENT *pI2 = (HWNDANDPLACEMENT *)pItem;
    WINDOWPLACEMENT wp;

    wp.length = sizeof(wp);
    pI2->fRestore = TRUE;
    if (GetWindowPlacement(pI2->hwnd, &wp)) {
        if (memcmp(&pI2->wp, &wp, sizeof(wp)) == 0)
            pI2->fRestore = FALSE;
    }

    TraceMsg(TF_TRAY, "cwp: (hwnd=0x%x) fRestore=%d", pI2->hwnd, pI2->fRestore);

    return 1;   // 1:continue enum
}

void CTray::CheckWindowPositions()
{
    ENTERCRITICAL;      // i think this is needed...
    if (_pPositions) {
        if (_pPositions->hdsaWP) {
            DSA_EnumCallback(_pPositions->hdsaWP, CheckWndPosEnumProc, NULL);
        }
    }
    LEAVECRITICAL;

    return;
}

BOOL BandSite_PermitAutoHide(IUnknown* punk)
{
    OLECMD cmd = { DBID_PERMITAUTOHIDE, 0 };
    if (SUCCEEDED(IUnknown_QueryStatus(punk, &IID_IDockingWindow, 1, &cmd, NULL)))
    {
        return !(cmd.cmdf & OLECMDF_SUPPORTED) || (cmd.cmdf & OLECMDF_ENABLED);
    }
    return TRUE;
}

void CTray::_HandleTimer(WPARAM wTimerID)
{
    switch (wTimerID)
    {
    case IDT_CHECKDISKSPACE:
        CheckDiskSpace();
        break;

    case IDT_DESKTOPCLEANUP:
        _CheckDesktopCleanup();
        break;

    case IDT_CHANGENOTIFY:
        // did somebody send another notify since we last handled one?
        if (_fUseChangeNotifyTimer)
        {
            // yep.
            // all we do is check the staging area.
            CheckStagingArea();

            // kill it off the next time.
            _fUseChangeNotifyTimer = FALSE;
        }
        else
        {
            // nope.
            KillTimer(_hwnd, IDT_CHANGENOTIFY);
            _fChangeNotifyTimerRunning = FALSE;
        }
        break;

    case IDT_HANDLEDELAYBOOTSTUFF:
        KillTimer(_hwnd, IDT_HANDLEDELAYBOOTSTUFF);
        PostMessage(_hwnd, TM_HANDLEDELAYBOOTSTUFF, 0, 0);
        break;

    case IDT_STARTMENU:
        SetForegroundWindow(_hwnd);
        KillTimer(_hwnd, wTimerID);
        DAD_ShowDragImage(FALSE);       // unlock the drag sink if we are dragging.
        SendMessage(_hwndStart, BM_SETSTATE, TRUE, 0);
        UpdateWindow(_hwndStart);
        DAD_ShowDragImage(TRUE);        // restore the lock state.
        break;

    case IDT_SAVESETTINGS:
        KillTimer(_hwnd, IDT_SAVESETTINGS);
        _SaveTray();
        break;
    
    case IDT_ENABLEUNDO:
        KillTimer(_hwnd, IDT_ENABLEUNDO);
        CheckWindowPositions();
        _fUndoEnabled = TRUE;
        break;

    case IDT_AUTOHIDE:
        if (!_fSysSizing && (_uAutoHide & AH_ON))
        {
            POINT pt;
            RECT rc;

            // Don't hide if we're already hiding, a balloon tip is showing, or
            // (on NT5) if any apps are flashing.
            //
            if (!(_uAutoHide & AH_HIDING) && BandSite_PermitAutoHide(_ptbs) && !_fBalloonUp)
            {
                // Get the cursor position.
                GetCursorPos(&pt);

                // Get the tray rect and inflate it a bit.
                rc = _arStuckRects[_uStuckPlace];
                InflateRect(&rc, g_cxEdge * 4, g_cyEdge*4);

                // Don't hide if cursor is within inflated tray rect.
                if (!PtInRect(&rc, pt))
                {
                    // Don't hide if the tray is active
                    if (!_IsActive() && _uStartButtonState != SBSM_SPACTIVE)
                    {
                        // Don't hide if the view has a system menu up.
                        if (!SendMessage(_hwndTasks, TBC_SYSMENUCOUNT, 0, 0L))
                        {
                            // Phew!  We made it.  Hide the tray.
                            _Hide();
                        }
                    }
                }
            }
        }
        break;

    case IDT_AUTOUNHIDE:
        if (!_fSysSizing && (_uAutoHide & AH_ON))
        {
            POINT pt;
            RECT rc;

            KillTimer(_hwnd, wTimerID);
            _ptLastHittest.x = -0x0fff;
            _ptLastHittest.y = -0x0fff;
            GetWindowRect(_hwnd, &rc);
            if (_uAutoHide & AH_HIDING)
            {
                GetCursorPos(&pt);
                if (PtInRect(&rc, pt))
                    Unhide();
            }
        }
        break;

    case IDT_STARTBUTTONBALLOON:
        _DestroyStartButtonBalloon();
        break;

    case IDT_COFREEUNUSED:        
        CoFreeUnusedLibraries();
        KillTimer(_hwnd, IDT_COFREEUNUSED);
        break;
        
    }
}

void CTray::_CheckStagingAreaOnTimer()
{
    if (_fChangeNotifyTimerRunning)
    {
        // we're already running the timer, so force a check the next time it comes up
        _fUseChangeNotifyTimer = TRUE;
    }
    else
    {
        _fChangeNotifyTimerRunning = TRUE;

        // check once immediately
        CheckStagingArea();

        // check again in half a minute, but only if notifies have been happening in the meantime.
        SetTimer(_hwnd, IDT_CHANGENOTIFY, 30 * 1000, NULL);
    }
}

void CTray::_HandleChangeNotify(WPARAM wParam, LPARAM lParam)
{
    LPITEMIDLIST *ppidl;
    LONG lEvent;
    LPSHChangeNotificationLock pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);
    if (pshcnl)
    {
        if (lEvent & SHCNE_STAGINGAREANOTIFICATIONS)
        {
            // something has changed within the staging area.
            _CheckStagingAreaOnTimer();
        }
        SHChangeNotification_Unlock(pshcnl);
    }
}

BOOL _ExecItemByPidls(HWND hwnd, LPITEMIDLIST pidlFolder, LPITEMIDLIST pidlItem)
{
    BOOL fRes = FALSE;

    if (pidlFolder && pidlItem)
    {
        IShellFolder *psf = BindToFolder(pidlFolder);
        if (psf)
        {
            fRes = SUCCEEDED(SHInvokeDefaultCommand(hwnd, psf, pidlItem));
        }
        else
        {
            TCHAR szPath[MAX_PATH];
            SHGetPathFromIDList(pidlFolder, szPath);
            ShellMessageBox(hinstCabinet, hwnd, MAKEINTRESOURCE(IDS_CANTFINDSPECIALDIR),
                            NULL, MB_ICONEXCLAMATION, szPath);
        }
    }
    return fRes;
}

void _DestroySavedWindowPositions(LPWINDOWPOSITIONS pPositions);

LRESULT CTray::_HandleDestroy()
{
    MINIMIZEDMETRICS mm;

    TraceMsg(DM_SHUTDOWN, "_HD: enter");

    mm.cbSize = sizeof(mm);
    SystemParametersInfo(SPI_GETMINIMIZEDMETRICS, sizeof(mm), &mm, FALSE);
    mm.iArrange &= ~ARW_HIDE;
    SystemParametersInfo(SPI_SETMINIMIZEDMETRICS, sizeof(mm), &mm, FALSE);

    _RevokeDropTargets();
    _DestroyStartMenu();
    Mixer_Shutdown();

    // Tell the start menu to free all its cached darwin links
    SHRegisterDarwinLink(NULL, NULL, TRUE);

    _DestroySavedWindowPositions(_pPositions);
    _pPositions = NULL;

    if (_hTheme)
    {
        CloseThemeData(_hTheme);
        _hTheme = NULL;
    }

    _UnregisterGlobalHotkeys();

    if (_uNotify)
    {
        SHChangeNotifyDeregister(_uNotify);
        _uNotify = 0;
    }

    ATOMICRELEASE(_ptbs);
    ATOMICRELEASE(_pdbTasks);
    _hwndTasks = NULL;

    if (_hwndTrayTips)
    {
        DestroyWindow(_hwndTrayTips);
        _hwndTrayTips = NULL;
    }

    _DestroyStartButtonBalloon();

    // REVIEW
    PostQuitMessage(0);

    if (_hbmpStartBkg)
    {
        DeleteBitmap(_hbmpStartBkg);
    }

    if (_hFontStart)
    {
        DeleteObject(_hFontStart);
    }

    if (_himlStartFlag)
    {
        ImageList_Destroy(_himlStartFlag);
    }

    // clean up service objects
    _ssomgr.Destroy();

    if (_hShellReadyEvent)
    {
        ResetEvent(_hShellReadyEvent);
        CloseHandle(_hShellReadyEvent);
        _hShellReadyEvent = NULL;
    }

    if (_fHandledDelayBootStuff)
    {
        TBOOL(WinStationUnRegisterConsoleNotification(SERVERNAME_CURRENT, v_hwndTray));
    }

    DeleteCriticalSection(&_csHotkey);

    // The order in which we shut down the HTTP key monitoring is important.
    //
    // We must close the key before closing the event handle because
    // closing the key causes the event to be signalled and we don't
    // want ADVAPI32 to try to signal an event after we closed its handle...
    //
    // To avoid a spurious trigger when the event fires, we unregister
    // the wait before closing the key.
    //

    if (_hHTTPWait)
    {
        UnregisterWait(_hHTTPWait);
        _hHTTPWait = NULL;
    }

    if (_hkHTTP)
    {
        RegCloseKey(_hkHTTP);
        _hkHTTP = NULL;
    }

    if (_hHTTPEvent)
    {
        CloseHandle(_hHTTPEvent);
        _hHTTPEvent = NULL;
    }

    // End of order-sensitive operations ----------------------------------

    v_hwndTray = NULL;
    _hwndStart = NULL;


    TraceMsg(DM_SHUTDOWN, "_HD: leave");
    return 0;
}

void CTray::_SetFocus(HWND hwnd)
{
    IUnknown_UIActivateIO(_ptbs, FALSE, NULL);
    SetFocus(hwnd);
}

#define TRIEDTOOMANYTIMES 100

void CTray::_ActAsSwitcher()
{
    if (_uModalMode) 
    {
        if (_uModalMode != MM_SHUTDOWN) 
        {
            SwitchToThisWindow(GetLastActivePopup(_hwnd), TRUE);
        }
        MessageBeep(0);
    }
    else
    {
        HWND hwndForeground;
        HWND hwndActive;

        static int s_iRecurse = 0;
        s_iRecurse++;

        ASSERT(s_iRecurse < TRIEDTOOMANYTIMES);
        TraceMsg(TF_TRAY, "s_iRecurse = %d", s_iRecurse);

        hwndForeground = GetForegroundWindow();
        hwndActive = GetActiveWindow();
        BOOL fIsTrayActive = (hwndForeground == _hwnd) && (hwndActive == _hwnd);
        if (v_hwndStartPane && hwndForeground == v_hwndStartPane && hwndActive == v_hwndStartPane)
        {
            fIsTrayActive = TRUE;
        }
        // only do the button once we're the foreground dude.
        if (fIsTrayActive)
        {
            // This code path causes the start button to do something because
            // of the keyboard. So reflect that with the focus rect.
            SendMessage(_hwndStart, WM_UPDATEUISTATE, MAKEWPARAM(UIS_CLEAR,
                UISF_HIDEFOCUS), 0);

            if (SendMessage(_hwndStart, BM_GETSTATE, 0, 0) & BST_PUSHED)
            {
                ClosePopupMenus();
                ForceStartButtonUp();
            }
            else
            {
                // This pushes the start button and causes the start menu to popup.
                SendMessage(GetDlgItem(_hwnd, IDC_START), BM_SETSTATE, TRUE, 0);
            }
            s_iRecurse = 0;
        } 
        else 
        {
            // we don't want to loop endlessly trying to become
            // foreground.  With NT's new SetForegroundWindow rules, it would
            // be pointless to try and hopefully we won't need to anyhow.
            // Randomly, I picked a quarter as many times as the debug squirty would indicate
            // as the number of times to try on NT.
            // Hopefully that is enough on most machines.
            if (s_iRecurse > (TRIEDTOOMANYTIMES / 4)) 
            {
                s_iRecurse = 0;
                return;
            }
            // until then, try to come forward.
            HandleFullScreenApp(NULL);
            if (hwndForeground == v_hwndDesktop) 
            {
                _SetFocus(_hwndStart);
                if (GetFocus() != _hwndStart)
                    return;
            }

            SwitchToThisWindow(_hwnd, TRUE);
            SetForegroundWindow(_hwnd);
            Sleep(20); // give some time for other async activation messages to get posted
            PostMessage(_hwnd, TM_ACTASTASKSW, 0, 0);
        }
    }
}

void CTray::_OnWinIniChange(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    Cabinet_InitGlobalMetrics(wParam, (LPTSTR)lParam);

    // Reset the programs menu.
    // REVIEW IANEL - We should only need to listen to the SPI_SETNONCLIENT stuff
    // but deskcpl doesn't send one.
    if (wParam == SPI_SETNONCLIENTMETRICS || (!wParam && (!lParam || (lstrcmpi((LPTSTR)lParam, TEXT("WindowMetrics")) == 0))))
    {
#ifdef DEBUG
        if (wParam == SPI_SETNONCLIENTMETRICS)
            TraceMsg(TF_TRAY, "c.t_owic: Non-client metrics (probably) changed.");
        else
            TraceMsg(TF_TRAY, "c.t_owic: Window metrics changed.");
#endif

        _OnNewSystemSizes();
    }

    // Handle old extensions.
    if (!lParam || (lParam && (lstrcmpi((LPTSTR)lParam, TEXT("Extensions")) == 0)))
    {
        TraceMsg(TF_TRAY, "t_owic: Extensions section change.");
        CheckWinIniForAssocs();
    }

    if (lParam && (0 == lstrcmpi((LPCTSTR)lParam, TEXT("TraySettings"))))
    {
        _Command(FCIDM_REFRESH);
    }

    // Tell shell32 to refresh its cache
    SHSettingsChanged(wParam, lParam);
}

HWND CTray::_HotkeyInUse(WORD wHK)
{
    HWND hwnd;
    DWORD_PTR lrHKInUse = 0;
    int nMod;
    WORD wHKNew;
#ifdef DEBUG
    TCHAR sz[MAX_PATH];
#endif

    // Map the modifiers back.
    nMod = 0;
    if (HIBYTE(wHK) & MOD_SHIFT)
        nMod |= HOTKEYF_SHIFT;
    if (HIBYTE(wHK) & MOD_CONTROL)
        nMod |= HOTKEYF_CONTROL;
    if (HIBYTE(wHK) & MOD_ALT)
        nMod |= HOTKEYF_ALT;

    wHKNew = (WORD)((nMod*256)+LOBYTE(wHK));

    DebugMsg(DM_IANELHK, TEXT("c.hkl_hiu: Checking for %x"), wHKNew);
    hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
    while (hwnd)
    {
        SendMessageTimeout(hwnd, WM_GETHOTKEY, 0, 0, SMTO_ABORTIFHUNG| SMTO_BLOCK, 3000, &lrHKInUse);
        if (wHKNew == (WORD)lrHKInUse)
        {
#ifdef DEBUG
            GetWindowText(hwnd, sz, ARRAYSIZE(sz));
            DebugMsg(DM_IANELHK, TEXT("c.hkl_hiu: %s (%x) is using %x"), sz, hwnd, lrHKInUse);
#endif
            return hwnd;
        }
#ifdef DEBUG
        else if (lrHKInUse)
        {
            GetWindowText(hwnd, sz, ARRAYSIZE(sz));
            DebugMsg(DM_IANELHK, TEXT("c.hkl_hiu: %s (%x) is using %x"), sz, hwnd, lrHKInUse);
        }
#endif
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }
    return NULL;
}

void CTray::_HandleHotKey(int nID)
{
    TraceMsg(TF_TRAY, "c.hkl_hh: Handling hotkey (%d).", nID);

    // Find it in the list.
    ASSERT(IS_VALID_HANDLE(_hdsaHKI, DSA));

    EnterCriticalSection(&_csHotkey);

    HOTKEYITEM *phki = (HOTKEYITEM *)DSA_GetItemPtr(_hdsaHKI, nID);
    if (phki && phki->wGHotkey)
    {
        TraceMsg(TF_TRAY, "c.hkl_hh: Hotkey listed.");

        // Are global hotkeys enabled?
        if (!_fGlobalHotkeyDisable)
        {
            // Yep.
            HWND hwnd = _HotkeyInUse(phki->wGHotkey);
            // Make sure this hotkey isn't already in use by someone.
            if (hwnd)
            {
                TraceMsg(TF_TRAY, "c.hkl_hh: Hotkey is already in use.");
                // Activate it.
                SwitchToThisWindow(GetLastActivePopup(hwnd), TRUE);
            }
            else
            {
                DECLAREWAITCURSOR;
                // Exec the item.
                SetWaitCursor();
                TraceMsg(TF_TRAY, "c.hkl_hh: Hotkey is not in use, execing item.");
                ASSERT(phki->pidlFolder && phki->pidlItem);
                BOOL fRes = _ExecItemByPidls(_hwnd, phki->pidlFolder, phki->pidlItem);
                ResetWaitCursor();
#ifdef DEBUG
                if (!fRes)
                {
                    DebugMsg(DM_ERROR, TEXT("c.hkl_hh: Can't exec command ."));
                }
#endif
            }
        }
        else
        {
            DebugMsg(DM_ERROR, TEXT("c.hkl_hh: Global hotkeys have been disabled."));
        }
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("c.hkl_hh: Hotkey not listed."));
    }
    LeaveCriticalSection(&_csHotkey);
}

LRESULT CTray::_UnregisterHotkey(HWND hwnd, int i)
{
    TraceMsg(TF_TRAY, "c.t_uh: Unregistering hotkey (%d).", i);

    if (!UnregisterHotKey(hwnd, i))
    {
        DebugMsg(DM_ERROR, TEXT("c.t_rh: Unable to unregister hotkey %d."), i);
    }
    return TRUE;
}

// Add hotkey to the shell's list of global hotkeys.
LRESULT CTray::_ShortcutRegisterHotkey(HWND hwnd, WORD wHotkey, ATOM atom)
{
    int i;
    LPITEMIDLIST pidl;
    TCHAR szPath[MAX_PATH];
    ASSERT(atom);

    if (GlobalGetAtomName(atom, szPath, MAX_PATH))
    {
        TraceMsg(TF_TRAY, "c.t_srh: Hotkey %d for %s", wHotkey, szPath);

        pidl = ILCreateFromPath(szPath);
        if (pidl)
        {
            i = _HotkeyAddCached(_MapHotkeyToGlobalHotkey(wHotkey), pidl);
            if (i != -1)
            {
                _RegisterHotkey(_hwnd, i);
            }
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

// Remove hotkey from shell's list.
LRESULT CTray::_ShortcutUnregisterHotkey(HWND hwnd, WORD wHotkey)
{
    // DebugMsg(DM_TRACE, "c.t_suh: Hotkey %d", wHotkey);
    int i  = _HotkeyRemove(wHotkey);
    if (i == -1)
        i = _HotkeyRemoveCached(_MapHotkeyToGlobalHotkey(wHotkey));

    if (i != -1)
        _UnregisterHotkey(hwnd, i);

    return TRUE;
}

LRESULT CTray::_RegisterHotkey(HWND hwnd, int i)
{
    HOTKEYITEM *phki;
    WORD wGHotkey = 0;

    ASSERT(IS_VALID_HANDLE(_hdsaHKI, DSA));

    TraceMsg(TF_TRAY, "c.t_rh: Registering hotkey (%d).", i);

    EnterCriticalSection(&_csHotkey);

    phki = (HOTKEYITEM *)DSA_GetItemPtr(_hdsaHKI, i);
    ASSERT(phki);
    if (phki)
    {
        wGHotkey = phki->wGHotkey;
    }

    LeaveCriticalSection(&_csHotkey);
    
    if (wGHotkey)
    {
        // Is the hotkey available?
        if (RegisterHotKey(hwnd, i, HIBYTE(wGHotkey), LOBYTE(wGHotkey)))
        {
            // Yes.
            return TRUE;
        }
        else
        {
            // Delete any cached items that might be using this
            // hotkey.
            int iCached = _HotkeyRemoveCached(wGHotkey);
            ASSERT(iCached != i);
            if (iCached != -1)
            {
                // Free up the hotkey for us.
                _UnregisterHotkey(hwnd, iCached);
                // Yep, nuked the cached item. Try again.
                if (RegisterHotKey(hwnd, i, HIBYTE(wGHotkey), LOBYTE(wGHotkey)))
                {
                    return TRUE;
                }
            }
        }

        // Can't set hotkey for this item.
        DebugMsg(DM_ERROR, TEXT("c.t_rh: Unable to register hotkey %d."), i);
        // Null out this item.
        phki->wGHotkey = 0;
        phki->pidlFolder = NULL;
        phki->pidlItem = NULL;
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("c.t_rh: Hotkey item is invalid."));
    }
    return FALSE;
}


#define GetABDHWnd(pabd)   ((HWND)ULongToPtr((pabd)->dwWnd))

void CTray::_AppBarGetTaskBarPos(PTRAYAPPBARDATA ptabd)
{
    APPBARDATA3264 *pabd;

    pabd = (APPBARDATA3264*)SHLockShared(UlongToPtr(ptabd->hSharedABD), ptabd->dwProcId);
    if (pabd)
    {
        pabd->rc = _arStuckRects[_uStuckPlace];
        pabd->uEdge = _uStuckPlace;     // compat: new to ie4
        SHUnlockShared(pabd);
    }
}

void CTray::_NukeAppBar(int i)
{
    LocalFree(DPA_GetPtr(_hdpaAppBars, i));
    DPA_DeletePtr(_hdpaAppBars, i);
}

void CTray::_AppBarRemove(PTRAYAPPBARDATA ptabd)
{
    int i;

    if (!_hdpaAppBars)
        return;

    i = DPA_GetPtrCount(_hdpaAppBars);

    while (i--)
    {
        PAPPBAR pab = (PAPPBAR)DPA_GetPtr(_hdpaAppBars, i);

        if (GetABDHWnd(&ptabd->abd) == pab->hwnd)
        {
            RECT rcNuke = pab->rc;

            _NukeAppBar(i);
            _StuckAppChange(GetABDHWnd(&ptabd->abd), &rcNuke, NULL, FALSE);
        }
    }
}

PAPPBAR CTray::_FindAppBar(HWND hwnd)
{
    if (_hdpaAppBars)
    {
        int i = DPA_GetPtrCount(_hdpaAppBars);

        while (i--)
        {
            PAPPBAR pab = (PAPPBAR)DPA_GetPtr(_hdpaAppBars, i);

            if (hwnd == pab->hwnd)
                return pab;
        }
    }

    return NULL;
}

void CTray::_AppBarNotifyAll(HMONITOR hmon, UINT uMsg, HWND hwndExclude, LPARAM lParam)
{
    if (!_hdpaAppBars)
        return;

    int i = DPA_GetPtrCount(_hdpaAppBars);

    while (i--)
    {
        PAPPBAR pab = (PAPPBAR)DPA_GetPtr(_hdpaAppBars, i);

        // We need to check pab here as an appbar can delete other
        // appbars on the callback.
        if (pab && (hwndExclude != pab->hwnd))
        {
            if (!IsWindow(pab->hwnd))
            {
                _NukeAppBar(i);
                continue;
            }

            //
            // if a monitor was specified only tell appbars on that display
            //
            if (hmon &&
                (hmon != MonitorFromWindow(pab->hwnd, MONITOR_DEFAULTTONULL)))
            {
                continue;
            }

            PostMessage(pab->hwnd, pab->uCallbackMessage, uMsg, lParam);
        }
    }
}

BOOL CTray::_AppBarNew(PTRAYAPPBARDATA ptabd)
{
    PAPPBAR pab;
    if (!_hdpaAppBars)
    {
        _hdpaAppBars = DPA_Create(4);
        if (!_hdpaAppBars)
            return FALSE;

    }
    else if (_FindAppBar(GetABDHWnd(&ptabd->abd)))
    {
        // already have this hwnd
        return FALSE;
    }

    pab = (PAPPBAR)LocalAlloc(LPTR, sizeof(APPBAR));
    if (!pab)
        return FALSE;

    pab->hwnd = GetABDHWnd(&ptabd->abd);
    pab->uCallbackMessage = ptabd->abd.uCallbackMessage;
    pab->uEdge = (UINT)-1;

    if (DPA_AppendPtr(_hdpaAppBars, pab) == -1)
    {
        // insertion failed
        LocalFree(pab);
        return FALSE;
    }

    return TRUE;
}


BOOL CTray::_AppBarOutsideOf(PAPPBAR pabReq, PAPPBAR pab)
{
    if (pabReq->uEdge == pab->uEdge) 
    {
        switch (pab->uEdge) 
        {
        case ABE_RIGHT:
            return (pab->rc.right >= pabReq->rc.right);

        case ABE_BOTTOM:
            return (pab->rc.bottom >= pabReq->rc.bottom);

        case ABE_TOP:
            return (pab->rc.top <= pabReq->rc.top);

        case ABE_LEFT:
            return (pab->rc.left <= pabReq->rc.left);
        }
    }
    return FALSE;
}

void CTray::_AppBarQueryPos(PTRAYAPPBARDATA ptabd)
{
    int i;
    PAPPBAR pabReq = _FindAppBar(GetABDHWnd(&ptabd->abd));

    if (pabReq)
    {
        APPBARDATA3264 *pabd;

        pabd = (APPBARDATA3264*)SHLockShared(UlongToPtr(ptabd->hSharedABD), ptabd->dwProcId);
        if (pabd)
        {
            HMONITOR hmon;

            pabd->rc = ptabd->abd.rc;

            //
            // default to the primary display for this call because old appbars
            // sometimes pass a huge rect and let us pare it down.  if they do
            // something like that they don't support multiple displays anyway
            // so just put them on the primary display...
            //
            hmon = MonitorFromRect(&pabd->rc, MONITOR_DEFAULTTOPRIMARY);

            //
            // always subtract off the tray if it's on the same display
            //
            if (!_uAutoHide && (hmon == _hmonStuck))
            {
                APPBAR ab;

                ab.uEdge = _GetDockedRect(&ab.rc, FALSE);
                _AppBarSubtractRect(&ab, &pabd->rc);
            }

            i = DPA_GetPtrCount(_hdpaAppBars);

            while (i--)
            {
                PAPPBAR pab = (PAPPBAR)DPA_GetPtr(_hdpaAppBars, i);

                //
                // give top and bottom preference
                // ||
                // if we're not changing edges,
                //          subtract anything currently on the outside of us
                // ||
                // if we are changing sides,
                //          subtract off everything on the new side.
                //
                // of course ignore appbars which are not on the same display...
                //
                if ((((pabReq->hwnd != pab->hwnd) &&
                    STUCK_HORIZONTAL(pab->uEdge) &&
                    !STUCK_HORIZONTAL(ptabd->abd.uEdge)) ||
                    ((pabReq->hwnd != pab->hwnd) &&
                    (pabReq->uEdge == ptabd->abd.uEdge) &&
                    _AppBarOutsideOf(pabReq, pab)) ||
                    ((pabReq->hwnd != pab->hwnd) &&
                    (pabReq->uEdge != ptabd->abd.uEdge) &&
                    (pab->uEdge == ptabd->abd.uEdge))) &&
                    (hmon == MonitorFromRect(&pab->rc, MONITOR_DEFAULTTONULL)))
                {
                    _AppBarSubtractRect(pab, &pabd->rc);
                }
            }
            SHUnlockShared(pabd);
        }
    }
}

void CTray::_AppBarSetPos(PTRAYAPPBARDATA ptabd)
{
    PAPPBAR pab = _FindAppBar(GetABDHWnd(&ptabd->abd));

    if (pab)
    {
        RECT rcOld;
        APPBARDATA3264 *pabd;
        BOOL fChanged = FALSE;

        _AppBarQueryPos(ptabd);

        pabd = (APPBARDATA3264*)SHLockShared(UlongToPtr(ptabd->hSharedABD), ptabd->dwProcId);
        if (pabd)
        {
            if (!EqualRect(&pab->rc, &pabd->rc)) {
                rcOld = pab->rc;
                pab->rc = pabd->rc;
                pab->uEdge = ptabd->abd.uEdge;
                fChanged = TRUE;
            }
            SHUnlockShared(pabd);
        }

        if (fChanged)
            _StuckAppChange(GetABDHWnd(&ptabd->abd), &rcOld, &pab->rc, FALSE);
    }
}

//
// FEATURE: need to get rid of this array-based implementation to allow autohide
// appbars on secondary display (or a/h tray on 2nd with a/h appbar on primary)
// change it to an _AppBarFindAutoHideBar that keeps flags on the appbardata...
//
HWND CTray::_AppBarGetAutoHideBar(UINT uEdge)
{
    if (uEdge >= ABE_MAX)
        return FALSE;
    else 
    {
        HWND hwndAutoHide = _aHwndAutoHide[uEdge];
        if (!IsWindow(hwndAutoHide)) 
        {
            _aHwndAutoHide[uEdge] = NULL;
        }
        return _aHwndAutoHide[uEdge];
    }
}

BOOL CTray::_AppBarSetAutoHideBar2(HWND hwnd, BOOL fAutoHide, UINT uEdge)
{
    HWND hwndAutoHide = _aHwndAutoHide[uEdge];
    if (!IsWindow(hwndAutoHide))
    {
        _aHwndAutoHide[uEdge] = NULL;
    }

    if (fAutoHide)
    {
        // register
        if (!_aHwndAutoHide[uEdge])
        {
            _aHwndAutoHide[uEdge] = hwnd;
        }

        return _aHwndAutoHide[uEdge] == hwnd;
    }
    else
    {
        // unregister
        if (_aHwndAutoHide[uEdge] == hwnd)
        {
            _aHwndAutoHide[uEdge] = NULL;
        }

        return TRUE;
    }
}

BOOL CTray::_AppBarSetAutoHideBar(PTRAYAPPBARDATA ptabd)
{
    UINT uEdge = ptabd->abd.uEdge;
    if (uEdge >= ABE_MAX)
        return FALSE;
    else {
        return _AppBarSetAutoHideBar2(GetABDHWnd(&ptabd->abd), BOOLFROMPTR(ptabd->abd.lParam), uEdge);
    }
}

void CTray::_AppBarActivationChange2(HWND hwnd, UINT uEdge)
{
    //
    // FEATURE: make this multi-monitor cool
    //
    HWND hwndAutoHide = _AppBarGetAutoHideBar(uEdge);

    if (hwndAutoHide && (hwndAutoHide != hwnd))
    {
        //
        // the _AppBar got this notification inside a SendMessage from USER
        // and is now in a SendMessage to us.  don't try to do a SetWindowPos
        // right now...
        //
        PostMessage(_hwnd, TM_BRINGTOTOP, (WPARAM)hwndAutoHide, uEdge);
    }
}

void CTray::_AppBarActivationChange(PTRAYAPPBARDATA ptabd)
{
    PAPPBAR pab = _FindAppBar(GetABDHWnd(&ptabd->abd));
    if (pab) 
    {
        // if this is an autohide bar and they're claiming to be on an edge not the same as their autohide edge,
        // we don't do any activation of other autohides
        for (UINT i = 0; i < ABE_MAX; i++) 
        {
            if (_aHwndAutoHide[i] == GetABDHWnd(&ptabd->abd) &&
                i != pab->uEdge)
                return;
        }
        _AppBarActivationChange2(GetABDHWnd(&ptabd->abd), pab->uEdge);
    }
}

LRESULT CTray::_OnAppBarMessage(PCOPYDATASTRUCT pcds)
{
    PTRAYAPPBARDATA ptabd = (PTRAYAPPBARDATA)pcds->lpData;

    ASSERT(pcds->cbData == sizeof(TRAYAPPBARDATA));
    ASSERT(ptabd->abd.cbSize == sizeof(APPBARDATA3264));

    switch (ptabd->dwMessage) {
    case ABM_NEW:
        return _AppBarNew(ptabd);

    case ABM_REMOVE:
        _AppBarRemove(ptabd);
        break;

    case ABM_QUERYPOS:
        _AppBarQueryPos(ptabd);
        break;

    case ABM_SETPOS:
        _AppBarSetPos(ptabd);
        break;

    case ABM_GETSTATE:
        return _desktray.AppBarGetState();

    case ABM_SETSTATE:
        _AppBarSetState((UINT)ptabd->abd.lParam);
        break;

    case ABM_GETTASKBARPOS:
        _AppBarGetTaskBarPos(ptabd);
        break;

    case ABM_WINDOWPOSCHANGED:
    case ABM_ACTIVATE:
        _AppBarActivationChange(ptabd);
        break;

    case ABM_GETAUTOHIDEBAR:
        return (LRESULT)_AppBarGetAutoHideBar(ptabd->abd.uEdge);

    case ABM_SETAUTOHIDEBAR:
        return _AppBarSetAutoHideBar(ptabd);

    default:
        return FALSE;
    }

    return TRUE;

}

// EA486701-7F92-11cf-9E05-444553540000
const GUID CLSID_HIJACKINPROC = {0xEA486701, 0x7F92, 0x11cf, 0x9E, 0x05, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00};

HRESULT CTray::_LoadInProc(PCOPYDATASTRUCT pcds)
{
    ASSERT(pcds->cbData == sizeof(LOADINPROCDATA));

    PLOADINPROCDATA plipd = (PLOADINPROCDATA)pcds->lpData;

    // Hack to allow us to kill W95 shell extensions that do reall hacky things that
    // we can not support.    In this case Hijack pro
    if (IsEqualIID(plipd->clsid, CLSID_HIJACKINPROC))
    {
        return E_FAIL;
    }

    return _ssomgr.EnableObject(&plipd->clsid, plipd->dwFlags);
}

// Allow the trays global hotkeys to be disabled for a while.
LRESULT CTray::_SetHotkeyEnable(HWND hwnd, BOOL fEnable)
{
    _fGlobalHotkeyDisable = !fEnable;
    return TRUE;
}

BOOL IsPosInHwnd(LPARAM lParam, HWND hwnd)
{
    RECT r1;
    POINT pt;

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);
    GetWindowRect(hwnd, &r1);
    return PtInRect(&r1, pt);
}

void CTray::_HandleWindowPosChanging(LPWINDOWPOS lpwp)
{
    DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_hwpc"));

    if (_uMoveStuckPlace != (UINT)-1)
    {
        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_hwpc handling pending move"));
        _DoneMoving(lpwp);
    }
    else if (_fSysSizing || !_fSelfSizing)
    {
        RECT rc;

        if (_fSysSizing)
        {
            GetWindowRect(_hwnd, &rc);
            if (!(lpwp->flags & SWP_NOMOVE))
            {
                rc.left = lpwp->x;
                rc.top = lpwp->y;
            }
            if (!(lpwp->flags & SWP_NOSIZE))
            {
                rc.right = rc.left + lpwp->cx;
                rc.bottom = rc.top + lpwp->cy;
            }

            DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_hwpc sys sizing to rect {%d, %d, %d, %d}"), rc.left, rc.top, rc.right, rc.bottom);

            _uStuckPlace = _RecalcStuckPos(&rc);
            _UpdateVertical(_uStuckPlace);
        }

        _GetDockedRect(&rc, _fSysSizing);

        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.t_hwpc using rect {%d, %d, %d, %d}"), rc.left, rc.top, rc.right, rc.bottom);

        lpwp->x = rc.left;
        lpwp->y = rc.top;
        lpwp->cx = RECTWIDTH(rc);
        lpwp->cy = RECTHEIGHT(rc);

        lpwp->flags &= ~(SWP_NOMOVE | SWP_NOSIZE);
    }

    lpwp->flags |= SWP_FRAMECHANGED;
}

void CTray::_HandlePowerStatus(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fResetDisplay = FALSE;

    //
    // always reset the display when the machine wakes up from a
    // suspend.  NOTE: we don't need this for a standby suspend.
    //
    // a critical resume does not generate a WM_POWERBROADCAST
    // to windows for some reason, but it does generate an old
    // WM_POWER message.
    //
    switch (uMsg)
    {
    case WM_POWER:
        fResetDisplay = (wParam == PWR_CRITICALRESUME);
        break;

    case WM_POWERBROADCAST:
        switch (wParam)
        {
        case PBT_APMRESUMECRITICAL:
            fResetDisplay = TRUE;
            break;
        }
        break;
    }

    if (fResetDisplay)
        ChangeDisplaySettings(NULL, CDS_RESET);
}

//////////////////////////////////////////////////////

//
// This function checks whether we need to run the cleaner 
// We will not run if user is guest, user has forced us not to, or if the requisite
// number of days have not yet elapsed
//
// We execute a great deal of code to decide whether to run or not that logically should be
// in fldrclnr.dll, but we execute it here so that we don't have to load fldrclnr.dll unless 
// we absolutely have to, since we execute this path on every logon of explorer.exe
//

#define REGSTR_PATH_CLEANUPWIZ            REGSTR_PATH_EXPLORER TEXT("\\Desktop\\CleanupWiz")
#define REGSTR_OEM_PATH                   REGSTR_PATH_SETUP TEXT("\\OemStartMenuData")
#define REGSTR_VAL_TIME                   TEXT("Last used time")
#define REGSTR_VAL_DELTA_DAYS             TEXT("Days between clean up")
#define REGSTR_VAL_DONTRUN                TEXT("NoRun")
#define REGSTR_OEM_SEVENDAY_DISABLE       TEXT("OemDesktopCleanupDisable")

//
// iDays can be negative or positive, indicating time in the past or future
//
//
#define FTsPerDayOver1000 (10000*60*60*24) // we've got (1000 x 10,000) 100ns intervals per second

void CTray::_DesktopCleanup_GetFileTimeNDaysFromGivenTime(const FILETIME *pftGiven, FILETIME * pftReturn, int iDays)
{
    __int64 i64 = *((__int64 *) pftGiven);
    i64 += Int32x32To64(iDays*1000,FTsPerDayOver1000);

    *pftReturn = *((FILETIME *) &i64);    
}

//////////////////////////////////////////////////////

BOOL CTray::_DesktopCleanup_ShouldRun()
{
    BOOL fRetVal = FALSE;

    if (!IsOS(OS_ANYSERVER) &&
        _fIsDesktopConnected &&
        !SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_GUESTS) &&
        !SHRestricted(REST_NODESKTOPCLEANUP))        
    {
        fRetVal = TRUE;

        FILETIME ftNow, ftLast;
        SYSTEMTIME st;
        GetLocalTime(&st);
        SystemTimeToFileTime(&st, &ftNow);
        
        DWORD cb = sizeof(ftLast);
        DWORD dwData;
        if (ERROR_SUCCESS != SHRegGetUSValue(REGSTR_PATH_CLEANUPWIZ, REGSTR_VAL_TIME, 
                                             NULL, &ftLast, &cb, FALSE, NULL, 0))
        {
            cb = sizeof(dwData);
            if ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_OEM_PATH, REGSTR_OEM_SEVENDAY_DISABLE, NULL, &dwData, &cb)) &&
                (dwData != 0))
            {
                _DesktopCleanup_GetFileTimeNDaysFromGivenTime(&ftNow, &ftLast, -53); // to get the timer to kick in 7 days from now, set last to be 53 days ago
            }
            else
            {
                ftLast = ftNow;                                
            }
            SHRegSetUSValue(REGSTR_PATH_CLEANUPWIZ, REGSTR_VAL_TIME, NULL, &ftLast, sizeof(ftLast), SHREGSET_FORCE_HKCU);
        }

        HUSKEY hkey = NULL;
        if (ERROR_SUCCESS == SHRegOpenUSKey(REGSTR_PATH_CLEANUPWIZ, KEY_READ, NULL, &hkey, FALSE))
        {
            //
            // if we're in normal mode and the DONT RUN flag is set, we return immediately
            // (the user checked the "don't run automatically" box)
            //
            cb = sizeof (DWORD);
            if ((ERROR_SUCCESS == SHRegQueryUSValue(hkey, REGSTR_VAL_DONTRUN, NULL, &dwData, &cb, FALSE, NULL, 0)) &&
                (dwData != 0))
            {
                fRetVal = FALSE;
            }
            else
            {
                //
                // we need to figure out if if we are within the (last run time + delta days) 
                // time period
                //                
                int iDays = 60;
                if (ERROR_SUCCESS == (SHRegGetUSValue(REGSTR_PATH_CLEANUPWIZ, REGSTR_VAL_DELTA_DAYS, 
                                                      NULL, &dwData, &cb,FALSE, NULL, 0)))               
                {
                    iDays = dwData;
                }

                // if (iDays == 0), run every time!
                if (iDays > 0)
                {
                    FILETIME ftRange;                        
        
                    _DesktopCleanup_GetFileTimeNDaysFromGivenTime(&ftLast, &ftRange, iDays);
                    if (!(CompareFileTime(&ftNow, &ftRange) > 0))
                    {
                        fRetVal = FALSE;
                    }
                }
            }

            SHRegCloseUSKey(hkey);
        }
    }

    return fRetVal;
}

void CTray::_CheckDesktopCleanup()
{
    if (_DesktopCleanup_ShouldRun())
    {
        PROCESS_INFORMATION pi = {0};
        TCHAR szRunDll32[MAX_PATH];

        GetSystemDirectory(szRunDll32, ARRAYSIZE(szRunDll32));
        PathAppend(szRunDll32, TEXT("rundll32.exe"));

        if (CreateProcessWithArgs(szRunDll32, TEXT("fldrclnr.dll,Wizard_RunDLL"), NULL, &pi))
        {
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }
}

//////////////////////////////////////////////////////

// 
// Try tacking a 1, 2, 3 or whatever on to a file or
// directory name until it is unique.  When on a file, 
// stick it before the extension.
// 
void _MakeBetterUniqueName(LPTSTR pszPathName, int cchPathName)
{
    TCHAR   szNewPath[MAX_PATH];
    int     i = 1;

    if (PathIsDirectory(pszPathName))
    {
        do 
        {
            StringCchPrintf(szNewPath, ARRAYSIZE(szNewPath), TEXT("%s%d"), pszPathName, i++);
        } while (-1 != GetFileAttributes(szNewPath));

        StringCchCopy(pszPathName, cchPathName, szNewPath);
    }
    else
    {
        TCHAR   szExt[MAX_PATH];
        LPTSTR  pszExt;

        pszExt = PathFindExtension(pszPathName);
        if (pszExt)
        {
            StringCchCopy(szExt, ARRAYSIZE(szExt), pszExt);
            *pszExt = 0;

            do 
            {
                StringCchPrintf(szNewPath, ARRAYSIZE(szNewPath), TEXT("%s%d%s"), pszPathName, i++,szExt);
            } while (-1 != GetFileAttributes(szNewPath));

            StringCchCopy(pszPathName, cchPathName, szNewPath);
        }
    }
}

BOOL_PTR WINAPI CTray::RogueProgramFileDlgProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR   szBuffer[MAX_PATH*2];
    TCHAR   szBuffer2[MAX_PATH*2];
    static TCHAR   szBetterPath[MAX_PATH];
    static TCHAR  *pszPath = NULL;
    
    switch (iMsg)
    {
    case WM_INITDIALOG:
        pszPath = (TCHAR *)lParam;
        StringCchCopy(szBetterPath, ARRAYSIZE(szBetterPath), pszPath);
        _MakeBetterUniqueName(szBetterPath, ARRAYSIZE(szBetterPath));
        SendDlgItemMessage(hWnd, IDC_MSG, WM_GETTEXT, (WPARAM)(MAX_PATH*2), (LPARAM)szBuffer);
        StringCchPrintf(szBuffer2, ARRAYSIZE(szBuffer2), szBuffer, pszPath, szBetterPath);
        SendDlgItemMessage(hWnd, IDC_MSG, WM_SETTEXT, (WPARAM)0, (LPARAM)szBuffer2);

        return TRUE;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDC_RENAME:
            //rename and fall through
            if (pszPath)
            {
                MoveFile(pszPath, szBetterPath);
            }
            EndDialog(hWnd, IDC_RENAME);
            return TRUE;

        case IDIGNORE:
            EndDialog(hWnd, IDIGNORE);
            return TRUE;
        }
        break;
    }
    return FALSE;
}

//
// Check to see if there are any files or folders that could interfere
// with the fact that Program Files has a space in it.
//
// An example would be a directory called: "C:\Program" or a file called"C:\Program.exe".
//
// This can prevent apps that dont quote strings in the registry or call CreateProcess with 
// unquoted strings from working properly since CreateProcess wont know what the real exe is.
//
void CTray::_CheckForRogueProgramFile()
{
    TCHAR szProgramFilesPath[MAX_PATH];
    TCHAR szProgramFilesShortName[MAX_PATH];

    if (SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS)
    && S_OK == SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, SHGFP_TYPE_CURRENT, szProgramFilesPath))
    {
        LPTSTR pszRoguePattern;
        int cchRoguePattern;

        pszRoguePattern = StrChr(szProgramFilesPath, TEXT(' '));
        cchRoguePattern = ARRAYSIZE(szProgramFilesPath) - (pszRoguePattern - szProgramFilesPath);
        
        if (pszRoguePattern)
        {
            HANDLE  hFind;
            WIN32_FIND_DATA wfd;

            // Remember short name for folder name comparison below
            *pszRoguePattern = TEXT('\0');
            StringCchCopy(szProgramFilesShortName, ARRAYSIZE(szProgramFilesShortName), szProgramFilesPath);

            // turn "C:\program files" into "C:\program.*"
            StringCchCopy(pszRoguePattern, cchRoguePattern, TEXT(".*"));
            pszRoguePattern = szProgramFilesPath;

            hFind = FindFirstFile(pszRoguePattern, &wfd);

            while (hFind != INVALID_HANDLE_VALUE)
            {
                int iRet = 0;
                TCHAR szRogueFileName[MAX_PATH];

                // we found a file (eg "c:\Program.txt")
                StringCchCopy(szRogueFileName, ARRAYSIZE(szRogueFileName), pszRoguePattern);
                PathRemoveFileSpec(szRogueFileName);
                StringCchCat(szRogueFileName, ARRAYSIZE(szRogueFileName), wfd.cFileName);

                // don't worry about folders unless they are called "Program"
                if (!((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                    lstrcmpi(szProgramFilesShortName, szRogueFileName) != 0))
                {
                        
                    iRet = SHMessageBoxCheckEx(GetDesktopWindow(),
                                               hinstCabinet,
                                               MAKEINTRESOURCE(DLG_PROGRAMFILECONFLICT),
                                               RogueProgramFileDlgProc,
                                               (void *)szRogueFileName,
                                               IDIGNORE,
                                               TEXT("RogueProgramName"));
                }
                
                if ((iRet == IDIGNORE) || !FindNextFile(hFind, &wfd))
                {
                    // user hit ignore or we are done, so don't keep going
                    break;
                }
            }

            if (hFind != INVALID_HANDLE_VALUE)
            {
                FindClose(hFind);
            }
        }
    }
}

void CTray::_OnWaitCursorNotify(LPNMHDR pnm)
{
    _iWaitCount += (pnm->code == NM_STARTWAIT ? 1 :-1);
    ASSERT(_iWaitCount >= 0);
    // Don't let it go negative or we'll never get rid of it.
    if (_iWaitCount < 0)
        _iWaitCount = 0;
    // what we really want is for user to simulate a mouse move/setcursor
    SetCursor(LoadCursor(NULL, _iWaitCount ? IDC_APPSTARTING : IDC_ARROW));
}

void CTray::_HandlePrivateCommand(LPARAM lParam)
{
    LPSTR psz = (LPSTR) lParam; // lParam always ansi.

    if (!lstrcmpiA(psz, "ToggleDesktop"))
    {
        _RaiseDesktop(!g_fDesktopRaised, TRUE);
    }
    else if (!lstrcmpiA(psz, "Explorer"))
    {
        // Fast way to bring up explorer window on root of
        // windows dir.
        SHELLEXECUTEINFO shei = {0};
        TCHAR szPath[MAX_PATH];

        if (GetWindowsDirectory(szPath, ARRAYSIZE(szPath)) != 0)
        {
            PathStripToRoot(szPath);

            shei.lpIDList = ILCreateFromPath(szPath);
            if (shei.lpIDList)
            {
                shei.cbSize     = sizeof(shei);
                shei.fMask      = SEE_MASK_IDLIST;
                shei.nShow      = SW_SHOWNORMAL;
                shei.lpVerb     = TEXT("explore");
                ShellExecuteEx(&shei);
                ILFree((LPITEMIDLIST)shei.lpIDList);
            }
        }
    }

    LocalFree(psz);
}

//***
//
void CTray::_OnFocusMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fActivate = (BOOL) wParam;

    switch (uMsg)
    {
    case TM_UIACTIVATEIO:
    {
#ifdef DEBUG
        {
            int dtb = (int) lParam;

            TraceMsg(DM_FOCUS, "tiois: TM_UIActIO fAct=%d dtb=%d", fActivate, dtb);

            ASSERT(dtb == 1 || dtb == -1);
        }
#endif

        if (fActivate)
        {
            // Since we are tabbing into the tray, turn the focus rect on.
            SendMessage(_hwnd, WM_UPDATEUISTATE, MAKEWPARAM(UIS_CLEAR,
                UISF_HIDEFOCUS), 0);

            SendMessage(v_hwndDesktop, DTM_ONFOCUSCHANGEIS, TRUE, (LPARAM) _hwnd);
            SetForegroundWindow(_hwnd);

            // fake an IUnknown_UIActivateIO(_ptbs, TRUE, &msg);
            if (GetAsyncKeyState(VK_SHIFT) < 0)
            {
                _SetFocus(_hwndNotify);
            }
            else
            {
                _SetFocus(_hwndStart);
            }
        }
        else
        {
Ldeact:
            IUnknown_UIActivateIO(_ptbs, FALSE, NULL);
            SetForegroundWindow(v_hwndDesktop);
        }

        break;
    }

    case TM_ONFOCUSCHANGEIS:
    {
        HWND hwnd = (HWND) lParam;

        TraceMsg(DM_FOCUS, "tiois: TM_OnFocChgIS hwnd=%x fAct=%d", hwnd, fActivate);

        if (fActivate)
        {
            // someone else is activating, so we need to deactivate
            goto Ldeact;
        }

        break;
    }

    default:
        ASSERT(0);
        break;
    }

    return;
}

#define TSVC_NTIMER     (IDT_SERVICELAST - IDT_SERVICE0 + 1)

struct {
#ifdef DEBUG
    UINT_PTR    idtWin;
#endif
    TIMERPROC   pfnSvc;
} g_timerService[TSVC_NTIMER];

#define TSVC_IDToIndex(id)    ((id) - IDT_SERVICE0)
#define TSVC_IndexToID(i)     ((i) + IDT_SERVICE0)

int CTray::_OnTimerService(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    int i;
    UINT_PTR idt;
    TIMERPROC pfn;
    BOOL b;

    switch (uMsg) {
    case TM_SETTIMER:
        TraceMsg(DM_UEMTRACE, "e.TM_SETTIMER: wP=0x%x lP=%x", wParam, lParam);
        ASSERT(IS_VALID_CODE_PTR(lParam, TIMERPROC));
        for (i = 0; i < TSVC_NTIMER; i++) {
            if (g_timerService[i].pfnSvc == 0) {
                g_timerService[i].pfnSvc = (TIMERPROC)lParam;
                idt = SetTimer(_hwnd, TSVC_IndexToID(i), (UINT)wParam, 0);
                if (idt == 0) {
                    TraceMsg(DM_UEMTRACE, "e.TM_SETTIMER: ST()=%d (!)", idt);
                    break;
                }
                ASSERT(idt == (UINT_PTR)TSVC_IndexToID(i));
                DBEXEC(TRUE, (g_timerService[i].idtWin = idt));
                TraceMsg(DM_UEMTRACE, "e.TM_SETTIMER: ret=0x%x", TSVC_IndexToID(i));
                return TSVC_IndexToID(i);   // idtWin
            }
        }
        TraceMsg(DM_UEMTRACE, "e.TM_SETTIMER: ret=0 (!)");
        return 0;

    case TM_KILLTIMER:  // lP=idtWin
        TraceMsg(DM_UEMTRACE, "e.TM_KILLTIMER: wP=0x%x lP=%x", wParam, lParam);
        if (EVAL(IDT_SERVICE0 <= lParam && lParam <= IDT_SERVICE0 + TSVC_NTIMER - 1)) {
            i = (int)TSVC_IDToIndex(lParam);
            if (g_timerService[i].pfnSvc) {
                ASSERT(g_timerService[i].idtWin == (UINT)lParam);
                b = KillTimer(_hwnd, lParam);
                ASSERT(b);
                g_timerService[i].pfnSvc = 0;
                DBEXEC(TRUE, (g_timerService[i].idtWin = 0));
                return TRUE;
            }
        }
        return 0;

    case WM_TIMER:      // wP=idtWin lP=0
        TraceMsg(DM_UEMTRACE, "e.TM_TIMER: wP=0x%x lP=%x", wParam, lParam);
        if (EVAL(IDT_SERVICE0 <= wParam && wParam <= IDT_SERVICE0 + TSVC_NTIMER - 1)) {
            i = (int)TSVC_IDToIndex(wParam);
            pfn = g_timerService[i].pfnSvc;
            if (EVAL(IS_VALID_CODE_PTR(pfn, TIMERPROC)))
                (*pfn)(_hwnd, WM_TIMER, wParam, GetTickCount());
        }
        return 0;
    }

    ASSERT(0);      /*NOTREACHED*/
    return 0;
}

void CTray::RealityCheck()
{
    //
    // Make sure that the tray's actual z-order position agrees with what we think
    // it is.  We need to do this because there's a recurring bug where the tray
    // gets bumped out of TOPMOST position.  (Lots of things, like a tray-owned
    // window moving itself to non-TOPMOST or a random app messing with the tray
    // window position, can cause this.)
    //
    _ResetZorder();
}

#define DELAY_STARTUPTROUBLESHOOT   (15 * 1000)

void CTray::LogFailedStartupApp()
{
    if (_hwnd)
    {
        PostMessage(_hwnd, TM_HANDLESTARTUPFAILED, 0, 0);
    }
    else
    {
        _fEarlyStartupFailure = TRUE;
    }
}

void WINAPI CTray::TroubleShootStartupCB(HWND hwnd, UINT uMsg, UINT_PTR idTimer, DWORD dwTime)
{
    KillTimer(hwnd, idTimer);

    if (!c_tray._fStartupTroubleshooterLaunched)
    {
        TCHAR szCmdLine[MAX_PATH];
        DWORD cb;

        c_tray._fStartupTroubleshooterLaunched = TRUE;
        cb = sizeof(szCmdLine);
        if (SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_EXPLORER,
                       TEXT("StartupTroubleshoot"), NULL,
                       szCmdLine, &cb) == ERROR_SUCCESS)
        {
            ShellExecuteRegApp(szCmdLine, RRA_NOUI | RRA_DELETE);
        }
    }
}

void CTray::_OnHandleStartupFailed()
{
    /*
     *  Don't launch the troubleshooter until we have gone
     *  DELAY_STARTUPTROUBLESHOOT milliseconds without a startup problem.
     *  This gives time for the system to settle down before starting to
     *  annoy the user all over again.
     *
     *  (And, of course, don't launch it more than once.)
     */
    if (!_fStartupTroubleshooterLaunched)
    {
        SetTimer(_hwnd, IDT_STARTUPFAILED, DELAY_STARTUPTROUBLESHOOT, TroubleShootStartupCB);
    }
}

void CTray::_HandleDelayBootStuff()
{
    // This posted message is the last one processed by the primary
    // thread (tray thread) when we boot.  At this point we will
    // want to load the shell services (which usually create threads)
    // and resume both the background start menu thread and the fs_notfiy
    // thread.

    if (!_fHandledDelayBootStuff)
    {
        if (GetShellWindow() == NULL)
        {
            // The desktop browser hasn't finished navigating yet.
            SetTimer(_hwnd, IDT_HANDLEDELAYBOOTSTUFF, 3 * 1000, NULL);
            return;
        }

        _fHandledDelayBootStuff = TRUE;

        if (g_dwStopWatchMode)
        {
            StopWatch_StartTimed(SWID_STARTUP, TEXT("_DelayedBootStuff"), SPMODE_SHELL | SPMODE_DEBUGOUT, GetPerfTime());
        }

        PostMessage(_hwnd, TM_SHELLSERVICEOBJECTS, 0, 0);

        BandSite_HandleDelayBootStuff(_ptbs);

        //check to see if there are any files or folders that could interfere
        //with the fact that Program Files has a space in it.  An example would
        //be a folder called "C:\Program" or a file called "C:\Program.exe"
        _CheckForRogueProgramFile();
        
        // Create a named event and fire it so that the services can
        // go to work, reducing contention during boot.
        _hShellReadyEvent = CreateEvent(0, TRUE, TRUE, TEXT("ShellReadyEvent"));
        if (_hShellReadyEvent) 
        {
            // Set the event in case it was already created and our "create
            // signaled" parameter to CreateEvent got ignored.
            SetEvent(_hShellReadyEvent);
        }

        // Check whether we should launch Desktop Cleanup Wizard
        _CheckDesktopCleanup();

        TBOOL(WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, _hwnd, NOTIFY_FOR_THIS_SESSION));

        if (g_dwStopWatchMode)
        {
            StopWatch_StopTimed(SWID_STARTUP, TEXT("_DelayedBootStuff"), SPMODE_SHELL | SPMODE_DEBUGOUT, GetPerfTime());
        }
    }
}

LRESULT CTray::_OnDeviceChange(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    switch (wParam)
    {
    case DBT_CONFIGCHANGED:
        // We got an update. Refresh.
        _RefreshStartMenu();
        break;

    case DBT_QUERYCHANGECONFIG:
        //
        // change to registry settings
        //
        ChangeDisplaySettings(NULL, 0);
        break;

    case DBT_MONITORCHANGE:
        //
        // handle monitor change
        //
        HandleDisplayChange(LOWORD(lParam), HIWORD(lParam), TRUE);
        break;

    case DBT_CONFIGCHANGECANCELED:
        //
        // if the config change was canceled go back
        //
        HandleDisplayChange(0, 0, FALSE);
        break;
    }

    Mixer_DeviceChange(wParam, lParam);
    return 0;
}

//
//  The "resizable" edge of the taskbar is the edge adjacent to
//  the desktop, i.e. opposite the stuck place.
//
//  returns HTXXX if on a resizable edge, else HTBORDER
//
DWORD CTray::_PtOnResizableEdge(POINT pt, LPRECT prcClient)
{
    RECT rc;
    GetWindowRect(_hwnd, &rc);

    DWORD dwHit = HTBORDER;

    switch (_uStuckPlace)
    {
    case STICK_LEFT:    rc.left = prcClient->right; dwHit = HTRIGHT;    break;
    case STICK_TOP:     rc.top = prcClient->bottom; dwHit = HTBOTTOM;   break;
    case STICK_RIGHT:   rc.right = prcClient->left; dwHit = HTLEFT;     break;
    case STICK_BOTTOM:  rc.bottom = prcClient->top; dwHit = HTTOP;      break;
    }

    return PtInRect(&rc, pt) ? dwHit : HTBORDER;
}

//
//  _OnFactoryMessage
//
//  The OPK "factory.exe" tool sends us this message to tell us that
//  it has dorked some setting or other and we should refresh so the
//  OEM can see the effect immediately and feel confident that it
//  actually worked.  This is not technically necessary but it cuts
//  down on OEM support calls when they ask us why their setting didn't
//  work.  (It did work, they just have to log off and back on to see
//  it.)
//

int CTray::_OnFactoryMessage(WPARAM wParam, LPARAM lParam)
{
    switch (wParam)
    {
    case 0:         // FACTORY_OEMLINK:  factory.exe has dorked the OEM link
        ClosePopupMenus();
        _BuildStartMenu();  // Force a rebuild
        return 1;

    case 1:         // FACTORY_MFU:  factory.exe has written a new MFU
        HandleFirstTime();      // Rebuild the default MFU
        ClosePopupMenus();
        _BuildStartMenu();  // Force a rebuild
        return 1;
    }

    return 0;
}

#define CX_OFFSET   g_cxEdge
#define CY_OFFSET   g_cyEdge

//
// _MapNCToClient
//
// see comments in _TryForwardNCToClient
//
BOOL CTray::_MapNCToClient(LPARAM* plParam)
{
    POINT pt = { GET_X_LPARAM(*plParam), GET_Y_LPARAM(*plParam) };

    RECT rcClient;
    GetClientRect(_hwnd, &rcClient);
    MapWindowPoints(_hwnd, NULL, (LPPOINT)&rcClient, 2);

    //
    // point must be outside the client area and not on the
    // resizable edge of the taskbar
    //

    if (!PtInRect(&rcClient, pt) && _PtOnResizableEdge(pt, &rcClient) == HTBORDER)
    {
        //
        // fudge it over onto the client edge and return TRUE
        //
        if (pt.x < rcClient.left)
            pt.x = rcClient.left + CX_OFFSET;
        else if (pt.x > rcClient.right)
            pt.x = rcClient.right - CX_OFFSET;

        if (pt.y < rcClient.top)
            pt.y = rcClient.top + CY_OFFSET;
        else if (pt.y > rcClient.bottom)
            pt.y = rcClient.bottom - CY_OFFSET;

        *plParam = MAKELONG(pt.x, pt.y);
        return TRUE;
    }

    //
    // didn't pass the test.  leave the point alone and return FALSE.
    //
    return FALSE;
}

HWND _TopChildWindowFromPoint(HWND hwnd, POINT pt)
{
    HWND hwndLast = NULL;
    hwnd = ChildWindowFromPoint(hwnd, pt);
    while (hwnd && hwnd != hwndLast)
    {
        hwndLast = hwnd;
        hwnd = ChildWindowFromPoint(hwnd, pt);
    }
    return hwndLast;
}

//
// _TryForwardNCToClient
//
// Hack!  This exists to solve a usability problem.  When you slam your
// mouse into the bottom corner of the screen and click, we want that to
// activate the start button.  Similarly, when you slam your mouse below
// a Quick Launch button or task button and click, we want that to
// activate the button.
//
// We hack this by remapping the coordinate of NC mouse messages and
// manually forwarding to the appropriate window.  We only do this for
// clicks on the edges non-resizable edge of the taskbar.
//
// We also warp the mouse cursor over to the new position.  This is needed
// because e.g. if toolbar is the client window we're forwarding
// to, it will set capture and receive subsequent mouse messages.  (And
// once it gets a mouse message outside the window, it will deselect the
// button and so the button won't get activated.)
//
// _MapNCToClient has the rules for figuring out if the click is on
// one of the edges we want and for remapping the coordinate into the
// client area.
//
BOOL CTray::_TryForwardNCToClient(UINT uMsg, LPARAM lParam)
{
    if (_MapNCToClient(&lParam))
    {
        // see if this is over one of our windows 
        POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
        MapWindowPoints(NULL, _hwnd, &pt, 1);
        HWND hwnd = _TopChildWindowFromPoint(_hwnd, pt);

        if (hwnd)
        {
            // warp the mouse cursor to this screen coord
            SetCursorPos(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

            // map to window coords
            MapWindowPoints(_hwnd, hwnd, &pt, 1);

            // set lparam to window coords
            lParam = MAKELONG(pt.x, pt.y);

            // map to client message
            ASSERT(InRange(uMsg, WM_NCMOUSEFIRST, WM_NCMOUSELAST));
            uMsg += (WM_LBUTTONDOWN - WM_NCLBUTTONDOWN);

            // forward it
            SendMessage(hwnd, uMsg, 0, lParam);
            return TRUE;
        }
    }
    return FALSE;
}

//  --------------------------------------------------------------------------
//  CTray::CountOfRunningPrograms
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Iterates the window list. Looks for windows that are visible
//              with a non-zero length window title. Gets that window process
//              ID and keeps the IDs in a list. For each window iterated it
//              checks against the list to see if the process is already
//              tagged and if so doesn't add it again. Finally it returns the
//              count of the unique processes handling open visible windows
//              in the user's desktop.
//
//              The list is fixed at 1000 processes (using stack space).
//
//  History:    2000-06-29  vtan        created
//  --------------------------------------------------------------------------

static  const int   MAXIMUM_PROCESS_COUNT   =   1000;

typedef struct
{
    DWORD   dwCount;
    DWORD   dwProcessIDs[MAXIMUM_PROCESS_COUNT];
} tProcessIDList;

bool    FoundProcessID (tProcessIDList *pProcessIDList, DWORD dwProcessID)

{
    bool    fFound;
    DWORD   dwIndex;

    for (fFound = false, dwIndex = 0; !fFound && (dwIndex < pProcessIDList->dwCount); ++dwIndex)
    {
        fFound = (pProcessIDList->dwProcessIDs[dwIndex] == dwProcessID);
    }
    return(fFound);
}

void    AddProcessID (tProcessIDList *pProcessIDList, DWORD dwProcessID)

{
    if (pProcessIDList->dwCount < MAXIMUM_PROCESS_COUNT)
    {
        pProcessIDList->dwProcessIDs[pProcessIDList->dwCount++] = dwProcessID;
    }
}

BOOL    CALLBACK    CountOfRunningProgramsEnumWindowsProc (HWND hwnd, LPARAM lParam)

{
    if ((GetShellWindow() != hwnd) && IsWindowVisible(hwnd))
    {
        DWORD   dwThreadID, dwProcessID;
        TCHAR   szWindowTitle[256];

        dwThreadID = GetWindowThreadProcessId(hwnd, &dwProcessID);
        if ((InternalGetWindowText(hwnd, szWindowTitle, ARRAYSIZE(szWindowTitle)) > 0) &&
            (szWindowTitle[0] != TEXT('\0')))
        {
            if (!FoundProcessID(reinterpret_cast<tProcessIDList*>(lParam), dwProcessID))
            {
                AddProcessID(reinterpret_cast<tProcessIDList*>(lParam), dwProcessID);
            }
        }
    }
    return(TRUE);
}

DWORD CTray::CountOfRunningPrograms()
{
    tProcessIDList processIDList = {0};
    TBOOL(EnumWindows(CountOfRunningProgramsEnumWindowsProc, reinterpret_cast<LPARAM>(&processIDList)));
    return processIDList.dwCount;
}

//  --------------------------------------------------------------------------
//  CTray::_OnSessionChange
//
//  Arguments:  wParam  =   WTS_xxx notification.
//              lParam  =   WTS_SESSION_NOTIFICATION struct pointer.
//
//  Returns:    LRESULT
//
//  Purpose:    Handles console/remote dis/reconnects.
//
//  History:    2000-07-12  vtan        created
//  --------------------------------------------------------------------------

LRESULT CTray::_OnSessionChange(WPARAM wParam, LPARAM lParam)
{
    ASSERTMSG(DWORD(lParam) == NtCurrentPeb()->SessionId, "Session ID mismatch in CTray::_OnSessionChange");

    if ((WTS_CONSOLE_CONNECT == wParam) || (WTS_REMOTE_CONNECT == wParam) || (WTS_SESSION_UNLOCK == wParam))
    {
        _fIsDesktopConnected = TRUE;
    }
    else if ((WTS_CONSOLE_DISCONNECT == wParam) || (WTS_REMOTE_DISCONNECT == wParam) || (WTS_SESSION_LOCK == wParam))
    {
        _fIsDesktopConnected = FALSE;
    }

    if ((WTS_CONSOLE_CONNECT == wParam) || (WTS_REMOTE_CONNECT == wParam))
    {
        _RefreshStartMenu();
        SHUpdateRecycleBinIcon();
    }
    else if ((WTS_SESSION_LOCK == wParam) || (WTS_SESSION_UNLOCK == wParam))
    {
        if (IsOS(OS_FASTUSERSWITCHING))
        {
            if (wParam == WTS_SESSION_LOCK)
            {
                ExplorerPlaySound(TEXT("WindowsLogoff"));
            }
            else if (wParam == WTS_SESSION_UNLOCK)
            {
                ExplorerPlaySound(TEXT("WindowsLogon"));
            }
        }

        PostMessage(_hwnd, TM_WORKSTATIONLOCKED, (WTS_SESSION_LOCK == wParam), 0);
    }
    else if (WTS_SESSION_REMOTE_CONTROL == wParam)
    {
        // optimization not needed on remote sessions
        if (!GetSystemMetrics(SM_REMOTESESSION)) {
            _BuildStartMenu();
        }
    }

    return 1;
}

LRESULT CTray::_NCPaint(HRGN hrgn)
{
    ASSERT(_hTheme);

    if (_fCanSizeMove || _fShowSizingBarAlways)
    {
        if ((INT_PTR)hrgn == 1)
            hrgn = NULL;

        HDC hdc = GetDCEx( _hwnd, hrgn, DCX_USESTYLE|DCX_WINDOW|DCX_LOCKWINDOWUPDATE|
                    ((hrgn != NULL) ? DCX_INTERSECTRGN|DCX_NODELETERGN : 0));

        if (hdc)
        {
            RECT rc;
            GetWindowRect(_hwnd, &rc);
            OffsetRect(&rc, -rc.left, -rc.top);

            _AdjustRectForSizingBar(_uStuckPlace, &rc, 0);
            DrawThemeBackground(_hTheme, hdc, _GetPart(TRUE, _uStuckPlace), 0, &rc, 0);
            ReleaseDC(_hwnd, hdc);
        }
    }

    return 0;
}

LRESULT CTray::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static  UINT uDDEExec = 0;
    LRESULT lres = 0;
    MSG msg;

    msg.hwnd = hwnd;
    msg.message = uMsg;
    msg.wParam = wParam;
    msg.lParam = lParam;

    if (_pmbStartMenu &&
        _pmbStartMenu->TranslateMenuMessage(&msg, &lres) == S_OK)
        return lres;

    if (_pmbStartPane &&
        _pmbStartPane->TranslateMenuMessage(&msg, &lres) == S_OK)
        return lres;

    if (_pmbTasks &&
        _pmbTasks->TranslateMenuMessage(&msg, &lres) == S_OK)
        return lres;

    wParam = msg.wParam;
    lParam = msg.lParam;

    INSTRUMENT_WNDPROC(SHCNFI_TRAY_WNDPROC, hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WMTRAY_REGISTERHOTKEY:
        return _RegisterHotkey(hwnd, (int)wParam);

    case WMTRAY_UNREGISTERHOTKEY:
        return _UnregisterHotkey(hwnd, (int)wParam);

    case WMTRAY_SCREGISTERHOTKEY:
        return _ShortcutRegisterHotkey(hwnd, (WORD)wParam, (ATOM)lParam);

    case WMTRAY_SCUNREGISTERHOTKEY:
        return _ShortcutUnregisterHotkey(hwnd, (WORD)wParam);

    case WMTRAY_SETHOTKEYENABLE:
        return _SetHotkeyEnable(hwnd, (BOOL)wParam);

    case WMTRAY_QUERY_MENU:
        return (LRESULT)_hmenuStart;

    case WMTRAY_QUERY_VIEW:
        return (LRESULT)_hwndTasks;

    case WMTRAY_TOGGLEQL:
        return _ToggleQL((int)lParam);

    case WM_COPYDATA:
        // Check for NULL it can happen if user runs out of selectors or memory...
        if (lParam)
        {
            switch (((PCOPYDATASTRUCT)lParam)->dwData) {
            case TCDM_NOTIFY:
            {
                BOOL bRefresh = FALSE;

                lres = _trayNotify.TrayNotify(_hwndNotify, (HWND)wParam, (PCOPYDATASTRUCT)lParam, &bRefresh);
                if (bRefresh)
                {
                    SizeWindows();
                }
                return(lres);
            }
            
            case TCDM_APPBAR:
                return _OnAppBarMessage((PCOPYDATASTRUCT)lParam);

            case TCDM_LOADINPROC:
                return (UINT)_LoadInProc((PCOPYDATASTRUCT)lParam);
            }
        }
        return FALSE;

    case WM_NCCALCSIZE:
        if (_hTheme)
        {
            if ((_fCanSizeMove || _fShowSizingBarAlways) && lParam)
            {
                _AdjustRectForSizingBar(_uStuckPlace, (LPRECT)lParam, -1);
            }

            return 0;
        }
        else
        {
            goto L_default;
        }
        break;

    case WM_NCLBUTTONDBLCLK:
        if (!_TryForwardNCToClient(uMsg, lParam))
        {
            if (IsPosInHwnd(lParam, _hwndNotify))
            {
                _Command(IDM_SETTIME);

                // Hack!  If you click on the tray clock, this tells the tooltip
                // "Hey, I'm using this thing; stop putting up a tip for me."
                // You can get the tooltip to lose track of when it needs to
                // reset the "stop it!" flag and you get stuck in "stop it!" mode.
                // It's particularly easy to make happen on Terminal Server.
                //
                // So let's assume that the only reason people click on the
                // tray clock is to change the time.  when they change the time,
                // kick the tooltip in the head to reset the "stop it!" flag.

                SendMessage(_hwndTrayTips, TTM_POP, 0, 0);
            }
        }
        break;

    case WM_NCLBUTTONDOWN:
    case WM_NCLBUTTONUP:
        if (!_TryForwardNCToClient(uMsg, lParam))
        {
            goto L_WM_NCMOUSEMOVE;
        }
        break;

    case WM_NCMOUSEMOVE:
    L_WM_NCMOUSEMOVE:
        if (IsPosInHwnd(lParam, _hwndNotify))
        {
            MSG msgInner;
            msgInner.lParam = lParam;
            msgInner.wParam = wParam;
            msgInner.message = uMsg;
            msgInner.hwnd = hwnd;
            SendMessage(_hwndTrayTips, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msgInner);
            if (uMsg == WM_NCLBUTTONDOWN)
                _SetFocus(_hwndNotify);
        }
        goto DoDefault;

    case WM_CREATE:
        return _OnCreate(hwnd);

    case WM_DESTROY:
        return _HandleDestroy();

#ifdef DEBUG
    case WM_QUERYENDSESSION:
        TraceMsg(DM_SHUTDOWN, "Tray.wp WM_QUERYENDSESSION");
        goto DoDefault;
#endif

    case WM_ENDSESSION:
        // save our settings if we are shutting down
        if (wParam) 
        {
            if (lParam | ENDSESSION_LOGOFF)
            {
                _fIsLogoff = TRUE;
                _RecomputeAllWorkareas();
            }

            _SaveTrayAndDesktop();

            ShowWindow(_hwnd, SW_HIDE);
            ShowWindow(v_hwndDesktop, SW_HIDE);

            DestroyWindow(_hwnd);
        }
        break;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        {
            RECT rc;
            PAINTSTRUCT ps;
            HDC hdc = (HDC)wParam;
            if (hdc == 0)
                hdc = BeginPaint(hwnd, &ps);

            GetClientRect(hwnd, &rc);


            if (_hTheme)
            {
                RECT rcClip;
                if (GetClipBox(hdc, &rcClip) == NULLREGION)
                    rcClip = rc;

                DrawThemeBackground(_hTheme, hdc, _GetPart(FALSE, _uStuckPlace), 0, &rc, &rcClip);
            }
            else
            {
                FillRect(hdc, &rc, (HBRUSH)(COLOR_3DFACE + 1));
                
                // draw etched line around on either side of the bandsite
                MapWindowPoints(HWND_DESKTOP, hwnd, (LPPOINT)&rc, 2);
                InflateRect(&rc, g_cxEdge, g_cyEdge);
                DrawEdge(hdc, &rc, EDGE_ETCHED, BF_TOPLEFT);
            }

            if (wParam == 0)
                EndPaint(hwnd, &ps);
        }
        break;

    case WM_ERASEBKGND:
        if (_hTheme)
        {
            if (!_fSkipErase)
            {
                RECT rc;
                GetClientRect(hwnd, &rc);
                DrawThemeBackground(_hTheme, (HDC)wParam, _GetPart(FALSE, _uStuckPlace), 0, &rc, NULL);

                // Only draw the first time to prevent piece-mail taskbar painting
                _fSkipErase = TRUE;
            }
            return 1;
        }
        else
        {
            goto DoDefault;
        }
        break;

    case WM_NCPAINT:
        if (_hTheme)
        {
            return _NCPaint((HRGN)wParam);
        }
        else
        {
            goto DoDefault;
        }
        break;

    case WM_POWER:
    case WM_POWERBROADCAST:
        _PropagateMessage(hwnd, uMsg, wParam, lParam);
        _HandlePowerStatus(uMsg, wParam, lParam);
        goto DoDefault;

    case WM_DEVICECHANGE:
        lres = _OnDeviceChange(hwnd, wParam, lParam);
        if (lres == 0)
        {
            goto DoDefault;
        }
        break;

    case WM_NOTIFY:
    {
        NMHDR *pnm = (NMHDR*)lParam;
        if (!BandSite_HandleMessage(_ptbs, hwnd, uMsg, wParam, lParam, &lres)) {
            switch (pnm->code)
            {
            case SEN_DDEEXECUTE:
                if (((LPNMHDR)lParam)->idFrom == 0)
                {
                    LPNMVIEWFOLDER pnmPost = DDECreatePostNotify((LPNMVIEWFOLDER)pnm);

                    if (pnmPost)
                    {
                        PostMessage(hwnd, GetDDEExecMsg(), 0, (LPARAM)pnmPost);
                        return TRUE;
                    }
                }
                break;

            case NM_STARTWAIT:
            case NM_ENDWAIT:
                _OnWaitCursorNotify((NMHDR *)lParam);
                PostMessage(v_hwndDesktop, ((NMHDR*)lParam)->code == NM_STARTWAIT ? DTM_STARTWAIT : DTM_ENDWAIT,
                            0, 0); // forward it along
                break;

            case NM_THEMECHANGED:
                // Force the start button to recalc its size
                _sizeStart.cx = 0;
                SizeWindows();
                break;

            case TTN_NEEDTEXT:
                //
                //  Make the clock manage its own tooltip.
                //
                return SendMessage(_GetClockWindow(), WM_NOTIFY, wParam, lParam);

            case TTN_SHOW:
                SetWindowZorder(_hwndTrayTips, HWND_TOP);
                break;

            }
        }
        break;
    }

    case WM_CLOSE:
        _DoExitWindows(v_hwndDesktop);
        break;

    case WM_NCHITTEST:
        {
            RECT r1;
            POINT pt;

            GetClientRect(hwnd, &r1);
            MapWindowPoints(hwnd, NULL, (LPPOINT)&r1, 2);

            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);

            _SetUnhideTimer(pt.x, pt.y);

            // If the user can't size or move the taskbar, then just say
            // they hit something useless
            if (!_fCanSizeMove)
            {
                return HTBORDER;
            }
            else if (PtInRect(&r1, pt))
            {
                // allow dragging if mouse is in client area of _hwnd
                return HTCAPTION;
            }
            else
            {
                return _PtOnResizableEdge(pt, &r1);
            }
        }
        break;

    case WM_WINDOWPOSCHANGING:
        _HandleWindowPosChanging((LPWINDOWPOS)lParam);
        break;

    case WM_ENTERSIZEMOVE:
        DebugMsg(DM_TRAYDOCK, TEXT("Tray -- WM_ENTERSIZEMOVE"));
        g_fInSizeMove = TRUE;
        GetCursorPos((LPPOINT)&_rcSizeMoveIgnore);
        _rcSizeMoveIgnore.right = _rcSizeMoveIgnore.left;
        _rcSizeMoveIgnore.bottom = _rcSizeMoveIgnore.top;
        InflateRect(&_rcSizeMoveIgnore, GetSystemMetrics(SM_CXICON),
                                         GetSystemMetrics(SM_CYICON));

        //
        // unclip the tray from the current monitor.
        // keeping the tray properly clipped in the MoveSize loop is extremely
        // hairy and provides almost no benefit.  we'll re-clip when it lands.
        //
        _ClipWindow(FALSE);

        // Remember the old monitor we were on
        _hmonOld = _hmonStuck;

        // set up for WM_MOVING/WM_SIZING messages
        _uMoveStuckPlace = (UINT)-1;
        _fSysSizing = TRUE;
        
        if (!g_fDragFullWindows)
        {
            SendMessage(_hwndRebar, WM_SETREDRAW, FALSE, 0);
        }
        break;

    case WM_EXITSIZEMOVE:
        DebugMsg(DM_TRAYDOCK, TEXT("Tray -- WM_EXITSIZEMOVE"));

        // done sizing
        _fSysSizing = FALSE;
        _fDeferedPosRectChange = FALSE;

        if (!g_fDragFullWindows)
        {
            SendMessage(_hwndRebar, WM_SETREDRAW, TRUE, 0);
        }

        //
        // kick the size code one last time after the loop is done.
        // NOTE: we rely on the WM_SIZE code re-clipping the tray.
        //
        PostMessage(hwnd, WM_SIZE, 0, 0L);
        g_fInSizeMove = FALSE;
        break;

    case WM_MOVING:
        _HandleMoving(wParam, (LPRECT)lParam);
        break;

    case WM_ENTERMENULOOP:
        // DebugMsg(DM_TRACE, "c.twp: Enter menu loop.");
        _HandleEnterMenuLoop();
        break;

    case WM_EXITMENULOOP:
        // DebugMsg(DM_TRACE, "c.twp: Exit menu loop.");
        _HandleExitMenuLoop();
        break;

    case WM_TIMER:
        if (IDT_SERVICE0 <= wParam && wParam <= IDT_SERVICELAST)
            return _OnTimerService(uMsg, wParam, lParam);
        _HandleTimer(wParam);
        break;

    case WM_SIZING:
        _HandleSizing(wParam, (LPRECT)lParam, _uStuckPlace);
        break;

    case WM_SIZE:
        _HandleSize();
        break;

    case WM_DISPLAYCHANGE:
        // NOTE: we get WM_DISPLAYCHANGE in the below two situations
        // 1. a display size changes (HMON will not change in USER)
        // 2. a display goes away or gets added (HMON will change even if
        // the monitor that went away has nothing to do with our hmonStuck)

        // In the above two situations we actually need to do different things
        // because in 1, we do not want to update our hmonStuck because we might
        // end up on another monitor, but in 2 we do want to update hmonStuck because
        // our hmon is invalid

        // The way we handle this is to call GetMonitorInfo on our old HMONITOR
        // and see if it's still valid, if not, we update it by calling _SetStuckMonitor 
        // all these code is in _ScreenSizeChange;

        _ScreenSizeChange(hwnd);

        // Force the Start Pane to rebuild because a change in color depth
        // causes themes to run around destroying fonts (ruining the OOBE
        // text) and we need to reload our bitmaps for the new color depth
        // anyway.
        ::PostMessage(_hwnd,  SBM_REBUILDMENU, 0, 0);

        break;
    
    // Don't go to default wnd proc for this one...
    case WM_INPUTLANGCHANGEREQUEST:
        return(LRESULT)0L;

    case WM_GETMINMAXINFO:
        ((MINMAXINFO *)lParam)->ptMinTrackSize.x = g_cxFrame;
        ((MINMAXINFO *)lParam)->ptMinTrackSize.y = g_cyFrame;
        break;

    case WM_WININICHANGE:
        if (lParam && (0 == lstrcmpi((LPCTSTR)lParam, TEXT("SaveTaskbar"))))
        {
            _SaveTrayAndDesktop();
        }
        else
        {
            BandSite_HandleMessage(_ptbs, hwnd, uMsg, wParam, lParam, NULL);
            _PropagateMessage(hwnd, uMsg, wParam, lParam);
            _OnWinIniChange(hwnd, wParam, lParam);
        }

        if (lParam)
            TraceMsg(TF_TRAY, "Tray Got: lParam=%s", (LPCSTR)lParam);

        break;

    case WM_TIMECHANGE:
        _PropagateMessage(hwnd, uMsg, wParam, lParam);
        break;

    case WM_SYSCOLORCHANGE:
        _OnNewSystemSizes();
        BandSite_HandleMessage(_ptbs, hwnd, uMsg, wParam, lParam, NULL);
        _PropagateMessage(hwnd, uMsg, wParam, lParam);
        break;

    case WM_SETCURSOR:
        if (_iWaitCount) {
            SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
            return TRUE;
        } else
            goto DoDefault;

    case WM_SETFOCUS:
        IUnknown_UIActivateIO(_ptbs, TRUE, NULL);
        break;

    case WM_SYSCHAR:
        if (wParam == TEXT(' ')) {
            HMENU hmenu;
            int idCmd;

            SHSetWindowBits(hwnd, GWL_STYLE, WS_SYSMENU, WS_SYSMENU);
            hmenu = GetSystemMenu(hwnd, FALSE);
            if (hmenu) {
                EnableMenuItem(hmenu, SC_RESTORE, MFS_GRAYED | MF_BYCOMMAND);
                EnableMenuItem(hmenu, SC_MAXIMIZE, MFS_GRAYED | MF_BYCOMMAND);
                EnableMenuItem(hmenu, SC_MINIMIZE, MFS_GRAYED | MF_BYCOMMAND);
                EnableMenuItem(hmenu, SC_MOVE, (_fCanSizeMove ? MFS_ENABLED : MFS_GRAYED) | MF_BYCOMMAND);
                EnableMenuItem(hmenu, SC_SIZE, (_fCanSizeMove ? MFS_ENABLED : MFS_GRAYED) | MF_BYCOMMAND);

                idCmd = _TrackMenu(hmenu);
                if (idCmd)
                    SendMessage(_hwnd, WM_SYSCOMMAND, idCmd, 0L);
            }
            SHSetWindowBits(hwnd, GWL_STYLE, WS_SYSMENU, 0L);
        }
        break;

    case WM_SYSCOMMAND:

        // if we are sizing, make the full screen accessible
        switch (wParam & 0xFFF0) {
        case SC_CLOSE:
            _DoExitWindows(v_hwndDesktop);
            break;

        default:
            goto DoDefault;
        }
        break;


    case TM_DESKTOPSTATE:
        _OnDesktopState(lParam);
        break;

    case TM_RAISEDESKTOP:
        _RaiseDesktop((BOOL)wParam, FALSE);
        break;

#ifdef DEBUG
    case TM_NEXTCTL:
#endif
    case TM_UIACTIVATEIO:
    case TM_ONFOCUSCHANGEIS:
        _OnFocusMsg(uMsg, wParam, lParam);
        break;

    case TM_MARSHALBS:  // wParam=IID lRes=pstm
        return BandSite_OnMarshallBS(wParam, lParam);

    case TM_SETTIMER:
    case TM_KILLTIMER:
        return _OnTimerService(uMsg, wParam, lParam);
        break;

    case TM_FACTORY:
        return _OnFactoryMessage(wParam, lParam);

    case TM_ACTASTASKSW:
        _ActAsSwitcher();
        break;

    case TM_RELAYPOSCHANGED:
        _AppBarNotifyAll((HMONITOR)lParam, ABN_POSCHANGED, (HWND)wParam, 0);
        break;

    case TM_BRINGTOTOP:
        SetWindowZorder((HWND)wParam, HWND_TOP);
        break;

    case TM_WARNNOAUTOHIDE:
        DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.twp collision UI request"));

        //
        // this may look a little funny but what we do is post this message all
        // over the place and ignore it when we think it is a bad time to put
        // up a message (like the middle of a fulldrag...)
        //
        // wParam tells us if we need to try to clear the state
        // the lowword of _SetAutoHideState's return tells if anything changed
        //
        if ((!_fSysSizing || !g_fDragFullWindows) &&
            (!wParam || LOWORD(_SetAutoHideState(FALSE))))
        {
            ShellMessageBox(hinstCabinet, hwnd,
                MAKEINTRESOURCE(IDS_ALREADYAUTOHIDEBAR),
                MAKEINTRESOURCE(IDS_TASKBAR), MB_OK | MB_ICONINFORMATION);
        }
        else
        {
            DebugMsg(DM_TRAYDOCK, TEXT("TRAYDOCK.twp blowing off extraneous collision UI request"));
        }
        break;

    case TM_PRIVATECOMMAND:
        _HandlePrivateCommand(lParam);
        break;

    case TM_HANDLEDELAYBOOTSTUFF:
        _HandleDelayBootStuff();
        break;

    case TM_SHELLSERVICEOBJECTS:
        _ssomgr.LoadRegObjects();
        break;

    case TM_CHANGENOTIFY:
        _HandleChangeNotify(wParam, lParam);
        break;

    case TM_GETHMONITOR:
        *((HMONITOR *)lParam) = _hmonStuck;
        break;

    case TM_DOTRAYPROPERTIES:
        DoProperties(TPF_TASKBARPAGE);
        break;

    case TM_STARTUPAPPSLAUNCHED:
        PostMessage(_hwndNotify, TNM_STARTUPAPPSLAUNCHED, 0, 0);
        break;

    case TM_LANGUAGEBAND:
        return _ToggleLanguageBand(lParam);
        
    case WM_NCRBUTTONUP:
        uMsg = WM_CONTEXTMENU;
        wParam = (WPARAM)_hwndTasks;
        goto L_WM_CONTEXTMENU;

    case WM_CONTEXTMENU:
    L_WM_CONTEXTMENU:

        if (!SHRestricted(REST_NOTRAYCONTEXTMENU))
        {
            if (((HWND)wParam) == _hwndStart)
            {
                // Don't display of the Start Menu is up.
                if (SendMessage(_hwndStart, BM_GETSTATE, 0, 0) & BST_PUSHED)
                    break;

                _fFromStart = TRUE;

                StartMenuContextMenu(_hwnd, (DWORD)lParam);

                _fFromStart = FALSE;
            } 
            else if (IsPosInHwnd(lParam, _hwndNotify) || SHIsChildOrSelf(_hwndNotify, GetFocus()) == S_OK)
            {
                // if click was inthe clock, include
                // the time
                _ContextMenu((DWORD)lParam, TRUE);
            } 
            else 
            {
                BandSite_HandleMessage(_ptbs, hwnd, uMsg, wParam, lParam, &lres);
            }
        }
        break;

    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_MENUCHAR:
        // Don't call bandsite message handler when code path started via the start button context menu
        if (!_fFromStart)
        {
            BandSite_HandleMessage(_ptbs, hwnd, uMsg, wParam, lParam, &lres);
        }
        break;

    case TM_DOEXITWINDOWS:
        _DoExitWindows(v_hwndDesktop);
        break;

    case TM_HANDLESTARTUPFAILED:
        _OnHandleStartupFailed();
        break;

    case WM_HOTKEY:
        if (wParam < GHID_FIRST)
        {
            _HandleHotKey((WORD)wParam);
        }
        else
        {
            _HandleGlobalHotkey(wParam);
        }
        break;

    case WM_COMMAND:
        if (!BandSite_HandleMessage(_ptbs, hwnd, uMsg, wParam, lParam, &lres))
            _Command(GET_WM_COMMAND_ID(wParam, lParam));
        break;

    case SBM_CANCELMENU:
        ClosePopupMenus();
        break;

    case SBM_REBUILDMENU:
        _BuildStartMenu();
        break;

    case WM_WINDOWPOSCHANGED:
        _AppBarActivationChange2(hwnd, _uStuckPlace);
        SendMessage(_hwndNotify, TNM_TRAYPOSCHANGED, 0, 0);
        goto DoDefault;

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
        if (_hwndStartBalloon)
        {
            RECT rc;
            POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
            GetWindowRect(_hwndStartBalloon, &rc);
            MapWindowRect(HWND_DESKTOP, _hwnd, &rc);

            if (PtInRect(&rc, pt))
            {
                ShowWindow(_hwndStartBalloon, SW_HIDE);
                _DontShowTheStartButtonBalloonAnyMore();
                _DestroyStartButtonBalloon();
            }
        }
        break;

    case TM_SETPUMPHOOK:
        ATOMICRELEASE(_pmbTasks);
        ATOMICRELEASE(_pmpTasks);
        if (wParam && lParam)
        {
            _pmbTasks = (IMenuBand*)wParam;
            _pmbTasks->AddRef();
            _pmpTasks = (IMenuPopup*)lParam;
            _pmpTasks->AddRef();
        }
        break;
        
    case WM_ACTIVATE:
        _AppBarActivationChange2(hwnd, _uStuckPlace);
        if (wParam != WA_INACTIVE)
        {
            Unhide();
        }
        else
        {
            // When tray is deactivated, remove our keyboard cues:
            //
            SendMessage(hwnd, WM_CHANGEUISTATE,
                MAKEWPARAM(UIS_SET, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);

            IUnknown_UIActivateIO(_ptbs, FALSE, NULL);
        }
        //
        // Tray activation is a good time to do a reality check
        // (make sure "always-on-top" agrees with actual window
        // position, make sure there are no ghost buttons, etc).
        //
        RealityCheck();
        goto L_default;

    case WM_WTSSESSION_CHANGE:
    {
        lres = _OnSessionChange(wParam, lParam);
        break;
    }

    case WM_THEMECHANGED:
        {
            if (_hTheme)
            {
                CloseThemeData(_hTheme);
                _hTheme = NULL;
            }
            if (wParam)
            {
                _hTheme = OpenThemeData(_hwnd, c_wzTaskbarTheme);
                _fShowSizingBarAlways = (_uAutoHide & AH_ON) ? TRUE : FALSE;
                if (_hTheme)
                {
                    GetThemeBool(_hTheme, 0, 0, TMT_ALWAYSSHOWSIZINGBAR, &_fShowSizingBarAlways);
                }
                _UpdateVertical(_uStuckPlace, TRUE);
                // Force Refresh of frame
                SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);
            }

            // Force the start button to recalc its size
            _sizeStart.cx = 0;
            _StartButtonReset();
            InvalidateRect(_hwnd, NULL, TRUE);

            // Force the Start Pane to rebuild with new theme
            ::PostMessage(_hwnd,  SBM_REBUILDMENU, 0, 0);

            SetWindowStyle(_hwnd, WS_BORDER | WS_THICKFRAME, !_hTheme);
        }
        break;

    case TM_WORKSTATIONLOCKED:
        {
            // Desktop locked status changed...
            BOOL fIsDesktopLocked = (BOOL) wParam;
            if (_fIsDesktopLocked != fIsDesktopLocked)
            {
                _fIsDesktopLocked = fIsDesktopLocked;
                _fIsLogoff = FALSE;
                _RecomputeAllWorkareas();
                PostMessage(_hwndNotify, TNM_WORKSTATIONLOCKED, wParam, 0);
            }
        }
        break;

    case TM_SHOWTRAYBALLOON:
        PostMessage(_hwndNotify, TNM_SHOWTRAYBALLOON, wParam, 0);
        break;

    case TM_STARTMENUDISMISSED:
        //  107561 - call CoFreeUnusedLibraries() peridically to free up dlls - ZekeL - 4-MAY-2001
        //  specifically to support MSONSEXT (webfolders) being used in RecentDocs
        //  after a file has been opened via webfolders.  we get the icon via
        //  their namespace but then COM holds on to the DLL for a while (forever?)
        //  calling CoFreeUnusedLibraries() does the trick
        SetTimer(_hwnd, IDT_COFREEUNUSED, 3 * 60 * 1000, NULL);
        break;

    case MM_MIXM_CONTROL_CHANGE:
        Mixer_ControlChange(wParam, lParam);
        break;

    default:
    L_default:
        if (uMsg == GetDDEExecMsg())
        {
            ASSERT(lParam && 0 == ((LPNMHDR)lParam)->idFrom);
            DDEHandleViewFolderNotify(NULL, _hwnd, (LPNMVIEWFOLDER)lParam);
            LocalFree((LPNMVIEWFOLDER)lParam);
            return TRUE;
        }
        else if (uMsg == _uStartButtonBalloonTip)
        {
            _ShowStartButtonToolTip();
        }
        else if (uMsg == _uLogoffUser)
        {
            // Log off the current user (message from U&P control panel)
            ExitWindowsEx(EWX_LOGOFF, 0);
        }
        else if (uMsg == _uMsgEnableUserTrackedBalloonTips)
        {
            PostMessage(_hwndNotify, TNM_ENABLEUSERTRACKINGINFOTIPS, wParam, 0);
        }
        else if (uMsg == _uWinMM_DeviceChange)
        {
            Mixer_MMDeviceChange();
        }


DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return lres;
}

void CTray::_DoExitWindows(HWND hwnd)
{
    static BOOL s_fShellShutdown = FALSE;

    if (!s_fShellShutdown)
    {

        if (_Restricted(hwnd, REST_NOCLOSE))
            return;

        {
            UEMFireEvent(&UEMIID_SHELL, UEME_CTLSESSION, UEMF_XEVENT, FALSE, -1);
            // really #ifdef DEBUG, but want for testing
            // however can't do unconditionally due to perf
            if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, TEXT("StartMenuForceRefresh"), 
                NULL, NULL, NULL) || GetAsyncKeyState(VK_SHIFT) < 0)
            {
                _RefreshStartMenu();
            }
        }

        _SaveTrayAndDesktop();

        _uModalMode = MM_SHUTDOWN;
        ExitWindowsDialog(hwnd);

        // NB User can have problems if the focus is forcebly changed to the desktop while
        // shutting down since it tries to serialize the whole process by making windows sys-modal.
        // If we hit this code at just the wrong moment (ie just after the sharing dialog appears)
        // the desktop will become sys-modal so you can't switch back to the sharing dialog
        // and you won't be able to shutdown.
        // SetForegroundWindow(hwnd);
        // SetFocus(hwnd);

        _uModalMode = 0;
        if ((GetKeyState(VK_SHIFT) < 0) && (GetKeyState(VK_CONTROL) < 0) && (GetKeyState(VK_MENU) < 0))
        {
            // User cancelled...
            // The shift key means exit the tray...
            // ??? - Used to destroy all cabinets...
            // PostQuitMessage(0);
            g_fFakeShutdown = TRUE; // Don't blow away session state; the session will survive
            TraceMsg(TF_TRAY, "c.dew: Posting quit message for tid=%#08x hwndDesk=%x(IsWnd=%d) hwndTray=%x(IsWnd=%d)", GetCurrentThreadId(),
            v_hwndDesktop,IsWindow(v_hwndDesktop), _hwnd,IsWindow(_hwnd));
            // 1 means close all the shell windows too
            PostMessage(v_hwndDesktop, WM_QUIT, 0, 1);
            PostMessage(_hwnd, WM_QUIT, 0, 0);

            s_fShellShutdown = TRUE;
        }
    }
}



void CTray::_SaveTray(void)
{
    if (SHRestricted(REST_NOSAVESET)) 
        return;

    if (SHRestricted(REST_CLEARRECENTDOCSONEXIT))
        ClearRecentDocumentsAndMRUStuff(FALSE);

    //
    // Don't persist tray stuff if in safe mode.  We want this
    // to be a temporary mode where the UI settings don't stick.
    //
    if (GetSystemMetrics(SM_CLEANBOOT) == 0)
    {
        _SaveTrayStuff();
    }
}

DWORD WINAPI CTray::PropertiesThreadProc(void* pv)
{
    return c_tray._PropertiesThreadProc(PtrToUlong(pv));
}

DWORD CTray::_PropertiesThreadProc(DWORD dwFlags)
{
    HWND hwnd;
    RECT rc;
    DWORD dwExStyle = WS_EX_TOOLWINDOW;

    GetWindowRect(_hwndStart, &rc);
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;

    _hwndProp = hwnd = CreateWindowEx(dwExStyle, TEXT("static"), NULL, 0   ,
        rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, NULL, NULL, hinstCabinet, NULL);

    #define IDI_STTASKBR 40         // stolen from shell32\ids.h
    if (_hwndProp)
    {
        // Get the Alt+Tab icon right
        HICON hicoStub = LoadIcon(GetModuleHandle(TEXT("SHELL32")), MAKEINTRESOURCE(IDI_STTASKBR));
        SendMessage(_hwndProp, WM_SETICON, ICON_BIG, (LPARAM)hicoStub);

        // SwitchToThisWindow(hwnd, TRUE);
        // SetForegroundWindow(hwnd);

        DoTaskBarProperties(hwnd, dwFlags);

        _hwndProp = NULL;
        DestroyWindow(hwnd);
        if (hicoStub)
            DestroyIcon(hicoStub);
    }

    return TRUE;
}

#define RUNWAITSECS 5
void CTray::DoProperties(DWORD dwFlags)
{
    if (!_Restricted(_hwnd, REST_NOSETTASKBAR))
    {
        int i = RUNWAITSECS;
        while (_hwndProp == ((HWND)-1) &&i--)
        {
            // we're in the process of coming up. wait
            Sleep(1000);
        }

        // failed!  blow it off.
        if (_hwndProp == (HWND)-1)
        {
            _hwndProp = NULL;
        }

        if (_hwndProp)
        {
            // there's a window out there... activate it
            SwitchToThisWindow(GetLastActivePopup(_hwndProp), TRUE);
        }
        else
        {
            _hwndProp = (HWND)-1;
            if (!SHCreateThread(PropertiesThreadProc, IntToPtr(dwFlags), CTF_COINIT, NULL))
            {
                _hwndProp = NULL;
            }
        }
    }
}

BOOL CTray::TileEnumProc(HWND hwnd, LPARAM lParam)
{
    CTray* ptray = (CTray*)lParam;

    if (IsWindowVisible(hwnd) && !IsIconic(hwnd) &&
        ((GetWindowLong(hwnd, GWL_STYLE) & WS_CAPTION) == WS_CAPTION) &&
        (hwnd != ptray->_hwnd) && hwnd != v_hwndDesktop)
    {
        return FALSE;   // we *can* tile this guy
    }
    return TRUE;    // we *cannot* tile this guy
}

HMENU CTray::BuildContextMenu(BOOL fIncludeTime)
{
    HMENU hmContext = LoadMenuPopup(MAKEINTRESOURCE(MENU_TRAYCONTEXT));
    if (!hmContext)
        return NULL;

    if (fIncludeTime)
    {
        if (_trayNotify.GetIsNoTrayItemsDisplayPolicyEnabled())
        {
            // We know the position of IDM_NOTIFYCUST from the menu resource...
            DeleteMenu(hmContext, 1, MF_BYPOSITION);
        }
        else
        {
            UINT uEnable = MF_BYCOMMAND;
            if (_trayNotify.GetIsNoAutoTrayPolicyEnabled() || !_trayNotify.GetIsAutoTrayEnabledByUser())
            {
                uEnable |= MFS_DISABLED;
            }
            else
            {
                uEnable |= MFS_ENABLED;
            }
            EnableMenuItem(hmContext, IDM_NOTIFYCUST, uEnable);
        }
    }
    else
    {
        INSTRUMENT_STATECHANGE(SHCNFI_STATE_TRAY_CONTEXT);
        for (int i = 2; i >= 0; i--)    // separator, IDM_SETTIME, IDM_NOTIFYCUST,
        {
            DeleteMenu(hmContext, i, MF_BYPOSITION);
        }
    }

    CheckMenuItem(hmContext, IDM_LOCKTASKBAR,
        MF_BYCOMMAND | (_fCanSizeMove ? MF_UNCHECKED : MF_CHECKED));

    // Don't let users accidentally check lock the taskbar when the taskbar is zero height
    RECT rc;
    GetClientRect(_hwnd, &rc);
    EnableMenuItem(hmContext, IDM_LOCKTASKBAR,
        MF_BYCOMMAND | ((_IsSizeMoveRestricted() || (RECTHEIGHT(rc) == 0)) ? MFS_DISABLED : MFS_ENABLED));

    if (!_fUndoEnabled || !_pPositions)
    {
        DeleteMenu(hmContext, IDM_UNDO, MF_BYCOMMAND);
    }
    else
    {
        TCHAR szTemplate[30];
        TCHAR szCommand[30];
        TCHAR szMenu[64];
        LoadString(hinstCabinet, IDS_UNDOTEMPLATE, szTemplate, ARRAYSIZE(szTemplate));
        LoadString(hinstCabinet, _pPositions->idRes, szCommand, ARRAYSIZE(szCommand));
        StringCchPrintf(szMenu, ARRAYSIZE(szMenu), szTemplate, szCommand);
        ModifyMenu(hmContext, IDM_UNDO, MF_BYCOMMAND | MF_STRING, IDM_UNDO, szMenu);
    }

    if (g_fDesktopRaised)
    {
        TCHAR szHideDesktop[64];
        LoadString(hinstCabinet, IDS_HIDEDESKTOP, szHideDesktop, ARRAYSIZE(szHideDesktop));
        ModifyMenu(hmContext, IDM_TOGGLEDESKTOP, MF_BYCOMMAND | MF_STRING, IDM_TOGGLEDESKTOP, szHideDesktop);
    }
    
    if (!_CanTileAnyWindows())
    {
        EnableMenuItem(hmContext, IDM_CASCADE, MFS_GRAYED | MF_BYCOMMAND);
        EnableMenuItem(hmContext, IDM_HORIZTILE, MFS_GRAYED | MF_BYCOMMAND);
        EnableMenuItem(hmContext, IDM_VERTTILE, MFS_GRAYED | MF_BYCOMMAND);
    }

    HKEY hKeyPolicy;
    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"),
                      0, KEY_READ, &hKeyPolicy) == ERROR_SUCCESS)
    {
        DWORD dwType, dwData = 0, dwSize = sizeof(dwData);
        RegQueryValueEx(hKeyPolicy, TEXT("DisableTaskMgr"), NULL,
                         &dwType, (LPBYTE) &dwData, &dwSize);
        RegCloseKey(hKeyPolicy);
        if (dwData)
            EnableMenuItem(hmContext, IDM_SHOWTASKMAN, MFS_GRAYED | MF_BYCOMMAND);
    }

    return hmContext;
}

void CTray::ContextMenuInvoke(int idCmd)
{
    if (idCmd)
    {
        if (idCmd < IDM_TRAYCONTEXTFIRST)
        {
            BandSite_HandleMenuCommand(_ptbs, idCmd);
        }
        else
        {
            _Command(idCmd);
        }
    }
}

//
//  CTray::AsyncSaveSettings
//
//  We need to save our tray settings, but there may be a bunch
//  of these calls coming, (at startup time or when dragging 
//  items in the task bar) so gather them up into one save that
//  will happen in at least 2 seconds.
//
void CTray::AsyncSaveSettings()
{
    if (!_fHandledDelayBootStuff)        // no point in saving if we're not done booting
        return;

    KillTimer(_hwnd, IDT_SAVESETTINGS);
    SetTimer(_hwnd, IDT_SAVESETTINGS, 2000, NULL); 
}


void CTray::_ContextMenu(DWORD dwPos, BOOL fIncludeTime)
{
    POINT pt = {LOWORD(dwPos), HIWORD(dwPos)};

    SwitchToThisWindow(_hwnd, TRUE);
    SetForegroundWindow(_hwnd);
    SendMessage(_hwndTrayTips, TTM_ACTIVATE, FALSE, 0L);

    if (dwPos != (DWORD)-1 &&
        IsChildOrHWND(_hwndRebar, WindowFromPoint(pt)))
    {
        // if the context menu came from below us, reflect down
        BandSite_HandleMessage(_ptbs, _hwnd, WM_CONTEXTMENU, 0, dwPos, NULL);

    }
    else
    {
        HMENU hmenu;

        if (dwPos == (DWORD)-1)
        {
            HWND hwnd = GetFocus();
            pt.x = pt.y = 0;
            ClientToScreen(hwnd, &pt);
            dwPos = MAKELONG(pt.x, pt.y);
        }

        hmenu = BuildContextMenu(fIncludeTime);
        if (hmenu)
        {
            int idCmd;

            BandSite_AddMenus(_ptbs, hmenu, 0, 0, IDM_TRAYCONTEXTFIRST);

            idCmd = TrackPopupMenu(hmenu, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                                   GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos), 0, _hwnd, NULL);

            DestroyMenu(hmenu);

            ContextMenuInvoke(idCmd);
        }
    }

    SendMessage(_hwndTrayTips, TTM_ACTIVATE, TRUE, 0L);
}

void _RunFileDlg(HWND hwnd, UINT idIcon, LPCITEMIDLIST pidlWorkingDir, UINT idTitle, UINT idPrompt, DWORD dwFlags)
{
    HICON hIcon;
    LPCTSTR lpszTitle;
    LPCTSTR lpszPrompt;
    TCHAR szTitle[256];
    TCHAR szPrompt[256];
    TCHAR szWorkingDir[MAX_PATH];

    dwFlags |= RFD_USEFULLPATHDIR;
    szWorkingDir[0] = 0;

    hIcon = idIcon ? LoadIcon(hinstCabinet, MAKEINTRESOURCE(idIcon)) : NULL;

    if (!pidlWorkingDir || !SHGetPathFromIDList(pidlWorkingDir, szWorkingDir))
    {
        // This is either the Tray, or some non-file system folder, so
        // we will "suggest" the Desktop as a working dir, but if the
        // user types a full path, we will use that instead.  This is
        // what WIN31 Progman did (except they started in the Windows
        // dir instead of the Desktop).
        goto UseDesktop;
    }

    // if it's a removable dir, make sure it's still there
    if (szWorkingDir[0])
    {
        int idDrive = PathGetDriveNumber(szWorkingDir);
        if ((idDrive != -1))
        {
            UINT dtype = DriveType(idDrive);
            if (((dtype == DRIVE_REMOVABLE) || (dtype == DRIVE_CDROM))
                 && !PathFileExists(szWorkingDir))
            {
                goto UseDesktop;
            }
        }
    }

    //
    // Check if this is a directory. Notice that it could be a in-place
    // navigated document.
    //
    if (PathIsDirectory(szWorkingDir)) {
        goto UseWorkingDir;
    }

UseDesktop:
    SHGetSpecialFolderPath(hwnd, szWorkingDir, CSIDL_DESKTOPDIRECTORY, FALSE);

UseWorkingDir:

    if (idTitle)
    {
        LoadString(hinstCabinet, idTitle, szTitle, ARRAYSIZE(szTitle));
        lpszTitle = szTitle;
    }
    else
        lpszTitle = NULL;
    if (idPrompt)
    {
        LoadString(hinstCabinet, idPrompt, szPrompt, ARRAYSIZE(szPrompt));
        lpszPrompt = szPrompt;
    }
    else
        lpszPrompt = NULL;

    RunFileDlg(hwnd, hIcon, szWorkingDir, lpszTitle, lpszPrompt, dwFlags);
}

BOOL CTray::SavePosEnumProc(HWND hwnd, LPARAM lParam)
{
    // dont need to entercritical here since we are only ever
    // called from SaveWindowPositions, which as already entered the critical secion
    // for _pPositions

    ASSERTCRITICAL;

    CTray* ptray = (CTray*)lParam;

    ASSERT(ptray->_pPositions);

    if (IsWindowVisible(hwnd) &&
        (hwnd != ptray->_hwnd) &&
        (hwnd != v_hwndDesktop))
    {
        HWNDANDPLACEMENT hap;

        hap.wp.length = sizeof(WINDOWPLACEMENT);
        GetWindowPlacement(hwnd, &hap.wp);

        if (hap.wp.showCmd != SW_SHOWMINIMIZED)
        {
            hap.hwnd = hwnd;
            hap.fRestore = TRUE;

            DSA_AppendItem(ptray->_pPositions->hdsaWP, &hap);
        }
    }
    return TRUE;
}

void CTray::SaveWindowPositions(UINT idRes)
{
    ENTERCRITICAL;
    if (_pPositions)
    {
        if (_pPositions->hdsaWP)
            DSA_DeleteAllItems(_pPositions->hdsaWP);
    }
    else
    {
        _pPositions = (LPWINDOWPOSITIONS)LocalAlloc(LPTR, sizeof(WINDOWPOSITIONS));
        if (_pPositions)
        {
            _pPositions->hdsaWP = DSA_Create(sizeof(HWNDANDPLACEMENT), 4);
        }
    }

    if (_pPositions)
    {
        _pPositions->idRes = idRes;

        // CheckWindowPositions tested for these...
        ASSERT(idRes == IDS_MINIMIZEALL || idRes == IDS_CASCADE || idRes == IDS_TILE);
        EnumWindows(SavePosEnumProc, (LPARAM)this);
    }
    LEAVECRITICAL;
}

typedef struct
{
    LPWINDOWPOSITIONS pPositions;
    HWND hwndDesktop;
    HWND hwndTray;
    BOOL fPostLowerDesktop;
} RESTOREWNDDATA, *PRESTOREWNDDATA;

DWORD WINAPI RestoreWndPosThreadProc(void* pv)
{
    PRESTOREWNDDATA pWndData = (PRESTOREWNDDATA)pv;
    if (pWndData && pWndData->pPositions)
    {
        LPHWNDANDPLACEMENT phap;
        LONG iAnimate;
        ANIMATIONINFO ami;

        ami.cbSize = sizeof(ANIMATIONINFO);
        SystemParametersInfo(SPI_GETANIMATION, sizeof(ami), &ami, FALSE);
        iAnimate = ami.iMinAnimate;
        ami.iMinAnimate = FALSE;
        SystemParametersInfo(SPI_SETANIMATION, sizeof(ami), &ami, FALSE);

        if (pWndData->pPositions->hdsaWP)
        {
            for (int i = DSA_GetItemCount(pWndData->pPositions->hdsaWP) - 1 ; i >= 0; i--)
            {
                phap = (LPHWNDANDPLACEMENT)DSA_GetItemPtr(pWndData->pPositions->hdsaWP, i);
                if (IsWindow(phap->hwnd))
                {

#ifndef WPF_ASYNCWINDOWPLACEMENT
#define WPF_ASYNCWINDOWPLACEMENT 0x0004
#endif
                    // pass this async.
                    if (!IsHungAppWindow(phap->hwnd))
                    {
                        phap->wp.length = sizeof(WINDOWPLACEMENT);
                        phap->wp.flags |= WPF_ASYNCWINDOWPLACEMENT;
                        if (phap->fRestore)
                        {
                            // only restore those guys we've actually munged.
                            SetWindowPlacement(phap->hwnd, &phap->wp);
                        }
                    }
                }
            }
        }

        ami.iMinAnimate = iAnimate;
        SystemParametersInfo(SPI_SETANIMATION, sizeof(ami), &ami, FALSE);

        _DestroySavedWindowPositions(pWndData->pPositions);

        if (pWndData->fPostLowerDesktop)
        {
            PostMessage(pWndData->hwndDesktop, DTM_RAISE, (WPARAM)pWndData->hwndTray, DTRF_LOWER);
        }

        delete pWndData;
    }

    return 1;
}


BOOL CTray::_RestoreWindowPositions(BOOL fPostLowerDesktop)
{
    BOOL fRet = FALSE;

    ENTERCRITICAL;
    if (_pPositions)
    {
        PRESTOREWNDDATA pWndData = new RESTOREWNDDATA;
        if (pWndData)
        {
            pWndData->pPositions = _pPositions;
            pWndData->fPostLowerDesktop = fPostLowerDesktop;
            pWndData->hwndDesktop = v_hwndDesktop;
            pWndData->hwndTray = _hwnd;

            if (SHCreateThread(RestoreWndPosThreadProc, pWndData, 0, NULL))
            {
                fRet = TRUE;
                _pPositions = NULL;
            }
            else
            {
                delete pWndData;
            }
        }
    }
    LEAVECRITICAL;

    return fRet;
}

void _DestroySavedWindowPositions(LPWINDOWPOSITIONS pPositions)
{
    ENTERCRITICAL;
    if (pPositions)
    {
        // free the global struct
        DSA_Destroy(pPositions->hdsaWP);
        LocalFree(pPositions);
    }
    LEAVECRITICAL;
}

void CTray::HandleWindowDestroyed(HWND hwnd)
{
    // enter critical section so we dont corrupt the hdsaWP
    ENTERCRITICAL;
    if (_pPositions)
    {
        int i = DSA_GetItemCount(_pPositions->hdsaWP) - 1;
        for (; i >= 0; i--) {
            LPHWNDANDPLACEMENT phap = (LPHWNDANDPLACEMENT)DSA_GetItemPtr(_pPositions->hdsaWP, i);
            if (phap->hwnd == hwnd || !IsWindow(phap->hwnd)) {
                DSA_DeleteItem(_pPositions->hdsaWP, i);
            }
        }

        if (!DSA_GetItemCount(_pPositions->hdsaWP))
        {
            _DestroySavedWindowPositions(_pPositions);
            _pPositions = NULL;
        }
    }
    LEAVECRITICAL;
}

// Allow us to bump the activation of the run dlg hidden window.
// Certain apps (Norton Desktop setup) use the active window at RunDlg time
// as the parent for their dialogs. If that window disappears then they fault.
// We don't want the tray to get the activation coz it will cause it to appeare
// if you're in auto-hide mode.
LRESULT WINAPI RunDlgStaticSubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_ACTIVATE:
        if (wParam == WA_ACTIVE)
        {
            // Bump the activation to the desktop.
            if (v_hwndDesktop)
            {
                SetForegroundWindow(v_hwndDesktop);
                return 0;
            }
        }
        break;

    case WM_NOTIFY:
        // relay it to the tray
        return SendMessage(v_hwndTray, uMsg, wParam, lParam);
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

DWORD WINAPI CTray::RunDlgThreadProc(void *pv)
{
    return c_tray._RunDlgThreadProc((HANDLE)pv);
}

BOOL _IsBrowserWindow(HWND hwnd)
{
    static const TCHAR* c_szClasses[] =
    {
        TEXT("ExploreWClass"),
        TEXT("CabinetWClass"),
        TEXT("IEFrame"),
    };

    TCHAR szClass[32];
    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));

    for (int i = 0; i < ARRAYSIZE(c_szClasses); i++)
    {
        if (lstrcmpi(szClass, c_szClasses[i]) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}

DWORD CTray::_RunDlgThreadProc(HANDLE hdata)
{
    RECT            rc, rcTemp;
    HRESULT hrInit = SHCoInitialize();

    // 99/04/12 #316424 vtan: Get the rectangle for the "Start" button.
    // If this is off the screen the tray is probably in auto hide mode.
    // In this case offset the rectangle into the monitor where it should
    // belong. This may be up, down, left or right depending on the
    // position of the tray.

    // First thing to do is to establish the dimensions of the monitor on
    // which the tray resides. If no monitor can be found then use the
    // primary monitor.

    MONITORINFO monitorInfo;
    monitorInfo.cbSize = sizeof(monitorInfo);
    if (GetMonitorInfo(_hmonStuck, &monitorInfo) == 0)
    {
        TBOOL(SystemParametersInfo(SPI_GETWORKAREA, 0, &monitorInfo.rcMonitor, 0));
    }

    // Get the co-ordinates of the "Start" button.

    GetWindowRect(_hwndStart, &rc);

    // Look for an intersection in the monitor.

    if (IntersectRect(&rcTemp, &rc, &monitorInfo.rcMonitor) == 0)
    {
        LONG    lDeltaX, lDeltaY;

        // Does not exist in the monitor. Move the co-ordinates by the
        // width or height of the tray so that it does.

        // This bizarre arithmetic is used because _ComputeHiddenRect()
        // takes into account the frame and that right/bottom of RECT
        // is exclusive in GDI.

        lDeltaX = _sStuckWidths.cx - g_cxFrame;
        lDeltaY = _sStuckWidths.cy - g_cyFrame;
        if (rc.left < monitorInfo.rcMonitor.left)
        {
            --lDeltaX;
            lDeltaY = 0;
        }
        else if (rc.top < monitorInfo.rcMonitor.top)
        {
            lDeltaX = 0;
            --lDeltaY;
        }
        else if (rc.right > monitorInfo.rcMonitor.right)
        {
            lDeltaX = -lDeltaX;
            lDeltaY = 0;
        }
        else if (rc.bottom > monitorInfo.rcMonitor.bottom)
        {
            lDeltaX = 0;
            lDeltaY = -lDeltaY;
        }
        TBOOL(OffsetRect(&rc, lDeltaX, lDeltaY));
    }

    HWND hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, TEXT("static"), NULL, 0   ,
        rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, NULL, NULL, hinstCabinet, NULL);
    if (hwnd)
    {
        BOOL fSimple = FALSE;
        HANDLE hMemWorkDir = NULL;
        LPITEMIDLIST pidlWorkingDir = NULL;

        // Subclass it.
        SubclassWindow(hwnd, RunDlgStaticSubclassWndProc);

        if (hdata)
            SetProp(hwnd, TEXT("WaitingThreadID"), hdata);

        if (!SHRestricted(REST_STARTRUNNOHOMEPATH))
        {
            // On NT, we like to start apps in the HOMEPATH directory.  This
            // should be the current directory for the current process.
            TCHAR szDir[MAX_PATH];
            TCHAR szPath[MAX_PATH];

            GetEnvironmentVariable(TEXT("HOMEDRIVE"), szDir, ARRAYSIZE(szDir));
            GetEnvironmentVariable(TEXT("HOMEPATH"), szPath, ARRAYSIZE(szPath));

            if (PathAppend(szDir, szPath) && PathIsDirectory(szDir))
            {
                pidlWorkingDir = SHSimpleIDListFromPath(szDir);
                if (pidlWorkingDir)
                {
                    // free it the "simple" way...
                    fSimple = TRUE;
                }
            }
        }
        
        if (!pidlWorkingDir)
        {
            // If the last active window was a folder/explorer window with the
            // desktop as root, use its as the current dir
            if (_hwndLastActive)
            {
                ENTERCRITICAL;
                if (_hwndLastActive && !IsMinimized(_hwndLastActive) && _IsBrowserWindow(_hwndLastActive))
                {
                    SendMessageTimeout(_hwndLastActive, CWM_CLONEPIDL, GetCurrentProcessId(), 0, SMTO_ABORTIFHUNG | SMTO_BLOCK, 500, (DWORD_PTR*)&hMemWorkDir);
                    pidlWorkingDir = (LPITEMIDLIST)SHLockShared(hMemWorkDir, GetCurrentProcessId());
                }
                LEAVECRITICAL;
            }
        }

        _RunFileDlg(hwnd, 0, pidlWorkingDir, 0, 0, 0);
        if (pidlWorkingDir)
        {
            if (fSimple)
            {
                ILFree(pidlWorkingDir);
            }
            else
            {
                SHUnlockShared(pidlWorkingDir);
            }
        }

        if (hMemWorkDir)
        {
            ASSERT(fSimple == FALSE);
            SHFreeShared(hMemWorkDir, GetCurrentProcessId());
        }

        if (hdata)
        {
            RemoveProp(hwnd, TEXT("WaitingThreadID"));
        }

        DestroyWindow(hwnd);
    }
   
    SHCoUninitialize(hrInit);
    return TRUE;
}

void CTray::_RunDlg()
{
    HANDLE hEvent;
    void *pvThreadParam;

    if (!_Restricted(_hwnd, REST_NORUN))
    {
        TCHAR szRunDlgTitle[MAX_PATH];
        HWND  hwndOldRun;
        LoadString(hinstCabinet, IDS_RUNDLGTITLE, szRunDlgTitle, ARRAYSIZE(szRunDlgTitle));

        // See if there is already a run dialog up, and if so, try to activate it

        hwndOldRun = FindWindow(WC_DIALOG, szRunDlgTitle);
        if (hwndOldRun)
        {
            DWORD dwPID;

            GetWindowThreadProcessId(hwndOldRun, &dwPID);
            if (dwPID == GetCurrentProcessId())
            {
                if (IsWindowVisible(hwndOldRun))
                {
                    SetForegroundWindow(hwndOldRun);
                    return;
                }
            }
        }

        // Create an event so we can wait for the run dlg to appear before
        // continue - this allows it to capture any type-ahead.
        hEvent = CreateEvent(NULL, TRUE, FALSE, TEXT("MSShellRunDlgReady"));
        if (hEvent)
            pvThreadParam = IntToPtr(GetCurrentThreadId());
        else
            pvThreadParam = NULL;

        if (SHQueueUserWorkItem(RunDlgThreadProc, pvThreadParam, 0, 0, NULL, NULL, TPS_LONGEXECTIME | TPS_DEMANDTHREAD))
        {
            if (hEvent)
            {
                SHProcessMessagesUntilEvent(NULL, hEvent, 10 * 1000);
                DebugMsg(DM_TRACE, TEXT("c.t_rd: Done waiting."));
            }
        }

        if (hEvent)
            CloseHandle(hEvent);
    }
}

void CTray::_ExploreCommonStartMenu(BOOL bExplore)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH + 50];
    
    //
    // Get the common start menu path.
    //
    // we want to force the directory to exist, but not on W95 machines
    if (!SHGetSpecialFolderPath(NULL, szPath, CSIDL_COMMON_STARTMENU, FALSE)) 
    {
        return;
    }
    
    //
    // If we are starting in explorer view, then the command line
    // has a "/e, " before the quoted diretory.
    //
    
    if (bExplore) 
    {
        StringCchCopy(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("explorer.exe /e, \""));
    }
    else 
    {
        StringCchCopy(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("explorer.exe \""));
    }
    
    StringCchCat(szCmdLine, ARRAYSIZE(szCmdLine), szPath);
    StringCchCat(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("\""));
    
    // Initialize process startup info
    STARTUPINFO si = {0};
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_SHOWNORMAL;
    
    // Start explorer
    PROCESS_INFORMATION pi = {0};
    if (CreateProcess(NULL, szCmdLine, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi)) 
    {
        // Close the process and thread handles
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
}

int CTray::_GetQuickLaunchID()
{
    int iQLBandID = -1;
   
    DWORD dwBandID;
    for (int i = 0; (iQLBandID == -1) && SUCCEEDED(_ptbs->EnumBands(i, &dwBandID)); i++)
    {
        if (BandSite_TestBandCLSID(_ptbs, dwBandID, CLSID_ISFBand) == S_OK)
        {
            IUnknown* punk;
            if (SUCCEEDED(_ptbs->GetBandObject(dwBandID, IID_PPV_ARG(IUnknown, &punk))))
            {
                VARIANTARG v = {0};
                v.vt = VT_I4;
                if (SUCCEEDED(IUnknown_Exec(punk, &CLSID_ISFBand, 1, 0, NULL, &v)))
                {
                    if ((v.vt == VT_I4) && (CSIDL_APPDATA == (DWORD)v.lVal))
                    {
                        iQLBandID = (int)dwBandID;
                    }
                }
                punk->Release();
            }
        }
    }

    return iQLBandID;
}

int CTray::_ToggleQL(int iVisible)
{
    int iQLBandID = _GetQuickLaunchID();

    bool fOldVisible = (-1 != iQLBandID);
    bool fNewVisible = (0  != iVisible);

    if ((iVisible != -1) && (fNewVisible != fOldVisible))
    {
        if (fNewVisible)
        {
            LPITEMIDLIST pidl;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidl)))
            {
                TCHAR szPath[MAX_PATH];
                SHGetPathFromIDList(pidl, szPath);
                PathCombine(szPath, szPath, L"Microsoft\\Internet Explorer\\Quick Launch");
                ILFree(pidl);
                pidl = ILCreateFromPath(szPath);
            
                if (pidl)
                {
                    IFolderBandPriv *pfbp;
                    // create an ISF band to show folders as hotlinks
                    if (SUCCEEDED(CoCreateInstance(CLSID_ISFBand, NULL, CLSCTX_INPROC, IID_PPV_ARG(IFolderBandPriv, &pfbp))))
                    {
                        IShellFolderBand* psfb;
                        if (SUCCEEDED(pfbp->QueryInterface(IID_PPV_ARG(IShellFolderBand, &psfb))))
                        {
                            if (SUCCEEDED(psfb->InitializeSFB(NULL, pidl)))
                            {
                                pfbp->SetNoText(TRUE);

                                VARIANTARG v;
                                v.vt = VT_I4;
                                v.lVal = CSIDL_APPDATA;
                                IUnknown_Exec(psfb, &CLSID_ISFBand, 1, 0, &v, NULL);

                                v.lVal = UEMIND_SHELL;  // UEMIND_SHELL/BROWSER
                                IUnknown_Exec(psfb, &CGID_ShellDocView, SHDVID_UEMLOG, 0, &v, NULL);

                                IDeskBand* ptb;
                                if (SUCCEEDED(pfbp->QueryInterface(IID_PPV_ARG(IDeskBand, &ptb))))
                                {
                                    HRESULT hr = _ptbs->AddBand(ptb);
                                    if (SUCCEEDED(hr))
                                    {
                                        _ptbs->SetBandState(ShortFromResult(hr), BSSF_NOTITLE, BSSF_NOTITLE);
                                    }
                                    ptb->Release();
                                }
                            }
                            psfb->Release();
                        }
                        pfbp->Release();
                    }

                    ILFree(pidl);
                }
            }
        }
        else
        {
            int iBandID;
            do {
                iBandID = _GetQuickLaunchID();
                if (iBandID != -1)
                {
                    _ptbs->RemoveBand(iBandID);
                }
           } while (iBandID != -1);
        }
    }

    return iQLBandID;
}

void CTray::StartMenuContextMenu(HWND hwnd, DWORD dwPos)
{
    LPITEMIDLIST pidlStart = SHCloneSpecialIDList(hwnd, CSIDL_STARTMENU, TRUE);
    INSTRUMENT_STATECHANGE(SHCNFI_STATE_TRAY_CONTEXT_START);
    HandleFullScreenApp(NULL);

    SetForegroundWindow(hwnd);

    if (pidlStart)
    {
        LPITEMIDLIST pidlLast = ILClone(ILFindLastID(pidlStart));
        ILRemoveLastID(pidlStart);

        if (pidlLast)
        {
            IShellFolder *psf = BindToFolder(pidlStart);
            if (psf)
            {
                HMENU hmenu = CreatePopupMenu();
                if (hmenu)
                {
                    IContextMenu *pcm;
                    HRESULT hr = psf->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pidlLast, IID_X_PPV_ARG(IContextMenu, NULL, &pcm));
                    if (SUCCEEDED(hr))
                    {
                        hr = pcm->QueryContextMenu(hmenu, 0, IDSYSPOPUP_FIRST, IDSYSPOPUP_LAST, CMF_VERBSONLY);
                        if (SUCCEEDED(hr))
                        {
                            int idCmd;
                            TCHAR szCommon[MAX_PATH];

                            //Add the menu to invoke the "Start Menu Properties"
                            LoadString (hinstCabinet, IDS_STARTMENUPROP, szCommon, ARRAYSIZE(szCommon));
                            AppendMenu (hmenu, MF_STRING, IDSYSPOPUP_STARTMENUPROP, szCommon);
                            if (!SHRestricted(REST_NOCOMMONGROUPS))
                            {
                                // If the user has access to the Common Start Menu, then we can add those items. If not,
                                // then we should not.
                                BOOL fAddCommon = (S_OK == SHGetFolderPath(NULL, CSIDL_COMMON_STARTMENU, NULL, 0, szCommon));

                                if (fAddCommon)
                                    fAddCommon = IsUserAnAdmin();


                                // Since we don't show this on the start button when the user is not an admin, don't show it here... I guess...
                                if (fAddCommon)
                                {
                                   AppendMenu (hmenu, MF_SEPARATOR, 0, NULL);
                                   LoadString (hinstCabinet, IDS_OPENCOMMON, szCommon, ARRAYSIZE(szCommon));
                                   AppendMenu (hmenu, MF_STRING, IDSYSPOPUP_OPENCOMMON, szCommon);
                                   LoadString (hinstCabinet, IDS_EXPLORECOMMON, szCommon, ARRAYSIZE(szCommon));
                                   AppendMenu (hmenu, MF_STRING, IDSYSPOPUP_EXPLORECOMMON, szCommon);
                                }
                            }

                            if (dwPos == (DWORD)-1)
                            {
                                idCmd = _TrackMenu(hmenu);
                            }
                            else
                            {
                                SendMessage(_hwndTrayTips, TTM_ACTIVATE, FALSE, 0L);
                                idCmd = TrackPopupMenu(hmenu,
                                                       TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                                                       GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos), 0, hwnd, NULL);
                                SendMessage(_hwndTrayTips, TTM_ACTIVATE, TRUE, 0L);
                            }


                            switch(idCmd)
                            {
                                case 0:  //User did not select a menu item; so, nothing to do!
                                    break; 
                                    
                                case IDSYSPOPUP_OPENCOMMON:
                                    _ExploreCommonStartMenu(FALSE);
                                    break;

                                case IDSYSPOPUP_EXPLORECOMMON:
                                    _ExploreCommonStartMenu(TRUE);
                                    break;

                                case IDSYSPOPUP_STARTMENUPROP:
                                    DoProperties(TPF_STARTMENUPAGE);
                                    break;
                                    
                                default:
                                    TCHAR szPath[MAX_PATH];
                                    CMINVOKECOMMANDINFOEX ici = {0};
#ifdef UNICODE
                                    CHAR szPathAnsi[MAX_PATH];
#endif
                                    ici.cbSize = sizeof(CMINVOKECOMMANDINFOEX);
                                    ici.hwnd = hwnd;
                                    ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - IDSYSPOPUP_FIRST);
                                    ici.nShow = SW_NORMAL;
#ifdef UNICODE
                                    SHGetPathFromIDListA(pidlStart, szPathAnsi);
                                    SHGetPathFromIDList(pidlStart, szPath);
                                    ici.lpDirectory = szPathAnsi;
                                    ici.lpDirectoryW = szPath;
                                    ici.fMask |= CMIC_MASK_UNICODE;
#else
                                    SHGetPathFromIDList(pidlStart, szPath);
                                    ici.lpDirectory = szPath;
#endif
                                    pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);

                                    break;
                                
                            } // Switch(idCmd)
                        }
                        pcm->Release();
                    }
                    DestroyMenu(hmenu);
                }
                psf->Release();
            }
            ILFree(pidlLast);
        }
        ILFree(pidlStart);
    }
}

void GiveDesktopFocus()
{
    SetForegroundWindow(v_hwndDesktop);
    SendMessage(v_hwndDesktop, DTM_UIACTIVATEIO, (WPARAM) TRUE, /*dtb*/0);
}

/*----------------------------------------------------------
Purpose: loads the given resource string and executes it.
         The resource string should follow this format:

         "program.exe>parameters"

         If there are no parameters, the format should simply be:

         "program.exe"

*/
void _ExecResourceCmd(UINT ids)
{
    TCHAR szCmd[2*MAX_PATH];

    if (LoadString(hinstCabinet, ids, szCmd, SIZECHARS(szCmd)))
    {
        SHELLEXECUTEINFO sei = {0};

        // Find list of parameters (if any)
        LPTSTR pszParam = StrChr(szCmd, TEXT('>'));

        if (pszParam)
        {
            // Replace the '>' with a null terminator
            *pszParam = 0;
            pszParam++;
        }

        sei.cbSize = sizeof(sei);
        sei.nShow = SW_SHOWNORMAL;
        sei.lpFile = szCmd;
        sei.lpParameters = pszParam;
        ShellExecuteEx(&sei);
    }
}

void CTray::_RefreshStartMenu()
{
    if (_pmbStartMenu)
    {
        IUnknown_Exec(_pmbStartMenu, &CLSID_MenuBand, MBANDCID_REFRESH, 0, NULL, NULL);
    }
    else if (_pmpStartPane)
    {
        IUnknown_Exec(_pmpStartPane, &CLSID_MenuBand, MBANDCID_REFRESH, 0, NULL, NULL);
    }
    _RefreshSettings();
    _UpdateBandSiteStyle();
}

BOOL CTray::_CanMinimizeAll()
{
    return (_hwndTasks && SendMessage(_hwndTasks, TBC_CANMINIMIZEALL, 0, 0));
}

BOOL CTray::_MinimizeAll(BOOL fPostRaiseDesktop)
{
    BOOL fRet = FALSE;

    if (_hwndTasks)
    {
        fRet = (BOOL)SendMessage(_hwndTasks, TBC_MINIMIZEALL, (WPARAM)_hwnd, (LPARAM)fPostRaiseDesktop);
    }

    return fRet;
}

extern void _UpdateNotifySetting(BOOL fNotifySetting);

//
//  Due to the weirdness of PnP, if the eject request occurs on a thread
//  that contains windows, the eject stalls for 15 seconds.  So do it
//  on its own thread.
//
DWORD CALLBACK _EjectThreadProc(LPVOID lpThreadParameter)
{
    CM_Request_Eject_PC();
    return 0;
}

void CTray::_Command(UINT idCmd)
{
    INSTRUMENT_ONCOMMAND(SHCNFI_TRAYCOMMAND, _hwnd, idCmd);

    switch (idCmd) {

    case IDM_CONTROLS:
    case IDM_PRINTERS:
        _ShowFolder(_hwnd,
            idCmd == IDM_CONTROLS ? CSIDL_CONTROLS : CSIDL_PRINTERS, COF_USEOPENSETTINGS);
        break;

    case IDM_EJECTPC:
        // Must use SHCreateThread and not a queued workitem because
        // a workitem might inherit a thread that has windows on it.
        // CTF_INSIST: In emergency, eject synchronously.  This stalls
        // for 15 seconds but it's better than nothing.
        SHCreateThread(_EjectThreadProc, NULL, CTF_INSIST, NULL);
        break;

    case IDM_LOGOFF:
        // Let the desktop get a chance to repaint to get rid of the
        // start menu bits before bringing up the logoff dialog box.
        UpdateWindow(_hwnd);
        Sleep(100);

        _SaveTrayAndDesktop();
        LogoffWindowsDialog(v_hwndDesktop);
        break;

    case IDM_MU_DISCONNECT:
        // Do the same sleep as above for the same reason.
        UpdateWindow(_hwnd);
        Sleep(100);
        DisconnectWindowsDialog(v_hwndDesktop);
        break;

    case IDM_EXITWIN:
        // Do the same sleep as above for the same reason.
        UpdateWindow(_hwnd);
        Sleep(100);

        _DoExitWindows(v_hwndDesktop);
        break;

    case IDM_TOGGLEDESKTOP:
        _RaiseDesktop(!g_fDesktopRaised, TRUE);
        break;

    case IDM_FILERUN:
        _RunDlg();
        break;

    case IDM_MINIMIZEALLHOTKEY:
        _HandleGlobalHotkey(GHID_MINIMIZEALL);
        break;

#ifdef DEBUG
    case IDM_SIZEUP:
    {
        RECT rcView;
        GetWindowRect(_hwndRebar, &rcView);
        MapWindowPoints(HWND_DESKTOP, _hwnd, (LPPOINT)&rcView, 2);
        rcView.bottom -= 18;
        SetWindowPos(_hwndRebar, NULL, 0, 0, RECTWIDTH(rcView), RECTHEIGHT(rcView), SWP_NOMOVE | SWP_NOZORDER);
    }
        break;

    case IDM_SIZEDOWN:
    {
        RECT rcView;
        GetWindowRect(_hwndRebar, &rcView);
        MapWindowPoints(HWND_DESKTOP, _hwnd, (LPPOINT)&rcView, 2);
        rcView.bottom += 18;
        SetWindowPos(_hwndRebar, NULL, 0, 0, RECTWIDTH(rcView), RECTHEIGHT(rcView), SWP_NOMOVE | SWP_NOZORDER);
    }
        break;
#endif

    case IDM_MINIMIZEALL:
        // minimize all window
        _MinimizeAll(FALSE);
        _fUndoEnabled = TRUE;
        break;

    case IDM_UNDO:
        _RestoreWindowPositions(FALSE);
        break;

    case IDM_SETTIME:
        // run the default applet in timedate.cpl
        SHRunControlPanel(TEXT("timedate.cpl"), _hwnd);
        break;

    case IDM_NOTIFYCUST:
        DoProperties(TPF_TASKBARPAGE | TPF_INVOKECUSTOMIZE);
        break;

    case IDM_LOCKTASKBAR:
        {
            BOOL fCanSizeMove = !_fCanSizeMove;   // toggle
            SHRegSetUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("TaskbarSizeMove"),
                REG_DWORD, &fCanSizeMove , sizeof(DWORD), SHREGSET_FORCE_HKCU);
            _RefreshSettings();
            _UpdateBandSiteStyle();
        }
        break;

    case IDM_SHOWTASKMAN:
        RunSystemMonitor();
        break;

    case IDM_CASCADE:
    case IDM_VERTTILE:
    case IDM_HORIZTILE:
        if (_CanTileAnyWindows())
        {
            SaveWindowPositions((idCmd == IDM_CASCADE) ? IDS_CASCADE : IDS_TILE);

            _AppBarNotifyAll(NULL, ABN_WINDOWARRANGE, NULL, TRUE);

            if (idCmd == IDM_CASCADE)
            {
                CascadeWindows(GetDesktopWindow(), 0, NULL, 0, NULL);
            }
            else
            {
                TileWindows(GetDesktopWindow(), ((idCmd == IDM_VERTTILE)?
                    MDITILE_VERTICAL : MDITILE_HORIZONTAL), NULL, 0, NULL);
            }

            // do it *before* ABN_xxx so don't get 'indirect' moves
            // REVIEW or should it be after?
            // CheckWindowPositions();
            _fUndoEnabled = FALSE;
            SetTimer(_hwnd, IDT_ENABLEUNDO, 500, NULL);

            _AppBarNotifyAll(NULL, ABN_WINDOWARRANGE, NULL, FALSE);
        }
        break;

    case IDM_TRAYPROPERTIES:
        DoProperties(TPF_TASKBARPAGE);
        break;

    case IDM_SETTINGSASSIST:
        SHCreateThread(SettingsUIThreadProc, NULL, 0, NULL);
        break;

    case IDM_HELPSEARCH:
        _ExecResourceCmd(IDS_HELP_CMD);
        break;

    // NB The Alt-s comes in here.
    case IDC_KBSTART:
        SetForegroundWindow(_hwnd);
        // This pushes the start button and causes the start menu to popup.
            SendMessage(_hwndStart, BM_SETSTATE, TRUE, 0);
        // This forces the button back up.
            SendMessage(_hwndStart, BM_SETSTATE, FALSE, 0);
        break;

    case IDC_ASYNCSTART:
#if 0 // (for testing UAssist locking code)
        UEMFireEvent(&UEMIID_SHELL, UEME_DBSLEEP, UEMF_XEVENT, -1, (LPARAM)10000);
#endif
#ifdef DEBUG
        if (GetAsyncKeyState(VK_SHIFT) < 0)
        {
            UEMFireEvent(&UEMIID_SHELL, UEME_CTLSESSION, UEMF_XEVENT, TRUE, -1);
            _RefreshStartMenu();
        }
#endif

        // Make sure the button is down.
        // DebugMsg(DM_TRACE, "c.twp: IDC_START.");

        // Make sure the Start button is down.
        if (!_bMainMenuInit && SendMessage(_hwndStart, BM_GETSTATE, 0, 0) & BST_PUSHED)
        {
            // DebugMsg(DM_TRACE, "c.twp: Start button down.");
            // Set the focus.
            _SetFocus(_hwndStart);
            _ToolbarMenu();
        }
        break;

    // NB LButtonDown on the Start button come in here.
    // Space-bar stuff also comes in here.
    case IDC_START:
        // User gets a bit confused with space-bar tuff (the popup ends up
        // getting the key-up and beeps).
        PostMessage(_hwnd, WM_COMMAND, IDC_ASYNCSTART, 0);
        break;

    case FCIDM_FINDFILES:
        SHFindFiles(NULL, NULL);
        break;

    case FCIDM_FINDCOMPUTER:
        SHFindComputer(NULL, NULL);
        break;

    case FCIDM_REFRESH:
        _RefreshStartMenu();
        break;

    case FCIDM_NEXTCTL:
        {
            MSG msg = { 0, WM_KEYDOWN, VK_TAB };
            HWND hwndFocus = GetFocus();

            // Since we are Tab or Shift Tab we should turn the focus rect on.
            //
            // Note: we don't need to do this in the GiveDesktopFocus cases below,
            // but in those cases we're probably already in the UIS_CLEAR UISF_HIDEFOCUS
            // state so this message is cheap to send.
            //
            SendMessage(_hwnd, WM_UPDATEUISTATE, MAKEWPARAM(UIS_CLEAR,
                UISF_HIDEFOCUS), 0);

            BOOL fShift = GetAsyncKeyState(VK_SHIFT) < 0;

            if (hwndFocus && (IsChildOrHWND(_hwndStart, hwndFocus)))
            {
                if (fShift)
                {
                    // gotta deactivate manually
                    GiveDesktopFocus();
                }
                else
                {
                    IUnknown_UIActivateIO(_ptbs, TRUE, &msg);
                }
            }
            else if (hwndFocus && (IsChildOrHWND(_hwndNotify, hwndFocus)))
            {
                if (fShift)
                {
                    IUnknown_UIActivateIO(_ptbs, TRUE, &msg);
                }
                else
                {
                    GiveDesktopFocus();
                }
            }
            else
            {
                if (IUnknown_TranslateAcceleratorIO(_ptbs, &msg) != S_OK)
                {
                    if (fShift)
                    {
                        _SetFocus(_hwndStart);
                    }
                    else
                    {
                        // if you tab forward out of the bands, the next focus guy is the tray notify set
                        _SetFocus(_hwndNotify);
                    }
                }
            }
        }
        break;

    case IDM_MU_SECURITY:
        MuSecurity();
        break;
    }
}

//// Start menu/Tray tab as a drop target

HRESULT CStartDropTarget::_GetStartMenuDropTarget(IDropTarget** pptgt)
{
    HRESULT hr = E_FAIL;
    *pptgt = NULL;

    LPITEMIDLIST pidlStart = SHCloneSpecialIDList(NULL, CSIDL_STARTMENU, TRUE);

    if (pidlStart)
    {
        IShellFolder *psf = BindToFolder(pidlStart);
        if (psf)
        {
            hr = psf->CreateViewObject(_ptray->_hwnd, IID_PPV_ARG(IDropTarget, pptgt));
            psf->Release();
        }

        ILFree(pidlStart);
    }
    return hr;
}


STDMETHODIMP CDropTargetBase::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CDropTargetBase, IDropTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDropTargetBase::AddRef()
{
    return 2;
}

STDMETHODIMP_(ULONG) CDropTargetBase::Release()
{
    return 1;
}

STDMETHODIMP CDropTargetBase::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    _ptray->_SetUnhideTimer(ptl.x, ptl.y);

    HWND hwndLock = _ptray->_hwnd;  // no clippy

    _DragEnter(hwndLock, ptl, pdtobj);

    return S_OK;
}

STDMETHODIMP CDropTargetBase::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    _ptray->_SetUnhideTimer(ptl.x, ptl.y);
    _DragMove(_ptray->_hwndStart, ptl);

    return S_OK;
}

STDMETHODIMP CDropTargetBase::DragLeave()
{
    DAD_DragLeave();
    return S_OK;
}

STDMETHODIMP CDropTargetBase::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DAD_DragLeave();
    return S_OK;
}

//
//  There are two different policies for the Start Button depending on
//  whether we are in Classic mode or Personal (New Start Pane) mode.
//
//  Classic mode:  Drops onto the Start Button are treated as if they
//  were drops into the CSIDL_STARTMENU folder.
//
//  Personal mode:  Drops onto the Start Button are treated as if they
//  were drops into the pin list.
//

CStartDropTarget::CStartDropTarget() : CDropTargetBase(IToClass(CTray, _dtStart, this))
{ 
}

CTrayDropTarget::CTrayDropTarget() : CDropTargetBase(IToClass(CTray, _dtTray, this))
{
}

STDMETHODIMP CTrayDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_NONE;
    return CDropTargetBase::DragEnter(pdtobj, grfKeyState, ptl, pdwEffect);
}

STDMETHODIMP CTrayDropTarget::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_NONE;
    return CDropTargetBase::DragOver(grfKeyState, ptl, pdwEffect);
}

void CStartDropTarget::_StartAutoOpenTimer(POINTL *pptl)
{
    POINT pt = { pptl->x, pptl->y };
    RECT rc;
    //Make sure it really is in the start menu..
    GetWindowRect(_ptray->_hwndStart, &rc);
    if (PtInRect(&rc,pt))
    {
        SetTimer(_ptray->_hwnd, IDT_STARTMENU, 1000, NULL);
    }
}

STDMETHODIMP CStartDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    HRESULT hr = S_OK;

    // default to not allowing drops
    _dwEffectsAllowed = DROPEFFECT_NONE;

    if (Tray_StartPanelEnabled())
    {
        // if we've disabled dragging and dropping, don't do anything, but if only the pin list is restricted, then still start the timer
        if (!IsRestrictedOrUserSetting(HKEY_CURRENT_USER, REST_NOCHANGESTARMENU, TEXT("Advanced"), TEXT("Start_EnableDragDrop"), ROUS_KEYALLOWS | ROUS_DEFAULTALLOW))
        {
            // Personal mode: Treat it as an add to the pin list.
            // IsPinnable checks REST_NOSMPINNEDLIST
            if (_ptray->_psmpin && _ptray->_psmpin->IsPinnable(pdtobj, SMPINNABLE_REJECTSLOWMEDIA, NULL) == S_OK)
            {
                _dwEffectsAllowed = DROPEFFECT_LINK;
            }

            *pdwEffect &= _dwEffectsAllowed;

            // Always start the AutoOpen timer because once we open, the user
            // can drop onto other things which may have different drop policies
            // from the pin list.
            _StartAutoOpenTimer(&ptl);
        }
    }
    else
    {
        if (!IsRestrictedOrUserSetting(HKEY_CURRENT_USER, REST_NOCHANGESTARMENU, TEXT("Advanced"), TEXT("StartMenuChange"), ROUS_KEYALLOWS | ROUS_DEFAULTALLOW))
        {
            // Classic mode: Treat it as a drop on the Start Menu folder.
            IDropTarget* ptgt;
            _dwEffectsAllowed = DROPEFFECT_LINK;
        
            hr = _GetStartMenuDropTarget(&ptgt);
            if (SUCCEEDED(hr))
            {
                // Check to make sure that we're going to accept the drop before we expand the start menu.
                ptgt->DragEnter(pdtobj, grfKeyState, ptl,
                                         pdwEffect);

                // DROPEFFECT_NONE means it ain't gonna work, so don't popup the Start Menu.
                if (*pdwEffect != DROPEFFECT_NONE)
                {
                    _StartAutoOpenTimer(&ptl);
                }

                ptgt->DragLeave();
                ptgt->Release();
            }
        }
    }

    CDropTargetBase::DragEnter(pdtobj, grfKeyState, ptl, pdwEffect);
    return hr;
}

STDMETHODIMP CStartDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = (_dwEffectsAllowed & DROPEFFECT_LINK);
    return CDropTargetBase::DragOver(grfKeyState, pt, pdwEffect);
}

STDMETHODIMP CStartDropTarget::DragLeave()
{
    KillTimer(_ptray->_hwnd, IDT_STARTMENU);
    return CDropTargetBase::DragLeave();
}

STDMETHODIMP CStartDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    KillTimer(_ptray->_hwnd, IDT_STARTMENU);

    HRESULT hr;

    if (Tray_StartPanelEnabled())
    {
        // Personal mode: Treat it as an add to the pin list.
        LPITEMIDLIST pidl;
        if (_ptray->_psmpin && _ptray->_psmpin->IsPinnable(pdtobj, SMPINNABLE_REJECTSLOWMEDIA, &pidl) == S_OK)
        {
            // Delete it from the pin list if it's already there because
            // we want to move it to the bottom.
            _ptray->_psmpin->Modify(pidl, NULL);
            // Now add it to the bottom.
            _ptray->_psmpin->Modify(NULL, pidl);
            ILFree(pidl);
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        IDropTarget* pdrop;
        hr = _GetStartMenuDropTarget(&pdrop);
        if (SUCCEEDED(hr))
        {
            if (!Tray_StartPanelEnabled())
            {
                POINTL ptDrop = { 0, 0 };
                DWORD grfKeyStateDrop = 0;

                *pdwEffect &= DROPEFFECT_LINK;

                pdrop->DragEnter(pdtobj, grfKeyStateDrop, ptDrop, pdwEffect);
                hr = pdrop->Drop(pdtobj, grfKeyStateDrop, ptDrop, pdwEffect);

                pdrop->DragLeave();
            }
            pdrop->Release();
        }
    }

    DAD_DragLeave();

    return hr;
}

void CTray::_RegisterDropTargets()
{
    THR(RegisterDragDrop(_hwndStart, &_dtStart));
    THR(RegisterDragDrop(_hwnd, &_dtTray));

    // It is not a serious error if this fails; it just means that
    // drag/drop to the Start Button will not add to the pin list
    CoCreateInstance(CLSID_StartMenuPin, NULL, CLSCTX_INPROC_SERVER,
                     IID_PPV_ARG(IStartMenuPin, &_psmpin));
}

void CTray::_RevokeDropTargets()
{
    RevokeDragDrop(_hwndStart);
    RevokeDragDrop(_hwnd);
    ATOMICRELEASET(_psmpin, IStartMenuPin);
}

void CTray::_HandleGlobalHotkey(WPARAM wParam)
{
    INSTRUMENT_HOTKEY(SHCNFI_GLOBALHOTKEY, wParam);

    switch(wParam)
    {
    case GHID_RUN:
        _RunDlg();
        break;

    case GHID_MINIMIZEALL:
        if (_CanMinimizeAll())
            _MinimizeAll(FALSE);
        SetForegroundWindow(v_hwndDesktop);
        break;

    case GHID_UNMINIMIZEALL:
        _RestoreWindowPositions(FALSE);
        break;

    case GHID_HELP:
        _Command(IDM_HELPSEARCH);
        break;

    case GHID_DESKTOP:
        _RaiseDesktop(!g_fDesktopRaised, TRUE);
        break;

    case GHID_TRAYNOTIFY:
        SwitchToThisWindow(_hwnd, TRUE);
        SetForegroundWindow(_hwnd);
        _SetFocus(_hwndNotify);
        break;

    case GHID_EXPLORER:
        _ShowFolder(_hwnd, CSIDL_DRIVES, COF_CREATENEWWINDOW | COF_EXPLORE);
        break;

    case GHID_FINDFILES:
        if (!SHRestricted(REST_NOFIND))
            _Command(FCIDM_FINDFILES);
        break;

    case GHID_FINDCOMPUTER:
        if (!SHRestricted(REST_NOFIND))
            _Command(FCIDM_FINDCOMPUTER);
        break;

    case GHID_TASKTAB:
    case GHID_TASKSHIFTTAB:
        if (GetForegroundWindow() != _hwnd)
            SetForegroundWindow(_hwnd);
        SendMessage(_hwndTasks, TBC_TASKTAB, wParam == GHID_TASKTAB ? 1 : -1, 0L);
        break;

    case GHID_SYSPROPERTIES:
#define IDS_SYSDMCPL            0x2334  // from shelldll
        SHRunControlPanel(MAKEINTRESOURCE(IDS_SYSDMCPL), _hwnd);
        break;
    }
}

void CTray::_UnregisterGlobalHotkeys()
{
    for (int i = GHID_FIRST; i < GHID_MAX; i++)
    {
        UnregisterHotKey(_hwnd, i);
    }
}

void CTray::_RegisterGlobalHotkeys()
{
    int i;
    // Are the Windows keys restricted?
    DWORD dwRestricted = SHRestricted(REST_NOWINKEYS);

    for (i = GHID_FIRST ; i < GHID_MAX; i++) 
    {
        // If the Windows Keys are Not restricted or it's not a Windows key
        if (!((HIWORD(GlobalKeylist[i - GHID_FIRST]) & MOD_WIN) && dwRestricted))
        {
            // Then register it.
            RegisterHotKey(_hwnd, i, HIWORD(GlobalKeylist[i - GHID_FIRST]), LOWORD(GlobalKeylist[i - GHID_FIRST]));
        }
    }
}

void CTray::_RaiseDesktop(BOOL fRaise, BOOL fRestoreWindows)
{
    if (v_hwndDesktop && (fRaise == !g_fDesktopRaised) && !_fProcessingDesktopRaise)
    {
        _fProcessingDesktopRaise = TRUE;
        BOOL fPostMessage = TRUE;

        if (fRaise)
        {
            HWND hwndFG = GetForegroundWindow();
            // If no window has focus then set focus to the tray
            if (hwndFG)
            {
                hwndFG = _hwnd;
            }

            if (!_hwndFocusBeforeRaise)
            {
                // See if the Foreground Window had a popup window
                _hwndFocusBeforeRaise = GetLastActivePopup(hwndFG);
            }
            if (!IsWindowVisible(_hwndFocusBeforeRaise))
            {
                _hwndFocusBeforeRaise = hwndFG;
            }

            // _MinimizeAll will save the windows positions synchronously, and will minimize the
            // the windows on a background thread
            _fMinimizedAllBeforeRaise = _CanMinimizeAll();
            if (_fMinimizedAllBeforeRaise)
            {
                fPostMessage = !_MinimizeAll(TRUE);
            }
        }
        else
        {
            if (fRestoreWindows)
            {
                HWND hwnd = _hwndFocusBeforeRaise;
                if (_fMinimizedAllBeforeRaise)
                {
                    // Since the windows are restored on a seperate thread, I want the make that the
                    // desktop is not raised until they are done, so the window restore thread will
                    // actually post the message for raising the desktop
                    fPostMessage = !_RestoreWindowPositions(TRUE);
                }

                SetForegroundWindow(hwnd);
                if (hwnd == _hwnd)
                {
                    _SetFocus(_hwndStart);
                }
            }

            _hwndFocusBeforeRaise = NULL;
        }

        if (fPostMessage)
            PostMessage(v_hwndDesktop, DTM_RAISE, (WPARAM)_hwnd, fRaise ? DTRF_RAISE : DTRF_LOWER);
    }
}

void CTray::_OnDesktopState(LPARAM lParam)
{
    g_fDesktopRaised = (!(lParam & DTRF_LOWER));

    DAD_ShowDragImage(FALSE);       // unlock the drag sink if we are dragging.

    if (!g_fDesktopRaised)
    {
        HandleFullScreenApp(NULL);
    }
    else
    {
        // if the desktop is raised, we need to force the tray to be always on top
        // until it's lowered again
        _ResetZorder();
    }

    DAD_ShowDragImage(TRUE);       // unlock the drag sink if we are dragging.
    _fProcessingDesktopRaise = FALSE;
}

BOOL CTray::_ToggleLanguageBand(BOOL fShowIt)
{
    HRESULT hr = E_FAIL;

    DWORD dwBandID;
    BOOL fFound = FALSE;
    for (int i = 0; !fFound && SUCCEEDED(_ptbs->EnumBands(i, &dwBandID)); i++)
    {
        if (BandSite_TestBandCLSID(_ptbs, dwBandID, CLSID_MSUTBDeskBand) == S_OK)
        {
            fFound = TRUE;
        }
    }

    BOOL fShow = fFound;

    if (fShowIt && !fFound)
    {
        IDeskBand* pdb;
        HRESULT hr = CoCreateInstance(CLSID_MSUTBDeskBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDeskBand, &pdb));
        if (SUCCEEDED(hr))
        {
            hr = _ptbs->AddBand(pdb);
            fShow = TRUE;
            pdb->Release();
        }
    }
    else if (!fShowIt && fFound)
    {
        hr = _ptbs->RemoveBand(dwBandID);
        if (SUCCEEDED(hr))
        {
            fShow = FALSE;
        }
    }

    return fShow;
}

// Process the message by propagating it to all of our child windows
typedef struct
{
    UINT uMsg;
    WPARAM wP;
    LPARAM lP;
    CTray* ptray;
} CABPM;

BOOL CTray::PropagateEnumProc(HWND hwnd, LPARAM lParam)
{
    CABPM *ppm = (CABPM *)lParam;
    
    if (SHIsChildOrSelf(ppm->ptray->_hwndRebar, hwnd) == S_OK) 
    {
        return TRUE;
    }
    SendMessage(hwnd, ppm->uMsg, ppm->wP, ppm->lP);
    return TRUE;
}

void CTray::_PropagateMessage(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CABPM pm = {uMessage, wParam, lParam, this};

    ASSERT(hwnd != _hwndRebar);
    EnumChildWindows(hwnd, PropagateEnumProc, (LPARAM)&pm);
}

//
// Called from SETTINGS.DLL when the tray property sheet needs
// to be activated.  See SettingsUIThreadProc below.
//
// Also used by desktop2\deskhost.cpp to get to the tray properties.
//
void WINAPI Tray_DoProperties(DWORD dwFlags)
{
    c_tray.DoProperties(dwFlags);
}
    

DWORD WINAPI CTray::SettingsUIThreadProc(void *pv)
{
    //
    // Open up the "Settings Wizards" UI.
    //
    HMODULE hmodSettings = LoadLibrary(TEXT("settings.dll"));
    if (NULL != hmodSettings)
    {
        //
        // Entry point in SETTINGS.DLL is ordinal 1.
        // Don't want to export this entry point by name.
        //
        PSETTINGSUIENTRY pfDllEntry = (PSETTINGSUIENTRY)GetProcAddress(hmodSettings, (LPCSTR)1);
        if (NULL != pfDllEntry)
        {
            //
            // This call will open and run the UI.
            // The thread's message loop is inside settings.dll.
            // This call will not return until the settings UI has been closed.
            //
            (*pfDllEntry)(Tray_DoProperties);
        }

        FreeLibrary(hmodSettings);
    }
    return 0;
}

//
//  This function is called whenever we detect a change to the default
//  browser registration in HKCR\http\shell\open\command.
//
//  For compatibility with old browsers, if the default browser (URL handler)
//  is not XP-aware, then auto-generate a StartMenuInternet client
//  registration and set it as the default.
//

void CTray::_MigrateOldBrowserSettings()
{
    // We want only one person to do this work per machine (though it doesn't
    // hurt to have more than one person do it; it's just pointless), so try
    // to filter out people who clearly didn't instigate the key change.
    //
    if (!_fIsDesktopLocked && _fIsDesktopConnected)
    {
        // If the user does not have write access then we can't migrate the
        // setting... (In which case there was nothing to migrate anyway
        // since you need to be administrator to change the default browser...)

        HKEY hkBrowser;
        DWORD dwDisposition;

        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Clients\\StartMenuInternet"),
                           0, NULL, REG_OPTION_NON_VOLATILE,
                           KEY_READ | KEY_WRITE, NULL, &hkBrowser, &dwDisposition) == ERROR_SUCCESS)
        {
            TCHAR szCommand[MAX_PATH];
            DWORD cch = ARRAYSIZE(szCommand);

            // It is important that we use AssocQueryString to parse the
            // executable, because Netscape has a habit of registering
            // their path incorrectly (they forget to quote the space in
            // "Program Files") but AssocQueryString has special recovery
            // code to detect and repair that case...
            if (SUCCEEDED(AssocQueryString(ASSOCF_NOUSERSETTINGS,
                                           ASSOCSTR_EXECUTABLE, L"http",
                                           L"open", szCommand, &cch)) &&
                szCommand[0])
            {
                TCHAR szAppName[MAX_PATH];
                StringCchCopy(szAppName, ARRAYSIZE(szAppName), PathFindFileName(szCommand));

                // You might think that we need to special-case MSN Explorer,
                // since they shipped before XP RTM'd, and convert MSN6.EXE
                // to "MSN Explorer", but that's not true because
                // they never take over as the default http handler, so we
                // will never see them here!

                // Create a registration for the new default browser if necessary.
                // We keep our hands off once we see a DefaultIcon key, since that
                // proves that the application is XP-aware.

                // When IE Access is turned off, StartMenuInternet\IExplore.exe is
                // also removed so that IE will not appear in "Customize Start Menu"
                // dialog box. Do not migrate IE.

                HKEY hkClient;

                if ( 0 != lstrcmpi(szAppName, TEXT("IEXPLORE.EXE")) && 
                    RegCreateKeyEx(hkBrowser, szAppName, 0, NULL, REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE, NULL, &hkClient, &dwDisposition) == ERROR_SUCCESS)
                {
                    if (dwDisposition == REG_CREATED_NEW_KEY)
                    {
                        TCHAR szFriendly[MAX_PATH];
                        cch = ARRAYSIZE(szFriendly);
                        if (SUCCEEDED(AssocQueryString(ASSOCF_NOUSERSETTINGS | ASSOCF_INIT_BYEXENAME | ASSOCF_VERIFY,
                                                       ASSOCSTR_FRIENDLYAPPNAME, szCommand,
                                                       NULL, szFriendly, &cch)))
                        {
                            // Set the friendly name
                            RegSetValueEx(hkClient, TEXT("LocalizedString"), 0, REG_SZ, (BYTE*)szFriendly, sizeof(TCHAR) * (cch + 1));

                            // Set the command string (properly quoted)
                            PathQuoteSpaces(szCommand);
                            SHSetValue(hkClient, TEXT("shell\\open\\command"), NULL,
                                       REG_SZ, szCommand, sizeof(TCHAR) * (1 + lstrlen(szCommand)));
                        }
                    }

                    LONG l = 0;
                    if (RegQueryValue(hkClient, TEXT("DefaultIcon"), NULL, &l) == ERROR_FILE_NOT_FOUND)
                    {
                        // Set it as the system default
                        RegSetValueEx(hkBrowser, NULL, 0, REG_SZ, (BYTE*)szAppName, sizeof(TCHAR) * (lstrlen(szAppName) + 1));

                        // Now tell everybody about the change
                        SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)TEXT("Software\\Clients\\StartMenuInternet"));
                    }
                    RegCloseKey(hkClient);
                }

            }
            RegCloseKey(hkBrowser);
        }
    }

    // Restart the monitoring of the registry...
    // (RegNotifyChangeKeyValue is good for only one shot.)
    // Some apps (like Opera) delete the key as part of their registration,
    // which causes our HKEY to go bad, so close it and make a new one.

    if (_hkHTTP)
    {
        RegCloseKey(_hkHTTP);
        _hkHTTP = NULL;
    }

    //
    //  Note!  We have to register on HKCR\http\shell recursively
    //  even though we only care about HKCR\http\shell\open\command.
    //  The reason is that shell\open\command might not exist (IE
    //  deletes it as part of its uninstall) and you can't register
    //  a wait on a key that doesn't exist.  We don't want to create
    //  a blank key on our own, because that means "To launch a web
    //  browser, run the null string as a command," which doesn't work
    //  too great.
    //
    if (RegCreateKeyEx(HKEY_CLASSES_ROOT, TEXT("http\\shell"),
                       0, NULL, REG_OPTION_NON_VOLATILE,
                       KEY_ENUMERATE_SUB_KEYS |
                       KEY_QUERY_VALUE | KEY_SET_VALUE | KEY_NOTIFY,
                       NULL, &_hkHTTP, NULL) == ERROR_SUCCESS)
    {
        RegNotifyChangeKeyValue(_hkHTTP, TRUE,
                                REG_NOTIFY_CHANGE_NAME |
                                REG_NOTIFY_CHANGE_LAST_SET,
                                _hHTTPEvent, TRUE);
    }
}

void CTray::_MigrateOldBrowserSettingsCB(PVOID lpParameter, BOOLEAN)
{
    //
    //  Sleep a little while so the app can finish installing all the
    //  registry keys it wants before we start cleaning up behind it.
    //
    Sleep(1000);

    CTray *self = (CTray *)lpParameter;
    self->_MigrateOldBrowserSettings();
}

//
// *** WARNING ***
//
//  This is a private interface EXPLORER.EXE exposes to SHDOCVW, which
// allows SHDOCVW (mostly desktop) to access tray. All member must be
// thread safe!
//

CDeskTray::CDeskTray()
{
    _ptray = IToClass(CTray, _desktray, this);
}

HRESULT CDeskTray::QueryInterface(REFIID riid, void ** ppvObj)
{
#if 0   // no IID_IDeskTray yet defined
    static const QITAB qit[] =
    {
        QITABENT(CDeskTray, IDeskTray),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
#else
    return E_NOTIMPL;
#endif
}

ULONG CDeskTray::AddRef()
{
    return 2;
}

ULONG CDeskTray::Release()
{
    return 1;
}

HRESULT CDeskTray::GetTrayWindow(HWND* phwndTray)
{
    ASSERT(_ptray->_hwnd);
    *phwndTray = _ptray->_hwnd;
    return S_OK;
}

HRESULT CDeskTray::SetDesktopWindow(HWND hwndDesktop)
{
    ASSERT(v_hwndDesktop == NULL);
    v_hwndDesktop = hwndDesktop;
    return S_OK;
}

UINT CDeskTray::AppBarGetState()
{
    return (_ptray->_uAutoHide ?  ABS_AUTOHIDE    : 0) |
        (_ptray->_fAlwaysOnTop ?  ABS_ALWAYSONTOP : 0);
}

//***   CDeskTray::SetVar -- set an explorer variable (var#i := value)
// ENTRY/EXIT
//  var     id# of variable to be changed
//  value   value to be assigned
// NOTES
//  WARNING: thread safety is up to caller!
//  notes: currently only called in 1 place, but extra generality is cheap
// minimal cost
HRESULT CDeskTray::SetVar(int var, DWORD value)
{
    extern BOOL g_fExitExplorer;

    TraceMsg(DM_TRACE, "c.cdt_sv: set var(%d):=%d", var, value);
    switch (var) {
    case SVTRAY_EXITEXPLORER:
        TraceMsg(DM_TRACE, "c.cdt_sv: set g_fExitExplorer:=%d", value);
        g_fExitExplorer = value;
        WriteCleanShutdown(1);
        break;

    default:
        ASSERT(0);
        return S_FALSE;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\trayitem.h ===
#ifndef _TRAYITEM_H
#define _TRAYITEM_H

#include "traycmn.h"

#define TNUP_AUTOMATIC  0
#define TNUP_DEMOTED    1
#define TNUP_PROMOTED   2

// IMPORTANT : Should be kept in sync with any flags defined in shellapi.w
typedef enum ICONSTATEFLAG
{
    TIF_HIDDEN = 0,
    TIF_DEMOTED,
    TIF_STARTUPICON,
    TIF_SHARED,
    TIF_SHAREDICONSOURCE,
    TIF_ONCEVISIBLE,
    TIF_ITEMCLICKED,
    TIF_ITEMSAMEICONMODIFY,
} ICONSTATEFLAG;

class CTrayItem
{
    public:
        CTrayItem() : dwUserPref(TNUP_AUTOMATIC), guidItem(GUID_NULL) { }
        ~CTrayItem() { }

        // The icon should have an associated exe name, and it should either be
        // demoted or its preference should be set to something other than automatic
        BOOL ShouldSaveIcon()
        {
            return ( (szExeName[0] != 0) && (WasOnceVisible()) && (szIconText[0] != 0) ); 
        }

        BOOL IsDemoted()            { return (_CheckIconState(TIF_DEMOTED)); }
        BOOL IsHidden()             { return (_CheckIconState(TIF_HIDDEN)); }
        BOOL IsIconShared()         { return (_CheckIconState(TIF_SHARED)); }
        BOOL IsSharedIconSource()   { return (_CheckIconState(TIF_SHAREDICONSOURCE)); }
        BOOL IsStartupIcon()        { return (_CheckIconState(TIF_STARTUPICON)); }
        BOOL WasOnceVisible()       { return (_CheckIconState(TIF_ONCEVISIBLE)); }
        BOOL IsItemClicked()        { return (_CheckIconState(TIF_ITEMCLICKED)); }
        BOOL IsItemSameIconModify() { return (_CheckIconState(TIF_ITEMSAMEICONMODIFY)); }

        BOOL IsGuidItemValid()      { return (guidItem != GUID_NULL); }

        BOOL IsIconTimerCurrent()   { return (uIconDemoteTimerID != 0); }

        void SetDemoted(BOOL bDemoted) { _SetIconState(TIF_DEMOTED, bDemoted); }
        void SetStartupIcon(BOOL bIsStartupIcon) { _SetIconState(TIF_STARTUPICON, bIsStartupIcon); }
        void SetSharedIconSource(BOOL bSharedIconSource) 
        {
            _SetIconState(TIF_SHAREDICONSOURCE, bSharedIconSource); 
        }
        void SetOnceVisible(BOOL bOnceVisible) { _SetIconState(TIF_ONCEVISIBLE, bOnceVisible); }
        void SetItemClicked(BOOL bItemClicked) { _SetIconState(TIF_ITEMCLICKED, bItemClicked); }
        void SetItemSameIconModify(BOOL bItemSameIconModify)
        {
            _SetIconState(TIF_ITEMSAMEICONMODIFY, bItemSameIconModify);
        }
   
    public:
        HWND        hWnd;
        UINT        uID;
        UINT        uCallbackMessage;
        DWORD       dwState;
        UINT        uVersion;
        HICON       hIcon;       // *** may be stale, not guaranteed to be a valid hicon ***

        ULONG       uIconDemoteTimerID;
        DWORD       dwUserPref;  // user preference (hidden? visible? automatic?)
        DWORD       dwLastSoundTime;
        TCHAR       szExeName[MAX_PATH];
        TCHAR       szIconText[MAX_PATH];
        UINT        uNumSeconds;
        GUID        guidItem;

    private:
        DWORD _GetStateFlag(ICONSTATEFLAG sf);
        void _SetIconState(ICONSTATEFLAG sf, BOOL bSet);
        BOOL _CheckIconState(ICONSTATEFLAG sf);
};

// Item Count helper flags..
#define     GIC_PROMOTED       0
#define     GIC_DEMOTED        1
#define     GIC_ALL            2

class CTrayItemManager
{
    public:
        CTrayItemManager()  { }
        ~CTrayItemManager() { }

        INT_PTR FindItemAssociatedWithGuid(GUID guidItemToCheck);
        INT_PTR FindItemAssociatedWithTimer(UINT_PTR uIconDemoteTimerID);
        INT_PTR FindItemAssociatedWithHwndUid(HWND hwnd, UINT uID);

        INT_PTR GetItemCount(int nItemCountThreshold = -1)
        {
            return _GetItemCountHelper(GIC_ALL, nItemCountThreshold);
        }

        INT_PTR GetDemotedItemCount(int nItemCountThreshold = -1)
        {
            return _GetItemCountHelper(GIC_DEMOTED, nItemCountThreshold);
        }

        INT_PTR GetPromotedItemCount(int nItemCountThreshold = -1)
        {
            return _GetItemCountHelper(GIC_PROMOTED, nItemCountThreshold);
        }

        void SetTBBtnImage(INT_PTR iIndex, int iImage);
        int GetTBBtnImage(INT_PTR iIndex, BOOL fByIndex = TRUE);
        
        void SetTBBtnText(INT_PTR iIndex, LPTSTR pszText);

        BOOL SetTBBtnStateHelper(INT_PTR iIndex, BYTE fsState, BOOL_PTR bSet);

        BOOL GetTrayItem(INT_PTR nIndex, CNotificationItem * pni, BOOL * pbStat);

        int FindImageIndex(HICON hIcon, BOOL fSetAsSharedSource);

        BOOL DemotedItemsPresent(int nMinDemotedItemsThreshold);

        CTrayItem * GetItemData(INT_PTR i, BOOL byIndex, HWND hwndToolbar);
        CTrayItem * GetItemDataByIndex(INT_PTR i) 
        {
            return GetItemData(i, TRUE, m_hwndToolbar);
        }

        void SetIconList(HIMAGELIST hImageList) { m_himlIcons = hImageList; }
        void SetTrayToolbar(HWND hwndToolbar)   { m_hwndToolbar = hwndToolbar; }

    private:
        INT_PTR _GetItemCountHelper(int nItemFlag, int nItemCountThreshold);

        HIMAGELIST      m_himlIcons;
        HWND            m_hwndToolbar;
};

#endif // _TRAYITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\trayitem.cpp ===
#include "cabinet.h"
#include "trayitem.h"
#include "shellapi.h"

#include "strsafe.h"

//
// CTrayItem members...
//
DWORD CTrayItem::_GetStateFlag(ICONSTATEFLAG sf)
{
    DWORD dwFlag = 0;
    switch (sf)
    {
        case TIF_HIDDEN:
            dwFlag = NIS_HIDDEN;
            break;
            
        case TIF_DEMOTED:
            dwFlag = NISP_DEMOTED;
            break;
            
        case TIF_STARTUPICON:
            dwFlag = NISP_STARTUPICON;
            break;
            
        case TIF_SHARED:
            dwFlag = NIS_SHAREDICON;
            break;
            
        case TIF_SHAREDICONSOURCE:
            dwFlag = NISP_SHAREDICONSOURCE;
            break;

        case TIF_ONCEVISIBLE:
            dwFlag = NISP_ONCEVISIBLE;
            break;

        case TIF_ITEMCLICKED:
            dwFlag = NISP_ITEMCLICKED;
            break;

        case TIF_ITEMSAMEICONMODIFY:
            dwFlag = NISP_ITEMSAMEICONMODIFY;
            break;
    }

    ASSERT(dwFlag);
    return dwFlag;
}

void CTrayItem::_SetIconState(ICONSTATEFLAG sf, BOOL bSet)
{
    DWORD dwFlag = _GetStateFlag(sf);

    ASSERT(dwFlag);
    
    if (bSet)
        dwState |= (dwFlag & 0xFFFFFFFF);
    else
        dwState &= ~dwFlag;    
}

BOOL CTrayItem::_CheckIconState(ICONSTATEFLAG sf)
{
    DWORD dwFlag = _GetStateFlag(sf);

    ASSERT(dwFlag);

    return ((dwState & dwFlag) != 0);
}


//
// CTrayItemManager members
//
CTrayItem * CTrayItemManager::GetItemData(INT_PTR i, BOOL byIndex, HWND hwndToolbar)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.lParam = 0;
    tbbi.dwMask = TBIF_LPARAM;
    if (byIndex)
        tbbi.dwMask |= TBIF_BYINDEX;
    SendMessage(hwndToolbar, TB_GETBUTTONINFO, i, (LPARAM)&tbbi);
    return (CTrayItem *)(void *)tbbi.lParam;
}

INT_PTR CTrayItemManager::FindItemAssociatedWithGuid(GUID guidItemToCheck)
{
    if (guidItemToCheck == GUID_NULL)
        return -1;

    for (INT_PTR i = GetItemCount()-1; i >= 0; i--)
    {
        CTrayItem * pti = GetItemDataByIndex(i);
        if (pti && pti->IsGuidItemValid() && IsEqualGUID(pti->guidItem, guidItemToCheck))
            return i;
    }

    return -1;
}

INT_PTR CTrayItemManager::FindItemAssociatedWithTimer(UINT_PTR uIconDemoteTimerID)
{
    for (INT_PTR i = GetItemCount()-1; i >= 0; i--)
    {
        CTrayItem * pti = GetItemDataByIndex(i);
        if (pti && pti->uIconDemoteTimerID == uIconDemoteTimerID)
            return i;
    }

    return -1;
}

INT_PTR CTrayItemManager::FindItemAssociatedWithHwndUid(HWND hwnd, UINT uID)
{
    for (INT_PTR i = GetItemCount() - 1; i >= 0; --i)
    {
        CTrayItem * pti = GetItemDataByIndex(i);
        if (pti && (pti->hWnd == hwnd) && (pti->uID == uID))
        {
            return i;
        }
    }

    return -1;
}

// Decides if there are as many "TNUP_AUTOMATIC" demoted items in the tray, above the 
// threshold that the user has specified...
// Returns TRUE if there is any TNUP_DEMOTED item in the list...
BOOL CTrayItemManager::DemotedItemsPresent(int nMinDemotedItemsThreshold)
{
    ASSERT(nMinDemotedItemsThreshold >= 0);

    INT_PTR cIcons = 0;
    INT_PTR nItems = SendMessage(m_hwndToolbar, TB_BUTTONCOUNT, 0, 0L);

    for (INT_PTR i = 0; i < nItems; i++)
    {
        CTrayItem * pti = GetItemDataByIndex(i);

        ASSERT(pti);

        // If the item is set to ALWAYS HIDE, then it must be shown in demoted state...
        if (pti->dwUserPref == TNUP_DEMOTED)
        {
            return TRUE;
        }
        // If the item is demoted, then only if there are enough demoted items must
        // they all be shown in demoted state...
        else if (pti->IsDemoted())
        {
            cIcons++;
            if (cIcons >= nMinDemotedItemsThreshold)
                return TRUE;
        }
    }

    return FALSE;
}

// Works irrespective of whether AutoTray is enabled or not...
INT_PTR CTrayItemManager::_GetItemCountHelper(int nItemFlag, int nItemCountThreshold)
{
    INT_PTR cIcons = 0;

    INT_PTR nItems = SendMessage(m_hwndToolbar, TB_BUTTONCOUNT, 0, 0L);
    switch(nItemFlag)
    {
        case GIC_ALL: 
            cIcons = nItems;
            break;

        case GIC_PROMOTED:
        case GIC_DEMOTED:
            for (INT_PTR i = nItems-1; i>= 0; i--)
            {
                CTrayItem * pti = GetItemDataByIndex(i);

                if (nItemFlag == GIC_PROMOTED)
                {
                    if (pti && !pti->IsDemoted() && !pti->IsHidden())
                        cIcons ++;
                }
                else
                {
                    if (pti && pti->IsDemoted())
                        cIcons++;
                }

                if (nItemCountThreshold != -1 && cIcons >= nItemCountThreshold)
                    break;
            }
            break;
    }
    return cIcons;    
}

void CTrayItemManager::SetTBBtnImage(INT_PTR iIndex, int iImage)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_IMAGE | TBIF_BYINDEX;
    tbbi.iImage = iImage;

    SendMessage(m_hwndToolbar, TB_SETBUTTONINFO, iIndex, (LPARAM)&tbbi);
}

int CTrayItemManager::GetTBBtnImage(INT_PTR iIndex, BOOL fByIndex /* = TRUE */)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_IMAGE;

    if (fByIndex)
        tbbi.dwMask |= TBIF_BYINDEX;

    SendMessage(m_hwndToolbar, TB_GETBUTTONINFO, iIndex, (LPARAM)&tbbi);
    return tbbi.iImage;
}

BOOL CTrayItemManager::SetTBBtnStateHelper(INT_PTR iIndex, BYTE fsState, BOOL_PTR bSet)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_STATE | TBIF_BYINDEX;

    // Get the original state of the button
    SendMessage(m_hwndToolbar, TB_GETBUTTONINFO, iIndex, (LPARAM)&tbbi);

    // Or the new state to the original state
    BYTE fsStateOld = tbbi.fsState;
    if (bSet)
        tbbi.fsState |= fsState;
    else
        tbbi.fsState &= ~fsState;

    if (tbbi.fsState ^ fsStateOld)
    {
        SendMessage(m_hwndToolbar, TB_SETBUTTONINFO, iIndex, (LPARAM)&tbbi);
        return TRUE;
    }

    return FALSE;
}

void CTrayItemManager::SetTBBtnText(INT_PTR iIndex, LPTSTR pszText)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_TEXT | TBIF_BYINDEX;
    tbbi.pszText = pszText;
    tbbi.cchText = -1;
    SendMessage(m_hwndToolbar, TB_SETBUTTONINFO, iIndex, (LPARAM)&tbbi);
}

int CTrayItemManager::FindImageIndex(HICON hIcon, BOOL fSetAsSharedSource)
{
    INT_PTR i;
    INT_PTR iCount = GetItemCount();
    
    for (i = 0; i < iCount; i++)
    {
        CTrayItem * pti = GetItemDataByIndex(i);
        if (pti && pti->hIcon == hIcon)
        {
            // if we're supposed to mark this as a shared icon source and its not itself a shared icon
            // target, mark it now.  this is to allow us to recognize when the source icon changes and
            // that we can know that we need to find other indicies and update them too.
            if (fSetAsSharedSource && !pti->IsIconShared())
                pti->SetSharedIconSource(TRUE);
                
            return GetTBBtnImage(i);
        }
    }
    return -1;
}

// TO DO szText can be replaced by pti->szIconText
BOOL CTrayItemManager::GetTrayItem(INT_PTR nIndex, CNotificationItem * pni, BOOL * pbStat)
{
    if (nIndex < 0 || nIndex >= GetItemCount())
    {
        *pbStat = FALSE;
        return FALSE;
    }

    ASSERT(pni->hIcon == NULL); // else we're going to leak it

    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(tbbi);
    tbbi.dwMask = TBIF_BYINDEX | TBIF_IMAGE | TBIF_LPARAM | TBIF_TEXT;

    TCHAR szText[80] = {0};
    tbbi.pszText = szText;
    tbbi.cchText = ARRAYSIZE(szText);

    if (SendMessage(m_hwndToolbar, TB_GETBUTTONINFO, nIndex, (LPARAM)&tbbi) != -1)
    {
        CTrayItem * pti = (CTrayItem *)tbbi.lParam;

        // don't expose the NIS_HIDDEN icons
        if (pti && !pti->IsHidden())
        {
            pni->hWnd       = pti->hWnd;
            pni->uID        = pti->uID;
            pni->hIcon      = ImageList_GetIcon(m_himlIcons, tbbi.iImage, ILD_NORMAL);
            pni->dwUserPref = pti->dwUserPref;
            pni->SetExeName(pti->szExeName);
            pni->SetIconText(szText);
            memcpy(&(pni->guidItem), &(pti->guidItem), sizeof(pti->guidItem));

            *pbStat = TRUE;
            return TRUE;
        }
    }

    *pbStat = FALSE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\traynot.h ===
#ifndef _TRAYNOT_H
#define _TRAYNOT_H

#include "cwndproc.h"
#include <atlstuff.h>
#include "dpa.h"
#include "traycmn.h"
#include "trayitem.h"
#include "trayreg.h"

#define TNM_GETCLOCK                (WM_USER + 1)
#define TNM_HIDECLOCK               (WM_USER + 2)
#define TNM_TRAYHIDE                (WM_USER + 3)
#define TNM_TRAYPOSCHANGED          (WM_USER + 4)
#define TNM_ASYNCINFOTIP            (WM_USER + 5)
#define TNM_ASYNCINFOTIPPOS         (WM_USER + 6)
#define TNM_RUDEAPP                 (WM_USER + 7)
#define TNM_SAVESTATE               (WM_USER + 8)
#define TNM_NOTIFY                  (WM_USER + 9)
#define TNM_STARTUPAPPSLAUNCHED     (WM_USER + 10)
#define TNM_ENABLEUSERTRACKINGINFOTIPS      (WM_USER + 11)

#define TNM_BANGICONMESSAGE         (WM_USER + 50)
#define TNM_ICONDEMOTETIMER         (WM_USER + 61)
#define TNM_INFOTIPTIMER            (WM_USER + 62)
#define TNM_UPDATEVERTICAL          (WM_USER + 63)
#define TNM_WORKSTATIONLOCKED       (WM_USER + 64)

#define TNM_SHOWTRAYBALLOON         (WM_USER + 90)

#define UID_CHEVRONBUTTON           (-1)

typedef struct
{
    HWND      hWnd;
    UINT      uID;
    TCHAR     szTitle[64];
    TCHAR     szInfo[256];
    UINT      uTimeout;
    DWORD     dwInfoFlags;
} TNINFOITEM;

//
//  For Win64 compat, the icon and hwnd are handed around as DWORDs
//  (so they won't change size as they travel between 32-bit and
//  64-bit processes).
//
#define GetHIcon(pnid)  ((HICON)ULongToPtr(pnid->dwIcon))
#define GetHWnd(pnid)   ((HWND)ULongToPtr(pnid->dwWnd))

//  Everybody has a copy of this function, so we will too!
STDAPI_(void) ExplorerPlaySound(LPCTSTR pszSound);

// defined in tray.cpp
extern BOOL IsPosInHwnd(LPARAM lParam, HWND hwnd);
// defined in taskband.cpp
extern BOOL ToolBar_IsVisible(HWND hwndToolBar, int iIndex);

typedef enum TRAYEVENT {
        TRAYEVENT_ONICONHIDE,
        TRAYEVENT_ONICONUNHIDE,
        TRAYEVENT_ONICONMODIFY,
        TRAYEVENT_ONITEMCLICK,
        TRAYEVENT_ONINFOTIP,
        TRAYEVENT_ONNEWITEMINSERT,
        TRAYEVENT_ONAPPLYUSERPREF,
        TRAYEVENT_ONDISABLEAUTOTRAY,
        TRAYEVENT_ONICONDEMOTETIMER,
} TRAYEVENT;

typedef enum TRAYITEMPOS {
        TIPOS_DEMOTED,
        TIPOS_PROMOTED,
        TIPOS_ALWAYS_DEMOTED,
        TIPOS_ALWAYS_PROMOTED,
        TIPOS_HIDDEN,
        TIPOS_STATUSQUO,
} TRAYITEMPOS;

typedef enum LASTINFOTIPSTATUS {
        LITS_BALLOONNONE,
        LITS_BALLOONDESTROYED,
        LITS_BALLOONXCLICKED
} LASTINFOTIPSTATUS;

typedef enum BALLOONEVENT {
        BALLOONEVENT_USERLEFTCLICK,
        BALLOONEVENT_USERRIGHTCLICK,
        BALLOONEVENT_USERXCLICK,
        BALLOONEVENT_TIMEOUT,
        BALLOONEVENT_NONE,
        BALLOONEVENT_APPDEMOTE,
        BALLOONEVENT_BALLOONHIDE
} BALLOONEVENT;

class CTrayNotify;  // forward declaration...

//
// CTrayNotify class members
//
class CTrayNotify : public CImpWndProc
{
public:
    CTrayNotify() {};
    virtual ~CTrayNotify() {};

    // *** IUnknown methods ***
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** ITrayNotify methods, which are called from the CTrayNotifyStub ***
    STDMETHODIMP SetPreference(LPNOTIFYITEM pNotifyItem);
    STDMETHODIMP RegisterCallback(INotificationCB* pNotifyCB);
    STDMETHODIMP EnableAutoTray(BOOL bTraySetting);

    // *** Properties Sheet methods ***
    BOOL GetIsNoTrayItemsDisplayPolicyEnabled() const
    {
        return _fNoTrayItemsDisplayPolicyEnabled;
    }
    
    BOOL GetIsNoAutoTrayPolicyEnabled() const
    {
        return m_TrayItemRegistry.IsNoAutoTrayPolicyEnabled();
    }

    BOOL GetIsAutoTrayEnabledByUser() const
    {
        return m_TrayItemRegistry.IsAutoTrayEnabledByUser();
    }

    // *** Other ***
    HWND TrayNotifyCreate(HWND hwndParent, UINT uID, HINSTANCE hInst);
    LRESULT TrayNotify(HWND hwndTray, HWND hwndFrom, PCOPYDATASTRUCT pcds, BOOL *pbRefresh);

protected:
    static BOOL GetTrayItemCB(INT_PTR nIndex, void *pCallbackData, TRAYCBARG trayCallbackArg, 
        TRAYCBRET * pOutData);

    void _TickleForTooltip(CNotificationItem *pni);
    void _UpdateChevronSize();
    void _UpdateChevronState(BOOL fBangMenuOpen, BOOL fTrayOrientationChanged, BOOL fUpdateDemotedItems);
    void _UpdateVertical(BOOL fVertical);
    void _OpenTheme();

    void _OnSizeChanged(BOOL fForceRepaint);

    // Tray Animation functions
    DWORD _GetStepTime(int iStep, int cSteps);
    void _ToggleDemotedMenu();
    void _BlankButtons(int iPos, int iNumberOfButtons, BOOL fAddButtons);
    void _AnimateButtons(int iIndex, DWORD dwSleep, int iNumberItems, BOOL fGrow);
    BOOL _SetRedraw(BOOL fRedraw);

    // Tray Icon Activation functions
    void _HideAllDemotedItems(BOOL bHide);
    BOOL _UpdateTrayItems(BOOL bUpdateDemotedItems);
    BOOL _PlaceItem(INT_PTR nIcon, CTrayItem * pti, TRAYEVENT tTrayEvent);
    TRAYITEMPOS _TrayItemPos(CTrayItem * pti, TRAYEVENT tTrayEvent, BOOL *bDemoteStatusChange);
    void _SetOrKillIconDemoteTimer(CTrayItem * pti, TRAYITEMPOS tiPos);

    // WndProc callback functions
    LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    // Callback for the chevron button
    static LRESULT CALLBACK ChevronSubClassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
        LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
    // Callback for the toolbar
    static LRESULT CALLBACK s_ToolbarWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
        LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

    // Icon Image-related functions
    void _RemoveImage(UINT uIMLIndex);
    BOOL _CheckAndResizeImages();

   // InfoTip/Balloon tip functions
    void _ActivateTips(BOOL bActivate);
    void _InfoTipMouseClick(int x, int y, BOOL bRightMouseButtonClick);
    void _PositionInfoTip();
    DWORD _ShowBalloonTip(LPTSTR szTitle, DWORD dwInfoFlags, UINT uTimeout, DWORD dwLastSoundTime);
    void _SetInfoTip(HWND hWnd, UINT uID, LPTSTR pszInfo, LPTSTR pszInfoTitle, 
            DWORD dwInfoFlags, UINT uTimeout, BOOL bAsync);
    void _ShowInfoTip(HWND hwnd, UINT uID, BOOL bShow, BOOL bAsync, UINT uReason);
    void _ShowChevronInfoTip();
    void _EmptyInfoTipQueue();
    void _HideBalloonTip();
    DWORD _GetBalloonWaitInterval(BALLOONEVENT be);
    void _DisableCurrentInfoTip(CTrayItem * ptiTemp, UINT uReason, BOOL bBalloonShowing);
    void _RemoveInfoTipFromQueue(HWND hWnd, UINT uID, BOOL bRemoveFirstOnly = FALSE);
    BOOL _CanShowBalloon();
    BOOL _CanActivateTips()
    {
        return (!_fInfoTipShowing && !_fItemClicked);
    }
    BOOL _IsChevronInfoTip(HWND hwnd, UINT uID)
    {
    	return (hwnd == _hwndNotify && uID == UID_CHEVRONBUTTON);
    }
    
    void _OnWorkStationLocked(BOOL bLocked);
    void _OnRudeApp(BOOL bRudeApp);
    
    // Toolbar Notification helper functions - respond to different user messages
    BOOL _InsertNotify(PNOTIFYICONDATA32 pnid);
    BOOL _DeleteNotify(INT_PTR nIcon, BOOL bShutdown, BOOL bShouldSaveIcon);
    BOOL _ModifyNotify(PNOTIFYICONDATA32 pnid, INT_PTR nIcon, BOOL *pbRefresh, BOOL bFirstTime);
    BOOL _SetVersionNotify(PNOTIFYICONDATA32 pnid, INT_PTR nIcon);
    LRESULT _SendNotify(CTrayItem *pti, UINT uMsg);
    void _SetToolbarHotItem(HWND hWndToolbar, UINT nToolbarIcon);
    INT_PTR _GetToolbarFirstVisibleItem(HWND hWndToolbar, BOOL bFromLast);

    void _NotifyCallback(DWORD dwMessage, INT_PTR nCurrentItem, INT_PTR nPastItem);

    void _SetCursorPos(INT_PTR i);

    // Tray registry setting-related functions
    void _ToggleTrayItems(BOOL bEnable);

    // Initialization/Destroy functions
    LRESULT _Create(HWND hWnd);
    LRESULT _Destroy();

    // Tray repainting helpers
    LRESULT _Paint(HDC hdc);
    LRESULT _HandleCustomDraw(LPNMCUSTOMDRAW pcd);
    void _SizeWindows(int nMaxHorz, int nMaxVert, LPRECT prcTotal, BOOL fSizeWindows);
    LRESULT _CalcMinSize(int nMaxHorz, int nMaxVert);
    LRESULT _Size();

    // Timer/Timer message handling functions
    void _OnInfoTipTimer();
    LRESULT _OnTimer(UINT_PTR uTimerID);
    void _OnIconDemoteTimer(WPARAM wParam, LPARAM lParam);
    
    // Various Message handles
    LRESULT _OnMouseEvent(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnCDNotify(LPNMTBCUSTOMDRAW pnm);
    LRESULT _Notify(LPNMHDR pNmhdr);
    void _OnSysChange(UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnCommand(UINT id, UINT uCmd);
    BOOL _TrayNotifyIcon(PTRAYNOTIFYDATA pnid, BOOL *pbRefresh);

    // User Event Timer functions
    HRESULT _SetItemTimer(CTrayItem *pti);
    HRESULT _KillItemTimer(CTrayItem *pti);
    IUserEventTimer * _CreateTimer(int nTimerFlag);
    HRESULT _SetTimer(int nTimerFlag, UINT uCallbackMessage, UINT uTimerInterval, ULONG * puTimerID);
    HRESULT _KillTimer(int nTimerFlag, ULONG uTimerID);
    BOOL _ShouldDestroyTimer(int nTimerFlag);
    UINT _GetAccumulatedTime(CTrayItem * pti);
    void _NullifyTimer(int nTimerFlag);
    LRESULT _OnKeyDown(WPARAM wChar, LPARAM lFlags);
    void _SetUsedTime();

#ifdef DEBUG
    void _TestNotify();
#endif

    static const TCHAR c_szTrayNotify[] ;
    static const WCHAR c_wzTrayNotifyTheme[];
    static const WCHAR c_wzTrayNotifyHorizTheme[];
    static const WCHAR c_wzTrayNotifyVertTheme[];
    static const WCHAR c_wzTrayNotifyHorizOpenTheme[];
    static const WCHAR c_wzTrayNotifyVertOpenTheme[];

private:
    // Helper/Utility functions
    BOOL _IsScreenSaverRunning();
    UINT _GetQueueCount();

    LONG        m_cRef;

    HWND            _hwndNotify;
    HWND            _hwndChevron;
    HWND            _hwndToolbar;
    HWND            _hwndClock;
    HWND            _hwndPager;
    HWND            _hwndInfoTip;
    HWND            _hwndChevronToolTip;
    HWND            _hwndToolbarInfoTip;

    TCHAR           _szExplorerExeName[MAX_PATH];
    TCHAR *         _pszCurrentThreadDesktopName;
    
    HIMAGELIST      _himlIcons;

    CTrayItemManager    m_TrayItemManager;
    CTrayItemRegistry   m_TrayItemRegistry;

    BOOL            _fKey;
    BOOL            _fReturn;

    BOOL            _fBangMenuOpen;
    
    BOOL            _fHaveDemoted;

    BOOL            _fAnimating;
    BOOL            _fAnimateMenuOpen;
    BOOL            _fRedraw;
    BOOL            _fRepaint;
    BOOL            _fChevronSelected;
    BOOL            _fNoTrayItemsDisplayPolicyEnabled;
    BOOL            _fHasFocus;
    
    RECT            _rcAnimateTotal;
    RECT            _rcAnimateCurrent;
    //
    // Timer for icon info tips..
    //
    ULONG           _uInfoTipTimer;
    
    TNINFOITEM      *_pinfo;    // current balloon being shown
    CDPA<TNINFOITEM> _dpaInfo;

    BOOL            _fInfoTipShowing;
    BOOL            _fItemClicked;
    BOOL            _fEnableUserTrackedInfoTips;

    HTHEME          _hTheme;
    int             _nMaxHorz;
    int             _nMaxVert;

    // command id of the icon which last received a single down-click
    int             _idMouseActiveIcon;

    INotificationCB     * _pNotifyCB;
    
    IUserEventTimer     * m_pIconDemoteTimer;
    IUserEventTimer     * m_pInfoTipTimer;

    BOOL                _fVertical;
    SIZE                _szChevron;
    BOOL                _bStartupIcon;

    BOOL                _bWorkStationLocked;
    BOOL                _bRudeAppLaunched;      // Includes screensaver...
    BOOL				_bWaitAfterRudeAppHide;

    LASTINFOTIPSTATUS   _litsLastInfoTip;

    BOOL                _bWaitingBetweenBalloons;
    BOOL                _bStartMenuAllowsTrayBalloon;
    BALLOONEVENT        _beLastBalloonEvent;
};

#endif  // _TRAYNOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\trayreg.cpp ===
#include "cabinet.h"
#include "traycmn.h"
#include "trayreg.h"
#include "trayitem.h"
#include "shellapi.h"
#include "util.h"

#include "strsafe.h"

BOOL CTrayItemRegistry::_DestroyIconInfoCB(TNPersistStreamData * pData, LPVOID pData2)
{
    delete [] pData;
    return TRUE;
}

void CTrayItemRegistry::_QueryRegValue(HKEY hkey, LPTSTR pszValue, ULONG* puVal, ULONG uDefault, DWORD dwValSize)
{
    if (hkey)
    {
        DWORD dwSize = dwValSize;
        if (ERROR_SUCCESS != RegQueryValueEx(hkey, pszValue, NULL, NULL, (LPBYTE) puVal, &dwSize))
            *puVal = uDefault;
    }
}

void CTrayItemRegistry::IncChevronInfoTipShownInRegistry(BOOL bUserClickedInfoTip/*=FALSE*/)
{
    HKEY hKey = NULL;

    if (_bShowChevronInfoTip)
    {
        if (bUserClickedInfoTip)
        {
            // If the user has clicked the info tip, do not show it in subsequent 
            // sessions...
            _dwTimesChevronInfoTipShown = MAX_CHEVRON_INFOTIP_SHOWN;
        }
        else
        {
            _dwTimesChevronInfoTipShown ++;
        }
    
        if ( (_dwTimesChevronInfoTipShown <= MAX_CHEVRON_INFOTIP_SHOWN) && 
             (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, SZ_TRAYNOTIFY_REGKEY, 0, KEY_WRITE, &hKey)) )
        {  
            RegSetValueEx(hKey, SZ_INFOTIP_REGVALUE, 0, REG_DWORD, 
                            (LPBYTE) &_dwTimesChevronInfoTipShown, sizeof(DWORD));
            RegCloseKey(hKey);
        }
    }

    // The chevron infotip can be shown only once per session...
    _bShowChevronInfoTip = FALSE;
}


void CTrayItemRegistry::InitRegistryValues(UINT uIconListFlags)
{
    HKEY hkeyTrayNotify = NULL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, SZ_TRAYNOTIFY_REGKEY, 0, KEY_QUERY_VALUE, &hkeyTrayNotify))
    {
        // Load the countdown interval for the items when added to the tray
        _QueryRegValue(hkeyTrayNotify, SZ_ICON_COUNTDOWN_VALUE, &_uPrimaryCountdown, TT_ICON_COUNTDOWN_INTERVAL,
            sizeof(DWORD));

        // The length of time for which an item can reside in the past items tray, from 
        // when it was last used...
        _QueryRegValue(hkeyTrayNotify, SZ_ICONCLEANUP_VALUE, &_uValidLastUseTimePeriod, TT_ICONCLEANUP_INTERVAL,
            sizeof(DWORD));

        // The number of times the chevron info tip has been shown...
        // - assume that it hasnt been shown before...
        _QueryRegValue(hkeyTrayNotify, SZ_INFOTIP_REGVALUE, &_dwTimesChevronInfoTipShown, 0, sizeof(DWORD));
        if (_dwTimesChevronInfoTipShown < MAX_CHEVRON_INFOTIP_SHOWN)
            _bShowChevronInfoTip = TRUE;
        else
            _bShowChevronInfoTip = FALSE;

        // The ticking interval for the internal timers for CUserEventTimer, when the
        // CUserEventTimer counts the time for which the item is resident in the tray
        _QueryRegValue(hkeyTrayNotify, SZ_ICONDEMOTE_TIMER_TICK_VALUE, &_uIconDemoteTimerTickInterval, 
            UET_ICONDEMOTE_TIMER_TICK_INTERVAL, sizeof(ULONG));

        // The ticking interval for the internal timers for CUserEventTimer, when the
        // CUserEventTimer counts the time for which the balloon tips show on an item in
        // the tray
        _QueryRegValue(hkeyTrayNotify, SZ_INFOTIP_TIMER_TICK_VALUE, &_uInfoTipTimerTickInterval, 
            UET_INFOTIP_TIMER_TICK_INTERVAL, sizeof(ULONG));

        RegCloseKey(hkeyTrayNotify);
    }
    else
    {
        _uPrimaryCountdown              = TT_ICON_COUNTDOWN_INTERVAL;
        _uValidLastUseTimePeriod          = TT_ICONCLEANUP_INTERVAL;
        _dwTimesChevronInfoTipShown     = 0;
        _bShowChevronInfoTip            = TRUE;
        _uIconDemoteTimerTickInterval     = UET_ICONDEMOTE_TIMER_TICK_INTERVAL;
        _uInfoTipTimerTickInterval         = UET_INFOTIP_TIMER_TICK_INTERVAL;
    }

    // Is the automatic tray (the new Whistler tray feature) enabled ?
    _fNoAutoTrayPolicyEnabled = (SHRestricted(REST_NOAUTOTRAYNOTIFY) != 0);
    _fAutoTrayEnabledByUser = _IsAutoTrayEnabledInRegistry();

    // Load the icon info from the previous session...
    InitTrayItemStream(STGM_READ, NULL, NULL);

    if (!_himlPastItemsIconList)
    {
        _himlPastItemsIconList = ImageList_Create(GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
                                       uIconListFlags, 0, 1);
    }
}

UINT CTrayItemRegistry::GetTimerTickInterval(int nTimerFlag)
{
    switch(nTimerFlag)
    {
        case TF_ICONDEMOTE_TIMER:
            return (UINT) _uIconDemoteTimerTickInterval;
        case TF_INFOTIP_TIMER:
            return (UINT) _uInfoTipTimerTickInterval;
    }

    ASSERT(FALSE);
    return 0;
}

void CTrayItemRegistry::InitTrayItemStream(DWORD dwStreamMode, 
            PFNTRAYNOTIFYCALLBACK pfnTrayNotifyCB, void *pCBData)
{   
    BOOL bDeleteIconStreamRegValue = FALSE;
    
    IStream * pStream = SHOpenRegStream( HKEY_CURRENT_USER, 
                                         SZ_TRAYNOTIFY_REGKEY, 
                                         SZ_ITEMSTREAMS_REGVALUE, 
                                         dwStreamMode );
  
    if (pStream && SUCCEEDED(IStream_Reset(pStream)))
    {
        if (dwStreamMode == STGM_READ)
        {
            _LoadTrayItemStream(pStream, pfnTrayNotifyCB, pCBData);
        }
        else 
        {
            ASSERT(dwStreamMode == STGM_WRITE);
            if (FAILED(_SaveTrayItemStream(pStream, pfnTrayNotifyCB, pCBData)))
                bDeleteIconStreamRegValue = TRUE;
        }

        pStream->Release();
    }

    if (bDeleteIconStreamRegValue)
    {
        HKEY hKey;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, SZ_TRAYNOTIFY_REGKEY, 0, KEY_WRITE, &hKey) == ERROR_SUCCESS)
        {
            ASSERT(hKey);
            RegDeleteValue(hKey, SZ_ITEMSTREAMS_REGVALUE);
            RegCloseKey(hKey);
        }
    }
}

BOOL CTrayItemRegistry::_LoadIconsFromRegStream(DWORD dwItemStreamSignature)
{   
    ASSERT(_himlPastItemsIconList == NULL);

    IStream * pStream = SHOpenRegStream( HKEY_CURRENT_USER, 
                                             SZ_TRAYNOTIFY_REGKEY, 
                                             SZ_ICONSTREAMS_REGVALUE, 
                                             STGM_READ );
  
    if (pStream)
    {
        TNPersistentIconStreamHeader tnPISH = {0};

        if (SUCCEEDED(IStream_Read(pStream, &tnPISH, sizeof(TNPersistentIconStreamHeader))))
        {
            if ( (tnPISH.dwSize == sizeof(TNPersistentIconStreamHeader)) &&
                    (_IsValidStreamHeaderVersion(tnPISH.dwVersion)) &&
                    (tnPISH.dwSignature == dwItemStreamSignature) &&
                    (tnPISH.cIcons > 0) )
            {
                LARGE_INTEGER c_li0 = { 0, 0 };
                c_li0.LowPart = tnPISH.dwOffset;

                if (S_OK == pStream->Seek(c_li0, STREAM_SEEK_SET, NULL))
                {
                    _himlPastItemsIconList = ImageList_Read(pStream);
                }
            }
        }

        pStream->Release();
    }

    return (_himlPastItemsIconList != NULL);
}

HRESULT CTrayItemRegistry::_LoadTrayItemStream(IStream *pstm, PFNTRAYNOTIFYCALLBACK pfnTrayNotifyCB, 
        void *pCBData)
{
    HRESULT hr;
    TNPersistStreamHeader persStmHeader = {0};

    ASSERT(pstm);
    
    hr = IStream_Read(pstm, &persStmHeader, sizeof(persStmHeader));
    if (SUCCEEDED(hr))
    {
        if ( (persStmHeader.dwSize != sizeof(TNPersistStreamHeader)) ||
             (!_IsValidStreamHeaderVersion(persStmHeader.dwVersion)) ||
             (persStmHeader.dwSignature != TNH_SIGNATURE) ||
             (persStmHeader.cIcons <= 0) )
        {
            return E_FAIL;
        }

        LARGE_INTEGER c_li0 = { 0, 0 };
        c_li0.LowPart = persStmHeader.dwOffset;

        if (S_OK == (hr = pstm->Seek(c_li0, STREAM_SEEK_SET, NULL)))
        {
            if (!_dpaPersistentItemInfo)
            {
                if (!_dpaPersistentItemInfo.Create(10))
                    return E_FAIL;
            }

            ASSERT( (persStmHeader.dwVersion != TNH_VERSION_ONE) &&
                    (persStmHeader.dwVersion != TNH_VERSION_TWO) &&
                    (persStmHeader.dwVersion != TNH_VERSION_THREE) );

            for (int i = 0; i < (int)(persStmHeader.cIcons); ++i)
            {
                TNPersistStreamData * ptnpd = new TNPersistStreamData;
                if (ptnpd)
                {
                    hr = IStream_Read(pstm, ptnpd, _SizeOfPersistStreamData(persStmHeader.dwVersion));
                    if (SUCCEEDED(hr))
                    {
                        if (persStmHeader.dwVersion == TNH_VERSION_FOUR)
                        {
                            ptnpd->guidItem = GUID_NULL;
                        }
                    }

                    if (FAILED(hr) || (_dpaPersistentItemInfo.AppendPtr(ptnpd) == -1))
                    {
                        delete (ptnpd);
                        _dpaPersistentItemInfo.DestroyCallback(_DestroyIconInfoCB, NULL);
                        _DestroyPastItemsIconList();
                        hr = E_FAIL;
                        break;
                    }
                }
                else
                {
                    _dpaPersistentItemInfo.DestroyCallback(_DestroyIconInfoCB, NULL);
                    _DestroyPastItemsIconList();
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }

            if (SUCCEEDED(hr))
            {
                if (!_LoadIconsFromRegStream(persStmHeader.dwSignature))
                {
                    if (_dpaPersistentItemInfo)
                    {
                        for (int i = _dpaPersistentItemInfo.GetPtrCount()-1; i >= 0; i--)
                        {
                            (_dpaPersistentItemInfo.GetPtr(i))->nImageIndex = INVALID_IMAGE_INDEX;
                        }
                    }
                }
            }
        }
    }

    return hr;
}

// TO DO : 1. Maybe we can avoid 2 stream writes of the header, maybe a seek will work directly
// 2. If failed, dont store anything, esp. avoid 2 writes
HRESULT CTrayItemRegistry::_SaveTrayItemStream(IStream *pstm, PFNTRAYNOTIFYCALLBACK pfnTrayNotifyCB, 
        void *pCBData)
{
    HRESULT hr;
    DWORD nWrittenIcons = 0;

    TNPersistStreamHeader persStmHeader;

    persStmHeader.dwSize        = sizeof(TNPersistStreamHeader);
    persStmHeader.dwVersion     = TNH_VERSION_FIVE;
    persStmHeader.dwSignature   = TNH_SIGNATURE;
    // The Bang Icon(s) dont count...
    persStmHeader.cIcons        = 0;
    persStmHeader.dwOffset      = persStmHeader.dwSize;

    hr = IStream_Write(pstm, &persStmHeader, sizeof(persStmHeader));
    if (SUCCEEDED(hr))
    {
        // Write the icons in the current session...
        // Since the icons are added to the front of the tray toolbar, the icons
        // in the front of the tray are the ones that have been added last. So
        // maintain this order in writing the icon data into the stream.

        INT_PTR i = 0;
        CTrayItem * pti = NULL;
        HICON hIcon = NULL;
        do
        {
            TRAYCBRET trayCBRet = {0};
            
            pti = NULL;
            hIcon = NULL;

            if (pfnTrayNotifyCB(i, pCBData, TRAYCBARG_ALL, &trayCBRet))
            {
                pti = trayCBRet.pti;
                hIcon = trayCBRet.hIcon;
                if (pti && pti->ShouldSaveIcon())
                {
                    int nPastSessionIndex = DoesIconExistFromPreviousSession(pti, 
                                                    pti->szIconText, hIcon);

                    if (nPastSessionIndex != -1)
                    {
                        DeletePastItem(nPastSessionIndex);
                    }

                    TNPersistStreamData tnPersistData = {0};
                    if (_FillPersistData(&tnPersistData, pti, trayCBRet.hIcon))
                    {
                        if (SUCCEEDED(hr = IStream_Write(pstm, &tnPersistData, sizeof(tnPersistData))))
                        {
                            nWrittenIcons ++;
                        }
                        else
                        {
                            // If we failed to store the item, then remove its corresponding icon
                            // from the icon image list...

                            // Since this icon was appended to the end of the list, and we remove it
                            // we dont need to update all the other item image indices, as they will
                            // not be affected...
                            ImageList_Remove(_himlPastItemsIconList, (INT) i);
                        }
                    }
                }
                if (hIcon)
                    DestroyIcon(hIcon);
            }
            else
            {
                break;
            }
            
            i++;
        } 
        while (TRUE);

        // Write out the icons from the previous sessions..
        if (_dpaPersistentItemInfo)
        {
            INT_PTR nIcons = _dpaPersistentItemInfo.GetPtrCount();
            for (i = 0; i < nIcons; i++)
            {
                TNPersistStreamData * ptnpd = _dpaPersistentItemInfo.GetPtr(i);
                ASSERT(ptnpd);

                BOOL bWritten = FALSE;
                if (_IsIconLastUseValid(ptnpd->wYear, ptnpd->wMonth))
                {
                    if (SUCCEEDED(hr = IStream_Write(pstm, ptnpd, sizeof(TNPersistStreamData))))
                    {
                        nWrittenIcons++;
                        bWritten = TRUE;
                    }
                }

                if (!bWritten)
                {
                    if (ImageList_Remove(_himlPastItemsIconList, (INT) i))
                        UpdateImageIndices(i);
                }
            }
        }
    }

    if (nWrittenIcons <= 0)
        return E_FAIL;
    else
    {
        _SaveIconsToRegStream();
    }

    if (FAILED(hr) || nWrittenIcons > 0)
    {
        persStmHeader.cIcons = nWrittenIcons;
        if (SUCCEEDED(hr = IStream_Reset(pstm)))
            hr = IStream_Write(pstm, &persStmHeader, sizeof(persStmHeader));
    }

    return hr;
}

void CTrayItemRegistry::UpdateImageIndices(INT_PTR nDeletedImageIndex)
{
    if (!_dpaPersistentItemInfo)
        return;

    INT_PTR nPastItemCount = _dpaPersistentItemInfo.GetPtrCount();

    for (INT_PTR i = 0; i < nPastItemCount; i++)
    {
        TNPersistStreamData * ptnpd = _dpaPersistentItemInfo.GetPtr(i);
        if (ptnpd)
        {
            if (ptnpd->nImageIndex > nDeletedImageIndex)
            {
                ptnpd->nImageIndex --;
            }
            else if (ptnpd->nImageIndex == nDeletedImageIndex)
            {
                ptnpd->nImageIndex = INVALID_IMAGE_INDEX;
            }
        }
    }
}


BOOL CTrayItemRegistry::_SaveIconsToRegStream()
{   
    BOOL bStreamWritten = FALSE;

    if (_himlPastItemsIconList)
    {
        IStream * pStream = SHOpenRegStream( HKEY_CURRENT_USER, 
                                             SZ_TRAYNOTIFY_REGKEY, 
                                             SZ_ICONSTREAMS_REGVALUE, 
                                             STGM_WRITE );
  
        if (pStream)
        {
            TNPersistentIconStreamHeader tnPISH = {0};

            tnPISH.dwSize       = sizeof(TNPersistentIconStreamHeader);
            tnPISH.dwVersion    = TNH_VERSION_FIVE;
            tnPISH.dwSignature  = TNH_SIGNATURE;
            tnPISH.cIcons       = ImageList_GetImageCount(_himlPastItemsIconList);
            tnPISH.dwOffset     = tnPISH.dwSize;

            if (tnPISH.cIcons > 0)
            {
                if (SUCCEEDED(IStream_Write(pStream, &tnPISH, sizeof(TNPersistentIconStreamHeader))))
                {
                    if (ImageList_Write(_himlPastItemsIconList, pStream))
                    {
                        bStreamWritten = TRUE;
                    }
                }
            }

            pStream->Release();
        }
    }

    if (!bStreamWritten)
    {
        HKEY hKey;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, SZ_TRAYNOTIFY_REGKEY, 0, KEY_WRITE, &hKey) == ERROR_SUCCESS)
        {
            ASSERT(hKey);
            RegDeleteValue(hKey, SZ_ICONSTREAMS_REGVALUE);
            RegCloseKey(hKey);
        }
    }

    return bStreamWritten;
}


BOOL CTrayItemRegistry::_IsIconLastUseValid(WORD wYear, WORD wMonth)
{
    SYSTEMTIME currentTime = {0};

    GetLocalTime(&currentTime);

    ULONG nCount = 0;

    // wYear/wMonth CANNOT be greater than currentTime.wYear/currentTime.wMonth
    while (nCount < _uValidLastUseTimePeriod)
    {
        if (wYear == currentTime.wYear && wMonth == currentTime.wMonth)
            break;

        wMonth++;
        if (wMonth > 12)
        {
            wYear ++;
            wMonth = 1;
        }
        nCount++;
    }

    return (nCount < _uValidLastUseTimePeriod);
}

BOOL CTrayItemRegistry::_IsAutoTrayEnabledInRegistry()
{
    return (SHRegGetBoolUSValue(SZ_EXPLORER_REGKEY, SZ_AUTOTRAY_REGVALUE, FALSE, TRUE));
}

BOOL CTrayItemRegistry::SetIsAutoTrayEnabledInRegistry(BOOL bAutoTray)
{
    HKEY hKey;

    ASSERT(!_fNoAutoTrayPolicyEnabled);

    if (_fAutoTrayEnabledByUser != bAutoTray)
    {
        _fAutoTrayEnabledByUser = bAutoTray;

        DWORD dwAutoTray = (bAutoTray ? 1 : 0); 

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, SZ_EXPLORER_REGKEY, 0, KEY_WRITE, &hKey))
        {  
            RegSetValueEx(hKey, SZ_AUTOTRAY_REGVALUE, 0, REG_DWORD, (LPBYTE) &dwAutoTray, sizeof(DWORD));
            RegCloseKey(hKey);
        }

        return TRUE;
    }

    return FALSE;
}

INT_PTR CTrayItemRegistry::CheckAndRestorePersistentIconSettings (
    CTrayItem *     pti, 
    LPTSTR          pszIconToolTip,
    HICON           hIcon
)
{
    // If we have icon information from the previous session..
    int i = -1;
    if (_dpaPersistentItemInfo)
    {
        i = DoesIconExistFromPreviousSession(pti, pszIconToolTip, hIcon);
        if (i != -1)
        {
            ASSERT(i >= 0 && i < _dpaPersistentItemInfo.GetPtrCount());

            TNPersistStreamData * ptnpd = _dpaPersistentItemInfo.GetPtr(i);

            ASSERT(ptnpd);
            _RestorePersistentIconSettings(ptnpd, pti);

            return i;
        }
    }

    return (-1);
}

//
// Since we have already taken the previous-session info for this icon,
// there is no need to hold it in our HDPA array...
//
void CTrayItemRegistry::DeletePastItem(INT_PTR nIndex)
{
    if (nIndex != -1)
    {
        ASSERT((nIndex >= 0) && (nIndex < _dpaPersistentItemInfo.GetPtrCount()));

        TNPersistStreamData * ptnpd = _dpaPersistentItemInfo.GetPtr(nIndex);

        if (ptnpd)
        {
            if (_himlPastItemsIconList && (ptnpd->nImageIndex != INVALID_IMAGE_INDEX))
            {
                if (ImageList_Remove(_himlPastItemsIconList, ptnpd->nImageIndex))
                    UpdateImageIndices(ptnpd->nImageIndex);
            }

            delete(ptnpd);
        }

        _dpaPersistentItemInfo.DeletePtr((int)nIndex);
    }
}

void CTrayItemRegistry::_RestorePersistentIconSettings(TNPersistStreamData * ptnpd, CTrayItem * pti)
{
    ASSERT(ptnpd);
    
    pti->SetDemoted(ptnpd->bDemoted);
    pti->dwUserPref = ptnpd->dwUserPref;
    
    // if (NULL == lstrcpyn(pti->szExeName, ptnpd->szExeName, lstrlen(ptnpd->szExeName)+1))
    //    pti->szExeName[0] = '\0';

    if (pti->IsStartupIcon())
    {
        if (ptnpd->bStartupIcon)
        {
            pti->uNumSeconds = ptnpd->uNumSeconds;

#define MAX_NUM_SECONDS_VALUE          TT_ICON_COUNTDOWN_INTERVAL/1000
#define NUM_SECONDS_THRESHOLD                                       30
            
            if (ptnpd->uNumSeconds > MAX_NUM_SECONDS_VALUE - NUM_SECONDS_THRESHOLD)
                pti->uNumSeconds = MAX_NUM_SECONDS_VALUE - NUM_SECONDS_THRESHOLD;
        }                
        else
        // If it wasnt a startup icon in the previous session, then dont take the acculumated time
            pti->uNumSeconds = 0;
    }
    // If it is not a startup icon, the accumulated time doesnt matter
}


int CTrayItemRegistry::DoesIconExistFromPreviousSession (
    CTrayItem * pti, 
    LPTSTR      pszIconToolTip,
    HICON       hIcon
)
{
    ASSERT(pti);
    
    if (!_dpaPersistentItemInfo)
        return -1;

    if (pti->szExeName)
    {
        for (int i = 0; i < _dpaPersistentItemInfo.GetPtrCount(); i++)
        {
            TNPersistStreamData * ptnpd = _dpaPersistentItemInfo.GetPtr(i);

            ASSERT(ptnpd);

            if (lstrcmpi(pti->szExeName, ptnpd->szExeName) == 0)
            {
                if (ptnpd->uID == pti->uID)
                    return i;

                if (hIcon)
                {
                    HICON hIconNew = DuplicateIcon(NULL, hIcon);
                    HICON hIconOld = NULL;

                    if (ptnpd->nImageIndex != INVALID_IMAGE_INDEX)
                        hIconOld = ImageList_GetIcon(_himlPastItemsIconList, ptnpd->nImageIndex, ILD_NORMAL);

                    BOOL bRet = FALSE;
                    if (hIconNew && hIconOld)
                    {
                        bRet = SHAreIconsEqual(hIconNew, hIconOld);
                    }

                    if (hIconNew)
                        DestroyIcon(hIconNew);
                    if (hIconOld)
                        DestroyIcon(hIconOld);

                    if (bRet)
                        return i;
                }

                // We need to check this case for animating icons. We do not know 
                // which icon is showing at the moment the item was deleted from the 
                // tray. 
                // For instance, in the "Network Connections" item, any of 3 
                // "animating" icons could be showing when the item was deleted from 
                // the tray. In this case, the SHAreIconsEqual check (between the 
                // Past icon and the current icon) will fail, still the icons 
                // represent the same item. 
                // There is *no* sure way to catch this case. Adding a tooltip check
                // would strengthen our check. If the two icons have the same tooltip
                // text (till the '\n'), then they will be eliminated.
                // Of course, if an exe placed two icons in the tray, and gave them
                // different IDs but the same tooltip, then one of them will be deemed
                // to be a dupe of the other. But an app shouldnt be placing two icons
                // on the tray if their tips are different.
                if (pszIconToolTip)
                {
                    LPTSTR szTemp = NULL;
                    int nCharToCompare = lstrlen(pszIconToolTip);
                    if ((szTemp = StrChr(pszIconToolTip, (TCHAR)'\n')) != NULL)
                    {
                        nCharToCompare = szTemp-pszIconToolTip;
                    }

                    if (StrCmpNI(pszIconToolTip, ptnpd->szIconText, nCharToCompare) == 0)
                        return i;
                }
            }
        }
    }

    return -1;
}

// Returns TRUE to indicate the function succeeded, fails only if the index is invalid
// *pbStat is set to TRUE if pni is filled in, FALSE if pni is not filled in. pni might
// not be filled in, if the item specified by index doesnt meet specific criteria.
BOOL CTrayItemRegistry::GetTrayItem(INT_PTR nIndex, CNotificationItem * pni, BOOL * pbStat)
{
    if (!_dpaPersistentItemInfo || (nIndex < 0) || (nIndex >= _dpaPersistentItemInfo.GetPtrCount()))
    {
        *pbStat = FALSE;
        return FALSE;
    }
    
    TNPersistStreamData * ptnpd = _dpaPersistentItemInfo.GetPtr(nIndex);

    if (ptnpd && _IsIconLastUseValid(ptnpd->wYear, ptnpd->wMonth))
    {        
        *pni = ptnpd;  // C++ magic...
        if (ptnpd->nImageIndex != INVALID_IMAGE_INDEX)
            pni->hIcon = ImageList_GetIcon(_himlPastItemsIconList, ptnpd->nImageIndex, ILD_NORMAL);
        *pbStat = TRUE;
        return TRUE;
    }

    *pbStat = FALSE;
    return TRUE;
}

BOOL CTrayItemRegistry::SetPastItemPreference(LPNOTIFYITEM pNotifyItem)
{
    if (_dpaPersistentItemInfo && pNotifyItem->pszExeName[0] != 0)
    {
        for (INT_PTR i = _dpaPersistentItemInfo.GetPtrCount()-1; i >= 0; --i)
        {
            TNPersistStreamData * ptnpd = _dpaPersistentItemInfo.GetPtr(i);
            if (ptnpd && ptnpd->uID == pNotifyItem->uID && 
                    lstrcmpi(ptnpd->szExeName, pNotifyItem->pszExeName) == 0)
            {
                ptnpd->dwUserPref = pNotifyItem->dwUserPref;
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL CTrayItemRegistry::AddToPastItems(CTrayItem * pti, HICON hIcon)
{
    if (!_dpaPersistentItemInfo)
        _dpaPersistentItemInfo.Create(10);

    if (_dpaPersistentItemInfo)
    {
        TNPersistStreamData * ptnPersistData = new TNPersistStreamData;
        if (ptnPersistData)
        {
            if (_FillPersistData(ptnPersistData, pti, hIcon))
            {
                if (_dpaPersistentItemInfo.InsertPtr(0, ptnPersistData) != -1)
                {
                    return TRUE;
                }
            }

            delete(ptnPersistData);
        }
    }

    return FALSE;
}

BOOL CTrayItemRegistry::_FillPersistData(TNPersistStreamData * ptnPersistData, CTrayItem * pti, HICON hIcon)
{
    SYSTEMTIME currentTime = {0};
    GetLocalTime(&currentTime);

    if (SUCCEEDED(StringCchCopy(ptnPersistData->szExeName, ARRAYSIZE(ptnPersistData->szExeName), pti->szExeName)))
    {
        ptnPersistData->uID           =     pti->uID;
        ptnPersistData->bDemoted      =     pti->IsDemoted(); 
        ptnPersistData->dwUserPref    =     pti->dwUserPref;
        ptnPersistData->wYear         =     currentTime.wYear;
        ptnPersistData->wMonth        =     currentTime.wMonth;
        ptnPersistData->bStartupIcon  =     pti->IsStartupIcon();
        ptnPersistData->nImageIndex   =     _AddPastIcon(-1, hIcon);  

        memcpy(&(ptnPersistData->guidItem), &(pti->guidItem), sizeof(pti->guidItem));

        StringCchCopy(ptnPersistData->szIconText, ARRAYSIZE(ptnPersistData->szIconText), pti->szIconText);

        if (pti->IsStartupIcon())
        {
            ptnPersistData->uNumSeconds = pti->uNumSeconds;
        }

        return TRUE;
    }

    return FALSE;
}

UINT_PTR CTrayItemRegistry::_SizeOfPersistStreamData(DWORD dwVersion)
{
    ASSERT((dwVersion == TNH_VERSION_FOUR) || (dwVersion == TNH_VERSION_FIVE)); 

    if (dwVersion == TNH_VERSION_FOUR)
        return FIELD_OFFSET(TNPersistStreamData, guidItem);

    return sizeof(TNPersistStreamData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\traynot.cpp ===
#include "cabinet.h"
#include "trayclok.h"
#include <atlstuff.h>
#include "traynot.h"
#include "rcids.h"
#include "tray.h"
#include "util.h"
#include "shellapi.h"

#include "strsafe.h"

//
// Tray Notify Icon area implementation notes / details:
//
// - The icons are held in a toolbar with CTrayItem * on each button's lParam
//

//
// #defines for TrayNotify
//

// Internal Tray Notify Timer IDs
#define TID_DEMOTEDMENU         2
#define TID_BALLOONPOP          3
#define TID_BALLOONPOPWAIT      4
#define TID_BALLOONSHOW         5
#define TID_RUDEAPPHIDE         6               // When a fullscreen (rude) app has gone away


#define KEYBOARD_VERSION        3

#define TT_CHEVRON_INFOTIP_INTERVAL                  30000         //  30 seconds
#define TT_BALLOONPOP_INTERVAL                       50
#define TT_BALLOONPOP_INTERVAL_INCREMENT            30
#define TT_BALLOONSHOW_INTERVAL                     3000          // 3 seconds
#define TT_RUDEAPPHIDE_INTERVAL                    10000          // 10 seconds

#define TT_DEMOTEDMENU_INTERVAL                (2 * g_uDoubleClick)

#define MAX_TIP_WIDTH           300

#define MIN_INFO_TIME           10000  // 10 secs is minimum time a balloon can be up
#define MAX_INFO_TIME           60000  // 1 min is the max time it can be up


// Atleast 2 items are necessary to "demote" them under the chevron...
#define MIN_DEMOTED_ITEMS_THRESHOLD         2

#define PGMP_RECALCSIZE  200

#define BALLOON_INTERVAL_MAX                    10000
#define BALLOON_INTERVAL_MEDIUM                  3000
#define BALLOON_INTERVAL_MIN                     1000

const TCHAR CTrayNotify::c_szTrayNotify[]                   = TEXT("TrayNotifyWnd");
const WCHAR CTrayNotify::c_wzTrayNotifyTheme[]              = L"TrayNotify";
const WCHAR CTrayNotify::c_wzTrayNotifyHorizTheme[]         = L"TrayNotifyHoriz";
const WCHAR CTrayNotify::c_wzTrayNotifyVertTheme[]          = L"TrayNotifyVert";
const WCHAR CTrayNotify::c_wzTrayNotifyHorizOpenTheme[]     = L"TrayNotifyHorizOpen";
const WCHAR CTrayNotify::c_wzTrayNotifyVertOpenTheme[]      = L"TrayNotifyVertOpen";

//
// Global functions...
//
int CALLBACK DeleteDPAPtrCB(TNINFOITEM *pItem, void *pData);

int CALLBACK DeleteDPAPtrCB(TNINFOITEM *pItem, void *pData)
{
    LocalFree(pItem);
    return TRUE;
}

//
// Stub for CTrayNotify, so as to not break the COM rules of refcounting a static object
//
class ATL_NO_VTABLE CTrayNotifyStub :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTrayNotifyStub, &CLSID_TrayNotify>,
    public ITrayNotify
{
public:
    CTrayNotifyStub() {};
    virtual ~CTrayNotifyStub() {};

    DECLARE_NOT_AGGREGATABLE(CTrayNotifyStub)

    BEGIN_COM_MAP(CTrayNotifyStub)
        COM_INTERFACE_ENTRY(ITrayNotify)
    END_COM_MAP()

    // *** ITrayNotify method ***
    STDMETHODIMP SetPreference(LPNOTIFYITEM pNotifyItem);
    STDMETHODIMP RegisterCallback(INotificationCB* pNotifyCB);
    STDMETHODIMP EnableAutoTray(BOOL bTraySetting);
};

//
// CTrayNotifyStub functions...
//
HRESULT CTrayNotifyStub::SetPreference(LPNOTIFYITEM pNotifyItem)
{
    return c_tray._trayNotify.SetPreference(pNotifyItem);
}

HRESULT CTrayNotifyStub::RegisterCallback(INotificationCB* pNotifyCB)
{
    return c_tray._trayNotify.RegisterCallback(pNotifyCB);
}

HRESULT CTrayNotifyStub::EnableAutoTray(BOOL bTraySetting)
{
    return c_tray._trayNotify.EnableAutoTray(bTraySetting);
}

HRESULT CTrayNotifyStub_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk)
{
    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    CComObject<CTrayNotifyStub> *pStub = new CComObject<CTrayNotifyStub>;
    if (pStub)
        return pStub->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    else
        return E_OUTOFMEMORY;
}


//
// CTrayNotify Methods..
//

// IUnknown methods
STDMETHODIMP_(ULONG) CTrayNotify::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CTrayNotify::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        //
        //  TODO:   gpease  27-FEB-2002
        //
        // delete this; Why is this statement missing? If on purpose, why even 
        //  bother with InterlockedXXX and even the refer counter?!?
        //
    }
    return cRef;
}

#ifdef FULL_DEBUG

void CTrayNotify::_TestNotify()
{
    // Loop thru the toolbar
    INT_PTR iCount = m_TrayItemManager.GetItemCount();
    for (int i = 0; i < iCount; i++)
    {
        TBBUTTONINFO tbbi;
        TCHAR szButtonText[MAX_PATH];

        tbbi.cbSize = sizeof(TBBUTTONINFO);
        tbbi.dwMask = TBIF_BYINDEX | TBIF_IMAGE | TBIF_TEXT | TBIF_COMMAND;
        tbbi.pszText = szButtonText;
        tbbi.cchText = ARRAYSIZE(szButtonText);

        INT_PTR j = SendMessage(_hwndToolbar, TB_GETBUTTONINFO, i, (LPARAM)&tbbi);
        if (j != -1)
        {
            TCHAR tempBuf[MAX_PATH];
            StringCchPrintf(tempBuf, ARRAYSIZE(tempBuf), TEXT("Toolbar pos i = %d ==> idCommand = %d, iImage = %d, pszText = %s"), i, tbbi.idCommand, tbbi.iImage, tbbi.pszText);

            MessageBox(NULL, tempBuf, TEXT("My Test Message"), MB_OK);
        }
    }
}

#endif  // DEBUG

void CTrayNotify::_TickleForTooltip(CNotificationItem *pni)
{
    if (pni->pszIconText == NULL || *pni->pszIconText == 0)
    {
        //
        // item hasn't set tooltip yet, tickle it by sending
        // mouse-moved notification
        //
        CTrayItem *pti = m_TrayItemManager.GetItemDataByIndex(
            m_TrayItemManager.FindItemAssociatedWithHwndUid(pni->hWnd, pni->uID));
        if (pti)
        {
            _SendNotify(pti, WM_MOUSEMOVE);
        }
    }
}

HRESULT CTrayNotify::RegisterCallback(INotificationCB* pNotifyCB)
{
    if (!_fNoTrayItemsDisplayPolicyEnabled)
    {
        ATOMICRELEASE(_pNotifyCB);
        if (pNotifyCB)
        {
            pNotifyCB->AddRef();

            // Add Current Items
            int i = 0;
            BOOL bStat = FALSE;
            do 
            {
                CNotificationItem ni;
                if (m_TrayItemManager.GetTrayItem(i++, &ni, &bStat))
                {
                    if (bStat)
                    {
                        pNotifyCB->Notify(NIM_ADD, &ni);
                        _TickleForTooltip(&ni);
                    }
                }
                else
                    break;
            } while (TRUE);

            // Add Past Items
            i = 0;
            bStat = FALSE;
            do 
            {
                CNotificationItem ni;
                if (m_TrayItemRegistry.GetTrayItem(i++, &ni, &bStat))
                {
                    if (bStat)
                        pNotifyCB->Notify(NIM_ADD, &ni);
                }
                else
                    break;
            } while (TRUE);
        }

        _pNotifyCB = pNotifyCB;
    }
    else
    {
        _pNotifyCB = NULL;
    }

    return S_OK;
}

HRESULT CTrayNotify::SetPreference(LPNOTIFYITEM pNotifyItem)
{
    // This function should NEVER be called if the NoTrayItemsDisplayPolicy is enabled...
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    ASSERT(!GetIsNoAutoTrayPolicyEnabled());

    ASSERT( pNotifyItem->dwUserPref == TNUP_AUTOMATIC   ||
            pNotifyItem->dwUserPref == TNUP_DEMOTED     ||
            pNotifyItem->dwUserPref == TNUP_PROMOTED );

    INT_PTR iItem = -1;

    if (pNotifyItem->hWnd)
    {
        iItem = m_TrayItemManager.FindItemAssociatedWithHwndUid(pNotifyItem->hWnd, pNotifyItem->uID);
        if (iItem != -1)
        {
            CTrayItem * pti = m_TrayItemManager.GetItemDataByIndex(iItem);
            if (pti && pti->dwUserPref != pNotifyItem->dwUserPref)
            {
                pti->dwUserPref = pNotifyItem->dwUserPref;
                // If the preference changes, the accumulated time must start again...
                if (pti->IsStartupIcon())
                    pti->uNumSeconds = 0;

                _PlaceItem(iItem, pti, TRAYEVENT_ONAPPLYUSERPREF);
                _Size();

                return S_OK;
            }
        }
    }
    else
    {
        if (m_TrayItemRegistry.SetPastItemPreference(pNotifyItem))
            return S_OK;
    }

    return E_INVALIDARG;
}

UINT CTrayNotify::_GetAccumulatedTime(CTrayItem * pti)
{
    // The global user event timer...
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    IUserEventTimer * pUserEventTimer = _CreateTimer(TF_ICONDEMOTE_TIMER);
    UINT uTimerElapsed = 0;
    if (pUserEventTimer)
    {
        if (SUCCEEDED(pUserEventTimer->GetUserEventTimerElapsed(pti->hWnd, pti->uIconDemoteTimerID, &uTimerElapsed)))
        {
            uTimerElapsed /= 1000;
        }
    }

    return uTimerElapsed;
}

void CTrayNotify::_RemoveImage(UINT uIMLIndex)
{
    INT_PTR nCount;
    INT_PTR i;

    if (uIMLIndex != (UINT)-1) 
    {
        ImageList_Remove(_himlIcons, uIMLIndex);

        nCount = m_TrayItemManager.GetItemCount();
        for (i = nCount - 1; i >= 0; i--) 
        {
            int iImage = m_TrayItemManager.GetTBBtnImage(i);
            if (iImage > (int)uIMLIndex)
                m_TrayItemManager.SetTBBtnImage(i, iImage - 1);
        }
    }
}

//---------------------------------------------------------------------------
// Returns TRUE if either the images are OK as they are or they needed
// resizing and the resize process worked. FALSE otherwise.
BOOL CTrayNotify::_CheckAndResizeImages()
{
    HIMAGELIST himlOld, himlNew;
    int cxSmIconNew, cySmIconNew, cxSmIconOld, cySmIconOld;
    int i, cItems;
    HICON hicon;
    BOOL fOK = TRUE;

    // if (!ptnd)
    //    return 0;

    if (_fNoTrayItemsDisplayPolicyEnabled)
        return fOK;

    himlOld = _himlIcons;

    // Do dimensions match current icons?
    cxSmIconNew = GetSystemMetrics(SM_CXSMICON);
    cySmIconNew = GetSystemMetrics(SM_CYSMICON);
    ImageList_GetIconSize(himlOld, &cxSmIconOld, &cySmIconOld);
    if (cxSmIconNew != cxSmIconOld || cySmIconNew != cySmIconOld)
    {
        // Nope, we're gonna need a new imagelist.
        himlNew = ImageList_Create(cxSmIconNew, cySmIconNew, SHGetImageListFlags(_hwndToolbar), 0, 1);
        if (himlNew)
        {
            // Copy the images over to the new image list.
            cItems = ImageList_GetImageCount(himlOld);
            for (i = 0; i < cItems; i++)
            {
                // REVIEW - there's no way to copy images to an empty
                // imagelist, resizing it on the way.
                hicon = ImageList_GetIcon(himlOld, i, ILD_NORMAL);
                if (hicon)
                {
                    if (ImageList_AddIcon(himlNew, hicon) == -1)
                    {
                        // Couldn't copy image so bail.
                        fOK = FALSE;
                    }
                    DestroyIcon(hicon);
                }
                else
                {
                    fOK = FALSE;
                }

                // FU - bail.
                if (!fOK)
                    break;
            }

            // Did everything copy over OK?
            if (fOK)
            {
                // Yep, Set things up to use the new one.
                _himlIcons = himlNew;
                m_TrayItemManager.SetIconList(_himlIcons);
                // Destroy the old icon cache.
                ImageList_Destroy(himlOld);
                SendMessage(_hwndToolbar, TB_SETIMAGELIST, 0, (LPARAM) _himlIcons);
                SendMessage(_hwndToolbar, TB_AUTOSIZE, 0, 0);
            }
            else
            {
                // Nope, stick with what we have.
                ImageList_Destroy(himlNew);
            }
        }
    }

    return fOK;
}

void CTrayNotify::_ActivateTips(BOOL bActivate)
{
    if (_fNoTrayItemsDisplayPolicyEnabled)
        return;

    if (bActivate && !_CanActivateTips())
        return;

    if (_hwndToolbarInfoTip)
        SendMessage(_hwndToolbarInfoTip, TTM_ACTIVATE, (WPARAM)bActivate, 0);
}

// x,y in client coords

void CTrayNotify::_InfoTipMouseClick(int x, int y, BOOL bRightMouseButtonClick)
{
    if (!_fNoTrayItemsDisplayPolicyEnabled && _pinfo)
    {
        RECT rect;
        GetWindowRect(_hwndInfoTip, &rect);
        // x & y are mapped to our window so map the rect to our window as well
        MapWindowRect(HWND_DESKTOP, _hwndNotify, &rect);   // screen -> client

        POINT pt = {x, y};
        if (PtInRect(&rect, pt))
        {
            SHAllowSetForegroundWindow(_pinfo->hWnd);

            _beLastBalloonEvent = (bRightMouseButtonClick ? BALLOONEVENT_USERRIGHTCLICK : BALLOONEVENT_USERLEFTCLICK);
            _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, FALSE, 
                FALSE, (bRightMouseButtonClick ? NIN_BALLOONTIMEOUT : NIN_BALLOONUSERCLICK));
        }
    }
}

void CTrayNotify::_PositionInfoTip()
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    if (_pinfo)
    {
        int x = 0;
        int y = 0;

        // if (_pinfo->hWnd == _hwndNotify && _pinfo->uID == UID_CHEVRONBUTTON)
        if (_IsChevronInfoTip(_pinfo->hWnd, _pinfo->uID))
        {
            RECT rc;
            GetWindowRect(_hwndChevron, &rc);
            x = rc.left;
            y = rc.top;
        }
        else
        {
            INT_PTR iIndex = m_TrayItemManager.FindItemAssociatedWithHwndUid(_pinfo->hWnd, _pinfo->uID);
            if (iIndex != -1)
            {
                RECT rc;
                if (SendMessage(_hwndToolbar, TB_GETITEMRECT, iIndex, (LPARAM)&rc))
                {
                    MapWindowRect(_hwndToolbar, HWND_DESKTOP, &rc);
                    x = (rc.left + rc.right)/2;
                    y = (rc.top  + rc.bottom)/2;
                }
            
            }
        }

        SendMessage(_hwndInfoTip, TTM_TRACKPOSITION, 0, MAKELONG(x, y));
    }
}

BOOL CTrayNotify::_IsScreenSaverRunning()
{
    BOOL fRunning;
    if (SystemParametersInfo(SPI_GETSCREENSAVERRUNNING, 0, &fRunning, 0))
    {
        return fRunning;
    }

    return FALSE;
}

UINT CTrayNotify::_GetQueueCount()
{
    return _dpaInfo ? _dpaInfo.GetPtrCount() : 0;
}

// NOTE: sligtly different versions of this exist in...
//      SHPlaySound() -> shell32
//      IEPlaySound() -> shdocvw/browseui

STDAPI_(void) ExplorerPlaySound(LPCTSTR pszSound)
{
    // note, we have access only to global system sounds here as we use "Apps\.Default"
    TCHAR szKey[256];
    StringCchPrintf(szKey, ARRAYSIZE(szKey), TEXT("AppEvents\\Schemes\\Apps\\.Default\\%s\\.current"), pszSound);

    TCHAR szFileName[MAX_PATH];
    szFileName[0] = 0;
    LONG cbSize = sizeof(szFileName);

    // test for an empty string, PlaySound will play the Default Sound if we
    // give it a sound it cannot find...

    if ((RegQueryValue(HKEY_CURRENT_USER, szKey, szFileName, &cbSize) == ERROR_SUCCESS)
        && szFileName[0])
    {
        // flags are relevant, we try to not stomp currently playing sounds
        PlaySound(szFileName, NULL, SND_FILENAME | SND_ASYNC | SND_NODEFAULT | SND_NOSTOP);
    }
}

DWORD CTrayNotify::_ShowBalloonTip(LPTSTR szTitle, DWORD dwInfoFlags, UINT uTimeout, DWORD dwLastSoundTime)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    DWORD dwCurrentSoundTime = dwLastSoundTime;
    
    SendMessage(_hwndInfoTip, TTM_SETTITLE, dwInfoFlags & NIIF_ICON_MASK, (LPARAM)szTitle);
    if (!(dwInfoFlags & NIIF_NOSOUND))
    {
        // make sure at least 5 seconds pass between sounds, avoid annoying balloons
        if ((GetTickCount() - dwLastSoundTime) >= 5000)
        {
            dwCurrentSoundTime = GetTickCount();
            ExplorerPlaySound(TEXT("SystemNotification"));
        }
    }

    _PositionInfoTip();

    // if tray is in auto hide mode unhide it
    c_tray.Unhide();
    c_tray._fBalloonUp = TRUE;

    TOOLINFO ti = {0};
    ti.cbSize       = sizeof(ti);
    ti.hwnd         = _hwndNotify;
    ti.uId          = (INT_PTR)_hwndNotify;
    ti.lpszText     = _pinfo->szInfo;

    SendMessage(_hwndInfoTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);

    // disable regular tooltips
    _fInfoTipShowing = TRUE;
    _ActivateTips(FALSE);

    // show the balloon
    SendMessage(_hwndInfoTip, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&ti);

    _SetTimer(TF_INFOTIP_TIMER, TNM_INFOTIPTIMER, uTimeout, &_uInfoTipTimer);    

    return dwCurrentSoundTime;
}

void CTrayNotify::_HideBalloonTip()
{
    _litsLastInfoTip = LITS_BALLOONDESTROYED;

    SendMessage(_hwndInfoTip, TTM_TRACKACTIVATE, (WPARAM)FALSE, (LPARAM)0);

    TOOLINFO ti = {0};
    ti.cbSize = sizeof(ti);
    ti.hwnd = _hwndNotify;
    ti.uId = (INT_PTR)_hwndNotify;
    ti.lpszText = NULL;
    
    SendMessage(_hwndInfoTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);
}

void CTrayNotify::_DisableCurrentInfoTip(CTrayItem * ptiTemp, UINT uReason, BOOL bBalloonShowing)
{
    _KillTimer(TF_INFOTIP_TIMER, _uInfoTipTimer);
    _uInfoTipTimer = 0;

    if (ptiTemp)
    {
        if (!uReason)
        {
            uReason = NIN_BALLOONTIMEOUT;
        }
        _SendNotify(ptiTemp, uReason);
    }
    
    delete _pinfo;
    _pinfo = NULL;

    if (bBalloonShowing)
        _HideBalloonTip();
}

void CTrayNotify::_EmptyInfoTipQueue()
{
    delete _pinfo;
    _pinfo = NULL;
    _dpaInfo.EnumCallback(DeleteDPAPtrCB, NULL);
    _dpaInfo.DeleteAllPtrs();
}

BOOL CTrayNotify::_CanShowBalloon()
{
    if (!_bStartMenuAllowsTrayBalloon || _bWaitingBetweenBalloons || _bWorkStationLocked 
        		|| _bRudeAppLaunched || IsDirectXAppRunningFullScreen() || _bWaitAfterRudeAppHide)
        return FALSE;

    return TRUE;
}

void CTrayNotify::_ShowInfoTip(HWND hwnd, UINT uID, BOOL bShow, BOOL bAsync, UINT uReason)
{
    if (_fNoTrayItemsDisplayPolicyEnabled)
        return;

    // make sure we only show/hide what we intended to show/hide
    if (_pinfo && _pinfo->hWnd == hwnd && _pinfo->uID == uID)
    {
        CTrayItem * pti = NULL;
        INT_PTR nIcon = ( _IsChevronInfoTip(hwnd, uID) ? 
                            -1 : 
                            m_TrayItemManager.FindItemAssociatedWithHwndUid(hwnd, uID) );
        if (nIcon != -1)
            pti = m_TrayItemManager.GetItemDataByIndex(nIcon);

        BOOL bNotify = TRUE;

        if (bShow && pti)
        {
            if (!_fEnableUserTrackedInfoTips || pti->dwUserPref == TNUP_DEMOTED)
            {
                _SendNotify(pti, NIN_BALLOONSHOW);
                _SendNotify(pti, NIN_BALLOONTIMEOUT);
            }
        }

        if ( !_IsChevronInfoTip(hwnd, uID) &&
                ( !pti || pti->IsHidden() 
                  || pti->dwUserPref == TNUP_DEMOTED
                  || !_fEnableUserTrackedInfoTips
                )
            )
        {
            // icon is hidden, cannot show its balloon
            bNotify = !bShow;
            bShow = FALSE; //show the next balloon instead
        }

        if (bShow)
        {
            if (bAsync)
            {
                PostMessage(_hwndNotify, TNM_ASYNCINFOTIP, (WPARAM)hwnd, (LPARAM)uID);
            }
            else if (_CanShowBalloon())
            {
                DWORD dwLastSoundTime = 0;

                if ((nIcon != -1) && pti)
                {
                    _PlaceItem(nIcon, pti, TRAYEVENT_ONINFOTIP);
                    dwLastSoundTime = pti->dwLastSoundTime;
                }

                dwLastSoundTime = _ShowBalloonTip(_pinfo->szTitle, _pinfo->dwInfoFlags, _pinfo->uTimeout, dwLastSoundTime);

                if ((nIcon != -1) && pti)
                {
                    pti->dwLastSoundTime = dwLastSoundTime;
                    _SendNotify(pti, NIN_BALLOONSHOW);
                }
            }
        }
        else
        {
            if (_IsChevronInfoTip(hwnd, uID))
            {
                // If the user clicked on the chevron info tip, we dont want to show the
                // chevron any more, otherwise we want to show it once more the next session
                // for a maximum of 5 sessions...
                m_TrayItemRegistry.IncChevronInfoTipShownInRegistry(uReason == NIN_BALLOONUSERCLICK);
            }

            _DisableCurrentInfoTip(pti, uReason, TRUE);

            _bWaitingBetweenBalloons = TRUE;

            c_tray._fBalloonUp = FALSE;
            _fInfoTipShowing = FALSE;
            _ActivateTips(TRUE);

            // we are hiding the current balloon. are there any waiting? yes, then show the first one
            if (_GetQueueCount())
            {
                _pinfo = _dpaInfo.DeletePtr(0);
                SetTimer(_hwndNotify, TID_BALLOONPOPWAIT, _GetBalloonWaitInterval(_beLastBalloonEvent), NULL);
            }
            else
            {
                _bWaitingBetweenBalloons = FALSE;
                UpdateWindow(_hwndToolbar);
            }
        }
    }
    else if (_pinfo && !bShow)
    {
        // we wanted to hide something that wasn't showing up
        // maybe it's in the queue

        // Remove only the first info tip from this (hwnd, uID)
        _RemoveInfoTipFromQueue(hwnd, uID, TRUE);
    }
}

void CTrayNotify::_SetInfoTip(HWND hWnd, UINT uID, LPTSTR pszInfo, LPTSTR pszInfoTitle,
        DWORD dwInfoFlags, UINT uTimeout, BOOL bAsync)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    // show the new one...
    if (pszInfo[0])
    {
        TNINFOITEM *pii = new TNINFOITEM;
        if (pii)
        {
            pii->hWnd = hWnd;
            pii->uID = uID;
            StringCchCopy(pii->szInfo, ARRAYSIZE(pii->szInfo), pszInfo);
            StringCchCopy(pii->szTitle, ARRAYSIZE(pii->szTitle), pszInfoTitle);
            pii->uTimeout = uTimeout;
            if (pii->uTimeout < MIN_INFO_TIME)
                pii->uTimeout = MIN_INFO_TIME;
            else if (pii->uTimeout > MAX_INFO_TIME)
                pii->uTimeout = MAX_INFO_TIME;
            pii->dwInfoFlags  = dwInfoFlags;

            // if _pinfo is non NULL then we have a balloon showing right now
            if (_pinfo || _GetQueueCount())
            {
                // if this is a different icon making the change request
                // we might have to queue this up
                if (hWnd != _pinfo->hWnd || uID != _pinfo->uID)
                {
                    // if the current balloon has not been up for the minimum 
                    // show delay or there are other items in the queue
                    // add this to the queue
                    if (!_dpaInfo || _dpaInfo.AppendPtr(pii) == -1)
                    {
                        delete pii;
                    }
                    return;
                }

                CTrayItem * ptiTemp = NULL;
                INT_PTR nIcon = m_TrayItemManager.FindItemAssociatedWithHwndUid(_pinfo->hWnd, _pinfo->uID);
                if (nIcon != -1)
                    ptiTemp = m_TrayItemManager.GetItemDataByIndex(nIcon);

                _DisableCurrentInfoTip(ptiTemp, NIN_BALLOONTIMEOUT, FALSE);
            }

            _pinfo = pii;  // in with the new

            _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, TRUE, bAsync, 0);
        }
    }
    else
    {
        // empty text means get rid of the balloon
        _beLastBalloonEvent = BALLOONEVENT_BALLOONHIDE;
        _ShowInfoTip(hWnd, uID, FALSE, FALSE, NIN_BALLOONHIDE);
    }
}

DWORD CTrayNotify::_GetBalloonWaitInterval(BALLOONEVENT be)
{
    switch (be)
    {
        case BALLOONEVENT_USERLEFTCLICK:
            return BALLOON_INTERVAL_MAX;

        case BALLOONEVENT_TIMEOUT:
        case BALLOONEVENT_NONE:
        case BALLOONEVENT_APPDEMOTE:
        case BALLOONEVENT_BALLOONHIDE:
            return BALLOON_INTERVAL_MEDIUM;

        case BALLOONEVENT_USERRIGHTCLICK:
        case BALLOONEVENT_USERXCLICK:
        default:
            return BALLOON_INTERVAL_MIN;
    }
}

BOOL CTrayNotify::_ModifyNotify(PNOTIFYICONDATA32 pnid, INT_PTR nIcon, BOOL *pbRefresh, BOOL bFirstTime)
{
    BOOL fResize = FALSE;

    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    CTrayItem * pti = m_TrayItemManager.GetItemDataByIndex(nIcon);
    if (!pti)
    {
        return FALSE;
    }

    _CheckAndResizeImages();

    if (pnid->uFlags & NIF_STATE) 
    {
#define NIS_VALIDMASK (NIS_HIDDEN | NIS_SHAREDICON)
        DWORD dwOldState = pti->dwState;

        // validate mask
        if (pnid->dwStateMask & ~NIS_VALIDMASK)
        {
            return FALSE;
        }

        pti->dwState = (pnid->dwState & pnid->dwStateMask) | (pti->dwState & ~pnid->dwStateMask);
        
        if (pnid->dwStateMask & NIS_HIDDEN)
        {
            if (pti->IsHidden())
            {
                m_TrayItemManager.SetTBBtnStateHelper(nIcon, TBSTATE_ENABLED, FALSE);
                _PlaceItem(nIcon, pti, TRAYEVENT_ONICONHIDE);
            }
            else 
            {
                // When the icon is inserted the first time, this function is called..
                // If the icon ended the previous session in the secondary tray, then it would
                // start this session in the secondary tray, in which case, the icon should not
                // be enabled...
                if (!bFirstTime)
                {
                    m_TrayItemManager.SetTBBtnStateHelper(nIcon, TBSTATE_ENABLED, TRUE);
                    _PlaceItem(nIcon, pti, TRAYEVENT_ONICONUNHIDE);
                }
            }                
        }

        if ((pnid->dwState ^ dwOldState) & NIS_SHAREDICON) 
        {
            if (dwOldState & NIS_SHAREDICON) 
            {
                // if we're going from shared to not shared, 
                // clear the icon
                m_TrayItemManager.SetTBBtnImage(nIcon, -1);
                pti->hIcon = NULL;
            }
        }
        fResize |= ((pnid->dwState ^ dwOldState) & NIS_HIDDEN);
    }

    if (pnid->uFlags & NIF_GUID)
    {
        memcpy(&(pti->guidItem), &(pnid->guidItem), sizeof(pnid->guidItem));
    }
    
    // The icon is the only thing that can fail, so I will do it first
    if (pnid->uFlags & NIF_ICON)
    {
        int iImageNew, iImageOld;
        HICON hIcon1 = NULL, hIcon2 = NULL;
        BOOL bIsEqualIcon = FALSE;

        iImageOld = m_TrayItemManager.GetTBBtnImage(nIcon);

        if (!bFirstTime)
        {
            if (iImageOld != -1)
            {
                if (_himlIcons)
                {
                    hIcon1 = ImageList_GetIcon(_himlIcons, iImageOld, ILD_NORMAL);
                }

                if (hIcon1)
                {
                    hIcon2 = GetHIcon(pnid);
                }
            }

            if (iImageOld != -1 && hIcon1 && hIcon2)
            {
                bIsEqualIcon = SHAreIconsEqual(hIcon1, hIcon2);
            }

            if (hIcon1)
                DestroyIcon(hIcon1);
        }

        if (pti->IsIconShared()) 
        {
            iImageNew = m_TrayItemManager.FindImageIndex(GetHIcon(pnid), TRUE);
            if (iImageNew == -1)
            {
                return FALSE;
            }
        } 
        else 
        {
            if (GetHIcon(pnid))
            {
                // Replace icon knows how to handle -1 for add
                iImageNew = ImageList_ReplaceIcon(_himlIcons, iImageOld, GetHIcon(pnid));
                if (iImageNew < 0)
                {
                    return FALSE;
                }
            }
            else
            {
                _RemoveImage(iImageOld);
                iImageNew = -1;
            }
            
            if (pti->IsSharedIconSource())
            {
                INT_PTR iCount = m_TrayItemManager.GetItemCount();
                // if we're the source of shared icons, we need to go update all the other icons that
                // are using our icon
                for (INT_PTR i = 0; i < iCount; i++) 
                {
                    if (m_TrayItemManager.GetTBBtnImage(i) == iImageOld) 
                    {
                        CTrayItem * ptiTemp = m_TrayItemManager.GetItemDataByIndex(i);
                        ptiTemp->hIcon = GetHIcon(pnid);
                        m_TrayItemManager.SetTBBtnImage(i, iImageNew);
                    }
                }
            }

            if (iImageOld == -1 || iImageNew == -1)
                fResize = TRUE;
        }
        pti->hIcon = GetHIcon(pnid);
        m_TrayItemManager.SetTBBtnImage(nIcon, iImageNew);

        // Dont count HICON_MODIFies the first time...
        if (!pti->IsHidden() && !bFirstTime)
        {
            pti->SetItemSameIconModify(bIsEqualIcon);
            _PlaceItem(nIcon, pti, TRAYEVENT_ONICONMODIFY);
        }
    }

    if (pnid->uFlags & NIF_MESSAGE)
    {
        pti->uCallbackMessage = pnid->uCallbackMessage;
    }

    if (pnid->uFlags & NIF_TIP)
    {
        m_TrayItemManager.SetTBBtnText(nIcon, pnid->szTip);
        //
        // pnid - NOTIFYICONDATA struct has an szTip of 64 or 128
        // szIconText - CTrayItem has an szTip of MAX_PATH
        // We ensure that pnid->szTip is NULL terminated, but the right thing to do is ensure that we 
        // copy only as many characters as we need, and dont overflow the buffer.
        StringCchCopy(pti->szIconText, min(ARRAYSIZE(pnid->szTip), ARRAYSIZE(pti->szIconText)), pnid->szTip);
    }

    if (fResize)
        _OnSizeChanged(FALSE);

    // need to have info stuff done after resize because we need to
    // position the infotip relative to the hwndToolbar
    if (pnid->uFlags & NIF_INFO)
    {
        // if button is hidden we don't show infotip
        if (!pti->IsHidden())
        {
            _SetInfoTip(pti->hWnd, pti->uID, pnid->szInfo, pnid->szInfoTitle, pnid->dwInfoFlags, 
                    pnid->uTimeout, (bFirstTime || fResize));
        }
    }

    if (!bFirstTime)
        _NotifyCallback(NIM_MODIFY, nIcon, -1);

    return TRUE;
}

BOOL CTrayNotify::_SetVersionNotify(PNOTIFYICONDATA32 pnid, INT_PTR nIcon)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    CTrayItem * pti = m_TrayItemManager.GetItemDataByIndex(nIcon);
    if (!pti)
        return FALSE;

    if (pnid->uVersion < NOTIFYICON_VERSION) 
    {
        pti->uVersion = 0;
        return TRUE;
    } 
    else if (pnid->uVersion == NOTIFYICON_VERSION) 
    {
        pti->uVersion = NOTIFYICON_VERSION;
        return TRUE;
    } 
    else 
    {
        return FALSE;
    }
}

void CTrayNotify::_NotifyCallback(DWORD dwMessage, INT_PTR nCurrentItem, INT_PTR nPastItem)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
    if (_pNotifyCB)
    {
        CNotificationItem * pni = new CNotificationItem;
        if (pni)
        {
            BOOL bStat = FALSE;
            if (nCurrentItem != -1 && m_TrayItemManager.GetTrayItem(nCurrentItem, pni, &bStat) && bStat)
            {
                PostMessage(_hwndNotify, TNM_NOTIFY, dwMessage, (LPARAM)pni);
            }
            else if (nCurrentItem == -1 && nPastItem != -1)
            {
                bStat = FALSE;
                m_TrayItemRegistry.GetTrayItem(nPastItem, pni, &bStat);

                if (bStat)
                    PostMessage(_hwndNotify, TNM_NOTIFY, dwMessage, (LPARAM)pni);
                else
                    delete pni;
            }
            else
                delete pni;
        }
    }
}

void CTrayNotify::_RemoveInfoTipFromQueue(HWND hWnd, UINT uID, BOOL bRemoveFirstOnly /* Default = FALSE */)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    int cItems = _GetQueueCount();

    for (int i = 0; _dpaInfo && (i < cItems); i++)
    {
        TNINFOITEM * pii = _dpaInfo.GetPtr(i);

        if (pii->hWnd == hWnd && pii->uID == uID)
        {
            _dpaInfo.DeletePtr(i);      // this removes the element from the dpa
            delete pii;

            if (bRemoveFirstOnly)
            {
                return;
            }
            else
            {
                i = i-1;
                cItems = _GetQueueCount();
            }
        }
    }
}

BOOL CTrayNotify::_DeleteNotify(INT_PTR nIcon, BOOL bShutdown, BOOL bShouldSaveIcon)
{
    BOOL bRet = FALSE;

    if (_fNoTrayItemsDisplayPolicyEnabled)
        return bRet;

    _NotifyCallback(NIM_DELETE, nIcon, -1);
    CTrayItem *pti = m_TrayItemManager.GetItemDataByIndex(nIcon);
    if (pti)
    {
        _RemoveInfoTipFromQueue(pti->hWnd, pti->uID);

        // delete info tip if showing
        if (_pinfo && _pinfo->hWnd == pti->hWnd && _pinfo->uID == pti->uID)
        {
            // frees pinfo and shows the next balloon if any
            _beLastBalloonEvent = BALLOONEVENT_BALLOONHIDE;
            _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, FALSE, TRUE, NIN_BALLOONHIDE); 
        }

        // Save the icon info only if needed...
        if (bShouldSaveIcon && pti->ShouldSaveIcon())
        {
            if (pti->IsStartupIcon() && !pti->IsDemoted() && pti->dwUserPref == TNUP_AUTOMATIC)
                pti->uNumSeconds = _GetAccumulatedTime(pti);

            // On Delete, add the icon to the past icons list, and the item to the past items list
            HICON hIcon = NULL;
            if (_himlIcons)
            {
                hIcon = ImageList_GetIcon(_himlIcons, m_TrayItemManager.GetTBBtnImage(nIcon), ILD_NORMAL);
            }

            int nPastSessionIndex = m_TrayItemRegistry.DoesIconExistFromPreviousSession(pti, pti->szIconText, hIcon);

            if (nPastSessionIndex != -1)
            {
                _NotifyCallback(NIM_DELETE, -1, nPastSessionIndex);
                m_TrayItemRegistry.DeletePastItem(nPastSessionIndex);
            }

            if (m_TrayItemRegistry.AddToPastItems(pti, hIcon))
                _NotifyCallback(NIM_ADD, -1, 0);

            if (hIcon)
                DestroyIcon(hIcon);
        }
        
        _KillItemTimer(pti);

        bRet = (BOOL) SendMessage(_hwndToolbar, TB_DELETEBUTTON, nIcon, 0);

        if (!bShutdown)
        {
            _UpdateChevronState(_fBangMenuOpen, FALSE, TRUE);
            _OnSizeChanged(FALSE);
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "Removing nIcon %x - pti is NULL", nIcon);
    }

    return bRet;
}


BOOL CTrayNotify::_InsertNotify(PNOTIFYICONDATA32 pnid)
{
    TBBUTTON tbb;

    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    // First insert a totally "default" icon
    CTrayItem * pti = new CTrayItem;
    if (!pti)
    {
        return FALSE;
    }

    pti->hWnd = GetHWnd(pnid);
    pti->uID = pnid->uID;
    if (_bStartupIcon)
        pti->SetStartupIcon(TRUE);

    if (!SUCCEEDED(SHExeNameFromHWND(pti->hWnd, pti->szExeName, ARRAYSIZE(pti->szExeName))))
    {
        pti->szExeName[0] = '\0';
    }

    INT_PTR nPastSessionIndex = m_TrayItemRegistry.CheckAndRestorePersistentIconSettings( pti,
                                    ((pnid->uFlags & NIF_TIP) ? pnid->szTip : NULL),
                                    ((pnid->uFlags & NIF_ICON) ? GetHIcon(pnid) : NULL) );

    tbb.dwData = (DWORD_PTR)pti;
    tbb.iBitmap = -1;
    tbb.idCommand = Toolbar_GetUniqueID(_hwndToolbar);
    tbb.fsStyle = BTNS_BUTTON;
    tbb.fsState = TBSTATE_ENABLED;

    // The "Show Always" flag should be special-cased...
    // If the item didnt exist before, and is added for the first time
    if (nPastSessionIndex == -1)
    {
        if (pnid->dwStateMask & NIS_SHOWALWAYS)
        {
            // Make sure that only the explorer process is setting this mask...
            if ( pti->szExeName && _szExplorerExeName && 
                    lstrcmpi(pti->szExeName, _szExplorerExeName) )
            {
                pti->dwUserPref = TNUP_PROMOTED;
            }
        }
    }
    pnid->dwStateMask &= ~NIS_SHOWALWAYS;

    // If one of the icons had been placed in the secondary tray in the previous session...
    if (pti->IsDemoted() && m_TrayItemRegistry.IsAutoTrayEnabled())
    {   
        tbb.fsState |= TBSTATE_HIDDEN;
    }

    tbb.iString = -1;

    BOOL fRet = TRUE;

    BOOL fRedraw = _SetRedraw(FALSE);

    // Insert at the zeroth position (from the beginning)
    INT_PTR iInsertPos = 0;
    if (SendMessage(_hwndToolbar, TB_INSERTBUTTON, iInsertPos, (LPARAM)&tbb))
    {    
        // Then modify this icon with the specified info
        if (!_ModifyNotify(pnid, iInsertPos, NULL, TRUE))
        {
            _DeleteNotify(iInsertPos, FALSE, FALSE);
            fRet = FALSE;
        }
        // BUG : 404477, Re-entrancy case where traynotify gets a TBN_DELETINGBUTTON
        // when processing a TB_INSERTBUTTON. In this re-entrant scenario, pti is
        // invalid after the TB_INSERTBUTTON above, even though it was created fine
        // before the TB_INSERTBUTTON.
        // Hence check for pti...
        else if (!pti)
        {
            fRet = FALSE;
        }
        else
        {
            // The item has been successfully added to the tray, and the user's
            // settings have been honored. So it can be deleted from the Past Items 
            // list and the Past Items bucket...
            if (nPastSessionIndex != -1)
            {
                _NotifyCallback(NIM_DELETE, -1, nPastSessionIndex);
                m_TrayItemRegistry.DeletePastItem(nPastSessionIndex);
            }

            if (!_PlaceItem(0, pti, TRAYEVENT_ONNEWITEMINSERT))
            {
                _UpdateChevronState(_fBangMenuOpen, FALSE, TRUE);
                _OnSizeChanged(FALSE);
            }
            // _hwndToolbar might not be large enough to hold new icon
            _Size();
        }
    }

    _SetRedraw(fRedraw);

    if (fRet)
        _NotifyCallback(NIM_ADD, iInsertPos, -1);
    
    return fRet;
}



// set the mouse cursor to the center of the button.
// do this becaus our tray notifies don't have enough data slots to
// pass through info about the button's position.
void CTrayNotify::_SetCursorPos(INT_PTR i)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    RECT rc;
    if (SendMessage(_hwndToolbar, TB_GETITEMRECT, i, (LPARAM)&rc)) 
    {
        MapWindowPoints(_hwndToolbar, HWND_DESKTOP, (LPPOINT)&rc, 2);
        SetCursorPos((rc.left + rc.right) / 2, (rc.top + rc.bottom) / 2);
    }
}

LRESULT CTrayNotify::_SendNotify(CTrayItem * pti, UINT uMsg)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    if (pti->uCallbackMessage && pti->hWnd)
       return SendNotifyMessage(pti->hWnd, pti->uCallbackMessage, pti->uID, uMsg);
    return 0;
}

void CTrayNotify::_SetToolbarHotItem(HWND hWndToolbar, UINT nToolbarIcon)
{
    if (!_fNoTrayItemsDisplayPolicyEnabled && hWndToolbar && nToolbarIcon != -1)
    {
        SetFocus(hWndToolbar);
        InvalidateRect(hWndToolbar, NULL, TRUE);
        SendMessage(hWndToolbar, TB_SETHOTITEM, nToolbarIcon, 0);
    }
}

LRESULT CALLBACK CTrayNotify::ChevronSubClassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    CTrayNotify * pTrayNotify = reinterpret_cast<CTrayNotify*>(dwRefData);
    AssertMsg((pTrayNotify != NULL), TEXT("pTrayNotify SHOULD NOT be NULL, as passed to ChevronSubClassWndProc."));

    if (pTrayNotify->_fNoTrayItemsDisplayPolicyEnabled)
    {
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);
    }

    static BOOL bBangMenuOpenLastTime = pTrayNotify->_fBangMenuOpen;

    switch(uMsg)
    {
        case WM_KEYDOWN:
        {
            BOOL fLastHot = FALSE;
            switch(wParam)
            {
                case VK_UP:
                case VK_LEFT:
                    fLastHot = TRUE;
                    // Fall through...

                case VK_DOWN:
                case VK_RIGHT:
                {
                    INT_PTR nToolbarIconSelected = pTrayNotify->_GetToolbarFirstVisibleItem(
                                    pTrayNotify->_hwndToolbar, fLastHot);

                    pTrayNotify->_fChevronSelected = FALSE;
                    if (!fLastHot)
                    {
                        if (nToolbarIconSelected != -1)
                        // The toolbar has been selected
                        {
                            pTrayNotify->_SetToolbarHotItem(pTrayNotify->_hwndToolbar, nToolbarIconSelected);
                        }
                        else if (pTrayNotify->_hwndClock)
                        {
                            SetFocus(pTrayNotify->_hwndClock);
                        }
                        else
                        // No visible items on the tray, no clock, so nothing happens
                        {
                            pTrayNotify->_fChevronSelected = TRUE;
                        }
                    }
                    else
                    {
                        if (pTrayNotify->_hwndClock)
                        {
                            SetFocus(pTrayNotify->_hwndClock);
                        }
                        else if (nToolbarIconSelected != -1)
                        {
                            pTrayNotify->_SetToolbarHotItem(pTrayNotify->_hwndToolbar, nToolbarIconSelected);
                        }
                        else
                        {
                            pTrayNotify->_fChevronSelected = TRUE;
                        }                        
                    }
                    return 0;
                }
                break;

                case VK_RETURN:
                case VK_SPACE:
                    pTrayNotify->_ToggleDemotedMenu();
                    return 0;
            }
        }
        break;

        case WM_SETFOCUS:
        case WM_KILLFOCUS:
            {
                if (pTrayNotify->_hTheme)
                {
                    pTrayNotify->_fHasFocus = (uMsg == WM_SETFOCUS);
                }
            }
            break;

        default:
            if (InRange(uMsg, WM_MOUSEFIRST, WM_MOUSELAST))
            {
                if (bBangMenuOpenLastTime != pTrayNotify->_fBangMenuOpen)
                {
                    TOOLINFO ti = {0};
                    ti.cbSize = sizeof(ti);
                    ti.hwnd = pTrayNotify->_hwndNotify;
                    ti.uId = (UINT_PTR)pTrayNotify->_hwndChevron;
                    ti.lpszText = (LPTSTR)MAKEINTRESOURCE(!pTrayNotify->_fBangMenuOpen ? IDS_SHOWDEMOTEDTIP : IDS_HIDEDEMOTEDTIP);
                    ti.hinst = hinstCabinet;

                    SendMessage(pTrayNotify->_hwndChevronToolTip, TTM_UPDATETIPTEXT, 0, (LPARAM)(LPTOOLINFO)&ti); 
                    bBangMenuOpenLastTime = pTrayNotify->_fBangMenuOpen;
                }

                MSG msg = {0};
                msg.lParam = lParam;
                msg.wParam = wParam;
                msg.message = uMsg;
                msg.hwnd = hwnd;

                SendMessage(pTrayNotify->_hwndChevronToolTip, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
            }
            break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK CTrayNotify::s_ToolbarWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    BOOL fClickDown = FALSE;

    CTrayNotify * pTrayNotify = reinterpret_cast<CTrayNotify*>(dwRefData);
    AssertMsg((pTrayNotify != NULL), TEXT("pTrayNotify SHOULD NOT be NULL, as passed to s_ToolbarWndProc."));

    if (pTrayNotify->_fNoTrayItemsDisplayPolicyEnabled)
    {
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);    
    }

    switch (uMsg)
    {
    case WM_KEYDOWN:
        pTrayNotify->_fReturn = (wParam == VK_RETURN);
        break;

    case WM_CONTEXTMENU:
        {
            INT_PTR i = SendMessage(pTrayNotify->_hwndToolbar, TB_GETHOTITEM, 0, 0);
            if (i != -1)
            {
                CTrayItem * pti = pTrayNotify->m_TrayItemManager.GetItemDataByIndex(i);
                if (lParam == (LPARAM)-1)
                    pTrayNotify->_fKey = TRUE;

                if (pTrayNotify->_fKey)
                {
                    pTrayNotify->_SetCursorPos(i);
                }

                if (pTrayNotify->_hwndToolbarInfoTip)
                    SendMessage(pTrayNotify->_hwndToolbarInfoTip, TTM_POP, 0, 0);
                
                if (pti)
                {
                    SHAllowSetForegroundWindow(pti->hWnd);
                    if (pti->uVersion >= KEYBOARD_VERSION)
                    {
                        pTrayNotify->_SendNotify(pti, WM_CONTEXTMENU);
                    }
                    else
                    {
                        if (pTrayNotify->_fKey)
                        {
                            pTrayNotify->_SendNotify(pti, WM_RBUTTONDOWN);
                            pTrayNotify->_SendNotify(pti, WM_RBUTTONUP);
                        }
                    }
                }
                return 0;
            }
        }
        break;

    default:
        if (InRange(uMsg, WM_MOUSEFIRST, WM_MOUSELAST))
        {
            pTrayNotify->_OnMouseEvent(uMsg, wParam, lParam);
        }
        break;
    }
        
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

void CTrayNotify::_ToggleTrayItems(BOOL bEnable)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
    for (INT_PTR i = m_TrayItemManager.GetItemCount()-1; i >= 0; i--)
    {
        CTrayItem *pti = m_TrayItemManager.GetItemDataByIndex(i);

        if (pti)
        {
            if (bEnable)
            {
                _PlaceItem(i, pti, TRAYEVENT_ONAPPLYUSERPREF);
            }
            else // if (disable)
            {
                _PlaceItem(i, pti, TRAYEVENT_ONDISABLEAUTOTRAY);
                if (_pinfo && _IsChevronInfoTip(_pinfo->hWnd, _pinfo->uID))
                {
                    //hide the balloon 
                    _beLastBalloonEvent = BALLOONEVENT_NONE;
                    _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, FALSE, FALSE, NIN_BALLOONHIDE);
                }
            }
        }
    }    
}

HRESULT CTrayNotify::EnableAutoTray(BOOL bTraySetting)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    // This function will NEVER be called if the auto tray is disabled by policy,
    // or if the system tray is made invisible by policy...
    ASSERT(m_TrayItemRegistry.IsNoAutoTrayPolicyEnabled() == FALSE);

    if (bTraySetting != m_TrayItemRegistry.IsAutoTrayEnabledByUser())
    {
        // NOTENOTE : Always assign this value BEFORE calling _ToggleTrayItems, since the timers
        // are started ONLY if auto tray is enabled..
        m_TrayItemRegistry.SetIsAutoTrayEnabledInRegistry(bTraySetting); 

        // Update the duration that the icon was present in the tray
        _SetUsedTime();

        _ToggleTrayItems(bTraySetting);
    }
    return S_OK;
}

void CTrayNotify::_ShowChevronInfoTip()
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
    if (m_TrayItemRegistry.ShouldChevronInfoTipBeShown() && !SHRestricted(REST_NOSMBALLOONTIP))
    {
        TCHAR szInfoTitle[64];
        LoadString(hinstCabinet, IDS_BANGICONINFOTITLE, szInfoTitle, ARRAYSIZE(szInfoTitle));

        TCHAR szInfoTip[256];
        LoadString(hinstCabinet, IDS_BANGICONINFOTIP1, szInfoTip, ARRAYSIZE(szInfoTip));

        _SetInfoTip(_hwndNotify, UID_CHEVRONBUTTON, szInfoTip, szInfoTitle, 
                TT_CHEVRON_INFOTIP_INTERVAL, NIIF_INFO, FALSE);
    }
}

void CTrayNotify::_SetUsedTime()
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
    for (INT_PTR i = m_TrayItemManager.GetItemCount()-1; i >= 0; i--)
    {
        CTrayItem * pti = m_TrayItemManager.GetItemDataByIndex(i);
        ASSERT(pti);
        if (pti->IsStartupIcon())
        {
            pti->uNumSeconds = (pti->IsIconTimerCurrent() ? _GetAccumulatedTime(pti) 
                                : pti->uNumSeconds);
        }
    }
}

BOOL CTrayNotify::GetTrayItemCB(INT_PTR nIndex, void *pCallbackData, TRAYCBARG trayCallbackArg, 
        TRAYCBRET * pOutData)
{
    ASSERT(pOutData);

    if (pCallbackData)
    {
        CTrayNotify * pTrayNotify = (CTrayNotify *) pCallbackData;

        ASSERT(!pTrayNotify->_fNoTrayItemsDisplayPolicyEnabled);

        if ( (nIndex < 0) || (nIndex >= pTrayNotify->m_TrayItemManager.GetItemCount()) )
            return FALSE;

        switch(trayCallbackArg)
        {
            case TRAYCBARG_ALL:
            case TRAYCBARG_PTI:
                {
                    CTrayItem * pti = pTrayNotify->m_TrayItemManager.GetItemDataByIndex(nIndex);

                    ASSERT(pti);
                    if (pti->IsStartupIcon())
                        pti->uNumSeconds = (pti->IsIconTimerCurrent() ? pTrayNotify->_GetAccumulatedTime(pti) : pti->uNumSeconds);

                    pOutData->pti = pti;
                }
                if (trayCallbackArg == TRAYCBARG_PTI)
                {
                    return TRUE;
                }
                //
                // else fall through..
                //

            case TRAYCBARG_HICON:
                {
                    int nImageIndex = pTrayNotify->m_TrayItemManager.GetTBBtnImage(nIndex);
                    pOutData->hIcon = NULL;
                    if (pTrayNotify->_himlIcons)
                    {
                        pOutData->hIcon = ImageList_GetIcon(pTrayNotify->_himlIcons, nImageIndex, ILD_NORMAL);
                    }
                }
                return TRUE;
        }
    }

    return FALSE;
}

LRESULT CTrayNotify::_Create(HWND hWnd)
{
    LRESULT lres = -1;

    _nMaxHorz = 0x7fff;
    _nMaxVert = 0x7fff;
    _fAnimateMenuOpen       = ShouldTaskbarAnimate();
    _fRedraw                = TRUE;
    _bStartupIcon           = TRUE;
    _fInfoTipShowing        = FALSE;
    _fItemClicked           = FALSE;
    _fChevronSelected       = FALSE;
    _fEnableUserTrackedInfoTips = TRUE;
    _fBangMenuOpen          = FALSE;

    _bWorkStationLocked     = FALSE;
    _bRudeAppLaunched       = FALSE;
    _bWaitAfterRudeAppHide  = FALSE;

    _bWaitingBetweenBalloons   = FALSE;

     // Assume that the start menu has been auto-popped
    _bStartMenuAllowsTrayBalloon       = FALSE;
    _beLastBalloonEvent     = BALLOONEVENT_NONE;

    _litsLastInfoTip        = LITS_BALLOONNONE;

    _fNoTrayItemsDisplayPolicyEnabled = (SHRestricted(REST_NOTRAYITEMSDISPLAY) != 0);
    
    _idMouseActiveIcon      = -1;

    _hwndNotify = hWnd;
    _hwndClock   = ClockCtl_Create(_hwndNotify, IDC_CLOCK, hinstCabinet);

    _hwndPager = CreateWindowEx(0, WC_PAGESCROLLER, NULL,
                        WS_CHILD | WS_TABSTOP | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | PGS_HORZ,
                        0, 0, 0, 0, _hwndNotify, (HMENU) 0, 0, NULL);
    _hwndToolbar = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                        WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS | WS_CLIPCHILDREN | TBSTYLE_TRANSPARENT |
                        WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NORESIZE | TBSTYLE_WRAPABLE,
                        0, 0, 0, 0, _hwndPager, 0, hinstCabinet, NULL);
                        
    _hwndChevron = CreateWindowEx(  0, WC_BUTTON, NULL, 
                        WS_VISIBLE | WS_CHILD, 
                        0, 0, 0, 0, _hwndNotify, (HMENU)IDC_TRAYNOTIFY_CHEVRON, hinstCabinet, NULL);

    if (_hwndNotify)
    {
        DWORD dwExStyle = 0;
        if (IS_WINDOW_RTL_MIRRORED(_hwndNotify))
            dwExStyle |= WS_EX_LAYOUTRTL;

        _hwndChevronToolTip = CreateWindowEx( dwExStyle, TOOLTIPS_CLASS, NULL,
                                WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
                                0, 0, 0, 0, _hwndNotify, NULL, hinstCabinet, NULL);

        _hwndInfoTip = CreateWindowEx( dwExStyle, TOOLTIPS_CLASS, NULL,
                                WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON | TTS_CLOSE,
                                0, 0, 0, 0, _hwndNotify, NULL, hinstCabinet, NULL);

        _himlIcons = ImageList_Create(GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
                                        SHGetImageListFlags(_hwndToolbar), 0, 1);
    }

    // Check to see if any windows failed to create, if so bail
    if (_himlIcons && _hwndNotify && _hwndClock && _hwndToolbar && _hwndPager && _hwndChevron && _hwndChevronToolTip && _hwndInfoTip)
    {
        // Get the explorer exe name, the complete launch path..
        if (!SUCCEEDED(SHExeNameFromHWND(_hwndNotify, _szExplorerExeName, ARRAYSIZE(_szExplorerExeName))))
        {
            _szExplorerExeName[0] = TEXT('\0');
        }

        SetWindowTheme(_hwndClock, c_wzTrayNotifyTheme, NULL);

        SendMessage(_hwndInfoTip, TTM_SETWINDOWTHEME, 0, (LPARAM)c_wzTrayNotifyTheme);
        SendMessage(_hwndToolbar, TB_SETWINDOWTHEME, 0, (LPARAM)c_wzTrayNotifyTheme);

        SetWindowPos(_hwndInfoTip, HWND_TOPMOST,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        TOOLINFO ti = {0};
        RECT     rc = {0,-2,0,0};
        ti.cbSize = sizeof(ti);
        ti.hwnd = _hwndNotify;
        ti.uFlags = TTF_IDISHWND | TTF_TRACK | TTF_TRANSPARENT;
        ti.uId = (UINT_PTR)_hwndNotify;

        // set the version so we can have non buggy mouse event forwarding
        SendMessage(_hwndInfoTip, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(_hwndInfoTip, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
        SendMessage(_hwndInfoTip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)MAX_TIP_WIDTH);
        SendMessage(_hwndInfoTip, TTM_SETMARGIN, 0, (LPARAM)&rc);
        ASSERT(_dpaInfo == NULL);
        _dpaInfo = DPA_Create(10);
    
        // Tray toolbar is a child of the pager control
        SendMessage(_hwndPager, PGM_SETCHILD, 0, (LPARAM)_hwndToolbar);
        
        // Set the window title to help out accessibility apps
        TCHAR szTitle[64];
        LoadString(hinstCabinet, IDS_TRAYNOTIFYTITLE, szTitle, ARRAYSIZE(szTitle));
        SetWindowText(_hwndToolbar, szTitle);

        // Toolbar settings - customize the tray toolbar...
        SendMessage(_hwndToolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(_hwndToolbar, TB_SETPADDING, 0, MAKELONG(2, 2));
        SendMessage(_hwndToolbar, TB_SETMAXTEXTROWS, 0, 0);
        SendMessage(_hwndToolbar, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(_hwndToolbar, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_INVERTIBLEIMAGELIST | TBSTYLE_EX_DOUBLEBUFFER | TBSTYLE_EX_TOOLTIPSEXCLUDETOOLBAR);
        SendMessage(_hwndToolbar, TB_SETIMAGELIST, 0, (LPARAM)_himlIcons);

        _hwndToolbarInfoTip = (HWND)SendMessage(_hwndToolbar, TB_GETTOOLTIPS, 0, 0);
        if (_hwndToolbarInfoTip)
        {
            SHSetWindowBits(_hwndToolbarInfoTip, GWL_STYLE, TTS_ALWAYSTIP, TTS_ALWAYSTIP);
            SetWindowZorder(_hwndToolbarInfoTip, HWND_TOPMOST);
        }

        // if this fails, not that big a deal... we'll still show, but won't handle clicks
        SetWindowSubclass(_hwndToolbar, s_ToolbarWndProc, 0, reinterpret_cast<DWORD_PTR>(this));

        ti.cbSize = sizeof(ti);
        ti.hwnd = _hwndNotify;
        ti.uFlags = TTF_IDISHWND | TTF_EXCLUDETOOLAREA;
        ti.uId = (UINT_PTR)_hwndChevron;
        ti.lpszText = (LPTSTR)MAKEINTRESOURCE(IDS_SHOWDEMOTEDTIP);
        ti.hinst = hinstCabinet;

        SetWindowZorder(_hwndChevronToolTip, HWND_TOPMOST);
        // Set the Chevron as the tool for the tooltip
        SendMessage(_hwndChevronToolTip, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);

        // Subclass the Chevron button, so we can forward mouse messages to the tooltip
        SetWindowSubclass(_hwndChevron, ChevronSubClassWndProc, 0, reinterpret_cast<DWORD_PTR>(this));

        _OpenTheme();

        m_TrayItemRegistry.InitRegistryValues(SHGetImageListFlags(_hwndToolbar));

        m_TrayItemManager.SetTrayToolbar(_hwndToolbar);
        m_TrayItemManager.SetIconList(_himlIcons);

        lres = 0; // Yeah we succeeded
    }

    return lres;
}


LRESULT CTrayNotify::_Destroy()
{
    if (!_fNoTrayItemsDisplayPolicyEnabled)
    {
        for (INT_PTR i = m_TrayItemManager.GetItemCount() - 1; i >= 0; i--)
        {
            _DeleteNotify(i, TRUE, TRUE);
        }
        if (_pinfo)
        {
            delete _pinfo;
            _pinfo = NULL;
        }    
    }
    else
    {
        AssertMsg((_pinfo == NULL), TEXT("_pinfo is being leaked"));
        AssertMsg((!_himlIcons || (ImageList_GetImageCount(_himlIcons) == 0)), TEXT("image list info being leaked"));
    }

    if (_dpaInfo)
    {
        _dpaInfo.DestroyCallback(DeleteDPAPtrCB, NULL);
    }
    
    if (_himlIcons)
    {
        ImageList_Destroy(_himlIcons);
        _himlIcons = NULL;
    }
    
    if (_hwndClock)
    {
        DestroyWindow(_hwndClock);
        _hwndClock = NULL;
    }
    
    if (_hwndToolbar)
    {
        RemoveWindowSubclass(_hwndToolbar, s_ToolbarWndProc, 0);
        DestroyWindow(_hwndToolbar);
        _hwndToolbar = NULL;
    }
    
    if (_hwndChevron)
    {
        RemoveWindowSubclass(_hwndChevron, ChevronSubClassWndProc, 0);
        DestroyWindow(_hwndChevron);
        _hwndChevron = NULL;
    }
    
    if (_hwndInfoTip)
    {
        DestroyWindow(_hwndInfoTip);
        _hwndInfoTip = NULL;
    }
    
    if (_hwndPager)
    {
        DestroyWindow(_hwndPager);
        _hwndPager = NULL;
    }
    
    if (_hTheme)
    {
        CloseThemeData(_hTheme);
        _hTheme = NULL;
    }

    if (_hwndChevronToolTip)
    {
        DestroyWindow(_hwndChevronToolTip);
        _hwndChevronToolTip = NULL;
    }

    if (_pszCurrentThreadDesktopName)
    {
        LocalFree(_pszCurrentThreadDesktopName);
    }

    // Takes care of clearing up registry-related data
    m_TrayItemRegistry.Delete();

    return 0;
}

LRESULT CTrayNotify::_Paint(HDC hdcIn)
{
    PAINTSTRUCT ps;
    HDC hPaintDC = NULL;
    HDC hMemDC = NULL;
    HBITMAP hMemBm = NULL, hOldBm = NULL;

    if (hdcIn)
    {
        hPaintDC = hdcIn;
        GetClipBox(hPaintDC, &ps.rcPaint);
    }
    else
    {
        BeginPaint(_hwndNotify, &ps);

        if (_fRedraw)
        {
            // Create memory surface and map rendering context if double buffering
            // Only make large enough for clipping region
            hMemDC = CreateCompatibleDC(ps.hdc);
            if (hMemDC)
            {
                hMemBm = CreateCompatibleBitmap(ps.hdc, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint));
                if (hMemBm)
                {
                    hOldBm = (HBITMAP) SelectObject(hMemDC, hMemBm);

                    // Offset painting to paint in region
                    OffsetWindowOrgEx(hMemDC, ps.rcPaint.left, ps.rcPaint.top, NULL);
                    hPaintDC = hMemDC;
                }
                else
                {
                    DeleteDC(hMemDC);
                    hPaintDC = NULL;                
                }
            }
        }
        else
        {
            _fRepaint = TRUE;
            hPaintDC = NULL;
        }
    }
    
    if (hPaintDC)
    {
        RECT rc;
        GetClientRect(_hwndNotify, &rc);

        if (_hTheme)
        {
            SHSendPrintRect(GetParent(_hwnd), _hwnd, hPaintDC, &ps.rcPaint);
            
            if (_fAnimating)
            {
                if (_fVertical)
                {
                    rc.top  = rc.bottom - _rcAnimateCurrent.bottom;
                }
                else
                {
                    rc.left = rc.right - _rcAnimateCurrent.right;
                }
            }

            DrawThemeBackground(_hTheme, hPaintDC, TNP_BACKGROUND, 0, &rc, 0);

            if (_fHasFocus)
            {
                LRESULT lRes = SendMessage(_hwndChevron, WM_QUERYUISTATE, 0, 0);
                if (!(LOWORD(lRes) & UISF_HIDEFOCUS))
                {
                    RECT rcFocus = {0};
                    GetClientRect(_hwndChevron, &rcFocus);
                    MapWindowRect(_hwndChevron, _hwndNotify, &rcFocus);
                    // InflateRect(&rcFocus, 2, 2);
                    DrawFocusRect(hPaintDC, &rcFocus);
                }
            }

        }
        else
        {
            FillRect(hPaintDC, &rc, (HBRUSH)(COLOR_3DFACE + 1));
        }
    }

    if (!hdcIn)
    {
        if (hMemDC)
        {
            BitBlt(ps.hdc, ps.rcPaint.left, ps.rcPaint.top, RECTWIDTH(ps.rcPaint), RECTHEIGHT(ps.rcPaint), hMemDC, ps.rcPaint.left, ps.rcPaint.top, SRCCOPY);

            SelectObject(hMemDC, hOldBm);

            DeleteObject(hMemBm);
            DeleteDC(hMemDC);
        }

        EndPaint(_hwndNotify, &ps);
    }

    return 0;
}

LRESULT CTrayNotify::_HandleCustomDraw(LPNMCUSTOMDRAW pcd)
{
    LRESULT lres = CDRF_DODEFAULT;

    // If this policy is enabled, the chevron should NEVER be shown, and if it is not
    // shown, no question about its WM_NOTIFY message handler...
    // ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
    if (_fNoTrayItemsDisplayPolicyEnabled)
    {
        return lres;
    }
    else if (!_hTheme)
    {
        switch (pcd->dwDrawStage)
        {
        case CDDS_PREERASE:
            {
                DWORD dwFlags = 0;
                if (pcd->uItemState & CDIS_HOT)
                {
                    // The chevron is under the pointer, hence the item is hot
                    _fChevronSelected = TRUE;
                    dwFlags |= DCHF_HOT;
                }
                if (!_fVertical)
                {
                    dwFlags |= DCHF_HORIZONTAL;
                }
                if ((!_fBangMenuOpen && _fVertical) || (_fBangMenuOpen && !_fVertical))
                {
                    dwFlags |= DCHF_FLIPPED;
                }
                if (pcd->uItemState & CDIS_FOCUS)
                {
                    if (_fChevronSelected)
                        dwFlags |= DCHF_HOT;
                }

                if (!(pcd->uItemState & CDIS_FOCUS || pcd->uItemState & CDIS_HOT))
                {
                    _fChevronSelected = FALSE;
                }

                DrawChevron(pcd->hdc, &(pcd->rc), dwFlags);
                lres = CDRF_SKIPDEFAULT;
            }
            break;
        }
    }

    return lres;
}

void CTrayNotify::_SizeWindows(int nMaxHorz, int nMaxVert, LPRECT prcTotal, BOOL fSizeWindows)
{
    RECT rcClock, rcPager, rcChevron;
    SIZE szNotify;
    RECT rcBound = { 0, 0, nMaxHorz, nMaxVert };
    RECT rcBorder = rcBound;

    rcChevron.left = rcChevron.top = 0;
    rcChevron.right = !_fNoTrayItemsDisplayPolicyEnabled && _fHaveDemoted ? _szChevron.cx : 0;
    rcChevron.bottom = !_fNoTrayItemsDisplayPolicyEnabled && _fHaveDemoted ? _szChevron.cy : 0;

    if (_hTheme)
    {
        GetThemeBackgroundContentRect(_hTheme, NULL, TNP_BACKGROUND, 0, &rcBound, &rcBorder);
    }
    else
    {
        rcBorder.top += g_cyBorder;
        rcBorder.left += g_cxBorder;
        rcBorder.bottom -= g_cyBorder + 2;
        rcBorder.right -= g_cxBorder + 2;
    }

    static LRESULT s_lRes = 0;
    static int s_nMaxVert = -1;
    if (s_nMaxVert != nMaxVert)
    {
        s_lRes = SendMessage(_hwndClock, WM_CALCMINSIZE, nMaxHorz, nMaxVert);
    }
    rcClock.left = rcClock.top = 0;
    rcClock.right = LOWORD(s_lRes);
    rcClock.bottom = HIWORD(s_lRes);

    szNotify.cx = RECTWIDTH(rcBorder);
    szNotify.cy = RECTHEIGHT(rcBorder);
    SendMessage(_hwndToolbar, TB_GETIDEALSIZE, _fVertical, (LPARAM)&szNotify);

    if (_fVertical)
    {
        int cxButtonSize = LOWORD(SendMessage(_hwndToolbar, TB_GETBUTTONSIZE, 0, 0));
        szNotify.cx -= szNotify.cx % (cxButtonSize ? cxButtonSize : 16);

        // Vertical Taskbar, place the clock on the bottom and icons on the top
        rcChevron.left = rcClock.left = rcBorder.left;
        rcChevron.right = rcClock.right = rcBorder.right;
        rcPager.left = (RECTWIDTH(rcBorder) - szNotify.cx) / 2 + rcBorder.left;
        rcPager.right = rcPager.left + szNotify.cx;
        if (_hTheme)
        {
            rcChevron.left = (nMaxHorz - _szChevron.cx) / 2;
            rcChevron.right = rcChevron.left + _szChevron.cx;
        }
        prcTotal->left = 0;
        prcTotal->right = nMaxHorz;

        // If Notification Icons take up more space than available then just set them to the maximum available size
        int cyTemp = max(rcChevron.bottom, rcBorder.top);
        int cyTotal = cyTemp + rcClock.bottom + (nMaxVert - rcBorder.bottom);
        rcPager.top = 0;
        rcPager.bottom = min(szNotify.cy, nMaxVert - cyTemp);
        
        OffsetRect(&rcPager, 0, cyTemp);
        OffsetRect(&rcClock, 0, rcPager.bottom);

        prcTotal->top = 0;
        prcTotal->bottom = rcClock.bottom + (nMaxVert - rcBorder.bottom);
    }
    else
    {
        int cyButtonSize = HIWORD(SendMessage(_hwndToolbar, TB_GETBUTTONSIZE, 0, 0));
        szNotify.cy -= szNotify.cy % (cyButtonSize ? cyButtonSize : 16);

        // Horizontal Taskbar, place the clock on the right and icons on the left
        rcChevron.top = rcClock.top = rcBorder.top;
        rcChevron.bottom = rcClock.bottom = rcBorder.bottom;
        rcPager.top = ((RECTHEIGHT(rcBorder) - szNotify.cy) / 2) + rcBorder.top;
        rcPager.bottom = rcPager.top + szNotify.cy;
        if (_hTheme)
        {
            rcChevron.top = ((RECTHEIGHT(rcBorder) - _szChevron.cy) / 2) + rcBorder.top;
            rcChevron.bottom = rcChevron.top + _szChevron.cy;
        }
        prcTotal->top    = 0;
        prcTotal->bottom = nMaxVert;

        // If Notification Icons take up more space than available then just set them to the maximum available size
        int cxTemp = max(rcChevron.right, rcBorder.left);
        int cxTotal = cxTemp + rcClock.right + (nMaxHorz - rcBorder.right);
        rcPager.left = 0;
        rcPager.right = min(szNotify.cx, nMaxHorz - cxTemp);
        
        OffsetRect(&rcPager, cxTemp, 0);
        OffsetRect(&rcClock, rcPager.right, 0);

        prcTotal->left = 0;
        prcTotal->right = rcClock.right + (nMaxHorz - rcBorder.right);
    }

    if (fSizeWindows)
    {
        if (_fAnimating)
        {
            RECT rcWin;
            GetWindowRect(_hwndNotify, &rcWin);
            int offsetX = _fVertical ? 0: RECTWIDTH(rcWin) - RECTWIDTH(*prcTotal);
            int offsetY = _fVertical ? RECTHEIGHT(rcWin) - RECTHEIGHT(*prcTotal) : 0;
            OffsetRect(&rcClock, offsetX, offsetY);
            OffsetRect(&rcPager, offsetX, offsetY);
            OffsetRect(&rcChevron, offsetX, offsetY);
        }

        SetWindowPos(_hwndClock,   NULL, rcClock.left,   rcClock.top,   RECTWIDTH(rcClock),   RECTHEIGHT(rcClock),   SWP_NOZORDER);
        SetWindowPos(_hwndToolbar, NULL, 0,              0,             szNotify.cx,          szNotify.cy,           SWP_NOZORDER | SWP_NOCOPYBITS);
        SetWindowPos(_hwndPager,   NULL, rcPager.left,   rcPager.top,   RECTWIDTH(rcPager),   RECTHEIGHT(rcPager),   SWP_NOZORDER | SWP_NOCOPYBITS);
        SetWindowPos(_hwndChevron, NULL, rcChevron.left, rcChevron.top, RECTWIDTH(rcChevron), RECTHEIGHT(rcChevron), SWP_NOZORDER | SWP_NOCOPYBITS);

        SendMessage(_hwndPager, PGMP_RECALCSIZE, (WPARAM) 0, (LPARAM) 0);
    }

    if (_fAnimating)
    {
        _rcAnimateCurrent = *prcTotal;
        *prcTotal = _rcAnimateTotal;
    }

    if (fSizeWindows)
    {
        RECT rcInvalid = *prcTotal;
        if (_fVertical)
        {
            rcInvalid.bottom = rcPager.bottom;
        }
        else
        {
            rcInvalid.right = rcPager.right;
        }
        InvalidateRect(_hwndNotify, &rcInvalid, FALSE);
        UpdateWindow(_hwndNotify);
    }
}

LRESULT CTrayNotify::_CalcMinSize(int nMaxHorz, int nMaxVert)
{
    RECT rcTotal;

    _nMaxHorz = nMaxHorz;
    _nMaxVert = nMaxVert;

    if (!(GetWindowLong(_hwndClock, GWL_STYLE) & WS_VISIBLE) && !m_TrayItemManager.GetItemCount()) 
    {
        // If we are visible, but have nothing to show, then hide ourselves
        ShowWindow(_hwndNotify, SW_HIDE);
        return 0L;
    } 
    else if (!IsWindowVisible(_hwndNotify))
    {
        ShowWindow(_hwndNotify, SW_SHOW);
    }

    _SizeWindows(nMaxHorz, nMaxVert, &rcTotal, FALSE);

    // Add on room for borders
    return(MAKELRESULT(rcTotal.right, rcTotal.bottom));
}

LRESULT CTrayNotify::_Size()
{
    RECT rcTotal;
    // use GetWindowRect because _SizeWindows includes the borders
    GetWindowRect(_hwndNotify, &rcTotal);
    // Account for borders on the left and right
    _SizeWindows(RECTWIDTH(rcTotal), RECTHEIGHT(rcTotal), &rcTotal, TRUE);

    return(0);
}

void CTrayNotify::_OnInfoTipTimer()
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
    _KillTimer(TF_INFOTIP_TIMER, _uInfoTipTimer);
    _uInfoTipTimer = 0;
    if (_pinfo)
    {
        _beLastBalloonEvent = BALLOONEVENT_TIMEOUT;
        _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, FALSE, FALSE, NIN_BALLOONTIMEOUT); // hide this balloon and show new one
    }
}

LRESULT CTrayNotify::_OnTimer(UINT_PTR uTimerID)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
    if (uTimerID == TID_DEMOTEDMENU)
    {
        if (_fBangMenuOpen)
            _ToggleDemotedMenu();
    }
    else if (uTimerID == TID_BALLOONPOP)
    {
        // When the user clicks the 'X' to close a balloon tip, this timer is set.
        // Ensure that the currently showing balloon tip (the one on which the user
        // clicked the 'X') is completely hidden, before showing the next balloon in
        // the queue.
        // 
        // Tooltips are layered windows, and comctl32 implements a fadeout effect on
        // them. So there is a time period during which a tooltip is still visible
        // after it has been asked to be deleted/hidden.
        if (IsWindowVisible(_hwndInfoTip))
        {
            SetTimer(_hwndNotify, TID_BALLOONPOP, TT_BALLOONPOP_INTERVAL_INCREMENT, NULL);
        }
        else
        {
            KillTimer(_hwndNotify, TID_BALLOONPOP);
            if (_pinfo)
            {
                _beLastBalloonEvent = BALLOONEVENT_USERXCLICK;
                _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, FALSE, FALSE, NIN_BALLOONTIMEOUT);
            }
            // This is called only when the user has clicked the 'X'.
            _litsLastInfoTip = LITS_BALLOONXCLICKED;
        }
    }
    else if (uTimerID == TID_BALLOONPOPWAIT)
    {
        KillTimer(_hwndNotify, TID_BALLOONPOPWAIT);
        _bWaitingBetweenBalloons = FALSE;
        if (_pinfo)
        {
            _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, TRUE, TRUE, 0);
        }
    }
    else if (uTimerID == TID_BALLOONSHOW)
    {
        KillTimer(_hwndNotify, TID_BALLOONSHOW);

        _bStartMenuAllowsTrayBalloon = TRUE;
        if (_pinfo)
        {
            _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, TRUE, TRUE, NIN_BALLOONSHOW);
        }
    }
    else if (uTimerID == TID_RUDEAPPHIDE)
    {
        KillTimer(_hwndNotify, TID_RUDEAPPHIDE);

        if (_pinfo && _bWaitAfterRudeAppHide)
        {
            _bWaitAfterRudeAppHide = FALSE;
            _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, TRUE, TRUE, NIN_BALLOONSHOW);            
        }

        _bWaitAfterRudeAppHide = FALSE;
    }
    else
    {
        AssertMsg(FALSE, TEXT("CTrayNotify::_OnTimer() not possible"));
    }

    return 0;
}

BOOL _IsClickDown(UINT uMsg)
{
    switch (uMsg)
    {
    case WM_LBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_LBUTTONDBLCLK:
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        return TRUE;
    }
    return FALSE;
}

BOOL _UseCachedIcon(UINT uMsg)
{
    switch (uMsg)
    {
    case WM_LBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MOUSEMOVE:
    case WM_MOUSEWHEEL:
        return FALSE;
    }
    return TRUE;
}

LRESULT CTrayNotify::_OnMouseEvent(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Icons can jump around between the time we get a down-click message and
    // the time we get a double-click or up-click message.  E.g. clicking on
    // the bang icon expands the hidden stuff, or an icon might delete itself
    // in response to the down-click.
    //
    // It's undesirable for a different icon to get the corresponding double-
    // or up-click in this case (very annoying to the user).
    //
    // To deal with this, cache the icon down-clicked and use that cached value
    // (instead of the button the mouse is currently over) on double- or up-click.


    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    // The mouse cursor has moved over the toolbar, so if the chevron was selected
    // earlier, it should not be anymore.
    _fChevronSelected = FALSE;

    BOOL fClickDown = _IsClickDown(uMsg);
    BOOL fUseCachedIcon = _UseCachedIcon(uMsg);

    INT_PTR i = -1;

    if (fUseCachedIcon)
    {
        i = ToolBar_CommandToIndex(_hwndToolbar, _idMouseActiveIcon);
    }

    if (i == -1)
    {
        POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
        i = SendMessage(_hwndToolbar, TB_HITTEST, 0, (LPARAM)&pt);
        if (fClickDown)
            _idMouseActiveIcon = ToolBar_IndexToCommand(_hwndToolbar, i);
    }

    CTrayItem *pti = m_TrayItemManager.GetItemDataByIndex(i);
    if (pti) 
    {
        if (IsWindow(pti->hWnd)) 
        {
            if (fClickDown) 
            {
                SHAllowSetForegroundWindow(pti->hWnd);

                if (_pinfo && _pinfo->hWnd == pti->hWnd && _pinfo->uID == pti->uID)
                {
                    if (uMsg == WM_RBUTTONDOWN || uMsg == WM_RBUTTONDBLCLK)
                        _beLastBalloonEvent = BALLOONEVENT_USERRIGHTCLICK;
                    else
                        _beLastBalloonEvent = BALLOONEVENT_USERLEFTCLICK;
                    _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, FALSE, FALSE, NIN_BALLOONUSERCLICK);
                }

                if (fClickDown)
                {
                    // down clicks count as activation
                    _PlaceItem(i, pti, TRAYEVENT_ONITEMCLICK);
                }
                
                _fItemClicked = TRUE;
                _ActivateTips(FALSE);
            }
                
            _SendNotify(pti, uMsg);
        } 
        else 
        {
            _DeleteNotify(i, FALSE, TRUE);
        }
        return 1;
    }
    return 0;
}

LRESULT CTrayNotify::_OnCDNotify(LPNMTBCUSTOMDRAW pnm)
{
    switch (pnm->nmcd.dwDrawStage)
    {
        case CDDS_PREPAINT:
            return CDRF_NOTIFYITEMDRAW;
        
        case CDDS_ITEMPREPAINT:
        {
            LRESULT lRet = TBCDRF_NOOFFSET;

            // notify us for the hot tracked item please
            if (pnm->nmcd.uItemState & CDIS_HOT)
                lRet |= CDRF_NOTIFYPOSTPAINT;

            // we want the buttons to look totally flat all the time
            pnm->nmcd.uItemState = 0;

            return  lRet;
        }

        case CDDS_ITEMPOSTPAINT:
        {
            // draw the hot tracked item as a focus rect, since
            // the tray notify area doesn't behave like a button:
            //   you can SINGLE click or DOUBLE click or RCLICK
            //   (kybd equiv: SPACE, ENTER, SHIFT F10)
            //
            LRESULT lRes = SendMessage(_hwndNotify, WM_QUERYUISTATE, 0, 0);
            if (!(LOWORD(lRes) & UISF_HIDEFOCUS) && _hwndToolbar == GetFocus())
            {
                DrawFocusRect(pnm->nmcd.hdc, &pnm->nmcd.rc);
            }
            break;
        }
    }

    return CDRF_DODEFAULT;
}

LRESULT CTrayNotify::_Notify(LPNMHDR pNmhdr)
{
    LRESULT lRes = 0;
    switch (pNmhdr->code)
    {
    case TTN_POP:               // a balloontip/tooltip is about to be hidden...
        if (pNmhdr->hwndFrom == _hwndInfoTip)
        {
            // If this infotip was hidden by means other than the user click on the
            // 'X', the code path sets _litsLastInfoTip to LITS_BALLOONDESTROYED
            // before the infotip is to be hidden...
            //
            // If _litsLastInfoTip is not set to LITS_BALLOONDESTROYED, the infotip
            // was deleted by the user click on the 'X' (that being the only other
            // way to close the infotip). comctl32 sends us a TTN_POP *before* it 
            // hides the infotip. Don't set the next infotip to show immediately.
            // (The hiding code would then hide the infotip for the next tool, since the
            // hwnds are the same). Set a timer in this case, and show the
            // next infotip, after ensuring that the current one is truly hidden...
            if ( (_litsLastInfoTip == LITS_BALLOONXCLICKED) ||
                 (_litsLastInfoTip == LITS_BALLOONNONE) )
            {
                _KillTimer(TF_INFOTIP_TIMER, _uInfoTipTimer);
                SetTimer(_hwndNotify, TID_BALLOONPOP, TT_BALLOONPOP_INTERVAL, NULL);
            }
            _litsLastInfoTip = LITS_BALLOONXCLICKED;
        }
        break;

    case NM_KEYDOWN:
        _fKey = TRUE;
        break;

    case TBN_ENDDRAG:
        _fKey = FALSE;
        break;

    case TBN_DELETINGBUTTON:
        {
            ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
            TBNOTIFY* ptbn = (TBNOTIFY*)pNmhdr;
            CTrayItem *pti = (CTrayItem *)(void *)ptbn->tbButton.dwData;
            // can be null if its a blank button used for the animation
            if (pti)
            {
                //if it wasn't sharing an icon with another guy, go ahead and delete it
                if (!pti->IsIconShared()) 
                    _RemoveImage(ptbn->tbButton.iBitmap);

                delete pti;
            }
        }
        break;

    case BCN_HOTITEMCHANGE:
    case TBN_HOTITEMCHANGE:
        {
            ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
            DWORD dwFlags = (pNmhdr->code == BCN_HOTITEMCHANGE) ? ((LPNMBCHOTITEM)pNmhdr)->dwFlags : ((LPNMTBHOTITEM)pNmhdr)->dwFlags;

            if (dwFlags & HICF_LEAVING)
            {
                _fItemClicked = FALSE;
                _ActivateTips(TRUE);
            }
            
            if (_fBangMenuOpen)
            {
                if (dwFlags & HICF_LEAVING)
                {
                    //
                    // When hottracking moves between button and toolbar,
                    // we get the HICF_ENTERING for one before we get the
                    // HICF_LEAVING for the other.  So before setting the
                    // timer to hide the bang menu, we check to see if the
                    // other control has a hot item.
                    //
                    BOOL fOtherHot;
                    if (pNmhdr->code == BCN_HOTITEMCHANGE)
                    {
                        fOtherHot = (SendMessage(_hwndToolbar, TB_GETHOTITEM, 0, 0) != -1);
                    }
                    else
                    {
                        fOtherHot = BOOLIFY(SendMessage(_hwndChevron, BM_GETSTATE, 0, 0) & BST_HOT);
                    }

                    if (!fOtherHot)
                    {
                        SetTimer(_hwndNotify, TID_DEMOTEDMENU, TT_DEMOTEDMENU_INTERVAL, NULL);
                    }
                }
                else if (dwFlags & HICF_ENTERING)
                {
                    KillTimer(_hwndNotify, TID_DEMOTEDMENU);
                }
            }
        }
        break;

    case TBN_WRAPHOTITEM:
        {
            ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
            NMTBWRAPHOTITEM * pnmWrapHotItem = (NMTBWRAPHOTITEM *) pNmhdr;

            // If the user hit a key on the tray toolbar icon and it was the first 
            // visible item in the tray toolbar, then maybe we want to go to the 
            // chevron button...
            switch (pnmWrapHotItem->iDir)
            {
                // Left/Up
                case -1:
                    if (_fHaveDemoted)
                    {
                        SetFocus(_hwndChevron);
                        _fChevronSelected = TRUE;
                    }
                    else if (_hwndClock)
                    {
                        SetFocus(_hwndClock);
                        _fChevronSelected = FALSE;
                    }
                    else
                    // do nothing
                    {
                        _fChevronSelected = FALSE;
                    }
                    break;

                // Right/Down
                case 1:
                    if (_hwndClock)
                    {
                        SetFocus(_hwndClock);
                        _fChevronSelected = FALSE;
                    }
                    else if (_fHaveDemoted)
                    {
                        SetFocus(_hwndChevron);
                        _fChevronSelected = TRUE;
                    }
                    else
                    {
                        _fChevronSelected = FALSE;
                    }
                    break;
                }
                break;
        }
        break;

    // NOTENOTE: This notification DOESNT need to be checked. Pager forwards its notifications
    // to our child toolbar control, and TBN_HOTITEMCHANGE above handles this case..    
    case PGN_HOTITEMCHANGE:
        {
            LPNMTBHOTITEM pnmhot = (LPNMTBHOTITEM)pNmhdr;

            if  (pnmhot->dwFlags & HICF_LEAVING)
            {
                _fItemClicked = FALSE;
                _ActivateTips(TRUE);
            }
            
            if (_fBangMenuOpen)
            {
                if (pnmhot->dwFlags & HICF_LEAVING)
                {
                    SetTimer(_hwndNotify, TID_DEMOTEDMENU, TT_DEMOTEDMENU_INTERVAL, NULL);
                }
                else if (pnmhot->dwFlags & HICF_ENTERING)
                {
                    KillTimer(_hwndNotify, TID_DEMOTEDMENU);
                }
            }
        }
        break;

    case PGN_CALCSIZE:
        {
            LPNMPGCALCSIZE   pCalcSize = (LPNMPGCALCSIZE)pNmhdr;

            switch(pCalcSize->dwFlag)
            {
                case PGF_CALCWIDTH:
                {
                    //Get the optimum WIDTH of the toolbar.
                    RECT rcToolBar;
                    GetWindowRect(_hwndToolbar, &rcToolBar);
                    pCalcSize->iWidth = RECTWIDTH(rcToolBar);
                }
                break;

                case PGF_CALCHEIGHT:
                {
                    //Get the optimum HEIGHT of the toolbar.
                    RECT rcToolBar;
                    GetWindowRect(_hwndToolbar, &rcToolBar);
                    pCalcSize->iHeight = RECTHEIGHT(rcToolBar);
                }
                break;
            }
        }

    case NM_CUSTOMDRAW:
        if (pNmhdr->hwndFrom == _hwndChevron)
        {
            return _HandleCustomDraw((LPNMCUSTOMDRAW)pNmhdr);
        }
        else
        {
            return _OnCDNotify((LPNMTBCUSTOMDRAW)pNmhdr);
        }
        break;
    }

    return lRes;
}

void CTrayNotify::_OnSysChange(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == WM_WININICHANGE)
    {
        _CheckAndResizeImages();
        if (lParam == SPI_SETMENUANIMATION || lParam == SPI_SETUIEFFECTS || (!wParam && 
            (!lParam || (lstrcmpi((LPTSTR)lParam, TEXT("Windows")) == 0))))
        {
            _fAnimateMenuOpen = ShouldTaskbarAnimate();
        }
    }

    if (_hwndClock)
        SendMessage(_hwndClock, uMsg, wParam, lParam);
}

void CTrayNotify::_OnCommand(UINT id, UINT uCmd)
{
    if (id == IDC_TRAYNOTIFY_CHEVRON)
    {
        AssertMsg(!_fNoTrayItemsDisplayPolicyEnabled, TEXT("Impossible-the chevron shouldnt be shown"));
        switch(uCmd)
        {
            case BN_SETFOCUS:
                break;

            default:
                _ToggleDemotedMenu();
                break;
        }
    }
    else
    {
        switch (uCmd)
        {
            case BN_CLICKED:
            {
                ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
                CTrayItem *pti = m_TrayItemManager.GetItemData(id, FALSE, _hwndToolbar);
                if (pti)
                {
                    if (_fKey)
                        _SetCursorPos(SendMessage(_hwndToolbar, TB_COMMANDTOINDEX, id, 0));

                    SHAllowSetForegroundWindow(pti->hWnd);
                    if (pti->uVersion >= KEYBOARD_VERSION)
                    {
                        // if they are a new version that understands the keyboard messages,
                        // send the real message to them.
                        _SendNotify(pti, _fKey ? NIN_KEYSELECT : NIN_SELECT);
                        // Hitting RETURN is like double-clicking (which in the new
                        // style means keyselecting twice)
                        if (_fKey && _fReturn)
                            _SendNotify(pti, NIN_KEYSELECT);
                    }
                    else
                    {
                        // otherwise mock up a mouse event if it was a keyboard select
                        // (if it wasn't a keyboard select, we assume they handled it already on
                        // the WM_MOUSE message
                        if (_fKey)
                        {
                            _SendNotify(pti, WM_LBUTTONDOWN);
                            _SendNotify(pti, WM_LBUTTONUP);
                            if (_fReturn)
                            {
                                _SendNotify(pti, WM_LBUTTONDBLCLK);
                                _SendNotify(pti, WM_LBUTTONUP);
                            }
                        }
                    }
                }
                break;
            }
        }
    }
}

void CTrayNotify::_OnSizeChanged(BOOL fForceRepaint)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
    if (_pinfo)
    {
        // if balloon is up we have to move it, but we cannot straight up
        // position it because traynotify will be moved around by tray
        // so we do it async

        PostMessage(_hwndNotify, TNM_ASYNCINFOTIPPOS, 0, 0);
    }
    c_tray.VerifySize(TRUE);

    if (fForceRepaint)
        UpdateWindow(_hwndToolbar);
}

#define TT_ANIMATIONLENGTH  20    // sum of all the animation steps
#define TT_ANIMATIONPAUSE  30      // extra pause for last step

DWORD CTrayNotify::_GetStepTime(int iStep, int cSteps)
{
    // our requirements here are:
    //
    // - animation velocity should decrease linearly with time
    //
    // - total animation time should be a constant, TT_ANIMATIONLENGTH
    //   (it should not vary with number of icons)
    //
    // - figure this out without using floating point math
    //
    // hence the following formula
    //

    if (cSteps == 0)
    {
        return 0;
    }
    else if (iStep == cSteps && cSteps > 2)
    {
        return TT_ANIMATIONPAUSE;
    }
    else
    {
        int iNumerator = (TT_ANIMATIONLENGTH - cSteps) * iStep;
        int iDenominator = (cSteps + 1) * cSteps;

        return (iNumerator / iDenominator);
    }
}

void CTrayNotify::_ToggleDemotedMenu()
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    _ActivateTips(FALSE);

    int iAnimStep = 1;  // animation steps are 1-based
    int cNumberDemoted = (int) m_TrayItemManager.GetDemotedItemCount();

    if (_fAnimateMenuOpen)
    {
        if (!_fBangMenuOpen)
        {
            _BlankButtons(0, cNumberDemoted, TRUE);
        }

        GetWindowRect(_hwndNotify, &_rcAnimateTotal);
        _SizeWindows(_fVertical ? RECTWIDTH(_rcAnimateTotal) : _nMaxHorz, _fVertical ? _nMaxVert : RECTHEIGHT(_rcAnimateTotal), &_rcAnimateTotal, FALSE);

        if (!_fBangMenuOpen)
        {
            _BlankButtons(0, cNumberDemoted, FALSE); 
        }

        _fAnimating = TRUE;   // Begin Animation loop

        if (!_fBangMenuOpen)
        {
            _OnSizeChanged(TRUE);
        }
    }

    for (INT_PTR i = m_TrayItemManager.GetItemCount() - 1; i >= 0; i--)
    {
        CTrayItem * pti = m_TrayItemManager.GetItemDataByIndex(i);
        if (!pti->IsHidden() && pti->IsDemoted())
        {
            DWORD dwSleep = _GetStepTime(iAnimStep, cNumberDemoted);
            iAnimStep++;

            if (_fBangMenuOpen)
            {
                m_TrayItemManager.SetTBBtnStateHelper(i, TBSTATE_HIDDEN, TRUE);
            }

            if (_fAnimateMenuOpen)
            {
                _AnimateButtons((int) i, dwSleep, cNumberDemoted, !_fBangMenuOpen);
            }

            if (!_fBangMenuOpen)
            {
                m_TrayItemManager.SetTBBtnStateHelper(i, TBSTATE_HIDDEN, FALSE);
            }

            if (_fAnimateMenuOpen)
            {
                _SizeWindows(_fVertical ? RECTWIDTH(_rcAnimateTotal) : _nMaxHorz, _fVertical ? _nMaxVert : RECTHEIGHT(_rcAnimateTotal), &_rcAnimateTotal, TRUE);
            }
        }
    }

    _fAnimating = FALSE;   // End Animation loop

    if (_fBangMenuOpen)
    {
        KillTimer(_hwndNotify, TID_DEMOTEDMENU);
    }

    _ActivateTips(TRUE);
    _UpdateChevronState(!_fBangMenuOpen, FALSE, _fBangMenuOpen);
    _OnSizeChanged(TRUE);
}

void CTrayNotify::_BlankButtons(int iPos, int iNumberOfButtons, BOOL fAddButtons)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    BOOL fRedraw = _SetRedraw(FALSE);

    TBBUTTON tbb;
    tbb.dwData = NULL;
    tbb.iBitmap = -1;
    tbb.fsStyle = BTNS_BUTTON;
    tbb.iString = -1;
    tbb.fsState = TBSTATE_INDETERMINATE;
    
    for (int i = 0; i < iNumberOfButtons; i++)
    {
        if (fAddButtons)
        {
            tbb.idCommand = Toolbar_GetUniqueID(_hwndToolbar);
        }
        //insert all blank buttons at the front of the toolbar
        SendMessage(_hwndToolbar, fAddButtons ? TB_INSERTBUTTON : TB_DELETEBUTTON, iPos, fAddButtons ? (LPARAM)&tbb : 0);
    }

    _SetRedraw(fRedraw);
}

#define TT_ANIMATIONSTEP 3
#define TT_ANIMATIONSTEPBASE 100
#define TT_ANIMATIONWRAPPAUSE  25 // pause for no animation for row wraps

void CTrayNotify::_AnimateButtons(int iIndex, DWORD dwSleep, int iNumberItems, BOOL fGrow)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    BOOL fInSameRow = TRUE;

    _BlankButtons((int) iIndex, 1, TRUE);

    if ((iIndex + 2 < m_TrayItemManager.GetItemCount()) && (iIndex > 0))
    {
        RECT rcItem1, rcItem2;
        SendMessage(_hwndToolbar, TB_GETITEMRECT, fGrow ? iIndex + 2 : iIndex - 1, (LPARAM)&rcItem1);
        SendMessage(_hwndToolbar, TB_GETITEMRECT, iIndex, (LPARAM)&rcItem2);
        fInSameRow = (rcItem1.top == rcItem2.top);
    }

    if (fInSameRow)
    {
        // target width of button
        WORD wWidth = LOWORD(SendMessage(_hwndToolbar, TB_GETBUTTONSIZE, 0, 0));

        int iAnimationStep = (iNumberItems * iNumberItems) / TT_ANIMATIONSTEPBASE;
        iAnimationStep = max(iAnimationStep, TT_ANIMATIONSTEP);

        TBBUTTONINFO tbbi;
        tbbi.cbSize = sizeof(TBBUTTONINFO);
        tbbi.dwMask = TBIF_SIZE | TBIF_BYINDEX;

        // Set the size of the buttons
        for (WORD cx = 1; cx < wWidth; cx += (WORD) iAnimationStep) 
        {
            tbbi.cx = fGrow ? cx : wWidth - cx;
            SendMessage(_hwndToolbar, TB_SETBUTTONINFO, iIndex, (LPARAM) &tbbi);

            RECT rcBogus;
            _SizeWindows(_fVertical ? RECTWIDTH(_rcAnimateTotal) : _nMaxHorz, _fVertical ? _nMaxVert : RECTHEIGHT(_rcAnimateTotal), &rcBogus, TRUE);

            Sleep(dwSleep);
        }

        if (fGrow)
        {
            // set the grow button back to normal size
            tbbi.cx = 0;
            SendMessage(_hwndToolbar, TB_SETBUTTONINFO, iIndex, (LPARAM) &tbbi);
        }
    }

    _BlankButtons((int) iIndex, 1, FALSE);
}

BOOL CTrayNotify::_SetRedraw(BOOL fRedraw)
{
    BOOL fOldRedraw = _fRedraw;
    _fRedraw = fRedraw;

    SendMessage(_hwndToolbar, WM_SETREDRAW, fRedraw, 0);
    if (_fRedraw)
    {
        if (_fRepaint)
        {
            InvalidateRect(_hwndNotify, NULL, FALSE);
            UpdateWindow(_hwndNotify);
        }
    }
    else
    {
        _fRepaint = FALSE;
    }

    return fOldRedraw;
}

void CTrayNotify::_OnIconDemoteTimer(WPARAM wParam, LPARAM lParam)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    INT_PTR nIcon = m_TrayItemManager.FindItemAssociatedWithTimer(lParam);
    if (nIcon >= 0)
    {
        CTrayItem *pti = m_TrayItemManager.GetItemDataByIndex(nIcon);
        ASSERT(pti);

        _PlaceItem(nIcon, pti, TRAYEVENT_ONICONDEMOTETIMER);
    }
    else
    {
        // It looks like a timer for a now-defunct icon.  Go ahead and kill it.
        // Though we do handle this case, it's odd for it to happen, so spew a
        // warning.
        TraceMsg(TF_WARNING, "CTrayNotify::_OnIconDemoteTimer -- killing zombie timer %x", lParam);
        _KillTimer(TF_ICONDEMOTE_TIMER, (UINT) lParam);
    }
}

BOOL CTrayNotify::_UpdateTrayItems(BOOL bUpdateDemotedItems)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    BOOL bDemoteItemsOverThreshold = ( m_TrayItemRegistry.IsAutoTrayEnabled() ? 
                                       m_TrayItemManager.DemotedItemsPresent(MIN_DEMOTED_ITEMS_THRESHOLD) :
                                       FALSE );

    if (bUpdateDemotedItems || !m_TrayItemRegistry.IsAutoTrayEnabled())
    {
        _HideAllDemotedItems(bDemoteItemsOverThreshold);
    }

    return bDemoteItemsOverThreshold;
}

void CTrayNotify::_HideAllDemotedItems(BOOL bHide)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    for (INT_PTR i = m_TrayItemManager.GetItemCount()-1; i >= 0; i--)
    {
        CTrayItem * pti = m_TrayItemManager.GetItemDataByIndex(i);
        ASSERT(pti);

        if (!pti->IsHidden() && pti->IsDemoted() && (pti->dwUserPref == TNUP_AUTOMATIC))
        {
            m_TrayItemManager.SetTBBtnStateHelper(i, TBSTATE_HIDDEN, bHide);
        }
    }
}

BOOL CTrayNotify::_PlaceItem(INT_PTR nIcon, CTrayItem * pti, TRAYEVENT tTrayEvent)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    BOOL bDemoteStatusChange = FALSE;
    if (!pti)
        return bDemoteStatusChange;

    TRAYITEMPOS tiPos = _TrayItemPos(pti, tTrayEvent, &bDemoteStatusChange);

    if (bDemoteStatusChange || tiPos == TIPOS_HIDDEN)
    {
        if (pti->IsStartupIcon() && (pti->IsDemoted() || tiPos == TIPOS_HIDDEN))
            pti->uNumSeconds = 0;

        if (!_fBangMenuOpen || pti->IsHidden())
        {
            if ( (pti->IsDemoted() || tiPos == TIPOS_HIDDEN) && 
                        _pinfo && (_pinfo->hWnd == pti->hWnd) && (_pinfo->uID == pti->uID) )
            {
                //hide the balloon
                _beLastBalloonEvent = BALLOONEVENT_APPDEMOTE;
                _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, FALSE, FALSE, NIN_BALLOONHIDE);
            }

            // hide/show
            m_TrayItemManager.SetTBBtnStateHelper( nIcon, 
                                TBSTATE_HIDDEN, 
                                (pti->IsHidden() || (m_TrayItemRegistry.IsAutoTrayEnabled() && pti->IsDemoted())) );

            if (bDemoteStatusChange)
            {
                _UpdateChevronState(_fBangMenuOpen, FALSE, TRUE);
                _OnSizeChanged(FALSE);
            }
        }
    }

    _SetOrKillIconDemoteTimer(pti, tiPos);

    return bDemoteStatusChange;
}

TRAYITEMPOS CTrayNotify::_TrayItemPos(CTrayItem * pti, TRAYEVENT tTrayEvent, BOOL *bDemoteStatusChange)
{   
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    TRAYITEMPOS tiPos      = TIPOS_STATUSQUO;

    *bDemoteStatusChange = FALSE;

    if (!pti)
        return tiPos;

    switch(tTrayEvent)
    {
        case TRAYEVENT_ONDISABLEAUTOTRAY:
            if (!pti->IsHidden())
            {
                tiPos = TIPOS_ALWAYS_PROMOTED;

                if (pti->IsStartupIcon() && !pti->IsDemoted() && pti->dwUserPref == TNUP_AUTOMATIC)
                    pti->uNumSeconds = _GetAccumulatedTime(pti);

                *bDemoteStatusChange = TRUE;

                pti->SetOnceVisible(TRUE);
                pti->SetItemClicked(FALSE);
            }
            break;

        case TRAYEVENT_ONITEMCLICK:
        case TRAYEVENT_ONICONMODIFY:
        case TRAYEVENT_ONINFOTIP:
            if (!pti->IsHidden())
                pti->SetOnceVisible(TRUE);

            if (m_TrayItemRegistry.IsAutoTrayEnabled() && !pti->IsHidden())
            {
                if ( (tTrayEvent == TRAYEVENT_ONICONMODIFY) &&
                     (pti->IsItemSameIconModify()) )
                {
                    break;
                }
                else if (pti->dwUserPref == TNUP_AUTOMATIC)
                {
                    // If the item has been clicked on, note it...
                    if (tTrayEvent == TRAYEVENT_ONITEMCLICK)
                    {
                        pti->SetItemClicked(TRUE);
                    }

                    tiPos = TIPOS_PROMOTED;
                    if (pti->IsDemoted())
                    {
                        pti->SetDemoted(FALSE);
                        *bDemoteStatusChange = TRUE;
                    }
                }
            }
            break;

        case TRAYEVENT_ONAPPLYUSERPREF:
        case TRAYEVENT_ONNEWITEMINSERT:
            if (!pti->IsHidden())
                pti->SetOnceVisible(TRUE);

            if (m_TrayItemRegistry.IsAutoTrayEnabled() && !pti->IsHidden())
            {
                if (pti->dwUserPref == TNUP_AUTOMATIC)
                {
                    tiPos = (pti->IsDemoted() ? TIPOS_DEMOTED : TIPOS_PROMOTED);
                    if (pti->IsDemoted())
                    {
                        // (1) New Item Insert : The new item is inserted. If it was demoted in the 
                        //     previous session, the setting has carried over, and is copied over
                        //     before this function is called (in InsertNotify->_PlaceItem). Use this
                        //     setting to determine if the item is to be demoted.
                        // (2) Apply User Pref : This is called in two cases :
                        //     (a) SetPreference : When the user clicks OK on the Notifications Prop
                        //         dialog. Since dwUserPref is TNUP_AUTOMATIC, use the current demoted
                        //         setting of the item. Do not change the demoted setting of the item
                        //     (b) EnableAutoTray : The AutoTray feature has been enabled. Demote the
                        //         icon only if it was already demoted before. When the icon was 
                        //         inserted, its previous demote setting was copied. So if its previous
                        //         demote setting was TRUE, then the item should be demoted, otherwise
                        //         it shouldnt be.
                        // So, in effect, in all these cases, if dwUserPref was TNUP_AUTOMATIC, there
                        // is no necessity to change the demote setting, but some cases, it is necessary
                        // to hide the icon.
                        *bDemoteStatusChange = TRUE;
                    }
                }
                else
                {
                    pti->SetDemoted(pti->dwUserPref == TNUP_DEMOTED);

                    tiPos = ((pti->dwUserPref == TNUP_DEMOTED) ? TIPOS_ALWAYS_DEMOTED : TIPOS_ALWAYS_PROMOTED);

                    *bDemoteStatusChange = TRUE;

                    pti->SetItemClicked(FALSE);
                }
            }
            break;

        case TRAYEVENT_ONICONDEMOTETIMER:
            // Hidden items cannot have timers, and we will never get this event if 
            // the item was hidden...
            ASSERT(!pti->IsHidden());
            ASSERT(m_TrayItemRegistry.IsAutoTrayEnabled());

            tiPos = TIPOS_DEMOTED;
            if (!pti->IsDemoted())
            {
                pti->SetDemoted(TRUE);
                *bDemoteStatusChange = TRUE;
            }
            pti->SetItemClicked(FALSE);
            break;

        case TRAYEVENT_ONICONHIDE:
            tiPos = TIPOS_HIDDEN;
            if (pti->IsDemoted() || pti->dwUserPref == TNUP_DEMOTED)
            {
                pti->SetDemoted(FALSE);
                *bDemoteStatusChange = TRUE;
            }
            pti->SetItemClicked(FALSE);
            break; 

        case TRAYEVENT_ONICONUNHIDE:
            pti->SetOnceVisible(TRUE);
            *bDemoteStatusChange = TRUE;

            if (m_TrayItemRegistry.IsAutoTrayEnabled())
            {
                if ((pti->dwUserPref == TNUP_AUTOMATIC) || (pti->dwUserPref == TNUP_PROMOTED))
                {
                    tiPos = ((pti->dwUserPref == TNUP_AUTOMATIC) ? TIPOS_PROMOTED : TIPOS_ALWAYS_PROMOTED);
                    if (pti->IsDemoted())
                    {
                        pti->SetDemoted(FALSE);
                    }
                }
                else
                {
                    ASSERT(pti->dwUserPref == TNUP_DEMOTED);
                    tiPos = TIPOS_ALWAYS_DEMOTED;
                    if (!pti->IsDemoted())
                    {
                        pti->SetDemoted(TRUE);
                    }
                }
            }
            else 
            // NO-AUTO-TRAY mode...
            {
                tiPos = TIPOS_ALWAYS_PROMOTED;
            }
            pti->SetItemClicked(FALSE);
            break;
    }

    return tiPos;
}


void CTrayNotify::_SetOrKillIconDemoteTimer(CTrayItem * pti, TRAYITEMPOS tiPos)
{
    switch(tiPos)
    {
    case TIPOS_PROMOTED:
        _SetItemTimer(pti);
        break;

    case TIPOS_DEMOTED:
    case TIPOS_HIDDEN:
    case TIPOS_ALWAYS_DEMOTED:
    case TIPOS_ALWAYS_PROMOTED:
        _KillItemTimer(pti);
        break;

    case TIPOS_STATUSQUO:
        break;
    }
}

LRESULT CTrayNotify::_OnKeyDown(WPARAM wChar, LPARAM lFlags)
{
    if (_hwndClock && _hwndClock == GetFocus())
    {
        BOOL fLastHot = FALSE;

        //
        // handle keyboard messages forwarded by clock
        //
        switch (wChar)
        {
        case VK_UP:
        case VK_LEFT:
            fLastHot = TRUE;
            //
            // fall through
            //

        case VK_DOWN:
        case VK_RIGHT:
            {
                if (_fNoTrayItemsDisplayPolicyEnabled)
                {
                    SetFocus(_hwndClock);
                    // this is moot, since the chevron will not be shown
                    _fChevronSelected = FALSE;
                    return 0;
                }
                else
                {
                    INT_PTR nToolbarIconSelected = -1;
                    if (fLastHot || !_fHaveDemoted)
                    {
                        nToolbarIconSelected = _GetToolbarFirstVisibleItem(_hwndToolbar, fLastHot);
                    }

                    if (nToolbarIconSelected != -1)
                    {
                        //
                        // make it the hot item
                        //
                        _SetToolbarHotItem(_hwndToolbar, nToolbarIconSelected);
                        _fChevronSelected = FALSE;
                    }
                    else if (_fHaveDemoted)
                    {
                        SetFocus(_hwndChevron);
                        _fChevronSelected = TRUE;
                    }

                    return 0;
                }
            }

        case VK_RETURN:
        case VK_SPACE:
            //
            // run the default applet in timedate.cpl
            //
            SHRunControlPanel(TEXT("timedate.cpl"), _hwnd);
            return 0;
        }
    }

    return 1;
}

void CTrayNotify::_OnWorkStationLocked(BOOL bLocked)
{
    _bWorkStationLocked = bLocked;

    if (!_bWorkStationLocked && !_fNoTrayItemsDisplayPolicyEnabled && 
        _fEnableUserTrackedInfoTips && _pinfo)
    {
        _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, TRUE, TRUE, NIN_BALLOONSHOW);
    }
}

void CTrayNotify::_OnRudeApp(BOOL bRudeApp)
{
    if (_bRudeAppLaunched != bRudeApp)
    {
        _bWaitAfterRudeAppHide = FALSE;
        
        _bRudeAppLaunched = bRudeApp;

        if (!bRudeApp)
        {
            if (_pinfo)
            {
                SetTimer(_hwndNotify, TID_RUDEAPPHIDE, TT_RUDEAPPHIDE_INTERVAL, 0);
                _bWaitAfterRudeAppHide = TRUE;

                // _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, TRUE, TRUE, NIN_BALLOONSHOW);
            }
        }
        else
        {
            _KillTimer(TF_INFOTIP_TIMER, _uInfoTipTimer);
            _uInfoTipTimer = 0;

            // NOTENOTE : *DO NOT* delete _pinfo, we will show the balloon tip after the fullscreen app has 
            // gone away. 
            _HideBalloonTip();
        }
    }
}

// WndProc as defined in CImpWndProc. s_WndProc function in base class calls
// virtual v_WndProc, which handles all the messages in the derived class.
LRESULT CTrayNotify::v_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // protect against re-entrancy after we've been partially destroyed
    //
    if (_hwndToolbar == NULL)
    {
        if (uMsg != WM_CREATE &&
            uMsg != WM_DESTROY)
        {
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
        }
    }
    
    switch (uMsg)
    {        
    case WM_CREATE:
        return _Create(hWnd);
        
    case WM_DESTROY:
        return _Destroy();

    case WM_COMMAND:
        if (!_fNoTrayItemsDisplayPolicyEnabled)
            _OnCommand(GET_WM_COMMAND_ID(wParam, lParam), GET_WM_COMMAND_CMD(wParam, lParam));
        break;

    case WM_SETFOCUS:
        {
            if (_fNoTrayItemsDisplayPolicyEnabled)
            {
                SetFocus(_hwndClock);
                _fChevronSelected = FALSE;
            }
            else
            {
                BOOL bFocusSet = FALSE;
                //
                // if there's a balloon tip up, start with focus on that icon
                //
                if (_pinfo)
                {
                    INT_PTR nIcon = m_TrayItemManager.FindItemAssociatedWithHwndUid(_pinfo->hWnd, _pinfo->uID);
                    if (nIcon != -1 && ToolBar_IsVisible(_hwndToolbar, nIcon))
                    {
                        _SetToolbarHotItem(_hwndToolbar, nIcon);
                        _fChevronSelected = FALSE;
                        bFocusSet = TRUE;
                    }
                }
                if (!bFocusSet && _fHaveDemoted)
                {
                    SetFocus(_hwndChevron);
                    _fChevronSelected = TRUE;
                    bFocusSet = TRUE;
                }
        
                if (!bFocusSet)
                {
                    INT_PTR nToolbarIcon = _GetToolbarFirstVisibleItem(_hwndToolbar, FALSE);
                    if (nToolbarIcon != -1)
                    {
                        _SetToolbarHotItem(_hwndToolbar, nToolbarIcon);
                        _fChevronSelected = FALSE;
                    }
                    else
                    {
                        SetFocus(_hwndClock);
                        _fChevronSelected = FALSE;
                    }
                }
            }
        }
        break;

    case WM_SETREDRAW:
        return _SetRedraw((BOOL) wParam);

    case WM_ERASEBKGND:
        if (_hTheme)
        {
            return 1;
        }
        else
        {
            _Paint((HDC)wParam);
        }
        break;


    case WM_PAINT:
    case WM_PRINTCLIENT:
        return _Paint((HDC)wParam);

    case WM_CALCMINSIZE:
        return _CalcMinSize((int)wParam, (int)lParam);

    case WM_KEYDOWN:
        return _OnKeyDown(wParam, lParam);

    case WM_NCHITTEST:
        return(IsPosInHwnd(lParam, _hwndClock) ? HTTRANSPARENT : HTCLIENT);

    case WM_NOTIFY:
        return(_Notify((LPNMHDR)lParam));

    case TNM_GETCLOCK:
        return (LRESULT)_hwndClock;

    case TNM_TRAYHIDE:
        if (lParam && IsWindowVisible(_hwndClock))
            SendMessage(_hwndClock, TCM_RESET, 0, 0);
        break;

    case TNM_HIDECLOCK:
        ShowWindow(_hwndClock, lParam ? SW_HIDE : SW_SHOW);
        break;

    case TNM_TRAYPOSCHANGED:
        if (_pinfo && !_fNoTrayItemsDisplayPolicyEnabled)
            PostMessage(_hwndNotify, TNM_ASYNCINFOTIPPOS, 0, 0);
        break;
    
    case TNM_ASYNCINFOTIPPOS:
        ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
        _PositionInfoTip();
        break;

    case TNM_ASYNCINFOTIP:
        ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
        _ShowInfoTip((HWND)wParam, (UINT)lParam, TRUE, FALSE, 0);
        break;

    case TNM_NOTIFY:
        {
            ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
            CNotificationItem* pni = (CNotificationItem*)lParam;
            if (pni)
            {
                if (_pNotifyCB)
                {
                    _pNotifyCB->Notify((UINT)wParam, pni);
                    if (wParam == NIM_ADD)
                    {
                        _TickleForTooltip(pni);
                    }
                }
                delete pni;
            }
        }
        break;

    case WM_SIZE:
        _Size();
        break;

    case WM_TIMER:
        _OnTimer(wParam);
        break;

    case TNM_UPDATEVERTICAL:
        {
            _UpdateVertical((BOOL)lParam);
        }
        break;        

    // only button down, mouse move msgs are forwarded down to us from info tip
    //case WM_LBUTTONUP:
    //case WM_MBUTTONUP:
    //case WM_RBUTTONUP:
    case WM_LBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
        _InfoTipMouseClick(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (uMsg == WM_RBUTTONDOWN));
        break;

    case TNM_ICONDEMOTETIMER:
        ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
        _OnIconDemoteTimer(wParam, lParam);
        break;

    case TNM_INFOTIPTIMER:
        ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
        _OnInfoTipTimer();
        break;

    case TNM_SAVESTATE:
        if (!_fNoTrayItemsDisplayPolicyEnabled)
        {
            _SetUsedTime();
            m_TrayItemRegistry.InitTrayItemStream(STGM_WRITE, this->GetTrayItemCB, this);
        }
        break;

    case TNM_STARTUPAPPSLAUNCHED:
        _bStartupIcon = FALSE;
        break;

    // This message is sent by a shimmed Winstone app, to prevent the launching of
    // user-tracked balloons. These "new" balloons last till the user has been at
    // the machine for a minimum of 10 seconds. But automated Winstone tests cause
    // this balloon to stay up forever, and screws up the tests. So we shim Winstone
    // to pass us this message, and allow normal balloon tips for such a machine.
    case TNM_ENABLEUSERTRACKINGINFOTIPS:
        if ((BOOL) wParam == FALSE)
        {
            if (!_fNoTrayItemsDisplayPolicyEnabled && _fEnableUserTrackedInfoTips && _pinfo)
            {
                _fEnableUserTrackedInfoTips = (BOOL) wParam;
                _beLastBalloonEvent = BALLOONEVENT_NONE;
                _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, FALSE, FALSE, NIN_BALLOONHIDE);
            }
        }
        _fEnableUserTrackedInfoTips = (BOOL) wParam;
        break;

    case TNM_WORKSTATIONLOCKED:
        _OnWorkStationLocked((BOOL)wParam);
        break;

    case TNM_RUDEAPP:
        _OnRudeApp((BOOL)wParam);
        break;

    case TNM_SHOWTRAYBALLOON:
        // If we enable display of tray balloons...
        if (wParam)
        {
            // If we had disabled display of tray balloons earlier...
            if (!_bStartMenuAllowsTrayBalloon)
            {
                SetTimer(_hwndNotify, TID_BALLOONSHOW, TT_BALLOONSHOW_INTERVAL, 0);
            }
        }
        else
        {
            KillTimer(_hwndNotify, TID_BALLOONSHOW);
            _bStartMenuAllowsTrayBalloon = FALSE;

            // TO DO : Should we hide the balloon ?
        }
        break;

    case WM_THEMECHANGED:
        _OpenTheme();
        break;

    case WM_TIMECHANGE:
    case WM_WININICHANGE:
    case WM_POWERBROADCAST:
    case WM_POWER:
        _OnSysChange(uMsg, wParam, lParam);
        // Fall through...

    default:
        return (DefWindowProc(hWnd, uMsg, wParam, lParam));
    }

    return 0;
}

INT_PTR CTrayNotify::_GetToolbarFirstVisibleItem(HWND hWndToolbar, BOOL bFromLast)
{
    INT_PTR nToolbarIconSelected = -1;

    if (_fNoTrayItemsDisplayPolicyEnabled)
        return -1;

    INT_PTR nTrayItemCount = m_TrayItemManager.GetItemCount()-1;

    INT_PTR i = ((nTrayItemCount > 0) ? ((bFromLast) ? nTrayItemCount : 0) : -1);

    if (i == -1)
        return i;

    do
    {
        if (ToolBar_IsVisible(hWndToolbar, i))
        {
            nToolbarIconSelected = i;
            break;
        }
        i = (bFromLast ? ((i > 0) ? i-1 : -1) : ((i < nTrayItemCount) ? i+1 : -1));
    }
    while (i != -1);

    return nToolbarIconSelected;
}

BOOL CTrayNotify::_TrayNotifyIcon(PTRAYNOTIFYDATA pnid, BOOL *pbRefresh)
{
    // we want to refrain from re-painting if possible...
    if (pbRefresh)
        *pbRefresh = FALSE;

    PNOTIFYICONDATA32 pNID = &pnid->nid;
    if (pNID->cbSize < sizeof(NOTIFYICONDATA32))
    {
        return FALSE;
    }

    if (_fNoTrayItemsDisplayPolicyEnabled)
    {
        if (pnid->dwMessage == NIM_SETFOCUS)
        {
            if (_hwndClock)
            {
                SetFocus(_hwndClock);
                _fChevronSelected = FALSE;
            }
        }
        return TRUE;
    }

    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);    
    INT_PTR nIcon = m_TrayItemManager.FindItemAssociatedWithHwndUid(GetHWnd(pNID), pNID->uID);
    
    BOOL bRet = FALSE;
    switch (pnid->dwMessage)
    {
    case NIM_SETFOCUS:
        // the notify client is trying to return focus to us
        if (nIcon >= 0)
        {
            if (!(_bRudeAppLaunched || IsDirectXAppRunningFullScreen()))
            {
                SetForegroundWindow(v_hwndTray);
                if (ToolBar_IsVisible(_hwndToolbar, nIcon))
                {
                    _SetToolbarHotItem(_hwndToolbar, nIcon);
                    _fChevronSelected = FALSE;
                }
                else if (_fHaveDemoted)
                {
                    SetFocus(_hwndChevron);
                    _fChevronSelected = TRUE;
                }
                else
                {
                    INT_PTR nToolbarIcon = _GetToolbarFirstVisibleItem(_hwndToolbar, FALSE);
                    if (nToolbarIcon != -1)
                    {
                        _SetToolbarHotItem(_hwndToolbar, nToolbarIcon);
                        _fChevronSelected = FALSE;
                    }
                    else
                    {
                        SetFocus(_hwndClock);
                        _fChevronSelected = FALSE;
                    }
                }
            }
            else
            {
                SHAllowSetForegroundWindow(v_hwndTray);
            }

            if (pbRefresh)
                *pbRefresh = TRUE;
        }
        else
        {
            if (_hwndClock)
            {
                SetFocus(_hwndClock);
                _fChevronSelected = FALSE;
            }
        }
        bRet = TRUE;
        break;
        
    case NIM_ADD:
        // The icon doesnt already exist, and we dont insert again...
        if (nIcon < 0)
        {
            bRet = _InsertNotify(pNID);
            if (bRet && pbRefresh)
                *pbRefresh = TRUE;
        }
        break;

    case NIM_MODIFY:
        if (nIcon >= 0)
        {
            BOOL bRefresh;
            int nCountBefore = -1, nCountAfter = -1;
            if (pbRefresh)
            {
                nCountBefore = m_TrayItemManager.GetPromotedItemCount();
                if (m_TrayItemManager.GetDemotedItemCount() > 0)
                    nCountBefore ++;
            }

            bRet = _ModifyNotify(pNID, nIcon, &bRefresh, FALSE);

            if (bRet && pbRefresh)
            {
                nCountAfter = m_TrayItemManager.GetPromotedItemCount();
                if (m_TrayItemManager.GetDemotedItemCount() > 0)
                    nCountAfter ++;

                *pbRefresh = (nCountBefore != nCountAfter);
            }
        }
        break;

    case NIM_DELETE:
        if (nIcon >= 0)
        {
            bRet = _DeleteNotify(nIcon, FALSE, TRUE);
            if (bRet)
            {
                if (pbRefresh)
                {
                    *pbRefresh = TRUE;
                }
            }
        }
        break;

    case NIM_SETVERSION:
        if (nIcon >= 0)
        {
            // There is no point in handling NIM_SETVERSION if the "No-Tray-Items-Display" 
            // policy is in effect. The version enables proper keyboard and mouse notification
            // messages to be sent to the apps, depending on the version of the shell 
            // specified. 
            // Since the policy prevents the display of any icons, there is no point in
            // setting the correct version..
            bRet = _SetVersionNotify(pNID, nIcon);
            
            // No activity occurs in SetVersionNotify, so no need to refresh 
            // screen - pbRefresh is not set to TRUE...
        }
        break;

    default:
        break;
    }

    return bRet;
}


// Public
LRESULT CTrayNotify::TrayNotify(HWND hwndNotify, HWND hwndFrom, PCOPYDATASTRUCT pcds, BOOL *pbRefresh)
{
    PTRAYNOTIFYDATA pnid;

    if (!hwndNotify || !pcds)
    {
        return FALSE;
    }

    if (pcds->cbData < sizeof(TRAYNOTIFYDATA))
    {
        return FALSE;
    }

    // We'll add a signature just in case
    pnid = (PTRAYNOTIFYDATA)pcds->lpData;
    if (pnid->dwSignature != NI_SIGNATURE)
    {
        return FALSE;
    }

    return _TrayNotifyIcon(pnid, pbRefresh);
}

// Public
HWND CTrayNotify::TrayNotifyCreate(HWND hwndParent, UINT uID, HINSTANCE hInst)
{
    WNDCLASSEX wc;

    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(WNDCLASSEX);

    if (!GetClassInfoEx(hInst, c_szTrayNotify, &wc))
    {
        wc.lpszClassName = c_szTrayNotify;
        wc.style = CS_DBLCLKS;
        wc.lpfnWndProc = s_WndProc;
        wc.hInstance = hInst;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = NULL;
        wc.cbWndExtra = sizeof(CTrayNotify *);

        if (!RegisterClassEx(&wc))
        {
            return(NULL);
        }

        if (!ClockCtl_Class(hInst))
        {
            return(NULL);
        }
    }

    return (CreateWindowEx(0, c_szTrayNotify,
            NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | WS_CLIPCHILDREN, 0, 0, 0, 0,
            hwndParent, IntToPtr_(HMENU,uID), hInst, (void *)this));
}

void CTrayNotify::_UpdateChevronSize()
{
    if (_hTheme)
    {
        HTHEME hTheme = OpenThemeData(_hwndChevron, L"Button");
        if (hTheme)
        {
            HDC hdc = GetDC(_hwndChevron);
            GetThemePartSize(hTheme, hdc, BP_PUSHBUTTON, PBS_DEFAULTED, NULL, TS_TRUE, &_szChevron);
            ReleaseDC(_hwndChevron, hdc);
            CloseThemeData(hTheme);
        }
    }
    else
    {
        _szChevron.cx = GetSystemMetrics(SM_CXSMICON);
        _szChevron.cy = GetSystemMetrics(SM_CYSMICON);
    }
}

void CTrayNotify::_UpdateChevronState( BOOL fBangMenuOpen, 
                    BOOL fTrayOrientationChanged, BOOL fUpdateDemotedItems)
{
    BOOL fChange = FALSE;

    if (_fNoTrayItemsDisplayPolicyEnabled)
        return;

    BOOL fHaveDemoted = _UpdateTrayItems(fUpdateDemotedItems);

    if (_fHaveDemoted != fHaveDemoted)
    {
        _fHaveDemoted = fHaveDemoted;
        ShowWindow(_hwndChevron, _fHaveDemoted ? SW_SHOW : SW_HIDE);
        if (!_fHaveDemoted)
        {
            if (_fBangMenuOpen)
            {
                fBangMenuOpen = FALSE;
            }
        }
        fChange = TRUE;

        if (_fHaveDemoted && !_fBangMenuOpen)
        {
            _ShowChevronInfoTip();
        }
        else if ( (!_fHaveDemoted || (_fBangMenuOpen != fBangMenuOpen)) && 
                  _pinfo && _IsChevronInfoTip(_pinfo->hWnd, _pinfo->uID) )
        {
            _beLastBalloonEvent = BALLOONEVENT_NONE;
            _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, FALSE, FALSE, NIN_BALLOONHIDE);         
        }
    }

    if ( fChange || fTrayOrientationChanged ||
                        ( _fHaveDemoted && (_fBangMenuOpen != fBangMenuOpen) )
        )
    {
        if ((_fBangMenuOpen != fBangMenuOpen) && _pinfo && _IsChevronInfoTip(_pinfo->hWnd, _pinfo->uID))
        {
            _beLastBalloonEvent = BALLOONEVENT_NONE;
            _ShowInfoTip(_pinfo->hWnd, _pinfo->uID, FALSE, FALSE, NIN_BALLOONHIDE); 
        }

        _fBangMenuOpen = fBangMenuOpen;
        LPCWSTR pwzTheme;

        if (_fBangMenuOpen)
        {
            pwzTheme = _fVertical ? c_wzTrayNotifyVertOpenTheme : c_wzTrayNotifyHorizOpenTheme;
        }
        else
        {
            pwzTheme = _fVertical ? c_wzTrayNotifyVertTheme : c_wzTrayNotifyHorizTheme;
        }

        SetWindowTheme(_hwndChevron, pwzTheme, NULL);
        _UpdateChevronSize();
    }
}


void CTrayNotify::_UpdateVertical(BOOL fVertical)
{
    _fVertical = fVertical;
    LPCWSTR pwzTheme = _fVertical ? c_wzTrayNotifyVertTheme : c_wzTrayNotifyHorizTheme;

    SetWindowTheme(_hwndNotify, pwzTheme, NULL);
    _UpdateChevronState(_fBangMenuOpen, TRUE, TRUE);
}

void CTrayNotify::_OpenTheme()
{
    if (_hTheme)
    {
        CloseThemeData(_hTheme);
        _hTheme = NULL;
    }
    _hTheme = OpenThemeData(_hwndNotify, L"TrayNotify");

    _UpdateChevronSize();
    SetWindowStyleEx(_hwndNotify, WS_EX_STATICEDGE, !_hTheme);

    InvalidateRect(_hwndNotify, NULL, FALSE);
}

// *** Helper functions for UserEventTimer..
HRESULT CTrayNotify::_SetItemTimer(CTrayItem * pti)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    if(pti)
    {
        ASSERT(pti->dwUserPref == TNUP_AUTOMATIC);

        UINT uTimerInterval = m_TrayItemRegistry._uPrimaryCountdown;
        if (pti->IsItemClicked())
        {
            // If the item has been clicked on, add 8 hours to its staying time
            // in the tray...
            uTimerInterval += TT_ICON_COUNTDOWN_INCREMENT;
        }
        if (pti->IsStartupIcon())
        {
            uTimerInterval -= (pti->uNumSeconds)*1000;
        }

        hr = _SetTimer(TF_ICONDEMOTE_TIMER, TNM_ICONDEMOTETIMER, uTimerInterval, &(pti->uIconDemoteTimerID));
    }

    return hr;
}

HRESULT CTrayNotify::_SetTimer(int nTimerFlag, UINT uCallbackMessage, UINT uTimerInterval, ULONG * puTimerID)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    if (puTimerID)
    {
        IUserEventTimer * pUserEventTimer = _CreateTimer(nTimerFlag);
        if (pUserEventTimer)
        {
            if (FAILED(hr = pUserEventTimer->SetUserEventTimer( _hwndNotify, 
                uCallbackMessage, uTimerInterval, NULL, puTimerID)))
            {
                *puTimerID = 0;
            }
        }
        else
        {
            *puTimerID = 0;
        }
    }

    return hr;
}

HRESULT CTrayNotify::_KillItemTimer(CTrayItem *pti)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    if (pti)
    {
        hr = _KillTimer(TF_ICONDEMOTE_TIMER, pti->uIconDemoteTimerID);
        // Irrespective of whether the timer ID was valid or not...
        pti->uIconDemoteTimerID = 0;
    }

    return hr;
}

HRESULT CTrayNotify::_KillTimer(int nTimerFlag, ULONG uTimerID)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);

    if (uTimerID)
    {
        IUserEventTimer * pUserEventTimer = _CreateTimer(nTimerFlag);
        if (pUserEventTimer)
        {
            hr = pUserEventTimer->KillUserEventTimer(_hwndNotify, uTimerID);

            // If we are finished with the user tracking timer, we should release it
            if (_ShouldDestroyTimer(nTimerFlag))
            {
                pUserEventTimer->Release();
                _NullifyTimer(nTimerFlag);
            }
        }
    }

    return hr;
}

void CTrayNotify::_NullifyTimer(int nTimerFlag)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
    
    switch(nTimerFlag)
    {
        case TF_ICONDEMOTE_TIMER:
            m_pIconDemoteTimer = NULL;
            break;

        case TF_INFOTIP_TIMER:
            m_pInfoTipTimer = NULL;
            break;
            
    }
}

BOOL CTrayNotify::_ShouldDestroyTimer(int nTimerFlag)
{
    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
    
    switch(nTimerFlag)
    {
        case TF_ICONDEMOTE_TIMER:
            return (!m_TrayItemRegistry.IsAutoTrayEnabled() || m_TrayItemManager.GetPromotedItemCount() == 0);

        case TF_INFOTIP_TIMER:
            return (!_GetQueueCount());

        default:
            AssertMsg(TF_ERROR, TEXT("No other timer ids are possible"));
            return FALSE;
    }
}

IUserEventTimer * CTrayNotify::_CreateTimer(int nTimerFlag)
{
    IUserEventTimer ** ppUserEventTimer = NULL;
    UINT uTimerTickInterval = 0;

    ASSERT(!_fNoTrayItemsDisplayPolicyEnabled);
    
    switch(nTimerFlag)
    {
        case TF_ICONDEMOTE_TIMER:
            ppUserEventTimer = &m_pIconDemoteTimer;
            break;

        case TF_INFOTIP_TIMER:
            ppUserEventTimer = &m_pInfoTipTimer;
            break;

        default:
            AssertMsg(TF_ERROR, TEXT("No other Timers are possible"));
            return NULL;
    }

    if (ppUserEventTimer && !*ppUserEventTimer)
    {
        if ( !SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_UserEventTimer, NULL, 
                                IID_PPV_ARG(IUserEventTimer, ppUserEventTimer))) )
        {
            *ppUserEventTimer = NULL;
        }
        else
        {
            uTimerTickInterval = m_TrayItemRegistry.GetTimerTickInterval(nTimerFlag);

            (*ppUserEventTimer)->InitTimerTickInterval(uTimerTickInterval);
        }
    }

    return *ppUserEventTimer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\trayreg.h ===
#ifndef _TRAYREG_H
#define _TRAYREG_H

#include "dpa.h"

#define SZ_TRAYNOTIFY_REGKEY        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\TrayNotify")
#define SZ_EXPLORER_REGKEY          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer")
#define SZ_AUTOTRAY_REGVALUE        TEXT("EnableAutoTray")
#define SZ_ITEMSTREAMS_REGVALUE     TEXT("IconStreams")
#define SZ_ICONSTREAMS_REGVALUE     TEXT("PastIconsStream")
#define SZ_INFOTIP_REGVALUE         TEXT("BalloonTip")

#define SZ_ICON_COUNTDOWN_VALUE             TEXT("TrayIconResidentInterval")
#define SZ_ICONCLEANUP_VALUE                TEXT("Icon Cleanup Time")

#define SZ_ICONDEMOTE_TIMER_TICK_VALUE      TEXT("IconDemoteTimerTick")
#define SZ_INFOTIP_TIMER_TICK_VALUE         TEXT("InfoTipTimerTick")

// Parameters to control the aging algorithm
#ifdef FULL_DEBUG
#define TT_ICON_COUNTDOWN_INTERVAL                   15000
#else
#define TT_ICON_COUNTDOWN_INTERVAL                 3600000      // 1 hour
#endif
#define TT_ICONCLEANUP_INTERVAL                          6      // 6 months


#define TT_ICON_COUNTDOWN_INCREMENT           8*60*60*1000      // 8 hours

// Show the Chevron info tip 5 times, once per session for the first 5 sessions, or
// until the user clicks on the balloon, whichever comes first.
#define MAX_CHEVRON_INFOTIP_SHOWN                        5


// Flags decide which user tracking timer to use - the balloon tips or the icons
#define TF_ICONDEMOTE_TIMER                              1
#define TF_INFOTIP_TIMER                                 2

// What is the timer interval for the UserEventTimer for each of the timer cases ?
// Once every 5 minutes, for the tray items...
#define UET_ICONDEMOTE_TIMER_TICK_INTERVAL                300000
// Once every 5 seconds, for balloon tips...
#define UET_INFOTIP_TIMER_TICK_INTERVAL                     5000


//
// header for persistent streams storing the tray notify info
//
typedef struct tagTNPersistStreamHeader
{
    DWORD   dwSize;         // Size of the header structure..
    DWORD   dwVersion;      // Version number for the header
    DWORD   dwSignature;    // Signature to identify this version of the header
    DWORD   cIcons;         // Number of Icons that have been stored in the stream
    DWORD   dwOffset;       // Offset to the start of the first icondata in the stream
} TNPersistStreamHeader;

#define INVALID_IMAGE_INDEX         -1

typedef struct tagTNPersistStreamData
{
    TCHAR       szExeName[MAX_PATH]; 
    UINT        uID;
    BOOL        bDemoted;
    DWORD       dwUserPref;
    WORD        wYear;
    WORD        wMonth;
    TCHAR       szIconText[MAX_PATH];
    UINT        uNumSeconds;
    BOOL        bStartupIcon;
    INT         nImageIndex;        // Index of the image in the Past Items image list.
    GUID        guidItem;
} TNPersistStreamData;

typedef struct tagTNPersistentIconStreamHeader
{
    DWORD   dwSize;         // Size of the header structure
    DWORD   dwVersion;      // Version number of the header
    DWORD   dwSignature;    // This signature must be the same as TNPersistStreamHeader.dwSignature
    DWORD   cIcons;         // Number of icons stored in the stream
    DWORD   dwOffset;       // Offset into the first item in the stream
} TNPersistentIconStreamHeader;

#define TNH_VERSION_ONE     1
#define TNH_VERSION_TWO     2
#define TNH_VERSION_THREE   3
#define TNH_VERSION_FOUR    4
#define TNH_VERSION_FIVE    5

#define TNH_SIGNATURE       0x00010001

class CNotificationItem;
class CTrayItem;

// Any client asking the TrayNotify class for an item passes these flags as one of the 
// parameters to the callback functions...
typedef enum TRAYCBARG
{
    TRAYCBARG_PTI,
    TRAYCBARG_HICON,
    TRAYCBARG_ALL
} TRAYCBARG;

typedef struct TRAYCBRET
{
    CTrayItem * pti;
    HICON hIcon;
} TRAYCBRET;


typedef BOOL (CALLBACK * PFNTRAYNOTIFYCALLBACK)(INT_PTR nIndex, void *pCallbackData, 
        TRAYCBARG trayCallbackArg, TRAYCBRET  *pOutData);


class CTrayItemRegistry
{
    public:
        CTrayItemRegistry() : _himlPastItemsIconList(NULL) { }
        ~CTrayItemRegistry() { }

        void InitRegistryValues(UINT uIconListFlags);
        void InitTrayItemStream(DWORD dwStreamMode, PFNTRAYNOTIFYCALLBACK pfnTrayNotifyCB, void *pCBData);

        BOOL GetTrayItem(INT_PTR nIndex, CNotificationItem * pni, BOOL * pbStat);
        BOOL AddToPastItems(CTrayItem * pti, HICON hIcon);

        void IncChevronInfoTipShownInRegistry(BOOL bUserClickedInfoTip = FALSE);
        BOOL SetIsAutoTrayEnabledInRegistry(BOOL bAutoTray);
        BOOL SetPastItemPreference(LPNOTIFYITEM pNotifyItem);

        INT_PTR CheckAndRestorePersistentIconSettings(CTrayItem *pti, LPTSTR pszIconToolTip, HICON hIcon);
        void DeletePastItem(INT_PTR nIndex);
        int DoesIconExistFromPreviousSession(CTrayItem * pti, LPTSTR pszIconToolTip, HICON hIcon);

        void Delete()
        {
            _dpaPersistentItemInfo.DestroyCallback(_DestroyIconInfoCB, NULL);

            _DestroyPastItemsIconList();
        }

        int _AddPastIcon(int nImageIndex, HICON hIcon)
        {
            if (_himlPastItemsIconList && hIcon)
                return ImageList_ReplaceIcon(_himlPastItemsIconList, nImageIndex, hIcon);

            return INVALID_IMAGE_INDEX;
        }
        
        UINT GetTimerTickInterval(int nTimerFlag);

    public:
        BOOL ShouldChevronInfoTipBeShown()
        {
            return _bShowChevronInfoTip;
        }

        // Is the "Auto" tray been disabled by policy ?
        BOOL IsNoAutoTrayPolicyEnabled() const
        {
            return _fNoAutoTrayPolicyEnabled;
        }

        // If not, has the user turned off the "auto" tray policy ?
        BOOL IsAutoTrayEnabledByUser() const
        {
            return _fAutoTrayEnabledByUser;
        }

        BOOL IsAutoTrayEnabled()
        {
            return (!_fNoAutoTrayPolicyEnabled && _fAutoTrayEnabledByUser);
        }

    public:
        ULONG           _uPrimaryCountdown;
        
    private:
        static int _DestroyIconInfoCB(TNPersistStreamData * pData, LPVOID pData2);

        HRESULT _LoadTrayItemStream(IStream *pstm, PFNTRAYNOTIFYCALLBACK pfnTrayNotifyCB, void *pCBData);
        HRESULT _SaveTrayItemStream(IStream *pstm, PFNTRAYNOTIFYCALLBACK pfnTrayNotifyCB, void *pCBData);
        BOOL _FillPersistData(TNPersistStreamData * ptnPersistData, CTrayItem * pti, HICON hIcon);

        BOOL _IsAutoTrayEnabledInRegistry();

        void _QueryRegValue(HKEY hkey, LPTSTR pszValue, ULONG* puVal, ULONG uDefault, DWORD dwValSize);

        void _RestorePersistentIconSettings(TNPersistStreamData * ptnpd, CTrayItem * pti);

        BOOL _IsValidStreamHeaderVersion(DWORD dwVersion)
        {
            return ( (dwVersion == TNH_VERSION_FOUR) || (dwVersion == TNH_VERSION_FIVE) );
        }

        UINT_PTR _SizeOfPersistStreamData(DWORD dwVersion);
        
        inline void _DestroyPastItemsIconList()
        {
            if (_himlPastItemsIconList)
            {
                ImageList_Destroy(_himlPastItemsIconList);
                _himlPastItemsIconList = NULL;
            }
        }

        BOOL _IsIconLastUseValid(WORD wYear, WORD wMonth);

        BOOL _SaveIconsToRegStream();
        BOOL _LoadIconsFromRegStream(DWORD dwItemStreamSignature);
        void UpdateImageIndices(INT_PTR nDeletedImageIndex);

        //
        // Persistent Icon information...
        //
        CDPA<TNPersistStreamData> _dpaPersistentItemInfo;
        DWORD           _dwTimesChevronInfoTipShown;
        BOOL            _bShowChevronInfoTip;
        ULONG           _uValidLastUseTimePeriod;

        // We store this policy in a local cache, since we do not support settings
        // changes during the session. At logon, the settings are renewed, and if the
        // settings change during the session, they dont take effect, until the user
        // has logged off and logged back on to a different session.

        // This policy states that the tray should function like the Windows 2000 tray,
        // and disables all "smart" functionality like aging, and advanced balloon 
        // tips.
        BOOL            _fNoAutoTrayPolicyEnabled;

        // This variable dictates the current setting of the tray, since the user is
        // allowed to specify if he wants the Windows 2000 tray, or the Whistler 
        // auto-tray. 
        BOOL            _fAutoTrayEnabledByUser;

        HIMAGELIST      _himlPastItemsIconList;

        ULONG           _uIconDemoteTimerTickInterval;
        ULONG           _uInfoTipTimerTickInterval;
};

#endif // _TRAYREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\trayprop.cpp ===
//---------------------------------------------------------------------------
// This file contains Taskbar and Start Menu property sheet code
//---------------------------------------------------------------------------
#include "cabinet.h"
#include "rcids.h"
#include "util.h"
#include <help.h>       // help ids
#include <regstr.h>
#include <atlstuff.h>

#include "dlg.h"
#include "tray.h"
#include "traycmn.h"
#include "startmnu.h"
#include "desktop2.h"
#include "uemapp.h"

#define GROUPID_CURRENTITEMS    5
#define GROUPID_PASTITEMS       6

#define MAX_PROGS_ALLOWED   30

const static DWORD aInitStartMenuHelpIDs[] = {
    IDC_NO_HELP_1,       NO_HELP,
    IDC_NO_HELP_2,       NO_HELP,
    IDC_NO_HELP_3,       NO_HELP,
    IDC_NO_HELP_4,       NO_HELP,
    IDC_GROUPBOX,        IDH_COMM_GROUPBOX,
    IDC_GROUPBOX_2,      IDH_MENUCONFIG_CLEAR,
    IDC_GROUPBOX_3,      IDH_COMM_GROUPBOX,
    IDC_ADDSHORTCUT,     IDH_TRAY_ADD_PROGRAM,
    IDC_DELSHORTCUT,     IDH_TRAY_REMOVE_PROGRAM,
    IDC_EXPLOREMENUS,    IDH_TRAY_ADVANCED,
    IDC_KILLDOCUMENTS,   IDH_MENUCONFIG_CLEAR,
    IDC_RESORT,          IDH_TRAY_RESORT_BUTTON,
    IDC_STARTMENUSETTINGSTEXT, IDH_TRAY_START_MENU_SETTINGS,
    0, 0
};

const static DWORD aTaskOptionsHelpIDs[] = {  // Context Help IDs
    IDC_TASKBARAPPEARANCE,IDH_TASKBAR_OPTIONS_BITMAP,
    IDC_NOTIFYAPPEARANCE, IDH_TASKBAR_OPTIONS_BITMAP,
    IDC_TRAYOPTAUTOHIDE,  IDH_TRAY_TASKBAR_AUTOHIDE,
    IDC_TRAYOPTSHOWCLOCK, IDH_TRAY_SHOW_CLOCK,
    IDC_TRAYOPTONTOP,     IDH_TRAY_TASKBAR_ONTOP,
    IDC_LOCKTASKBAR,      IDH_TRAY_ENABLEMOVERESIZE,
    IDC_GROUPITEMS,       IDH_TRAY_GROUPING,
    IDC_NOTIFYMAN,        IDH_TRAY_HIDE_ICONS,
    IDC_CUSTOMIZE,        IDH_TRAY_CUSTOMIZE_ICONS,
    IDC_QUICKLAUNCH,      IDH_TRAY_QUICKLAUNCH,
    0, 0
};

const static DWORD aNotifyOptionsHelpIDs[] = {  // Context Help IDs
    IDC_NOTIFY_TEXT,            NO_HELP,
    IDC_NOTIFY_TEXT2,           NO_HELP,
    IDC_COMBO_ACTION,           NO_HELP,
    IDC_NOTIFY_ITEMS,           NO_HELP,
    IDB_NOTIFY_RESTOREDEFAULTS, IDH_TRAY_RESTOREDEFBUTTON,
    0, 0
};

const static DWORD aStartTabHelpIDs[] = {
    IDC_STARTMENUPREVIEW,   IDH_START_PREVIEW,
    IDC_NEWSCHOOL,          IDH_START_SELECTPERSONAL,
    IDC_OLDSCHOOL,          IDH_START_SELECTCLASSIC,
    IDC_NEWSTARTCUSTOMIZE,  IDH_START_CUSTOMIZEPERSONAL,
    IDC_OLDSTARTCUSTOMIZE,  IDH_START_CUSTOMIZECLASSIC,
    0, 0
};

const static DWORD aStartCustGeneralTabHelpIDs[] = {
    IDC_SPCUST_ICONLARGE,       IDH_START_SPCUST_LARGE,
    IDC_SPCUST_ICONSMALL,       IDH_START_SPCUST_SMALL,
    IDC_SPCUST_LARGE,           IDH_START_SPCUST_LARGE,
    IDC_SPCUST_SMALL,           IDH_START_SPCUST_SMALL,
    IDC_SPCUST_MINPROGS,        IDH_START_SPCUST_MINPROGS,
    IDC_SPCUST_MINPROGS_ARROW,  IDH_START_SPCUST_MINPROGS,
    IDB_SPCUST_CLEARPROG,       IDH_START_SPCUST_CLEARPROG,
    IDC_SPCUST_INTERNET,        IDH_START_SPCUST_INTERNET,
    IDC_SPCUST_INTERNETCB,      IDH_START_SPCUST_INTERNETCB,
    IDC_SPCUST_EMAIL,           IDH_START_SPCUST_EMAIL,
    IDC_SPCUST_EMAILCB,         IDH_START_SPCUST_EMAILCB,
    0, 0
};

const static DWORD aStartCustAdvancedTabHelpIDs[] = {
    IDC_SPCUST_HOVEROPEN,       IDH_START_SPCUST_HOVEROPEN,
    IDC_SPCUST_NOTIFYNEW,       IDH_START_SPCUST_NOTIFYNEW,
    IDC_STARTMENUSETTINGS,      IDH_START_STARTMENUSETTINGS,
    IDC_SPCUST_RECENT_GROUPBOX, NO_HELP,
    IDC_SPCUST_RECENT_TEXT,     NO_HELP,
    IDC_SPCUST_RECENT,          IDH_START_SPCUST_RECENT,
    IDB_SPCUST_CLEARDOCS,       IDH_START_SPCUST_CLEARDOCS,
    0, 0
};

#define REGSTR_VAL_LARGEICONSTEMP TEXT("Start_LargeIcons")
#define REGSTR_VAL_ADMINTOOLSTEMP TEXT("Start_AdminToolsTemp")

void SetDlgItemBitmap(HWND hDlg, int idStatic, int iResource);
void SetDlgItemIcon(HWND hDlg, int idStatic, HICON hi);
void SetProgramIcon(HWND hDlg, int idLarge, int idSmall);

void _TaskbarOptionsUpdateDisplay(HWND hDlg);
void _TaskbarOptionsSizeControls(HWND hDlg);
void _TaskbarOptionsDestroyBitmaps(HWND hDlg);

BOOL_PTR WINAPI AdvancedOptDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);


typedef struct
{
    HWND hwndTree;
    IRegTreeOptions *pTO;
} SMADVANCED;

void SendPSMChanged(HWND hDlg)
{
    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
}

class CPinHelper
{
public:
    CPinHelper();
    ~CPinHelper();

    void Save(BOOL bShowEmail, BOOL bShowBrowser);
    void GetPinInfo(BOOL *pbPinBrowser, BOOL *pbPinEmail);

private:
    void SavePinInfo(LPCITEMIDLIST pidlVictim, BOOL bOld, BOOL bNew);

    LPITEMIDLIST _pidlBrowser;
    LPITEMIDLIST _pidlEmail;

    IStartMenuPin *_psmp;
};

CPinHelper::CPinHelper()
{
    _pidlBrowser = ILCreateFromPath(TEXT("shell:::{2559a1f4-21d7-11d4-bdaf-00c04f60b9f0}"));
    _pidlEmail   = ILCreateFromPath(TEXT("shell:::{2559a1f5-21d7-11d4-bdaf-00c04f60b9f0}"));
    CoCreateInstance(CLSID_StartMenuPin, NULL, CLSCTX_INPROC_SERVER,
                     IID_PPV_ARG(IStartMenuPin, &_psmp));
}


CPinHelper::~CPinHelper()
{
    ILFree(_pidlBrowser);
    ILFree(_pidlEmail);
    ATOMICRELEASE(_psmp);
}

void CPinHelper::GetPinInfo(BOOL *pbPinBrowser, BOOL *pbPinEmail)
{
    *pbPinBrowser = FALSE;
    *pbPinEmail = FALSE;
    if (_psmp)
    {
        IEnumIDList *peidl;
        if (SUCCEEDED(_psmp->EnumObjects(&peidl)))
        {
            LPITEMIDLIST pidl;
            while (peidl->Next(1, &pidl, NULL) == S_OK)
            {
                if (ILIsEqual(pidl, _pidlBrowser)) *pbPinBrowser = TRUE;
                if (ILIsEqual(pidl, _pidlEmail))   *pbPinEmail = TRUE;
                ILFree(pidl);
            }
            peidl->Release();
        }
    }

}


void CPinHelper::SavePinInfo(LPCITEMIDLIST pidlVictim, BOOL bOld, BOOL bNew)
{
    ASSERT(bOld == TRUE || bOld == FALSE);
    ASSERT(bNew == TRUE || bNew == FALSE);

    if (pidlVictim && _psmp && bOld != bNew)
    {
        if (bNew)
        {
            _psmp->Modify(NULL, pidlVictim);
            _psmp->Modify(pidlVictim, SMPIN_POS(0));
        }
        else
        {
            _psmp->Modify(pidlVictim, NULL);
        }
    }
}

void CPinHelper::Save(BOOL bShowEmail, BOOL bShowBrowser)
{
    // Get old settings
    BOOL bShowBrowserOld, bShowEmailOld;
    GetPinInfo(&bShowBrowserOld, &bShowEmailOld);

    //
    //  Do in reverse order because we insert at the top of the list.
    //
    SavePinInfo(_pidlEmail, bShowEmailOld, bShowEmail);
    SavePinInfo(_pidlBrowser, bShowBrowserOld, bShowBrowser);
}

class ATL_NO_VTABLE CNotificationsDlg : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CDialogImpl<CNotificationsDlg>, 
    public INotificationCB
{
public:
    CNotificationsDlg() 
    { 
        _pTrayNotify = NULL; 
        _fItemChanged = FALSE;
        _hPlaceholderIcon = NULL;
        _nIndex = -1;
        _fComboBoxActive = FALSE;
    };
    virtual ~CNotificationsDlg() 
    { 
        if (_pTrayNotify) 
        { 
            _pTrayNotify->Release(); 
            _pTrayNotify = NULL;
        } 
    };

    DECLARE_NOT_AGGREGATABLE(CNotificationsDlg)

    BEGIN_COM_MAP(CNotificationsDlg)
        COM_INTERFACE_ENTRY(INotificationCB)
    END_COM_MAP()

    enum {IDD = DLG_NOTIFY};
    BEGIN_MSG_MAP_EX(CNotificationsDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_HANDLER_EX(IDC_NOTIFY_ITEMS, LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_HANDLER_EX(IDC_NOTIFY_ITEMS, LVN_ENDSCROLL, OnEndScroll)
        NOTIFY_CODE_HANDLER(HDN_ITEMCHANGED, OnHeaderItemChanged)
        COMMAND_HANDLER_EX(IDC_COMBO_ACTION, CBN_SELENDOK, OnComboSelEnd) 
        COMMAND_ID_HANDLER_EX(IDB_NOTIFY_RESTOREDEFAULTS, OnRestoreDefaults)
        COMMAND_RANGE_HANDLER(IDOK, IDNO, OnCloseCmd)
    END_MSG_MAP()

    //*** INotificationCB ***
    STDMETHODIMP Notify(DWORD dwMessage, LPNOTIFYITEM pNotifyItem);

    //*** Message Callbacks ***
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnItemChanged(LPNMHDR pnmh);
    LRESULT OnEndScroll(LPNMHDR pnmh);
    LRESULT OnHeaderItemChanged(WPARAM wParam, LPNMHDR pnmh, LPARAM lParam);
    LRESULT OnComboSelEnd(UINT uMsg, UINT uID , HWND hwnd);

    LRESULT OnRestoreDefaults(UINT uMsg, UINT uID , HWND hwnd);
    LRESULT OnCloseCmd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    static LRESULT CALLBACK s_ListViewSubClassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
        LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

    static LRESULT CALLBACK s_ComboBoxSubClassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
        LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

    //*** Other ***
    void ApplyChanges(void);

private:
    HRESULT _AddItem(CNotificationItem& ni, int iIndex);
    void _ShowComboBox();
    int _GetCurSel();
    void _LoadAndSetLVItemText(UINT uResourceID, DWORD nRow, DWORD nCol);

    CSimpleArray<CNotificationItem> _saItems; //copy of the data, initialized by user
    BOOL _fItemChanged;
    ITrayNotify* _pTrayNotify;
    int _nPrevIndex;
    HWND _hwndCombo;
    HWND _hwndListView;
    RECT _rcOldPos;
    HICON _hPlaceholderIcon;
    BOOL _fComboBoxActive;
    int _nIndex;
};

HRESULT CNotificationsDlg::_AddItem(CNotificationItem& ni, int iIndex)
{
    HIMAGELIST himl = ListView_GetImageList(_hwndListView, LVSIL_SMALL);
    BOOL fInsert = FALSE;
    LV_ITEM lvitem = {0};
    int iImage = -1;

    if (!ni.hIcon)
    {
        if (!_hPlaceholderIcon)
        {
            _hPlaceholderIcon = (HICON)LoadImage(hinstCabinet, 
                MAKEINTRESOURCE(ICO_TRAYPROP_PLACEHOLDER), IMAGE_ICON,
                GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 
                LR_LOADMAP3DCOLORS);
        }

        if (_hPlaceholderIcon)
            ni.hIcon = CopyIcon(_hPlaceholderIcon);
    }
    
    if (iIndex == -1)
    {
        iIndex = _saItems.GetSize();
        iImage = ImageList_AddIcon(himl, ni.hIcon);
        fInsert = TRUE;
    }
    else
    {
        lvitem.mask = LVIF_IMAGE;
        lvitem.iItem = iIndex;
        lvitem.iSubItem = 0;
        ListView_GetItem(_hwndListView, &lvitem);
        ImageList_ReplaceIcon(himl, lvitem.iImage, ni.hIcon);
        iImage = lvitem.iImage;
        fInsert = FALSE;
    }

    if (!ni.pszIconText || ni.pszIconText[0] == 0)
    {
        TCHAR szTemp[MAX_PATH];
        if (LoadString(hinstCabinet, IDS_NOTITLE, szTemp, ARRAYSIZE(szTemp)))
            ni.SetIconText(szTemp);
        // ni.m_strText.LoadString(IDS_NOTITLE);
    }
    else
    // Replace '\n' with ' '
    {
        LPTSTR pszTemp = NULL;
        while (NULL != (pszTemp = StrChr(ni.pszIconText, TEXT('\n'))))
        {
            *pszTemp = TEXT(' ');
        }
    }

    lvitem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_GROUPID;
    lvitem.iItem = iIndex;
    lvitem.iSubItem = 0;
    lvitem.pszText = ni.pszIconText;
    lvitem.iImage = iImage;
    lvitem.iGroupId = (ni.hWnd == NULL) ? GROUPID_PASTITEMS : GROUPID_CURRENTITEMS;
    if (fInsert)
        ListView_InsertItem(_hwndListView, &lvitem);
    else
        ListView_SetItem(_hwndListView, &lvitem);

    lvitem.mask = LVIF_TEXT;
    lvitem.iItem = iIndex;
    lvitem.iSubItem = 1;

    CString str;
    str.LoadString(IDS_NOTIFY_FIRST + ni.dwUserPref);
    lvitem.pszText = (LPTSTR)(LPCTSTR)str;
    ListView_SetItem(_hwndListView, &lvitem);

    if (fInsert)
    {
        _saItems.Add(ni);
    }
    else
    {
        _saItems[iIndex] = ni;
    }

    return S_OK;
}

HRESULT CNotificationsDlg::Notify(DWORD dwMessage, NOTIFYITEM * pNotifyItem)
{
    if (!pNotifyItem || (!pNotifyItem->hWnd && !pNotifyItem->pszExeName))
        return E_INVALIDARG;

    ASSERT(pNotifyItem);        
    CNotificationItem ni = *pNotifyItem;

    switch (dwMessage)
    {
    case NIM_ADD:
    case NIM_MODIFY:
        {
            // We never need to modify a Past Item
            for (int i = 0; (i < _saItems.GetSize() && ni.hWnd); i++)
            {
                // If the Item is already in the list just update it
                if (_saItems[i] == ni)
                {
                    return _AddItem(ni, i);
                }
            }

            // If it is not in the list add it
            return _AddItem(ni, -1);
        }
        break;

    case NIM_DELETE:
        {
            for (int i = 0; (i < _saItems.GetSize()); i++)
            {
                if (_saItems[i] == ni)
                {
                    _saItems.RemoveAt(i);
                    ListView_DeleteItem(_hwndListView, i);
                    _ShowComboBox();

                    return S_OK;
                }
            }
            break;
        }
    }

    return E_INVALIDARG;
}

LRESULT CNotificationsDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    _hwndListView = GetDlgItem(IDC_NOTIFY_ITEMS);
    _nPrevIndex = -2;
    _rcOldPos.top = -500;

    CImageList il;
    int iSize = GetSystemMetrics(SM_CXSMICON);
    // found in security review -- not a security problem, but this doesnt do jack (?)
    // ::Create allocates a new CImageList, should this call initialize()?
    il.Create(iSize, iSize, SHGetImageListFlags(_hwndListView), _saItems.GetSize(), 4);
    if (il)
    {
        CString str;
        //list view control holding all the items
        ListView_SetExtendedListViewStyle(_hwndListView, LVS_EX_FULLROWSELECT);
        ListView_EnableGroupView(_hwndListView, TRUE);

        static const struct {
            int ids;
            int idGroup;
        } groupData[] =  {{ IDS_NOTIFY_CURRENTITEMS, GROUPID_CURRENTITEMS }, 
                          { IDS_NOTIFY_PASTITEMS, GROUPID_PASTITEMS }};

        for (int i = 0; i < ARRAYSIZE(groupData); i++)
        {
            str.LoadString(groupData[i].ids);
            LVGROUP lvgrp = { sizeof(LVGROUP) };
            lvgrp.mask = LVGF_HEADER | LVGF_GROUPID;
            lvgrp.pszHeader = (LPTSTR)(LPCTSTR)str;
            lvgrp.cchHeader = lstrlen(lvgrp.pszHeader);
            lvgrp.iGroupId = groupData[i].idGroup;
            SendMessage(_hwndListView, LVM_INSERTGROUP, -1, (LPARAM)&lvgrp);
        }

        //Split width of columns 3/5, 2/5
        RECT rc;
        ::GetClientRect(_hwndListView, &rc);
        int width = rc.right - rc.left - GetSystemMetrics(SM_CXHSCROLL);
        int width0 = 3*width/5;
        int width1 = width-width0;

        LV_COLUMN lvcol = {0};
        lvcol.mask = LVCF_TEXT | LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
        str.LoadString(IDS_NOTIFYNAME);
        lvcol.pszText = (LPTSTR)(LPCTSTR)str;
        lvcol.cx = width0;
        lvcol.iSubItem = 0;
        ListView_InsertColumn(_hwndListView, 0, &lvcol);

        str.LoadString(IDS_BEHAVIOR);
        lvcol.pszText = (LPTSTR)(LPCTSTR)str;
        lvcol.cx = width1;
        lvcol.iSubItem = 1;
        ListView_InsertColumn(_hwndListView, 1, &lvcol);

        il.SetBkColor(GetSysColor(COLOR_WINDOW));
        ListView_SetImageList(_hwndListView, il, LVSIL_SMALL);
        il.Detach();

        _hwndCombo = GetDlgItem(IDC_COMBO_ACTION);
        // make sure combo box uses same font as list view
        ::SendMessage(_hwndCombo, WM_SETFONT, (WPARAM)::SendMessage(_hwndListView, WM_GETFONT, 0, 0), MAKELPARAM(TRUE, 0));
        for (int i = IDS_NOTIFY_FIRST; i < IDS_NOTIFY_LAST; i++)
        {
            CString strTemp;
            strTemp.LoadString(i);
            ComboBox_AddString(_hwndCombo, strTemp);
        }

        ::SetParent(_hwndCombo, _hwndListView);
        HWND hwndHeader = ListView_GetHeader(_hwndListView);
        ::SetWindowPos(_hwndCombo, hwndHeader, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOREDRAW);

        ::SetWindowSubclass(_hwndListView, s_ListViewSubClassWndProc, 0, 
                reinterpret_cast<DWORD_PTR>(this));

        ::SetWindowSubclass(_hwndCombo, s_ComboBoxSubClassWndProc, 0, 
                reinterpret_cast<DWORD_PTR>(this));
    }

    _saItems.RemoveAll();
    
    if (_pTrayNotify)
    {
        _pTrayNotify->Release();
        _pTrayNotify = NULL;
    }

    // localserver for tray notify
    if (SUCCEEDED(CoCreateInstance(CLSID_TrayNotify, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(ITrayNotify, &_pTrayNotify))))
    {
        INotificationCB* pCB;

        if (SUCCEEDED(QueryInterface(IID_PPV_ARG(INotificationCB, &pCB))))
        {
            _pTrayNotify->RegisterCallback(pCB);
            pCB->Release();
        }
    }

    // Set the selected and focused state to the first item
    // ListView_SetItemState(hwndLV, 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

    bHandled = TRUE;
    return 0;
}

LRESULT CNotificationsDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ::WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aNotifyOptionsHelpIDs);
    bHandled = TRUE;
    return 0;
}

LRESULT CNotificationsDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ::WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aNotifyOptionsHelpIDs);
    bHandled = TRUE;
    return 0;
}

LRESULT CNotificationsDlg::OnItemChanged(LPNMHDR pnmh)
{
    _ShowComboBox();
    return 0;
}

LRESULT CNotificationsDlg::OnEndScroll(LPNMHDR pnmh)
{
    _ShowComboBox();
    return 0;
}

LRESULT CNotificationsDlg::OnHeaderItemChanged(WPARAM wParam, LPNMHDR pnmh, LPARAM lParam)
{
    HWND hwndHeader = ListView_GetHeader(_hwndListView);
    if (pnmh->hwndFrom == hwndHeader)
    {
        _ShowComboBox();
    }

    return 0;
}

int CNotificationsDlg::_GetCurSel()
{
    return (int)::SendMessage(_hwndListView, LVM_GETNEXTITEM, -1, MAKELPARAM(LVNI_ALL | LVNI_SELECTED, 0));
}

void CNotificationsDlg::_LoadAndSetLVItemText(UINT uResourceID, DWORD nRow, DWORD nCol)
{
    CString str;
    str.LoadString(uResourceID);
    ListView_SetItemText(_hwndListView, nRow, nCol, (LPTSTR)(LPCTSTR)str);
}

LRESULT CNotificationsDlg::OnComboSelEnd(UINT uMsg, UINT uID ,HWND hwnd)
{
    int nCurIndex = _fComboBoxActive ? _nIndex : _GetCurSel();
    if (nCurIndex != -1)
    {
        DWORD dwUserPref = ComboBox_GetCurSel(_hwndCombo);
        if (dwUserPref != _saItems[nCurIndex].dwUserPref)
        {
            _fItemChanged = TRUE;
            _saItems[nCurIndex].dwUserPref = dwUserPref;
            _LoadAndSetLVItemText(IDS_NOTIFY_FIRST + dwUserPref, nCurIndex, 1);
        }
    }

    return 0;
}

LRESULT CNotificationsDlg::OnRestoreDefaults(UINT uMsg, UINT uID , HWND hwnd)
{
    for (int i=0;i<_saItems.GetSize();i++)
    {
        if (_saItems[i].dwUserPref != TNUP_AUTOMATIC)
        {
            _fItemChanged = TRUE;
            _saItems[i].dwUserPref = TNUP_AUTOMATIC;
            _LoadAndSetLVItemText(IDS_AUTOMATIC, i, 1);
        }
    }

    return 0;
}

LRESULT CNotificationsDlg::OnCloseCmd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (wID == IDOK)
    {
        ApplyChanges();
    }

    if (_hPlaceholderIcon)
    {
        DestroyIcon(_hPlaceholderIcon);
        _hPlaceholderIcon = NULL;
    }

    _saItems.RemoveAll();

    if (_hwndListView)
    {
        RemoveWindowSubclass(_hwndListView, s_ListViewSubClassWndProc, 0);
    }

    if (_hwndCombo)
    {
        RemoveWindowSubclass(_hwndCombo, s_ComboBoxSubClassWndProc, 0);
    }

    if (_pTrayNotify)
    {
        _pTrayNotify->RegisterCallback(NULL);
    }

    bHandled = TRUE;
    ::EndDialog(m_hWnd, wID);
    return 0;
}

LRESULT CALLBACK CNotificationsDlg::s_ListViewSubClassWndProc( HWND hwnd, UINT uMsg, 
    WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData )
{
    CNotificationsDlg * pNotificationsDlg = reinterpret_cast<CNotificationsDlg*>(dwRefData);
    AssertMsg((pNotificationsDlg != NULL), TEXT("pNotificationsDlg SHOULD NOT be NULL."));

    switch (uMsg)
    {
        case WM_KEYDOWN:
        {
            if (wParam == VK_RIGHT && !pNotificationsDlg->_fComboBoxActive)
            {
                int nIndex = pNotificationsDlg->_GetCurSel();
                if (nIndex != -1)
                {
                    pNotificationsDlg->_nIndex = nIndex;
                    pNotificationsDlg->_fComboBoxActive = TRUE;
                    ::SetFocus(pNotificationsDlg->_hwndCombo);
                }
                return 0;
            }
        }
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK CNotificationsDlg::s_ComboBoxSubClassWndProc( HWND hwnd, UINT uMsg, 
    WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData )
{
    CNotificationsDlg * pNotificationsDlg = reinterpret_cast<CNotificationsDlg*>(dwRefData);
    AssertMsg((pNotificationsDlg != NULL), TEXT("pNotificationsDlg SHOULD NOT be NULL."));

    switch (uMsg)
    {
        case WM_KEYDOWN:
        {
            if (pNotificationsDlg->_fComboBoxActive)
            {
                if (wParam == VK_LEFT)
                {
                    pNotificationsDlg->_fComboBoxActive = FALSE;
                    pNotificationsDlg->_nIndex = 0;
                    ::SetFocus(pNotificationsDlg->_hwndListView);
                    return 0;
                }
                else if (wParam == VK_RIGHT)
                {
                    // Disable selection in combo on right button
                    return 0;
                }
            }
        }
        break;

        case WM_KILLFOCUS:
        {
            if (pNotificationsDlg->_fComboBoxActive)
            {
                pNotificationsDlg->_fComboBoxActive = FALSE;
                pNotificationsDlg->_nIndex = 0;
            }
        }
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

void CNotificationsDlg::ApplyChanges(void)
{
    if (!_fItemChanged)
        return;
        
    if (_pTrayNotify)
    {
        for (int i = 0; i < _saItems.GetSize(); i++)
        {
            _pTrayNotify->SetPreference(&_saItems[i]);
        }
    }
}

void CNotificationsDlg::_ShowComboBox(void)
{
    int nCurIndex = _GetCurSel();
        
    if (!_fComboBoxActive && nCurIndex == -1)
    {
        ::ShowWindow(_hwndCombo, SW_HIDE);
    }
    else if (nCurIndex != -1)
    {
        RECT rcListView;
        ::GetClientRect(_hwndListView, &rcListView);

        RECT rc;
        ListView_GetItemRect(_hwndListView, nCurIndex, &rc, LVIR_BOUNDS);

        RECT rcHeader;
        HWND hwndHeader = ListView_GetHeader(_hwndListView);
        Header_GetItemRect(hwndHeader, 1, &rcHeader);
        rc.left = rcHeader.left;
        rc.right = rcHeader.right;

        if (!EqualRect(&_rcOldPos, &rc))
        {
            _rcOldPos = rc;
            ::MoveWindow(_hwndCombo, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, TRUE);
        }

        if (!::IsWindowVisible(_hwndCombo))
        {
            ::ShowWindow(_hwndCombo, SW_SHOW);
            ComboBox_SetCurSel(_hwndCombo, _saItems[nCurIndex].dwUserPref);
        }
    }
}


//This is the property sheet for all of the task bar stuff
class CTaskBarPropertySheet : public CPropertySheetImpl<CTaskBarPropertySheet>
{
public:
    CTaskBarPropertySheet(UINT nStartPage, HWND hwndParent, DWORD dwFlags) : 
        CPropertySheetImpl<CTaskBarPropertySheet>((LPCTSTR)NULL, nStartPage, hwndParent),
        _dwFlags(dwFlags)
    {
        LoadString(hinstCabinet, IDS_STARTMENUANDTASKBAR, szPath, ARRAYSIZE(szPath));
        SetTitle(szPath);

        HPROPSHEETPAGE hpage;
        PROPSHEETPAGE psp;

        psp.dwSize = sizeof(psp);
        psp.dwFlags = PSP_DEFAULT;
        psp.hInstance = hinstCabinet;

        //taskbar page
        psp.pszTemplate = MAKEINTRESOURCE(DLG_TRAY_OPTIONS);
        psp.pfnDlgProc = s_TaskbarOptionsDlgProc;
        psp.lParam = (LPARAM) this;
        hpage = CreatePropertySheetPage(&psp);
        if (hpage)
            AddPage(hpage);

        //start page
        psp.pszTemplate = MAKEINTRESOURCE(DLG_START);
        psp.pfnDlgProc = s_StartMenuDlgProc;
        psp.lParam = (LPARAM) this;
        hpage = CreatePropertySheetPage(&psp);
        if (hpage)
            AddPage(hpage);

        _pDlgNotify = new CComObject<CNotificationsDlg>;
        if (_pDlgNotify)
        {
            _pDlgNotify->AddRef();
        }
    }

    ~CTaskBarPropertySheet()
    {
        ATOMICRELEASE(_pDlgNotify);
    }

    // We aren't handling any messages special, so we just make an empty map
    DECLARE_EMPTY_MSG_MAP()
private:

    // dlgproc's for the various pages
    static BOOL_PTR s_TaskbarOptionsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR s_StartMenuDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL_PTR TaskbarOptionsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL_PTR StartMenuDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void _ApplyTaskbarOptionsFromDialog(HWND hDlg);
    void _ApplyStartOptionsFromDialog(HWND hDlg);

    // for the old style customize dialog
    SMADVANCED  _Adv;
    //need to keep storage for the title until the property sheet is created
    TCHAR szPath[MAX_PATH];
    CComObject<CNotificationsDlg>* _pDlgNotify;

    DWORD _dwFlags;
};

//
// RegSaveDefaultClient
//
void RegSaveDefaultClient(HWND hwndCB, LPCTSTR pszPath)
{
    int iSelected = ComboBox_GetCurSel(hwndCB);
    if (iSelected >= 0)
    {
        LPTSTR pszKey = (LPTSTR)ComboBox_GetItemData(hwndCB, iSelected);
        if (pszKey)
        {
            if (SHSetValue(HKEY_CURRENT_USER, pszPath, NULL, REG_SZ, pszKey, sizeof(TCHAR) * (1 + lstrlen(pszKey))) == ERROR_SUCCESS)
            {
                SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)pszPath);
            }
        }
    }
}

BOOL RegGetDefaultClient(HWND hwndCB, HKEY hkRoot, LPCTSTR pszPath)
{
    TCHAR szCurrent[MAX_PATH];
    LONG cb = sizeof(szCurrent);
    if (RegQueryValue(hkRoot, pszPath, szCurrent, &cb) != ERROR_SUCCESS ||
        szCurrent[0] == TEXT('\0'))
    {
        return FALSE;
    }

    // Now make sure the selected client exists
    int i = ComboBox_GetCount(hwndCB);
    while (--i >= 0)
    {
        LPTSTR pszKey = (LPTSTR)ComboBox_GetItemData(hwndCB, i);
        // Use StrCmpIC so we don't get faked out by Hungarian locale...
        if (pszKey && StrCmpIC(pszKey, szCurrent) == 0)
        {
            ComboBox_SetCurSel(hwndCB, i);
            return TRUE;
        }
    }

    return FALSE;
}


void RegPopulateComboBox(HWND hwndCB, LPCTSTR pszPath)
{
    TCHAR           szFriendlyName      [MAX_PATH];
    TCHAR           szKeyName           [MAX_PATH];

    DWORD   i;              // Index counter

    HKEY    hkeyProtocol;

    // See if the clients key even exists...
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszPath, 0, KEY_READ, &hkeyProtocol) != ERROR_SUCCESS)
        return;

    // populate the dropdown
    for(i=0;                    // always start with 0
        ERROR_SUCCESS==RegEnumKey(hkeyProtocol, i, szKeyName, ARRAYSIZE(szKeyName));
        i++)                    // get next entry
    {
        // get the friendly name of the client
        if (SUCCEEDED(SHLoadLegacyRegUIString(hkeyProtocol, szKeyName, szFriendlyName, ARRAYSIZE(szFriendlyName))))
        {
            // save its key name so we can find it later
            LPTSTR pszKeyName = StrDup(szKeyName);
            if (pszKeyName)
            {
                // add name to dropdown
                int iAdded = ComboBox_AddString(hwndCB, szFriendlyName);
                if (iAdded >= 0)
                {
                    ComboBox_SetItemData(hwndCB, iAdded, pszKeyName);
                }
                else
                {
                    LocalFree(pszKeyName);
                }
            }
        }
    }

    RegCloseKey(hkeyProtocol);

    // Do this after populating the dropdown because we need to look into
    // the dropdown to see if the current value is valid or not

    //
    //  First try HKCU; then try HKLM...
    //
    if (!RegGetDefaultClient(hwndCB, HKEY_CURRENT_USER, pszPath))
    {
        RegGetDefaultClient(hwndCB, HKEY_LOCAL_MACHINE, pszPath);
    }
}

void RegClearClientComboBox(HWND hDlg, UINT idc)
{
    HWND hwndCB = GetDlgItem(hDlg, idc);

    int i = ComboBox_GetCount(hwndCB);
    while (--i >= 0)
    {
        LPTSTR pszKey = (LPTSTR)ComboBox_GetItemData(hwndCB, i);
        LocalFree(pszKey);
    }
}

void HandleClearButtonClick(HWND hwndClear);
void SetDocButton(HWND hDlg, int id);

//This is the property sheet for the "Customize Simple Start Menu" dlg
class CCustomizeSPPropSheet : public CPropertySheetImpl<CCustomizeSPPropSheet>
{
public:
    CCustomizeSPPropSheet(HWND hwndParent) : 
        CPropertySheetImpl<CCustomizeSPPropSheet>((LPCTSTR)NULL, 0, hwndParent)
      , _fInsideInit(FALSE)
    {
        HPROPSHEETPAGE hpage;
        PROPSHEETPAGE psp;

        // We are heap-allocated so these should be pre-initialized properly
        ASSERT(_bDirtyTree == FALSE);
        ASSERT(_prto == NULL);
        ASSERT(_pph == NULL);

        LoadString(hinstCabinet, IDS_SPCUST_TITLE, _szTitle, ARRAYSIZE(_szTitle));
        SetTitle(_szTitle);

        m_psh.dwFlags |= PSH_NOAPPLYNOW;

        psp.dwSize = sizeof(psp);
        psp.dwFlags = PSP_DEFAULT;
        psp.hInstance = hinstCabinet;

        //General page
        psp.pszTemplate = MAKEINTRESOURCE(DLG_PAGE_SMGENERAL);
        psp.pfnDlgProc = s_GeneralTabDlgProc;
        psp.lParam = (LPARAM) this;
        hpage = CreatePropertySheetPage(&psp);
        if (hpage)
            AddPage(hpage);

        //Advanced page
        psp.pszTemplate = MAKEINTRESOURCE(DLG_PAGE_SMADVANCED);
        psp.pfnDlgProc = s_AdvancedTabDlgProc;
        psp.lParam = (LPARAM) this;
        hpage = CreatePropertySheetPage(&psp);
        if (hpage)
            AddPage(hpage);

    };

    ~CCustomizeSPPropSheet()
    {
        ASSERT(!_prto);     // should be gone by now
        if (_pph)
            delete _pph;
    }

private:

    // dlgproc's for the various pages
    static BOOL_PTR s_GeneralTabDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR s_AdvancedTabDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL_PTR GeneralTabDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL_PTR AdvancedTabDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL GeneralTabInit(HWND hDlg);
    BOOL AdvancedTabInit(HWND hDlg);

    BOOL OnCommand(UINT id, UINT code, HWND hwndCtl, HWND hwndDlg); // shared command handler
    BOOL OnGeneralApply(HWND hwndDlg);
    BOOL_PTR OnAdvancedNotify(HWND hwndDlg, NMHDR * pnm);
    BOOL_PTR OnAdvancedHelp(HWND hDlg, HELPINFO *phi);

    void _InitMagicEntries();
    void _SaveMagicEntries();

    //helpers
    DWORD _ReadStartPageSetting(LPCTSTR pszVal, DWORD dwDefault)
    {
        DWORD dw, cb=sizeof(dw), dwType;
        SHRegGetUSValue(REGSTR_PATH_STARTPANE_SETTINGS, pszVal, &dwType, &dw, &cb, FALSE, &dwDefault, sizeof(dwDefault));
        return dw; // since we passed a default value, above fn will return our default on failure
    }
    BOOL _ReadStartPageCUSetting(LPCTSTR pszVal, DWORD *pdw) // returns TRUE/FALSE for present under CU or not, actual value in pdw
    {
        DWORD cb=sizeof(*pdw), dwType;
        return NO_ERROR == SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_STARTPANE_SETTINGS, pszVal, &dwType, pdw, &cb);
    }
    BOOL _WriteStartPageSetting(LPCTSTR pszVal, DWORD dwVal)
    {
        return SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_STARTPANE_SETTINGS, pszVal, REG_DWORD, &dwVal, sizeof(dwVal)) == NO_ERROR;
    }
    BOOL _ClearStartPageSetting(LPCTSTR pszVal)
    {
        return SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_STARTPANE_SETTINGS, pszVal) == NO_ERROR;
    }

    // State
    BOOL _bLargeIcons;
    IRegTreeOptions *_prto;

    // Dirty Flags
    BOOL _bDirtyTree;       // to avoid saving the tree if we don't need to
    BOOL _bDirtyClients;    // to avoid saving the clients if we don't need to
    BOOL _bDirtyPinList;    // to avoid re-persisting the pin list (and possibly changing the order)
    BOOL _bCustNetPlaces;   // Did the user previously have net places customized?
    BOOL _bCustNetConn;     // Did the user previously have net connections customized?

    // random bits
    CPinHelper *_pph;
    TCHAR _szTitle[80];      // needed for the propsheet title...

    // We need this to take care of initialization!
    BOOL  _fInsideInit;
};

BOOL_PTR CCustomizeSPPropSheet::s_GeneralTabDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CCustomizeSPPropSheet* self = NULL;

    if (uMsg == WM_INITDIALOG)
    {
        ::SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        self = (CCustomizeSPPropSheet*) ((PROPSHEETPAGE*)lParam)->lParam;
    }
    else
    {
        PROPSHEETPAGE* psp = (PROPSHEETPAGE*)::GetWindowLongPtr(hDlg, DWLP_USER);
        if (psp)
            self = (CCustomizeSPPropSheet*)psp->lParam;
    }

    if (self)
    {
        return self->GeneralTabDlgProc(hDlg, uMsg, wParam, lParam);
    }
    else
    {
        return FALSE;
    }
}

BOOL_PTR CCustomizeSPPropSheet::s_AdvancedTabDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CCustomizeSPPropSheet* self = NULL;

    if (uMsg == WM_INITDIALOG)
    {
        ::SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        self = (CCustomizeSPPropSheet*) ((PROPSHEETPAGE*)lParam)->lParam;
    }
    else
    {
        PROPSHEETPAGE* psp = (PROPSHEETPAGE*)::GetWindowLongPtr(hDlg, DWLP_USER);
        if (psp)
            self = (CCustomizeSPPropSheet*)psp->lParam;
    }

    if (self)
    {
        return self->AdvancedTabDlgProc(hDlg, uMsg, wParam, lParam);
    }
    else
    {
        return FALSE;
    }
}

BOOL_PTR CCustomizeSPPropSheet::GeneralTabDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return GeneralTabInit(hDlg);
        case WM_COMMAND:
            return OnCommand(LOWORD(wParam), HIWORD(wParam), (HWND) lParam, hDlg);
        case WM_DESTROY:
            {
                SetDlgItemIcon(hDlg, IDC_SPCUST_ICONSMALL, NULL);
                SetDlgItemIcon(hDlg, IDC_SPCUST_ICONLARGE, NULL);
                RegClearClientComboBox(hDlg, IDC_SPCUST_EMAILCB);
                RegClearClientComboBox(hDlg, IDC_SPCUST_INTERNETCB);
                break;
            }
        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code)
            {
                case PSN_APPLY:
                    return OnGeneralApply(hDlg);

            }
            break;

        case WM_HELP:
            ::WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aStartCustGeneralTabHelpIDs);
            break;

        case WM_CONTEXTMENU:
            ::WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aStartCustGeneralTabHelpIDs);
            break;
    }
    return FALSE;
}

BOOL CCustomizeSPPropSheet::GeneralTabInit(HWND hDlg)
{
    _fInsideInit = TRUE; //We are getting inside initilization!
    
    ::SendMessage(::GetDlgItem(hDlg, IDC_SPCUST_MINPROGS_ARROW), UDM_SETRANGE, 0, (LPARAM)MAKELONG(MAX_PROGS_ALLOWED, 0));
    
    // set up icon size
    _bLargeIcons = _ReadStartPageSetting(REGSTR_VAL_DV2_LARGEICONS, /*bDefault*/ TRUE);
    ::CheckDlgButton(hDlg, IDC_SPCUST_LARGE, _bLargeIcons);
    ::CheckDlgButton(hDlg, IDC_SPCUST_SMALL, !_bLargeIcons);

    SetProgramIcon(hDlg, IDC_SPCUST_ICONLARGE, IDC_SPCUST_ICONSMALL);

    // Set up the Number of programs dropdown
    DWORD dwMinMFU = _ReadStartPageSetting(REGSTR_VAL_DV2_MINMFU, REGSTR_VAL_DV2_MINMFU_DEFAULT);
    ::SetDlgItemInt(hDlg, IDC_SPCUST_MINPROGS, dwMinMFU, FALSE);

    // Set up internet, email checkboxes and comboboxes
    BOOL bInternet=FALSE, bMail=FALSE;
    RegPopulateComboBox(::GetDlgItem(hDlg, IDC_SPCUST_EMAILCB), TEXT("SOFTWARE\\Clients\\mail"));
    RegPopulateComboBox(::GetDlgItem(hDlg, IDC_SPCUST_INTERNETCB), TEXT("SOFTWARE\\Clients\\StartMenuInternet"));

    // if this fails, its not fatal, we just won't be able to persist the pin info
    _pph = new CPinHelper();
    if (_pph)
    {
        _pph->GetPinInfo(&bInternet, &bMail);
    }

    ::CheckDlgButton(hDlg, IDC_SPCUST_INTERNET, bInternet);
    ::CheckDlgButton(hDlg, IDC_SPCUST_EMAIL,    bMail);
    ::EnableWindow(::GetDlgItem(hDlg, IDC_SPCUST_INTERNETCB), bInternet);
    ::EnableWindow(::GetDlgItem(hDlg, IDC_SPCUST_EMAILCB),   bMail);

    _fInsideInit = FALSE;  //We are done initializing.
    
    return TRUE;
}

// Temp until the new UEM code gets in...
void ClearUEMData()
{
    HKEY hk;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\UserAssist\\{75048700-EF1F-11D0-9888-006097DEACF9}\\Count"), 
        0, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
        &hk))
    {
        int cValues;
        if (ERROR_SUCCESS == RegQueryInfoKey(hk, NULL, NULL, NULL, NULL, NULL, NULL, (DWORD*) &cValues, NULL, NULL, NULL, NULL))
        {
            while (cValues >= 0)
            {
                TCHAR szValue[MAX_PATH];
                DWORD cch = ARRAYSIZE(szValue);
                DWORD cbData;
                if (ERROR_SUCCESS != RegEnumValue(hk, --cValues, szValue, &cch, NULL, NULL, NULL, &cbData))
                    break;
                // don't nuke the session value
                if (cbData > 8)
                    RegDeleteValue(hk, szValue);
            }
#ifdef DEBUG
            RegQueryInfoKey(hk, NULL, NULL, NULL, NULL, NULL, NULL, (DWORD*) &cValues, NULL, NULL, NULL, NULL);
            ASSERT(cValues == 1);           // the session info value should still exist
#endif
        }

        RegCloseKey(hk);

        // Set the "Apps installed prior to this point are not interesting"
        // to the current time.  Since we deleted all the usages, we have to
        // do something to prevent all the user's apps from being redetected
        // as "newly installed and not yet run".

        FILETIME ftNow;
        GetSystemTimeAsFileTime(&ftNow);
        SHRegSetUSValue(DV2_REGPATH, DV2_SYSTEM_START_TIME, REG_BINARY,
                        &ftNow, sizeof(ftNow), SHREGSET_FORCE_HKCU);


        // Start a new session - this kick-starts anybody who is listening
        // to UEM events to tell them their cache is invalid
        UEMFireEvent(&UEMIID_SHELL, UEME_CTLSESSION, UEMF_XEVENT, TRUE, -1);
    }
}

void AdjustNumOfProgsOnStartMenu(HWND hwndDlg, UINT Id)
{
    BOOL fTranslated;
    int iNumOfProgs = (int)GetDlgItemInt(hwndDlg, Id, &fTranslated, FALSE);
    int iNewNumOfProgs = min(max(iNumOfProgs, 0), MAX_PROGS_ALLOWED);
    if((iNumOfProgs != iNewNumOfProgs) || (!fTranslated))
    {
        SetDlgItemInt(hwndDlg, Id, (UINT)iNewNumOfProgs, FALSE);
        SendPSMChanged(hwndDlg);
    }
}

// NOTE - shared WM_COMMAND handler
//
BOOL CCustomizeSPPropSheet::OnCommand(UINT id, UINT code, HWND hwndCtl, HWND hwndDlg)
{
    switch (id)
    {
        ////// General Tab Controls
        case IDC_SPCUST_LARGE:
        case IDC_SPCUST_SMALL:
            _bLargeIcons = (id == IDC_SPCUST_LARGE);
            SendPSMChanged(hwndDlg);
            return FALSE;
        case IDC_SPCUST_MINPROGS:
            if(code == EN_KILLFOCUS)
                AdjustNumOfProgsOnStartMenu(hwndDlg, id);
            else
            {
                if ((_fInsideInit == FALSE) && (code == EN_CHANGE))
                    SendPSMChanged(hwndDlg);
            }
            return FALSE;
            
        case IDB_SPCUST_CLEARPROG:
            ClearUEMData();
            return FALSE;

        case IDC_SPCUST_INTERNET:
        case IDC_SPCUST_EMAIL:
            COMPILETIME_ASSERT(IDC_SPCUST_INTERNETCB == IDC_SPCUST_INTERNET+1);
            COMPILETIME_ASSERT(IDC_SPCUST_EMAILCB == IDC_SPCUST_EMAIL+1);
            ::EnableWindow(::GetDlgItem(hwndDlg, id+1), ::IsDlgButtonChecked(hwndDlg, id));
            _bDirtyPinList = TRUE;
            SendPSMChanged(hwndDlg);
            return FALSE;

        case IDC_SPCUST_INTERNETCB:
        case IDC_SPCUST_EMAILCB:
            if (code == CBN_SELCHANGE)
            {
                _bDirtyClients = TRUE;
                SendPSMChanged(hwndDlg);
            }
            return FALSE;


        ////// Advanced Tab Controls
        case IDC_SPCUST_RECENT:
            SendPSMChanged(hwndDlg);
            return FALSE;
        case IDB_SPCUST_CLEARDOCS:
            HandleClearButtonClick(hwndCtl);
            return FALSE;

        case IDC_SPCUST_HOVEROPEN:
        case IDC_SPCUST_NOTIFYNEW:
            SendPSMChanged(hwndDlg);
            return FALSE;
            break;

    }
    return TRUE;
}

BOOL CCustomizeSPPropSheet::OnGeneralApply(HWND hDlg)
{
    TraceMsg(TF_ALWAYS, "cspps.General apply", _bDirtyTree);

    _WriteStartPageSetting(REGSTR_VAL_DV2_LARGEICONS,  _bLargeIcons);

    if (_pph && _bDirtyPinList)
    {
        BOOL bInternet  = ::IsDlgButtonChecked(hDlg, IDC_SPCUST_INTERNET);
        BOOL bMail      = ::IsDlgButtonChecked(hDlg, IDC_SPCUST_EMAIL);
        _pph->Save(bMail, bInternet);
    }
    if (_bDirtyClients)
    {
        // persist Internet, Mail comboboxes
        RegSaveDefaultClient(::GetDlgItem(hDlg, IDC_SPCUST_EMAILCB), TEXT("Software\\Clients\\mail"));
        RegSaveDefaultClient(::GetDlgItem(hDlg, IDC_SPCUST_INTERNETCB), TEXT("SOFTWARE\\Clients\\StartMenuInternet"));
    }

    BOOL bTranslated;
    DWORD dwMinMFU = ::GetDlgItemInt(hDlg, IDC_SPCUST_MINPROGS, &bTranslated, FALSE);
    if (EVAL(bTranslated))
    {
        dwMinMFU = min(max(dwMinMFU, 0), MAX_PROGS_ALLOWED);
        _WriteStartPageSetting(REGSTR_VAL_DV2_MINMFU, dwMinMFU);
    }

    return TRUE;
}

BOOL_PTR CCustomizeSPPropSheet::OnAdvancedNotify(HWND hwndDlg, NMHDR * pnm)
{
    ::SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, 0); // handled
    switch (pnm->code)
    {
        case PSN_APPLY:
            TraceMsg(TF_ALWAYS, "cspps.Advanced apply - _bDirtyTree=%d", _bDirtyTree);
            if (_bDirtyTree)
            {
                _prto->WalkTree(WALK_TREE_SAVE);
            }

            _WriteStartPageSetting(REGSTR_VAL_DV2_SHOWRECDOCS,  ::IsDlgButtonChecked(hwndDlg, IDC_SPCUST_RECENT) ? 2 : 0);  // 2 so that it cascades
            _WriteStartPageSetting(REGSTR_VAL_DV2_AUTOCASCADE,  ::IsDlgButtonChecked(hwndDlg, IDC_SPCUST_HOVEROPEN));
            _WriteStartPageSetting(REGSTR_VAL_DV2_NOTIFYNEW,    ::IsDlgButtonChecked(hwndDlg, IDC_SPCUST_NOTIFYNEW));
            // fall through to PSN_RESET case...

        case PSN_RESET:
            _SaveMagicEntries(); // this must be called on both cancel and apply, so that it cleans up properly...

            // must release prto before the treeview goes away!
            _prto->WalkTree(WALK_TREE_DELETE);
            ATOMICRELEASE(_prto);
            break;

        case TVN_KEYDOWN:
        {
            TV_KEYDOWN *pnmtv = (TV_KEYDOWN*)pnm;
            if (pnmtv->wVKey == VK_SPACE)
            {
                HWND hwndTree = ::GetDlgItem(hwndDlg, IDC_STARTMENUSETTINGS);
                _prto->ToggleItem((HTREEITEM)SendMessage(hwndTree, TVM_GETNEXTITEM, (WPARAM)TVGN_CARET, 0L));
                _bDirtyTree = TRUE;
                SendPSMChanged(hwndDlg);
                ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE); // eat the key
            }
            break;
        }

        case NM_CLICK:
        case NM_DBLCLK:
            // is this click in our tree?
            if ( pnm->idFrom == IDC_STARTMENUSETTINGS )
            {
                HWND hwndTree = ::GetDlgItem(hwndDlg, IDC_STARTMENUSETTINGS);
                TV_HITTESTINFO ht;

                DWORD dwPos = GetMessagePos();                  // get where we were hit
                ht.pt.x = GET_X_LPARAM(dwPos);
                ht.pt.y = GET_Y_LPARAM(dwPos);
                ::ScreenToClient(hwndTree, &ht.pt);       // translate it to our window

                // retrieve the item hit
                HTREEITEM hti = TreeView_HitTest(hwndTree, &ht);
                if (hti)
                {
                    _prto->ToggleItem(hti);
                    _bDirtyTree = TRUE;
                    SendPSMChanged(hwndDlg);
                }
            }

            break;
        // no help yet- needs ids/text from UA
#if 0
        case NM_RCLICK:      // right mouse click
            if (pnm->hwndFrom == hwndTree)
            {
                _DoTreeHelp(pAdv, (WPARAM)pnm->hwndFrom);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE); // eat the click
                return TRUE;
            }
            break;
#endif 
    }
    return TRUE;
}

BOOL_PTR CCustomizeSPPropSheet::OnAdvancedHelp(HWND hDlg, HELPINFO *phi)
{
    if (phi->iCtrlId != IDC_STARTMENUSETTINGS)
    {
        ::WinHelp((HWND)(phi->hItemHandle), NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)aStartCustAdvancedTabHelpIDs);
    }
    else
    {
        HTREEITEM hItem;
        HWND hwndTree = ::GetDlgItem(hDlg, IDC_STARTMENUSETTINGS);

        //Is this help invoked throught F1 key
        if (GetAsyncKeyState(VK_F1) < 0)
        {
            // Yes. WE need to give help for the currently selected item
            hItem = TreeView_GetSelection(hwndTree);
        }
        else
        {
            //No, We need to give help for the item at the cursor position
            TV_HITTESTINFO ht;
            ht.pt = phi->MousePos;
            ::ScreenToClient(hwndTree, &ht.pt); // Translate it to our window
            hItem = TreeView_HitTest(hwndTree, &ht);
        }

        if (hItem)
            _prto->ShowHelp(hItem, HELP_WM_HELP);
    }
    return TRUE;
}

BOOL_PTR CCustomizeSPPropSheet::AdvancedTabDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return AdvancedTabInit(hDlg);
        case WM_COMMAND:
            return OnCommand(LOWORD(wParam), HIWORD(wParam), (HWND) lParam, hDlg);
        case WM_NOTIFY:
            return OnAdvancedNotify(hDlg, (NMHDR*)lParam);
        case WM_HELP:
            return OnAdvancedHelp(hDlg, (HELPINFO*) lParam);
            break;
        case WM_CONTEXTMENU:
            ::WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aStartCustAdvancedTabHelpIDs);
            break;
    }
    return FALSE;
}

int DefaultNetConValue()
{
    return ShouldShowConnectTo() ? 2 : 0;      // default to menu-style (2)
}

int DefaultNetPlacesValue()
{
    return ShouldShowNetPlaces() ? 1 : 0;      // default to link -style (1)
}

// These two "magic" functions maintain the proper behavior of the network places and network connections settings
// which, by default, turn on when there are n or more items in the folder.  But they can also be customized by the
// user to force them on or off.

void CCustomizeSPPropSheet::_InitMagicEntries()
{
    BOOL bNewNetPlaces;
    BOOL bNewNetConn;

    _bCustNetPlaces = _ReadStartPageCUSetting(REGSTR_VAL_DV2_SHOWNETPL, (DWORD*) &bNewNetPlaces);
    _bCustNetConn = _ReadStartPageCUSetting(REGSTR_VAL_DV2_SHOWNETCONN, (DWORD*) &bNewNetConn);
    // if the user didn't previously customize these settings, then use the auto-magic setting
    if (!_bCustNetPlaces)
        bNewNetPlaces = DefaultNetPlacesValue();
    if (!_bCustNetConn)
        bNewNetConn   = DefaultNetConValue();

    // Write it out, so the rgtreeoption control will reflect either the user's customization, or the magic value
    _WriteStartPageSetting(REGSTR_VAL_DV2_SHOWNETPL, bNewNetPlaces);
    _WriteStartPageSetting(REGSTR_VAL_DV2_SHOWNETCONN, bNewNetConn);

    // for the admin tools radio buttons:
    // 0 = don't show anywhere
    // 1 = display in all programs (StartMenuAdminTools = 1, Start_AdminToolsRoot = 0)
    // 2 = display in all programs and root (StartMenuAdminTools = 1, Start_AdminToolsRoot = 2)
    int iAdminToolsTemp = _ReadStartPageSetting(REGSTR_VAL_DV2_ADMINTOOLSROOT, FALSE) ? 2 :
                          (_ReadStartPageSetting(TEXT("StartMenuAdminTools"), FALSE) ? 1 : 0);

    _WriteStartPageSetting(REGSTR_VAL_ADMINTOOLSTEMP, iAdminToolsTemp);
}

void CCustomizeSPPropSheet::_SaveMagicEntries()
{
    BOOL bNewNetPlaces = _ReadStartPageSetting(REGSTR_VAL_DV2_SHOWNETPL, FALSE);
    BOOL bNewNetConn   = _ReadStartPageSetting(REGSTR_VAL_DV2_SHOWNETCONN, FALSE);

    // if the user previously had it customized, then we don't need to clear it since it will either
    // contain the original value we loaded in _InitMagicEntries, or the updated value if the user changed it.
    // if it wasn't originally customized, then we need to clear it if the tree isn't even dirty, or the current value is the magic value we loaded

    if (!_bCustNetPlaces && (!_bDirtyTree || bNewNetPlaces == DefaultNetPlacesValue()))
        _ClearStartPageSetting(REGSTR_VAL_DV2_SHOWNETPL);

    if (!_bCustNetConn && (!_bDirtyTree || bNewNetConn == DefaultNetConValue()))
        _ClearStartPageSetting(REGSTR_VAL_DV2_SHOWNETCONN);

    if (_bDirtyTree)
    {
        // see comment above for how this should work
        int iAdminToolsTemp = _ReadStartPageSetting(REGSTR_VAL_ADMINTOOLSTEMP, FALSE);
        int iATRoot = 0;
        int iATPrograms = 0;

        if (iAdminToolsTemp >= 1)
        {
            iATPrograms = 1;
            if (iAdminToolsTemp == 2)
            {
                iATRoot = 2;
            }
        }
        _WriteStartPageSetting(REGSTR_VAL_DV2_ADMINTOOLSROOT, iATRoot);
        _WriteStartPageSetting(TEXT("StartMenuAdminTools"), iATPrograms);
    }
    _ClearStartPageSetting(REGSTR_VAL_ADMINTOOLSTEMP);
}

BOOL CCustomizeSPPropSheet::AdvancedTabInit(HWND hDlg)
{
    if (SUCCEEDED(CoCreateInstance(CLSID_CRegTreeOptions, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IRegTreeOptions, &_prto))))
    {
        HRESULT hr;
        HWND hwndTV = ::GetDlgItem(hDlg, IDC_STARTMENUSETTINGS);

        // Compute the magic entries before we init the RegTreeOptions
        // (so we will have correct information for him!)
        _InitMagicEntries();

        // HACKHACK - IRegTreeOptions is ANSI, so we temporarily turn off UNICODE
        #undef TEXT
        #define TEXT(s) s
        hr = _prto->InitTree(hwndTV, HKEY_LOCAL_MACHINE, REGSTR_PATH_SMADVANCED "\\StartPanel", NULL);

        #undef TEXT
        #define TEXT(s) __TEXT(s)

        TreeView_SelectSetFirstVisible(hwndTV, TreeView_GetRoot(hwndTV));

        ::CheckDlgButton(hDlg, IDC_SPCUST_RECENT,   _ReadStartPageSetting(REGSTR_VAL_DV2_SHOWRECDOCS, IsOS(OS_PERSONAL) ? FALSE : TRUE));
        ::CheckDlgButton(hDlg, IDC_SPCUST_HOVEROPEN,_ReadStartPageSetting(REGSTR_VAL_DV2_AUTOCASCADE, TRUE));
        ::CheckDlgButton(hDlg, IDC_SPCUST_NOTIFYNEW,_ReadStartPageSetting(REGSTR_VAL_DV2_NOTIFYNEW, TRUE));

        if(SHRestricted(REST_NORECENTDOCSMENU))
        {
            //Since this policy is present, hide all the relevant controls
            ::ShowWindow(::GetDlgItem(hDlg, IDC_SPCUST_RECENT_GROUPBOX), FALSE);// Group box
            ::ShowWindow(::GetDlgItem(hDlg, IDC_SPCUST_RECENT_TEXT), FALSE);    // Description Text.
            ::ShowWindow(::GetDlgItem(hDlg, IDC_SPCUST_RECENT), FALSE);         // Check box
            ::ShowWindow(::GetDlgItem(hDlg, IDB_SPCUST_CLEARDOCS), FALSE);      // Clear button.
        }

        SetDocButton(hDlg, IDB_SPCUST_CLEARDOCS);

        return TRUE;
    }

    
    return FALSE;
}

BOOL_PTR CTaskBarPropertySheet::s_TaskbarOptionsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CTaskBarPropertySheet* self = NULL;

    if (uMsg == WM_INITDIALOG)
    {
        ::SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        self = (CTaskBarPropertySheet*) ((PROPSHEETPAGE*)lParam)->lParam;
    }
    else
    {
        PROPSHEETPAGE* psp = (PROPSHEETPAGE*)::GetWindowLongPtr(hDlg, DWLP_USER);
        if (psp)
            self = (CTaskBarPropertySheet*)psp->lParam;
    }

    
    BOOL_PTR fValue = FALSE;
    if (self)
    {
        self->TaskbarOptionsDlgProc(hDlg, uMsg, wParam, lParam);
    }

    return fValue;
}

void _TaskbarOptions_OnInitDialog(HWND hDlg)
{
    TRAYVIEWOPTS tvo;
    c_tray.GetTrayViewOpts(&tvo);
    
    CheckDlgButton(hDlg, IDC_QUICKLAUNCH, tvo.fShowQuickLaunch);
    CheckDlgButton(hDlg, IDC_TRAYOPTONTOP, tvo.fAlwaysOnTop);
    CheckDlgButton(hDlg, IDC_TRAYOPTAUTOHIDE, (tvo.uAutoHide & AH_ON));
    CheckDlgButton(hDlg, IDC_TRAYOPTSHOWCLOCK, !tvo.fHideClock);
    if (SHRestricted(REST_HIDECLOCK))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_TRAYOPTSHOWCLOCK), FALSE);
    }

    if (SHRestricted(REST_NOTOOLBARSONTASKBAR))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_QUICKLAUNCH), FALSE);
    }
    // Restriction- either the tray is disabled by policy, or the "smart" auto tray 
    // is disabled by policy
    if (tvo.fNoTrayItemsDisplayPolicyEnabled || tvo.fNoAutoTrayPolicyEnabled) 
    {
        EnableWindow(GetDlgItem(hDlg, IDC_NOTIFYMAN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CUSTOMIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_NOTIFY), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_CUSTOMIZE), tvo.fAutoTrayEnabledByUser);
        CheckDlgButton(hDlg, IDC_NOTIFYMAN, tvo.fAutoTrayEnabledByUser);
    }

    CheckDlgButton(hDlg, IDC_LOCKTASKBAR, !_IsSizeMoveEnabled());
    BOOL fEnable = !_IsSizeMoveRestricted();
    EnableWindow(GetDlgItem(hDlg, IDC_LOCKTASKBAR), fEnable);

    if (SHRestricted(REST_NOTASKGROUPING))
    {
        // If there is a restriction of any kine, hide the window
        ShowWindow(GetDlgItem(hDlg, IDC_GROUPITEMS), FALSE);
    }
    else if (SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("TaskbarGlomming"),
                        FALSE, TRUE))
    {
        CheckDlgButton(hDlg, IDC_GROUPITEMS, TRUE);
    }

    _TaskbarOptionsSizeControls(hDlg);
    _TaskbarOptionsUpdateDisplay(hDlg);
}

BOOL_PTR CTaskBarPropertySheet::TaskbarOptionsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INSTRUMENT_WNDPROC(SHCNFI_TRAYVIEWOPTIONS_DLGPROC, hDlg, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_COMMAND:
        if (GET_WM_COMMAND_ID(wParam, lParam) == IDC_CUSTOMIZE)
        {
            if (_pDlgNotify)
            {
                _pDlgNotify->DoModal();
            }
        }

        _TaskbarOptionsUpdateDisplay(hDlg);
        SendPSMChanged(hDlg);

        break;

    case WM_INITDIALOG:
        _TaskbarOptions_OnInitDialog(hDlg);
        if (_dwFlags & TPF_INVOKECUSTOMIZE)
        {
            ::PostMessage(hDlg, WM_COMMAND, IDC_CUSTOMIZE, 0);
        }
        break;

    case WM_SYSCOLORCHANGE:
        _TaskbarOptionsUpdateDisplay(hDlg);
        return TRUE;

    case WM_DESTROY:
        _TaskbarOptionsDestroyBitmaps(hDlg);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case PSN_APPLY:
            // save settings here

            _ApplyTaskbarOptionsFromDialog(hDlg);
            return TRUE;

        case PSN_KILLACTIVE:
        case PSN_SETACTIVE:
            return TRUE;

        }
        break;

    case WM_HELP:
        ::WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aTaskOptionsHelpIDs);
        break;

    case WM_CONTEXTMENU:
        ::WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aTaskOptionsHelpIDs);
        break;
    }

    return FALSE;
}

void _StartOptions_OnInitDialog(HWND hDlg)
{
    // If StartPanel UI is turned off, then this check box should not show up! 
    if (SHRestricted(REST_NOSTARTPANEL))
    {
        //If the restriction exists, then hide this check box.
        ShowWindow(::GetDlgItem(hDlg, IDC_NEWSCHOOL), FALSE);
        ShowWindow(::GetDlgItem(hDlg, IDC_NEWSCHOOLDESCRIPTION), FALSE);
        ShowWindow(::GetDlgItem(hDlg, IDC_NEWSTARTCUSTOMIZE), FALSE);

        // And the only thing you can do is check the OldSchool button
        CheckDlgButton(hDlg, IDC_OLDSCHOOL, TRUE);

        // TODO - PM's need to figure out what to do in the case where new start menu is restricted
        //        or not available.  This propsheet page is rather pointless in that case...
        SetDlgItemBitmap(hDlg, IDC_STARTMENUPREVIEW, IDB_STARTPREVIEWCLASSIC);
    }
    else
    {
        SHELLSTATE  ss = {0};
        SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);
        CheckDlgButton(hDlg, IDC_NEWSCHOOL, BOOLIFY(ss.fStartPanelOn));
        CheckDlgButton(hDlg, IDC_OLDSCHOOL, !BOOLIFY(ss.fStartPanelOn));

        SetDlgItemBitmap(hDlg, IDC_STARTMENUPREVIEW,
            ss.fStartPanelOn ? IDB_STARTPREVIEWNEW : IDB_STARTPREVIEWCLASSIC);
        
        // disable "customize" for the style thats off.
        EnableWindow(GetDlgItem(hDlg, ss.fStartPanelOn ? IDC_OLDSTARTCUSTOMIZE : IDC_NEWSTARTCUSTOMIZE), FALSE);
    }
}

// On destroy, clean up the bitmaps we loaded so we don't leak them
void _StartOptions_OnDestroy(HWND hDlg)
{
    SetDlgItemBitmap(hDlg, IDC_STARTMENUPREVIEW, 0);
}

BOOL_PTR CTaskBarPropertySheet::s_StartMenuDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CTaskBarPropertySheet* self = NULL;

    if (uMsg == WM_INITDIALOG)
    {
        ::SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        self = (CTaskBarPropertySheet*) ((PROPSHEETPAGE*)lParam)->lParam;
    }
    else
    {
        PROPSHEETPAGE* psp = (PROPSHEETPAGE*)::GetWindowLongPtr(hDlg, DWLP_USER);
        if (psp)
            self = (CTaskBarPropertySheet*)psp->lParam;
    }

    BOOL_PTR fValue = FALSE;
    if (self)
    {
        self->StartMenuDlgProc(hDlg, uMsg, wParam, lParam);
    }

    return fValue;
}


BOOL_PTR CTaskBarPropertySheet::StartMenuDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_NEWSCHOOL:
            case IDC_OLDSCHOOL:
                if (HIWORD(wParam) == BN_CLICKED)
                {
                    ::EnableWindow(::GetDlgItem(hDlg, IDC_NEWSTARTCUSTOMIZE), GET_WM_COMMAND_ID(wParam, lParam) == IDC_NEWSCHOOL);
                    ::EnableWindow(::GetDlgItem(hDlg, IDC_OLDSTARTCUSTOMIZE), GET_WM_COMMAND_ID(wParam, lParam) == IDC_OLDSCHOOL);
                    SetDlgItemBitmap(hDlg, IDC_STARTMENUPREVIEW,
                        GET_WM_COMMAND_ID(wParam, lParam) == IDC_NEWSCHOOL ? IDB_STARTPREVIEWNEW : IDB_STARTPREVIEWCLASSIC);
    
                    SendPSMChanged(hDlg);
                }
                break;


            case IDC_NEWSTARTCUSTOMIZE:
            {
                CCustomizeSPPropSheet *pps = new CCustomizeSPPropSheet(hDlg);
                if (pps)
                {
                    if (pps->DoModal() == IDOK)
                    {
                        // if anything changed, let the propsheet know
                        SendPSMChanged(hDlg);
                    }
                    delete pps;
                }
                break;
            }
            case IDC_OLDSTARTCUSTOMIZE:
            {
                if (FAILED(CoCreateInstance(CLSID_CRegTreeOptions, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IRegTreeOptions, &_Adv.pTO))))
                {
                    TraceMsg(TF_WARNING, "ctbps failed to create CRegTreeOptions");
                    break;
                }

                if (DialogBoxParam(hinstCabinet, MAKEINTRESOURCE(DLG_STARTMENU_CONFIG), hDlg, AdvancedOptDlgProc, (LPARAM)&_Adv))
                {
                    // if anything changed, let the propsheet know
                    SendPSMChanged(hDlg);
                }
                break;
            }
        }

        break;

    case WM_INITDIALOG:
        _StartOptions_OnInitDialog(hDlg);
        break;

    case WM_DESTROY:
        _StartOptions_OnDestroy(hDlg);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case PSN_APPLY:
            // save settings here

            _ApplyStartOptionsFromDialog(hDlg);
            return TRUE;

        case PSN_KILLACTIVE:
        case PSN_SETACTIVE:
            return TRUE;

        }
        break;

    case WM_HELP:
        ::WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aStartTabHelpIDs);
        break;

    case WM_CONTEXTMENU:
        ::WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aStartTabHelpIDs);
        break;
    }

    return FALSE;
}

void _UpdateNotifySetting(BOOL fNotifySetting)
{
    ITrayNotify * pTrayNotify = NULL;
    // localserver for tray notify
    if (SUCCEEDED(CoCreateInstance(CLSID_TrayNotify, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(ITrayNotify, &pTrayNotify))))
    {
        pTrayNotify->EnableAutoTray(fNotifySetting);
        pTrayNotify->Release();
    }
}

void CTaskBarPropertySheet ::_ApplyTaskbarOptionsFromDialog(HWND hDlg)
{
    // We need to get the Cabinet structure from the property sheet info.

    // First check for Always on Top
    BOOL fAlwaysOnTop = ::IsDlgButtonChecked(hDlg, IDC_TRAYOPTONTOP);
    c_tray._UpdateAlwaysOnTop(fAlwaysOnTop);

    // And change the Autohide state
    BOOL fAutoHide = ::IsDlgButtonChecked(hDlg, IDC_TRAYOPTAUTOHIDE);
    LONG lRet = c_tray._SetAutoHideState(fAutoHide);

    TRAYVIEWOPTS tvo;
    c_tray.GetTrayViewOpts(&tvo);
    if (!HIWORD(lRet) && fAutoHide)
    {
        // we tried and failed.
        if (!(tvo.uAutoHide & AH_ON))
        {
            ::CheckDlgButton(hDlg, IDC_TRAYOPTAUTOHIDE, FALSE);
            _TaskbarOptionsUpdateDisplay(hDlg);
        }
    }
    BOOL fChanged = LOWORD(lRet);

    if (fChanged)
        c_tray._AppBarNotifyAll(NULL, ABN_STATECHANGE, NULL, 0);

    // show/hide the clock
    tvo.fHideClock = !::IsDlgButtonChecked(hDlg, IDC_TRAYOPTSHOWCLOCK);

    if (!tvo.fNoTrayItemsDisplayPolicyEnabled && !tvo.fNoAutoTrayPolicyEnabled)
    {
        BOOL fNotifySetting = ::IsDlgButtonChecked(hDlg, IDC_NOTIFYMAN);
        if (tvo.fAutoTrayEnabledByUser != fNotifySetting)
        {
            tvo.fAutoTrayEnabledByUser = fNotifySetting;
            _UpdateNotifySetting(fNotifySetting);
        }
    }
        
    tvo.fShowQuickLaunch = ::IsDlgButtonChecked(hDlg, IDC_QUICKLAUNCH);

    c_tray.SetTrayViewOpts(&tvo);
    SendMessage(c_tray.GetTrayNotifyHWND(), TNM_HIDECLOCK, 0, tvo.fHideClock);

    c_tray.SizeWindows();

    // Update registry for locked taskbar
    DWORD dwEnableSizeMove = !::IsDlgButtonChecked(hDlg, IDC_LOCKTASKBAR);
    SHRegSetUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("TaskbarSizeMove"),
        REG_DWORD, &dwEnableSizeMove, sizeof(DWORD), SHREGSET_FORCE_HKCU);

    //Update registry for grouping behavior
    DWORD dwGlom = ::IsDlgButtonChecked(hDlg, IDC_GROUPITEMS);
    SHRegSetUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("TaskbarGlomming"),
        REG_DWORD, &dwGlom, sizeof(DWORD), SHREGSET_FORCE_HKCU);

    ::SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, NULL, (LPARAM)TEXT("TraySettings"), SMTO_NOTIMEOUTIFNOTHUNG, 1000, NULL);
}

void CTaskBarPropertySheet::_ApplyStartOptionsFromDialog(HWND hDlg)
{
    if (!SHRestricted(REST_NOSTARTPANEL))
    {
        //Get the current state of the check box
        BOOL fStartPanelOn = BOOLIFY(::IsDlgButtonChecked(hDlg, IDC_NEWSCHOOL));
        SHELLSTATE ss = {0};
        //See if Startpage is currently on or off.
        SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);
        //Check if the check box has been toggled
        if (fStartPanelOn != BOOLIFY(ss.fStartPanelOn))
        {
            // Toggle the setting
            ss.fStartPanelOn = fStartPanelOn;
            SHGetSetSettings(&ss, SSF_STARTPANELON, TRUE);

            //Tell the desktop window so it can add/remove the desktop icons
            ::PostMessage(v_hwndDesktop, DTM_STARTPAGEONOFF, 0, 0);
        }

        // Tell the Start Menu to rebuild itself now that we changed it
        // (This part is unconditional since the user may have merely
        // changed a setting with the Start Menu)
        ::PostMessage(v_hwndTray, SBM_REBUILDMENU, 0, 0);
    }
}

//---------------------------------------------------------------------------
void _TaskbarOptionsDestroyBitmaps(HWND hDlg)
{
    SetDlgItemBitmap(hDlg, IDC_TASKBARAPPEARANCE, 0);
    SetDlgItemBitmap(hDlg, IDC_NOTIFYAPPEARANCE, 0);
}

typedef struct
{
    int idc;
    int iAdd;
}
CONTROLBITMAP;

int _TaskbarPickBitmap(HWND hDlg, int iBmpBase, const CONTROLBITMAP* pca, int cca)
{
    for (int i = 0; i < cca; i++)
    {
        if (!IsDlgButtonChecked(hDlg, pca[i].idc))
        {
            iBmpBase += pca[i].iAdd;
        }
    }
    return iBmpBase;
}

void _TaskbarOptionsUpdateDisplay(HWND hDlg)
{
    static const CONTROLBITMAP c_caTaskbar[] =
    {
        { IDC_LOCKTASKBAR, 1 },
        { IDC_GROUPITEMS,  2 },
        { IDC_QUICKLAUNCH, 4 },
    };
    static const CONTROLBITMAP c_caNotify[] =
    {
        { IDC_TRAYOPTSHOWCLOCK, 1 },
        { IDC_NOTIFYMAN,        2 },
    };

    //
    // top preview
    //
    int iBmp;
    if (IsDlgButtonChecked(hDlg, IDC_TRAYOPTAUTOHIDE))
    {
        iBmp = IDB_TAAUTOHIDE;
    }
    else
    {
        iBmp = _TaskbarPickBitmap(hDlg, IDB_TAQLLOCKGROUP, c_caTaskbar, ARRAYSIZE(c_caTaskbar));
    }
    SetDlgItemBitmap(hDlg, IDC_TASKBARAPPEARANCE, iBmp);

    //
    // bottom preview
    //
    iBmp = _TaskbarPickBitmap(hDlg, IDB_NACLOCKCLEAN, c_caNotify, ARRAYSIZE(c_caNotify));
    SetDlgItemBitmap(hDlg, IDC_NOTIFYAPPEARANCE, iBmp);

    //
    // customize button
    //
    EnableWindow(GetDlgItem(hDlg, IDC_CUSTOMIZE), IsDlgButtonChecked(hDlg, IDC_NOTIFYMAN));
}


#define CX_PREVIEW  336
#define CY_PREVIEW  35

// need to do this by hand because dialog units to pixels will change,
// but the bitmaps won't
void _TaskbarOptionsSizeControls(HWND hDlg)
{
    static const int c_IDC[] =
    {
        IDC_TASKBARAPPEARANCE,
        IDC_NOTIFYAPPEARANCE
    };

    for (int i = 0; i < ARRAYSIZE(c_IDC); i++)
    {
        SetWindowPos(GetDlgItem(hDlg, c_IDC[i]), NULL, 0, 0, CX_PREVIEW, CY_PREVIEW,
                        SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOZORDER);
    }
}

typedef BOOL (* PFCFGSTART) (HWND, BOOL);

void CallAppWiz(HWND hDlg, BOOL bDelItems)
{
    HINSTANCE hmodWiz = LoadLibrary(TEXT("AppWiz.Cpl"));
    if (hmodWiz)
    {
        PFCFGSTART pfnCfgStart = (PFCFGSTART)GetProcAddress(hmodWiz, "ConfigStartMenu");
        if (pfnCfgStart)
        {
            pfnCfgStart(hDlg, bDelItems);
        }
        FreeLibrary(hmodWiz);
    }
}

BOOL ExecExplorerAtStartMenu(HWND hDlg)
{
    BOOL fRet = FALSE;

    TCHAR szFile[MAX_PATH];
    if (GetSystemWindowsDirectory(szFile, ARRAYSIZE(szFile)))
    {
        SHELLEXECUTEINFO ei = { 0 };

        StrCatBuff(szFile, TEXT("\\explorer.exe"), ARRAYSIZE(szFile));
        ei.lpFile = szFile;

        ei.cbSize = sizeof(ei);
        ei.hwnd = hDlg;

        TCHAR szParams[MAX_PATH + ARRAYSIZE(TEXT("/E,/Root,"))];
        if (IsUserAnAdmin())
        {
            lstrcpyn(szParams, TEXT("/E,"), ARRAYSIZE(szParams));
            SHGetSpecialFolderPath(hDlg, &(szParams[ARRAYSIZE(TEXT("/E,"))-1]),
                                    CSIDL_STARTMENU, FALSE);
        }
        else
        {
            lstrcpyn(szParams, TEXT("/E,/Root,"), ARRAYSIZE(szParams));
            SHGetSpecialFolderPath(hDlg, &(szParams[ARRAYSIZE(TEXT("/E,/Root,"))-1]),
                                    CSIDL_STARTMENU, FALSE);
        }

        ei.lpParameters = szParams;
        ei.nShow = SW_SHOWDEFAULT;
        ei.hInstApp = hinstCabinet;

        fRet = ShellExecuteEx(&ei);
    }
    return fRet;
}

const TCHAR *c_szRegMruKeysToDelete[] =
{
    TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs"),
    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU"),
    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Doc Find Spec MRU"),

    // New for Whistler (should've been in Windows 2000 and Millennium but we forgot)
    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Comdlg32\\OpenSaveMRU"),
    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Comdlg32\\LastVisitedMRU"),
};

void SetDocButton(HWND hDlg, int id)
{
    LPITEMIDLIST pidl;
    BOOL    bAreDocs = FALSE;

    HRESULT hr = SHGetSpecialFolderLocation(hDlg, CSIDL_RECENT, &pidl);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf = BindToFolder(pidl);
        if (psf)
        {
            IEnumIDList *penum;
            if (S_OK == psf->EnumObjects(hDlg, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penum))
            {
                unsigned long celt;
                LPITEMIDLIST pidlenum;
                if ((S_OK == penum->Next(1, &pidlenum, &celt)) && (celt == 1))
                {
                    ILFree(pidlenum);
                    bAreDocs = TRUE;
                }
                penum->Release();
            }
            psf->Release();
        }
        ILFree(pidl);
    }

    // Check other MRU registry keys
    if (!bAreDocs)
    {
        int  i;
        for (i = 0; i < ARRAYSIZE(c_szRegMruKeysToDelete); i++)
        {
            HKEY hkey;
            // ALL_ACCESS to delete c_szRegMruKeysToDelete.
            if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegMruKeysToDelete[i], 0L, KEY_ALL_ACCESS, &hkey) == ERROR_SUCCESS)
            {
                bAreDocs = TRUE;
                RegCloseKey(hkey);
            }
        }
    }
    
    Button_Enable(GetDlgItem(hDlg, id), bAreDocs);
}

void ClearRecentDocumentsAndMRUStuff(BOOL fBroadcastChange)
{
    int i;
    SHAddToRecentDocs(0, NULL);

    // Flush other MRUs in the registry for privacy
    for (i = 0; i < ARRAYSIZE(c_szRegMruKeysToDelete); i++)
    {
        SHDeleteKey(HKEY_CURRENT_USER, c_szRegMruKeysToDelete[i]);

        if (fBroadcastChange)
            SHSendMessageBroadcast(WM_SETTINGCHANGE, 0,
                        (LPARAM)c_szRegMruKeysToDelete[i]);
    }    
}

void HandleClearButtonClick(HWND hwndClear)
{
    HCURSOR hc = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ClearRecentDocumentsAndMRUStuff(TRUE);
    SetCursor(hc);

    //
    //  Before disabling the button, shove focus off it.
    //
    if (GetFocus() == hwndClear)
    {
        SendMessage(GetParent(hwndClear), WM_NEXTDLGCTL, 0, MAKELONG(FALSE, 0));
    }

    Button_Enable(hwndClear, FALSE);
}

void Reorder(HDPA hdpa)
{
    for (int i = DPA_GetPtrCount(hdpa) - 1; i >= 0; i--)
    {
        PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpa, i);
        poi->nOrder = i;
    }
}

void MenuOrderSort(HKEY hkeyRoot, IShellFolder* psf);

void MenuOrderSortKeyWithFolder(HKEY hkeyRoot, LPTSTR pszKey, IShellFolder* psf)
{
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyRoot, pszKey, 0, KEY_READ | KEY_WRITE, &hkey))
    {
        MenuOrderSort(hkey, psf);
        RegCloseKey(hkey);
    }
}

// Binds to the Key pszKey, under hkey root, using psf, and sorts the resultant order.
void MenuOrderSortSubKey(HKEY hkeyRoot, LPTSTR pszFolder, LPTSTR pszKey, IShellFolder* psf)
{
    LPITEMIDLIST pidl;
    DWORD cbEaten;
    DWORD dwAttrib;
    if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, pszFolder, &cbEaten, &pidl, &dwAttrib)))
    {
        IShellFolder* psfSub;
        if (SUCCEEDED(psf->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, &psfSub))))
        {
            MenuOrderSortKeyWithFolder(hkeyRoot, pszKey, psfSub);
            psfSub->Release();
        }
        ILFree(pidl);
    }
}


void MenuOrderSort(HKEY hkeyRoot, IShellFolder* psf)
{
    // Try to open Value Order
    IStream* pstm = SHOpenRegStream(hkeyRoot, TEXT(""), TEXT("Order"), STGM_READWRITE);
    if (pstm)
    {
        IOrderList2* pol2;
        if (SUCCEEDED(CoCreateInstance(CLSID_OrderListExport, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IOrderList2, &pol2))))
        {
            HDPA hdpa;
            if (SUCCEEDED(pol2->LoadFromStream(pstm, &hdpa, psf)))
            {
                // Since it's stored ordered by name, this should be no problem.
                Reorder(hdpa);

                // Set the seek pointer at the beginning.
                LARGE_INTEGER liZero = {0};
                pstm->Seek(liZero, STREAM_SEEK_SET, NULL);

                pol2->SaveToStream(pstm, hdpa);
                DPA_Destroy(hdpa);
            }
            pol2->Release();
        }
        pstm->Release();
    }

    // Now enumerate sub keys.

    TCHAR szKey[MAX_PATH];
    DWORD cbKey = ARRAYSIZE(szKey);
    int iIndex = 0;
    while (ERROR_SUCCESS == RegEnumKeyEx(hkeyRoot, iIndex, szKey, &cbKey, NULL, NULL, NULL, NULL))
    {
        MenuOrderSortSubKey(hkeyRoot, szKey, szKey, psf);
        iIndex++;
        cbKey = ARRAYSIZE(szKey);
    }
}

// Defined in Tray.c
IShellFolder* BindToFolder(LPCITEMIDLIST pidl);

void StartMenuSort()
{
    IShellFolder* psf = NULL;
    LPITEMIDLIST pidl;

    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_STARTMENU, &pidl);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl2;
        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_STARTMENU, &pidl2)))
        {
            IAugmentedShellFolder2* pasf;
            IShellFolder* psfCommon;
            IShellFolder* psfUser;
            HRESULT hres = CoCreateInstance(CLSID_MergedFolder, NULL, CLSCTX_INPROC_SERVER,
                                    IID_PPV_ARG(IAugmentedShellFolder2, &pasf));
            if (SUCCEEDED(hres))
            {
                psfUser = BindToFolder(pidl);
                if (psfUser)
                {
                    pasf->AddNameSpace(NULL, psfUser, pidl, ASFF_DEFAULT | ASFF_DEFNAMESPACE_ALL);
                    psfUser->Release();
                }

                psfCommon = BindToFolder(pidl2);

                if (psfCommon)
                {
                    pasf->AddNameSpace(NULL, psfCommon, pidl2, ASFF_DEFAULT);
                    psfCommon->Release();
                }

                hres = pasf->QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
                pasf->Release();
            }

            ILFree(pidl2);
        }
        else
        {
            psf = BindToFolder(pidl);
        }
        ILFree(pidl);                        
    }

    if (psf)
    {
        HKEY hkeyRoot;

        // Recursivly sort the orders. Should this be on another thread?
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, STRREG_STARTMENU,
            0, KEY_READ | KEY_WRITE, &hkeyRoot))
        {
            MenuOrderSort(hkeyRoot, psf);

            // Sort the My Documents menu item:
            LPITEMIDLIST pidlMyDocs;
            SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &pidlMyDocs);
            if (pidlMyDocs)
            {
                IShellFolder* psfMyDocs;
                if (SUCCEEDED(SHBindToObjectEx(NULL, pidlMyDocs, NULL, IID_PPV_ARG(IShellFolder, &psfMyDocs))))
                {
                    MenuOrderSortKeyWithFolder(hkeyRoot, TEXT("MyDocuments"), psfMyDocs);
                    psfMyDocs->Release();
                }
                ILFree(pidlMyDocs);
            }

            // What happens if the Filesystem programs is not equal to the hard coded string "Programs"? This
            // happens on German: Programme != Programs and we fail to sort. So let's verify:
            TCHAR szPath[MAX_PATH];
            SHGetFolderPath(NULL, CSIDL_PROGRAMS, NULL, 0, szPath);
            LPTSTR pszName = PathFindFileName(szPath);

            if (StrCmpI(pszName, TEXT("Programs")) != 0)
            {
                // Ok, It's not the same, so go bind to that sub tree and sort it.
                MenuOrderSortSubKey(hkeyRoot, pszName, TEXT("Programs"), psf);
            }
            RegCloseKey(hkeyRoot);
        }
        psf->Release();
    }
}

BOOL Advanced_OnInitDialog(HWND hwndDlg, SMADVANCED* pAdv)
{
    if (!pAdv || !pAdv->pTO)
    {
        EndDialog(hwndDlg, 0);
        return FALSE;   // no memory?
    }

    SetWindowPtr(hwndDlg, DWLP_USER, pAdv);

    // since the large icon setting is stored in the tray state, not as a standalone reg key, we need to have a temp reg key for the regtreeop to use...
    TRAYVIEWOPTS tvo;
    c_tray.GetTrayViewOpts(&tvo);
    BOOL fLargePrev = !tvo.fSMSmallIcons;
    SHSetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, REGSTR_VAL_LARGEICONSTEMP, REG_DWORD, (void*) &fLargePrev, sizeof(fLargePrev));

    pAdv->hwndTree = GetDlgItem( hwndDlg, IDC_STARTMENUSETTINGS );

    // HACKHACK - IRegTreeOptions is ANSI, so we temporarily turn off UNICODE
    #undef TEXT
    #define TEXT(s) s
    HRESULT hr = pAdv->pTO->InitTree(pAdv->hwndTree, HKEY_LOCAL_MACHINE, REGSTR_PATH_SMADVANCED "\\StartMenu", NULL);

    #undef TEXT
    #define TEXT(s) __TEXT(s)

    // find the first root and make sure that it is visible
    TreeView_EnsureVisible(pAdv->hwndTree, TreeView_GetRoot( pAdv->hwndTree ));

    SetDocButton(hwndDlg, IDC_KILLDOCUMENTS);

    return SUCCEEDED(hr);
}

void InitStartMenu_DoTreeHelp(SMADVANCED* pAdv, WPARAM wParam)
{
    TV_HITTESTINFO ht;

    GetCursorPos( &ht.pt );                         // get where we were hit

    if (pAdv->hwndTree == WindowFromPoint(ht.pt))
    {
        ScreenToClient( pAdv->hwndTree, &ht.pt );       // translate it to our window

        // retrieve the item hit
        pAdv->pTO->ShowHelp(TreeView_HitTest( pAdv->hwndTree, &ht),HELP_CONTEXTMENU);
    }
    else
    {
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(LPVOID)aInitStartMenuHelpIDs);
    }
}

BOOL_PTR CALLBACK AdvancedOptDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    SMADVANCED* pAdv = (SMADVANCED*)GetWindowPtr(hwndDlg, DWLP_USER);
    INSTRUMENT_WNDPROC(SHCNFI_INITSTARTMENU_DLGPROC, hwndDlg, msg, wParam, lParam);

    if (msg != WM_INITDIALOG && !pAdv)
    {
        // We've been re-entered after being destroyed.  Bail.
        return FALSE;
    }

    switch (msg) 
    {
    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDC_ADDSHORTCUT:
            CallAppWiz(hwndDlg, FALSE);
            break;

        case IDC_DELSHORTCUT:
            CallAppWiz(hwndDlg, TRUE);
            break;
            
        case IDC_RESORT:
        {
            SHChangeDWORDAsIDList dwidl;

            StartMenuSort();

            // Notify everyone that the order changed
            dwidl.cb      = sizeof(dwidl) - sizeof(dwidl.cbZero);
            dwidl.dwItem1 = SHCNEE_ORDERCHANGED;
            dwidl.dwItem2 = 0; 
            dwidl.cbZero  = 0;

            SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_FLUSH, (LPCITEMIDLIST)&dwidl, NULL);
            break;
        }
        
        case IDC_EXPLOREMENUS:
            ExecExplorerAtStartMenu(hwndDlg);
            break;

        case IDC_KILLDOCUMENTS:
            {
                HandleClearButtonClick(GET_WM_COMMAND_HWND(wParam, lParam));
            }
            break;

        case IDOK:
            {
                pAdv->pTO->WalkTree(WALK_TREE_SAVE);

                TRAYVIEWOPTS tvo;
                c_tray.GetTrayViewOpts(&tvo);
                BOOL fSmallPrev = tvo.fSMSmallIcons;
                // note that we are loading the classic setting for large icons here....
                BOOL fSmallNew = !SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, REGSTR_VAL_LARGEICONSTEMP, FALSE, TRUE /* default to large*/);
                if (fSmallPrev != fSmallNew)
                {
                    tvo.fSMSmallIcons = fSmallNew;
                    c_tray.SetTrayViewOpts(&tvo);
                    IMenuPopup_SetIconSize(c_tray.GetStartMenu(), fSmallNew ? BMICON_SMALL : BMICON_LARGE);
                }

                ::SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, NULL, (LPARAM)TEXT("TraySettings"), SMTO_NOTIMEOUTIFNOTHUNG, 1000, NULL);
            }
            // fall through

        case IDCANCEL:
            SHDeleteValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, REGSTR_VAL_LARGEICONSTEMP);
            EndDialog(hwndDlg, FALSE); // false to not enable parent's apply
            break;
        }
        break;

    case WM_INITDIALOG:
        return Advanced_OnInitDialog(hwndDlg, (SMADVANCED *)lParam);

    case WM_NOTIFY:
    {
        LPNMHDR pnm = (NMHDR *)lParam;
        SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, 0); // handled
        switch (pnm->code)
        {
            case TVN_KEYDOWN:
            {
                TV_KEYDOWN *pnmKeyDown = (TV_KEYDOWN*)((NMHDR *)lParam);
                if (pnmKeyDown->wVKey == VK_SPACE)
                {
                    pAdv->pTO->ToggleItem((HTREEITEM)SendMessage(pAdv->hwndTree, TVM_GETNEXTITEM, (WPARAM)TVGN_CARET, 0L));
                    SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0L);
                    SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, TRUE); // eat the key
                }
                break;
            }

            case NM_CLICK:
            case NM_DBLCLK:
                // is this click in our tree?
                if ( pnm->idFrom == IDC_STARTMENUSETTINGS )
                {
                    TV_HITTESTINFO ht;

                    DWORD dwPos = GetMessagePos();                  // get where we were hit
                    ht.pt.x = GET_X_LPARAM(dwPos);
                    ht.pt.y = GET_Y_LPARAM(dwPos);
                    ScreenToClient( pAdv->hwndTree, &ht.pt );       // translate it to our window

                    // retrieve the item hit
                    pAdv->pTO->ToggleItem(TreeView_HitTest( pAdv->hwndTree, &ht));
                    SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0L);
                }

                break;

            case NM_RCLICK:      // right mouse click
                if (pnm->hwndFrom == pAdv->hwndTree)
                {
                    InitStartMenu_DoTreeHelp(pAdv, (WPARAM)pnm->hwndFrom);
                    SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, TRUE); // eat the click
                    return TRUE;
                }
                break;
        }
        break;
    }

    case WM_HELP:                   // F1
    {
        LPHELPINFO phi = (LPHELPINFO)lParam;

        if (phi->iCtrlId != IDC_STARTMENUSETTINGS)
        {
            WinHelp( (HWND)(phi->hItemHandle), NULL,
                HELP_WM_HELP, (ULONG_PTR)(LPTSTR)aInitStartMenuHelpIDs);
        }
        else
        {
            HTREEITEM hItem;
            //Is this help invoked throught F1 key
            if (GetAsyncKeyState(VK_F1) < 0)
            {
                // Yes. WE need to give help for the currently selected item
                hItem = TreeView_GetSelection(pAdv->hwndTree);
            }
            else
            {
                //No, We need to give help for the item at the cursor position
                TV_HITTESTINFO ht;
                ht.pt = phi->MousePos;
                ScreenToClient(pAdv->hwndTree, &ht.pt); // Translate it to our window
                hItem = TreeView_HitTest(pAdv->hwndTree, &ht);
            }

            pAdv->pTO->ShowHelp(hItem, HELP_WM_HELP);
        }
        break;
    }

    case WM_CONTEXTMENU:        // right mouse click
    {
        InitStartMenu_DoTreeHelp(pAdv, wParam);
        break;
    }
        
    case WM_DESTROY:
        {
            pAdv->pTO->WalkTree(WALK_TREE_DELETE);
            ATOMICRELEASE(pAdv->pTO);

            // make sure we don't re-enter
            SetWindowPtr( hwndDlg, DWLP_USER, NULL );
        }
        break; // WM_DESTORY

    default:
        return FALSE;
    }

    return TRUE;
}

#define TPF_PAGEFLAGS   (TPF_STARTMENUPAGE | TPF_TASKBARPAGE)

void DoTaskBarProperties(HWND hwnd, DWORD dwFlags)
{
    ASSERT(((dwFlags & TPF_PAGEFLAGS) == TPF_STARTMENUPAGE) ||
            ((dwFlags & TPF_PAGEFLAGS) == TPF_TASKBARPAGE));

    UINT nStartPage = (dwFlags & TPF_TASKBARPAGE) ? 0 : 1;
    CTaskBarPropertySheet sheet(nStartPage, hwnd, dwFlags);

    sheet.DoModal(hwnd);
}

// Passing iResource=0 deletes the bitmap in the control

void SetDlgItemBitmap(HWND hDlg, int idStatic, int iResource)
{
    HBITMAP hbm;

    if (iResource)
    {
        hbm = (HBITMAP)LoadImage(hinstCabinet, MAKEINTRESOURCE(iResource), IMAGE_BITMAP, 0,0, LR_LOADMAP3DCOLORS);
    }
    else
    {
        hbm = NULL;
    }

    hbm = (HBITMAP)SendDlgItemMessage(hDlg, idStatic, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hbm);
    if (hbm)
        DeleteObject(hbm);

}

void SetDlgItemIcon(HWND hDlg, int idStatic, HICON hIcon)
{
    HICON hiOld = (HICON)SendDlgItemMessage(hDlg, idStatic, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
    if (hiOld)
        DestroyIcon(hiOld);
}

// REVIEW - use SHGetFileInfo?
void SetProgramIcon(HWND hDlg, int idLarge, int idSmall)
{
    HICON hIconLarge = NULL;
    HICON hIconSmall = NULL;
    LPITEMIDLIST pidlMyComp = ILCreateFromPath(TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}")); // CLSID_MyComputer;
    if (pidlMyComp)
    {
        IShellFolder *psfDesktop;
        if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
        {
            IExtractIcon *pxi;
            if (SUCCEEDED(psfDesktop->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&pidlMyComp, IID_PPV_ARG_NULL(IExtractIcon, &pxi))))
            {
                TCHAR szIconFile[MAX_PATH];
                int iIndex;
                UINT wFlags;
                if (S_OK == pxi->GetIconLocation(GIL_FORSHELL, szIconFile, ARRAYSIZE(szIconFile), &iIndex, &wFlags))
                {
                    pxi->Extract(szIconFile, iIndex, &hIconLarge, &hIconSmall, (GetSystemMetrics(SM_CXSMICON)<<16) | GetSystemMetrics(SM_CXICON));
                }
                pxi->Release();
            }
            psfDesktop->Release();
        }
        ILFree(pidlMyComp);
    }

    if (hIconLarge)
        SetDlgItemIcon(hDlg, idLarge, hIconLarge);
    if (hIconSmall)
        SetDlgItemIcon(hDlg, idSmall, hIconSmall);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\deskhost.cpp ===
#include "stdafx.h"
#include <startids.h>           // for IDM_PROGRAMS et al
#include "regstr.h"
#include "rcids.h"
#include <desktray.h>
#include "tray.h"
#include "startmnu.h"
#include "hostutil.h"
#include "deskhost.h"
#include "shdguid.h"

#define REGSTR_EXPLORER_ADVANCED REGSTR_PATH_EXPLORER TEXT("\\Advanced")

#define TF_DV2HOST  0
// #define TF_DV2HOST TF_CUSTOM1

#define TF_DV2DIALOG  0
// #define TF_DV2DIALOG TF_CUSTOM1

EXTERN_C HINSTANCE hinstCabinet;
HRESULT StartMenuHost_Create(IMenuPopup** ppmp, IMenuBand** ppmb);
void RegisterDesktopControlClasses();

const WCHAR c_wzStartMenuTheme[] = L"StartMenu";

//*****************************************************************

CPopupMenu::~CPopupMenu()
{
    IUnknown_SetSite(_pmp, NULL);
    ATOMICRELEASE(_pmp);
    ATOMICRELEASE(_pmb);
    ATOMICRELEASE(_psm);
}

HRESULT CPopupMenu::Popup(RECT *prcExclude, DWORD dwFlags)
{
    COMPILETIME_ASSERT(sizeof(RECT) == sizeof(RECTL));
    return _pmp->Popup((POINTL*)prcExclude, (RECTL*)prcExclude, dwFlags);
}


HRESULT CPopupMenu::Initialize(IShellMenu *psm, IUnknown *punkSite, HWND hwnd)
{
    HRESULT hr;

    // We should have been zero-initialized
    ASSERT(_pmp == NULL);
    ASSERT(_pmb == NULL);
    ASSERT(_psm == NULL);

    hr = CoCreateInstance(CLSID_MenuDeskBar, NULL, CLSCTX_INPROC_SERVER,
                          IID_PPV_ARG(IMenuPopup, &_pmp));
    if (SUCCEEDED(hr))
    {
        IUnknown_SetSite(_pmp, punkSite);

        IBandSite *pbs;
        hr = CoCreateInstance(CLSID_MenuBandSite, NULL, CLSCTX_INPROC_SERVER,
                              IID_PPV_ARG(IBandSite, &pbs));
        if (SUCCEEDED(hr))
        {
            hr = _pmp->SetClient(pbs);
            if (SUCCEEDED(hr))
            {
                IDeskBand *pdb;
                if (SUCCEEDED(psm->QueryInterface(IID_PPV_ARG(IDeskBand, &pdb))))
                {
                    hr = pbs->AddBand(pdb);
                    if (SUCCEEDED(hr))
                    {
                        DWORD dwBandID;
                        hr = pbs->EnumBands(0, &dwBandID);
                        if (SUCCEEDED(hr))
                        {
                            hr = pbs->GetBandObject(dwBandID, IID_PPV_ARG(IMenuBand, &_pmb));
                        }
                    }
                    pdb->Release();
                }
            }
            pbs->Release();
        }
    }

    if (SUCCEEDED(hr))
    {
        // Failure to set the theme is nonfatal
        IShellMenu2* psm2;
        if (SUCCEEDED(psm->QueryInterface(IID_PPV_ARG(IShellMenu2, &psm2))))
        {
            BOOL fThemed = IsAppThemed();
            psm2->SetTheme(fThemed ? c_wzStartMenuTheme : NULL);
            psm2->SetNoBorder(fThemed ? TRUE : FALSE);
            psm2->Release();
        }

        // Tell the popup that we are the window to parent UI on
        // This will fail on purpose so don't freak out
        psm->SetMenu(NULL, hwnd, 0);
    }

    if (SUCCEEDED(hr))
    {
        _psm = psm;
        psm->AddRef();
        hr = S_OK;
    }

    return hr;
}

HRESULT CPopupMenu_CreateInstance(IShellMenu *psm,
                                  IUnknown *punkSite,
                                  HWND hwnd,
                                  CPopupMenu **ppmOut)
{
    HRESULT hr;
    *ppmOut = NULL;
    CPopupMenu *ppm = new CPopupMenu();
    if (ppm)
    {
        hr = ppm->Initialize(psm, punkSite, hwnd);
        if (FAILED(hr))
        {
            ppm->Release();
        }
        else
        {
            *ppmOut = ppm;  // transfer ownership to called
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//*****************************************************************

const STARTPANELMETRICS g_spmDefault = {
    {380,440},
    {
        {WC_USERPANE,   0,                      SPP_USERPANE,      {380,  40}, NULL, NULL},
        {WC_SFTBARHOST, WS_TABSTOP | WS_CLIPCHILDREN,
                                                SPP_PROGLIST,      {190, 330}, NULL, NULL},
        {WC_MOREPROGRAMS, 0,                    SPP_MOREPROGRAMS,  {190,  30}, NULL, NULL},
        {WC_SFTBARHOST, WS_CLIPCHILDREN,        SPP_PLACESLIST,    {190, 360}, NULL, NULL},
        {WC_LOGOFF,     0,                      SPP_LOGOFF,        {380,  40}, NULL, NULL},
    }
};

HRESULT
CDesktopHost::Initialize()
{
    ASSERT(_hwnd == NULL);

    //
    //  Load some settings.
    //
    _fAutoCascade = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("Start_AutoCascade"), FALSE, TRUE);

    return S_OK;
}

HRESULT CDesktopHost::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CDesktopHost, IMenuPopup),
        QITABENT(CDesktopHost, IDeskBar),       // IMenuPopup derives from IDeskBar
        QITABENTMULTI(CDesktopHost, IOleWindow, IMenuPopup),  // IDeskBar derives from IOleWindow

        QITABENT(CDesktopHost, IMenuBand),
        QITABENT(CDesktopHost, IServiceProvider),
        QITABENT(CDesktopHost, IOleCommandTarget),
        QITABENT(CDesktopHost, IObjectWithSite),

        QITABENT(CDesktopHost, ITrayPriv),      // going away
        QITABENT(CDesktopHost, ITrayPriv2),     // going away
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CDesktopHost::SetSite(IUnknown *punkSite)
{
    CObjectWithSite::SetSite(punkSite);
    if (!_punkSite)
    {
        // This is our cue to break the recursive reference loop
        // The _ppmpPrograms contains multiple backreferences to
        // the CDesktopHost (we are its site, it also references
        // us via CDesktopShellMenuCallback...)
        ATOMICRELEASE(_ppmPrograms);
    }
    return S_OK;
}

CDesktopHost::~CDesktopHost()
{
    if (_hbmCachedSnapshot)
    {
        DeleteObject(_hbmCachedSnapshot);
    }

    ATOMICRELEASE(_ppmPrograms);
    ATOMICRELEASE(_ppmTracking);

    if (_hwnd)
    {
        ASSERT(GetWindowThreadProcessId(_hwnd, NULL) == GetCurrentThreadId());
        DestroyWindow(_hwnd);
    }
    ATOMICRELEASE(_ptFader);

}

BOOL CDesktopHost::Register()
{
    _wmDragCancel = RegisterWindowMessage(TEXT("CMBDragCancel"));

    WNDCLASSEX  wndclass;

    wndclass.cbSize         = sizeof(wndclass);
    wndclass.style          = CS_DROPSHADOW;
    wndclass.lpfnWndProc    = WndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 0;
    wndclass.hInstance      = hinstCabinet;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = GetStockBrush(HOLLOW_BRUSH);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = WC_DV2;
    wndclass.hIconSm        = NULL;
    
    return (0 != RegisterClassEx(&wndclass));
}

inline int _ClipCoord(int x, int xMin, int xMax)
{
    if (x < xMin) x = xMin;
    if (x > xMax) x = xMax;
    return x;
}

//
//  Everybody conspires against us.
//
//  CTray does not pass us any MPPF_POS_MASK flags to tell us where we
//  need to pop up relative to the point, so there's no point looking
//  at the dwFlags parameter.  Which is for the better, I guess, because
//  the MPPF_* flags are not the same as the TPM_* flags.  Go figure.
//
//  And then the designers decided that the Start Menu should pop up
//  in a location different from the location that the standard
//  TrackPopupMenuEx function chooses, so we need a custom positioning
//  algorithm anyway.
//
//  And finally, the AnimateWindow function takes AW_* flags, which are
//  not the same as TPM_*ANIMATE flags.  Go figure.  But since we gave up
//  on trying to map IMenuPopup::Popup to TrackPopupMenuEx anyway, we
//  don't have to do any translation here anyway.
//
//  Returns animation direction.
//
void CDesktopHost::_ChoosePopupPosition(POINT *ppt, LPCRECT prcExclude, LPRECT prcWindow)
{
    //
    // Calculate the monitor BEFORE we adjust the point.  Otherwise, we might
    // move the point offscreen.  In which case, we will end up pinning the
    // popup to the primary display, which is wron_
    //
    HMONITOR hmon = MonitorFromPoint(*ppt, MONITOR_DEFAULTTONEAREST);
    MONITORINFO minfo;
    minfo.cbSize = sizeof(minfo);
    GetMonitorInfo(hmon, &minfo);

    // Clip the exclude rectangle to the monitor

    RECT rcExclude;
    if (prcExclude)
    {
        // We can't use IntersectRect because it turns the rectangle
        // into (0,0,0,0) if the intersection is empty (which can happen if
        // the taskbar is autohide) but we want to glue it to the nearest
        // valid edge.
        rcExclude.left   = _ClipCoord(prcExclude->left,   minfo.rcMonitor.left, minfo.rcMonitor.right);
        rcExclude.right  = _ClipCoord(prcExclude->right,  minfo.rcMonitor.left, minfo.rcMonitor.right);
        rcExclude.top    = _ClipCoord(prcExclude->top,    minfo.rcMonitor.top, minfo.rcMonitor.bottom);
        rcExclude.bottom = _ClipCoord(prcExclude->bottom, minfo.rcMonitor.top, minfo.rcMonitor.bottom);
    }
    else
    {
        rcExclude.left = rcExclude.right = ppt->x;
        rcExclude.top = rcExclude.bottom = ppt->y;
    }

    _ComputeActualSize(&minfo, &rcExclude);

    // initialize the height and width from what the layout asked for
    int cy=RECTHEIGHT(_rcActual);
    int cx=RECTWIDTH(_rcActual);

    ASSERT(cx && cy); // we're in trouble if these are zero
    
    int x, y;

    //
    //  First: Determine whether we are going to pop upwards or downwards.
    //

    BOOL fSide = FALSE;

    if (rcExclude.top - cy >= minfo.rcMonitor.top)
    {
        // There is room above.
        y = rcExclude.top - cy;
    }
    else if (rcExclude.bottom - cy >= minfo.rcMonitor.top)
    {
        // There is room above if we slide to the side.
        y = rcExclude.bottom - cy;
        fSide = TRUE;
    }
    else if (rcExclude.bottom + cy <= minfo.rcMonitor.bottom)
    {
        // There is room below.
        y = rcExclude.bottom;
    }
    else if (rcExclude.top + cy <= minfo.rcMonitor.bottom)
    {
        // There is room below if we slide to the side.
        y = rcExclude.top;
        fSide = TRUE;
    }
    else
    {
        // We don't fit anywhere.  Pin to the appropriate edge of the screen.
        // And we have to go to the side, too.
        fSide = TRUE;

        if (rcExclude.top - minfo.rcMonitor.top < minfo.rcMonitor.bottom - rcExclude.bottom)
        {
            // Start button at top of screen; pin to top
            y = minfo.rcMonitor.top;
        }
        else
        {
            // Start button at bottom of screen; pin to bottom
            y = minfo.rcMonitor.bottom - cy;
        }
    }

    //
    //  Now choose whether we will pop left or right.  Try right first.
    //

    x = fSide ? rcExclude.right : rcExclude.left;
    if (x + cx > minfo.rcMonitor.right)
    {
        // Doesn't fit to the right; pin to the right edge.
        // Notice that we do *not* try to pop left.  For some reason,
        // the start menu never pops left.

        x = minfo.rcMonitor.right - cx;
    }

    SetRect(prcWindow, x, y, x+cx, y+cy);
}

int GetDesiredHeight(HWND hwndHost, SMPANEDATA *psmpd)
{
    SMNGETMINSIZE nmgms = {0};
    nmgms.hdr.hwndFrom = hwndHost;
    nmgms.hdr.code = SMN_GETMINSIZE;
    nmgms.siz = psmpd->size;

    SendMessage(psmpd->hwnd, WM_NOTIFY, nmgms.hdr.idFrom, (LPARAM)&nmgms);

    return nmgms.siz.cy;
}

//
// Query each item to see if it has any size requirements.
// Position all the items at their final locations.
//
void CDesktopHost::_ComputeActualSize(MONITORINFO *pminfo, LPCRECT prcExclude)
{
    // Compute the maximum permissible space above/below the Start Menu.
    // Designers don't want the Start Menu to slide horizontally; it must
    // fit entirely above or below.

    int cxMax = RECTWIDTH(pminfo->rcWork);
    int cyMax = max(prcExclude->top - pminfo->rcMonitor.top,
                    pminfo->rcMonitor.bottom - prcExclude->bottom);

    // Start at the minimum size and grow as necesary
    _rcActual = _rcDesired;

    // Ask the windows if they wants any adjustments
    int iMFUHeight = GetDesiredHeight(_hwnd, &_spm.panes[SMPANETYPE_MFU]);
    int iPlacesHeight = GetDesiredHeight(_hwnd, &_spm.panes[SMPANETYPE_PLACES]);
    int iMoreProgHeight = _spm.panes[SMPANETYPE_MOREPROG].size.cy;

    // Figure out the maximum size for each pane
    int cyPlacesMax = cyMax - (_spm.panes[SMPANETYPE_USER].size.cy + _spm.panes[SMPANETYPE_LOGOFF].size.cy);
    int cyMFUMax    = cyPlacesMax - _spm.panes[SMPANETYPE_MOREPROG].size.cy;


    TraceMsg(TF_DV2HOST, "MFU Desired Height=%d(cur=%d,max=%d), Places Desired Height=%d(cur=%d,max=%d)",
        iMFUHeight, _spm.panes[SMPANETYPE_MFU].size.cy, cyMFUMax, 
        iPlacesHeight, _spm.panes[SMPANETYPE_PLACES].size.cy, cyPlacesMax);

    // Clip each pane to its max - the smaller of (The largest possible or The largest we want to be)
    _fClipped = FALSE;
    if (iMFUHeight > cyMFUMax)
    {
        iMFUHeight = cyMFUMax;
        _fClipped = TRUE;
    }

    if (iPlacesHeight > cyPlacesMax)
    {
        iPlacesHeight = cyPlacesMax;
        _fClipped = TRUE;
    }

    // ensure that places == mfu + moreprog by growing the smaller of the two.
    if (iPlacesHeight > iMFUHeight + iMoreProgHeight)
        iMFUHeight = iPlacesHeight - iMoreProgHeight;
    else
        iPlacesHeight = iMFUHeight + iMoreProgHeight;

    //
    // move the actual windows
    // See diagram of layout in deskhost.h for the hardcoded assumptions here.
    //  this could be made more flexible/variable, but we want to lock in this layout
    //

    // helper variables...
    DWORD dwUserBottomEdge = _spm.panes[SMPANETYPE_USER].size.cy;
    DWORD dwMFURightEdge =   _spm.panes[SMPANETYPE_MFU].size.cx;
    DWORD dwMFUBottomEdge =  dwUserBottomEdge + iMFUHeight;
    DWORD dwMoreProgBottomEdge = dwMFUBottomEdge + iMoreProgHeight;

    // set the size of the overall pane
    _rcActual.right = _spm.panes[SMPANETYPE_USER].size.cx;
    _rcActual.bottom = dwMoreProgBottomEdge + _spm.panes[SMPANETYPE_LOGOFF].size.cy;

    HDWP hdwp = BeginDeferWindowPos(5);
    const DWORD dwSWPFlags = SWP_NOACTIVATE | SWP_NOZORDER;
    DeferWindowPos(hdwp, _spm.panes[SMPANETYPE_USER].hwnd, NULL,    0, 0, _rcActual.right, dwUserBottomEdge, dwSWPFlags);
    DeferWindowPos(hdwp, _spm.panes[SMPANETYPE_MFU].hwnd, NULL,     0, dwUserBottomEdge, dwMFURightEdge, iMFUHeight, dwSWPFlags);
    DeferWindowPos(hdwp, _spm.panes[SMPANETYPE_MOREPROG].hwnd, NULL,0, dwMFUBottomEdge, dwMFURightEdge, iMoreProgHeight, dwSWPFlags);
    DeferWindowPos(hdwp, _spm.panes[SMPANETYPE_PLACES].hwnd, NULL,  dwMFURightEdge, dwUserBottomEdge, _rcActual.right-dwMFURightEdge, iPlacesHeight, dwSWPFlags);
    DeferWindowPos(hdwp, _spm.panes[SMPANETYPE_LOGOFF].hwnd, NULL,  0, dwMoreProgBottomEdge, _rcActual.right, _spm.panes[SMPANETYPE_LOGOFF].size.cy, dwSWPFlags);
    EndDeferWindowPos(hdwp);
}

HWND CDesktopHost::_Create()
{
    TCHAR szTitle[MAX_PATH];

    LoadString(hinstCabinet, IDS_STARTMENU, szTitle, MAX_PATH);

    Register();

    // Must load metrics early to determine whether we are themed or not
    LoadPanelMetrics();

    DWORD dwExStyle = WS_EX_TOOLWINDOW | WS_EX_TOPMOST;
    if (IS_BIDI_LOCALIZED_SYSTEM())
    {
        dwExStyle |= WS_EX_LAYOUTRTL;
    }

    DWORD dwStyle = WS_POPUP | WS_CLIPSIBLINGS | WS_CLIPCHILDREN;  // We will make it visible as part of animation
    if (!_hTheme)
    {
        // Normally the theme provides the border effects, but if there is
        // no theme then we have to do it ourselves.
        dwStyle |= WS_DLGFRAME;
    }

    _hwnd = CreateWindowEx(
        dwExStyle,
        WC_DV2,
        szTitle,
        dwStyle,
        0, 0,
        0, 0,
        v_hwndTray,
        NULL,
        hinstCabinet,
        this);

    v_hwndStartPane = _hwnd;

    return _hwnd;
}

void CDesktopHost::_ReapplyRegion()
{
    SMNMAPPLYREGION ar;

    // If we fail to create a rectangular region, then remove the region
    // entirely so we don't carry the old (bad) region around.
    // Yes it means you get ugly black corners, but it's better than
    // clipping away huge chunks of the Start Menu!

    ar.hrgn = CreateRectRgn(0, 0, _sizWindowPrev.cx, _sizWindowPrev.cy);
    if (ar.hrgn)
    {
        // Let all the clients take a bite out of it
        ar.hdr.hwndFrom = _hwnd;
        ar.hdr.idFrom = 0;
        ar.hdr.code = SMN_APPLYREGION;

        SHPropagateMessage(_hwnd, WM_NOTIFY, 0, (LPARAM)&ar, SPM_SEND | SPM_ONELEVEL);
    }

    if (!SetWindowRgn(_hwnd, ar.hrgn, FALSE))
    {
        // SetWindowRgn takes ownership on success
        // On failure we need to free it ourselves
        if (ar.hrgn)
        {
            DeleteObject(ar.hrgn);
        }
    }
}


//
//  We need to use PrintWindow because WM_PRINT messes up RTL.
//  PrintWindow requires that the window be visible.
//  Making the window visible causes the shadow to appear.
//  We don't want the shadow to appear until we are ready.
//  So we have to do a lot of goofy style mangling to suppress the
//  shadow until we're ready.
//
BOOL ShowCachedWindow(HWND hwnd, SIZE sizWindow, HBITMAP hbmpSnapshot, BOOL fRepaint)
{
    BOOL fSuccess = FALSE;
    if (hbmpSnapshot)
    {
        // Turn off the shadow so it won't get triggered by our SetWindowPos
        DWORD dwClassStylePrev = GetClassLong(hwnd, GCL_STYLE);
        SetClassLong(hwnd, GCL_STYLE, dwClassStylePrev & ~CS_DROPSHADOW);

        // Show the window and tell it not to repaint; we'll do that
        SetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER |
                     SWP_NOREDRAW | SWP_SHOWWINDOW);

        // Turn the shadow back on
        SetClassLong(hwnd, GCL_STYLE, dwClassStylePrev);

        // Disable WS_CLIPCHILDREN because we need to draw over the kids for our BLT
        DWORD dwStylePrev = SHSetWindowBits(hwnd, GWL_STYLE, WS_CLIPCHILDREN, 0);

        HDC hdcWindow = GetDCEx(hwnd, NULL, DCX_WINDOW | DCX_CACHE);
        if (hdcWindow)
        {
            HDC hdcMem = CreateCompatibleDC(hdcWindow);
            if (hdcMem)
            {
                HBITMAP hbmPrev = (HBITMAP)SelectObject(hdcMem, hbmpSnapshot);

                // PrintWindow only if fRepaint says it's necessary
                if (!fRepaint || PrintWindow(hwnd, hdcMem, 0))
                {
                    // Do this horrible dance because sometimes GDI takes a long
                    // time to do a BitBlt so you end up seeing the shadow for
                    // a half second before the bits show up.
                    //
                    // So show the bits first, then show the shadow.

                    if (BitBlt(hdcWindow, 0, 0, sizWindow.cx, sizWindow.cy, hdcMem, 0, 0, SRCCOPY))
                    {
                        // Tell USER to attach the shadow
                        // Do this by hiding the window and then showing it
                        // again, but do it in this goofy way to avoid flicker.
                        // (If we used ShowWindow(SW_HIDE), then the window
                        // underneath us would repaint pointlessly.)

                        SHSetWindowBits(hwnd, GWL_STYLE, WS_VISIBLE, 0);
                        SetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER |
                                     SWP_NOREDRAW | SWP_SHOWWINDOW);

                        // Validate the window now that we've drawn it
                        RedrawWindow(hwnd, NULL, NULL, RDW_NOERASE | RDW_NOFRAME |
                                     RDW_NOINTERNALPAINT | RDW_VALIDATE);
                        fSuccess = TRUE;
                    }
                }

                SelectObject(hdcMem, hbmPrev);
                DeleteDC(hdcMem);
            }
            ReleaseDC(hwnd, hdcWindow);
        }

        SetWindowLong(hwnd, GWL_STYLE, dwStylePrev);
    }

    if (!fSuccess)
    {
        // re-hide the window so USER knows it's all invalid again
        ShowWindow(hwnd, SW_HIDE);
    }
    return fSuccess;
}




BOOL CDesktopHost::_TryShowBuffered()
{
    BOOL fSuccess = FALSE;
    BOOL fRepaint = FALSE;

    if (!_hbmCachedSnapshot)
    {
        HDC hdcWindow = GetDCEx(_hwnd, NULL, DCX_WINDOW | DCX_CACHE);
        if (hdcWindow)
        {
            _hbmCachedSnapshot = CreateCompatibleBitmap(hdcWindow, _sizWindowPrev.cx, _sizWindowPrev.cy);
            fRepaint = TRUE;
            ReleaseDC(_hwnd, hdcWindow);
        }
    }
    if (_hbmCachedSnapshot)
    {
        fSuccess = ShowCachedWindow(_hwnd, _sizWindowPrev, _hbmCachedSnapshot, fRepaint);
        if (!fSuccess)
        {
            DeleteObject(_hbmCachedSnapshot);
            _hbmCachedSnapshot = NULL;
        }
    }
    return fSuccess;
}

LRESULT CDesktopHost::OnNeedRepaint()
{
    if (_hwnd && _hbmCachedSnapshot)
    {
        // This will force a repaint the next time the window is shown
        DeleteObject(_hbmCachedSnapshot);
        _hbmCachedSnapshot = NULL;
    }
    return 0;
}

HRESULT CDesktopHost::_Popup(POINT *ppt, RECT *prcExclude, DWORD dwFlags)
{
    if (_hwnd)
    {
        RECT rcWindow;
        _ChoosePopupPosition(ppt, prcExclude, &rcWindow);
        SIZE sizWindow = { RECTWIDTH(rcWindow), RECTHEIGHT(rcWindow) };

        MoveWindow(_hwnd, rcWindow.left, rcWindow.top,
                          sizWindow.cx, sizWindow.cy, TRUE);

        if (sizWindow.cx != _sizWindowPrev.cx ||
            sizWindow.cy != _sizWindowPrev.cy)
        {
            _sizWindowPrev = sizWindow;
            _ReapplyRegion();
            // We need to repaint since our size has changed
            OnNeedRepaint();
        }

        // If the user toggles the tray between topmost and nontopmost
        // our own topmostness can get messed up, so re-assert it here.
        SetWindowZorder(_hwnd, HWND_TOPMOST);

        if (GetSystemMetrics(SM_REMOTESESSION) || GetSystemMetrics(SM_REMOTECONTROL))
        {
            // If running remotely, then don't cache the Start Menu
            // or double-buffer.  Show the keyboard cues accurately
            // from the start (to avoid flicker).

            SendMessage(_hwnd, WM_CHANGEUISTATE, UIS_INITIALIZE, 0);
            if (dwFlags & MPPF_KEYBOARD)
            {
                _EnableKeyboardCues();
            }
            ShowWindow(_hwnd, SW_SHOW);
        }
        else
        {
            // If running locally, then force keyboard cues off so our
            // cached bitmap won't have underlines.  Then draw the
            // Start Menu, then turn on keyboard cues if necessary.

            SendMessage(_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_SET, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);

            if (!_TryShowBuffered())
            {
                ShowWindow(_hwnd, SW_SHOW);
            }

            if (dwFlags & MPPF_KEYBOARD)
            {
                _EnableKeyboardCues();
            }
        }

        NotifyWinEvent(EVENT_SYSTEM_MENUPOPUPSTART, _hwnd, OBJID_CLIENT, CHILDID_SELF);

        // Tell tray that the start pane is active, so it knows to eat
        // mouse clicks on the Start Button.
        Tray_SetStartPaneActive(TRUE);

        _fOpen = TRUE;
        _fMenuBlocked = FALSE;
        _fMouseEntered = FALSE;
        _fOfferedNewApps = FALSE;

        _MaybeOfferNewApps();
        _MaybeShowClipBalloon();

        // Tell all our child windows it's time to maybe revalidate
        NMHDR nm = { _hwnd, 0, SMN_POSTPOPUP };
        SHPropagateMessage(_hwnd, WM_NOTIFY, 0, (LPARAM)&nm, SPM_SEND | SPM_ONELEVEL);

        ExplorerPlaySound(TEXT("MenuPopup"));


        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

HRESULT CDesktopHost::Popup(POINTL *pptl, RECTL *prclExclude, DWORD dwFlags)
{
    COMPILETIME_ASSERT(sizeof(POINTL) == sizeof(POINT));
    POINT *ppt = reinterpret_cast<POINT*>(pptl);

    COMPILETIME_ASSERT(sizeof(RECTL) == sizeof(RECT));
    RECT *prcExclude = reinterpret_cast<RECT*>(prclExclude);

    if (_hwnd == NULL)
    {
        _hwnd = _Create();
    }

    return _Popup(ppt, prcExclude, dwFlags);
}

LRESULT CDesktopHost::OnHaveNewItems(NMHDR *pnm)
{
    PSMNMHAVENEWITEMS phni = (PSMNMHAVENEWITEMS)pnm;

    _hwndNewHandler = pnm->hwndFrom;

    // We have a new "new app" list, so tell the cached Programs menu
    // its cache is no longer valid and it should re-query us
    // so we can color the new apps appropriately.

    if (_ppmPrograms)
    {
        _ppmPrograms->Invalidate();
    }

    //
    //  Were any apps in the list installed since the last time the
    //  user acknowledged a new app?
    //

    FILETIME ftBalloon = { 0, 0 };      // assume never
    DWORD dwSize = sizeof(ftBalloon);

    SHRegGetUSValue(DV2_REGPATH, DV2_NEWAPP_BALLOON_TIME, NULL,
                    &ftBalloon, &dwSize, FALSE, NULL, 0);

    if (CompareFileTime(&ftBalloon, &phni->ftNewestApp) < 0)
    {
        _iOfferNewApps = NEWAPP_OFFER_COUNT;
        _MaybeOfferNewApps();
    }

    return 1;
}

void CDesktopHost::_MaybeOfferNewApps()
{
    // Display the balloon tip only once per pop-open,
    // and only if there are new apps to offer
    // and only if we're actually visible
    if (_fOfferedNewApps || !_iOfferNewApps || !IsWindowVisible(_hwnd) || 
        !SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, REGSTR_VAL_DV2_NOTIFYNEW, FALSE, TRUE))
    {
        return;
    }

    _fOfferedNewApps = TRUE;
    _iOfferNewApps--;

    SMNMBOOL nmb = { { _hwnd, 0, SMN_SHOWNEWAPPSTIP }, TRUE };
    SHPropagateMessage(_hwnd, WM_NOTIFY, 0, (LPARAM)&nmb, SPM_SEND | SPM_ONELEVEL);
}

void CDesktopHost::OnSeenNewItems()
{
    _iOfferNewApps = 0; // Do not offer More Programs balloon tip again

    // Remember the time the user acknowledged the balloon so we only
    // offer the balloon if there is an app installed after this point.

    FILETIME ftNow;
    GetSystemTimeAsFileTime(&ftNow);
    SHRegSetUSValue(DV2_REGPATH, DV2_NEWAPP_BALLOON_TIME, REG_BINARY,
                    &ftNow, sizeof(ftNow), SHREGSET_FORCE_HKCU);
}


void CDesktopHost::_MaybeShowClipBalloon()
{
    if (_fClipped && !_fWarnedClipped)
    {
        _fWarnedClipped = TRUE;

        RECT rc;
        GetWindowRect(_spm.panes[SMPANETYPE_MFU].hwnd, &rc);    // show the clipped ballon pointing to the bottom of the MFU

        _hwndClipBalloon = CreateBalloonTip(_hwnd,
                                            (rc.right+rc.left)/2, rc.bottom,
                                            NULL,
                                            IDS_STARTPANE_CLIPPED_TITLE,
                                            IDS_STARTPANE_CLIPPED_TEXT);
        if (_hwndClipBalloon)
        {
            SetProp(_hwndClipBalloon, PROP_DV2_BALLOONTIP, DV2_BALLOONTIP_CLIP);
        }
    }
}

void CDesktopHost::OnContextMenu(LPARAM lParam)
{
    if (!IsRestrictedOrUserSetting(HKEY_CURRENT_USER, REST_NOTRAYCONTEXTMENU, TEXT("Advanced"), TEXT("TaskbarContextMenu"), ROUS_KEYALLOWS | ROUS_DEFAULTALLOW))
    {
        HMENU hmenu = SHLoadMenuPopup(hinstCabinet, MENU_STARTPANECONTEXT);
        if (hmenu)
        {
            POINT pt;
            if (IS_WM_CONTEXTMENU_KEYBOARD(lParam))
            {
                pt.x = pt.y = 0;
                MapWindowPoints(_hwnd, HWND_DESKTOP, &pt, 1);
            }
            else
            {
                pt.x = GET_X_LPARAM(lParam);
                pt.y = GET_Y_LPARAM(lParam);
            }

            int idCmd = TrackPopupMenuEx(hmenu, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                                         pt.x, pt.y, _hwnd, NULL);
            if (idCmd == IDSYSPOPUP_STARTMENUPROP)
            {
                DesktopHost_Dismiss(_hwnd);
                Tray_DoProperties(TPF_STARTMENUPAGE);
            }
            DestroyMenu(hmenu);
        }
    }
}

BOOL CDesktopHost::_ShouldIgnoreFocusChange(HWND hwndFocusRecipient)
{
    // Ignore focus changes when a popup menu is up
    if (_ppmTracking)
    {
        return TRUE;
    }

    // If a focus change from a special balloon, this means that the
    // user is clicking a tooltip.  So dismiss the ballon and not the Start Menu.
    HANDLE hProp = GetProp(hwndFocusRecipient, PROP_DV2_BALLOONTIP);
    if (hProp)
    {
        SendMessage(hwndFocusRecipient, TTM_POP, 0, 0);
        if (hProp == DV2_BALLOONTIP_MOREPROG)
        {
            OnSeenNewItems();
        }
        return TRUE;
    }

    // Otherwise, dismiss ourselves
    return FALSE;

}

HRESULT CDesktopHost::TranslatePopupMenuMessage(MSG *pmsg, LRESULT *plres)
{
    BOOL fDismissOnlyPopup = FALSE;

    // If the user drags an item off of a popup menu, the popup menu
    // will autodismiss itself.  If the user is over our window, then
    // we only want it to dismiss up to our level.

    // (under low memory conditions, _wmDragCancel might be WM_NULL)
    if (pmsg->message == _wmDragCancel && pmsg->message != WM_NULL)
    {
        RECT rc;
        POINT pt;
        if (GetWindowRect(_hwnd, &rc) &&
            GetCursorPos(&pt) &&
            PtInRect(&rc, pt))
        {
            fDismissOnlyPopup = TRUE;
        }
    }

    if (fDismissOnlyPopup)
        _fDismissOnlyPopup++;

    HRESULT hr = _ppmTracking->TranslateMenuMessage(pmsg, plres);

    if (fDismissOnlyPopup)
        _fDismissOnlyPopup--;

    return hr;
}

LRESULT CALLBACK CDesktopHost::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDesktopHost *pdh = (CDesktopHost *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    LPCREATESTRUCT pcs;

    if (pdh && pdh->_ppmTracking)
    {
        MSG msg = { hwnd, uMsg, wParam, lParam };
        LRESULT lres;
        if (pdh->TranslatePopupMenuMessage(&msg, &lres) == S_OK)
        {
            return lres;
        }
        wParam = msg.wParam;
        lParam = msg.lParam;
    }

    switch(uMsg)
    {
    case WM_NCCREATE:
        pcs = (LPCREATESTRUCT)lParam;
        pdh = (CDesktopHost *)pcs->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pdh);
        break;
        
    case WM_CREATE:
        pdh->OnCreate(hwnd);
        break;

    case WM_ACTIVATEAPP:
        if (!wParam)
        {
            DesktopHost_Dismiss(hwnd);
        }
        break;

    case WM_ACTIVATE:
        if (pdh)
        {
            if (LOWORD(wParam) == WA_INACTIVE)
            {
                pdh->_SaveChildFocus();
                HWND hwndAncestor = GetAncestor((HWND) lParam, GA_ROOTOWNER);
                if (hwnd != hwndAncestor &&
                    !(hwndAncestor == v_hwndTray && pdh->_ShouldIgnoreFocusChange((HWND)lParam)) &&
                    !pdh->_ppmTracking)
                    // Losing focus to somebody unrelated to us = dismiss
                {
#ifdef FULL_DEBUG
                    if (! (GetAsyncKeyState(VK_SHIFT) <0) )
#endif
                        DesktopHost_Dismiss(hwnd);
                }
            }
            else
            {
                pdh->_RestoreChildFocus();
            }
        }
        break;
        
    case WM_DESTROY:
        pdh->OnDestroy();
        break;
        
    case WM_SHOWWINDOW:
        /*
         *  If hiding the window, save the focus for restoration later.
         */
        if (!wParam)
        {
            pdh->_SaveChildFocus();
        }
        break;

    case WM_SETFOCUS:
        pdh->OnSetFocus((HWND)wParam);
        break;

    case WM_ERASEBKGND:
        pdh->OnPaint((HDC)wParam, TRUE);
        return TRUE;

#if 0
    // currently, the host doesn't do anything on WM_PAINT
    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC         hdc;

            if(hdc = BeginPaint(hwnd, &ps))
            {
                pdh->OnPaint(hdc, FALSE);
                EndPaint(hwnd, &ps);
            }
        }

        break;
#endif

    case WM_NOTIFY:
        {
            LPNMHDR pnm = (LPNMHDR)lParam;
            switch (pnm->code)
            {
            case SMN_HAVENEWITEMS:
                return pdh->OnHaveNewItems(pnm);
            case SMN_COMMANDINVOKED:
                return pdh->OnCommandInvoked(pnm);
            case SMN_FILTEROPTIONS:
                return pdh->OnFilterOptions(pnm);

            case SMN_NEEDREPAINT:
                return pdh->OnNeedRepaint();

            case SMN_TRACKSHELLMENU:
                pdh->OnTrackShellMenu(pnm);
                return 0;

            case SMN_BLOCKMENUMODE:
                pdh->_fMenuBlocked = ((SMNMBOOL*)pnm)->f;
                break;
            case SMN_SEENNEWITEMS:
                pdh->OnSeenNewItems();
                break;

            case SMN_CANCELSHELLMENU:
                pdh->_DismissTrackShellMenu();
                break;
            }
        }
        break;

    case WM_CONTEXTMENU:
        pdh->OnContextMenu(lParam);
        return 0;                   // do not bubble up

    case WM_SETTINGCHANGE:
        if ((wParam == SPI_ICONVERTICALSPACING) ||
            ((wParam == 0) && (lParam != 0) && (StrCmpIC((LPCTSTR)lParam, TEXT("Policy")) == 0)))
        {
            // A change in icon vertical spacing is how the themes control
            // panel tells us that it changed the Large Icons setting (!)
            ::PostMessage(v_hwndTray, SBM_REBUILDMENU, 0, 0);
        }

        // Toss our cached bitmap because the user may have changed something
        // that affects our appearance (e.g., toggled keyboard cues)
        pdh->OnNeedRepaint();

        SHPropagateMessage(hwnd, uMsg, wParam, lParam, SPM_SEND | SPM_ONELEVEL); // forward to kids
        break;


    case WM_DISPLAYCHANGE:
    case WM_SYSCOLORCHANGE:
        // Toss our cached bitmap because these settings may affect our
        // appearance (e.g., color changes)
        pdh->OnNeedRepaint();

        SHPropagateMessage(hwnd, uMsg, wParam, lParam, SPM_SEND | SPM_ONELEVEL); // forward to kids
        break;

    case WM_TIMER:
        switch (wParam)
        {
        case IDT_MENUCHANGESEL:
            pdh->_OnMenuChangeSel();
            return 0;
        }
        break;

    case DHM_DISMISS:
        pdh->_OnDismiss((BOOL)wParam);
        break;

    // Alt+F4 dismisses the window, but doesn't destroy it
    case WM_CLOSE:
        pdh->_OnDismiss(FALSE);
        return 0;

    case WM_SYSCOMMAND:
        switch (wParam & ~0xF) // must ignore bottom 4 bits
        {
        case SC_SCREENSAVE:
            DesktopHost_Dismiss(hwnd);
            break;
        }
        break;

    }
    
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

//
//  If the user executes something or cancels out, we dismiss ourselves.
//
HRESULT CDesktopHost::OnSelect(DWORD dwSelectType)
{
    HRESULT hr = E_NOTIMPL;

    switch (dwSelectType)
    {
    case MPOS_EXECUTE:
    case MPOS_CANCELLEVEL:
        _DismissMenuPopup();
        hr = S_OK;
        break;

    case MPOS_FULLCANCEL:
        if (!_fDismissOnlyPopup)
        {
            _DismissMenuPopup();
        }
        // Don't _CleanupTrackShellMenu yet; wait for
        // _smTracking.IsMenuMessage() to return E_FAIL
        // because it might have some modal UI up
        hr = S_OK;
        break;

    case MPOS_SELECTLEFT:
        _DismissTrackShellMenu();
        hr = S_OK;
        break;
    }
    return hr;
}

void CDesktopHost::_DismissTrackShellMenu()
{
    if (_ppmTracking)
    {
        _fDismissOnlyPopup++;
        _ppmTracking->OnSelect(MPOS_FULLCANCEL);
        _fDismissOnlyPopup--;
    }
}

void CDesktopHost::_CleanupTrackShellMenu()
{
    ATOMICRELEASE(_ppmTracking);
    _hwndTracking = NULL;
    _hwndAltTracking = NULL;
    KillTimer(_hwnd, IDT_MENUCHANGESEL);

    NMHDR nm = { _hwnd, 0, SMN_SHELLMENUDISMISSED };
    SHPropagateMessage(_hwnd, WM_NOTIFY, 0, (LPARAM)&nm, SPM_SEND | SPM_ONELEVEL);
}

void CDesktopHost::_DismissMenuPopup()
{
    DesktopHost_Dismiss(_hwnd);
}

//
//  The PMs want custom keyboard navigation behavior on the Start Panel,
//  so we have to do it all manually.
//
BOOL CDesktopHost::_IsDialogMessage(MSG *pmsg)
{
    //
    //  If the menu isn't even open or if menu mode is blocked, then
    //  do not mess with the message.
    //
    if (!_fOpen || _fMenuBlocked) {
        return FALSE;
    }

    //
    //  Tapping the ALT key dismisses menus.
    //
    if (pmsg->message == WM_SYSKEYDOWN && pmsg->wParam == VK_MENU)
    {
        DesktopHost_Dismiss(_hwnd);
        // For accessibility purposes, dismissing the
        // Start Menu should place focus on the Start Button.
        SetFocus(c_tray._hwndStart);
        return TRUE;
    }

    if (SHIsChildOrSelf(_hwnd, pmsg->hwnd) != S_OK) {
        //
        //  If this is an uncaptured mouse move message, then eat it.
        //  That's what menus do -- they eat mouse moves.
        //  Let clicks go through, however, so the user
        //  can click away to dismiss the menu and activate
        //  whatever they clicked on.
        if (!GetCapture() && pmsg->message == WM_MOUSEMOVE) {
            return TRUE;
        }

        return FALSE;
    }

    //
    // Destination window must be a grandchild of us.  The child is the
    // host control; the grandchild is the real control.  Note also that
    // we do not attempt to modify the behavior of great-grandchildren,
    // because that would mess up inplace editing (which creates an
    // edit control as a child of the listview).

    HWND hwndTarget = GetParent(pmsg->hwnd);
    if (hwndTarget != NULL && GetParent(hwndTarget) != _hwnd)
    {
        hwndTarget = NULL;
    }

    //
    //  Intercept mouse messages so we can do mouse hot tracking goo.
    //  (But not if a client has blocked menu mode because it has gone
    //  into some modal state.)
    //
    switch (pmsg->message) {
    case WM_MOUSEMOVE:
        _FilterMouseMove(pmsg, hwndTarget);
        break;

    case WM_MOUSELEAVE:
        _FilterMouseLeave(pmsg, hwndTarget);
        break;

    case WM_MOUSEHOVER:
        _FilterMouseHover(pmsg, hwndTarget);
        break;

    }

    //
    //  Keyboard messages require a valid target.
    //
    if (hwndTarget == NULL) {
        return FALSE;
    }

    //
    //  Okay, hwndTarget is the host control that understands our
    //  wacky notification messages.
    //

    switch (pmsg->message)
    {
    case WM_KEYDOWN:
        _EnableKeyboardCues();

        switch (pmsg->wParam)
        {
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
            return _DlgNavigateArrow(hwndTarget, pmsg);

        case VK_ESCAPE:
        case VK_CANCEL:
            DesktopHost_Dismiss(_hwnd);
            // For accessibility purposes, hitting ESC to dismiss the
            // Start Menu should place focus on the Start Button.
            SetFocus(c_tray._hwndStart);
            return TRUE;

        case VK_RETURN:
            _FindChildItem(hwndTarget, NULL, SMNDM_INVOKECURRENTITEM | SMNDM_KEYBOARD);
            return TRUE;

        // Eat space
        case VK_SPACE:
            return TRUE;

        default:
            break;
        }
        return FALSE;

    // Must dispatch there here so Tray's TranslateAccelerator won't see them
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
    case WM_SYSCHAR:
        DispatchMessage(pmsg);
        return TRUE;

    case WM_CHAR:
        return _DlgNavigateChar(hwndTarget, pmsg);

    }

    return FALSE;
}

LRESULT CDesktopHost::_FindChildItem(HWND hwnd, SMNDIALOGMESSAGE *pnmdm, UINT smndm)
{
    SMNDIALOGMESSAGE nmdm;
    if (!pnmdm)
    {
        pnmdm = &nmdm;
    }

    pnmdm->hdr.hwndFrom = _hwnd;
    pnmdm->hdr.idFrom = 0;
    pnmdm->hdr.code = SMN_FINDITEM;
    pnmdm->flags = smndm;

    LRESULT lres = ::SendMessage(hwnd, WM_NOTIFY, 0, (LPARAM)pnmdm);

    if (lres && (smndm & SMNDM_SELECT))
    {
        SetFocus(::GetWindow(hwnd, GW_CHILD));
    }

    return lres;
}

void CDesktopHost::_EnableKeyboardCues()
{
    SendMessage(_hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
}


//
//  _DlgFindItem does the grunt work of walking the group/tab order
//  looking for an item.
//
//  hwndStart = window after which to start searching
//  pnmdm = structure to receive results
//  smndm = flags for _FindChildItem call
//  GetNextDlgItem = GetNextDlgTabItem or GetNextDlgGroupItem
//  fl = flags (DFI_*)
//
//  DFI_INCLUDESTARTLAST:  Include hwndStart at the end of the search.
//                         Otherwise do not search in hwndStart.
//
//  Returns the found window, or NULL.
//

#define DFI_FORWARDS            0x0000
#define DFI_BACKWARDS           0x0001

#define DFI_INCLUDESTARTLAST    0x0002

HWND CDesktopHost::_DlgFindItem(
    HWND hwndStart, SMNDIALOGMESSAGE *pnmdm, UINT smndm,
    GETNEXTDLGITEM GetNextDlgItem, UINT fl)
{
    HWND hwndT = hwndStart;
    int iLoopCount = 0;

    while ((hwndT = GetNextDlgItem(_hwnd, hwndT, fl & DFI_BACKWARDS)) != NULL)
    {
        if (!(fl & DFI_INCLUDESTARTLAST) && hwndT == hwndStart)
        {
            return NULL;
        }

        if (_FindChildItem(hwndT, pnmdm, smndm))
        {
            return hwndT;
        }

        if (hwndT == hwndStart)
        {
            ASSERT(fl & DFI_INCLUDESTARTLAST);
            return NULL;
        }

        if (++iLoopCount > 10)
        {
            // If this assert fires, it means that the controls aren't
            // playing nice with WS_TABSTOP and WS_GROUP and we got stuck.
            ASSERT(iLoopCount < 10);
            return NULL;
        }

    }
    return NULL;
}

BOOL CDesktopHost::_DlgNavigateArrow(HWND hwndStart, MSG *pmsg)
{
    HWND hwndT;
    SMNDIALOGMESSAGE nmdm;
    MSG msg;
    nmdm.pmsg = pmsg;   // other fields will be filled in by _FindChildItem

    TraceMsg(TF_DV2DIALOG, "idm.arrow(%04x)", pmsg->wParam);

    // If RTL, then flip the left and right arrows
    UINT vk = (UINT)pmsg->wParam;
    BOOL fRTL = GetWindowLong(_hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL;
    if (fRTL)
    {
        if (vk == VK_LEFT) vk = VK_RIGHT;
        else if (vk == VK_RIGHT) vk = VK_LEFT;
        // Put the flipped arrows into the MSG structure so clients don't
        // have to know anything about RTL.
        msg = *pmsg;
        nmdm.pmsg = &msg;
        msg.wParam = vk;
    }
    BOOL fBackwards = vk == VK_LEFT || vk == VK_UP;
    BOOL fVerticalKey = vk == VK_UP || vk == VK_DOWN;


    //
    //  First see if the navigation can be handled by the control natively.
    //  We have to let the control get first crack because it might want to
    //  override default behavior (e.g., open a menu when VK_RIGHT is pressed
    //  instead of moving to the right).
    //

    //
    //  Holding the shift key while hitting the Right [RTL:Left] arrow
    //  suppresses the attempt to cascade.
    //

    DWORD dwTryCascade = 0;
    if (vk == VK_RIGHT && GetKeyState(VK_SHIFT) >= 0)
    {
        dwTryCascade |= SMNDM_TRYCASCADE;
    }

    if (_FindChildItem(hwndStart, &nmdm, dwTryCascade | SMNDM_FINDNEXTARROW | SMNDM_SELECT | SMNDM_KEYBOARD))
    {
        // That was easy
        return TRUE;
    }

    //
    //  If the arrow key is in alignment with the control's orientation,
    //  then walk through the other controls in the group until we find
    //  one that contains an item, or until we loop back.
    //

    ASSERT(nmdm.flags & (SMNDM_VERTICAL | SMNDM_HORIZONTAL));

    // Save this because subsequent callbacks will wipe it out.
    DWORD dwDirection = nmdm.flags;

    //
    //  Up/Down arrow always do prev/next.  Left/right arrow will
    //  work if we are in a horizontal control.
    //
    if (fVerticalKey || (dwDirection & SMNDM_HORIZONTAL))
    {
        // Search for next/prev control in group.

        UINT smndm = fBackwards ? SMNDM_FINDLAST : SMNDM_FINDFIRST;
        UINT fl = fBackwards ? DFI_BACKWARDS : DFI_FORWARDS;

        hwndT = _DlgFindItem(hwndStart, &nmdm,
                             smndm | SMNDM_SELECT | SMNDM_KEYBOARD,
                             GetNextDlgGroupItem,
                             fl | DFI_INCLUDESTARTLAST);

        // Always return TRUE to eat the message
        return TRUE;
    }

    //
    //  Navigate to next column or row.  Look for controls that intersect
    //  the x (or y) coordinate of the current item and ask them to select
    //  the nearest available item.
    //
    //  Note that in this loop we do not want to let the starting point
    //  try again because it already told us that the navigation key was
    //  trying to leave the starting point.
    //

    //
    //  Note: For RTL compatibility, we must map rectangles.
    //
    RECT rcSrc = { nmdm.pt.x, nmdm.pt.y, nmdm.pt.x, nmdm.pt.y };
    MapWindowRect(hwndStart, HWND_DESKTOP, &rcSrc);
    hwndT = hwndStart;

    while ((hwndT = GetNextDlgGroupItem(_hwnd, hwndT, fBackwards)) != NULL &&
           hwndT != hwndStart)
    {
        // Does this window intersect in the desired direction?
        RECT rcT;
        BOOL fIntersect;

        GetWindowRect(hwndT, &rcT);
        if (dwDirection & SMNDM_VERTICAL)
        {
            rcSrc.left = rcSrc.right = fRTL ? rcT.right : rcT.left;
            fIntersect = rcSrc.top >= rcT.top && rcSrc.top < rcT.bottom;
        }
        else
        {
            rcSrc.top = rcSrc.bottom = rcT.top;
            fIntersect = rcSrc.left >= rcT.left && rcSrc.left < rcT.right;
        }

        if (fIntersect)
        {
            rcT = rcSrc;
            MapWindowRect(HWND_DESKTOP, hwndT, &rcT);
            nmdm.pt.x = rcT.left;
            nmdm.pt.y = rcT.top;
            if (_FindChildItem(hwndT, &nmdm,
                               SMNDM_FINDNEAREST | SMNDM_SELECT | SMNDM_KEYBOARD))
            {
                return TRUE;
            }
        }
    }

    // Always return TRUE to eat the message
    return TRUE;
}

//
// Find the next/prev tabstop and tell it to select its first item.
// Keep doing this until we run out of controls or we find a control
// that is nonempty.
//

HWND CDesktopHost::_FindNextDlgChar(HWND hwndStart, SMNDIALOGMESSAGE *pnmdm, UINT smndm)
{
    //
    //  See if there is a match in the hwndStart control.
    //
    if (_FindChildItem(hwndStart, pnmdm, SMNDM_FINDNEXTMATCH | SMNDM_KEYBOARD | smndm))
    {
        return hwndStart;
    }

    //
    //  Oh well, look for some other control, possibly wrapping back around
    //  to the start.
    //
    return _DlgFindItem(hwndStart, pnmdm,
                        SMNDM_FINDFIRSTMATCH | SMNDM_KEYBOARD | smndm,
                        GetNextDlgGroupItem,
                        DFI_FORWARDS | DFI_INCLUDESTARTLAST);

}

//
//  Find the next item that begins with the typed letter and
//  invoke it if it is unique.
//
BOOL CDesktopHost::_DlgNavigateChar(HWND hwndStart, MSG *pmsg)
{
    SMNDIALOGMESSAGE nmdm;
    nmdm.pmsg = pmsg;   // other fields will be filled in by _FindChildItem

    //
    //  See if there is a match in the hwndStart control.
    //
    HWND hwndFound = _FindNextDlgChar(hwndStart, &nmdm, SMNDM_SELECT);
    if (hwndFound)
    {
        LRESULT idFound = nmdm.itemID;

        //
        //  See if there is another match for this character.
        //  We are only looking, so don't pass SMNDM_SELECT.
        //
        HWND hwndFound2 = _FindNextDlgChar(hwndFound, &nmdm, 0);
        if (hwndFound2 == hwndFound && nmdm.itemID == idFound)
        {
            //
            //  There is only one item that begins with this character.
            //  Invoke it!
            //
            UpdateWindow(_hwnd);
            _FindChildItem(hwndFound2, &nmdm, SMNDM_INVOKECURRENTITEM | SMNDM_KEYBOARD);
        }
    }

    return TRUE;
}

void CDesktopHost::_FilterMouseMove(MSG *pmsg, HWND hwndTarget)
{

    if (!_fMouseEntered) {
        _fMouseEntered = TRUE;
        TRACKMOUSEEVENT tme;
        tme.cbSize = sizeof(tme);
        tme.dwFlags = TME_LEAVE;
        tme.hwndTrack = pmsg->hwnd;
        TrackMouseEvent(&tme);
    }

    //
    //  If the mouse is in the same place as last time, then ignore it.
    //  We can get spurious "no-motion" messages when the user is
    //  keyboard navigating.
    //
    if (_hwndLastMouse == pmsg->hwnd &&
        _lParamLastMouse == pmsg->lParam)
    {
        return;
    }

    _hwndLastMouse = pmsg->hwnd;
    _lParamLastMouse = pmsg->lParam;

    //
    //  See if the target window can hit-test this item successfully.
    //
    LRESULT lres;
    if (hwndTarget)
    {
        SMNDIALOGMESSAGE nmdm;
        nmdm.pt.x = GET_X_LPARAM(pmsg->lParam);
        nmdm.pt.y = GET_Y_LPARAM(pmsg->lParam);
        lres = _FindChildItem(hwndTarget, &nmdm, SMNDM_HITTEST | SMNDM_SELECT);
    }
    else
    {
        lres = 0;               // No target, so no hit-test
    }

    if (!lres)
    {
        _RemoveSelection();
    }
    else
    {
        //
        //  We selected a guy.  Turn on the hover timer so we can
        //  do the auto-open thingie.
        //
        if (_fAutoCascade)
        {
            TRACKMOUSEEVENT tme;
            tme.cbSize = sizeof(tme);
            tme.dwFlags = TME_HOVER;
            tme.hwndTrack = pmsg->hwnd;
            if (!SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &tme.dwHoverTime, 0))
            {
                tme.dwHoverTime = HOVER_DEFAULT;
            }
            TrackMouseEvent(&tme);
        }
    }

}

void CDesktopHost::_FilterMouseLeave(MSG *pmsg, HWND hwndTarget)
{
    _fMouseEntered = FALSE;
    _hwndLastMouse = NULL;

    // If we got a WM_MOUSELEAVE due to a menu popping up, don't
    // give up the focus since it really didn't leave yet.
    if (!_ppmTracking)
    {
        _RemoveSelection();
    }
}

void CDesktopHost::_FilterMouseHover(MSG *pmsg, HWND hwndTarget)
{
    _FindChildItem(hwndTarget, NULL, SMNDM_OPENCASCADE);
}

//
//  Remove the menu selection and put it in the "dead space" above
//  the first visible item.
//
void CDesktopHost::_RemoveSelection()
{
        // Put focus on first valid child control
        // The real control is the grandchild
        HWND hwndChild = GetNextDlgTabItem(_hwnd, NULL, FALSE);
        if (hwndChild)
        {
            // The inner ::GetWindow will always succeed
            // because all our controls contain inner windows
            // (and if they failed to create their inner window,
            // they would've failed their WM_CREATE message)
            HWND hwndInner = ::GetWindow(hwndChild, GW_CHILD);
            SetFocus(hwndInner);

            //
            //  Now lie to the control and make it think it lost
            //  focus.  This will cause the selection to clear.
            //
            NMHDR hdr;
            hdr.hwndFrom = hwndInner;
            hdr.idFrom = GetDlgCtrlID(hwndInner);
            hdr.code = NM_KILLFOCUS;
            ::SendMessage(hwndChild, WM_NOTIFY, hdr.idFrom, (LPARAM)&hdr);
        }
}

HRESULT CDesktopHost::IsMenuMessage(MSG *pmsg)
{
    if (_hwnd)
    {
        if (_ppmTracking)
        {
            HRESULT hr = _ppmTracking->IsMenuMessage(pmsg);
            if (hr == E_FAIL)
            {
                _CleanupTrackShellMenu();
                hr = S_FALSE;
            }
            if (hr == S_OK)
            {
                return hr;
            }
        }

        if (_IsDialogMessage(pmsg))
        {
            return S_OK;    // message handled
        }
        else
        {
            return S_FALSE; // message not handled
        }
    }
    else
    {
        return E_FAIL;      // Menu is gone
    }
}

HRESULT CDesktopHost::TranslateMenuMessage(MSG *pmsg, LRESULT *plres)
{
    if (_ppmTracking)
    {
        return _ppmTracking->TranslateMenuMessage(pmsg, plres);
    }
    return E_NOTIMPL;
}

// IServiceProvider::QueryService
STDMETHODIMP CDesktopHost::QueryService(REFGUID guidService, REFIID riid, void ** ppvObject)
{
    if(IsEqualGUID(guidService,SID_SMenuPopup))
        return QueryInterface(riid,ppvObject);

    return E_FAIL;
}

// *** IOleCommandTarget ***
STDMETHODIMP  CDesktopHost::QueryStatus (const GUID * pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return E_NOTIMPL;
}

STDMETHODIMP  CDesktopHost::Exec (const GUID * pguidCmdGroup,
    DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (IsEqualGUID(CLSID_MenuBand,*pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case MBANDCID_REFRESH:
            {
                // There was a session or WM_DEVICECHANGE, we need to refresh our logoff options
                NMHDR nm = { _hwnd, 0, SMN_REFRESHLOGOFF};
                SHPropagateMessage(_hwnd, WM_NOTIFY, 0, (LPARAM)&nm, SPM_SEND | SPM_ONELEVEL);
                OnNeedRepaint();
            }
            break;
        default:
            break;
        }
    }

    return NOERROR;
}

// ITrayPriv2::ModifySMInfo
HRESULT CDesktopHost::ModifySMInfo(IN LPSMDATA psmd, IN OUT SMINFO *psminfo)
{
    if (_hwndNewHandler)
    {
        SMNMMODIFYSMINFO nmsmi;
        nmsmi.hdr.hwndFrom = _hwnd;
        nmsmi.hdr.idFrom = 0;
        nmsmi.hdr.code = SMN_MODIFYSMINFO;
        nmsmi.psmd = psmd;
        nmsmi.psminfo = psminfo;
        SendMessage(_hwndNewHandler, WM_NOTIFY, 0, (LPARAM)&nmsmi);
    }

    return S_OK;
}

BOOL CDesktopHost::AddWin32Controls()
{
    RegisterDesktopControlClasses();

    // we create the controls with an arbitrary size, since we won't know how big we are until we pop up...

    // Note that we do NOT set WS_EX_CONTROLPARENT because we want the
    // dialog manager to think that our child controls are the interesting
    // objects, not the inner grandchildren.
    //
    // Setting the control ID equal to the internal index number is just
    // for the benefit of the test automation tools.

    for (int i=0; i<ARRAYSIZE(_spm.panes); i++)
    {
        _spm.panes[i].hwnd = CreateWindowExW(0, _spm.panes[i].pszClassName,
                                            NULL,
                                            _spm.panes[i].dwStyle | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
                                            0, 0, _spm.panes[i].size.cx, _spm.panes[i].size.cy,
                                            _hwnd, IntToPtr_(HMENU, i), NULL,
                                            &_spm.panes[i]);
    }

    return TRUE;
}

void CDesktopHost::OnPaint(HDC hdc, BOOL bBackground)
{
}

void CDesktopHost::_ReadPaneSizeFromTheme(SMPANEDATA *psmpd)
{
    RECT rc;
    if (SUCCEEDED(GetThemeRect(psmpd->hTheme, psmpd->iPartId, 0, TMT_DEFAULTPANESIZE, &rc)))
    {
        // semi-hack to take care of the fact that if one the start panel parts is missing a property, 
        // themes will use the next level up (to the panel itself)
        if ((rc.bottom != _spm.sizPanel.cy) || (rc.right != _spm.sizPanel.cx))
        {
            psmpd->size.cx = RECTWIDTH(rc); 
            psmpd->size.cy = RECTHEIGHT(rc);
        }
    }
}

void RemapSizeForHighDPI(SIZE *psiz)
{
    static int iLPX, iLPY;

    if (!iLPX || !iLPY)
    {
        HDC hdc = GetDC(NULL);
        iLPX = GetDeviceCaps(hdc, LOGPIXELSX);
        iLPY = GetDeviceCaps(hdc, LOGPIXELSY);
        ReleaseDC(NULL, hdc);
    }

    // 96 DPI is small fonts, so scale based on the multiple of that.
    psiz->cx = (psiz->cx * iLPX)/96;
    psiz->cy = (psiz->cy * iLPY)/96;
}



void CDesktopHost::LoadResourceInt(UINT ids, LONG *pl)
{
    TCHAR sz[64];
    if (LoadString(hinstCabinet, ids, sz, ARRAYSIZE(sz)))
    {
        int i = StrToInt(sz);
        if (i)
        {
            *pl = i;
        }
    }
}

void CDesktopHost::LoadPanelMetrics()
{
    // initialize our copy of the panel metrics from the default...
    _spm = g_spmDefault;

    // Adjust for localization
    LoadResourceInt(IDS_STARTPANE_TOTALHEIGHT,   &_spm.sizPanel.cy);
    LoadResourceInt(IDS_STARTPANE_TOTALWIDTH,    &_spm.sizPanel.cx);
    LoadResourceInt(IDS_STARTPANE_USERHEIGHT,    &_spm.panes[SMPANETYPE_USER].size.cy);
    LoadResourceInt(IDS_STARTPANE_MOREPROGHEIGHT,&_spm.panes[SMPANETYPE_MOREPROG].size.cy);
    LoadResourceInt(IDS_STARTPANE_LOGOFFHEIGHT,  &_spm.panes[SMPANETYPE_LOGOFF].size.cy);

    // wacky raymondc logic to scale using the values in g_spmDefault as relative ratio's
    // Now apply those numbers; widths are easy
    int i;
    for (i = 0; i < ARRAYSIZE(_spm.panes); i++)
    {
        _spm.panes[i].size.cx = MulDiv(g_spmDefault.panes[i].size.cx,
                                       _spm.sizPanel.cx,
                                       g_spmDefault.sizPanel.cx);
    }

    // Places gets all height not eaten by User and Logoff
    _spm.panes[SMPANETYPE_PLACES].size.cy = _spm.sizPanel.cy
                                          - _spm.panes[SMPANETYPE_USER].size.cy
                                          - _spm.panes[SMPANETYPE_LOGOFF].size.cy;

    // MFU gets Places minus More Programs
    _spm.panes[SMPANETYPE_MFU].size.cy = _spm.panes[SMPANETYPE_PLACES].size.cy
                                       - _spm.panes[SMPANETYPE_MOREPROG].size.cy;

    // End of adjustments for localization

    // load the theme file (which shouldn't be loaded yet)
    ASSERT(!_hTheme);
    // only try to use themes if our color depth is greater than 8bpp.
    if (SHGetCurColorRes() > 8)
        _hTheme = OpenThemeData(_hwnd, STARTPANELTHEME);

    if (_hTheme)
    {
        // if we fail reading the size from the theme, it will fall back to the defaul size....

        RECT rcT;
        if (SUCCEEDED(GetThemeRect(_hTheme, 0, 0, TMT_DEFAULTPANESIZE, &rcT))) // the overall pane
        {
            _spm.sizPanel.cx = RECTWIDTH(rcT);
            _spm.sizPanel.cy = RECTHEIGHT(rcT);
            for (int i=0;i<ARRAYSIZE(_spm.panes);i++)
            {
                _spm.panes[i].hTheme = _hTheme;
                _ReadPaneSizeFromTheme(&_spm.panes[i]);
            }
        }
    }

    // ASSERT that the layout matches up somewhat...
    ASSERT(_spm.sizPanel.cx == _spm.panes[SMPANETYPE_USER].size.cx);
    ASSERT(_spm.sizPanel.cx == _spm.panes[SMPANETYPE_MFU].size.cx + _spm.panes[SMPANETYPE_PLACES].size.cx );
    ASSERT(_spm.sizPanel.cx == _spm.panes[SMPANETYPE_LOGOFF].size.cx);
    ASSERT(_spm.panes[SMPANETYPE_MOREPROG].size.cx == _spm.panes[SMPANETYPE_MFU].size.cx);
    TraceMsg(TF_DV2HOST, "sizPanel.cy = %d, user = %d, MFU =%d, moreprog=%d, logoff=%d",
        _spm.sizPanel.cy, _spm.panes[SMPANETYPE_USER].size.cy, _spm.panes[SMPANETYPE_MFU].size.cy,
        _spm.panes[SMPANETYPE_MOREPROG].size.cy, _spm.panes[SMPANETYPE_LOGOFF].size.cy);

    ASSERT(_spm.sizPanel.cy == _spm.panes[SMPANETYPE_USER].size.cy + _spm.panes[SMPANETYPE_MFU].size.cy + _spm.panes[SMPANETYPE_MOREPROG].size.cy + _spm.panes[SMPANETYPE_LOGOFF].size.cy);

    // one final pass to adjust everything for DPI
    // note that things may not match up exactly after this due to rounding, but _ComputeActualSize can deal
    RemapSizeForHighDPI(&_spm.sizPanel);
    for (int i=0;i<ARRAYSIZE(_spm.panes);i++)
    {
        RemapSizeForHighDPI(&_spm.panes[i].size);
    }

    SetRect(&_rcDesired, 0, 0, _spm.sizPanel.cx, _spm.sizPanel.cy);
}

void CDesktopHost::OnCreate(HWND hwnd)
{
    _hwnd          = hwnd;
    TraceMsg(TF_DV2HOST, "Entering CDesktopHost::OnCreate");

    // Add the controls and background images
    AddWin32Controls();
}

void CDesktopHost::OnDestroy()
{
    _hwnd = NULL;
    if (_hTheme)
    {
        CloseThemeData(_hTheme);
        _hTheme = NULL;
    }
}

void CDesktopHost::OnSetFocus(HWND hwndLose)
{
    if (!_RestoreChildFocus())
    {
        _RemoveSelection();
    }
}

LRESULT CDesktopHost::OnCommandInvoked(NMHDR *pnm)
{
    PSMNMCOMMANDINVOKED pci = (PSMNMCOMMANDINVOKED)pnm;

    ExplorerPlaySound(TEXT("MenuCommand"));
    BOOL fFade = FALSE;
    if (SystemParametersInfo(SPI_GETSELECTIONFADE, 0, &fFade, 0) && fFade)
    {
        if (!_ptFader)
        {
            CoCreateInstance(CLSID_FadeTask, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IFadeTask, &_ptFader));
        }
        if (_ptFader)
        {
            _ptFader->FadeRect(&pci->rcItem);
        }
    }

    return OnSelect(MPOS_EXECUTE);
}

LRESULT CDesktopHost::OnFilterOptions(NMHDR *pnm)
{
    PSMNFILTEROPTIONS popt = (PSMNFILTEROPTIONS)pnm;

    if ((popt->smnop & SMNOP_LOGOFF) &&
        !_ShowStartMenuLogoff())
    {
        popt->smnop &= ~SMNOP_LOGOFF;
    }

    if ((popt->smnop & SMNOP_TURNOFF) &&
        !_ShowStartMenuShutdown())
    {
        popt->smnop &= ~SMNOP_TURNOFF;
    }

    if ((popt->smnop & SMNOP_DISCONNECT) &&
        !_ShowStartMenuDisconnect())
    {
        popt->smnop &= ~SMNOP_DISCONNECT;
    }

    if ((popt->smnop & SMNOP_EJECT) &&
        !_ShowStartMenuEject())
    {
        popt->smnop &= ~SMNOP_EJECT;
    }

    return 0;
}

LRESULT CDesktopHost::OnTrackShellMenu(NMHDR *pnm)
{
    PSMNTRACKSHELLMENU ptsm = CONTAINING_RECORD(pnm, SMNTRACKSHELLMENU, hdr);
    HRESULT hr;

    _hwndTracking = ptsm->hdr.hwndFrom;
    _itemTracking = ptsm->itemID;
    _hwndAltTracking = NULL;
    _itemAltTracking = 0;

    //
    //  Decide which direction we need to pop.
    //
    DWORD dwFlags;
    if (GetWindowLong(_hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
    {
        dwFlags = MPPF_LEFT;
    }
    else
    {
        dwFlags = MPPF_RIGHT;
    }

    // Don't _CleanupTrackShellMenu because that will undo some of the
    // work we've already done and make the client think that the popup
    // they requested got dismissed.

    //
    // ISSUE raymondc: actually this abandons the trackpopupmenu that
    // may already be in progress - its mouse UI gets messed up as a result.
    //
    ATOMICRELEASE(_ppmTracking);

    if (_hwndTracking == _spm.panes[SMPANETYPE_MOREPROG].hwnd)
    {
        if (_ppmPrograms && _ppmPrograms->IsSame(ptsm->psm))
        {
            // It's already in our cache, woo-hoo!
            hr = S_OK;
        }
        else
        {
            ATOMICRELEASE(_ppmPrograms);
            _SubclassTrackShellMenu(ptsm->psm);
            hr = CPopupMenu_CreateInstance(ptsm->psm, GetUnknown(), _hwnd, &_ppmPrograms);
        }

        if (SUCCEEDED(hr))
        {
            _ppmTracking = _ppmPrograms;
            _ppmTracking->AddRef();
        }
    }
    else
    {
        _SubclassTrackShellMenu(ptsm->psm);
        hr = CPopupMenu_CreateInstance(ptsm->psm, GetUnknown(), _hwnd, &_ppmTracking);
    }

    if (SUCCEEDED(hr))
    {
        hr = _ppmTracking->Popup(&ptsm->rcExclude, ptsm->dwFlags | dwFlags);
    }

    if (FAILED(hr))
    {
        // In addition to freeing any partially-allocated objects,
        // this also sends a SMN_SHELLMENUDISMISSED so the client
        // knows to remove the highlight from the item being cascaded
        _CleanupTrackShellMenu();
    }

    return 0;
}

HRESULT CDesktopHost::_MenuMouseFilter(LPSMDATA psmd, BOOL fRemove, LPMSG pmsg)
{
    HRESULT hr = S_FALSE;
    SMNDIALOGMESSAGE nmdm;

    enum {
        WHERE_IGNORE,               // ignore this message
        WHERE_OUTSIDE,              // outside the Start Menu entirely
        WHERE_DEADSPOT,             // a dead spot on the Start Menu
        WHERE_ONSELF,               // over the item that initiated the popup
        WHERE_ONOTHER,              // over some other item in the Start Menu
    } uiWhere;

    //
    //  Figure out where the mouse is.
    //
    //  Note: ChildWindowFromPointEx searches only immediate
    //  children; it does not search grandchildren. Fortunately, that's
    //  exactly what we want...
    //

    HWND hwndTarget = NULL;

    if (fRemove)
    {
        if (psmd->punk)
        {
            // Inside a menuband - mouse has left our window
            uiWhere = WHERE_OUTSIDE;
        }
        else
        {
            POINT pt = { GET_X_LPARAM(pmsg->lParam), GET_Y_LPARAM(pmsg->lParam) };
            ScreenToClient(_hwnd, &pt);

            hwndTarget = ChildWindowFromPointEx(_hwnd, pt, CWP_SKIPINVISIBLE);
            if (hwndTarget == _hwnd)
            {
                uiWhere = WHERE_DEADSPOT;
            }
            else if (hwndTarget)
            {
                LRESULT lres;
                nmdm.pt = pt;
                HWND hwndChild = ::GetWindow(hwndTarget, GW_CHILD);
                MapWindowPoints(_hwnd, hwndChild, &nmdm.pt, 1);
                lres = _FindChildItem(hwndTarget, &nmdm, SMNDM_HITTEST | SMNDM_SELECT);
                if (lres)
                {
                    // Mouse is over something; is it over the current item?

                    if (nmdm.itemID == _itemTracking &&
                        hwndTarget == _hwndTracking)
                    {
                        uiWhere = WHERE_ONSELF;
                    }
                    else
                    {
                        uiWhere = WHERE_ONOTHER;
                    }
                }
                else
                {
                    uiWhere = WHERE_DEADSPOT;
                }
            }
            else
            {
                // ChildWindowFromPoint failed - user has left the Start Menu
                uiWhere = WHERE_OUTSIDE;
            }
        }
    }
    else
    {
        // Ignore PM_NOREMOVE messages; we'll pay attention to them when
        // they are PM_REMOVE'd.
        uiWhere = WHERE_IGNORE;
    }

    //
    //  Now do appropriate stuff depending on where the mouse is.
    //
    switch (uiWhere)
    {
    case WHERE_IGNORE:
        break;

    case WHERE_OUTSIDE:
        //
        // If you've left the menu entirely, then we return the menu to
        // its original state, which is to say, as if you are hovering
        // over the item that caused the popup to open in the first place.
        // as being in a dead zone.
        //
        // FALL THROUGH
        goto L_WHERE_ONSELF_HOVER;

    case WHERE_DEADSPOT:
        // To avoid annoying flicker as the user wanders over dead spots,
        // we ignore mouse motion over them (but dismiss if they click
        // in a dead spot).
        if (pmsg->message == WM_LBUTTONDOWN ||
            pmsg->message == WM_RBUTTONDOWN)
        {
            // Must explicitly dismiss; if we let it fall through to the
            // default handler, then it will dismiss for us, causing the
            // entire Start Menu to go away instead of just the tracking
            // part.
            _DismissTrackShellMenu();
            hr = S_OK;
        }
        break;

    case WHERE_ONSELF:
        if (pmsg->message == WM_LBUTTONDOWN ||
            pmsg->message == WM_RBUTTONDOWN)
        {
            _DismissTrackShellMenu();
            hr = S_OK;
        }
        else
        {
    L_WHERE_ONSELF_HOVER:
            _hwndAltTracking = NULL;
            _itemAltTracking = 0;
            nmdm.itemID = _itemTracking;
            _FindChildItem(_hwndTracking, &nmdm, SMNDM_FINDITEMID | SMNDM_SELECT);
            KillTimer(_hwnd, IDT_MENUCHANGESEL);
        }
        break;

    case WHERE_ONOTHER:
        if (pmsg->message == WM_LBUTTONDOWN ||
            pmsg->message == WM_RBUTTONDOWN)
        {
            _DismissTrackShellMenu();
            hr = S_OK;
        }
        else if (hwndTarget == _hwndAltTracking && nmdm.itemID == _itemAltTracking)
        {
            // Don't restart the timer if the user wiggles the mouse
            // within a single item
        }
        else
        {
            _hwndAltTracking = hwndTarget;
            _itemAltTracking = nmdm.itemID;

            DWORD dwHoverTime;
            if (!SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &dwHoverTime, 0))
            {
                dwHoverTime = 0;
            }
            SetTimer(_hwnd, IDT_MENUCHANGESEL, dwHoverTime, 0);
        }
        break;
    }

    return hr;
}

void CDesktopHost::_OnMenuChangeSel()
{
    KillTimer(_hwnd, IDT_MENUCHANGESEL);
    _DismissTrackShellMenu();
}

void CDesktopHost::_SaveChildFocus()
{
    if (!_hwndChildFocus)
    {
    HWND hwndFocus = GetFocus();
        if (hwndFocus && IsChild(_hwnd, hwndFocus))
        {
            _hwndChildFocus = hwndFocus;
        }
    }
}

// Returns non-NULL if focus was successfully restored
HWND CDesktopHost::_RestoreChildFocus()
{
    HWND hwndRet = NULL;
    if (IsWindow(_hwndChildFocus))
    {
        HWND hwndT = _hwndChildFocus;
        _hwndChildFocus = NULL;
        hwndRet = SetFocus(hwndT);
    }
    return hwndRet;
}


void CDesktopHost::_DestroyClipBalloon()
{
    if (_hwndClipBalloon)
    {
        DestroyWindow(_hwndClipBalloon);
        _hwndClipBalloon = NULL;
    }
}


void CDesktopHost::_OnDismiss(BOOL bDestroy)
{
    // Break the recursion loop:  Call IMenuPopup::OnSelect only if the
    // window was previously visible.
    _fOpen = FALSE;
    if (ShowWindow(_hwnd, SW_HIDE))
    {
        if (_ppmTracking)
        {
            _ppmTracking->OnSelect(MPOS_FULLCANCEL);
        }

        OnSelect(MPOS_FULLCANCEL);

        NMHDR nm = { _hwnd, 0, SMN_DISMISS };
        SHPropagateMessage(_hwnd, WM_NOTIFY, 0, (LPARAM)&nm, SPM_SEND | SPM_ONELEVEL);

        _DestroyClipBalloon();

        // Allow clicking on Start button to pop the menu immediately
        Tray_SetStartPaneActive(FALSE);

        // Don't try to preserve child focus across popups
        _hwndChildFocus = NULL;

        Tray_OnStartMenuDismissed();

        NotifyWinEvent(EVENT_SYSTEM_MENUPOPUPEND, _hwnd, OBJID_CLIENT, CHILDID_SELF);
    }
    if (bDestroy)
    {
        v_hwndStartPane = NULL;
        ASSERT(GetWindowThreadProcessId(_hwnd, NULL) == GetCurrentThreadId());
        DestroyWindow(_hwnd);
    }
}

HRESULT CDesktopHost::Build()
{
    HRESULT hr = S_OK;
    if (_hwnd == NULL)
    {
        _hwnd = _Create();

        if (_hwnd)
        {
            // Tell all our child windows it's time to reinitialize
            NMHDR nm = { _hwnd, 0, SMN_INITIALUPDATE };
            SHPropagateMessage(_hwnd, WM_NOTIFY, 0, (LPARAM)&nm, SPM_SEND | SPM_ONELEVEL);
        }
    }
    
    if (_hwnd == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
 
    return hr;
}


//*****************************************************************
//
//  CDeskHostShellMenuCallback
//
//  Create a wrapper IShellMenuCallback that picks off mouse
//  messages.
//
class CDeskHostShellMenuCallback
    : public CUnknown
    , public IShellMenuCallback
    , public IServiceProvider
    , public CObjectWithSite
{
    friend class CDesktopHost;

public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CUnknown::AddRef(); }
    STDMETHODIMP_(ULONG) Release(void) { return CUnknown::Release(); }

    // *** IShellMenuCallback ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** IObjectWithSite ***
    STDMETHODIMP SetSite(IUnknown *punkSite);

    // *** IServiceProvider ***
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObject);

private:
    CDeskHostShellMenuCallback(CDesktopHost *pdh)
    {
        _pdh = pdh; _pdh->AddRef();
    }

    ~CDeskHostShellMenuCallback()
    {
        ATOMICRELEASE(_pdh);
        IUnknown_SetSite(_psmcPrev, NULL);
        ATOMICRELEASE(_psmcPrev);
    }

    IShellMenuCallback *_psmcPrev;
    CDesktopHost *_pdh;
};

HRESULT CDeskHostShellMenuCallback::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CDeskHostShellMenuCallback, IShellMenuCallback),
        QITABENT(CDeskHostShellMenuCallback, IObjectWithSite),
        QITABENT(CDeskHostShellMenuCallback, IServiceProvider),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

BOOL FeatureEnabled(LPTSTR pszFeature)
{
    return SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, pszFeature,
                        FALSE, // Don't ignore HKCU
                        FALSE); // Disable this cool feature.
}


HRESULT CDeskHostShellMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case SMC_MOUSEFILTER:
        if (_pdh)
            return _pdh->_MenuMouseFilter(psmd, (BOOL)wParam, (MSG*)lParam);

    case SMC_GETSFINFOTIP:
        if (!FeatureEnabled(TEXT("ShowInfoTip")))
            return E_FAIL;  // E_FAIL means don't show. S_FALSE means show default
        break;

    }

    if (_psmcPrev)
        return _psmcPrev->CallbackSM(psmd, uMsg, wParam, lParam);

    return S_FALSE;
}

HRESULT CDeskHostShellMenuCallback::SetSite(IUnknown *punkSite)
{
    CObjectWithSite::SetSite(punkSite);
    // Each time our site changes, reassert ourselves as the site of
    // the inner object so he can try a new QueryService.
    IUnknown_SetSite(_psmcPrev, this->GetUnknown());

    // If the game is over, break our backreference
    if (!punkSite)
    {
        ATOMICRELEASE(_pdh);
    }

    return S_OK;
}

HRESULT CDeskHostShellMenuCallback::QueryService(REFGUID guidService, REFIID riid, void ** ppvObject)
{
    return IUnknown_QueryService(_punkSite, guidService, riid, ppvObject);
}

void CDesktopHost::_SubclassTrackShellMenu(IShellMenu *psm)
{
    CDeskHostShellMenuCallback *psmc = new CDeskHostShellMenuCallback(this);
    if (psmc)
    {
        UINT uId, uIdAncestor;
        DWORD dwFlags;
        if (SUCCEEDED(psm->GetMenuInfo(&psmc->_psmcPrev, &uId, &uIdAncestor, &dwFlags)))
        {
            psm->Initialize(psmc, uId, uIdAncestor, dwFlags);
        }
        psmc->Release();
    }
}

STDAPI DesktopV2_Build(void *pvStartPane)
{
    HRESULT hr = E_POINTER;
    if (pvStartPane)
    {
        hr = reinterpret_cast<CDesktopHost *>(pvStartPane)->Build();
    }
    return hr;
}


STDAPI DesktopV2_Create(
    IMenuPopup **ppmp, IMenuBand **ppmb, void **ppvStartPane)
{
    *ppmp = NULL;
    *ppmb = NULL;

    HRESULT hr;
    CDesktopHost *pdh = new CDesktopHost;
    if (pdh)
    {
        *ppvStartPane = pdh;
        hr = pdh->Initialize();
        if (SUCCEEDED(hr))
        {
            hr = pdh->QueryInterface(IID_PPV_ARG(IMenuPopup, ppmp));
            if (SUCCEEDED(hr))
            {
                hr = pdh->QueryInterface(IID_PPV_ARG(IMenuBand, ppmb));
            }
        }
        pdh->GetUnknown()->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        ATOMICRELEASE(*ppmp);
        ATOMICRELEASE(*ppmb);
        ppvStartPane = NULL;
    }

    return hr;
}


HBITMAP CreateMirroredBitmap( HBITMAP hbmOrig)
{
    HDC     hdc, hdcMem1, hdcMem2;
    HBITMAP hbm = NULL, hOld_bm1, hOld_bm2;
    BITMAP  bm;
    int     IncOne = 0;

    if (!hbmOrig)
        return NULL;

    if (!GetObject(hbmOrig, sizeof(BITMAP), &bm))
        return NULL;

    // Grab the screen DC
    hdc = GetDC(NULL);

    if (hdc)
    {
        hdcMem1 = CreateCompatibleDC(hdc);

        if (!hdcMem1)
        {
            ReleaseDC(NULL, hdc);
            return NULL;
        }

        hdcMem2 = CreateCompatibleDC(hdc);
        if (!hdcMem2)
        {
            DeleteDC(hdcMem1);
            ReleaseDC(NULL, hdc);
            return NULL;
        }

        hbm = CreateCompatibleBitmap(hdc, bm.bmWidth, bm.bmHeight);

        if (!hbm)
        {
            ReleaseDC(NULL, hdc);
            DeleteDC(hdcMem1);
            DeleteDC(hdcMem2);
            return NULL;
        }

        //
        // Flip the bitmap
        //
        hOld_bm1 = (HBITMAP)SelectObject(hdcMem1, hbmOrig);
        hOld_bm2 = (HBITMAP)SelectObject(hdcMem2 , hbm );

        SET_DC_RTL_MIRRORED(hdcMem2);
        BitBlt(hdcMem2, IncOne, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY);

        SelectObject(hdcMem1, hOld_bm1 );
        SelectObject(hdcMem1, hOld_bm2 );

        DeleteDC(hdcMem1);
        DeleteDC(hdcMem2);

        ReleaseDC(NULL, hdc);
    }

    return hbm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\util.cpp ===
#include "util.h"
#include "rcids.h"
#include "psapi.h"

#include <regstr.h>
#include <ntddapmt.h>

#define DECL_CRTFREE
#include <crtfree.h>

#include <qsort.h>

#include <ddraw.h>      // DirectDraw stuff..

#define STRSAFE_NO_CB_FUNCTIONS
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//////////////////////////////////////////////////////////////////////////
//
// util.cpp
//
// miscellaneous explorer helper functions
//
//////////////////////////////////////////////////////////////////////////


ULONG _RegisterNotify(HWND hwnd, UINT nMsg, LPITEMIDLIST pidl, BOOL fRecursive)
{
    SHChangeNotifyEntry fsne;

    fsne.fRecursive = fRecursive;
    fsne.pidl = pidl;

    //
    // Don't watch for attribute changes since we just want the
    // name and icon.  For example, if a printer is paused, we don't
    // want to re-enumerate everything.
    //
    return SHChangeNotifyRegister(hwnd, SHCNRF_NewDelivery | SHCNRF_ShellLevel | SHCNRF_InterruptLevel,
        ((SHCNE_DISKEVENTS | SHCNE_UPDATEIMAGE) & ~SHCNE_ATTRIBUTES), nMsg, 1, &fsne);
}

void _UnregisterNotify(ULONG nNotify)
{
    if (nNotify)
        SHChangeNotifyDeregister(nNotify);
}

// Mirror a bitmap in a DC (mainly a text object in a DC)
//
// [samera]
//
void _MirrorBitmapInDC(HDC hdc , HBITMAP hbmOrig)
{
    HDC     hdcMem;
    HBITMAP hbm;
    BITMAP  bm;

    if (!GetObject(hbmOrig, sizeof(bm) , &bm))
        return;

    hdcMem = CreateCompatibleDC(hdc);

    if (!hdcMem)
        return;

    hbm = CreateCompatibleBitmap(hdc , bm.bmWidth , bm.bmHeight);

    if (!hbm)
    {
        DeleteDC(hdcMem);
        return;
    }

    //
    // Flip the bitmap
    //
    SelectObject(hdcMem , hbm);
    SET_DC_RTL_MIRRORED(hdcMem);

    BitBlt(hdcMem , 0 , 0 , bm.bmWidth , bm.bmHeight ,
          hdc , 0 , 0 , SRCCOPY);

    SET_DC_LAYOUT(hdcMem,0);

    //
    // The offset by 1 in hdcMem is to solve the off-by-one problem. Removed.
    // [samera]
    //
    BitBlt(hdc , 0 , 0 , bm.bmWidth , bm.bmHeight ,
          hdcMem , 0 , 0 , SRCCOPY);


    DeleteDC(hdcMem);
    DeleteObject(hbm);

    return;
}

// Sort of a registry equivalent of the profile API's.
BOOL Reg_GetStruct(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, void *pData, DWORD *pcbData)
{
    BOOL fRet = FALSE;
 
    if (!g_fCleanBoot)
    {
        fRet = ERROR_SUCCESS == SHGetValue(hkey, pszSubKey, pszValue, NULL, pData, pcbData);
    }

    return fRet;
}

// Sort of a registry equivalent of the profile API's.
BOOL Reg_SetStruct(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, void *lpData, DWORD cbData)
{
    HKEY hkeyNew = hkey;
    BOOL fRet = FALSE;

    if (pszSubKey)
    {
        if (RegCreateKeyEx(hkey, pszSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkeyNew, NULL) != ERROR_SUCCESS)
        {
            return fRet;
        }
    }

    if (RegSetValueEx(hkeyNew, pszValue, 0, REG_BINARY, (BYTE*)lpData, cbData) == ERROR_SUCCESS)
    {
        fRet = TRUE;
    }

    if (pszSubKey)
        RegCloseKey(hkeyNew);

    return fRet;
}


HMENU LoadMenuPopup(LPCTSTR id)
{
    HMENU hMenuSub = NULL;
    HMENU hMenu = LoadMenu(hinstCabinet, id);
    if (hMenu) {
        hMenuSub = GetSubMenu(hMenu, 0);
        if (hMenuSub) {
            RemoveMenu(hMenu, 0, MF_BYPOSITION);
        }
        DestroyMenu(hMenu);
    }

    return hMenuSub;
}

// this gets hotkeys for files given a folder and a pidls  it is much faster
// than _GetHotkeyFromPidls since it does not need to bind to an IShellFolder
// to interrogate it.  if you have access to the item's IShellFolder, call this
// one, especially in a loop.
//
WORD _GetHotkeyFromFolderItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    WORD wHotkey = 0;
    DWORD dwAttrs = SFGAO_LINK;

    // Make sure it is an SFGAO_LINK so we don't load a big handler dll
    // just to get back E_NOINTERFACE...
    if (SUCCEEDED(psf->GetAttributesOf(1, &pidl, &dwAttrs)) &&
        (dwAttrs & SFGAO_LINK))
    {
        IShellLink *psl;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IShellLink, NULL, &psl))))
        {
            psl->GetHotkey(&wHotkey);
            psl->Release();
        }
    }
    return wHotkey;
}


// Just like shells SHRestricted() only this put up a message if the restricion
// is in effect.
BOOL _Restricted(HWND hwnd, RESTRICTIONS rest)
{
    if (SHRestricted(rest))
    {
        ShellMessageBox(hinstCabinet, hwnd, MAKEINTRESOURCE(IDS_RESTRICTIONS),
            MAKEINTRESOURCE(IDS_RESTRICTIONSTITLE), MB_OK|MB_ICONSTOP);
        return TRUE;
    }
    return FALSE;
}

int Window_GetClientGapHeight(HWND hwnd)
{
    RECT rc;

    SetRectEmpty(&rc);
    AdjustWindowRectEx(&rc, GetWindowLong(hwnd, GWL_STYLE), FALSE, GetWindowLong(hwnd, GWL_EXSTYLE));
    return RECTHEIGHT(rc);
}

const TCHAR c_szConfig[] = REGSTR_KEY_CONFIG;
const TCHAR c_szSlashDisplaySettings[] = TEXT("\\") REGSTR_PATH_DISPLAYSETTINGS;
const TCHAR c_szResolution[] = REGSTR_VAL_RESOLUTION;

//
// GetMinDisplayRes
//
// walk all the configs and find the minimum display resolution.
//
// when doing a hot undock we have no idea what config we are
// going to undock into.
//
// we want to put the display into a "common" mode that all configs
// can handle so we dont "fry" the display when we wake up in the
// new mode.
//
DWORD GetMinDisplayRes(void)
{
    TCHAR ach[128];
    ULONG cb;
    HKEY hkey;
    HKEY hkeyT;
    int i, n;
    int xres=0;
    int yres=0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szConfig, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        for (n=0; RegEnumKey(hkey, n, ach, ARRAYSIZE(ach)) == ERROR_SUCCESS; n++)
        {
            StrCatBuff(ach, c_szSlashDisplaySettings, ARRAYSIZE(ach));  // 0000\Display\Settings

            TraceMsg(TF_TRAY, "GetMinDisplayRes: found config %s", ach);

            if (RegOpenKeyEx(hkey, ach, 0, KEY_READ, &hkeyT) == ERROR_SUCCESS)
            {
                cb = sizeof(ach);
                ach[0] = 0;
                RegQueryValueEx(hkeyT, c_szResolution, 0, NULL, (LPBYTE) &ach[0], &cb);

                TraceMsg(TF_TRAY, "GetMinDisplayRes: found res %s", ach);

                if (ach[0])
                {
                    i = StrToInt(ach);

                    if (i < xres || xres == 0)
                        xres = i;

                    for (i=1;ach[i] && ach[i-1]!=TEXT(','); i++)
                        ;

                    i = StrToInt(ach + i);

                    if (i < yres || yres == 0)
                        yres = i;
                }
                else
                {
                    xres = 640;
                    yres = 480;
                }

                RegCloseKey(hkeyT);
            }
        }
        RegCloseKey(hkey);
    }

    TraceMsg(TF_TRAY, "GetMinDisplayRes: xres=%d yres=%d", xres, yres);

    if (xres == 0 || yres == 0)
        return MAKELONG(640, 480);
    else
        return MAKELONG(xres, yres);
}


//
//  the user has done a un-doc or re-doc we may need to switch
//  to a new display mode.
//
//  if fCritical is set the mode switch is critical, show a error
//  if it does not work.
//
void HandleDisplayChange(int x, int y, BOOL fCritical)
{
    DEVMODE dm;
    LONG err;
    HDC hdc;

    //
    //  try to change into the mode specific to this config
    //  HKEY_CURRENT_CONFIG has already been updated by PnP
    //  so all we have to do is re-init the current display
    //
    //  we cant default to current bpp because we may have changed configs.
    //  and the bpp may be different in the new config.
    //
    dm.dmSize   = sizeof(dm);
    dm.dmFields = DM_BITSPERPEL;

    hdc = GetDC(NULL);
    dm.dmBitsPerPel = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(NULL, hdc);

    if (x + y)
    {
        dm.dmFields    |= DM_PELSWIDTH|DM_PELSHEIGHT;
        dm.dmPelsWidth  = x;
        dm.dmPelsHeight = y;
    }

    err = ChangeDisplaySettings(&dm, 0);

    if (err != 0 && fCritical)
    {
        //
        //  if it fails make a panic atempt to try 640x480, if
        //  that fails also we should put up a big error message
        //  in text mode and tell the user he is in big trouble.
        //
        dm.dmFields     = DM_PELSWIDTH|DM_PELSHEIGHT|DM_BITSPERPEL;
        dm.dmPelsWidth  = 640;
        dm.dmPelsHeight = 480;

        err = ChangeDisplaySettings(&dm, 0);
    }
}


UINT GetDDEExecMsg()
{
    static UINT uDDEExec = 0;

    if (!uDDEExec)
        uDDEExec = RegisterWindowMessage(TEXT("DDEEXECUTESHORTCIRCUIT"));

    return uDDEExec;
}

TCHAR const c_szCheckAssociations[] = TEXT("CheckAssociations");

// Returns true if GrpConv says we should check extensions again (and then
// clears the flag).
// The assumption here is that runonce gets run before we call this (so
// GrpConv -s can set this).
BOOL _CheckAssociations(void)
{
    DWORD dw = 0, cb = sizeof(dw);

    if (Reg_GetStruct(g_hkeyExplorer, NULL, c_szCheckAssociations, &dw, &cb) && dw)
    {
        dw = 0;
        Reg_SetStruct(g_hkeyExplorer, NULL, c_szCheckAssociations, &dw, sizeof(dw));
        return TRUE;
    }

    return FALSE;
}


void _ShowFolder(HWND hwnd, UINT csidl, UINT uFlags)
{
    SHELLEXECUTEINFO shei = { 0 };

    shei.cbSize     = sizeof(shei);
    shei.fMask      = SEE_MASK_IDLIST | SEE_MASK_INVOKEIDLIST;
    shei.nShow      = SW_SHOWNORMAL;

    if (_Restricted(hwnd, REST_NOSETFOLDERS))
        return;

    if (uFlags & COF_EXPLORE)
        shei.lpVerb = TEXT("explore");

    shei.lpIDList = SHCloneSpecialIDList(NULL, csidl, FALSE);
    if (shei.lpIDList)
    {
        ShellExecuteEx(&shei);
        ILFree((LPITEMIDLIST)shei.lpIDList);
    }
}

EXTERN_C IShellFolder* BindToFolder(LPCITEMIDLIST pidl)
{
    IShellFolder *psfDesktop;
    if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
    {
        IShellFolder* psf;
        psfDesktop->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, &psf));
        psfDesktop->Release();    // not really needed
        return psf;
    }
    return NULL;
}


// RunSystemMonitor
//
// Launches system monitor (taskmgr.exe), which is expected to be able
// to find any currently running instances of itself

void RunSystemMonitor(void)
{
    STARTUPINFO startup;
    PROCESS_INFORMATION pi;
    TCHAR szTaskMan[MAX_PATH];

    if (GetSystemDirectory(szTaskMan, ARRAYSIZE(szTaskMan)))
    {
        if (PathAppend(szTaskMan, TEXT("taskmgr.exe")))
        {
            PathQuoteSpaces(szTaskMan);

            startup.cb = sizeof(startup);
            startup.lpReserved = NULL;
            startup.lpDesktop = NULL;
            startup.lpTitle = NULL;
            startup.dwFlags = 0L;
            startup.cbReserved2 = 0;
            startup.lpReserved2 = NULL;
            startup.wShowWindow = SW_SHOWNORMAL;

            // Used to pass "taskmgr.exe" here, but NT faulted in CreateProcess
            // Probably they are wacking on the command line, which is bogus, but
            // then again the paremeter is not marked const...
            if (CreateProcess(szTaskMan, szTaskMan, NULL, NULL, FALSE, 0,
                            NULL, NULL, &startup, &pi))
            {
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }
        }
    }
}


HRESULT SHIsParentOwnerOrSelf(HWND hwndParent, HWND hwnd)
{
    while (hwnd)
    {
        if (hwnd == hwndParent)
            return S_OK;

        hwnd = GetParent(hwnd);
    }

    return E_FAIL;
}

void SHAllowSetForegroundWindow(HWND hwnd)
{
    DWORD dwProcessId = 0;
    GetWindowThreadProcessId(hwnd, &dwProcessId);
    AllowSetForegroundWindow(dwProcessId);
}

//////////////////////////////////////////////////////////////////////////
//
// BEGIN scary crt-wannabe code
//
// This code implements some stuff that crt main ordinarily does for
// you.  In particular it implements construction and destruction of
// static C++ objects.  We can't just use crt main, unfortunately,
// because we need to reserve control over whether or not ExitProcess
// is called when our WinMain returns (see SVTRAY_EXITEXPLORER).
//
//////////////////////////////////////////////////////////////////////////

typedef void (__cdecl*_PVFV)(void);

extern "C" _PVFV* __onexitbegin = NULL;
extern "C" _PVFV* __onexitend = NULL;

extern "C" _PVFV __xc_a[], __xc_z[];    // C++ initializers

HANDLE g_hProcessHeap;

void DoInitialization()
{
    // code swiped from atl40\atlimpl.cpp

    g_hProcessHeap = GetProcessHeap();

    _PVFV* pf;

    // Call initialization routines (contructors for globals, etc.)

    for (pf = __xc_a; pf < __xc_z; pf++)
    {
       if (*pf != NULL)
       {
          (**pf)();
       }
    }
}

void DoCleanup()
{
    // code swiped from atl40\atlimpl.cpp

    // leaving this code turned off for now, otherwise the tray object
    // will be destroyed on the desktop thread which is bad because the
    // tray thread might still be running... just leak these objects
    // (our process is going away immediately anyhow, so who cares) until
    // we think of something better to do
#ifdef DESTROY_STATIC_OBJECTS
    _PVFV* pf;

    // Call routines registered with atexit() from most recently registered
    // to least recently registered
    if (__onexitbegin != NULL)
    {
        for (pf = __onexitend - 1; pf >= __onexitbegin; pf--)
        {
            (**pf)();
        }
    }
#endif

    HeapFree(g_hProcessHeap, 0, __onexitbegin);
    __onexitbegin = NULL;
    __onexitend = NULL;
}

//
// You might be wondering, "What's the deal with atexit?"
//
// This is the mechanism which static C++ objects use to register
// their destructors so that they get called when WinMain is finished.
// Each such object constructor simply calls atexit with the destructor
// function pointer.  atexit saves the pointers off in __onexitbegin.
// DoCleanup iterates through __onexitbegin and calls each destructor.
//
EXTERN_C int __cdecl atexit(_PVFV pf)
{
    if (__onexitbegin == NULL)
    {
        __onexitbegin = (_PVFV*)HeapAlloc(g_hProcessHeap, 0, 16 * sizeof(_PVFV));
        if (__onexitbegin == NULL)
        {
            return(-1);
        }
        __onexitend = __onexitbegin;
    }

    ULONG_PTR nCurrentSize = HeapSize(g_hProcessHeap, 0, __onexitbegin);

    if (nCurrentSize + sizeof(_PVFV) < 
        ULONG_PTR(((const BYTE*)__onexitend - (const BYTE*)__onexitbegin)))
    {
        _PVFV* pNew;

        pNew = (_PVFV*)HeapReAlloc(g_hProcessHeap, 0, __onexitbegin, 2*nCurrentSize);
        if (pNew == NULL)
        {
            return(-1);
        }
    }

    *__onexitend = pf;
    __onexitend++;

    return(0);
}

//////////////////////////////////////////////////////////////////////////
//
// END scary crt-wannabe code
//
//////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////
//
// BEGIN stuff moved over from APITHK.C
//
//////////////////////////////////////////////////////////////////////////

/*----------------------------------------------------------
Returns: If the Eject PC option is available
*/
BOOL IsEjectAllowed(BOOL fForceUpdateCache)
{
    static BOOL fCachedEjectAllowed = FALSE;
    static BOOL fCacheValid = FALSE;

    // we called the function before and the caller did not
    // pass fForceUpdateCache so just use the cached value
    if (fForceUpdateCache || !fCacheValid)
    {
        CM_Is_Dock_Station_Present(&fCachedEjectAllowed);
    }
    return fCachedEjectAllowed;
}

/*----------------------------------------------------------
Purpose: Checks if system is BiDi locale, and if so sets the 
         date format to DATE_RTLREADING.
*/
void SetBiDiDateFlags(int *piDateFormat)
{
    // GetLocaleInfo with LOCALE_FONTSIGNATURE always returns 16 WCHARs (even w/o Unicode support)
    WCHAR wchLCIDFontSignature[16];
    CALTYPE defCalendar;
    LCID lcidUserDefault = GetUserDefaultLCID();
    if (!lcidUserDefault)
        return;

    // Let's verify the bits we have a BiDi UI locale. This will work for Win9x and NT
    if ((LANG_ARABIC == PRIMARYLANGID(LANGIDFROMLCID(lcidUserDefault))) ||
        (LANG_HEBREW == PRIMARYLANGID(LANGIDFROMLCID(lcidUserDefault))) ||
        ((GetLocaleInfo(LOCALE_USER_DEFAULT,
                        LOCALE_FONTSIGNATURE,
                        (TCHAR *) &wchLCIDFontSignature[0],
                        (sizeof(wchLCIDFontSignature)/sizeof(WCHAR)))) &&
         (wchLCIDFontSignature[7] & (WCHAR)0x0800))
      )
    {
        //
        // Let's verify the calendar type.
        TCHAR szCalendarType[64];
        if (GetLocaleInfo(LOCALE_USER_DEFAULT, 
                          LOCALE_ICALENDARTYPE, 
                          (TCHAR *) &szCalendarType[0],
                          (sizeof(szCalendarType)/sizeof(TCHAR))))
        {
            defCalendar = StrToInt((TCHAR *)&szCalendarType[0]);
            if ((defCalendar == CAL_GREGORIAN)              ||
                (defCalendar == CAL_HIJRI)                  ||
                (defCalendar == CAL_GREGORIAN_ARABIC)       ||
                (defCalendar == CAL_HEBREW)                 ||
                (defCalendar == CAL_GREGORIAN_XLIT_ENGLISH) ||
                (defCalendar == CAL_GREGORIAN_XLIT_FRENCH))
            {
                *piDateFormat |= DATE_RTLREADING;
            }
            else
            {
                *piDateFormat |= DATE_LTRREADING;
            }
        }
    }
}

// first chance hook at all HSHELL_APPCOMMAND commands
// this covers the below keys that are registered by shell32.dll
// that includes
//      APPCOMMAND_LAUNCH_MEDIA_SELECT
//      APPCOMMAND_BROWSER_HOME
//      APPCOMMAND_LAUNCH_APP1
//      APPCOMMAND_LAUNCH_APP2
//      APPCOMMAND_LAUNCH_MAIL
//
// registry format:
//      HKCU | HKLM
//      Software\Microsoft\Windows\CurrentVersion\Explorer\AppKey\<value>
//          <value> is one of the APPCOMMAND_ constants (see winuser.h)
// 
//      create values with one of the following names
//        "ShellExecute" = <cmd line>   
//                          calc.exe, ::{my computer}, etc
//                          pass this strin to ShellExecute()
//        "Association" = <extension>
//                          .mp3, http
//                          launch the program associated with this file type
//        "RegisteredApp" = <app name>   
//                          Mail, Contacts, etc
//                          launch the registered app for this 

BOOL AppCommandTryRegistry(int cmd)
{
    BOOL bRet = FALSE;
    TCHAR szKey[128];
    HUSKEY hkey;

    wnsprintf(szKey, ARRAYSIZE(szKey), REGSTR_PATH_EXPLORER TEXT("\\AppKey\\%d"), cmd);

    if (ERROR_SUCCESS == SHRegOpenUSKey(szKey, KEY_READ, NULL, &hkey, FALSE))
    {
        TCHAR szCmdLine[MAX_PATH];
        DWORD cb = sizeof(szCmdLine);

        szCmdLine[0] = 0;

        if (ERROR_SUCCESS != SHRegQueryUSValue(hkey, TEXT("ShellExecute"), NULL, szCmdLine, &cb, FALSE, NULL, 0))
        {
            TCHAR szExt[MAX_PATH];
            cb = ARRAYSIZE(szExt);
            if (ERROR_SUCCESS == SHRegQueryUSValue(hkey, TEXT("Association"), NULL, szExt, &cb, FALSE, NULL, 0))
            {
                cb = ARRAYSIZE(szCmdLine);
                AssocQueryString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, szExt, NULL, szCmdLine, &cb);
            }
            else
            {
                cb = ARRAYSIZE(szExt);
                if (ERROR_SUCCESS == SHRegQueryUSValue(hkey, TEXT("RegisteredApp"), NULL, szExt, &cb, FALSE, NULL, 0))
                {
                    WCHAR szAppW[MAX_PATH];
                    SHTCharToUnicode(szExt, szAppW, ARRAYSIZE(szAppW));
                    SHRunIndirectRegClientCommand(NULL, szAppW);
                    szCmdLine[0] = 0;
                    bRet = TRUE;
                }
            }
        }

        if (szCmdLine[0])
        {
            // ShellExecuteRegApp does all the parsing for us, so apps
            // can register appcommands with command line arguments.
            // Pass the RRA_DELETE flag so this won't get logged as a failed
            // startup app.
            ShellExecuteRegApp(szCmdLine, RRA_DELETE | RRA_NOUI);
            bRet = TRUE;
        }

        SHRegCloseUSKey(hkey);
    }

    return bRet;
}

//////////////////////////////////////////////////////////////////////////
//
// END stuff moved over from APITHK.C
//
//////////////////////////////////////////////////////////////////////////

void RECTtoRECTL(LPRECT prc, LPRECTL lprcl)
{
    lprcl->left = prc->left;
    lprcl->top = prc->top;
    lprcl->bottom = prc->bottom;
    lprcl->right = prc->right;
}

int Toolbar_GetUniqueID(HWND hwndTB)
{
    int iCount = ToolBar_ButtonCount(hwndTB);

    int *rgCmds = (int *)malloc(iCount * sizeof(*rgCmds));

    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(TBBUTTONINFO);
    tbbi.dwMask = TBIF_BYINDEX | TBIF_COMMAND;

    int iCmd = 0;

    if (rgCmds)
    {
        int i;
        for (i = 0; i < iCount; i++)
        {
            ToolBar_GetButtonInfo(hwndTB, i, &tbbi);
            rgCmds[i] = tbbi.idCommand;
        }

        QSort<int>(rgCmds, iCount, TRUE);

        for (i = 0; i < iCount; i++)
        {
            if (iCmd != rgCmds[i])
                break;
            iCmd++;
        }
        free(rgCmds);
    }
    else // malloc failed, do it the slow way!
    {
        int i;
        for (;;) // loop till break;
        {
            BOOL fFoundGoodCmd = TRUE;
            for (i = 0; i < iCount; i++)
            {
                ToolBar_GetButtonInfo(hwndTB, i, &tbbi);
                
                if (iCmd == tbbi.idCommand) // Collision, skip to the next iCmd
                {
                    fFoundGoodCmd = FALSE;
                    break;
                }
            }
            if (fFoundGoodCmd)
                break;

            iCmd++; // Try next value
        }
    }

    return iCmd;
}

BYTE ToolBar_GetStateByIndex(HWND hwnd, INT_PTR iIndex)
{
    TBBUTTONINFO tbb;
    tbb.cbSize = sizeof(TBBUTTONINFO);
    tbb.dwMask = TBIF_STATE | TBIF_BYINDEX;
    ToolBar_GetButtonInfo(hwnd, iIndex, &tbb);
    return tbb.fsState;
}

int ToolBar_IndexToCommand(HWND hwnd, INT_PTR iIndex)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = sizeof(TBBUTTONINFO);
    tbbi.dwMask = TBIF_COMMAND | TBIF_BYINDEX;
    ToolBar_GetButtonInfo(hwnd, iIndex, &tbbi);
    return tbbi.idCommand;
}

//
//  Determine the flags for creating the tray notify icon imagelist.
//
//
UINT SHGetImageListFlags(HWND hwnd)
{
    UINT flags = ILC_MASK | ILC_COLOR32;

    // Mirrored if we are RTL
    if (IS_WINDOW_RTL_MIRRORED(hwnd))
    {
        flags |= ILC_MIRROR;
    }

    return flags;
}

// Copied from \\index2\src\sdktools\psapi\module.c
BOOL
SHFindModule(
    IN HANDLE hProcess,
    IN HMODULE hModule,
    OUT PLDR_DATA_TABLE_ENTRY LdrEntryData
    )

/*++

Routine Description:

    This function retrieves the loader table entry for the specified
    module.  The function copies the entry into the buffer pointed to
    by the LdrEntryData parameter.

Arguments:

    hProcess - Supplies the target process.

    hModule - Identifies the module whose loader entry is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    LdrEntryData - Returns the requested table entry.

Return Value:

    TRUE if a matching entry was found.

--*/

{
    PROCESS_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    PPEB Peb;
    PPEB_LDR_DATA Ldr;
    PLIST_ENTRY LdrHead;
    PLIST_ENTRY LdrNext;

    Status = NtQueryInformationProcess(
                hProcess,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
                );

    if ( !NT_SUCCESS(Status) ) {
        SetLastError( RtlNtStatusToDosError( Status ) );
        return(FALSE);
    }

    Peb = BasicInfo.PebBaseAddress;


    if ( !ARGUMENT_PRESENT( hModule )) {
        if (!ReadProcessMemory(hProcess, &Peb->ImageBaseAddress, &hModule, sizeof(hModule), NULL)) {
            return(FALSE);
        }
    }

    //
    // Ldr = Peb->Ldr
    //

    if (!ReadProcessMemory(hProcess, &Peb->Ldr, &Ldr, sizeof(Ldr), NULL)) {
        return (FALSE);
    }

    if (!Ldr) {
        // Ldr might be null (for instance, if the process hasn't started yet).
        SetLastError(ERROR_INVALID_HANDLE);
        return (FALSE);
    }


    LdrHead = &Ldr->InMemoryOrderModuleList;

    //
    // LdrNext = Head->Flink;
    //

    if (!ReadProcessMemory(hProcess, &LdrHead->Flink, &LdrNext, sizeof(LdrNext), NULL)) {
        return(FALSE);
    }

    while (LdrNext != LdrHead) {
        PLDR_DATA_TABLE_ENTRY LdrEntry;

        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);

        if (!ReadProcessMemory(hProcess, LdrEntry, LdrEntryData, sizeof(*LdrEntryData), NULL)) {
            return(FALSE);
        }

        if ((HMODULE) LdrEntryData->DllBase == hModule) {
            return(TRUE);
        }

        LdrNext = LdrEntryData->InMemoryOrderLinks.Flink;
    }

    SetLastError(ERROR_INVALID_HANDLE);
    return(FALSE);
}

// Copied from \\index2\src\sdktools\psapi\module.c
DWORD
WINAPI
SHGetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    )

/*++

Routine Description:

    This function retrieves the full pathname of the executable file
    from which the specified module was loaded.  The function copies the
    null-terminated filename into the buffer pointed to by the
    lpFilename parameter.

Routine Description:

    hModule - Identifies the module whose executable file name is being
        requested.  A value of NULL references the module handle
        associated with the image file that was used to create the
        process.

    lpFilename - Points to the buffer that is to receive the filename.

    nSize - Specifies the maximum number of characters to copy.  If the
        filename is longer than the maximum number of characters
        specified by the nSize parameter, it is truncated.

Return Value:

    The return value specifies the actual length of the string copied to
    the buffer.  A return value of zero indicates an error and extended
    error status is available using the GetLastError function.

Arguments:

--*/

{
    LDR_DATA_TABLE_ENTRY LdrEntryData;
    DWORD cb;

    if (!SHFindModule(hProcess, hModule, &LdrEntryData)) {
        return(0);
        }

    nSize *= sizeof(WCHAR);

    cb = LdrEntryData.FullDllName.MaximumLength;
    if ( nSize < cb ) {
        cb = nSize;
        }

    if (!ReadProcessMemory(hProcess, LdrEntryData.FullDllName.Buffer, lpFilename, cb, NULL)) {
        return(0);
        }

    if (cb == LdrEntryData.FullDllName.MaximumLength) {
        cb -= sizeof(WCHAR);
        }

    return(cb / sizeof(WCHAR));
}


HRESULT SHExeNameFromHWND(HWND hWnd, LPWSTR pszExeName, UINT cchExeName)
{

    /* Getting the Friendly App Name is fun, this is the general process:
        1) Get ProcessId from the HWND
        2) Open that process
        3) Query for it's basic information, essentially getting the PEB
        4) Read the PEB information from the process' memory
        5) In the PEB information is the name of the imagefile (i.e. C:\WINNT\EXPLORER.EXE)
    */

    HRESULT hr = S_OK;
    UINT uWritten = 0;

    pszExeName[0] = 0;

    DWORD dwProcessID;
    DWORD dwThreadID = GetWindowThreadProcessId(hWnd, &dwProcessID);
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwProcessID);
    if (hProcess)
    {
        uWritten = SHGetModuleFileNameExW(hProcess, 0, pszExeName, cchExeName);
        pszExeName[cchExeName-1] = 0;
        CloseHandle(hProcess);
    }

    if (!uWritten)
        hr = E_FAIL;
        
    return hr;
}

// Gets the Monitor's bounding or work rectangle, if the hMon is bad, return
// the primary monitor's bounding rectangle. 
BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork)
{
    MONITORINFO mi; 
    mi.cbSize = sizeof(mi);
    if (hMon && GetMonitorInfo(hMon, &mi))
    {
        if (!prc)
            return TRUE;
        
        else if (bWork)
            CopyRect(prc, &mi.rcWork);
        else 
            CopyRect(prc, &mi.rcMonitor);
        
        return TRUE;
    }
    
    if (prc)
        SetRect(prc, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    return FALSE;
}

BOOL ShouldTaskbarAnimate()
{
    BOOL fAnimate;
    SystemParametersInfo(SPI_GETUIEFFECTS, 0, (PVOID) &fAnimate, 0);
    if (fAnimate)
    {
        if (GetSystemMetrics(SM_REMOTESESSION) || GetSystemMetrics(SM_REMOTECONTROL))
        {
            DWORD dwSessionID = NtCurrentPeb()->SessionId;

            WCHAR szRegKey[MAX_PATH];
            wnsprintf(szRegKey, ARRAYSIZE(szRegKey), L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Remote\\%d", dwSessionID);

            fAnimate = SHRegGetBoolUSValue(szRegKey, TEXT("TaskbarAnimations"), FALSE, TRUE);
        }
        else
        {
            fAnimate = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("TaskbarAnimations"), FALSE, TRUE);
        }
    }
    return fAnimate;
}

void FillRectClr(HDC hdc, LPRECT prc, COLORREF clr)
{
    COLORREF clrSave = SetBkColor(hdc, clr);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL);
    SetBkColor(hdc, clrSave);
}

BOOL CCDrawEdge(HDC hdc, LPRECT lprc, UINT edge, UINT flags, LPCOLORSCHEME lpclrsc)
{
    RECT    rc, rcD;
    UINT    bdrType;
    COLORREF clrTL, clrBR;    

    //
    // Enforce monochromicity and flatness
    //    

    // if (oemInfo.BitCount == 1)
    //    flags |= BF_MONO;
    if (flags & BF_MONO)
        flags |= BF_FLAT;    

    CopyRect(&rc, lprc);

    //
    // Draw the border segment(s), and calculate the remaining space as we
    // go.
    //
    if (bdrType = (edge & BDR_OUTER))
    {
DrawBorder:
        //
        // Get colors.  Note the symmetry between raised outer, sunken inner and
        // sunken outer, raised inner.
        //

        if (flags & BF_FLAT)
        {
            if (flags & BF_MONO)
                clrBR = (bdrType & BDR_OUTER) ? GetSysColor(COLOR_WINDOWFRAME) : GetSysColor(COLOR_WINDOW);
            else
                clrBR = (bdrType & BDR_OUTER) ? GetSysColor(COLOR_BTNSHADOW): GetSysColor(COLOR_BTNFACE);
            
            clrTL = clrBR;
        }
        else
        {
            // 5 == HILIGHT
            // 4 == LIGHT
            // 3 == FACE
            // 2 == SHADOW
            // 1 == DKSHADOW

            switch (bdrType)
            {
                // +2 above surface
                case BDR_RAISEDOUTER:           // 5 : 4
                    clrTL = ((flags & BF_SOFT) ? GetSysColor(COLOR_BTNHIGHLIGHT) : GetSysColor(COLOR_3DLIGHT));
                    clrBR = GetSysColor(COLOR_3DDKSHADOW);     // 1
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnHighlight;
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnShadow;
                    }                                            
                    break;

                // +1 above surface
                case BDR_RAISEDINNER:           // 4 : 5
                    clrTL = ((flags & BF_SOFT) ? GetSysColor(COLOR_3DLIGHT) : GetSysColor(COLOR_BTNHIGHLIGHT));
                    clrBR = GetSysColor(COLOR_BTNSHADOW);       // 2
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnHighlight;
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnShadow;
                    }                                            
                    break;

                // -1 below surface
                case BDR_SUNKENOUTER:           // 1 : 2
                    clrTL = ((flags & BF_SOFT) ? GetSysColor(COLOR_3DDKSHADOW) : GetSysColor(COLOR_BTNSHADOW));
                    clrBR = GetSysColor(COLOR_BTNHIGHLIGHT);      // 5
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnShadow;
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnHighlight;                        
                    }
                    break;

                // -2 below surface
                case BDR_SUNKENINNER:           // 2 : 1
                    clrTL = ((flags & BF_SOFT) ? GetSysColor(COLOR_BTNSHADOW) : GetSysColor(COLOR_3DDKSHADOW));
                    clrBR = GetSysColor(COLOR_3DLIGHT);        // 4
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnShadow;
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnHighlight;                        
                    }
                    break;

                default:
                    return(FALSE);
            }
        }

        //
        // Draw the sides of the border.  NOTE THAT THE ALGORITHM FAVORS THE
        // BOTTOM AND RIGHT SIDES, since the light source is assumed to be top
        // left.  If we ever decide to let the user set the light source to a
        // particular corner, then change this algorithm.
        //
            
        // Bottom Right edges
        if (flags & (BF_RIGHT | BF_BOTTOM))
        {            
            // Right
            if (flags & BF_RIGHT)
            {       
                rc.right -= g_cxBorder;
                // PatBlt(hdc, rc.right, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rcD.left = rc.right;
                rcD.right = rc.right + g_cxBorder;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom;

                FillRectClr(hdc, &rcD, clrBR);
            }
            
            // Bottom
            if (flags & BF_BOTTOM)
            {
                rc.bottom -= g_cyBorder;
                // PatBlt(hdc, rc.left, rc.bottom, rc.right - rc.left, g_cyBorder, PATCOPY);
                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.bottom;
                rcD.bottom = rc.bottom + g_cyBorder;

                FillRectClr(hdc, &rcD, clrBR);
            }
        }
        
        // Top Left edges
        if (flags & (BF_TOP | BF_LEFT))
        {
            // Left
            if (flags & BF_LEFT)
            {
                // PatBlt(hdc, rc.left, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rc.left += g_cxBorder;

                rcD.left = rc.left - g_cxBorder;
                rcD.right = rc.left;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom; 

                FillRectClr(hdc, &rcD, clrTL);
            }
            
            // Top
            if (flags & BF_TOP)
            {
                // PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, g_cyBorder, PATCOPY);
                rc.top += g_cyBorder;

                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.top - g_cyBorder;
                rcD.bottom = rc.top;

                FillRectClr(hdc, &rcD, clrTL);
            }
        }
        
    }

    if (bdrType = (edge & BDR_INNER))
    {
        //
        // Strip this so the next time through, bdrType will be 0.
        // Otherwise, we'll loop forever.
        //
        edge &= ~BDR_INNER;
        goto DrawBorder;
    }

    //
    // Fill the middle & clean up if asked
    //
    if (flags & BF_MIDDLE)    
        FillRectClr(hdc, &rc, (flags & BF_MONO) ? GetSysColor(COLOR_WINDOW) : GetSysColor(COLOR_BTNFACE));

    if (flags & BF_ADJUST)
        CopyRect(lprc, &rc);

    return(TRUE);
}

void DrawBlankButton(HDC hdc, LPRECT lprc, DWORD wControlState)
{
    BOOL fAdjusted;

    if (wControlState & (DCHF_HOT | DCHF_PUSHED) &&
        !(wControlState & DCHF_NOBORDER)) {
        COLORSCHEME clrsc;

        clrsc.dwSize = 1;
        if (GetBkColor(hdc) == GetSysColor(COLOR_BTNSHADOW)) {
            clrsc.clrBtnHighlight = GetSysColor(COLOR_BTNHIGHLIGHT);
            clrsc.clrBtnShadow = GetSysColor(COLOR_BTNTEXT);
        } else
            clrsc.clrBtnHighlight = clrsc.clrBtnShadow = CLR_DEFAULT;

        // if button is both DCHF_HOT and DCHF_PUSHED, DCHF_HOT wins here
        CCDrawEdge(hdc, lprc, (wControlState & DCHF_HOT) ? BDR_RAISEDINNER : BDR_SUNKENOUTER,
                 (UINT) (BF_ADJUST | BF_RECT), &clrsc);
        fAdjusted = TRUE;
    } else {
        fAdjusted = FALSE;
    }

    if (!(wControlState & DCHF_TRANSPARENT))
        FillRectClr(hdc, lprc, GetBkColor(hdc));
    
    if (!fAdjusted)
        InflateRect(lprc, -g_cxBorder, -g_cyBorder);
}

#define CX_INCREMENT    1
#define CX_DECREMENT    (-CX_INCREMENT)

#define MIDPOINT(x1, x2)        ((x1 + x2) / 2)
#define CHEVRON_WIDTH(dSeg)     (4 * dSeg)

void DrawChevron(HDC hdc, LPRECT lprc, DWORD dwFlags)
{
    RECT rc;
    CopyRect(&rc, lprc);

    // draw the border and background
    DrawBlankButton(hdc, &rc, dwFlags);

    // offset the arrow if pushed
    if (dwFlags & DCHF_PUSHED)
        OffsetRect(&rc, CX_INCREMENT, CX_INCREMENT);

    // draw the arrow
    HBRUSH hbrSave = SelectBrush(hdc, GetSysColorBrush(COLOR_BTNTEXT));

    int dSeg = (g_cxVScroll / 7);
    dSeg = max(2, dSeg);

    BOOL fFlipped = (dwFlags & DCHF_FLIPPED);
    if (dwFlags & DCHF_HORIZONTAL)
    {
        // horizontal arrow
        int x = MIDPOINT(rc.left, rc.right - CHEVRON_WIDTH(dSeg));
        if (!fFlipped)
            x += dSeg;

        int yBase;
        if (dwFlags & DCHF_TOPALIGN)
            yBase = rc.top + (3 * dSeg);
        else
            yBase = MIDPOINT(rc.top, rc.bottom);


        for (int y = -dSeg; y <= dSeg; y++)
        {
            PatBlt(hdc, x,              yBase + y, dSeg, CX_INCREMENT, PATCOPY);
            PatBlt(hdc, x + (dSeg * 2), yBase + y, dSeg, CX_INCREMENT, PATCOPY);

            x += (fFlipped ? (y < 0) : (y >= 0)) ? CX_INCREMENT : CX_DECREMENT;
        }
    }
    else
    {
        // vertical arrow
        int y;
        if (dwFlags & DCHF_TOPALIGN)
            y = rc.top + CX_INCREMENT;
        else
        {
            y = MIDPOINT(rc.top, rc.bottom - CHEVRON_WIDTH(dSeg));
            if (!fFlipped)
            {
                y += dSeg;
            }
        }

        int xBase = MIDPOINT(rc.left, rc.right);

        for (int x = -dSeg; x <= dSeg; x++)
        {
            PatBlt(hdc, xBase + x, y,              CX_INCREMENT, dSeg, PATCOPY);
            PatBlt(hdc, xBase + x, y + (dSeg * 2), CX_INCREMENT, dSeg, PATCOPY);

            y += (fFlipped ? (x < 0) : (x >= 0)) ? CX_DECREMENT : CX_INCREMENT;
        }
    }

    // clean up
    SelectBrush(hdc, hbrSave);
}

void SetWindowStyle(HWND hwnd, DWORD dwStyle, BOOL fOn)
{
    if (hwnd)
    {
        DWORD_PTR dwStyleOld = GetWindowLongPtr(hwnd, GWL_STYLE);
        if (fOn)
        {
            dwStyleOld |= dwStyle;
        }
        else
        {
            dwStyleOld &= ~(DWORD_PTR)dwStyle;
        }
        SetWindowLongPtr(hwnd, GWL_STYLE, dwStyleOld);
    }
}

void SetWindowStyleEx(HWND hwnd, DWORD dwStyleEx, BOOL fOn)
{
    if (hwnd)
    {
        DWORD_PTR dwExStyleOld = GetWindowLongPtr(hwnd, GWL_EXSTYLE);
        if (fOn)
        {
            dwExStyleOld |= dwStyleEx;
        }
        else
        {
            dwExStyleOld &= ~(DWORD_PTR)dwStyleEx;
        }
        SetWindowLongPtr(hwnd, GWL_EXSTYLE, dwExStyleOld);
    }
}

// Review chrisny:  this can be moved into an object easily to handle generic droptarget, dropcursor
// , autoscrool, etc. . .
void _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject)
{
    RECT    rc;
    POINT   pt;

    GetWindowRect(hwndTarget, &rc);

    //
    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [msadek]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;
    pt.y = ptStart.y - rc.top;
    DAD_DragEnterEx2(hwndTarget, pt, pdtObject);
    return;
}

void _DragMove(HWND hwndTarget, const POINTL ptStart)
{
    RECT rc;
    POINT pt;

    GetWindowRect(hwndTarget, &rc);

    //
    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [msadek]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;
    pt.y = ptStart.y - rc.top;
    DAD_DragMove(pt);
    return;
}

// Gets the bits from the parent for a rect relative to the client
BOOL SHSendPrintRect(HWND hwndParent, HWND hwnd, HDC hdc, RECT* prc)
{
    HRGN hrgnOld = NULL;
    POINT pt;
    RECT rc;

    if (prc)
    {
        hrgnOld = CreateRectRgn(0,0,0,0);
        // Is there a clipping rgn set on the context already?
        if (GetClipRgn(hdc, hrgnOld) == 0)
        {
            // No, then get rid of the one I just created. NOTE: hrgnOld is NULL meaning we will 
            // remove the region later that we set in this next call to SelectClipRgn
            DeleteObject(hrgnOld);
            hrgnOld = NULL;
        }

        IntersectClipRect(hdc, prc->left, prc->top, prc->right, prc->bottom);
    }

    GetWindowRect(hwnd, &rc);
    MapWindowPoints(NULL, hwndParent, (POINT*)&rc, 2);

    GetViewportOrgEx(hdc, &pt);
    SetViewportOrgEx(hdc, pt.x - rc.left, pt.y - rc.top, NULL);
    SendMessage(hwndParent, WM_PRINTCLIENT, (WPARAM)hdc, (LPARAM)PRF_CLIENT);
    SetViewportOrgEx(hdc, pt.x, pt.y, NULL);

    if (hrgnOld)
    {
        SelectClipRgn(hdc, hrgnOld);
        DeleteObject(hrgnOld);
    }
    return TRUE;
}

//
//  For security purposes, we pass an explicit lpApplication to avoid
//  being spoofed by a path search.  This just does some of the grunt
//  work.  To execute the program C:\Foo.exe with the command line
//  argument /bar, you have to pass
//
//  lpApplication = C:\Program Files\Foo.exe
//  lpCommandLine = "C:\Program Files\Foo.exe" /bar
//

BOOL CreateProcessWithArgs(LPCTSTR pszApp, LPCTSTR pszArgs, LPCTSTR pszDirectory, PROCESS_INFORMATION *ppi)
{
    BOOL fRet = FALSE;
    STARTUPINFO si = {0};
    si.cb = sizeof(si);
    TCHAR szCommandLine[MAX_PATH * 2];
    HRESULT hr = StringCchCopy(szCommandLine, MAX_PATH-2 /* Leave space for quotes */, pszApp);
    if (SUCCEEDED(hr))
    {
        PathQuoteSpaces(szCommandLine);    // PathQuoteSpaces never goes beyond MAX_PATH
        hr = StringCchCat(szCommandLine, ARRAYSIZE(szCommandLine), TEXT(" "));
    }
    
    if (SUCCEEDED(hr))
    {
        hr = StringCchCat(szCommandLine, ARRAYSIZE(szCommandLine), pszArgs);
    }
    if (SUCCEEDED(hr))
    {
        fRet = CreateProcess(pszApp, szCommandLine, NULL, NULL, FALSE, 0, NULL, pszDirectory, &si, ppi);
    }
    return fRet;
}

// From a mail regarding the DirectX fct below:
//
// You can definitely count on the following:
//
// (1) If shadow cursors are on, there is definitely not an exclusive mode app running.
// (2) If hot tracking is on, there is definitely not an exclusive mode app running.
// (3) If message boxes for SEM_NOGPFAULTERRORBOX, SEM_FAILCRITICALERRORS, or
//     SEM_NOOPENFILEERRORBOX have not been disabled via SetErrorMode, then there
//     is definitely not an exclusive mode app running.
//
// Note: we cannot use (3) since this is per-process.

BOOL IsDirectXAppRunningFullScreen()
{
    BOOL fRet = FALSE;
    BOOL fSPI;

    if (SystemParametersInfo(SPI_GETCURSORSHADOW, 0, &fSPI, 0) && !fSPI)
    {
        if (SystemParametersInfo(SPI_GETHOTTRACKING, 0, &fSPI, 0) && !fSPI)
        {
            // There's a chance that a DirectX app is running full screen.  Let's do the
            // expensive DirectX calls that will tell us for sure.
            fRet = _IsDirectXExclusiveMode();
        }
    }

    return fRet;
}

BOOL _IsDirectXExclusiveMode()
{
    BOOL fRet = FALSE;

    // This code determines whether a DirectDraw 7 process (game) is running and
    // whether it's exclusively holding the video to the machine in full screen mode.

    // The code is probably to be considered untrusted and hence is wrapped in a
    // __try / __except block. It could AV and therefore bring down shell
    // with it. Not very good. If the code does raise an exception the release
    // call is skipped. Tough. Don't trust the release method either.

    IDirectDraw7 *pIDirectDraw7 = NULL;

    HRESULT hr = CoCreateInstance(CLSID_DirectDraw7, NULL, CLSCTX_INPROC_SERVER,
        IID_IDirectDraw7, (void**)&pIDirectDraw7);

    if (SUCCEEDED(hr))
    {
        ASSERT(pIDirectDraw7);

        __try
        {
            hr = IDirectDraw7_Initialize(pIDirectDraw7, NULL);

            if (DD_OK == hr)
            {
                fRet = (IDirectDraw7_TestCooperativeLevel(pIDirectDraw7) ==
                    DDERR_EXCLUSIVEMODEALREADYSET);
            }

            IDirectDraw7_Release(pIDirectDraw7);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\util.h ===
#ifndef _UTIL_H
#define _UTIL_H

#include "cabinet.h"

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

ULONG _RegisterNotify(HWND hwnd, UINT nMsg, LPITEMIDLIST pidl, BOOL fRecursive);
void _UnregisterNotify(ULONG nNotify);

void _MirrorBitmapInDC(HDC hdc, HBITMAP hbmOrig);

BOOL Reg_GetStruct(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, void *pData, DWORD *pcbData);
BOOL Reg_SetStruct(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, void *lpData, DWORD cbData);

HMENU LoadMenuPopup(LPCTSTR id);

BOOL SetWindowZorder(HWND hwnd, HWND hwndInsertAfter);  // from shell\lib

__inline BOOL IsChildOrHWND(HWND hwnd, HWND hwndChild) { return (SHIsChildOrSelf(hwnd, hwndChild) == S_OK); }

WORD    _GetHotkeyFromFolderItem(LPSHELLFOLDER psf, LPCITEMIDLIST pidl);

DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent, DWORD dwTimeout);

BOOL _Restricted(HWND hwnd, RESTRICTIONS rest);
int Window_GetClientGapHeight(HWND hwnd);


#define DOCKSTATE_DOCKED            0
#define DOCKSTATE_UNDOCKED          1
#define DOCKSTATE_UNKNOWN           2

BOOL IsDisplayChangeSafe();
DWORD GetMinDisplayRes(void);
void HandleDisplayChange(int x, int y, BOOL fCritical);

UINT GetDDEExecMsg();

BOOL _CheckAssociations(void);

void _ShowFolder(HWND hwnd, UINT csidl, UINT uFlags);

STDAPI_(IShellFolder*) BindToFolder(LPCITEMIDLIST pidl);

void RunSystemMonitor(void);

HRESULT SHIsParentOwnerOrSelf(HWND hwndParent, HWND hwnd);

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

void SHAllowSetForegroundWindow(HWND hwnd);

void DoInitialization();
void DoCleanup();

BOOL IsEjectAllowed(BOOL fForceUpdateCache);
void SetBiDiDateFlags(int *piDateFormat);
BOOL AppCommandTryRegistry(int cmd);

void RECTtoRECTL(LPRECT prc, LPRECTL lprcl);

int Toolbar_GetUniqueID(HWND hwndTB);
BYTE ToolBar_GetStateByIndex(HWND hwnd, INT_PTR iIndex);
int ToolBar_IndexToCommand(HWND hwnd, INT_PTR iIndex);
UINT SHGetImageListFlags(HWND hwndToolbar);

HRESULT SHExeNameFromHWND(HWND hWnd, LPWSTR pszExeName, UINT cchExeName);

BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork);
#define GetMonitorRect(hMon, prc) \
        GetMonitorRects((hMon), (prc), FALSE)

BOOL ShouldTaskbarAnimate();

#define DCHF_TOPALIGN       0x00000002  // default is center-align
#define DCHF_HORIZONTAL     0x00000004  // default is vertical
#define DCHF_HOT            0x00000008  // default is flat
#define DCHF_PUSHED         0x00000010  // default is flat
#define DCHF_FLIPPED        0x00000020  // if horiz, default is pointing right
                                        // if vert, default is pointing up
#define DCHF_TRANSPARENT    0x00000040
#define DCHF_INACTIVE       0x00000080
#define DCHF_NOBORDER       0x00000100
void DrawChevron(HDC hdc, LPRECT lprc, DWORD dwFlags);

void SetWindowStyle(HWND hwnd, DWORD dwStyle, BOOL fOn);
void SetWindowStyleEx(HWND hwnd, DWORD dwStyleEx, BOOL fOn);

// Review chrisny:  this can be moved into an object easily to handle generic droptarget, dropcursor
// , autoscrool, etc. . .
void _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject);
void _DragMove(HWND hwndTarget, const POINTL ptStart);

BOOL SHSendPrintRect(HWND hwndParent, HWND hwnd, HDC hdc, RECT* prc);

BOOL CreateProcessWithArgs(LPCTSTR pszApp, LPCTSTR pszArgs, LPCTSTR pszDirectory, PROCESS_INFORMATION *ppi);

BOOL IsDirectXAppRunningFullScreen();
BOOL _IsDirectXExclusiveMode();

#endif  // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\deskhost.h ===
#ifndef _DESKHOST_H_
#define _DESKHOST_H_

#include <exdisp.h>
#include <mshtml.h>
#include "dpa.h"
#include "../startmnu.h"
#include <cowsite.h>

#define WC_DV2      TEXT("DV2ControlHost")

// These are in WM_APP range because IsDialogMessage uses
// the WM_USER range and we used to use IsDialogMessage to get our focus
// management right.

#define DHM_DISMISS                 (WM_APP+0)

#define DesktopHost_Dismiss(hwnd)   SendMessage(hwnd, DHM_DISMISS, 0, 0)

EXTERN_C HBITMAP CreateMirroredBitmap(HBITMAP hbm);

class CPopupMenu
{
    CPopupMenu() : _cRef(1) { }
    ~CPopupMenu();

public:
    friend HRESULT CPopupMenu_CreateInstance(IShellMenu *psm,
                                             IUnknown *punkSite,
                                             HWND hwnd,
                                             CPopupMenu **ppmOut);

    void AddRef() { _cRef++; }
    void Release() { if (--_cRef == 0) delete this; }

    BOOL IsSame(IShellMenu *psm)
    {
        return SHIsSameObject(_psm, psm);
    }

    // Wrapped method calls

    HRESULT Invalidate()
        { return _psm->InvalidateItem(NULL, SMINV_REFRESH); }

    HRESULT TranslateMenuMessage(MSG *pmsg, LRESULT *plRet)
        { return _pmb->TranslateMenuMessage(pmsg, plRet); }

    HRESULT OnSelect(DWORD dwSelectType)
        { return _pmp->OnSelect(dwSelectType); }

    HRESULT IsMenuMessage(MSG *pmsg)
        { return _pmb->IsMenuMessage(pmsg); }

    HRESULT Popup(RECT *prcExclude, DWORD dwFlags);

private:
    HRESULT Initialize(IShellMenu *psm, IUnknown *punkSite, HWND hwnd);

private:
    LONG            _cRef;

    IMenuPopup *    _pmp;
    IMenuBand *     _pmb;
    IShellMenu *    _psm;
};

class CDesktopHost
    : public CUnknown
    , public IMenuPopup
    , public IMenuBand
    , public ITrayPriv2
    , public IServiceProvider
    , public IOleCommandTarget
    , public CObjectWithSite
{
    friend class CDeskHostShellMenuCallback;

    private:

    enum {
        IDT_MENUCHANGESEL = 1,
    };

    enum {
        NEWAPP_OFFER_COUNT = 3, // offer up to 3 times
    };

    private:
        HWND            _hwnd;             // window handle

        HTHEME          _hTheme;

        HWND            _hwndChildFocus;   // which child last had focus?

        IMenuPopup *    _pmpTracking;       // The popup menu we are tracking
        IMenuBand *     _pmbTracking;       // The menuband we are tracking
        LPARAM          _itemTracking;      // The item that owns the current popup menu
        HWND            _hwndTracking;      // The child window that owns _itemTracking
        LPARAM          _itemAltTracking;   // The item the user has hot-tracked to while viewing a different item's popup menu
        HWND            _hwndAltTracking;   // The child window that owns _itemAltTracking

        CPopupMenu *    _ppmPrograms;       // Cached Programs menu
        CPopupMenu *    _ppmTracking;       // The one that is currently popped up

        HWND            _hwndNewHandler;    // Which window knows which apps are new?

        RECT            _rcDesired;         // The layout gets to specify a desired size
        RECT            _rcActual;          // And then the components can request additional resizing

        int             _iOfferNewApps;     // number of times we should suggest to the
                                            // user that they look at the app that was installed
        UINT            _wmDragCancel;      // user dragged an item off of a submenu
        BOOL            _fOfferedNewApps;   // did we offer new apps this time?
        BOOL            _fOpen;             // Is the menu open for business?
        BOOL            _fMenuBlocked;      // Is menu mode temporarily blocked?
        BOOL            _fMouseEntered;     // Is the mouse inside our window?
        BOOL            _fAutoCascade;      // Should we auto-open on hover?
        BOOL            _fClipped;          // Did we have to pitch some items to fit on screen?
        BOOL            _fWarnedClipped;    // Has the user been warned that it's been clipped?
        BOOL            _fDismissOnlyPopup; // Are we only dismissing the popup?

        HWND            _hwndLastMouse;     // HWND that received last mousemove message
        LPARAM          _lParamLastMouse;   // LPARAM of last mousemove message

        HWND            _hwndClipBalloon;   // HWND of "you've been clipped!" balloon tip

        IFadeTask *     _ptFader;           // For cool selection fading

        SIZE            _sizWindowPrev;     // previous size of window when we popped up

        STARTPANELMETRICS _spm;             // start panel metrics

        HBITMAP         _hbmCachedSnapshot; // This bitmap reflects the current look of the start menu, ready to show!

    public:
        // *** IUnknown ***
        STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void) { return CUnknown::AddRef(); }
        STDMETHODIMP_(ULONG) Release(void) { return CUnknown::Release(); }

        // *** IOleWindow methods ***
        STDMETHODIMP GetWindow(HWND * phwnd) { *phwnd = _hwnd; return S_OK; }
        STDMETHODIMP ContextSensitiveHelp(BOOL bEnterMode) { return E_NOTIMPL; }

        // *** IDeskBar methods ***
        STDMETHODIMP SetClient(IUnknown* punk) { return E_NOTIMPL; };
        STDMETHODIMP GetClient(IUnknown** ppunkClient) { return E_NOTIMPL; }
        STDMETHODIMP OnPosRectChangeDB (LPRECT prc) { return E_NOTIMPL; }

        // *** IMenuPopup methods ***
        STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);
        STDMETHODIMP OnSelect(DWORD dwSelectType);
        STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet) { return E_NOTIMPL; }

        // *** IMenuBand methods ***
        STDMETHODIMP IsMenuMessage(MSG *pmsg);
        STDMETHODIMP TranslateMenuMessage(MSG *pmsg, LRESULT *plres);

        // *** ITrayPriv methods ***
        STDMETHODIMP ExecItem(IShellFolder *psf, LPCITEMIDLIST pidl) { return E_NOTIMPL; }
        STDMETHODIMP GetFindCM(HMENU hmenu, UINT idFirst, UINT idLast, IContextMenu **ppcmFind) { return E_NOTIMPL; }
        STDMETHODIMP GetStaticStartMenu(HMENU* phmenu) { return E_NOTIMPL; }

        // *** ITrayPriv2 methods ***
        STDMETHODIMP ModifySMInfo(IN LPSMDATA psmd, IN OUT SMINFO *psminfo);

        // *** IServiceProvider ***
        STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

        // *** IOleCommandTarget ***
        STDMETHODIMP QueryStatus(const GUID * pguidCmdGroup,
                                 ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
        STDMETHODIMP Exec(const GUID * pguidCmdGroup,
                                 DWORD nCmdID, DWORD nCmdexecopt, 
                                 VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

        // *** IObjectWithSite ***
        STDMETHODIMP SetSite(IUnknown *punkSite);

    public:
        HRESULT Initialize();
        HRESULT Build();

    private:
        HWND _Create();
        HRESULT _Popup(POINT *ppt, RECT *prcExclude, DWORD dwFlags);

    private:

        ~CDesktopHost();

        static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

        // Window Messages
        void OnCreate(HWND hwnd);
        void OnDestroy();
        void OnPaint(HDC hdc, BOOL bBackground);
        void OnSetFocus(HWND hwndLose);
        void OnContextMenu(LPARAM lParam);
        void _OnDismiss(BOOL bDestroy);
        void _OnMenuChangeSel();
        LRESULT OnHaveNewItems(NMHDR *pnm);
        LRESULT OnCommandInvoked(NMHDR *pnm);
        LRESULT OnFilterOptions(NMHDR *pnm);
        LRESULT OnTrackShellMenu(NMHDR *pnm);
        void OnSeenNewItems();
        LRESULT OnNeedRepaint();
        HRESULT TranslatePopupMenuMessage(MSG *pmsg, LRESULT *plres);

        // Other helpers
        BOOL Register();
        void LoadPanelMetrics();
        void LoadResourceInt(UINT ids, LONG *pl);
        BOOL AddWin32Controls();

        BOOL _TryShowBuffered();

        void _DismissTrackShellMenu();
        void _CleanupTrackShellMenu(); // release + UI-related goo

        void _DismissMenuPopup();
        BOOL _IsDialogMessage(MSG *pmsg);
        BOOL _DlgNavigateArrow(HWND hwndStart, MSG *pmsg);
        BOOL _DlgNavigateChar(HWND hwndStart, MSG *pmsg);
        HWND _FindNextDlgChar(HWND hwndStart, SMNDIALOGMESSAGE *pnmdm, UINT snmdm);
        void _EnableKeyboardCues();
        void _MaybeOfferNewApps();
        BOOL _ShouldIgnoreFocusChange(HWND hwndFocusRecipient);
        void _FilterMouseMove(MSG *pmsg, HWND hwndTarget);
        void _FilterMouseLeave(MSG *pmsg, HWND hwndTarget);
        void _FilterMouseHover(MSG *pmsg, HWND hwndTarget);
        void _RemoveSelection();
        void _SubclassTrackShellMenu(IShellMenu *psm);
        HRESULT _MenuMouseFilter(LPSMDATA psmd, BOOL fRemove, LPMSG pmsg);

        typedef HWND (WINAPI *GETNEXTDLGITEM)(HWND, HWND, BOOL);
        HWND _DlgFindItem(HWND hwndStart, SMNDIALOGMESSAGE *pnmdm, UINT smndm,
                          GETNEXTDLGITEM GetNextDlgItem, UINT fl);

        LRESULT _FindChildItem(HWND hwnd, SMNDIALOGMESSAGE *pnmdm, UINT smndm);

        void _ReadPaneSizeFromTheme(SMPANEDATA *psmpd);

        void _ComputeActualSize(MONITORINFO *pminfo, LPCRECT prcExclude);
        void _ChoosePopupPosition(POINT *ppt, LPCRECT prcExclude, LPRECT prcWindow);
        void _ReapplyRegion();
        void _SaveChildFocus();
        HWND _RestoreChildFocus();

        void _MaybeShowClipBalloon();
        void _DestroyClipBalloon();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\defaultmfu.cpp ===
#include "stdafx.h"
#include "sfthost.h"
#include "uemapp.h"
#include <desktray.h>
#include "tray.h"
#include "rcids.h"
#include "mfulist.h"
#define STRSAFE_NO_CB_FUNCTIONS
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

//---------------------------------------------------------------------------
//
//  Create the initial MFU.
//
//  Due to the way sysprep works, we cannot do this work in
//  per-user install because "reseal" copies the already-installed user
//  to the default hive, so all new users will bypass per-user install
//  since ActiveSetup thinks that they have already been installed...
//

//
//  We need a parallel list of hard-coded English links so we can get
//  the correct shortcut name on MUI systems.
//

#define MAX_MSMFUENTRIES    16

struct MFULIST {
    UINT    idsBase;
    LPCTSTR rgpszEnglish[MAX_MSMFUENTRIES];
};

#define MAKEMFU(name) \
    const MFULIST c_mfu##name = { IDS_MFU_##name##_00, { MFU_ENUMC(name) } };

#ifdef _WIN64
MAKEMFU(PRO64ALL)
MAKEMFU(SRV64ADM)

#define c_mfuPROALL c_mfuPRO64ALL
#define c_mfuSRVADM c_mfuSRV64ADM

#else
MAKEMFU(PRO32ALL)
MAKEMFU(SRV32ADM)

#define c_mfuPROALL c_mfuPRO32ALL
#define c_mfuSRVADM c_mfuSRV32ADM

#endif

//---------------------------------------------------------------------------
//
//  _GetPinnedItemTarget
//
//      Given a pidl, find the executable that will ultimately be launched.
//
//      This tunnels through shortcuts and resolves the magical "Internet"
//      and "Email" icons to the respective registered programs.
//
BOOL _GetPinnedItemTarget(LPCITEMIDLIST pidl, LPTSTR *ppszPath)
{
    *ppszPath = NULL;

    IShellFolder *psf;
    LPCITEMIDLIST pidlChild;
    if (SUCCEEDED(SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
    {
        IShellLink *psl;
        IExtractIcon *pxi;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidlChild,
                                           IID_PPV_ARG_NULL(IShellLink, &psl))))
        {
            TCHAR szPath[MAX_PATH];
            TCHAR szPathExpanded[MAX_PATH];
            if (psl->GetPath(szPath, ARRAYSIZE(szPath), 0, SLGP_RAWPATH) == S_OK &&
                SHExpandEnvironmentStrings(szPath, szPathExpanded, ARRAYSIZE(szPathExpanded)))
            {
                SHStrDup(szPathExpanded, ppszPath);
            }
            psl->Release();
        }
        else if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidlChild,
                                           IID_PPV_ARG_NULL(IExtractIcon, &pxi))))
        {
            // There is no way to get the IAssociationElement directly, so
            // we get the IExtractIcon and then ask him for the IAssociationElement.
            IAssociationElement *pae;
            if (SUCCEEDED(IUnknown_QueryService(pxi, IID_IAssociationElement, IID_PPV_ARG(IAssociationElement, &pae))))
            {
                pae->QueryString(AQVS_APPLICATION_PATH, L"open", ppszPath);
                pae->Release();
            }
            pxi->Release();
        }
        psf->Release();
    }
    return *ppszPath != NULL;
}

//---------------------------------------------------------------------------
//
//  MFUExclusion
//
//  Keep track of apps that should be excluded from the MFU.

class MFUExclusion
{
public:
    MFUExclusion();
    ~MFUExclusion();
    BOOL    IsExcluded(LPCITEMIDLIST pidl) const;

private:

    // worst-case default pin list size
    enum {MAX_EXCLUDED = 3 };

    PWSTR   _rgpszExclude[MAX_EXCLUDED];
    int     _cExcluded;
};

MFUExclusion::MFUExclusion() : _cExcluded(0)
{
    IStartMenuPin *psmpin;
    HRESULT hr;

    hr = CoCreateInstance(CLSID_StartMenuPin, NULL, CLSCTX_INPROC_SERVER,
                          IID_PPV_ARG(IStartMenuPin, &psmpin));
    if (SUCCEEDED(hr))
    {
        IEnumIDList *penum;

        if (SUCCEEDED(psmpin->EnumObjects(&penum)))
        {
            LPITEMIDLIST pidl;
            while (_cExcluded < ARRAYSIZE(_rgpszExclude) &&
                   penum->Next(1, &pidl, NULL) == S_OK)
            {
                if (_GetPinnedItemTarget(pidl, &_rgpszExclude[_cExcluded]))
                {
                    _cExcluded++;
                }
                ILFree(pidl);
            }

            penum->Release();
        }

        psmpin->Release();
    }
}

MFUExclusion::~MFUExclusion()
{
    for (int i = 0; i < _cExcluded; i++)
    {
        SHFree(_rgpszExclude[i]);
    }
}

BOOL MFUExclusion::IsExcluded(LPCITEMIDLIST pidl) const
{
    BOOL fRc = FALSE;
    LPTSTR pszTarget;

    if (_GetPinnedItemTarget(pidl, &pszTarget))
    {
        for (int i = 0; i < _cExcluded; i++)
        {
            if (lstrcmpi(_rgpszExclude[i], pszTarget) == 0)
            {
                fRc = TRUE;
                break;
            }
        }

        SHFree(pszTarget);
    }
    return fRc;
}

extern "C" HKEY g_hkeyExplorer;
void ClearUEMData();

//---------------------------------------------------------------------------
//
//  MFUEnumerator (and derived OEMMFUEnumerator, MSMFUEnumerator)
//
//  Enumerate applications to be added to the default MFU.

#define MAX_OEMMFUENTRIES   4

class MFUEnumerator
{
public:
    MFUEnumerator() : _dwIndex(0) { }
protected:
    DWORD   _dwIndex;
};

#define REGSTR_PATH_SMDEN TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SMDEn")

class OEMMFUEnumerator : protected MFUEnumerator
{
public:
    OEMMFUEnumerator() : _hk(NULL)
    {
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SMDEN, 0, KEY_READ, &_hk);
    }
    ~OEMMFUEnumerator()
    {
        if (_hk)
        {
            RegCloseKey(_hk);
        }
    }

    LPITEMIDLIST Next(const MFUExclusion *pmex);

private:
    HKEY    _hk;
};

LPITEMIDLIST OEMMFUEnumerator::Next(const MFUExclusion *pmex)
{
    if (!_hk)
    {
        return NULL;            // No entries at all
    }

restart:
    if (_dwIndex >= MAX_OEMMFUENTRIES)
    {
        return NULL;            // No more entries
    }

    TCHAR szKey[20];
    DWORD dwCurrentIndex = _dwIndex++;
    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("OEM%d"), dwCurrentIndex);

    TCHAR szPath[MAX_PATH];
    HRESULT hr = SHLoadRegUIStringW(_hk, szKey, szPath, ARRAYSIZE(szPath));
    if (FAILED(hr))
    {
        goto restart;
    }

    TCHAR szPathExpanded[MAX_PATH];
    SHExpandEnvironmentStrings(szPath, szPathExpanded, ARRAYSIZE(szPathExpanded));

    LPITEMIDLIST pidl = ILCreateFromPath(szPathExpanded);
    if (!pidl)
    {
        goto restart;
    }

    if (pmex->IsExcluded(pidl))
    {
        // Excluded - skip it
        ILFree(pidl);
        goto restart;
    }

    return pidl;
}

class MSMFUEnumerator : protected MFUEnumerator
{
public:
    LPITEMIDLIST Next(const MFULIST *pmfu, const MFUExclusion *pmex);
};

LPITEMIDLIST MSMFUEnumerator::Next(const MFULIST *pmfu, const MFUExclusion *pmex)
{
restart:
    if (_dwIndex >= MAX_MSMFUENTRIES)
    {
        return NULL;            // No more entries
    }

    DWORD dwCurrentIndex = _dwIndex++;

    //
    //  If this is excluded by policy, then skip it.
    //
    if (StrCmpC(pmfu->rgpszEnglish[dwCurrentIndex], TEXT(MFU_SETDEFAULTS)) == 0 &&
        SHRestricted(REST_NOSMCONFIGUREPROGRAMS))
    {
        goto restart;
    }

    //
    //  If this entry is blank, then skip it.
    //
    TCHAR szPath[MAX_PATH];
    if (!LoadString(_Module.GetModuleInstance(), pmfu->idsBase + dwCurrentIndex,
                    szPath, ARRAYSIZE(szPath)))
    {
        goto restart;
    }

    TCHAR szPathExpanded[MAX_PATH];
    SHExpandEnvironmentStrings(szPath, szPathExpanded, ARRAYSIZE(szPathExpanded));

    LPITEMIDLIST pidl = ILCreateFromPath(szPathExpanded);
    if (!pidl)
    {
        // Doesn't exist under localized name; try the English name
        SHExpandEnvironmentStrings(pmfu->rgpszEnglish[dwCurrentIndex], szPathExpanded, ARRAYSIZE(szPathExpanded));
        pidl = ILCreateFromPath(szPathExpanded);
    }

    if (!pidl)
    {
        // Doesn't exist at all - skip it
        goto restart;
    }

    if (pmex->IsExcluded(pidl))
    {
        // Excluded - skip it
        ILFree(pidl);
        goto restart;
    }

    return pidl;
}

#ifdef DEBUG
void ValidateMFUList(const MFULIST *pmfu)
{
    for (int i = 0; i < MAX_MSMFUENTRIES; i++)
    {
        TCHAR szBuf[MAX_PATH];
        LoadString(_Module.GetModuleInstance(), pmfu->idsBase + i, szBuf, ARRAYSIZE(szBuf));
        ASSERT(StrCmpC(szBuf, pmfu->rgpszEnglish[i]) == 0);
    }
}

void ValidateInitialMFUTables()
{
    // If this is the English build, then validate that the resources match
    // the hard-coded table.

    if (GetUserDefaultUILanguage() == MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
    {
        ValidateMFUList(&c_mfuPROALL);
        ValidateMFUList(&c_mfuSRVADM);
    }

    //  The PRO list must contain a copy of MFU_SETDEFAULTS for the
    //  policy exclusion code to work.
    BOOL fFound = FALSE;
    for (int i = 0; i < MAX_MSMFUENTRIES; i++)
    {
        if (StrCmpC(c_mfuPROALL.rgpszEnglish[i], TEXT(MFU_SETDEFAULTS)) == 0)
        {
            fFound = TRUE;
            break;
        }
    }
    ASSERT(fFound);
}
#endif

void CreateInitialMFU(BOOL fReset)
{
#ifdef DEBUG
    ValidateInitialMFUTables();
#endif

    HRESULT hrInit = SHCoInitialize();

    // Delete any dregs left over from "sysprep -reseal".
    // This also prevents OEMs from spamming the pin list.
    SHDeleteKey(g_hkeyExplorer, TEXT("StartPage"));
    SHDeleteValue(g_hkeyExplorer, TEXT("Advanced"), TEXT("StartButtonBalloonTip"));

    // Start with a clean slate if so requested
    if (fReset)
    {
        ClearUEMData();
    }

    // Okay now build the default MFU
    {
        // nested scope so MFUExclusion gets destructed before we
        // SHCoUninitialize()
        MFUExclusion mex;
        int iSlot;
        LPITEMIDLIST rgpidlMFU[REGSTR_VAL_DV2_MINMFU_DEFAULT] = { 0 };

        // Assert that the slots are evenly shared between MSFT and the OEM
        COMPILETIME_ASSERT(ARRAYSIZE(rgpidlMFU) % 2 == 0);

        // The OEM can provide up to four apps, and we will put as many
        // as fit into into bottom half.
        {
            OEMMFUEnumerator mfuOEM;
            for (iSlot = ARRAYSIZE(rgpidlMFU)/2; iSlot < ARRAYSIZE(rgpidlMFU); iSlot++)
            {
                rgpidlMFU[iSlot] = mfuOEM.Next(&mex);
            }
        }

        // The top half (and any unused slots in the bottom half)
        // go to MSFT (up to MAX_MSMFUENTRIES MSFT apps); which list
        // we use depends on the SKU and whether we are an administrator.
        const MFULIST *pmfu = NULL;

        if (IsOS(OS_ANYSERVER))
        {
            // On Server SKUs, only administrators get a default MFU
            // and they get the special server administrator MFU
            if (IsOS(OS_SERVERADMINUI))
            {
                pmfu = &c_mfuSRVADM;
            }
        }
        else
        {
            // On Workstation SKUs, everybody gets a default MFU.
            pmfu = &c_mfuPROALL;
        }

        if (pmfu)
        {
            MSMFUEnumerator mfuMSFT;
            for (iSlot = 0; iSlot < ARRAYSIZE(rgpidlMFU); iSlot++)
            {
                if (!rgpidlMFU[iSlot])
                {
                    rgpidlMFU[iSlot] = mfuMSFT.Next(pmfu, &mex);
                }
            }
        }

        // Now build up the new MFU given this information

        UEMINFO uei;
        uei.cbSize = sizeof(uei);
        uei.dwMask = UEIM_HIT | UEIM_FILETIME;
        GetSystemTimeAsFileTime(&uei.ftExecute);

        // All apps get the same timestamp of "now minus one UEM unit"
        // 1 UEM unit = 1<<30 FILETIME units
        DecrementFILETIME(&uei.ftExecute, 1 << 30);

        for (iSlot = 0; iSlot < ARRAYSIZE(rgpidlMFU); iSlot++)
        {
            if (!rgpidlMFU[iSlot])
            {
                continue;
            }

            // Number of points decrease as you go down the list, with
            // the bottom slot getting 14 points.
            uei.cHit = 14 + ARRAYSIZE(rgpidlMFU) - 1 - iSlot;

            // Shortcut points are read via UEME_RUNPIDL so that's
            // how we have to set them.
            IShellFolder *psf;
            LPCITEMIDLIST pidlChild;
            if (SUCCEEDED(SHBindToIDListParent(rgpidlMFU[iSlot], IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
            {
                _SetUEMPidlInfo(psf, pidlChild, &uei);
                psf->Release();
            }
        }

        // Clean up
        for (iSlot = 0; iSlot < ARRAYSIZE(rgpidlMFU); iSlot++)
        {
            ILFree(rgpidlMFU[iSlot]);
        }

        // MFUExclusion destructor runs here
    }

    SHCoUninitialize(hrInit);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\hostutil.h ===
#ifndef _HOSTUTIL_H_
#define _HOSTUTIL_H_

// usefull macro's which aren't elsewhere
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

// Balloon tip / infotip / tooltip helper
HWND CreateBalloonTip(HWND hwndOwner, int x, int y, HFONT hf, UINT idsTitle, UINT idsText);
void MakeMultilineTT(HWND hwndTT);
LRESULT HandleApplyRegion(HWND hwnd, HTHEME hTheme,
                          PSMNMAPPLYREGION par, int iPartId, int iStateId);

class CPropBagFromReg : public IPropertyBag
{
private:
    HKEY _hk;
    DWORD _cref;

    CPropBagFromReg::CPropBagFromReg(HKEY hk);
    CPropBagFromReg::~CPropBagFromReg();

public:

    STDMETHOD (QueryInterface) (REFIID riid, PVOID *ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar)
    {
        return E_NOTIMPL;
    }

    friend HRESULT CreatePropBagFromReg(LPCTSTR pszKey, IPropertyBag**pppb);
};

BOOL RectFromStrW(LPCWSTR pwsz, RECT *pr);

//
//  To get a common implementation of IUnknown so the compiler can collapse
//  them all together.
//
class CUnknown : public IUnknown
{
public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj) PURE;
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return ++_cRef; }
    virtual STDMETHODIMP_(ULONG) Release(void)
    {
        ULONG cRef = --_cRef;
        if (cRef == 0) {
            delete this;
            return 0;
        }
        return cRef;
    }

    virtual ~CUnknown() { }     // Because we delete from the base class

    IUnknown *GetUnknown() { return this; }

protected:

    CUnknown() : _cRef(1) { }

    LONG    _cRef;
};

//
//  Implementation of IAccessible that wraps the default IAccessible
//  of a window, but allows people to override selected methods.
//
class CAccessible : public IAccessible
{
public:
    // *** IUnknown ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvOut) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;

    // *** IDispatch ***
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames,
                      LCID lcid, DISPID *rgdispid);
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                        DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo,
                        UINT *puArgErr);

    // *** IAccessible ***
    STDMETHODIMP get_accParent(IDispatch **ppdispParent);
    STDMETHODIMP get_accChildCount(long *pChildCount);
    STDMETHODIMP get_accChild(VARIANT varChildIndex, IDispatch **ppdispChild);
    STDMETHODIMP get_accName(VARIANT varChild, BSTR *pszName);
    STDMETHODIMP get_accValue(VARIANT varChild, BSTR *pszValue);
    STDMETHODIMP get_accDescription(VARIANT varChild, BSTR *pszDescription);
    STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);
    STDMETHODIMP get_accHelp(VARIANT varChild, BSTR *pszHelp);
    STDMETHODIMP get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
    STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut);
    STDMETHODIMP get_accFocus(VARIANT *pvarFocusChild);
    STDMETHODIMP get_accSelection(VARIANT *pvarSelectedChildren);
    STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction);
    STDMETHODIMP accSelect(long flagsSelect, VARIANT varChild);
    STDMETHODIMP accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
    STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);
    STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT *pvarChildAtPoint);
    STDMETHODIMP accDoDefaultAction(VARIANT varChild);
    STDMETHODIMP put_accName(VARIANT varChild, BSTR szName);
    STDMETHODIMP put_accValue(VARIANT varChild, BSTR pszValue);

protected:
    ~CAccessible() { ATOMICRELEASE(_paccInner); }

    BOOL SetAccessibleSubclassWindow(HWND hwnd)
    {
        return SetWindowSubclass(hwnd, s_SubclassProc, 0,
                                 reinterpret_cast<DWORD_PTR>(this));
    }

    enum {
        ACCSTR_OPEN         = -815,
        ACCSTR_CLOSE        = -814,
        ACCSTR_EXECUTE      = -842,
    };

    enum {
        E_NOT_APPLICABLE = DISP_E_MEMBERNOTFOUND,
    };

    static HRESULT GetRoleString(DWORD dwRole, BSTR *pbsOut);
    static HRESULT CreateAcceleratorBSTR(TCHAR tch, BSTR *pbsOut);

private:
    static LRESULT CALLBACK s_SubclassProc(
                         HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                         UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

protected:
    IAccessible *_paccInner;
};

#endif // _HOSTUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\makefile.inc ===
#
# StartPage.ui preprocessing
#

$(O)\StartPage.uipp: StartPage.ui
    cl /nologo /EP StartPage.ui > $(O)\StartPage.uipp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\moreprog.h ===
// window class name of More Programs pane control
#define WC_MOREPROGRAMS TEXT("Desktop More Programs Pane")

class CMorePrograms
    : public IDropTarget
    , public CAccessible
{
public:
    /*
     *  Interface stuff...
     */

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvOut);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IDropTarget ***
    STDMETHODIMP DragEnter(IDataObject *pdto, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pdto, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** IAccessible overridden methods ***
    STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);
    STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut);
    STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction);
    STDMETHODIMP accDoDefaultAction(VARIANT varChild);

private:
    CMorePrograms(HWND hwnd);
    ~CMorePrograms();

    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnNCCreate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnCreate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnNCDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnCtlColorBtn(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnDrawItem(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnCommand(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnSysColorChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnDisplayChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnSettingChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnContextMenu(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnEraseBkgnd(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnNotify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnSMNFindItem(PSMNDIALOGMESSAGE pdm);
    LRESULT _OnSMNShowNewAppsTip(PSMNMBOOL psmb);
    LRESULT _OnSMNDismiss();

    void    _InitMetrics();
    HWND    _CreateTooltip();
    void    _PopBalloon();
    void    _TrackShellMenu(DWORD dwFlags);

    friend BOOL MorePrograms_RegisterClass();

    enum { IDC_BUTTON = 1,
           IDC_KEYPRESS = 2 };

private:
    HWND _hwnd;
    HWND _hwndButton;
    HWND _hwndTT;
    HWND _hwndBalloon;

    HTHEME _hTheme;

    HFONT _hf;
    HFONT _hfTTBold;                // Bold tooltip font
    HFONT _hfMarlett;
    HBRUSH _hbrBk;                  // Always a stock object

    IDropTargetHelper *_pdth;       // For friendly-looking drag/drop

    COLORREF _clrText;
    COLORREF _clrTextHot;
    COLORREF _clrBk;

    int      _colorHighlight;       // GetSysColor
    int      _colorHighlightText;   // GetSysColor

    DWORD    _tmHoverStart;         // When did the user start a drag/drop hover?

    // Assorted metrics for painting
    int     _tmAscent;              // Ascent of main font
    int     _tmAscentMarlett;       // Ascent of Marlett font
    int     _cxText;                // width of entire client text
    int     _cxTextIndent;          // distance to beginning of text
    int     _cxArrow;               // width of the arrow image or glyph
    MARGINS _margins;               // margins for the proglist listview
    int     _iTextCenterVal;        // space added to top of text to center with arrow bitmap

    RECT    _rcExclude;             // Exclusion rectangle for when the menu comes up

    // More random stuff
    LONG    _lRef;                  // reference count

    TCHAR   _chMnem;                // Mnemonic
    BOOL    _fMenuOpen;             // Is the menu open?

    IShellMenu *_psmPrograms;       // Cached ShellMenu for perf

    // Large things go at the end
    TCHAR  _szMessage[128];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\moreprog.cpp ===
#include "stdafx.h"
#include "sfthost.h"
#include "hostutil.h"
#include "moreprog.h"

#include <desktray.h>
#include "tray.h"           // To get access to c_tray
#include "rcids.h"          // for IDM_PROGRAMS etc.
#include <strsafe.h>

//
//  Unfortunately, WTL #undef's SelectFont, so we have to define it again.
//

inline HFONT SelectFont(HDC hdc, HFONT hf)
{
    return (HFONT)SelectObject(hdc, hf);
}

CMorePrograms::CMorePrograms(HWND hwnd) :
    _lRef(1),
    _hwnd(hwnd),
    _clrText(CLR_INVALID),
    _clrBk(CLR_INVALID)
{
}

CMorePrograms::~CMorePrograms()
{
    if (_hf)
      DeleteObject(_hf);

    if (_hfTTBold)
      DeleteObject(_hfTTBold);

    if (_hfMarlett)
      DeleteObject(_hfMarlett);

    ATOMICRELEASE(_pdth);
    ATOMICRELEASE(_psmPrograms);

    // Note that we do not need to clean up our HWNDs.
    // USER does that for us automatically.
}

//
//  Metrics changed -- update.
//
void CMorePrograms::_InitMetrics()
{
    if (_hwndTT)
    {
        MakeMultilineTT(_hwndTT);

        // Disable/enable infotips based on user preference
        SendMessage(_hwndTT, TTM_ACTIVATE, ShowInfoTip(), 0);
    }
}


LRESULT CMorePrograms::_OnNCCreate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
        
    CMorePrograms *self = new CMorePrograms(hwnd);

    if (self)
    {
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)self);
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return FALSE;
}

//
//  Create an inner button that is exactly the right size.
//
//  Height of inner button = height of text.
//  Width of inner button = full width.
//
//  This allows us to let USER do most of the work of hit-testing and
//  focus rectangling.
//
LRESULT CMorePrograms::_OnCreate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    _hTheme = (PaneDataFromCreateStruct(lParam))->hTheme;


    if (!_hTheme)
    {
        _clrText = GetSysColor(COLOR_MENUTEXT);
        _clrBk = GetSysColor(COLOR_MENU);
        _hbrBk = GetSysColorBrush(COLOR_MENU);
        _colorHighlight = COLOR_HIGHLIGHT;
        _colorHighlightText = COLOR_HIGHLIGHTTEXT;
        
        // should match proglist values, in sfthost.cpp
        _margins.cxLeftWidth = 2*GetSystemMetrics(SM_CXEDGE);
        _margins.cxRightWidth = 2*GetSystemMetrics(SM_CXEDGE);
    }
    else
    {
        GetThemeColor(_hTheme, SPP_MOREPROGRAMS, 0, TMT_TEXTCOLOR, &_clrText );
        _hbrBk = (HBRUSH) GetStockObject(HOLLOW_BRUSH);
        _colorHighlight = COLOR_MENUHILIGHT;
        _colorHighlightText = COLOR_HIGHLIGHTTEXT;

        // theme designer should make it so these margins match proglist's
        GetThemeMargins(_hTheme, NULL, SPP_MOREPROGRAMS, 0, TMT_CONTENTMARGINS, NULL, &_margins);

        // get the width of the arrow
        SIZE siz = { 0, 0 };
        GetThemePartSize(_hTheme, NULL, SPP_MOREPROGRAMSARROW, 0, NULL, TS_TRUE, &siz);
        _cxArrow = siz.cx;
    }

    // If we're restricted, just create the window without doing any work
    // We still need to paint our background, so we can't just fail the create
    if(SHRestricted(REST_NOSMMOREPROGRAMS))
        return TRUE;

    if (!LoadString(_Module.GetResourceInstance(),
                    IDS_STARTPANE_MOREPROGRAMS, _szMessage, ARRAYSIZE(_szMessage)))
    {
        return FALSE;
    }

    // Find the accelerator
    _chMnem = CharUpperChar(SHFindMnemonic(_szMessage));

    _hf = LoadControlFont(_hTheme, SPP_MOREPROGRAMS, FALSE, 0);

    // Get some information about the font the user has selected
    // and create a Marlett font at a matching size.
    TEXTMETRIC tm;
    HDC hdc = GetDC(hwnd);
    if (hdc)
    {
        HFONT hfPrev = SelectFont(hdc, _hf);
        if (hfPrev)
        {
            SIZE sizText;
            GetTextExtentPoint32(hdc, _szMessage, lstrlen(_szMessage), &sizText);
            _cxText = sizText.cx + GetSystemMetrics(SM_CXEDGE); // chevron should be a little right of the text

            if (GetTextMetrics(hdc, &tm))
            {
                _tmAscent = tm.tmAscent;
                LOGFONT lf;
                ZeroMemory(&lf, sizeof(lf));
                lf.lfHeight = _tmAscent;
                lf.lfWeight = FW_NORMAL;
                lf.lfCharSet = SYMBOL_CHARSET;
                StringCchCopy(lf.lfFaceName, ARRAYSIZE(lf.lfFaceName), TEXT("Marlett"));
                _hfMarlett = CreateFontIndirect(&lf);

                if (_hfMarlett)
                {
                    SelectFont(hdc, _hfMarlett);
                    if (GetTextMetrics(hdc, &tm))
                    {
                        _tmAscentMarlett = tm.tmAscent;
                    }

                    if (0 == _cxArrow) // if we're not themed, or the GetThemePartSize failed,
                    {
                        // set the width of the Marlett arrow into _cxArrow
                        GetTextExtentPoint32(hdc, GetLayout(hdc) & LAYOUT_RTL ? TEXT("w") : TEXT("8"), 1, &sizText);
                        _cxArrow = sizText.cx;
                    }
                }
            }

            SelectFont(hdc, hfPrev);
        }
        ReleaseDC(hwnd, hdc);
    }

    if (!_tmAscentMarlett)
    {
        return FALSE;
    }



    // This is the same large icon setting from proglist
    BOOL bLargeIcons = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, REGSTR_VAL_DV2_LARGEICONS, FALSE, TRUE /* default to large*/);

    RECT rc;
    GetClientRect(_hwnd, &rc);
    rc.left += _margins.cxLeftWidth;
    rc.right -= _margins.cxRightWidth;
    rc.top += _margins.cyTopHeight;
    rc.bottom -= _margins.cyBottomHeight;

    // Compute the text indent value, so more programs lines up with text on icons in programs list
    _cxTextIndent = (3 * GetSystemMetrics(SM_CXEDGE)) +    // 2 between icon&text + 1 before icon
        GetSystemMetrics(bLargeIcons ? SM_CXICON : SM_CXSMICON);

    // truncate the indent, if the text won't fit in the given area
    if (_cxTextIndent > RECTWIDTH(rc) - (_cxText + _cxArrow))
    {
        TraceMsg(TF_WARNING, "StartMenu: '%s' is %dpx, only room for %d- notify localizers!",_szMessage, _cxText, RECTWIDTH(rc)-(_cxArrow+_cxTextIndent));
        _cxTextIndent = max(0, RECTWIDTH(rc) - (_cxText + _cxArrow));
    }

    ASSERT(RECTHEIGHT(rc) > _tmAscent);

    _iTextCenterVal = (RECTHEIGHT(rc) - _tmAscent) / 2;

    // Do not set WS_TABSTOP or WS_GROUP; CMorePrograms handles that
    // BS_NOTIFY ensures that we get BN_SETFOCUS and BN_KILLFOCUS
    DWORD dwStyle = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE |
                    BS_OWNERDRAW;

    _hwndButton = CreateWindowEx(0, TEXT("button"), _szMessage, dwStyle,
                                 rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
                                 _hwnd, (HMENU)IntToPtr(IDC_BUTTON),
                                 _Module.GetModuleInstance(), NULL);

    if (!_hwndButton)
    {
        return FALSE;
    }

    //
    //  Don't freak out if this fails.  It just means that the accessibility
    //  stuff won't be perfect.
    //
    SetAccessibleSubclassWindow(_hwndButton);

    if (_hf)
        SetWindowFont(_hwndButton, _hf, FALSE);

    // Unlike the button itself, failure to create the tooltip is nonfatal.
    // only create the tooltip if auto-cascade is off
    if (!SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, REGSTR_VAL_DV2_AUTOCASCADE, FALSE, TRUE))
        _hwndTT = _CreateTooltip();

    _InitMetrics();

    // We can survive if this fails to be created
    CoCreateInstance(CLSID_DragDropHelper, NULL, CLSCTX_INPROC_SERVER,
                     IID_PPV_ARG(IDropTargetHelper, &_pdth));

    //
    // If this fails, no big whoop - you just don't get
    // drag/drop, boo hoo.
    //
    RegisterDragDrop(_hwndButton, this);

    return TRUE;
}

HWND CMorePrograms::_CreateTooltip()
{
    DWORD dwStyle = WS_BORDER | TTS_NOPREFIX;

    HWND hwnd = CreateWindowEx(0, TOOLTIPS_CLASS, NULL, dwStyle,
                               0, 0, 0, 0,
                               _hwndButton, NULL,
                               _Module.GetModuleInstance(), NULL);
    if (hwnd)
    {
        TCHAR szBuf[MAX_PATH];
        TOOLINFO ti;
        ti.cbSize = sizeof(ti);
        ti.hwnd = _hwnd;
        ti.uId = reinterpret_cast<UINT_PTR>(_hwndButton);
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
        ti.hinst = _Module.GetResourceInstance();

        // We can't use MAKEINTRESOURCE because that allows only up to 80
        // characters for text, and our text can be longer than that.
        UINT ids = IDS_STARTPANE_MOREPROGRAMS_TIP;

        ti.lpszText = szBuf;
        if (LoadString(_Module.GetResourceInstance(), ids, szBuf, ARRAYSIZE(szBuf)))
        {
            SendMessage(hwnd, TTM_ADDTOOL, 0, reinterpret_cast<LPARAM>(&ti));

        }
    }

    return hwnd;
}

LRESULT CMorePrograms::_OnDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RevokeDragDrop(_hwndButton);
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


LRESULT CMorePrograms::_OnNCDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // WARNING!  "this" might be invalid (if WM_NCCREATE failed), so
    // do not use any member variables!
    LRESULT lres = DefWindowProc(hwnd, uMsg, wParam, lParam);
    SetWindowPtr0(hwnd, 0);
    if (this)
    {
        this->Release();
    }
    return lres;
}

LRESULT CMorePrograms::_OnCtlColorBtn(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HDC hdc = reinterpret_cast<HDC>(wParam);

    if (_clrText != CLR_INVALID)
    {
        SetTextColor(hdc, _clrText);
    }

    if (_clrBk != CLR_INVALID)
    {
        SetBkColor(hdc, _clrBk);
    }

    return reinterpret_cast<LRESULT>(_hbrBk);
}


LRESULT CMorePrograms::_OnDrawItem(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPDRAWITEMSTRUCT pdis = reinterpret_cast<LPDRAWITEMSTRUCT>(lParam);
    ASSERT(pdis->CtlType == ODT_BUTTON);
    ASSERT(pdis->CtlID == IDC_BUTTON);

    if (pdis->itemAction & (ODA_DRAWENTIRE | ODA_FOCUS))
    {
        BOOL fRTLReading = GetLayout(pdis->hDC) & LAYOUT_RTL;
        UINT fuOptions = 0;
        if (fRTLReading)
        {
            fuOptions |= ETO_RTLREADING;
        }

        HFONT hfPrev = SelectFont(pdis->hDC, _hf);
        if (hfPrev)
        {
            BOOL fHot = (pdis->itemState & ODS_FOCUS) || _tmHoverStart;
            if (fHot)
            {
                // hot background
                FillRect(pdis->hDC, &pdis->rcItem, GetSysColorBrush(_colorHighlight));
                SetTextColor(pdis->hDC, GetSysColor(_colorHighlightText));
            }
            else if (_hTheme)
            {
                // Themed non-hot background = custom
                RECT rc;
                GetClientRect(hwnd, &rc);
                MapWindowRect(hwnd, pdis->hwndItem, &rc);
                DrawThemeBackground(_hTheme, pdis->hDC, SPP_MOREPROGRAMS, 0, &rc, 0);
            }
            else
            {
                // non-themed non-hot background
                FillRect(pdis->hDC, &pdis->rcItem, _hbrBk);
            }

            int iOldMode = SetBkMode(pdis->hDC, TRANSPARENT);

            // _cxTextIndent will move it in the current width of an icon (small or large), plus the space we add between an icon and the text
            pdis->rcItem.left += _cxTextIndent;

            UINT dtFlags = DT_VCENTER | DT_SINGLELINE | DT_EDITCONTROL;
            if (fRTLReading)
            {
                dtFlags |= DT_RTLREADING;
            }
            if (pdis->itemState & ODS_NOACCEL)
            {
                dtFlags |= DT_HIDEPREFIX;
            }

            DrawText(pdis->hDC, _szMessage, -1, &pdis->rcItem, dtFlags);

            RECT rc = pdis->rcItem;
            rc.left += _cxText;

            if (_hTheme)
            {
                if (_iTextCenterVal < 0) // text is taller than the bitmap
                    rc.top += (-_iTextCenterVal);

                rc.right = rc.left + _cxArrow;       // clip rectangle down to the minumum size...
                DrawThemeBackground(_hTheme, pdis->hDC, SPP_MOREPROGRAMSARROW,
                                    fHot ? SPS_HOT : 0, &rc, 0);
            }
            else
            {
                if (SelectFont(pdis->hDC, _hfMarlett))
                {
                    rc.top = rc.top + _tmAscent - _tmAscentMarlett + (_iTextCenterVal > 0 ? _iTextCenterVal : 0);
                    TCHAR chOut = fRTLReading ? TEXT('w') : TEXT('8');
                    if (EVAL(!IsRectEmpty(&rc)))
                    {
                        ExtTextOut(pdis->hDC, rc.left, rc.top, fuOptions, &rc, &chOut, 1, NULL);
                        rc.right = rc.left + _cxArrow;
                    }
                }
            }

            _rcExclude = rc;
            _rcExclude.left -= _cxText;  // includes the text in the exclusion rectangle.

            MapWindowRect(pdis->hwndItem, NULL, &_rcExclude);
            SetBkMode(pdis->hDC, iOldMode);
            SelectFont(pdis->hDC, hfPrev);
        }
    }

    //
    //  Since we are emulating a menu item, we don't need to draw a
    //  focus rectangle.
    //
    return TRUE;
}

void CMorePrograms::_TrackShellMenu(DWORD dwFlags)
{
    // Pop the balloon tip and tell the Start Menu not to offer it any more
    _PopBalloon();
    _SendNotify(_hwnd, SMN_SEENNEWITEMS);

    SMNTRACKSHELLMENU tsm;
    tsm.itemID = 0;
    tsm.dwFlags = dwFlags;
    if (!_psmPrograms)
    {
        CoCreateInstance(CLSID_PersonalStartMenu, NULL, CLSCTX_INPROC,
            IID_PPV_ARG(IShellMenu, &_psmPrograms));
    }

    if (_psmPrograms)
    {
        tsm.psm = _psmPrograms;
        tsm.rcExclude = _rcExclude;
        HWND hwnd = _hwnd;
        _fMenuOpen = TRUE;
        _SendNotify(_hwnd, SMN_TRACKSHELLMENU, &tsm.hdr);
    }
}

LRESULT CMorePrograms::_OnCommand(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
    case IDC_BUTTON:
        switch (GET_WM_COMMAND_CMD(wParam, lParam))
        {
        case BN_CLICKED:
            _TrackShellMenu(0);
            break;
        }
        break;

    case IDC_KEYPRESS:
        _TrackShellMenu(MPPF_KEYBOARD | MPPF_INITIALSELECT);
        break;
    }

    return 0;
}

LRESULT CMorePrograms::_OnEraseBkgnd(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    GetClientRect(hwnd, &rc);
    if (_hTheme)
    {
        DrawThemeBackground(_hTheme, (HDC)wParam, SPP_MOREPROGRAMS, 0, &rc, 0);
    }
    else
        SHFillRectClr((HDC)wParam, &rc, _clrBk);
    return 0;
}

LRESULT CMorePrograms::_OnNotify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPNMHDR pnm = reinterpret_cast<LPNMHDR>(lParam);

    switch (pnm->code)
    {
    case SMN_FINDITEM:
        return _OnSMNFindItem(CONTAINING_RECORD(pnm, SMNDIALOGMESSAGE, hdr));
    case SMN_SHOWNEWAPPSTIP:
        return _OnSMNShowNewAppsTip(CONTAINING_RECORD(pnm, SMNMBOOL, hdr));
    case SMN_DISMISS:
        return _OnSMNDismiss();
    case SMN_APPLYREGION:
        return HandleApplyRegion(_hwnd, _hTheme, (SMNMAPPLYREGION *)lParam, SPP_MOREPROGRAMS, 0);
    case SMN_SHELLMENUDISMISSED:
        _fMenuOpen = FALSE;
        return 0;
    }
    return 0;
}

LRESULT CMorePrograms::_OnSMNFindItem(PSMNDIALOGMESSAGE pdm)
{
    if(SHRestricted(REST_NOSMMOREPROGRAMS))
        return 0;

    switch (pdm->flags & SMNDM_FINDMASK)
    {

    // Life is simple if you have only one item -- all searches succeed!
    case SMNDM_FINDFIRST:
    case SMNDM_FINDLAST:
    case SMNDM_FINDNEAREST:
    case SMNDM_HITTEST:
        pdm->itemID = 0;
        return TRUE;

    case SMNDM_FINDFIRSTMATCH:
        {
            TCHAR tch = CharUpperChar((TCHAR)pdm->pmsg->wParam);
            if (tch == _chMnem)
            {
                pdm->itemID = 0;
                return TRUE;
            }
        }
        break;      // not found

    case SMNDM_FINDNEXTMATCH:
        break;      // there is only one item so there can't be a "next"


    case SMNDM_FINDNEXTARROW:
        if (pdm->flags & SMNDM_TRYCASCADE)
        {
            FORWARD_WM_COMMAND(_hwnd, IDC_KEYPRESS, NULL, 0, PostMessage);
            return TRUE;
        }
        break;      // not found

    case SMNDM_INVOKECURRENTITEM:
    case SMNDM_OPENCASCADE:
        if (pdm->flags & SMNDM_KEYBOARD)
        {
            FORWARD_WM_COMMAND(_hwnd, IDC_KEYPRESS, NULL, 0, PostMessage);
        }
        else
        {
            FORWARD_WM_COMMAND(_hwnd, IDC_BUTTON, NULL, 0, PostMessage);
        }
        return TRUE;

    case SMNDM_FINDITEMID:
        return TRUE;

    default:
        ASSERT(!"Unknown SMNDM command");
        break;
    }

    //
    //  If not found, then tell caller what our orientation is (vertical)
    //  and where the currently-selected item is.
    //
    pdm->flags |= SMNDM_VERTICAL;
    pdm->pt.x = 0;
    pdm->pt.y = 0;
    return FALSE;
}

//
//  The boolean parameter in the SMNMBOOL tells us whether to display or
//  hide the balloon tip.
//
LRESULT CMorePrograms::_OnSMNShowNewAppsTip(PSMNMBOOL psmb)
{
    if(SHRestricted(REST_NOSMMOREPROGRAMS))
        return 0;

    if (psmb->f)
    {
        if (_hwndTT)
        {
            SendMessage(_hwndTT, TTM_ACTIVATE, FALSE, 0);
        }

        if (!_hwndBalloon)
        {
            RECT rc;
            GetWindowRect(_hwndButton, &rc);

            if (!_hfTTBold)
            {
                NONCLIENTMETRICS ncm;
                ncm.cbSize = sizeof(ncm);
                if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
                {
                    ncm.lfStatusFont.lfWeight = FW_BOLD;
                    SHAdjustLOGFONT(&ncm.lfStatusFont);
                    _hfTTBold = CreateFontIndirect(&ncm.lfStatusFont);
                }
            }

            _hwndBalloon = CreateBalloonTip(_hwnd,
                            rc.left + _cxTextIndent + _cxText,
                            (rc.top + rc.bottom)/2,
                            _hfTTBold, 0,
                            IDS_STARTPANE_MOREPROGRAMS_BALLOONTITLE);
            if (_hwndBalloon)
            {
                SetProp(_hwndBalloon, PROP_DV2_BALLOONTIP, DV2_BALLOONTIP_MOREPROG);
            }

        }
    }
    else
    {
        _PopBalloon();
    }

    return 0;
}

void CMorePrograms::_PopBalloon()
{
    if (_hwndBalloon)
    {
        DestroyWindow(_hwndBalloon);
        _hwndBalloon = NULL;
    }
    if (_hwndTT)
    {
        SendMessage(_hwndTT, TTM_ACTIVATE, TRUE, 0);
    }

}

LRESULT CMorePrograms::_OnSMNDismiss()
{
    _PopBalloon();
    return 0;
}

LRESULT CMorePrograms::_OnSysColorChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // update colors in classic mode
    if (!_hTheme)
    {
        _clrText = GetSysColor(COLOR_MENUTEXT);
        _clrBk = GetSysColor(COLOR_MENU);
        _hbrBk = GetSysColorBrush(COLOR_MENU);
    }

    SHPropagateMessage(hwnd, uMsg, wParam, lParam, SPM_SEND | SPM_ONELEVEL);
    return 0;
}

LRESULT CMorePrograms::_OnDisplayChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _InitMetrics();
    SHPropagateMessage(hwnd, uMsg, wParam, lParam, SPM_SEND | SPM_ONELEVEL);
    return 0;
}

LRESULT CMorePrograms::_OnSettingChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // _InitMetrics() is so cheap it's not worth getting too upset about
    // calling it too many times.
    _InitMetrics();
    SHPropagateMessage(hwnd, uMsg, wParam, lParam, SPM_SEND | SPM_ONELEVEL);
    return 0;
}

LRESULT CMorePrograms::_OnContextMenu(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if(SHRestricted(REST_NOSMMOREPROGRAMS))
        return 0;

    if (IS_WM_CONTEXTMENU_KEYBOARD(lParam))
    {
        RECT rc;
        GetWindowRect(_hwnd, &rc);
        lParam = MAKELPARAM(rc.left, rc.top);
    }

    c_tray.StartMenuContextMenu(_hwnd, (DWORD)lParam);
    return 0;
}

LRESULT CALLBACK CMorePrograms::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMorePrograms *self = reinterpret_cast<CMorePrograms *>(GetWindowPtr(hwnd, GWLP_USERDATA));

    switch (uMsg)
    {
        case WM_NCCREATE:
            return self->_OnNCCreate(hwnd, uMsg, wParam, lParam);
        case WM_CREATE:
            return self->_OnCreate(hwnd, uMsg, wParam, lParam);
        case WM_DESTROY:
            return self->_OnDestroy(hwnd, uMsg, wParam, lParam);
        case WM_NCDESTROY:
            return self->_OnNCDestroy(hwnd, uMsg, wParam, lParam);
        case WM_CTLCOLORBTN:
            return self->_OnCtlColorBtn(hwnd, uMsg, wParam, lParam);
        case WM_DRAWITEM:
            return self->_OnDrawItem(hwnd, uMsg, wParam, lParam);
        case WM_ERASEBKGND:
            return self->_OnEraseBkgnd(hwnd, uMsg, wParam, lParam);
        case WM_COMMAND:
            return self->_OnCommand(hwnd, uMsg, wParam, lParam);
        case WM_SYSCOLORCHANGE:
            return self->_OnSysColorChange(hwnd, uMsg, wParam, lParam);
        case WM_DISPLAYCHANGE:
            return self->_OnDisplayChange(hwnd, uMsg, wParam, lParam);
        case WM_SETTINGCHANGE:
            return self->_OnSettingChange(hwnd, uMsg, wParam, lParam);
        case WM_NOTIFY:
            return self->_OnNotify(hwnd, uMsg, wParam, lParam);
        case WM_CONTEXTMENU:
            return self->_OnContextMenu(hwnd, uMsg, wParam, lParam);
    }

    return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

BOOL WINAPI MorePrograms_RegisterClass()
{
    WNDCLASSEX wc;
    ZeroMemory(&wc, sizeof(wc));
    
    wc.cbSize        = sizeof(wc);
    wc.style         = CS_GLOBALCLASS;
    wc.lpfnWndProc   = CMorePrograms::s_WndProc;
    wc.hInstance     = _Module.GetModuleInstance();
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszClassName = WC_MOREPROGRAMS;

    return RegisterClassEx(&wc);
}

// We implement a minimal drop target so we can auto-open the More Programs
// list when the user hovers over the More Programs button.

// *** IUnknown ***

HRESULT CMorePrograms::QueryInterface(REFIID riid, void * *ppvOut)
{
    static const QITAB qit[] = {
        QITABENT(CMorePrograms, IDropTarget),
        QITABENT(CMorePrograms, IAccessible),
        QITABENT(CMorePrograms, IDispatch), // IAccessible derives from IDispatch
        { 0 },
    };
    return QISearch(this, qit, riid, ppvOut);
}

ULONG CMorePrograms::AddRef()
{
    return InterlockedIncrement(&_lRef);
}

ULONG CMorePrograms::Release()
{
    ASSERT( 0 != _lRef );
    ULONG cRef = InterlockedDecrement(&_lRef);
    if ( 0 == cRef) 
    {
        delete this;
    }
    return cRef;
}


// *** IDropTarget::DragEnter ***

HRESULT CMorePrograms::DragEnter(IDataObject *pdto, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    POINT pt = { ptl.x, ptl.y };
    if (_pdth) {
        _pdth->DragEnter(_hwnd, pdto, &pt, *pdwEffect);
    }

    //  Remember when the hover started.
    _tmHoverStart = NonzeroGetTickCount();
    InvalidateRect(_hwndButton, NULL, TRUE); // draw with drop highlight

    return DragOver(grfKeyState, ptl, pdwEffect);
}

// *** IDropTarget::DragOver ***

HRESULT CMorePrograms::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    POINT pt = { ptl.x, ptl.y };
    if (_pdth) {
        _pdth->DragOver(&pt, *pdwEffect);
    }

    //  Hover time is 1 second, the same as the hard-coded value for the
    //  Start Button.
    if (_tmHoverStart && GetTickCount() - _tmHoverStart > 1000)
    {
        _tmHoverStart = 0;
        FORWARD_WM_COMMAND(_hwnd, IDC_BUTTON, _hwndButton, BN_CLICKED, PostMessage);
    }

    *pdwEffect = DROPEFFECT_NONE;
    return S_OK;
}

// *** IDropTarget::DragLeave ***

HRESULT CMorePrograms::DragLeave()
{
    if (_pdth) {
        _pdth->DragLeave();
    }

    _tmHoverStart = 0;
    InvalidateRect(_hwndButton, NULL, TRUE); // draw without drop highlight

    return S_OK;
}

// *** IDropTarget::Drop ***

HRESULT CMorePrograms::Drop(IDataObject *pdto, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    POINT pt = { ptl.x, ptl.y };
    if (_pdth) {
        _pdth->Drop(pdto, &pt, *pdwEffect);
    }

    _tmHoverStart = 0;
    InvalidateRect(_hwndButton, NULL, TRUE); // draw without drop highlight

    return S_OK;
}

//****************************************************************************
//
//  Accessibility
//

//
//  The default accessibility object reports buttons as
//  ROLE_SYSTEM_PUSHBUTTON, but we know that we are really a menu.
//
HRESULT CMorePrograms::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    HRESULT hr = CAccessible::get_accRole(varChild, pvarRole);
    if (SUCCEEDED(hr) && V_VT(pvarRole) == VT_I4)
    {
        switch (V_I4(pvarRole))
        {
        case ROLE_SYSTEM_PUSHBUTTON:
            V_I4(pvarRole) = ROLE_SYSTEM_MENUITEM;
            break;
        }
    }
    return hr;
}

HRESULT CMorePrograms::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    HRESULT hr = CAccessible::get_accState(varChild, pvarState);
    if (SUCCEEDED(hr) && V_VT(pvarState) == VT_I4)
    {
        V_I4(pvarState) |= STATE_SYSTEM_HASPOPUP;
    }
    return hr;
}

HRESULT CMorePrograms::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut)
{
    return CreateAcceleratorBSTR(_chMnem, pszKeyboardShortcut);
}

HRESULT CMorePrograms::get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction)
{
    DWORD dwRole = _fMenuOpen ? ACCSTR_CLOSE : ACCSTR_OPEN;
    return GetRoleString(dwRole, pszDefAction);
}

HRESULT CMorePrograms::accDoDefaultAction(VARIANT varChild)
{
    if (_fMenuOpen)
    {
        _SendNotify(_hwnd, SMN_CANCELSHELLMENU);
        return S_OK;
    }
    else
    {
        return CAccessible::accDoDefaultAction(varChild);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\hostutil.cpp ===
#include "stdafx.h"
#include "hostutil.h"

#define DEFAULT_BALLOON_TIMEOUT     (10*1000)       // 10 seconds

LRESULT CALLBACK BalloonTipSubclassProc(
                         HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                         UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    switch (uMsg)
    {
    case WM_TIMER:
        // Our autodismiss timer
        if (uIdSubclass == wParam)
        {
            KillTimer(hwnd, wParam);
            DestroyWindow(hwnd);
            return 0;
        }
        break;


    // On a settings change, recompute our size and margins
    case WM_SETTINGCHANGE:
        MakeMultilineTT(hwnd);
        break;

    case WM_NCDESTROY:
        RemoveWindowSubclass(hwnd, BalloonTipSubclassProc, uIdSubclass);
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

//
//  A "fire and forget" balloon tip.  Tell it where to go, what font
//  to use, and what to say, and it pops up and times out.
//
HWND CreateBalloonTip(HWND hwndOwner, int x, int y, HFONT hf,
                      UINT idsTitle, UINT idsText)
{
    DWORD dwStyle = TTS_ALWAYSTIP | TTS_BALLOON | TTS_NOPREFIX;

    HWND hwnd = CreateWindowEx(0, TOOLTIPS_CLASS, NULL, dwStyle,
                               0, 0, 0, 0,
                               hwndOwner, NULL,
                               _Module.GetModuleInstance(), NULL);
    if (hwnd)
    {
        MakeMultilineTT(hwnd);

        TCHAR szBuf[MAX_PATH];
        TOOLINFO ti;
        ti.cbSize = sizeof(ti);
        ti.hwnd = hwndOwner;
        ti.uId = reinterpret_cast<UINT_PTR>(hwndOwner);
        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS | TTF_TRACK;
        ti.hinst = _Module.GetResourceInstance();

        // We can't use MAKEINTRESOURCE because that allows only up to 80
        // characters for text, and our text can be longer than that.
        ti.lpszText = szBuf;
        if (LoadString(_Module.GetResourceInstance(), idsText, szBuf, ARRAYSIZE(szBuf)))
        {
            SendMessage(hwnd, TTM_ADDTOOL, 0, reinterpret_cast<LPARAM>(&ti));

            if (idsTitle &&
                LoadString(_Module.GetResourceInstance(), idsTitle, szBuf, ARRAYSIZE(szBuf)))
            {
                SendMessage(hwnd, TTM_SETTITLE, TTI_INFO, reinterpret_cast<LPARAM>(szBuf));
            }

            SendMessage(hwnd, TTM_TRACKPOSITION, 0, MAKELONG(x, y));

            if (hf)
            {
                SetWindowFont(hwnd, hf, FALSE);
            }

            SendMessage(hwnd, TTM_TRACKACTIVATE, TRUE, reinterpret_cast<LPARAM>(&ti));

            // Set the autodismiss timer
            if (SetWindowSubclass(hwnd, BalloonTipSubclassProc, (UINT_PTR)hwndOwner, 0))
            {
                SetTimer(hwnd, (UINT_PTR)hwndOwner, DEFAULT_BALLOON_TIMEOUT, NULL);
            }
        }
    }

    return hwnd;
}

// Make the tooltip control multiline (infotip or balloon tip).
// The size computations are the same ones that comctl32 uses
// for listview and treeview infotips.

void MakeMultilineTT(HWND hwndTT)
{
    HWND hwndOwner = GetWindow(hwndTT, GW_OWNER);
    HDC hdc = GetDC(hwndOwner);
    if (hdc)
    {
        int iWidth = MulDiv(GetDeviceCaps(hdc, LOGPIXELSX), 300, 72);
        int iMaxWidth = GetDeviceCaps(hdc, HORZRES) * 3 / 4;
        SendMessage(hwndTT, TTM_SETMAXTIPWIDTH, 0, min(iWidth, iMaxWidth));

        static const RECT rcMargin = {4, 4, 4, 4};
        SendMessage(hwndTT, TTM_SETMARGIN, 0, (LPARAM)&rcMargin);

        ReleaseDC(hwndOwner, hdc);
    }
}



CPropBagFromReg::CPropBagFromReg(HKEY hk)
{
    _cref = 1;
    _hk = hk;
};
CPropBagFromReg::~CPropBagFromReg()
{
    RegCloseKey(_hk);
}

STDMETHODIMP CPropBagFromReg::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    if (IsEqualIID(riid, IID_IPropertyBag))
        *ppvObject = (IPropertyBag *)this;
    else if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = this;
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG CPropBagFromReg::AddRef(void)
{
    return ++_cref; // on the stack
}
ULONG CPropBagFromReg::Release(void)
{
    if (--_cref)
        return _cref;

    delete this;
    return 0;
}

STDMETHODIMP CPropBagFromReg::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
    VARTYPE vtDesired = pVar->vt;

    WCHAR szTmp[100];
    DWORD cb = sizeof(szTmp);
    DWORD dwType;
    if (ERROR_SUCCESS == RegQueryValueExW(_hk, pszPropName, NULL, &dwType, (LPBYTE)szTmp, &cb) && (REG_SZ==dwType))
    {
        // TODO - use dwType to set the vt properly
        pVar->bstrVal = SysAllocString(szTmp);
        if (pVar->bstrVal)
        {
            pVar->vt = VT_BSTR;
            return VariantChangeTypeForRead(pVar, vtDesired);
        }
        else
            return E_OUTOFMEMORY;
    }
    else
        return E_INVALIDARG;

}

HRESULT CreatePropBagFromReg(LPCTSTR pszKey, IPropertyBag**pppb)
{
    HRESULT hr = E_OUTOFMEMORY;

    *pppb = NULL;

    // Try current user 1st, if that fails, fall back to localmachine
    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, pszKey, NULL, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hk)
     || ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKey, NULL, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hk))
    {
        CPropBagFromReg* pcpbfi = new CPropBagFromReg(hk);
        if (pcpbfi)
        {
            hr = pcpbfi->QueryInterface(IID_IPropertyBag, (void**) pppb);
            pcpbfi->Release();
        }
        else
        {
            RegCloseKey(hk);
        }
    }

    return hr;
};

BOOL RectFromStrW(LPCWSTR pwsz, RECT *pr)
{
    pr->left = StrToIntW(pwsz);
    pwsz = StrChrW(pwsz, L',');
    if (!pwsz)
        return FALSE;
    pr->top = StrToIntW(++pwsz);
    pwsz = StrChrW(pwsz, L',');
    if (!pwsz)
        return FALSE;
    pr->right = StrToIntW(++pwsz);
    pwsz = StrChrW(pwsz, L',');
    if (!pwsz)
        return FALSE;
    pr->bottom = StrToIntW(++pwsz);
    return TRUE;
}

LRESULT HandleApplyRegion(HWND hwnd, HTHEME hTheme,
                          PSMNMAPPLYREGION par, int iPartId, int iStateId)
{
    if (hTheme)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);

        // Map to caller's coordinates
        MapWindowRect(NULL, par->hdr.hwndFrom, &rc);

        HRGN hrgn;
        if (SUCCEEDED(GetThemeBackgroundRegion(hTheme, NULL, iPartId, iStateId, &rc, &hrgn)) && hrgn)
        {
            // Replace our window rectangle with the region
            HRGN hrgnRect = CreateRectRgnIndirect(&rc);
            if (hrgnRect)
            {
                // We want to take par->hrgn, subtract hrgnRect and add hrgn.
                // But we want to do this with a single operation to par->hrgn
                // so we don't end up with a corrupted region on low memory failure.
                // So we do
                //
                //  par->hrgn ^= hrgnRect ^ hrgn.
                //
                // If hrgnRect ^ hrgn == NULLREGION then the background
                // does not want to customize the rectangle so we can just
                // leave par->hrgn alone.

                int iResult = CombineRgn(hrgn, hrgn, hrgnRect, RGN_XOR);
                if (iResult != ERROR && iResult != NULLREGION)
                {
                    CombineRgn(par->hrgn, par->hrgn, hrgn, RGN_XOR);
                }
                DeleteObject(hrgnRect);
            }
            DeleteObject(hrgn);
        }
    }
    return 0;
}

//****************************************************************************
//
//  CAccessible - Most of this class is just forwarders

#define ACCESSIBILITY_FORWARD(fn, typedargs, args)  \
HRESULT CAccessible::fn typedargs                   \
{                                                   \
    return _paccInner->fn args;                     \
}

ACCESSIBILITY_FORWARD(get_accParent,
                      (IDispatch **ppdispParent),
                      (ppdispParent))
ACCESSIBILITY_FORWARD(GetTypeInfoCount,
                      (UINT *pctinfo),
                      (pctinfo))
ACCESSIBILITY_FORWARD(GetTypeInfo,
                      (UINT itinfo, LCID lcid, ITypeInfo **pptinfo),
                      (itinfo, lcid, pptinfo))
ACCESSIBILITY_FORWARD(GetIDsOfNames,
                      (REFIID riid, OLECHAR **rgszNames, UINT cNames,
                       LCID lcid, DISPID *rgdispid),
                      (riid, rgszNames, cNames, lcid, rgdispid))
ACCESSIBILITY_FORWARD(Invoke,
                      (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                       DISPPARAMS *pdispparams, VARIANT *pvarResult,
                       EXCEPINFO *pexcepinfo, UINT *puArgErr),
                      (dispidMember, riid, lcid, wFlags,
                       pdispparams, pvarResult,
                       pexcepinfo, puArgErr))
ACCESSIBILITY_FORWARD(get_accChildCount,
                      (long *pChildCount),
                      (pChildCount))
ACCESSIBILITY_FORWARD(get_accChild,
                      (VARIANT varChildIndex, IDispatch **ppdispChild),
                      (varChildIndex, ppdispChild))
ACCESSIBILITY_FORWARD(get_accName,
                      (VARIANT varChild, BSTR *pszName),
                      (varChild, pszName))
ACCESSIBILITY_FORWARD(get_accValue,
                      (VARIANT varChild, BSTR *pszValue),
                      (varChild, pszValue))
ACCESSIBILITY_FORWARD(get_accDescription,
                      (VARIANT varChild, BSTR *pszDescription),
                      (varChild, pszDescription))
ACCESSIBILITY_FORWARD(get_accRole,
                      (VARIANT varChild, VARIANT *pvarRole),
                      (varChild, pvarRole))
ACCESSIBILITY_FORWARD(get_accState,
                      (VARIANT varChild, VARIANT *pvarState),
                      (varChild, pvarState))
ACCESSIBILITY_FORWARD(get_accHelp,
                      (VARIANT varChild, BSTR *pszHelp),
                      (varChild, pszHelp))
ACCESSIBILITY_FORWARD(get_accHelpTopic,
                      (BSTR *pszHelpFile, VARIANT varChild, long *pidTopic),
                      (pszHelpFile, varChild, pidTopic))
ACCESSIBILITY_FORWARD(get_accKeyboardShortcut,
                      (VARIANT varChild, BSTR *pszKeyboardShortcut),
                      (varChild, pszKeyboardShortcut))
ACCESSIBILITY_FORWARD(get_accFocus,
                      (VARIANT *pvarFocusChild),
                      (pvarFocusChild))
ACCESSIBILITY_FORWARD(get_accSelection,
                      (VARIANT *pvarSelectedChildren),
                      (pvarSelectedChildren))
ACCESSIBILITY_FORWARD(get_accDefaultAction,
                      (VARIANT varChild, BSTR *pszDefaultAction),
                      (varChild, pszDefaultAction))
ACCESSIBILITY_FORWARD(accSelect,
                      (long flagsSelect, VARIANT varChild),
                      (flagsSelect, varChild))
ACCESSIBILITY_FORWARD(accLocation,
                      (long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild),
                      (pxLeft, pyTop, pcxWidth, pcyHeight, varChild))
ACCESSIBILITY_FORWARD(accNavigate,
                      (long navDir, VARIANT varStart, VARIANT *pvarEndUpAt),
                      (navDir, varStart, pvarEndUpAt))
ACCESSIBILITY_FORWARD(accHitTest,
                      (long xLeft, long yTop, VARIANT *pvarChildAtPoint),
                      (xLeft, yTop, pvarChildAtPoint))
ACCESSIBILITY_FORWARD(accDoDefaultAction,
                      (VARIANT varChild),
                      (varChild));
ACCESSIBILITY_FORWARD(put_accName,
                      (VARIANT varChild, BSTR szName),
                      (varChild, szName))
ACCESSIBILITY_FORWARD(put_accValue,
                      (VARIANT varChild, BSTR pszValue),
                      (varChild, pszValue));


LRESULT CALLBACK CAccessible::s_SubclassProc(
                         HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                         UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    CAccessible *self = reinterpret_cast<CAccessible *>(dwRefData);

    switch (uMsg)
    {

    case WM_GETOBJECT:
        if ((DWORD)lParam == OBJID_CLIENT) {
            HRESULT hr;

            // Create the accessibility object for the inner listview if we haven't already
            // We forward nearly all calls to the inner IAccessible.
            if (!self->_paccInner)
            {
                hr = CreateStdAccessibleObject(hwnd, (DWORD)lParam, IID_PPV_ARG(IAccessible, &self->_paccInner));
            } else {
                hr = S_OK;
            }

            if (SUCCEEDED(hr))
            {
                return LresultFromObject(IID_IAccessible, wParam, SAFECAST(self, IAccessible *));
            } else {
                return hr;
            }
        };
        break;

    case WM_NCDESTROY:
        RemoveWindowSubclass(hwnd, s_SubclassProc, 0);
        break;


    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

HRESULT CAccessible::GetRoleString(DWORD dwRole, BSTR *pbsOut)
{
    *pbsOut = NULL;

    WCHAR szBuf[MAX_PATH];
    if (GetRoleTextW(dwRole, szBuf, ARRAYSIZE(szBuf)))
    {
        *pbsOut = SysAllocString(szBuf);
    }

    return *pbsOut ? S_OK : E_OUTOFMEMORY;
}

HRESULT CAccessible::CreateAcceleratorBSTR(TCHAR tch, BSTR *pbsOut)
{
    TCHAR sz[2] = { tch, 0 };
    *pbsOut = SysAllocString(sz);
    return *pbsOut ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\logoff.cpp ===
#include "stdafx.h"
#include "sfthost.h"
#include "uxtheme.h"
#include "uxthemep.h"
#include "rcids.h"

// WARNING!  Must be in sync with c_rgidmLegacy

#define NUM_TBBUTTON_IMAGES 3
static const TBBUTTON tbButtonsCreate [] = 
{
    {0, SMNLC_EJECT,    TBSTATE_ENABLED, BTNS_SHOWTEXT|BTNS_AUTOSIZE, {0,0}, IDS_LOGOFF_TIP_EJECT, 0},
    {1, SMNLC_LOGOFF,   TBSTATE_ENABLED, BTNS_SHOWTEXT|BTNS_AUTOSIZE, {0,0}, IDS_LOGOFF_TIP_LOGOFF, 1},
    {2, SMNLC_TURNOFF,  TBSTATE_ENABLED, BTNS_SHOWTEXT|BTNS_AUTOSIZE, {0,0}, IDS_LOGOFF_TIP_SHUTDOWN, 2},
    {2,SMNLC_DISCONNECT,TBSTATE_ENABLED, BTNS_SHOWTEXT|BTNS_AUTOSIZE, {0,0}, IDS_LOGOFF_TIP_DISCONNECT, 3},
};

// WARNING!  Must be in sync with tbButtonsCreate
static const UINT c_rgidmLegacy[] =
{
    IDM_EJECTPC,
    IDM_LOGOFF,
    IDM_EXITWIN,
    IDM_MU_DISCONNECT,
};

class CLogoffPane
    : public CUnknown
    , public CAccessible
{
public:

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CUnknown::AddRef(); }
    STDMETHODIMP_(ULONG) Release(void) { return CUnknown::Release(); }

    // *** IAccessible overridden methods ***
    STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut);
    STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction);

    CLogoffPane::CLogoffPane();
    CLogoffPane::~CLogoffPane();

    static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnCreate(LPARAM lParam);
    void _OnDestroy();
    LRESULT _OnNCCreate(HWND hwnd,  UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnNCDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnNotify(NMHDR *pnm);
    LRESULT _OnCommand(int id);
    LRESULT _OnCustomDraw(NMTBCUSTOMDRAW *pnmcd);
    LRESULT _OnSMNFindItem(PSMNDIALOGMESSAGE pdm);
    LRESULT _OnSMNFindItemWorker(PSMNDIALOGMESSAGE pdm);
    LRESULT _OnSysColorChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnDisplayChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnSettingChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void    _InitMetrics();
    LRESULT _OnSize(int x, int y);

private:
    HWND _hwnd;
    HWND _hwndTB;
    HWND _hwndTT;   //Tooltip window.
    COLORREF _clr;
    int      _colorHighlight;
    int      _colorHighlightText;
    HTHEME _hTheme;
    BOOL   _fSettingHotItem;
    MARGINS _margins;

    // helper functions
    int _GetCurButton();
    LRESULT _NextVisibleButton(PSMNDIALOGMESSAGE pdm, int i, int direction);
    BOOL _IsButtonHidden(int i);
    TCHAR _GetButtonAccelerator(int i);
    void _RightAlign();
    void _ApplyOptions();

    BOOL _SetTBButtons(int id, UINT iMsg);
    BOOL _ThemedSetTBButtons(int iState, UINT iMsg);

    friend BOOL CLogoffPane_RegisterClass();
};

CLogoffPane::CLogoffPane()
{
    ASSERT(_hwndTB == NULL);
    ASSERT(_hwndTT == NULL);
    _clr = CLR_INVALID;
}

CLogoffPane::~CLogoffPane()
{
}

HRESULT CLogoffPane::QueryInterface(REFIID riid, void * *ppvOut)
{
    static const QITAB qit[] = {
        QITABENT(CLogoffPane, IAccessible),
        QITABENT(CLogoffPane, IDispatch), // IAccessible derives from IDispatch
        { 0 },
    };
    return QISearch(this, qit, riid, ppvOut);
}

LRESULT CALLBACK CLogoffPane::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CLogoffPane *self = reinterpret_cast<CLogoffPane *>(GetWindowPtr0(hwnd));

    switch (uMsg)
    {
        case WM_NCCREATE:
            return self->_OnNCCreate(hwnd, uMsg, wParam, lParam);

        case WM_CREATE:
            return self->_OnCreate(lParam);

        case WM_DESTROY:
            self->_OnDestroy();
            break;

        case WM_NCDESTROY:
            return self->_OnNCDestroy(hwnd, uMsg, wParam, lParam);

        case WM_ERASEBKGND:
        {
            RECT rc;
            GetClientRect(hwnd, &rc);
            if (self->_hTheme)
            {
                DrawThemeBackground(self->_hTheme, (HDC)wParam, SPP_LOGOFF, 0, &rc, 0);
            }
            else
            {
                SHFillRectClr((HDC)wParam, &rc, GetSysColor(COLOR_MENU));
                DrawEdge((HDC)wParam, &rc, EDGE_ETCHED, BF_TOP);
            }
    
            return 1;
        }

        case WM_COMMAND:
            return self->_OnCommand(GET_WM_COMMAND_ID(wParam, lParam));

        case WM_NOTIFY:
            return self->_OnNotify((NMHDR*)(lParam));

        case WM_SIZE:
            return self->_OnSize(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

        case WM_SYSCOLORCHANGE:
            return self->_OnSysColorChange(hwnd, uMsg, wParam, lParam);
            
        case WM_DISPLAYCHANGE:
            return self->_OnDisplayChange(hwnd, uMsg, wParam, lParam);
            
        case WM_SETTINGCHANGE:
            return self->_OnSettingChange(hwnd, uMsg, wParam, lParam);
    }
    return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CLogoffPane::_OnNCCreate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPCREATESTRUCT lpcs = reinterpret_cast<LPCREATESTRUCT>(lParam);

    CLogoffPane *self = new CLogoffPane;

    if (self)
    {
        SetWindowPtr0(hwnd, self);

        self->_hwnd = hwnd;

        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return FALSE;
}



void AddBitmapToToolbar(HWND hwndTB, HBITMAP hBitmap, int cxTotal, int cy, UINT iMsg)
{
    HIMAGELIST himl = ImageList_Create(cxTotal / NUM_TBBUTTON_IMAGES, cy, ILC_COLOR32, 0, NUM_TBBUTTON_IMAGES);

    if (himl)
    {
        ImageList_Add(himl, hBitmap, NULL);

        HIMAGELIST himlPrevious = (HIMAGELIST) SendMessage(hwndTB, iMsg, 0, (LPARAM)himl);
        if (himlPrevious)
        {
            ImageList_Destroy(himlPrevious);
        }
    }
}

BOOL CLogoffPane::_SetTBButtons(int id, UINT iMsg)
{
    HBITMAP hBitmap = LoadBitmap(_Module.GetModuleInstance(), MAKEINTRESOURCE(id));
    if (hBitmap)
    {
        BITMAP bm;
        if (GetObject(hBitmap, sizeof(BITMAP), &bm))
        {
            AddBitmapToToolbar(_hwndTB, hBitmap, bm.bmWidth, bm.bmHeight, iMsg);
        }
        DeleteObject(hBitmap);
    }
    return BOOLIFY(hBitmap);
}

BOOL CLogoffPane::_ThemedSetTBButtons(int iState, UINT iMsg)
{
    BOOL bRet = FALSE;
    HDC hdcScreen = GetDC(NULL);
    HDC hdc = CreateCompatibleDC(hdcScreen);
    if (hdc)
    {
        SIZE siz;
        if (SUCCEEDED(GetThemePartSize(_hTheme, NULL, SPP_LOGOFFBUTTONS, iState, 
            NULL, TS_TRUE, &siz)))
        {
            void *pvDestBits;
            BITMAPINFO bi = {0};

            bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
            bi.bmiHeader.biWidth = siz.cx;
            bi.bmiHeader.biHeight = siz.cy;
            bi.bmiHeader.biPlanes = 1;
            bi.bmiHeader.biBitCount = 32;
            bi.bmiHeader.biCompression = BI_RGB;

            // Create a DIB Section so we can force it to be 32 bits, and preserve the alpha channel.
            HBITMAP hbm = CreateDIBSection(hdcScreen, &bi, DIB_RGB_COLORS, &pvDestBits, NULL, 0);
            if (hbm)
            {
                HBITMAP hbmOld = (HBITMAP) SelectObject(hdc, hbm);

                RECT rc={0,0,siz.cx,siz.cy};

                // draws into the DC, which updates the bitmap
                DTBGOPTS dtbg = {sizeof(DTBGOPTS), DTBG_DRAWSOLID, 0,};   // tell drawthemebackground to preserve the alpha channel
                bRet = SUCCEEDED(DrawThemeBackgroundEx(_hTheme, hdc, SPP_LOGOFFBUTTONS, iState, &rc, &dtbg));

                SelectObject(hdc, hbmOld);                                  // unselect the bitmap, so we can use it

                if (bRet)
                    AddBitmapToToolbar(_hwndTB, hbm, siz.cx, siz.cy, iMsg);

                DeleteObject(hbm);
            }
        }
        DeleteDC(hdc);
    }
    if (hdcScreen)
        ReleaseDC(NULL, hdcScreen);

    return bRet;
}

void CLogoffPane::_OnDestroy()
{
    if (IsWindow(_hwndTB))
    {
        HIMAGELIST himl = (HIMAGELIST) SendMessage(_hwndTB, TB_GETIMAGELIST, 0, 0);

        if (himl)
        {
            ImageList_Destroy(himl);
        }

        himl = (HIMAGELIST) SendMessage(_hwndTB, TB_GETHOTIMAGELIST, 0, 0);
        if (himl)
        {
            ImageList_Destroy(himl);
        }
    }
}

LRESULT CLogoffPane::_OnCreate(LPARAM lParam)
{
    // Do not set WS_TABSTOP here; that's CLogoffPane's job

    DWORD dwStyle = WS_CHILD|WS_CLIPSIBLINGS|WS_VISIBLE | CCS_NORESIZE|CCS_NODIVIDER | TBSTYLE_FLAT|TBSTYLE_LIST|TBSTYLE_TOOLTIPS;
    RECT rc;

    _hTheme = (PaneDataFromCreateStruct(lParam))->hTheme;

    if (_hTheme)
    {
        GetThemeColor(_hTheme, SPP_LOGOFF, 0, TMT_TEXTCOLOR, &_clr);
        _colorHighlight = COLOR_MENUHILIGHT;
        _colorHighlightText = COLOR_HIGHLIGHTTEXT;

        GetThemeMargins(_hTheme, NULL, SPP_LOGOFF, 0, TMT_CONTENTMARGINS, NULL, &_margins);
    }
    else
    {
        _clr = GetSysColor(COLOR_MENUTEXT);
        _colorHighlight = COLOR_HIGHLIGHT;
        _colorHighlightText = COLOR_HIGHLIGHTTEXT;

        _margins.cyTopHeight = _margins.cyBottomHeight = 2 * GetSystemMetrics(SM_CYEDGE);
        ASSERT(_margins.cxLeftWidth == 0);
        ASSERT(_margins.cxRightWidth == 0);
    }

    GetClientRect(_hwnd, &rc);
    rc.left += _margins.cxLeftWidth;
    rc.right -= _margins.cxRightWidth;
    rc.top += _margins.cyTopHeight;
    rc.bottom -= _margins.cyBottomHeight;

    _hwndTB = CreateWindowEx(0, TOOLBARCLASSNAME, NULL, dwStyle,
                               rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), _hwnd, 
                               NULL, NULL, NULL );
    if (_hwndTB)
    {
        //
        //  Don't freak out if this fails.  It just means that the accessibility
        //  stuff won't be perfect.
        //
        SetAccessibleSubclassWindow(_hwndTB);

        // we do our own themed drawing...
        SetWindowTheme(_hwndTB, L"", L"");

        // Scale up on HIDPI
        SendMessage(_hwndTB, CCM_DPISCALE, TRUE, 0);

        SendMessage(_hwndTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

        if (!_hTheme ||
            !_ThemedSetTBButtons(SPLS_NORMAL, TB_SETIMAGELIST) ||
            !_ThemedSetTBButtons(SPLS_HOT, TB_SETHOTIMAGELIST) )
        {
            // if we don't have a theme, or failed at setting the images from the theme
            // set buttons images from the rc file
            _SetTBButtons(IDB_LOGOFF_NORMAL, TB_SETIMAGELIST);
            _SetTBButtons(IDB_LOGOFF_HOT, TB_SETHOTIMAGELIST);
        }
        
        SendMessage(_hwndTB, TB_ADDBUTTONS, ARRAYSIZE(tbButtonsCreate), (LPARAM) tbButtonsCreate);
        int idText = IsOS(OS_FRIENDLYLOGONUI) ? IDS_LOGOFF_TEXT_FRIENDLY : IDS_LOGOFF_TEXT_DOMAIN;
        SendMessage(_hwndTB, TB_ADDSTRING, (WPARAM) _Module.GetModuleInstance(), (LPARAM) idText);

        _ApplyOptions();

        _hwndTT = (HWND)SendMessage(_hwndTB, TB_GETTOOLTIPS, 0, 0); //Get the tooltip window.

        _InitMetrics();
        
        return 0;
    }

    return -1; // no point in sticking around if we couldn't create the toolbar
}

BOOL CLogoffPane::_IsButtonHidden(int i)
{
    TBBUTTON but;
    SendMessage(_hwndTB, TB_GETBUTTON, i, (LPARAM) &but);
    return but.fsState & TBSTATE_HIDDEN;
}

void CLogoffPane::_RightAlign()
{
    int iWidthOfButtons=0;

    // add up the width of all the non-hidden buttons
    for(int i=0;i<ARRAYSIZE(tbButtonsCreate);i++)
    {
        if (!_IsButtonHidden(i))
        {
            RECT rc;
            SendMessage(_hwndTB, TB_GETITEMRECT, i, (LPARAM) &rc);
            iWidthOfButtons += RECTWIDTH(rc);
        }
    }

    if (iWidthOfButtons)
    {
        RECT rc;
        GetClientRect(_hwndTB, &rc);

        int iIndent = RECTWIDTH(rc) - iWidthOfButtons - GetSystemMetrics(SM_CXEDGE);

        if (iIndent < 0)
            iIndent = 0;
        SendMessage(_hwndTB, TB_SETINDENT, iIndent, 0);
    }
}

LRESULT CLogoffPane::_OnSize(int x, int y)
{
    if (_hwndTB)
    {
        SetWindowPos(_hwndTB, NULL, _margins.cxLeftWidth, _margins.cyTopHeight, 
            x-(_margins.cxRightWidth+_margins.cxLeftWidth), y-(_margins.cyBottomHeight+_margins.cyTopHeight), 
            SWP_NOACTIVATE | SWP_NOOWNERZORDER);
        _RightAlign();
    }
    return 0;
}

LRESULT CLogoffPane::_OnNCDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // WARNING!  "this" might be invalid (if WM_NCCREATE failed), so
    // do not use any member variables!
    LRESULT lres = DefWindowProc(hwnd, uMsg, wParam, lParam);
    SetWindowPtr0(hwnd, 0);
    if (this)
    {
        this->Release();
    }
    return lres;
}

void CLogoffPane::_ApplyOptions()
{
    SMNFILTEROPTIONS nmopt;
    nmopt.smnop = SMNOP_LOGOFF | SMNOP_TURNOFF | SMNOP_DISCONNECT | SMNOP_EJECT;
    _SendNotify(_hwnd, SMN_FILTEROPTIONS, &nmopt.hdr);

    SendMessage(_hwndTB, TB_HIDEBUTTON, SMNLC_EJECT, !(nmopt.smnop & SMNOP_EJECT));
    SendMessage(_hwndTB, TB_HIDEBUTTON, SMNLC_LOGOFF, !(nmopt.smnop & SMNOP_LOGOFF));
    SendMessage(_hwndTB, TB_HIDEBUTTON, SMNLC_TURNOFF, !(nmopt.smnop & SMNOP_TURNOFF));
    SendMessage(_hwndTB, TB_HIDEBUTTON, SMNLC_DISCONNECT, !(nmopt.smnop & SMNOP_DISCONNECT));

    _RightAlign();
}


LRESULT CLogoffPane::_OnNotify(NMHDR *pnm)
{
    if (pnm->hwndFrom == _hwndTB)
    {
        switch (pnm->code)
        {
            case NM_CUSTOMDRAW:
                return _OnCustomDraw((NMTBCUSTOMDRAW*)pnm);
            case TBN_WRAPACCELERATOR:
                return TRUE;            // Disable wraparound; we want DeskHost to do navigation
            case TBN_GETINFOTIP:
                {
                    NMTBGETINFOTIP *ptbgit = (NMTBGETINFOTIP *)pnm;
                    ASSERT(ptbgit->lParam >= IDS_LOGOFF_TIP_EJECT && ptbgit->lParam <= IDS_LOGOFF_TIP_DISCONNECT);
                    LoadString(_Module.GetModuleInstance(), ptbgit->lParam, ptbgit->pszText, ptbgit->cchTextMax);
                    return TRUE;
                }
            case TBN_HOTITEMCHANGE:
                {
                    // Disallow setting a hot item if we are not focus
                    // (unless it was specifically our idea in the first place)
                    // Otherwise we interfere with keyboard navigation

                    NMTBHOTITEM *phot = (NMTBHOTITEM*)pnm;
                    if (!(phot->dwFlags & HICF_LEAVING) &&
                        GetFocus() != pnm->hwndFrom &&
                        !_fSettingHotItem)
                    {
                        return TRUE; // deny hot item change
                    }
                }
                break;

        }
    }
    else // from host
    {
        switch (pnm->code)
        {
            case SMN_REFRESHLOGOFF:
                _ApplyOptions();
                return TRUE;
            case SMN_FINDITEM:
                return _OnSMNFindItem(CONTAINING_RECORD(pnm, SMNDIALOGMESSAGE, hdr));
            case SMN_APPLYREGION:
                return HandleApplyRegion(_hwnd, _hTheme, (SMNMAPPLYREGION *)pnm, SPP_LOGOFF, 0);
        }
    }

    return FALSE;
}

LRESULT CLogoffPane::_OnCommand(int id)
{
    int i;
    for (i = 0; i < ARRAYSIZE(tbButtonsCreate); i++)
    {
        if (tbButtonsCreate[i].idCommand == id)
        {
            if (!_IsButtonHidden(i))
            {
                PostMessage(v_hwndTray, WM_COMMAND, c_rgidmLegacy[i], 0);
                SMNMCOMMANDINVOKED ci;
                SendMessage(_hwndTB, TB_GETITEMRECT, i,  (LPARAM)&ci.rcItem);
                MapWindowRect(_hwndTB, NULL, &ci.rcItem);
                _SendNotify(_hwnd, SMN_COMMANDINVOKED, &ci.hdr);
            }
            break;
        }
    }
    return 0;
}

LRESULT CLogoffPane::_OnCustomDraw(NMTBCUSTOMDRAW *pnmtbcd)
{
    LRESULT lres;

    switch (pnmtbcd->nmcd.dwDrawStage)
    {
        case CDDS_PREPAINT:
            return CDRF_NOTIFYITEMDRAW;
        
        case CDDS_ITEMPREPAINT:
#if 0       //Do we still need this?
            pnmtbcd->nHLStringBkMode = TRANSPARENT; // needed to reduce flicker- bug in toolbar?
#endif

            pnmtbcd->clrText = _clr;
            pnmtbcd->clrTextHighlight = GetSysColor(_colorHighlightText);
            pnmtbcd->clrHighlightHotTrack = GetSysColor(_colorHighlight);

            lres = TBCDRF_NOEDGES | TBCDRF_HILITEHOTTRACK;

            // todo - FIX TOOLBAR to respect clrTextHighlight when item is hot.
            if (pnmtbcd->nmcd.uItemState == CDIS_HOT)
            {
                pnmtbcd->clrText = pnmtbcd->clrTextHighlight;
            }

            return lres;
    }
    return CDRF_DODEFAULT;
}

LRESULT CLogoffPane::_NextVisibleButton(PSMNDIALOGMESSAGE pdm, int i, int direction)
{
    ASSERT(direction == +1 || direction == -1);

    i += direction;
    while (i >= 0 && i < ARRAYSIZE(tbButtonsCreate))
    {
        if (!_IsButtonHidden(i))
        {
            pdm->itemID = i;
            return TRUE;
        }
        i += direction;
    }
    return FALSE;
}

int CLogoffPane::_GetCurButton()
{
    return (int)SendMessage(_hwndTB, TB_GETHOTITEM, 0, 0);
}

LRESULT CLogoffPane::_OnSMNFindItem(PSMNDIALOGMESSAGE pdm)
{
    LRESULT lres = _OnSMNFindItemWorker(pdm);

    if (lres)
    {
        //
        //  If caller requested that the item also be selected, then do so.
        //
        if (pdm->flags & SMNDM_SELECT)
        {
            if (_GetCurButton() != pdm->itemID)
            {
                // Explicitly pop the tooltip so we don't have the problem
                // of a "virtual" tooltip causing the infotip to appear
                // the instant the mouse moves into the window.
                if (_hwndTT)
                {
                    SendMessage(_hwndTT, TTM_POP, 0, 0);
                }

                // _fSettingHotItem tells our WM_NOTIFY handler to
                // allow this hot item change to go through
                _fSettingHotItem = TRUE;
                SendMessage(_hwndTB, TB_SETHOTITEM, pdm->itemID, 0);
                _fSettingHotItem = FALSE;

                // Do the SetFocus after setting the hot item to prevent
                // toolbar from autoselecting the first button (which
                // is what it does if you SetFocus when there is no hot
                // item).  SetFocus returns the previous focus window.
                if (SetFocus(_hwndTB) != _hwndTB)
                {
                    // Send the notify since we tricked toolbar into not sending it
                    // (Toolbar doesn't send a subobject focus notification
                    // on WM_SETFOCUS if the item was already hot when it gained focus)
                    NotifyWinEvent(EVENT_OBJECT_FOCUS, _hwndTB, OBJID_CLIENT, pdm->itemID + 1);
                }
            }
        }
    }
    else
    {
        //
        //  If not found, then tell caller what our orientation is (horizontal)
        //  and where the currently-selected item is.
        //

        pdm->flags |= SMNDM_HORIZONTAL;
        int i = _GetCurButton();
        RECT rc;
        if (i >= 0 && SendMessage(_hwndTB, TB_GETITEMRECT, i, (LPARAM)&rc))
        {
            pdm->pt.x = (rc.left + rc.right)/2;
            pdm->pt.y = (rc.top + rc.bottom)/2;
        }
        else
        {
            pdm->pt.x = 0;
            pdm->pt.y = 0;
        }

    }
    return lres;
}

TCHAR CLogoffPane::_GetButtonAccelerator(int i)
{
    TCHAR szText[MAX_PATH];

    // First get the length of the text
    LRESULT lRes = SendMessage(_hwndTB, TB_GETBUTTONTEXT, tbButtonsCreate[i].idCommand, (LPARAM)NULL);

    // Check if the text will fit in our buffer.
    if (lRes > 0 && lRes < MAX_PATH)
    {
        if (SendMessage(_hwndTB, TB_GETBUTTONTEXT, tbButtonsCreate[i].idCommand, (LPARAM)szText) > 0)
        {
            return CharUpperChar(SHFindMnemonic(szText));
        }
    }
    return 0;
}

//
//  Metrics changed -- update.
//
void CLogoffPane::_InitMetrics()
{
    if (_hwndTT)
    {
        // Disable/enable infotips based on user preference
        SendMessage(_hwndTT, TTM_ACTIVATE, ShowInfoTip(), 0);

        // Toolbar control doesn't set the tooltip font so we have to do it ourselves
        SetWindowFont(_hwndTT, GetWindowFont(_hwndTB), FALSE);
    }
}

LRESULT CLogoffPane::_OnDisplayChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Propagate first because _InitMetrics needs to talk to the updated toolbar
    SHPropagateMessage(hwnd, uMsg, wParam, lParam, SPM_SEND | SPM_ONELEVEL);
    _InitMetrics();
    return 0;
}

LRESULT CLogoffPane::_OnSettingChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Propagate first because _InitMetrics needs to talk to the updated toolbar
    SHPropagateMessage(hwnd, uMsg, wParam, lParam, SPM_SEND | SPM_ONELEVEL);
    // _InitMetrics() is so cheap it's not worth getting too upset about
    // calling it too many times.
    _InitMetrics();
    _RightAlign();
    return 0;
}

LRESULT CLogoffPane::_OnSysColorChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // update colors in classic mode
    if (!_hTheme)
    {
        _clr = GetSysColor(COLOR_MENUTEXT);
    }

    SHPropagateMessage(hwnd, uMsg, wParam, lParam, SPM_SEND | SPM_ONELEVEL);
    return 0;
}



LRESULT CLogoffPane::_OnSMNFindItemWorker(PSMNDIALOGMESSAGE pdm)
{
    int i;
    switch (pdm->flags & SMNDM_FINDMASK)
    {
    case SMNDM_FINDFIRST:
        return _NextVisibleButton(pdm, -1, +1);

    case SMNDM_FINDLAST:
        return _NextVisibleButton(pdm, ARRAYSIZE(tbButtonsCreate), -1);

    case SMNDM_FINDNEAREST:
        // HACK! but we know that we are the only control in our group
        // so this doesn't need to be implemented
        return FALSE;

    case SMNDM_HITTEST:
        pdm->itemID = SendMessage(_hwndTB, TB_HITTEST, 0, (LPARAM)&pdm->pt);
        return pdm->itemID >= 0;

    case SMNDM_FINDFIRSTMATCH:
    case SMNDM_FINDNEXTMATCH:
        {
            if ((pdm->flags & SMNDM_FINDMASK) == SMNDM_FINDFIRSTMATCH)
            {
                i = 0;
            }
            else
            {
                i = _GetCurButton() + 1;
            }

            TCHAR tch = CharUpperChar((TCHAR)pdm->pmsg->wParam);
            for ( ; i < ARRAYSIZE(tbButtonsCreate); i++)
            {
                if (_IsButtonHidden(i))
                    continue;               // skip hidden buttons
                if (_GetButtonAccelerator(i) == tch)
                {
                    pdm->itemID = i;
                    return TRUE;
                }
            }
        }
        break;      // not found

    case SMNDM_FINDNEXTARROW:
        switch (pdm->pmsg->wParam)
        {
        case VK_LEFT:
        case VK_UP:
            return _NextVisibleButton(pdm, _GetCurButton(), -1);

        case VK_RIGHT:
        case VK_DOWN:
            return _NextVisibleButton(pdm, _GetCurButton(), +1);
        }

        return FALSE;           // not found

    case SMNDM_INVOKECURRENTITEM:
        i = _GetCurButton();
        if (i >= 0 && i < ARRAYSIZE(tbButtonsCreate))
        {
            FORWARD_WM_COMMAND(_hwnd, tbButtonsCreate[i].idCommand, _hwndTB, BN_CLICKED, PostMessage);
            return TRUE;
        }
        return FALSE;

    case SMNDM_OPENCASCADE:
        return FALSE;           // none of our items cascade

    default:
        ASSERT(!"Unknown SMNDM command");
        break;
    }

    return FALSE;
}

HRESULT CLogoffPane::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut)
{
    if (varChild.lVal)
    {
        return CreateAcceleratorBSTR(_GetButtonAccelerator(varChild.lVal - 1), pszKeyboardShortcut);
    }
    return CAccessible::get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}

HRESULT CLogoffPane::get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction)
{
    if (varChild.lVal)
    {
        return GetRoleString(ACCSTR_EXECUTE, pszDefAction);
    }
    return CAccessible::get_accDefaultAction(varChild, pszDefAction);
}


BOOL WINAPI LogoffPane_RegisterClass()
{
    WNDCLASSEX wc;
    ZeroMemory( &wc, sizeof(wc) );
    
    wc.cbSize        = sizeof(wc);
    wc.style         = CS_GLOBALCLASS;
    wc.cbWndExtra    = sizeof(LPVOID);
    wc.lpfnWndProc   = CLogoffPane::WndProc;
    wc.hInstance     = _Module.GetModuleInstance();
    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hbrBackground = (HBRUSH)(NULL);
    wc.lpszClassName = TEXT("DesktopLogoffPane");

    return RegisterClassEx( &wc );
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\proglist.cpp ===
#include "stdafx.h"
#include "proglist.h"
#include "uemapp.h"
#include <shdguid.h>
#include "shguidp.h"        // IID_IInitializeObject
#include <pshpack4.h>
#include <idhidden.h>       // Note!  idhidden.h requires pack4
#include <poppack.h>
#include <userenv.h>        // GetProfileType
#include <desktray.h>
#include "tray.h"
#define STRSAFE_NO_CB_FUNCTIONS
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

// Global cache item being passed from the background task to the start panel ByUsage.
CMenuItemsCache *g_pMenuCache;


// From startmnu.cpp
HRESULT Tray_RegisterHotKey(WORD wHotKey, LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl);

#define TF_PROGLIST 0x00000020

#define CH_DARWINMARKER TEXT('\1')  // Illegal filename character

#define IsDarwinPath(psz) ((psz)[0] == CH_DARWINMARKER)

// Largest date representable in FILETIME - rolls over in the year 30828
static const FILETIME c_ftNever = { 0xFFFFFFFF, 0x7FFFFFFF };

void GetStartTime(FILETIME *pft)
{
    //
    //  If policy says "Don't offer new apps", then set the New App
    //  threshold to some impossible time in the future.
    //
    if (!SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, REGSTR_VAL_DV2_NOTIFYNEW, FALSE, TRUE))
    {
        *pft = c_ftNever;
        return;
    }

    FILETIME ftNow;
    GetSystemTimeAsFileTime(&ftNow);

    DWORD dwSize = sizeof(*pft);
    //Check to see if we have the StartMenu start Time for this user saved in the registry.
    if(SHRegGetUSValue(DV2_REGPATH, DV2_SYSTEM_START_TIME, NULL,
                       pft, &dwSize, FALSE, NULL, 0) != ERROR_SUCCESS)
    {
        // Get the current system time as the start time. If any app is launched after
        // this time, that will result in the OOBE message going away!
        *pft = ftNow;

        dwSize = sizeof(*pft);

        //Save this time as the StartMenu start time for this user.
        SHRegSetUSValue(DV2_REGPATH, DV2_SYSTEM_START_TIME, REG_BINARY,
                        pft, dwSize, SHREGSET_FORCE_HKCU);
    }

    //
    //  Thanks to roaming and reinstalls, the user may have installed a new
    //  OS since they first turned on the Start Menu, so bump forwards to
    //  the time the OS was installed (plus some fudge to account for the
    //  time it takes to run Setup) so all the Accessories don't get marked
    //  as "New".
    //
    DWORD dwTime;
    dwSize = sizeof(dwTime);
    if (SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                   TEXT("InstallDate"), NULL, &dwTime, &dwSize) == ERROR_SUCCESS)
    {
        // Sigh, InstallDate is stored in UNIX time format, not FILETIME,
        // so convert it to FILETIME.  Q167296 shows how to do this.
        LONGLONG ll = Int32x32To64(dwTime, 10000000) + 116444736000000000;

        // Add some fudge to account for how long it takes to run Setup
        ll += FT_ONEHOUR * 5;       // five hours should be plenty

        FILETIME ft;
        SetFILETIMEfromInt64(&ft, ll);

        //
        //  But don't jump forwards into the future
        //
        if (::CompareFileTime(&ft, &ftNow) > 0)
        {
            ft = ftNow;
        }

        if (::CompareFileTime(pft, &ft) < 0)
        {
            *pft = ft;
        }

    }

    //
    //  If this is a roaming profile, then don't count anything that
    //  happened before the user logged on because we don't want to mark
    //  apps as new just because it roamed in with the user at logon.
    //  We actually key off of the start time of Explorer, because
    //  Explorer starts after the profiles are sync'd so we don't need
    //  a fudge factor.
    //
    DWORD dwType;
    if (GetProfileType(&dwType) && (dwType & (PT_TEMPORARY | PT_ROAMING)))
    {
        FILETIME ft, ftIgnore;
        if (GetProcessTimes(GetCurrentProcess(), &ft, &ftIgnore, &ftIgnore, &ftIgnore))
        {
            if (::CompareFileTime(pft, &ft) < 0)
            {
                *pft = ft;
            }
        }
    }

}

//****************************************************************************
//
//  How the pieces fit together...
//
//
//  Each ByUsageRoot consists of a ByUsageShortcutList.
//
//  A ByUsageShortcutList is a list of shortcuts.
//
//  Each shortcut references a ByUsageAppInfo.  Multiple shortcuts can
//  reference the same ByUsageAppInfo if they are all shortcuts to the same
//  app.
//
//  The ByUsageAppInfo::_cRef is the number of ByUsageShortcut's that
//  reference it.
//
//  A master list of all ByUsageAppInfo's is kept in _dpaAppInfo.
//

//****************************************************************************

//
//  Helper template for destroying DPA's.
//
//  DPADELETEANDDESTROY(dpa);
//
//  invokes the "delete" method on each pointer in the DPA,
//  then destroys the DPA.
//

template<class T>
BOOL CALLBACK _DeleteCB(T *self, LPVOID)
{
    delete self;
    return TRUE;
}

template<class T>
void DPADELETEANDDESTROY(CDPA<T> &dpa)
{
    if (dpa)
    {
        dpa.DestroyCallback(_DeleteCB<T>, NULL);
        ASSERT(dpa == NULL);
    }
}

//****************************************************************************

void ByUsageRoot::Reset()
{
    DPADELETEANDDESTROY(_sl);
    DPADELETEANDDESTROY(_slOld);

    ILFree(_pidl);
    _pidl = NULL;
};

//****************************************************************************

class ByUsageDir
{
    IShellFolder *_psf;         // the folder interface
    LPITEMIDLIST _pidl;         // the absolute pidl for this folder
    LONG         _cRef;         // Reference count

    ByUsageDir() : _cRef(1) { }
    ~ByUsageDir() { ATOMICRELEASE(_psf); ILFree(_pidl); }

public:
    // Creates a ByUsageDir for CSIDL_DESKTOP.  All other
    // ByUsageDir's come from this.
    static ByUsageDir *CreateDesktop()
    {
        ByUsageDir *self = new ByUsageDir();
        if (self)
        {
            ASSERT(self->_pidl == NULL);
            if (SUCCEEDED(SHGetDesktopFolder(&self->_psf)))
            {
                // all is well
                return self;
            }
            
            delete self;
        }

        return NULL;
    }

    // pdir = parent folder
    // pidl = new folder location relative to parent
    static ByUsageDir *Create(ByUsageDir *pdir, LPCITEMIDLIST pidl)
    {
        ByUsageDir *self = new ByUsageDir();
        if (self)
        {
            LPCITEMIDLIST pidlRoot = pdir->_pidl;
            self->_pidl = ILCombine(pidlRoot, pidl);
            if (self->_pidl)
            {
                IShellFolder *psfRoot = pdir->_psf;
                if (SUCCEEDED(SHBindToObject(psfRoot,
                              IID_X_PPV_ARG(IShellFolder, pidl, &self->_psf))))
                {
                    // all is well
                    return self;
                }
            }

            delete self;
        }
        
        return NULL;
    }

    void AddRef();
    void Release();
    IShellFolder *Folder() const { return _psf; }
    LPCITEMIDLIST Pidl() const { return _pidl; }
};

void ByUsageDir::AddRef()
{
    InterlockedIncrement(&_cRef);
}

void ByUsageDir::Release()
{
    ASSERT( 0 != _cRef );
    if (InterlockedDecrement(&_cRef) == 0)
    {
        delete this;
    }
}


//****************************************************************************

class ByUsageItem : public PaneItem
{
public:
    LPITEMIDLIST _pidl;     // relative pidl
    ByUsageDir *_pdir;      // Parent directory
    UEMINFO _uei;           /* Usage info (for sorting) */

    static ByUsageItem *Create(ByUsageShortcut *pscut);
    static ByUsageItem *CreateSeparator();

    ByUsageItem() { EnableDropTarget(); }
    ~ByUsageItem();

    ByUsageDir *Dir() const { return _pdir; }
    IShellFolder *ParentFolder() const { return _pdir->Folder(); }
    LPCITEMIDLIST RelativePidl() const { return _pidl; }
    LPITEMIDLIST CreateFullPidl() const { return ILCombine(_pdir->Pidl(), _pidl); }
    void SetRelativePidl(LPITEMIDLIST pidlNew) { ILFree(_pidl); _pidl = pidlNew; }

    virtual BOOL IsEqual(PaneItem *pItem) const 
    {
        ByUsageItem *pbuItem = reinterpret_cast<ByUsageItem *>(pItem);
        BOOL fIsEqual = FALSE;
        if (_pdir == pbuItem->_pdir)
        {
            // Do we have identical pidls?
            // Note: this test needs to be fast, and does not need to be exact, so we don't use pidl binding here.
            UINT usize1 = ILGetSize(_pidl);
            UINT usize2 = ILGetSize(pbuItem->_pidl);
            if (usize1 == usize2)
            {
                fIsEqual = (memcmp(_pidl, pbuItem->_pidl, usize1) == 0);
            }
        }

        return fIsEqual; 
    }
};

inline BOOL ByUsage::_IsPinned(ByUsageItem *pitem)
{
    return pitem->Dir() == _pdirDesktop;
}

//****************************************************************************

// Each app referenced by a command line is saved in one of these
// structures.

class ByUsageAppInfo {          // "papp"
public:
    ByUsageShortcut *_pscutBest;// best candidate so far
    ByUsageShortcut *_pscutBestSM;// best candidate so far on Start Menu (excludes Desktop)
    UEMINFO _ueiBest;           // info about best candidate so far
    UEMINFO _ueiTotal;          // cumulative information
    LPTSTR  _pszAppPath;        // path to app in question
    FILETIME _ftCreated;        // when was file created?
    bool    _fNew;              // is app new?
    bool    _fPinned;           // is app referenced by a pinned item?
    bool    _fIgnoreTimestamp;  // Darwin apps have unreliable timestamps
private:
    LONG    _cRef;              // reference count

public:

    // WARNING!  Initialize() is called multiple times, so make sure
    // that you don't leak anything
    BOOL Initialize(LPCTSTR pszAppPath, CMenuItemsCache *pmenuCache, BOOL fCheckNew, bool fIgnoreTimestamp)
    {
        TraceMsg(TF_PROGLIST, "%p.ai.Init(%s)", this, pszAppPath);
        ASSERT(IsBlank());

        _fIgnoreTimestamp = fIgnoreTimestamp || IsDarwinPath(pszAppPath);

        // Note! Str_SetPtr is last so there's nothing to free on failure

        if (_fIgnoreTimestamp)
        {
            // just save the path; ignore the timestamp
            if (Str_SetPtr(&_pszAppPath, pszAppPath))
            {
                _fNew = TRUE;
                return TRUE;
            }
        }
        else
        if (Str_SetPtr(&_pszAppPath, pszAppPath))
        {
            if (fCheckNew && GetFileCreationTime(pszAppPath, &_ftCreated))
            {
                _fNew = pmenuCache->IsNewlyCreated(&_ftCreated);
            }
            return TRUE;
        }

        return FALSE;
    }

    static ByUsageAppInfo *Create()
    {
        ByUsageAppInfo *papp = new ByUsageAppInfo;
        if (papp)
        {
            ASSERT(papp->IsBlank());        // will be AddRef()d by caller
            ASSERT(papp->_pszAppPath == NULL);
        }
        return papp;
    }

    ~ByUsageAppInfo()
    {
        TraceMsg(TF_PROGLIST, "%p.ai.~", this);
        ASSERT(IsBlank());
        Str_SetPtr(&_pszAppPath, NULL);
    }

    // Notice! When the reference count goes to zero, we do not delete
    // the item.  That's because there is still a reference to it in
    // the _dpaAppInfo DPA.  Instead, we'll recycle items whose refcount
    // is zero.

    // NTRAID:135696 potential race condition against background enumeration
    void AddRef() { InterlockedIncrement(&_cRef); }
    void Release() { ASSERT( 0 != _cRef ); InterlockedDecrement(&_cRef); }
    inline BOOL IsBlank() { return _cRef == 0; }
    inline BOOL IsNew() { return _fNew; }
    inline BOOL IsAppPath(LPCTSTR pszAppPath)
        { return lstrcmpi(_pszAppPath, pszAppPath) == 0; }
    const FILETIME& GetCreatedTime() const { return _ftCreated; }
    inline const FILETIME *GetFileTime() const { return &_ueiTotal.ftExecute; }

    inline LPTSTR GetAppPath() const { return _pszAppPath; }

    void GetUEMInfo(OUT UEMINFO *puei)
    {
        _GetUEMPathInfo(_pszAppPath, puei);
    }

    void CombineUEMInfo(IN const UEMINFO *pueiNew, BOOL fNew = TRUE, BOOL fIsDesktop = FALSE)
    {
        //  Accumulate the points
        _ueiTotal.cHit += pueiNew->cHit;

        //  Take the most recent execution time
        if (CompareFileTime(&pueiNew->ftExecute, &_ueiTotal.ftExecute) > 0)
        {
            _ueiTotal.ftExecute = pueiNew->ftExecute;
        }

        // If anybody contributing to those app is no longer new, then
        // the app stops being new.
        // If the item is on the desktop, we don't track its newness,
        // but we don't want to invalidate the newness of the app either
        if (!fIsDesktop && !fNew) _fNew = FALSE;
    }

    //
    //  The app UEM info is "old" if the execution time is more
    //  than an hour after the install time.
    //
    inline BOOL _IsUEMINFONew(const UEMINFO *puei)
    {
        return FILETIMEtoInt64(puei->ftExecute) <
               FILETIMEtoInt64(_ftCreated) + ByUsage::FT_NEWAPPGRACEPERIOD();
    }

    //
    //  Prepare for a new enumeration.
    //
    static BOOL CALLBACK EnumResetCB(ByUsageAppInfo *self, CMenuItemsCache *pmenuCache)
    {
        self->_pscutBest = NULL;
        self->_pscutBestSM = NULL;
        self->_fPinned = FALSE;
        ZeroMemory(&self->_ueiBest, sizeof(self->_ueiBest));
        ZeroMemory(&self->_ueiTotal, sizeof(self->_ueiTotal));
        if (self->_fNew && !self->_fIgnoreTimestamp)
        {
            self->_fNew = pmenuCache->IsNewlyCreated(&self->_ftCreated);
        }
        return TRUE;
    }

    static BOOL CALLBACK EnumGetFileCreationTime(ByUsageAppInfo *self, CMenuItemsCache *pmenuCache)
    {
        if (!self->IsBlank() &&
            !self->_fIgnoreTimestamp &&
            GetFileCreationTime(self->_pszAppPath, &self->_ftCreated))
        {
            self->_fNew = pmenuCache->IsNewlyCreated(&self->_ftCreated);
        }
        return TRUE;
    }

    ByUsageItem *CreateByUsageItem();
};

//****************************************************************************

class ByUsageShortcut
{
#ifdef DEBUG
    ByUsageShortcut() { }           // make constructor private
#endif
    ByUsageDir *        _pdir;      // folder that contains this shortcut
    LPITEMIDLIST        _pidl;      // pidl relative to parent
    ByUsageAppInfo *    _papp;      // associated EXE
    FILETIME            _ftCreated; // time shortcut was created
    bool                _fNew;      // new app?
    bool                _fInteresting; // Is this a candidate for the MFU list?
    bool                _fDarwin;   // Is this a Darwin shortcut?
public:

    // Accessors
    LPCITEMIDLIST RelativePidl() const { return _pidl; }
    ByUsageDir *Dir() const { return _pdir; }
    LPCITEMIDLIST ParentPidl() const { return _pdir->Pidl(); }
    IShellFolder *ParentFolder() const { return _pdir->Folder(); }
    ByUsageAppInfo *App() const { return _papp; }
    bool IsNew() const { return _fNew; }
    bool SetNew(bool fNew) { return _fNew = fNew; }
    const FILETIME& GetCreatedTime() const { return _ftCreated; }
    bool IsInteresting() const { return _fInteresting; }
    bool SetInteresting(bool fInteresting) { return _fInteresting = fInteresting; }
    bool IsDarwin() { return _fDarwin; }

    LPITEMIDLIST CreateFullPidl() const
        { return ILCombine(ParentPidl(), RelativePidl()); }

    LPCITEMIDLIST UpdateRelativePidl(ByUsageHiddenData *phd);

    void SetApp(ByUsageAppInfo *papp)
    {
        if (_papp) _papp->Release();
        _papp = papp;
        if (papp) papp->AddRef();
    }

    static ByUsageShortcut *Create(ByUsageDir *pdir, LPCITEMIDLIST pidl, ByUsageAppInfo *papp, bool fDarwin, BOOL fForce = FALSE)
    {
        ASSERT(pdir);
        ASSERT(pidl);

        ByUsageShortcut *pscut = new ByUsageShortcut;
        if (pscut)
        {
            TraceMsg(TF_PROGLIST, "%p.scut()", pscut);

            pscut->_fNew = TRUE;        // will be set to FALSE later
            pscut->_pdir = pdir; pdir->AddRef();
            pscut->SetApp(papp);
            pscut->_fDarwin = fDarwin;
            pscut->_pidl = ILClone(pidl);
            if (pscut->_pidl)
            {
                LPTSTR pszShortcutName = _DisplayNameOf(pscut->ParentFolder(), pscut->RelativePidl(), SHGDN_FORPARSING);
                if (pszShortcutName &&
                    GetFileCreationTime(pszShortcutName, &pscut->_ftCreated))
                {
                    // Woo-hoo, all is well
                }
                else if (fForce)
                {
                    // The item was forced -- create it even though
                    // we don't know what it is.
                }
                else
                {
                    delete pscut;
                    pscut = NULL;
                }
                SHFree(pszShortcutName);
            }
            else
            {
                delete pscut;
                pscut = NULL;
            }
        }
        return pscut;
    }

    ~ByUsageShortcut()
    {
        TraceMsg(TF_PROGLIST, "%p.scut.~", this);
        if (_pdir) _pdir->Release();
        if (_papp) _papp->Release();
        ILFree(_pidl);          // ILFree ignores NULL
    }

    ByUsageItem *CreatePinnedItem(int iPinPos);

    void GetUEMInfo(OUT UEMINFO *puei)
    {
        _GetUEMPidlInfo(_pdir->Folder(), _pidl, puei);
    }
};

//****************************************************************************

ByUsageItem *ByUsageItem::Create(ByUsageShortcut *pscut)
{
    ASSERT(pscut);
    ByUsageItem *pitem = new ByUsageItem;
    if (pitem)
    {
        pitem->_pdir = pscut->Dir();
        pitem->_pdir->AddRef();

        pitem->_pidl = ILClone(pscut->RelativePidl());
        if (pitem->_pidl)
        {
            return pitem;
        }
    }
    delete pitem;           // "delete" can handle NULL
    return NULL;
}

ByUsageItem *ByUsageItem::CreateSeparator()
{
    ByUsageItem *pitem = new ByUsageItem;
    if (pitem)
    {
        pitem->_iPinPos = PINPOS_SEPARATOR;
    }
    return pitem;
}

ByUsageItem::~ByUsageItem()
{
    ILFree(_pidl);
    if (_pdir) _pdir->Release();
}

ByUsageItem *ByUsageAppInfo::CreateByUsageItem()
{
    ASSERT(_pscutBest);
    ByUsageItem *pitem = ByUsageItem::Create(_pscutBest);
    if (pitem)
    {
        pitem->_uei = _ueiTotal;
    }
    return pitem;
}

ByUsageItem *ByUsageShortcut::CreatePinnedItem(int iPinPos)
{
    ASSERT(iPinPos >= 0);

    ByUsageItem *pitem = ByUsageItem::Create(this);
    if (pitem)
    {
        pitem->_iPinPos = iPinPos;
    }
    return pitem;
}

//****************************************************************************
//
//  The hidden data for the Programs list is of the following form:
//
//      WORD    cb;             // hidden item size
//      WORD    wPadding;       // padding
//      IDLHID  idl;            // IDLHID_STARTPANEDATA
//      int     iUnused;        // (was icon index)
//      WCHAR   LocalMSIPath[]; // variable-length string
//      WCHAR   TargetPath[];   // variable-length string
//      WCHAR   AltName[];      // variable-length string
//
//  AltName is the alternate display name for the EXE.
//
//  The hidden data is never accessed directly.  We always operate on the
//  ByUsageHiddenData structure, and there are special methods for
//  transferring data between this structure and the pidl.
//
//  The hidden data is appended to the pidl, with a "wOffset" backpointer
//  at the very end.
//
//  The TargetPath is stored as an unexpanded environment string.
//  (I.e., you have to ExpandEnvironmentStrings before using them.)
//
//  As an added bonus, the TargetPath might be a GUID (product code)
//  if it is really a Darwin shortcut.
//
class ByUsageHiddenData {
public:
    WORD    _wHotKey;            // Hot Key
    LPWSTR  _pwszMSIPath;        // SHAlloc
    LPWSTR  _pwszTargetPath;     // SHAlloc
    LPWSTR  _pwszAltName;        // SHAlloc

public:

    void Init()
    {
        _wHotKey = 0;
        _pwszMSIPath = NULL;
        _pwszTargetPath = NULL;
        _pwszAltName = NULL;
    }

    BOOL IsClear()              // are all fields at initial values?
    {
        return _wHotKey == 0 &&
               _pwszMSIPath == NULL &&
               _pwszTargetPath == NULL &&
               _pwszAltName == NULL;
    }

    ByUsageHiddenData() { Init(); }

    enum {
        BUHD_HOTKEY       = 0x0000,             // so cheap we always fetch it
        BUHD_MSIPATH      = 0x0001,
        BUHD_TARGETPATH   = 0x0002,
        BUHD_ALTNAME      = 0x0004,
        BUHD_ALL          = -1,
    };

    BOOL Get(LPCITEMIDLIST pidl, UINT buhd);    // Load from pidl
    LPITEMIDLIST Set(LPITEMIDLIST pidl);        // Save to pidl

    void Clear()
    {
        SHFree(_pwszMSIPath);
        SHFree(_pwszTargetPath);
        SHFree(_pwszAltName);
        Init();
    }

    static LPTSTR GetAltName(LPCITEMIDLIST pidl);
    static LPITEMIDLIST SetAltName(LPITEMIDLIST pidl, LPCTSTR ptszNewName);
    void LoadFromShellLink(IShellLink *psl);
    HRESULT UpdateMSIPath();

private:
    static LPBYTE _ParseString(LPBYTE pbHidden, LPWSTR *ppwszOut, LPITEMIDLIST pidlMax, BOOL fSave);
    static LPBYTE _AppendString(LPBYTE pbHidden, LPWSTR pwsz);
};

//
//  We are parsing a string out of a pidl, so we have to be extra careful
//  to watch out for data corruption.
//
//  pbHidden = next byte to parse (or NULL to stop parsing)
//  ppwszOut receives parsed string if fSave = TRUE
//  pidlMax = start of next pidl; do not parse past this point
//  fSave = should we save the string in ppwszOut?
//
LPBYTE ByUsageHiddenData::_ParseString(LPBYTE pbHidden, LPWSTR *ppwszOut, LPITEMIDLIST pidlMax, BOOL fSave)
{
    if (!pbHidden)
        return NULL;

    LPNWSTR pwszSrc = (LPNWSTR)pbHidden;
    LPNWSTR pwsz = pwszSrc;
    LPNWSTR pwszLast = (LPNWSTR)pidlMax - 1;

    //
    //  We cannot use ualstrlenW because that might scan past pwszLast
    //  and fault.
    //
    while (pwsz < pwszLast && *pwsz)
    {
        pwsz++;
    }

    //  Corrupted data -- no null terminator found.
    if (pwsz >= pwszLast)
        return NULL;

    pwsz++;     // Step pwsz over the terminating NULL

    UINT cb = (UINT)((LPBYTE)pwsz - (LPBYTE)pwszSrc);
    if (fSave)
    {
        *ppwszOut = (LPWSTR)SHAlloc(cb);
        if (*ppwszOut)
        {
            CopyMemory(*ppwszOut, pbHidden, cb);
        }
        else
        {
            return NULL;
        }
    }
    pbHidden += cb;
    ASSERT(pbHidden == (LPBYTE)pwsz);
    return pbHidden;
}

BOOL ByUsageHiddenData::Get(LPCITEMIDLIST pidl, UINT buhd)
{
    ASSERT(IsClear());

    PCIDHIDDEN pidhid = ILFindHiddenID(pidl, IDLHID_STARTPANEDATA);
    if (!pidhid)
    {
        return FALSE;
    }

    // Do not access bytes after pidlMax
    LPITEMIDLIST pidlMax = _ILNext((LPITEMIDLIST)pidhid);

    LPBYTE pbHidden = ((LPBYTE)pidhid) + sizeof(HIDDENITEMID);

    // Skip the iUnused value
    // Note: if you someday choose to use it, you must read it as
    //      _iWhatever = *(UNALIGNED int *)pbHidden;
    pbHidden += sizeof(int);

    // HotKey
    _wHotKey = *(UNALIGNED WORD *)pbHidden;
    pbHidden += sizeof(_wHotKey);

    pbHidden = _ParseString(pbHidden, &_pwszMSIPath,    pidlMax, buhd & BUHD_MSIPATH);
    pbHidden = _ParseString(pbHidden, &_pwszTargetPath, pidlMax, buhd & BUHD_TARGETPATH);
    pbHidden = _ParseString(pbHidden, &_pwszAltName,    pidlMax, buhd & BUHD_ALTNAME);

    if (pbHidden)
    {
        return TRUE;
    }
    else
    {
        Clear();
        return FALSE;
    }
}


LPBYTE ByUsageHiddenData::_AppendString(LPBYTE pbHidden, LPWSTR pwsz)
{
    LPWSTR pwszOut = (LPWSTR)pbHidden;

    // The pointer had better already be aligned for WCHARs
    ASSERT(((ULONG_PTR)pwszOut & 1) == 0);

    if (pwsz)
    {
        lstrcpyW(pwszOut, pwsz);
    }
    else
    {
        pwszOut[0] = L'\0';
    }
    return (LPBYTE)(pwszOut + 1 + lstrlenW(pwszOut));
}

//
//  Note!  On failure, the source pidl is freed!
//  (This behavior is inherited from ILAppendHiddenID.)
//
LPITEMIDLIST ByUsageHiddenData::Set(LPITEMIDLIST pidl)
{
    UINT cb = sizeof(HIDDENITEMID);
    cb += sizeof(int);
    cb += sizeof(_wHotKey);
    cb += (UINT)(CbFromCchW(1 + (_pwszMSIPath ? lstrlenW(_pwszMSIPath) : 0)));
    cb += (UINT)(CbFromCchW(1 + (_pwszTargetPath ? lstrlenW(_pwszTargetPath) : 0)));
    cb += (UINT)(CbFromCchW(1 + (_pwszAltName ? lstrlenW(_pwszAltName) : 0)));

    // We can use the aligned version here since we allocated it ourselves
    // and didn't suck it out of a pidl.
    HIDDENITEMID *pidhid = (HIDDENITEMID*)alloca(cb);

    pidhid->cb = (WORD)cb;
    pidhid->wVersion = 0;
    pidhid->id = IDLHID_STARTPANEDATA;

    LPBYTE pbHidden = ((LPBYTE)pidhid) + sizeof(HIDDENITEMID);

    // The pointer had better already be aligned for ints
    ASSERT(((ULONG_PTR)pbHidden & 3) == 0);
    *(int *)pbHidden = 0;   // iUnused
    pbHidden += sizeof(int);

    *(DWORD *)pbHidden = _wHotKey;
    pbHidden += sizeof(_wHotKey);

    pbHidden = _AppendString(pbHidden, _pwszMSIPath);
    pbHidden = _AppendString(pbHidden, _pwszTargetPath);
    pbHidden = _AppendString(pbHidden, _pwszAltName);

    // Make sure our math was correct
    ASSERT(cb == (UINT)((LPBYTE)pbHidden - (LPBYTE)pidhid));

    // Remove and expunge the old data
    ILRemoveHiddenID(pidl, IDLHID_STARTPANEDATA);
    ILExpungeRemovedHiddenIDs(pidl);

    return ILAppendHiddenID(pidl, pidhid);
}

LPWSTR ByUsageHiddenData::GetAltName(LPCITEMIDLIST pidl)
{
    LPWSTR pszRet = NULL;
    ByUsageHiddenData hd;
    if (hd.Get(pidl, BUHD_ALTNAME))
    {
        pszRet = hd._pwszAltName;   // Keep this string
        hd._pwszAltName = NULL;     // Keep the upcoming assert happy
    }
    ASSERT(hd.IsClear());           // make sure we aren't leaking
    return pszRet;
}

//
//  Note!  On failure, the source pidl is freed!
//  (Propagating weird behavior of ByUsageHiddenData::Set)
//
LPITEMIDLIST ByUsageHiddenData::SetAltName(LPITEMIDLIST pidl, LPCTSTR ptszNewName)
{
    ByUsageHiddenData hd;

    // Attempt to overlay the existing values, but if they aren't available,
    // don't freak out.
    hd.Get(pidl, BUHD_ALL & ~BUHD_ALTNAME);

    ASSERT(hd._pwszAltName == NULL); // we excluded it from the hd.Get()
    hd._pwszAltName = const_cast<LPTSTR>(ptszNewName);

    pidl = hd.Set(pidl);
    hd._pwszAltName = NULL;     // so hd.Clear() won't SHFree() it
    hd.Clear();
    return pidl;

}

//
//  Returns S_OK if the item changed; S_FALSE if it remained the same
//
HRESULT ByUsageHiddenData::UpdateMSIPath()
{
    HRESULT hr = S_FALSE;

    if (_pwszTargetPath && IsDarwinPath(_pwszTargetPath))
    {
        LPWSTR pwszMSIPath = NULL;
        //
        //  If we can't resolve the Darwin ID to a filename, then leave
        //  the filename in the HiddenData alone - it's better than
        //  nothing.
        //
        if (SUCCEEDED(SHParseDarwinIDFromCacheW(_pwszTargetPath+1, &pwszMSIPath)) && pwszMSIPath)
        {
            //
            //  See if the MSI path has changed...
            //
            if (_pwszMSIPath == NULL ||
                StrCmpCW(pwszMSIPath, _pwszMSIPath) != 0)
            {
                hr = S_OK;
                SHFree(_pwszMSIPath);
                _pwszMSIPath = pwszMSIPath; // take ownership
            }
            else
            {
                // Unchanged; happy, free the path we aren't going to use
                SHFree(pwszMSIPath);
            }
        }
    }
    return hr;
}

LPCITEMIDLIST ByUsageShortcut::UpdateRelativePidl(ByUsageHiddenData *phd)
{
    return _pidl = phd->Set(_pidl);     // frees old _pidl even on failure
}

//
//  We must key off the Darwin ID and not the product code.
//
//  The Darwin ID is unique for each app in an application suite.
//  For example, PowerPoint and Outlook have different Darwin IDs.
//
//  The product code is the same for all apps in an application suite.
//  For example, PowerPoint and Outlook have the same product code.
//
//  Since we want to treat PowerPoint and Outlook as two independent
//  applications, we want to use the Darwin ID and not the product code.
//
HRESULT _GetDarwinID(IShellLinkDataList *pdl, DWORD dwSig, LPWSTR pszPath, UINT cchPath)
{
    LPEXP_DARWIN_LINK pedl;
    HRESULT hr;
    ASSERT(cchPath > 0);

    hr = pdl->CopyDataBlock(dwSig, (LPVOID*)&pedl);

    if (SUCCEEDED(hr))
    {
        pszPath[0] = CH_DARWINMARKER;
        hr = StringCchCopy(pszPath+1, cchPath - 1, pedl->szwDarwinID);
        LocalFree(pedl);
    }

    return hr;
}

HRESULT _GetPathOrDarwinID(IShellLink *psl, LPTSTR pszPath, UINT cchPath, DWORD dwFlags)
{
    HRESULT hr;

    ASSERT(cchPath);
    pszPath[0] = TEXT('\0');

    //
    //  See if it's a Darwin thingie.
    //
    IShellLinkDataList *pdl;
    hr = psl->QueryInterface(IID_PPV_ARG(IShellLinkDataList, &pdl));
    if (SUCCEEDED(hr))
    {
        //
        //  Maybe this is a Darwin shortcut...  If so, then
        //  use the Darwin ID.
        //
        DWORD dwSLFlags;
        hr = pdl->GetFlags(&dwSLFlags);
        if (SUCCEEDED(hr))
        {
            if (dwSLFlags & SLDF_HAS_DARWINID)
            {
                hr = _GetDarwinID(pdl, EXP_DARWIN_ID_SIG, pszPath, cchPath);
            }
            else
            {
                hr = E_FAIL;            // No Darwin ID found
            }

            pdl->Release();
        }
    }

    if (FAILED(hr))
    {
        hr = psl->GetPath(pszPath, cchPath, 0, dwFlags);
    }

    return hr;
}

void ByUsageHiddenData::LoadFromShellLink(IShellLink *psl)
{
    ASSERT(_pwszTargetPath == NULL);

    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    szPath[0] = TEXT('\0');

    hr = _GetPathOrDarwinID(psl, szPath, ARRAYSIZE(szPath), SLGP_RAWPATH);
    if (SUCCEEDED(hr))
    {
        SHStrDup(szPath, &_pwszTargetPath);
    }

    hr = psl->GetHotkey(&_wHotKey);
}

//****************************************************************************

ByUsageUI::ByUsageUI() : _byUsage(this, NULL),
    // We want to log execs as if they were launched by the Start Menu
    SFTBarHost(HOSTF_FIREUEMEVENTS |
               HOSTF_CANDELETE |
               HOSTF_CANRENAME)
{
    _iThemePart = SPP_PROGLIST;
    _iThemePartSep = SPP_PROGLISTSEPARATOR;
}

ByUsage::ByUsage(ByUsageUI *pByUsageUI, ByUsageDUI *pByUsageDUI)
{
    _pByUsageUI = pByUsageUI;

    _pByUsageDUI = pByUsageDUI;

    GetStartTime(&_ftStartTime);

    _pidlBrowser = ILCreateFromPath(TEXT("shell:::{2559a1f4-21d7-11d4-bdaf-00c04f60b9f0}"));
    _pidlEmail   = ILCreateFromPath(TEXT("shell:::{2559a1f5-21d7-11d4-bdaf-00c04f60b9f0}"));
}

SFTBarHost *ByUsage_CreateInstance()
{
    return new ByUsageUI();
}

ByUsage::~ByUsage()
{
    if (_fUEMRegistered)
    {
        // Unregister with UEM DB if necessary
        UEMRegisterNotify(NULL, NULL);
    }

    if (_dpaNew)
    {
        _dpaNew.DestroyCallback(ILFreeCallback, NULL);
    }

    // Must clear the pinned items before releasing the MenuCache, 
    // as the pinned items point to AppInfo items in the cache.
    _rtPinned.Reset();

    if (_pMenuCache)
    {
        // Clean up the Menu cache properly.
        _pMenuCache->LockPopup();
        _pMenuCache->UnregisterNotifyAll();
        _pMenuCache->AttachUI(NULL);
        _pMenuCache->UnlockPopup();
        _pMenuCache->Release();
    }

    ILFree(_pidlBrowser);
    ILFree(_pidlEmail);
    ATOMICRELEASE(_psmpin);

    if (_pdirDesktop)
    {
        _pdirDesktop->Release();
    }
}

HRESULT ByUsage::Initialize()
{
    HRESULT hr;

    hr = CoCreateInstance(CLSID_StartMenuPin, NULL, CLSCTX_INPROC_SERVER,
                          IID_PPV_ARG(IStartMenuPin, &_psmpin));
    if (FAILED(hr))
    {
        return hr;
    }

    if (!(_pdirDesktop = ByUsageDir::CreateDesktop())) {
        return E_OUTOFMEMORY;
    }

    // Use already initialized MenuCache if available
    if (g_pMenuCache)
    {
        _pMenuCache = g_pMenuCache;
        _pMenuCache->AttachUI(_pByUsageUI);
        g_pMenuCache = NULL; // We take ownership here.
    }
    else
    {
        hr = CMenuItemsCache::ReCreateMenuItemsCache(_pByUsageUI, &_ftStartTime, &_pMenuCache);
        if (FAILED(hr))
        {
            return hr;
        }
    }


    _ulPinChange = -1;              // Force first query to re-enumerate

    _dpaNew = NULL;

    if (_pByUsageUI)
    {
        _hwnd = _pByUsageUI->_hwnd;

        //
        //  Register for the "pin list change" event.  This is an extended
        //  event (hence global), so listen in a location that contains
        //  no objects so the system doesn't waste time sending
        //  us stuff we don't care about.  Our choice: _pidlBrowser.
        //  It's not even a folder, so it can't contain any objects!
        //
        ASSERT(!_pMenuCache->IsLocked());
        _pByUsageUI->RegisterNotify(NOTIFY_PINCHANGE, SHCNE_EXTENDED_EVENT, _pidlBrowser, FALSE);
    }

    return S_OK;
}

void CMenuItemsCache::_InitStringList(HKEY hk, LPCTSTR pszSub, CDPA<TCHAR> dpa)
{
    ASSERT(static_cast<HDPA>(dpa));

    LONG lRc;
    DWORD cb = 0;
    lRc = RegQueryValueEx(hk, pszSub, NULL, NULL, NULL, &cb);
    if (lRc == ERROR_SUCCESS)
    {
        // Add an extra TCHAR just to be extra-safe.  That way, we don't
        // barf if there is a non-null-terminated string in the registry.
        cb += sizeof(TCHAR);
        LPTSTR pszKillList = (LPTSTR)LocalAlloc(LPTR, cb);
        if (pszKillList)
        {
            lRc = SHGetValue(hk, NULL, pszSub, NULL, pszKillList, &cb);
            if (lRc == ERROR_SUCCESS)
            {
                // A semicolon-separated list of application names.
                LPTSTR psz = pszKillList;
                LPTSTR pszSemi;

                while ((pszSemi = StrChr(psz, TEXT(';'))) != NULL)
                {
                    *pszSemi = TEXT('\0');
                    if (*psz)
                    {
                        AppendString(dpa, psz);
                    }
                    psz = pszSemi+1;
                }
                if (*psz)
                {
                    AppendString(dpa, psz);
                }
            }
            LocalFree(pszKillList);
        }
    }
}

//
//  Fill the kill list with the programs that should be ignored
//  should they be encountered in the Start Menu or elsewhere.
//
#define REGSTR_PATH_FILEASSOCIATION TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileAssociation")

void CMenuItemsCache::_InitKillList()
{
    HKEY hk;
    LONG lRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_FILEASSOCIATION, 0,
                            KEY_READ, &hk);
    if (lRc == ERROR_SUCCESS)
    {
        _InitStringList(hk, TEXT("AddRemoveApps"), _dpaKill);
        _InitStringList(hk, TEXT("AddRemoveNames"), _dpaKillLink);
        RegCloseKey(hk);
    }
}

//****************************************************************************
//
//  Filling the ByUsageShortcutList
//

int CALLBACK PidlSortCallback(LPITEMIDLIST pidl1, LPITEMIDLIST pidl2, IShellFolder *psf)
{
    HRESULT hr = psf->CompareIDs(0, pidl1, pidl2);

    // We got them from the ShellFolder; they should still be valid!
    ASSERT(SUCCEEDED(hr));

    return ShortFromResult(hr);
}


// {06C59536-1C66-4301-8387-82FBA3530E8D}
static const GUID TOID_STARTMENUCACHE = 
{ 0x6c59536, 0x1c66, 0x4301, { 0x83, 0x87, 0x82, 0xfb, 0xa3, 0x53, 0xe, 0x8d } };


/*
 *  Background cache creation stuff...
 */
class CCreateMenuItemCacheTask : public CRunnableTask {
    CMenuItemsCache *_pMenuCache;
    IShellTaskScheduler *_pScheduler;
public:
    CCreateMenuItemCacheTask(CMenuItemsCache *pMenuCache, IShellTaskScheduler *pScheduler)
        : CRunnableTask(RTF_DEFAULT), _pMenuCache(pMenuCache), _pScheduler(pScheduler) 
    {
        if (_pScheduler)
            _pScheduler->AddRef();
    }

    ~CCreateMenuItemCacheTask()
    {
        if (_pScheduler)
            _pScheduler->Release();
    }

    static void DummyCallBack(LPCITEMIDLIST pidl, LPVOID pvData, LPVOID pvHint, INT iIconIndex, INT iOpenIconIndex){}

    STDMETHODIMP RunInitRT()
    {
        _pMenuCache->DelayGetFileCreationTimes();
        _pMenuCache->DelayGetDarwinInfo();
        _pMenuCache->LockPopup();
        _pMenuCache->InitCache();
        _pMenuCache->UpdateCache();
        _pMenuCache->StartEnum();

        ByUsageHiddenData hd;           // construct once
        while (TRUE)
        {
            ByUsageShortcut *pscut = _pMenuCache->GetNextShortcut();
            if (!pscut)
                break;

            hd.Get(pscut->RelativePidl(), ByUsageHiddenData::BUHD_HOTKEY | ByUsageHiddenData::BUHD_TARGETPATH);
            if (hd._wHotKey)
            {
                Tray_RegisterHotKey(hd._wHotKey, pscut->ParentPidl(), pscut->RelativePidl());
            }
            
            // Pre-load the icons in the cache
            int iIndex;
            SHMapIDListToImageListIndexAsync(_pScheduler, pscut->ParentFolder(), pscut->RelativePidl(), 0, 
                                                    DummyCallBack, NULL, NULL, &iIndex, NULL);
            
            // Register Darwin shortcut so that they can be grayed out if not installed
            // and so we can map them to local paths as necessary
            if (hd._pwszTargetPath && IsDarwinPath(hd._pwszTargetPath))
            {
                SHRegisterDarwinLink(pscut->CreateFullPidl(), 
                                     hd._pwszTargetPath +1 /* Exclude the Darwin marker! */, 
                                     FALSE /* Don't update the Darwin state now, we'll do it later */);
            }
            hd.Clear();
        }
        _pMenuCache->EndEnum();
        _pMenuCache->UnlockPopup();

        // Now determine all new items
        // Note: this is safe to do after the Unlock because we never remove anything from the _dpaAppInfo
        _pMenuCache->GetFileCreationTimes();

        _pMenuCache->AllowGetDarwinInfo();
        SHReValidateDarwinCache();

        // Refreshing Darwin shortcuts must be done under the popup lock
        // to avoid another thread doing a re-enumeration while we are
        // studying the dpa.  Keep SHReValidateDarwinCache outside of the
        // lock since it is slow.  (All we do is query the cache that
        // SHReValidateDarwinCache created for us.)
        _pMenuCache->LockPopup();
        _pMenuCache->RefreshCachedDarwinShortcuts();
        _pMenuCache->UnlockPopup();

        _pMenuCache->Release();
        return S_OK;
    }
};

HRESULT AddMenuItemsCacheTask(IShellTaskScheduler* pSystemScheduler, BOOL fKeepCacheWhenFinished)
{
    HRESULT hr;

    CMenuItemsCache *pMenuCache = new CMenuItemsCache;

    FILETIME ftStart;
    // Initialize with something.
    GetStartTime(&ftStart);

    if (pMenuCache)
    {
        hr = pMenuCache->Initialize(NULL, &ftStart);
        if (fKeepCacheWhenFinished)
        {
            g_pMenuCache = pMenuCache;
            g_pMenuCache->AddRef();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        CCreateMenuItemCacheTask *pTask = new CCreateMenuItemCacheTask(pMenuCache, pSystemScheduler);

        if (pTask)
        {
            hr = pSystemScheduler->AddTask(pTask, TOID_STARTMENUCACHE, 0, ITSAT_DEFAULT_PRIORITY);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

DWORD WINAPI CMenuItemsCache::ReInitCacheThreadProc(void *pv)
{
    HRESULT hr = SHCoInitialize();

    if (SUCCEEDED(hr))
    {
        CMenuItemsCache *pMenuCache = reinterpret_cast<CMenuItemsCache *>(pv);
        pMenuCache->DelayGetFileCreationTimes();
        pMenuCache->LockPopup();
        pMenuCache->InitCache();
        pMenuCache->UpdateCache();
        pMenuCache->UnlockPopup();

        // Now determine all new items
        // Note: this is safe to do after the Unlock because we never remove anything from the _dpaAppInfo
        pMenuCache->GetFileCreationTimes();
        pMenuCache->Release();
    }
    SHCoUninitialize(hr);
    
    return 0;
}

HRESULT CMenuItemsCache::ReCreateMenuItemsCache(ByUsageUI *pbuUI, FILETIME *ftOSInstall, CMenuItemsCache **ppMenuCache)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMenuItemsCache *pMenuCache;

    // Create a CMenuItemsCache with ref count 1.
    pMenuCache = new CMenuItemsCache;
    if (pMenuCache)
    {
        hr = pMenuCache->Initialize(pbuUI, ftOSInstall);
    }

    if (SUCCEEDED(hr))
    {
        pMenuCache->AddRef();
        if (!SHQueueUserWorkItem(ReInitCacheThreadProc, pMenuCache, 0, 0, NULL, NULL, 0))
        {
            // No big deal if we fail here, we'll get another chance at enumerating later.
            pMenuCache->Release();
        }
        *ppMenuCache = pMenuCache;
    }
    return hr;
}


HRESULT CMenuItemsCache::GetFileCreationTimes()
{
    if (CompareFileTime(&_ftOldApps, &c_ftNever) != 0)
    {
        // Get all file creation times for our app list.
        _dpaAppInfo.EnumCallbackEx(ByUsageAppInfo::EnumGetFileCreationTime, this);

        // From now on, we will be checkin newness when we create the app object.
        _fCheckNew = TRUE;
    }
    return S_OK;
}


//
//  Enumerate the contents of the folder specified by psfParent.
//  pidlParent represents the location of psfParent.
//
//  Note that we cannot do a depth-first walk into subfolders because
//  many (most?) machines have a timeout on FindFirst handles; if you don't
//  call FindNextFile for a few minutes, they secretly do a FindClose for
//  you on the assumption that you are a bad app that leaked a handle.
//  (There is also a valid DOS-compatibility reason for this behavior:
//  The DOS FindFirstFile API doesn't have a FindClose, so the server can
//  never tell if you are finished or not, so it has to guess that if you
//  don't do a FindNext for a long time, you're probably finished.)
//
//  So we have to save all the folders we find into a DPA and then walk
//  the folders after we close the enumeration.
//

void CMenuItemsCache::_FillFolderCache(ByUsageDir *pdir, ByUsageRoot *prt)
{
    // Caller should've initialized us
    ASSERT(prt->_sl);

    //
    // Note that we must use a namespace walk instead of FindFirst/FindNext,
    // because there might be folder shortcuts in the user's Start Menu.
    //

    // We do not specify SHCONTF_INCLUDEHIDDEN, so hidden objects are
    // automatically excluded
    IEnumIDList *peidl;
    if (S_OK == pdir->Folder()->EnumObjects(NULL, SHCONTF_FOLDERS |
                                              SHCONTF_NONFOLDERS, &peidl))
    {
        CDPAPidl dpaDirs;
        if (dpaDirs.Create(4))
        {
            CDPAPidl dpaFiles;
            if (dpaFiles.Create(4))
            {
                LPITEMIDLIST pidl;

                while (peidl->Next(1, &pidl, NULL) == S_OK)
                {
                    // _IsExcludedDirectory carse about SFGAO_FILESYSTEM and SFGAO_LINK
                    DWORD dwAttributes = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_LINK;
                    if (SUCCEEDED(pdir->Folder()->GetAttributesOf(1, (LPCITEMIDLIST*)(&pidl),
                                                                  &dwAttributes)))
                    {
                        if (dwAttributes & SFGAO_FOLDER)
                        {
                            if (_IsExcludedDirectory(pdir->Folder(), pidl, dwAttributes) ||
                                dpaDirs.AppendPtr(pidl) < 0)
                            {
                                ILFree(pidl);
                            }
                        }
                        else
                        {
                            if (dpaFiles.AppendPtr(pidl) < 0)
                            {
                                ILFree(pidl);
                            }
                        }
                    }
                }

                dpaDirs.SortEx(PidlSortCallback, pdir->Folder());

                if (dpaFiles.GetPtrCount() > 0)
                {
                    dpaFiles.SortEx(PidlSortCallback, pdir->Folder());

                    //
                    //  Now merge the enumerated items with the ones
                    //  in the cache.
                    //
                    _MergeIntoFolderCache(prt, pdir, dpaFiles);
                }
                dpaFiles.DestroyCallback(ILFreeCallback, NULL);
            }

            // Must release now to force the FindClose to happen
            peidl->Release();

            // Now go back and handle all the folders we collected
            ENUMFOLDERINFO info;
            info.self = this;
            info.pdir = pdir;
            info.prt = prt;

            dpaDirs.DestroyCallbackEx(FolderEnumCallback, &info);
        }
    }
}

BOOL CMenuItemsCache::FolderEnumCallback(LPITEMIDLIST pidl, ENUMFOLDERINFO *pinfo)
{
    ByUsageDir *pdir = ByUsageDir::Create(pinfo->pdir, pidl);
    if (pdir)
    {
        pinfo->self->_FillFolderCache(pdir, pinfo->prt);
        pdir->Release();
    }
    ILFree(pidl);
    return TRUE;
}

//
//  Returns the next element in prt->_slOld that still belongs to the
//  directory "pdir", or NULL if no more.
//
ByUsageShortcut *CMenuItemsCache::_NextFromCacheInDir(ByUsageRoot *prt, ByUsageDir *pdir)
{
    if (prt->_iOld < prt->_cOld)
    {
        ByUsageShortcut *pscut = prt->_slOld.FastGetPtr(prt->_iOld);
        if (pscut->Dir() == pdir)
        {
            prt->_iOld++;
            return pscut;
        }
    }
    return NULL;
}

void CMenuItemsCache::_MergeIntoFolderCache(ByUsageRoot *prt, ByUsageDir *pdir, CDPAPidl dpaFiles)
{
    //
    //  Look at prt->_slOld to see if we have cached information about
    //  this directory already.
    //
    //  If we find directories that are less than us, skip over them.
    //  These correspond to directories that have been deleted.
    //
    //  For example, if we are "D" and we run across directories
    //  "B" and "C" in the old cache, that means that directories "B"
    //  and "C" were deleted and we should continue scanning until we
    //  find "D" (or maybe we find "E" and stop since E > D).
    //
    //
    ByUsageDir *pdirPrev = NULL;

    while (prt->_iOld < prt->_cOld)
    {
        ByUsageDir *pdirT = prt->_slOld.FastGetPtr(prt->_iOld)->Dir();
        HRESULT hr = _pdirDesktop->Folder()->CompareIDs(0, pdirT->Pidl(), pdir->Pidl());
        if (hr == ResultFromShort(0))
        {
            pdirPrev = pdirT;
            break;
        }
        else if (FAILED(hr) || ShortFromResult(hr) < 0)
        {
            //
            //  Skip over this directory
            //
            while (_NextFromCacheInDir(prt, pdirT)) { }
        }
        else
        {
            break;
        }
    }

    if (pdirPrev)
    {
        //
        //  If we have a cached previous directory, then recycle him.
        //  This keeps us from creating lots of copies of the same IShellFolder.
        //  It is also essential that all entries from the same directory
        //  have the same pdir; that's how _NextFromCacheInDir knows when
        //  to stop.
        //
        pdir = pdirPrev;

        //
        //  Make sure that this IShellFolder supports SHCIDS_ALLFIELDS.
        //  If not, then we just have to assume that they all changed.
        //
        IShellFolder2 *psf2;
        if (SUCCEEDED(pdir->Folder()->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
        {
            psf2->Release();
        }
        else
        {
            pdirPrev = NULL;
        }
    }

    //
    //  Now add all the items in dpaFiles to prt->_sl.  If we find a match
    //  in prt->_slOld, then use that information instead of hitting the disk.
    //
    int iNew;
    ByUsageShortcut *pscutNext = _NextFromCacheInDir(prt, pdirPrev);
    for (iNew = 0; iNew < dpaFiles.GetPtrCount(); iNew++)
    {
        LPITEMIDLIST pidl = dpaFiles.FastGetPtr(iNew);

        // Look for a match in the cache.
        HRESULT hr = S_FALSE;
        while (pscutNext &&
               (FAILED(hr = pdir->Folder()->CompareIDs(SHCIDS_ALLFIELDS, pscutNext->RelativePidl(), pidl)) ||
                ShortFromResult(hr) < 0))
        {
            pscutNext = _NextFromCacheInDir(prt, pdirPrev);
        }

        // pscutNext, if non-NULL, is the item that made us stop searching.
        // If hr == S_OK, then it was a match and we should use the data
        // from the cache.  Otherwise, we have a new item and should
        // fill it in the slow way.
        if (hr == ResultFromShort(0))
        {
            // A match from the cache; move it over
            _TransferShortcutToCache(prt, pscutNext);
            pscutNext = _NextFromCacheInDir(prt, pdirPrev);
        }
        else
        {
            // Brand new item, fill in from scratch
            _AddShortcutToCache(pdir, pidl, prt->_sl);
            dpaFiles.FastGetPtr(iNew) = NULL; // took ownership
        }
    }
}

//****************************************************************************

bool CMenuItemsCache::_SetInterestingLink(ByUsageShortcut *pscut)
{
    bool fInteresting = true;
    if (pscut->App() && !_PathIsInterestingExe(pscut->App()->GetAppPath())) {
        fInteresting = false;
    }
    else if (!_IsInterestingDirectory(pscut->Dir())) {
        fInteresting = false;
    }
    else
    {
        LPTSTR pszDisplayName = _DisplayNameOf(pscut->ParentFolder(), pscut->RelativePidl(), SHGDN_NORMAL | SHGDN_INFOLDER);
        if (pszDisplayName)
        {
            // SFGDN_INFOLDER should've returned a relative path
            ASSERT(pszDisplayName == PathFindFileName(pszDisplayName));

            int i;
            for (i = 0; i < _dpaKillLink.GetPtrCount(); i++)
            {
                if (StrStrI(pszDisplayName, _dpaKillLink.GetPtr(i)) != NULL)
                {
                    fInteresting = false;
                    break;
                }
            }
            SHFree(pszDisplayName);
        }
    }

    pscut->SetInteresting(fInteresting);
    return fInteresting;
}

BOOL CMenuItemsCache::_PathIsInterestingExe(LPCTSTR pszPath)
{
    //
    //  Darwin shortcuts are always interesting.
    //
    if (IsDarwinPath(pszPath))
    {
        return TRUE;
    }

    LPCTSTR pszExt = PathFindExtension(pszPath);

    //
    //  *.msc files are also always interesting.  They aren't
    //  strictly-speaking EXEs, but they act like EXEs and administrators
    //  really use them a lot.
    //
    if (StrCmpICW(pszExt, TEXT(".msc")) == 0)
    {
        return TRUE;
    }

    return StrCmpICW(pszExt, TEXT(".exe")) == 0 && !_IsExcludedExe(pszPath);
}


BOOL CMenuItemsCache::_IsExcludedExe(LPCTSTR pszPath)
{
    pszPath = PathFindFileName(pszPath);

    int i;
    for (i = 0; i < _dpaKill.GetPtrCount(); i++)
    {
        if (StrCmpI(pszPath, _dpaKill.GetPtr(i)) == 0)
        {
            return TRUE;
        }
    }

    HKEY hk;
    BOOL fRc = FALSE;

    if (SUCCEEDED(_pqa->Init(ASSOCF_OPEN_BYEXENAME, pszPath, NULL, NULL)) &&
        SUCCEEDED(_pqa->GetKey(0, ASSOCKEY_APP, NULL, &hk)))
    {
        fRc = ERROR_SUCCESS == SHQueryValueEx(hk, TEXT("NoStartPage"), NULL, NULL, NULL, NULL);
        RegCloseKey(hk);
    }

    return fRc;
}


HRESULT ByUsage::_GetShortcutExeTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPTSTR pszPath, UINT cchPath)
{
    HRESULT hr;
    IShellLink *psl;

    hr = psf->GetUIObjectOf(_hwnd, 1, &pidl, IID_PPV_ARG_NULL(IShellLink, &psl));

    if (SUCCEEDED(hr))
    {
        hr = psl->GetPath(pszPath, cchPath, 0, 0);
        psl->Release();
    }
    return hr;
}

void _GetUEMInfo(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, UEMINFO *pueiOut)
{
    ZeroMemory(pueiOut, sizeof(UEMINFO));
    pueiOut->cbSize = sizeof(UEMINFO);
    pueiOut->dwMask = UEIM_HIT | UEIM_FILETIME;

    //
    // If this call fails (app / pidl was never run), then we'll
    // just use the zeros we pre-initialized with.
    //
    UEMQueryEvent(pguidGrp, eCmd, wParam, lParam, pueiOut);

    //
    // The UEM code invents a default usage count if the shortcut
    // was never used.  We don't want that.
    //
    if (FILETIMEtoInt64(pueiOut->ftExecute) == 0)
    {
        pueiOut->cHit = 0;
    }
}

//
//  Returns S_OK if the item changed, S_FALSE if the item stayed the same,
//  or an error code
//
HRESULT CMenuItemsCache::_UpdateMSIPath(ByUsageShortcut *pscut)
{
    HRESULT hr = S_FALSE;       // Assume nothing happened

    if (pscut->IsDarwin())
    {
        ByUsageHiddenData hd;
        hd.Get(pscut->RelativePidl(), ByUsageHiddenData::BUHD_ALL);
        if (hd.UpdateMSIPath() == S_OK)
        {
            // Redirect to the new target (user may have
            // uninstalled then reinstalled to a new location)
            ByUsageAppInfo *papp = GetAppInfoFromHiddenData(&hd);
            pscut->SetApp(papp);
            if (papp) papp->Release();

            if (pscut->UpdateRelativePidl(&hd))
            {
                hr = S_OK;          // We changed stuff
            }
            else
            {
                hr = E_OUTOFMEMORY; // Couldn't update the relative pidl
            }
        }
        hd.Clear();
    }

    return hr;
}

//
//  Take pscut (which is the ByUsageShortcut most recently enumerated from
//  the old cache) and move it to the new cache.  NULL out the entry in the
//  old cache so that DPADELETEANDDESTROY(prt->_slOld) won't free it.
//
void CMenuItemsCache::_TransferShortcutToCache(ByUsageRoot *prt, ByUsageShortcut *pscut)
{
    ASSERT(pscut);
    ASSERT(pscut == prt->_slOld.FastGetPtr(prt->_iOld - 1));
    if (SUCCEEDED(_UpdateMSIPath(pscut)) &&
        prt->_sl.AppendPtr(pscut) >= 0) {
        // Take ownership
        prt->_slOld.FastGetPtr(prt->_iOld - 1) = NULL;
    }
}

ByUsageAppInfo *CMenuItemsCache::GetAppInfoFromHiddenData(ByUsageHiddenData *phd)
{
    ByUsageAppInfo *papp = NULL;
    bool fIgnoreTimestamp = false;

    TCHAR szPath[MAX_PATH];
    LPTSTR pszPath = szPath;
    szPath[0] = TEXT('\0');

    if (phd->_pwszMSIPath && phd->_pwszMSIPath[0])
    {
        pszPath = phd->_pwszMSIPath;

        // When MSI installs an app, the timestamp is applies to the app
        // is the timestamp on the source media, *not* the time the user
        // user installed the app.  So ignore the timestamp entirely since
        // it's useless information (and in fact makes us think the app
        // is older than it really is).
        fIgnoreTimestamp = true;
    }
    else if (phd->_pwszTargetPath)
    {
        if (IsDarwinPath(phd->_pwszTargetPath))
        {
            pszPath = phd->_pwszTargetPath;
        }
        else
        {
            //
            //  Need to expand the path because it may contain environment
            //  variables.
            //
            SHExpandEnvironmentStrings(phd->_pwszTargetPath, szPath, ARRAYSIZE(szPath));
        }
    }

    return GetAppInfo(pszPath, fIgnoreTimestamp);
}

ByUsageShortcut *CMenuItemsCache::CreateShortcutFromHiddenData(ByUsageDir *pdir, LPCITEMIDLIST pidl, ByUsageHiddenData *phd, BOOL fForce)
{
    ByUsageAppInfo *papp = GetAppInfoFromHiddenData(phd);
    bool fDarwin = phd->_pwszTargetPath && IsDarwinPath(phd->_pwszTargetPath);
    ByUsageShortcut *pscut = ByUsageShortcut::Create(pdir, pidl, papp, fDarwin, fForce);
    if (papp) papp->Release();
    return pscut;
}


void CMenuItemsCache::_AddShortcutToCache(ByUsageDir *pdir, LPITEMIDLIST pidl, ByUsageShortcutList slFiles)
{
    HRESULT hr;
    ByUsageHiddenData hd;

    if (pidl)
    {
        //
        //  Juice-up this pidl with cool info about the shortcut target
        //
        IShellLink *psl;
        hr = pdir->Folder()->GetUIObjectOf(NULL, 1, const_cast<LPCITEMIDLIST *>(&pidl),
                                           IID_PPV_ARG_NULL(IShellLink, &psl));
        if (SUCCEEDED(hr))
        {
            hd.LoadFromShellLink(psl);

            psl->Release();

            if (hd._pwszTargetPath && IsDarwinPath(hd._pwszTargetPath))
            {
                SHRegisterDarwinLink(ILCombine(pdir->Pidl(), pidl),
                                     hd._pwszTargetPath +1 /* Exclude the Darwin marker! */,
                                     _fCheckDarwin);
                SHParseDarwinIDFromCacheW(hd._pwszTargetPath+1, &hd._pwszMSIPath);
            }

            // ByUsageHiddenData::Set frees the source pidl on failure
            pidl = hd.Set(pidl);

        }
    }

    if (pidl)
    {
        ByUsageShortcut *pscut = CreateShortcutFromHiddenData(pdir, pidl, &hd);

        if (pscut)
        {
            if (slFiles.AppendPtr(pscut) >= 0)
            {
                _SetInterestingLink(pscut);
            }
            else
            {
                // Couldn't append; oh well
                delete pscut;       // "delete" can handle NULL pointer
            }
        }

        ILFree(pidl);
    }
    hd.Clear();
}

//
//  Find an entry in the AppInfo list that matches this application.
//  If not found, create a new entry.  In either case, bump the
//  reference count and return the item.
//
ByUsageAppInfo* CMenuItemsCache::GetAppInfo(LPTSTR pszAppPath, bool fIgnoreTimestamp)
{
    Lock();

    ByUsageAppInfo *pappBlank = NULL;

    int i;
    for (i = _dpaAppInfo.GetPtrCount() - 1; i >= 0; i--)
    {
        ByUsageAppInfo *papp = _dpaAppInfo.FastGetPtr(i);
        if (papp->IsBlank())
        {   // Remember that we found a blank entry we can recycle
            pappBlank = papp;
        }
        else if (lstrcmpi(papp->_pszAppPath, pszAppPath) == 0)
        {
            papp->AddRef();
            Unlock();
            return papp;
        }
    }

    // Not found in the list.  Try to recycle a blank entry.

    if (!pappBlank)
    {
        // No blank entries found; must make a new one.
        pappBlank = ByUsageAppInfo::Create();
        if (pappBlank && _dpaAppInfo.AppendPtr(pappBlank) < 0)
        {
            delete pappBlank;
            pappBlank = NULL;
        }
    }

    if (pappBlank && pappBlank->Initialize(pszAppPath, this, _fCheckNew, fIgnoreTimestamp))
    {
        ASSERT(pappBlank->IsBlank());
        pappBlank->AddRef();
    }
    else
    {
        pappBlank = NULL;
    }

    Unlock();
    return pappBlank;
}

    // A shortcut is new if...
    //
    //  the shortcut is newly created, and
    //  the target is newly created, and
    //  neither the shortcut nor the target has been run "in an interesting
    //  way".
    //
    // An "interesting way" is "more than one hour after the shortcut/target
    // was created."
    //
    // Note that we test the easiest things first, to avoid hitting
    // the disk too much.

bool ByUsage::_IsShortcutNew(ByUsageShortcut *pscut, ByUsageAppInfo *papp, const UEMINFO *puei)
{
    //
    //  Shortcut is new if...
    //
    //  It was run less than an hour after the app was installed.
    //  It was created relatively recently.
    //
    //
    bool fNew = FILETIMEtoInt64(puei->ftExecute) < FILETIMEtoInt64(papp->_ftCreated) + FT_NEWAPPGRACEPERIOD() &&
                _pMenuCache->IsNewlyCreated(&pscut->GetCreatedTime());

    return fNew;
}

//****************************************************************************


// See how many pinned items there are, so we can tell our dad
// how big we want to be.

void ByUsage::PrePopulate()
{
    _FillPinnedItemsCache();
    _NotifyDesiredSize();
}

//
//  Enumerating out of cache.
//
void ByUsage::EnumFolderFromCache()
{
    if(SHRestricted(REST_NOSMMFUPROGRAMS)) //If we don't need MFU list,...
        return;                            // don't enumerate this!

    _pMenuCache->StartEnum();

    LPITEMIDLIST pidlDesktop, pidlCommonDesktop;
    (void)SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY, &pidlDesktop);
    (void)SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, &pidlCommonDesktop);

    while (TRUE)
    {
        ByUsageShortcut *pscut = _pMenuCache->GetNextShortcut();

        if (!pscut)
            break;

        if (!pscut->IsInteresting())
            continue;

        // Find out if the item is on the desktop, because we don't track new items on the desktop.
        BOOL fIsDesktop = FALSE;
        if ((pidlDesktop && ILIsEqual(pscut->ParentPidl(), pidlDesktop)) ||
            (pidlCommonDesktop && ILIsEqual(pscut->ParentPidl(), pidlCommonDesktop)) )
        {
            fIsDesktop = TRUE;
            pscut->SetNew(FALSE);
        }

        TraceMsg(TF_PROGLIST, "%p.scut.enum", pscut);

        ByUsageAppInfo *papp = pscut->App();

        if (papp)
        {
            // Now enumerate the item itself.  Enumerating an item consists
            // of extracting its UEM data, updating the totals, and possibly
            // marking ourselves as the "best" representative of the associated
            // application.
            //
            //
            UEMINFO uei;
            pscut->GetUEMInfo(&uei);

            // See if this shortcut is still new.  If the app is no longer new,
            // then there's no point in keeping track of the shortcut's new-ness.

            if (pscut->IsNew() && papp->_fNew)
            {
                pscut->SetNew(_IsShortcutNew(pscut, papp, &uei));
            }

            //
            //  Maybe we are the "best"...  Note that we win ties.
            //  This ensures that even if an app is never run, *somebody*
            //  will be chosen as the "best".
            //
            if (CompareUEMInfo(&uei, &papp->_ueiBest) <= 0)
            {
                papp->_ueiBest = uei;
                papp->_pscutBest = pscut;
                if (!fIsDesktop)
                {
                    // Best Start Menu (i.e., non-desktop) item
                    papp->_pscutBestSM = pscut;
                }
                TraceMsg(TF_PROGLIST, "%p.scut.winner papp=%p", pscut, papp);
            }

            //  Include this file's UEM info in the total
            papp->CombineUEMInfo(&uei, pscut->IsNew(), fIsDesktop);
        }
    }
    _pMenuCache->EndEnum();
    ILFree(pidlCommonDesktop);
    ILFree(pidlDesktop);
}

BOOL IsPidlInDPA(LPCITEMIDLIST pidl, CDPAPidl dpa)
{
    int i;
    for (i = dpa.GetPtrCount()-1; i >= 0; i--)
    {
        if (ILIsEqual(pidl, dpa.FastGetPtr(i)))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL ByUsage::_AfterEnumCB(ByUsageAppInfo *papp, AFTERENUMINFO *paei)
{
    // A ByUsageAppInfo doesn't exist unless there's a ByUsageShortcut
    // that references it or it is pinned...

    if (!papp->IsBlank() && papp->_pscutBest)
    {
        UEMINFO uei;
        papp->GetUEMInfo(&uei);
        papp->CombineUEMInfo(&uei, papp->_IsUEMINFONew(&uei));

        // A file counts on the list only if it has been used
        // and is not pinned.  (Pinned items are added to the list
        // elsewhere.)
        //
        // Note that "new" apps are *not* placed on the list until
        // they are used.  ("new" apps are highlighted on the
        // Start Menu.)

        if (!papp->_fPinned &&
            papp->_ueiTotal.cHit && FILETIMEtoInt64(papp->_ueiTotal.ftExecute))
        {
            TraceMsg(TF_PROGLIST, "%p.app.add", papp);

            ByUsageItem *pitem = papp->CreateByUsageItem();
            if (pitem)
            {
                LPITEMIDLIST pidl = pitem->CreateFullPidl();
                if (paei->self->_pByUsageUI)
                {
                    paei->self->_pByUsageUI->AddItem(pitem, NULL, pidl);
                }

                if (paei->self->_pByUsageDUI)
                {
                    paei->self->_pByUsageDUI->AddItem(pitem, NULL, pidl);
                }
                ILFree(pidl);
            }
        }
        else
        {
            TraceMsg(TF_PROGLIST, "%p.app.skip", papp);
        }


#if 0
        //
        //  If you enable this code, then holding down Ctrl and Alt
        //  will cause us to pick a program to be new.  This is for
        //  testing the "new apps" balloon tip.
        //
#define DEBUG_ForceNewApp() \
        (paei->dpaNew && paei->dpaNew.GetPtrCount() == 0 && \
         GetAsyncKeyState(VK_CONTROL) < 0 && GetAsyncKeyState(VK_MENU) < 0)
#else
#define DEBUG_ForceNewApp() FALSE
#endif

        //
        //  Must also check _pscutBestSM because if an app is represented
        //  only on the desktop and not on the start menu, then
        //  _pscutBestSM will be NULL.
        //
        if (paei->dpaNew && (papp->IsNew() || DEBUG_ForceNewApp()) && papp->_pscutBestSM)
        {
            // NTRAID:193226 We mistakenly treat apps on the desktop
            // as if they were "new".
            // we should only care about apps in the start menu
            TraceMsg(TF_PROGLIST, "%p.app.new(%s)", papp, papp->_pszAppPath);
            LPITEMIDLIST pidl = papp->_pscutBestSM->CreateFullPidl();
            while (pidl)
            {
                LPITEMIDLIST pidlParent = NULL;

                if (paei->dpaNew.AppendPtr(pidl) >= 0)
                {
                    pidlParent = ILClone(pidl);
                    pidl = NULL; // ownership of pidl transferred to DPA
                    if (!ILRemoveLastID(pidlParent) || ILIsEmpty(pidlParent) || IsPidlInDPA(pidlParent, paei->dpaNew))
                    {
                        // If failure or if we already have it in the list
                        ILFree(pidlParent);
                        pidlParent = NULL;
                    }

                    // Remember the creation time of the most recent app
                    if (CompareFileTime(&paei->self->_ftNewestApp, &papp->GetCreatedTime()) < 0)
                    {
                        paei->self->_ftNewestApp = papp->GetCreatedTime();
                    }

                    // If the shortcut is even newer, then use that.
                    // This happens in the "freshly installed Darwin app"
                    // case, because Darwin is kinda reluctant to tell
                    // us where the EXE is so all we have to go on is
                    // the shortcut.

                    if (CompareFileTime(&paei->self->_ftNewestApp, &papp->_pscutBestSM->GetCreatedTime()) < 0)
                    {
                        paei->self->_ftNewestApp = papp->_pscutBestSM->GetCreatedTime();
                    }


                }
                ILFree(pidl);

                // Now add the parent to the list also.
                pidl = pidlParent;
            }
        }
    }
    return TRUE;
}

BOOL ByUsage::IsSpecialPinnedPidl(LPCITEMIDLIST pidl)
{
    return _pdirDesktop->Folder()->CompareIDs(0, pidl, _pidlEmail) == S_OK ||
           _pdirDesktop->Folder()->CompareIDs(0, pidl, _pidlBrowser) == S_OK;
}

BOOL ByUsage::IsSpecialPinnedItem(ByUsageItem *pitem)
{
    return IsSpecialPinnedPidl(pitem->RelativePidl());
}

//
//  For each app we found, add it to the list.
//
void ByUsage::AfterEnumItems()
{
    //
    //  First, all pinned items are enumerated unconditionally.
    //
    if (_rtPinned._sl && _rtPinned._sl.GetPtrCount())
    {
        int i;
        for (i = 0; i < _rtPinned._sl.GetPtrCount(); i++)
        {
            ByUsageShortcut *pscut = _rtPinned._sl.FastGetPtr(i);
            ByUsageItem *pitem = pscut->CreatePinnedItem(i);
            if (pitem)
            {
                // Pinned items are relative to the desktop, so we can
                // save ourselves an ILClone because the relative pidl
                // is equal to the absolute pidl.
                ASSERT(pitem->Dir() == _pdirDesktop);

                //
                // Special handling for E-mail and Internet pinned items
                //
                if (IsSpecialPinnedItem(pitem))
                {
                    pitem->EnableSubtitle();
                }

                if (_pByUsageUI)
                    _pByUsageUI->AddItem(pitem, NULL, pscut->RelativePidl());
            }
        }
    }

    //
    //  Now add the separator after the pinned items.
    //
    ByUsageItem *pitem = ByUsageItem::CreateSeparator();
    if (pitem && _pByUsageUI)
    {
        _pByUsageUI->AddItem(pitem, NULL, NULL);
    }

    //
    //  Now walk through all the regular items.
    //
    //  PERF: Can skip this if _cMFUDesired==0 and "highlight new apps" is off
    //
    AFTERENUMINFO aei;
    aei.self = this;
    aei.dpaNew.Create(4);       // Will check failure in callback

    ByUsageAppInfoList *pdpaAppInfo = _pMenuCache->GetAppList();
    pdpaAppInfo->EnumCallbackEx(_AfterEnumCB, &aei);

    // Now that we have the official list of new items, tell the
    // foreground thread to pick it up.  We don't update the master
    // copy in-place for three reasons.
    //
    //  1.  It generates contention since both the foreground and
    //      background threads would be accessing it simultaneously.
    //      This means more critical sections (yuck).
    //  2.  It means that items that were new and are still new have
    //      a brief period where they are no longer new because we
    //      are rebuilding the list.
    //  3.  By having only one thread access the master copy, we avoid
    //      synchronization issues.

    if (aei.dpaNew && _pByUsageUI && _pByUsageUI->_hwnd && SendNotifyMessage(_pByUsageUI->_hwnd, BUM_SETNEWITEMS, 0, (LPARAM)(HDPA)aei.dpaNew))
    {
        aei.dpaNew.Detach();       // Successfully delivered
    }

    //  If we were unable to deliver the new HDPA, then destroy it here
    //  so we don't leak.
    if (aei.dpaNew)
    {
        aei.dpaNew.DestroyCallback(ILFreeCallback, NULL);
    }

    if (!_fUEMRegistered)
    {
        // Register with UEM DB if we haven't done it yet
        ASSERT(!_pMenuCache->IsLocked());
        _fUEMRegistered = SUCCEEDED(UEMRegisterNotify(UEMNotifyCB, static_cast<void *>(this)));
    }
}

int ByUsage::UEMNotifyCB(void *param, const GUID *pguidGrp, int eCmd)
{
    ByUsage *pbu = reinterpret_cast<ByUsage *>(param);
    // Refresh our list whenever a new app is started.
    // or when the session changes (because that changes all the usage counts)
    switch (eCmd)
    {
    case UEME_CTLSESSION:
        if (IsEqualGUID(*pguidGrp, UEMIID_BROWSER))
            break;

        // Fall thru
    case UEME_RUNPIDL:
    case UEME_RUNPATH:

        if (pbu && pbu->_pByUsageUI)
        {
            pbu->_pByUsageUI->Invalidate();
            pbu->_pByUsageUI->StartRefreshTimer();
        }
        break;
    default:
        // Do nothing
        ;
    }
    return 0;
}

BOOL CreateExcludedDirectoriesDPA(const int rgcsidlExclude[], CDPA<TCHAR> *pdpaExclude)
{
    if (*pdpaExclude)
    {
        pdpaExclude->EnumCallback(LocalFreeCallback, NULL);
        pdpaExclude->DeleteAllPtrs();
    }
    else if (!pdpaExclude->Create(4))
    {
        return FALSE;
    }

    ASSERT(*pdpaExclude);
    ASSERT(pdpaExclude->GetPtrCount() == 0);

    int i = 0;
    while (rgcsidlExclude[i] != -1)
    {
        TCHAR szPath[MAX_PATH];
        // Note: This call can legitimately fail if the corresponding
        // folder does not exist, so don't get upset.  Less work for us!
        if (SUCCEEDED(SHGetFolderPath(NULL, rgcsidlExclude[i], NULL, SHGFP_TYPE_CURRENT, szPath)))
        {
            AppendString(*pdpaExclude, szPath);
        }
        i++;
    }

    return TRUE;
}

BOOL CMenuItemsCache::_GetExcludedDirectories()
{
    //
    //  The directories we exclude from enumeration - Shortcuts in these
    //  folders are never candidates for inclusion.
    //
    static const int c_rgcsidlUninterestingDirectories[] = {
        CSIDL_ALTSTARTUP,
        CSIDL_STARTUP,
        CSIDL_COMMON_ALTSTARTUP,
        CSIDL_COMMON_STARTUP,
        -1          // End marker
    };

    return CreateExcludedDirectoriesDPA(c_rgcsidlUninterestingDirectories, &_dpaNotInteresting);
}

BOOL CMenuItemsCache::_IsExcludedDirectory(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwAttributes)
{
    if (_enumfl & ENUMFL_NORECURSE)
        return TRUE;

    if (!(dwAttributes & SFGAO_FILESYSTEM))
        return TRUE;

    // SFGAO_LINK | SFGAO_FOLDER = folder shortcut.
    // We want to exclude those because we can get blocked
    // on network stuff
    if (dwAttributes & SFGAO_LINK)
        return TRUE;

    return FALSE;
}

BOOL CMenuItemsCache::_IsInterestingDirectory(ByUsageDir *pdir)
{
    STRRET str;
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(_pdirDesktop->Folder()->GetDisplayNameOf(pdir->Pidl(), SHGDN_FORPARSING, &str)) &&
        SUCCEEDED(StrRetToBuf(&str, pdir->Pidl(), szPath, ARRAYSIZE(szPath))))
    {
        int i;
        for (i = _dpaNotInteresting.GetPtrCount() - 1; i >= 0; i--)
        {
            if (lstrcmpi(_dpaNotInteresting.FastGetPtr(i), szPath) == 0)
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

void ByUsage::OnPinListChange()
{
    _pByUsageUI->Invalidate();
    PostMessage(_pByUsageUI->_hwnd, ByUsageUI::SFTBM_REFRESH, TRUE, 0);
}

void ByUsage::OnChangeNotify(UINT id, LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (id == NOTIFY_PINCHANGE)
    {
        if (lEvent == SHCNE_EXTENDED_EVENT && pidl1)
        {
            SHChangeDWORDAsIDList *pdwidl = (SHChangeDWORDAsIDList *)pidl1;
            if (pdwidl->dwItem1 == SHCNEE_PINLISTCHANGED)
            {
                OnPinListChange();
            }
        }
    }
    else if (_pMenuCache)
    {
        _pMenuCache->OnChangeNotify(id, lEvent, pidl1, pidl2);
    }
}


void CMenuItemsCache::OnChangeNotify(UINT id, LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    ASSERT(id < min(MAXNOTIFY, NUM_PROGLIST_ROOTS));

    if (id < NUM_PROGLIST_ROOTS)
    {
        _rgrt[id].SetNeedRefresh();
        _fIsCacheUpToDate = FALSE;
        // Once we get one notification, there's no point in listening to further
        // notifications until our next enumeration.  This keeps us from churning
        // while Winstones are running.
        if (_pByUsageUI)
        {
            ASSERT(!IsLocked());
            _pByUsageUI->UnregisterNotify(id);
            _rgrt[id].ClearRegistered();
            _pByUsageUI->Invalidate();
            _pByUsageUI->RefreshNow();
        }
    }
}

void CMenuItemsCache::UnregisterNotifyAll()
{
    if (_pByUsageUI)
    {
        UINT id;
        for (id = 0; id < NUM_PROGLIST_ROOTS; id++)
        {
            _rgrt[id].ClearRegistered();
            _pByUsageUI->UnregisterNotify(id);
        }
    }
}

inline LRESULT ByUsage::_OnNotify(LPNMHDR pnm)
{
    switch (pnm->code)
    {
    case SMN_MODIFYSMINFO:
        return _ModifySMInfo(CONTAINING_RECORD(pnm, SMNMMODIFYSMINFO, hdr));
    }
    return 0;
}

//
//  We need this message to avoid a race condition between the background
//  thread (the enumerator) and the foreground thread.  So the rule is
//  that only the foreground thread is allowd to mess with _dpaNew.
//  The background thread collects the information it wants into a
//  separate DPA and hands it to us on the foreground thread, where we
//  can safely set it into _dpaNew without encountering a race condition.
//
inline LRESULT ByUsage::_OnSetNewItems(HDPA hdpaNew)
{
    CDPAPidl dpaNew(hdpaNew);

    //
    //  Most of the time, there are no new apps and there were no new apps
    //  last time either.  Short-circuit this case...
    //
    int cNew = _dpaNew ? _dpaNew.GetPtrCount() : 0;

    if (cNew == 0 && dpaNew.GetPtrCount() == 0)
    {
        // Both old and new are empty.  We're finished.
        // (Since we own dpaNew, free it to avoid a memory leak.)
        dpaNew.DestroyCallback(ILFreeCallback, NULL);
        return 0;
    }

    //  Now swap the new DPA in

    if (_dpaNew)
    {
        _dpaNew.DestroyCallback(ILFreeCallback, NULL);
    }
    _dpaNew.Attach(hdpaNew);

    // Tell our dad that we can identify new items
    // Also tell him the timestamp of the most recent app
    // (so he can tell whether or not to restart the "offer new apps" counter)
    SMNMHAVENEWITEMS nmhni;
    nmhni.ftNewestApp = _ftNewestApp;
    _SendNotify(_pByUsageUI->_hwnd, SMN_HAVENEWITEMS, &nmhni.hdr);

    return 0;
}

LRESULT ByUsage::OnWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_NOTIFY:
        return _OnNotify(reinterpret_cast<LPNMHDR>(lParam));

    case BUM_SETNEWITEMS:
        return _OnSetNewItems(reinterpret_cast<HDPA>(lParam));

    case WM_SETTINGCHANGE:
        static const TCHAR c_szClients[] = TEXT("Software\\Clients");
        if ((wParam == 0 && lParam == 0) ||     // wildcard
            (lParam && StrCmpNIC((LPCTSTR)lParam, c_szClients, ARRAYSIZE(c_szClients) - 1) == 0)) // client change
        {
            _pByUsageUI->ForceChange();         // even though the pidls didn't change, their targets did
            _ulPinChange = -1;                  // Force reload even if list didn't change
            OnPinListChange();                  // reload the pin list (since a client changed)
        }
        break;
    }

    // Else fall back to parent implementation
    return _pByUsageUI->SFTBarHost::OnWndProc(hwnd, uMsg, wParam, lParam);
}

LRESULT ByUsage::_ModifySMInfo(PSMNMMODIFYSMINFO pmsi)
{
    LPSMDATA psmd = pmsi->psmd;

    // Do this only if there is a ShellFolder.  We don't want to fault
    // on the static menu items.
    if ((psmd->dwMask & SMDM_SHELLFOLDER) && _dpaNew)
    {

        // NTRAID:135699: this needs big-time optimization
        // E.g., remember the previous folder if there was nothing found

        LPITEMIDLIST pidl = NULL;

        IAugmentedShellFolder2* pasf2;
        if (SUCCEEDED(psmd->psf->QueryInterface(IID_PPV_ARG(IAugmentedShellFolder2, &pasf2))))
        {
            LPITEMIDLIST pidlFolder;
            LPITEMIDLIST pidlItem;
            if (SUCCEEDED(pasf2->UnWrapIDList(psmd->pidlItem, 1, NULL, &pidlFolder, &pidlItem, NULL)))
            {
                pidl = ILCombine(pidlFolder, pidlItem);
                ILFree(pidlFolder);
                ILFree(pidlItem);
            }
            pasf2->Release();
        }

        if (!pidl)
        {
            pidl = ILCombine(psmd->pidlFolder, psmd->pidlItem);
        }

        if (pidl)
        {
            if (IsPidlInDPA(pidl, _dpaNew))
            {
                // Designers say: New items should never be demoted
                pmsi->psminfo->dwFlags |= SMIF_NEW;
                pmsi->psminfo->dwFlags &= ~SMIF_DEMOTED;
            }
            ILFree(pidl);
        }
    }
    return 0;
}

void ByUsage::_FillPinnedItemsCache()
{
    if(SHRestricted(REST_NOSMPINNEDLIST))   //If no pinned list is allowed,.....
        return;                             //....there is nothing to do!
        
    ULONG ulPinChange;
    _psmpin->GetChangeCount(&ulPinChange);
    if (_ulPinChange == ulPinChange)
    {
        // No change in pin list; do not need to reload
        return;
    }

    _ulPinChange = ulPinChange;
    _rtPinned.Reset();
    if (_rtPinned._sl.Create(4))
    {
        IEnumIDList *penum;

        if (SUCCEEDED(_psmpin->EnumObjects(&penum)))
        {
            LPITEMIDLIST pidl;
            while (penum->Next(1, &pidl, NULL) == S_OK)
            {
                IShellLink *psl;
                HRESULT hr;
                ByUsageHiddenData hd;

                //
                //  If we have a shortcut, do bookkeeping based on the shortcut
                //  target.  Otherwise do it based on the pinned object itself.
                //  Note that we do not go through _PathIsInterestingExe
                //  because all pinned items are interesting.

                hr = SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IShellLink, &psl));
                if (SUCCEEDED(hr))
                {
                    hd.LoadFromShellLink(psl);
                    psl->Release();

                    // We do not need to SHRegisterDarwinLink because the only
                    // reason for getting the MSI path is so pinned items can
                    // prevent items on the Start Menu from appearing in the MFU.
                    // So let the shortcut on the Start Menu do the registration.
                    // (If there is none, then that's even better - no work to do!)
                    hd.UpdateMSIPath();
                }

                if (FAILED(hr))
                {
                    hr = DisplayNameOfAsOLESTR(_pdirDesktop->Folder(), pidl, SHGDN_FORPARSING, &hd._pwszTargetPath);
                }

                //
                //  If we were able to figure out what the pinned object is,
                //  use that information to block the app from also appearing
                //  in the MFU.
                //
                //  Inability to identify the pinned
                //  object is not grounds for rejection.  A pinned items is
                //  of great sentimental value to the user.
                //
                if (FAILED(hr))
                {
                    ASSERT(hd.IsClear());
                }

                ByUsageShortcut *pscut = _pMenuCache->CreateShortcutFromHiddenData(_pdirDesktop, pidl, &hd, TRUE);
                if (pscut)
                {
                    if (_rtPinned._sl.AppendPtr(pscut) >= 0)
                    {
                        pscut->SetInteresting(true);  // Pinned items are always interesting
                        if (IsSpecialPinnedPidl(pidl))
                        {
                            ByUsageAppInfo *papp = _pMenuCache->GetAppInfoFromSpecialPidl(pidl);
                            pscut->SetApp(papp);
                            if (papp) papp->Release();
                        }
                    }
                    else
                    {
                        // Couldn't append; oh well
                        delete pscut;       // "delete" can handle NULL pointer
                    }
                }
                hd.Clear();
                ILFree(pidl);
            }
            penum->Release();
        }
    }

}

IAssociationElement *GetAssociationElementFromSpecialPidl(IShellFolder *psf, LPCITEMIDLIST pidlItem)
{
    IAssociationElement *pae = NULL;

    // There is no way to get the IAssociationElement directly, so
    // we get the IExtractIcon and then ask him for the IAssociationElement.
    IExtractIcon *pxi;
    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidlItem, IID_PPV_ARG_NULL(IExtractIcon, &pxi))))
    {
        IUnknown_QueryService(pxi, IID_IAssociationElement, IID_PPV_ARG(IAssociationElement, &pae));
        pxi->Release();
    }

    return pae;
}

//
//  On success, the returned ByUsageAppInfo has been AddRef()d
//
ByUsageAppInfo *CMenuItemsCache::GetAppInfoFromSpecialPidl(LPCITEMIDLIST pidl)
{
    ByUsageAppInfo *papp = NULL;

    IAssociationElement *pae = GetAssociationElementFromSpecialPidl(_pdirDesktop->Folder(), pidl);
    if (pae)
    {
        LPWSTR pszData;
        if (SUCCEEDED(pae->QueryString(AQVS_APPLICATION_PATH, L"open", &pszData)))
        {
            //
            //  HACK!  Outlook puts the short file name in the registry.
            //  Convert to long file name (if it won't cost too much) so
            //  people who select Outlook as their default mail client
            //  won't get a dup copy in the MFU.
            //
            LPTSTR pszPath = pszData;
            TCHAR szLFN[MAX_PATH];
            if (!PathIsNetworkPath(pszData))
            {
                DWORD dwLen = GetLongPathName(pszData, szLFN, ARRAYSIZE(szLFN));
                if (dwLen && dwLen < ARRAYSIZE(szLFN))
                {
                    pszPath = szLFN;
                }
            }

            papp = GetAppInfo(pszPath, true);
            SHFree(pszData);
        }
        pae->Release();
    }
    return papp;
}

void ByUsage::_EnumPinnedItemsFromCache()
{
    if (_rtPinned._sl)
    {
        int i;
        for (i = 0; i < _rtPinned._sl.GetPtrCount(); i++)
        {
            ByUsageShortcut *pscut = _rtPinned._sl.FastGetPtr(i);

            TraceMsg(TF_PROGLIST, "%p.scut.enumC", pscut);

            // Enumerating a pinned item consists of marking the corresponding
            // application as "I am pinned, do not mess with me!"

            ByUsageAppInfo *papp = pscut->App();

            if (papp)
            {
                papp->_fPinned = TRUE;
                TraceMsg(TF_PROGLIST, "%p.scut.pin papp=%p", pscut, papp);

            }
        }
    }
}

const struct CMenuItemsCache::ROOTFOLDERINFO CMenuItemsCache::c_rgrfi[] = {
    { CSIDL_STARTMENU,               ENUMFL_RECURSE | ENUMFL_CHECKNEW | ENUMFL_ISSTARTMENU },
    { CSIDL_PROGRAMS,                ENUMFL_RECURSE | ENUMFL_CHECKNEW | ENUMFL_CHECKISCHILDOFPREVIOUS },
    { CSIDL_COMMON_STARTMENU,        ENUMFL_RECURSE | ENUMFL_CHECKNEW | ENUMFL_ISSTARTMENU },
    { CSIDL_COMMON_PROGRAMS,         ENUMFL_RECURSE | ENUMFL_CHECKNEW | ENUMFL_CHECKISCHILDOFPREVIOUS },
    { CSIDL_DESKTOPDIRECTORY,        ENUMFL_NORECURSE | ENUMFL_NOCHECKNEW },
    { CSIDL_COMMON_DESKTOPDIRECTORY, ENUMFL_NORECURSE | ENUMFL_NOCHECKNEW },  // The limit for register notify is currently 5 (slots 0 through 4)    
                                                                            // Changing this requires changing ByUsageUI::SFTHOST_MAXNOTIFY
};

//
//  Here's where we decide all the things that should be enumerated
//  in the "My Programs" list.
//
void ByUsage::EnumItems()
{
    _FillPinnedItemsCache();
    _NotifyDesiredSize();


    _pMenuCache->LockPopup();
    _pMenuCache->InitCache();

    BOOL fNeedUpdateDarwin = !_pMenuCache->IsCacheUpToDate();

    // Note!  UpdateCache() must occur before _EnumPinnedItemsFromCache()
    // because UpdateCache() resets _fPinned.
    _pMenuCache->UpdateCache();

    if (fNeedUpdateDarwin)
    {
        SHReValidateDarwinCache();
    }

    _pMenuCache->RefreshDarwinShortcuts(&_rtPinned);
    _EnumPinnedItemsFromCache();
    EnumFolderFromCache();

    // Finished collecting data; do some postprocessing...
    AfterEnumItems();

    // Do not unlock before this point, as AfterEnumItems depends on the cache to stay put.
    _pMenuCache->UnlockPopup();
}

void ByUsage::_NotifyDesiredSize()
{
    if (_pByUsageUI)
    {
        int cPinned = _rtPinned._sl ? _rtPinned._sl.GetPtrCount() : 0;

        int cNormal;
        DWORD cb = sizeof(cNormal);
        if (SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_STARTPANE_SETTINGS,
                       REGSTR_VAL_DV2_MINMFU, NULL, &cNormal, &cb) != ERROR_SUCCESS)
        {
            cNormal = REGSTR_VAL_DV2_MINMFU_DEFAULT;
        }

        _cMFUDesired = cNormal;
        _pByUsageUI->SetDesiredSize(cPinned, cNormal);
    }
}


//****************************************************************************
// CMenuItemsCache

CMenuItemsCache::CMenuItemsCache() : _cref(1)
{
}

LONG CMenuItemsCache::AddRef()
{
    return InterlockedIncrement(&_cref);
}

LONG CMenuItemsCache::Release()
{
    ASSERT( 0 != _cref );
    LONG cRef = InterlockedDecrement(&_cref);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CMenuItemsCache::Initialize(ByUsageUI *pbuUI, FILETIME * pftOSInstall)
{
    HRESULT hr = S_OK;

    // Must do this before any of the operations that can fail
    // because we unconditionally call DeleteCriticalSection in destructor
    _fCSInited = InitializeCriticalSectionAndSpinCount(&_csInUse, 0);

    if (!_fCSInited)
    {
        return E_OUTOFMEMORY;
    }

    hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &_pqa));
    if (FAILED(hr))
    {
        return hr;
    }

    _pByUsageUI = pbuUI;

    _ftOldApps = *pftOSInstall;

    _pdirDesktop = ByUsageDir::CreateDesktop();
    
    if (!_dpaAppInfo.Create(4))
    {
        hr = E_OUTOFMEMORY;
    }

    if (!_GetExcludedDirectories())
    {
        hr = E_OUTOFMEMORY;
    }

    if (!_dpaKill.Create(4) ||
        !_dpaKillLink.Create(4)) {
        return E_OUTOFMEMORY;
    }

    _InitKillList();

    _hPopupReady = CreateMutex(NULL, FALSE, NULL);
    if (!_hPopupReady)
    {
        return E_OUTOFMEMORY;
    }

    // By default, we want to check applications for newness.
    _fCheckNew = TRUE;

    return hr;
}
HRESULT CMenuItemsCache::AttachUI(ByUsageUI *pbuUI)
{
    // We do not AddRef here so that destruction always happens on the same thread that created the object
    // but beware of lifetime issues: we need to synchronize attachUI/detachUI operations with LockPopup and UnlockPopup.

    LockPopup();
    _pByUsageUI = pbuUI;
    UnlockPopup();

    return S_OK;
}

CMenuItemsCache::~CMenuItemsCache()
{
    if (_fIsCacheUpToDate)
    {
        _SaveCache();
    }

    if (_dpaNotInteresting)
    {
        _dpaNotInteresting.DestroyCallback(LocalFreeCallback, NULL);
    }

    if (_dpaKill)
    {
        _dpaKill.DestroyCallback(LocalFreeCallback, NULL);
    }

    if (_dpaKillLink)
    {
        _dpaKillLink.DestroyCallback(LocalFreeCallback, NULL);
    }

    // Must delete the roots before destroying _dpaAppInfo.
    int i;
    for (i = 0; i < ARRAYSIZE(_rgrt); i++)
    {
        _rgrt[i].Reset();
    }

    ATOMICRELEASE(_pqa);
    DPADELETEANDDESTROY(_dpaAppInfo);

    if (_pdirDesktop)
    {
        _pdirDesktop->Release();
    }

    if (_hPopupReady)
    {
        CloseHandle(_hPopupReady);
    }

    if (_fCSInited)
    {
        DeleteCriticalSection(&_csInUse);
    }
}


BOOL CMenuItemsCache::_ShouldProcessRoot(int iRoot)
{
    BOOL fRet = TRUE;

    if (!_rgrt[iRoot]._pidl)
    {
        fRet = FALSE;
    }
    else if ((c_rgrfi[iRoot]._enumfl & ENUMFL_CHECKISCHILDOFPREVIOUS) && !SHRestricted(REST_NOSTARTMENUSUBFOLDERS) )
    {
        ASSERT(iRoot >= 1);
        if (_rgrt[iRoot-1]._pidl && ILIsParent(_rgrt[iRoot-1]._pidl, _rgrt[iRoot]._pidl, FALSE))
        {
            fRet = FALSE;
        }
    }
    return fRet;
}

//****************************************************************************
//
//  The format of the ProgramsCache is as follows:
//
//  [DWORD] dwVersion
//
//      If the version is wrong, then ignore.  Not worth trying to design
//      a persistence format that is forward-compatible since it's just
//      a cache.
//
//      Don't be stingy about incrementing the dwVersion.  We've got room
//      for four billion revs.

#define PROGLIST_VERSION 9

//
//
//  For each special folder we persist:
//
//      [BYTE] CSIDL_xxx (as a sanity check)
//
//      Followed by a sequence of segments; either...
//
//          [BYTE] 0x00 -- Change directory
//          [pidl] directory (relative to CSIDL_xxx)
//
//      or
//
//          [BYTE] 0x01 -- Add shortcut
//          [pidl] item (relative to current directory)
//
//      or
//
//          [BYTE] 0x02 -- end
//

#define CACHE_CHDIR     0
#define CACHE_ITEM      1
#define CACHE_END       2

BOOL CMenuItemsCache::InitCache()
{
    COMPILETIME_ASSERT(ARRAYSIZE(c_rgrfi) == NUM_PROGLIST_ROOTS);

        // Make sure we don't use more than MAXNOTIFY notify slots for the cache
    COMPILETIME_ASSERT( NUM_PROGLIST_ROOTS <= MAXNOTIFY);

    if (_fIsInited)
        return TRUE;

    BOOL fSuccess = FALSE;
    int irfi;

    IStream *pstm = SHOpenRegStream2(HKEY_CURRENT_USER, REGSTR_PATH_STARTFAVS, REGSTR_VAL_PROGLIST, STGM_READ);
    if (pstm)
    {
        ByUsageDir *pdirRoot = NULL;
        ByUsageDir *pdir = NULL;

        DWORD dwVersion;
        if (FAILED(IStream_Read(pstm, &dwVersion, sizeof(dwVersion))) ||
            dwVersion != PROGLIST_VERSION)
        {
            goto panic;
        }

        for (irfi = 0; irfi < ARRAYSIZE(c_rgrfi); irfi++)
        {
            ByUsageRoot *prt = &_rgrt[irfi];

            // If SHGetSpecialFolderLocation fails, it could mean that
            // the directory was recently restricted.  We *could* just
            // skip over this block and go to the next csidl, but that
            // would be actual work, and this is just a cache, so we may
            // as well just panic and re-enumerate from scratch.
            //
            if (FAILED(SHGetSpecialFolderLocation(NULL, c_rgrfi[irfi]._csidl, &prt->_pidl)))
            {
                goto panic;
            }

            if (!_ShouldProcessRoot(irfi))
                continue;

            if (!prt->_sl.Create(4))
            {
                goto panic;
            }

            BYTE csidl;
            if (FAILED(IStream_Read(pstm, &csidl, sizeof(csidl))) ||
                csidl != c_rgrfi[irfi]._csidl)
            {
                goto panic;
            }

            pdirRoot = ByUsageDir::Create(_pdirDesktop, prt->_pidl);

            if (!pdirRoot)
            {
                goto panic;
            }


            BYTE bCmd;
            do
            {
                LPITEMIDLIST pidl;

                if (FAILED(IStream_Read(pstm, &bCmd, sizeof(bCmd))))
                {
                    goto panic;
                }

                switch (bCmd)
                {
                case CACHE_CHDIR:
                    // Toss the old directory
                    if (pdir)
                    {
                        pdir->Release();
                        pdir = NULL;
                    }

                    // Figure out where the new directory is
                    if (FAILED(IStream_ReadPidl(pstm, &pidl)))
                    {
                        goto panic;
                    }

                    // and create it
                    pdir = ByUsageDir::Create(pdirRoot, pidl);
                    ILFree(pidl);

                    if (!pdir)
                    {
                        goto panic;
                    }
                    break;

                case CACHE_ITEM:
                    {
                        // Must set a directory befor creating an item
                        if (!pdir)
                        {
                            goto panic;
                        }

                        // Get the new item
                        if (FAILED(IStream_ReadPidl(pstm, &pidl)))
                        {
                            goto panic;
                        }

                        // Create it
                        ByUsageShortcut *pscut = _CreateFromCachedPidl(prt, pdir, pidl);
                        ILFree(pidl);
                        if (!pscut)
                        {
                            goto panic;
                        }
                    }
                    break;

                case CACHE_END:
                    break;

                default:
                    goto panic;
                }
            }
            while (bCmd != CACHE_END);

            pdirRoot->Release();
            pdirRoot = NULL;
            if (pdir)
            {
                pdir->Release();
                pdir = NULL;
            }

            prt->SetNeedRefresh();
        }

        fSuccess = TRUE;

    panic:
        if (!fSuccess)
        {
            for (irfi = 0; irfi < ARRAYSIZE(c_rgrfi); irfi++)
            {
                _rgrt[irfi].Reset();
            }
        }

        if (pdirRoot)
        {
            pdirRoot->Release();
        }

        if (pdir)
        {
            pdir->Release();
        }

        pstm->Release();
    }

    _fIsInited = TRUE;

    return fSuccess;
}

HRESULT CMenuItemsCache::UpdateCache()
{
    FILETIME ft;
    // Apps are "new" only if installed less than 1 week ago.
    // They also must postdate the user's first use of the new Start Menu.
    GetSystemTimeAsFileTime(&ft);
    DecrementFILETIME(&ft, FT_ONEDAY * 7);

    // _ftOldApps is the more recent of OS install time, or last week.
    if (CompareFileTime(&ft, &_ftOldApps) >= 0)
    {
        _ftOldApps = ft;
    }

    _dpaAppInfo.EnumCallbackEx(ByUsageAppInfo::EnumResetCB, this);

    if(!SHRestricted(REST_NOSMMFUPROGRAMS))
    {
        int i;
        for (i = 0; i < ARRAYSIZE(c_rgrfi); i++)
        {
            ByUsageRoot *prt = &_rgrt[i];
            int csidl = c_rgrfi[i]._csidl;
            _enumfl = c_rgrfi[i]._enumfl;

            if (!prt->_pidl)
            {
                (void)SHGetSpecialFolderLocation(NULL, csidl, &prt->_pidl);     // void cast to keep prefast happy
                prt->SetNeedRefresh();
            }

            if (!_ShouldProcessRoot(i))
                continue;


            // Restrictions might deny recursing into subfolders
            if ((_enumfl & ENUMFL_ISSTARTMENU) && SHRestricted(REST_NOSTARTMENUSUBFOLDERS))
            {
                _enumfl &= ~ENUMFL_RECURSE;
                _enumfl |= ENUMFL_NORECURSE;
            }

            // Fill the cache if it is stale

            LPITEMIDLIST pidl;
            if (!IsRestrictedCsidl(csidl) &&
                SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidl, &pidl)))
            {
                if (prt->_pidl == NULL || !ILIsEqual(prt->_pidl, pidl) ||
                    prt->NeedsRefresh() || prt->NeedsRegister())
                {
                    if (!prt->_pidl || prt->NeedsRefresh())
                    {
                        prt->ClearNeedRefresh();
                        ASSERT(prt->_slOld == NULL);
                        prt->_slOld = prt->_sl;
                        prt->_cOld = prt->_slOld ? prt->_slOld.GetPtrCount() : 0;
                        prt->_iOld = 0;

                        // Free previous pidl
                        ILFree(prt->_pidl);
                        prt->_pidl = NULL;

                        if (prt->_sl.Create(4))
                        {
                            ByUsageDir *pdir = ByUsageDir::Create(_pdirDesktop, pidl);
                            if (pdir)
                            {
                                prt->_pidl = pidl;  // Take ownership
                                pidl = NULL;        // So ILFree won't nuke it
                                _FillFolderCache(pdir, prt);
                                pdir->Release();
                            }
                        }
                        DPADELETEANDDESTROY(prt->_slOld);
                    }
                    if (_pByUsageUI && prt->NeedsRegister() && prt->_pidl)
                    {
                        ASSERT(i < ByUsageUI::SFTHOST_MAXNOTIFY);
                        prt->SetRegistered();
                        ASSERT(!IsLocked());
                        _pByUsageUI->RegisterNotify(i, SHCNE_DISKEVENTS, prt->_pidl, TRUE);
                    }
                }
                ILFree(pidl);

            }
            else
            {
                // Special folder doesn't exist; erase the file list
                prt->Reset();
            }
        } // for loop!

    } // Restriction!
    _fIsCacheUpToDate = TRUE;
    return S_OK;
}

void CMenuItemsCache::RefreshDarwinShortcuts(ByUsageRoot *prt)
{
    if (prt->_sl)
    {
        int j = prt->_sl.GetPtrCount();
        while (--j >= 0)
        {
            ByUsageShortcut *pscut = prt->_sl.FastGetPtr(j);
            if (FAILED(_UpdateMSIPath(pscut)))
            {
                prt->_sl.DeletePtr(j);  // remove the bad shortcut so we don't fault
            }
        }
    }
}

void CMenuItemsCache::RefreshCachedDarwinShortcuts()
{
    if(!SHRestricted(REST_NOSMMFUPROGRAMS))
    {
        Lock();

        for (int i = 0; i < ARRAYSIZE(c_rgrfi); i++)
        {
            RefreshDarwinShortcuts(&_rgrt[i]);
        }
        Unlock();
    }
}


ByUsageShortcut *CMenuItemsCache::_CreateFromCachedPidl(ByUsageRoot *prt, ByUsageDir *pdir, LPITEMIDLIST pidl)
{
    ByUsageHiddenData hd;
    UINT buhd = ByUsageHiddenData::BUHD_TARGETPATH | ByUsageHiddenData::BUHD_MSIPATH;
    hd.Get(pidl, buhd);

    ByUsageShortcut *pscut = CreateShortcutFromHiddenData(pdir, pidl, &hd);
    if (pscut)
    {
        if (prt->_sl.AppendPtr(pscut) >= 0)
        {
            _SetInterestingLink(pscut);
        }
        else
        {
            // Couldn't append; oh well
            delete pscut;       // "delete" can handle NULL pointer
        }
    }

    hd.Clear();

    return pscut;
}

HRESULT IStream_WriteByte(IStream *pstm, BYTE b)
{
    return IStream_Write(pstm, &b, sizeof(b));
}

#ifdef DEBUG
//
//  Like ILIsParent, but defaults to TRUE if we don't have enough memory
//  to determine for sure.  (ILIsParent defaults to FALSE on error.)
//
BOOL ILIsProbablyParent(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
    BOOL fRc = TRUE;
    LPITEMIDLIST pidlT = ILClone(pidlChild);
    if (pidlT)
    {

        // Truncate pidlT to the same depth as pidlParent.
        LPCITEMIDLIST pidlParentT = pidlParent;
        LPITEMIDLIST pidlChildT = pidlT;
        while (!ILIsEmpty(pidlParentT))
        {
            pidlChildT = _ILNext(pidlChildT);
            pidlParentT = _ILNext(pidlParentT);
        }

        pidlChildT->mkid.cb = 0;

        // Okay, at this point pidlT should equal pidlParent.
        IShellFolder *psfDesktop;
        if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
        {
            HRESULT hr = psfDesktop->CompareIDs(0, pidlT, pidlParent);
            if (SUCCEEDED(hr) && ShortFromResult(hr) != 0)
            {
                // Definitely, conclusively different.
                fRc = FALSE;
            }
            psfDesktop->Release();
        }

        ILFree(pidlT);
    }
    return fRc;
}
#endif

inline LPITEMIDLIST ILFindKnownChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
#ifdef DEBUG
    // ILIsParent will give wrong answers in low-memory situations
    // (which testers like to simulate) so we roll our own.
    // ASSERT(ILIsParent(pidlParent, pidlChild, FALSE));
    ASSERT(ILIsProbablyParent(pidlParent, pidlChild));
#endif

    while (!ILIsEmpty(pidlParent))
    {
        pidlChild = _ILNext(pidlChild);
        pidlParent = _ILNext(pidlParent);
    }
    return const_cast<LPITEMIDLIST>(pidlChild);
}

void CMenuItemsCache::_SaveCache()
{
    int irfi;
    BOOL fSuccess = FALSE;

    IStream *pstm = SHOpenRegStream2(HKEY_CURRENT_USER, REGSTR_PATH_STARTFAVS, REGSTR_VAL_PROGLIST, STGM_WRITE);
    if (pstm)
    {
        DWORD dwVersion = PROGLIST_VERSION;
        if (FAILED(IStream_Write(pstm, &dwVersion, sizeof(dwVersion))))
        {
            goto panic;
        }

        for (irfi = 0; irfi < ARRAYSIZE(c_rgrfi); irfi++)
        {
            if (!_ShouldProcessRoot(irfi))
                continue;

            ByUsageRoot *prt = &_rgrt[irfi];

            if (FAILED(IStream_WriteByte(pstm, (BYTE)c_rgrfi[irfi]._csidl)))
            {
                goto panic;
            }

            if (prt->_sl && prt->_pidl)
            {
                int i;
                ByUsageDir *pdir = NULL;
                for (i = 0; i < prt->_sl.GetPtrCount(); i++)
                {
                    ByUsageShortcut *pscut = prt->_sl.FastGetPtr(i);

                    // If the directory changed, write out a chdir entry
                    if (pdir != pscut->Dir())
                    {
                        pdir = pscut->Dir();

                        // Write the new directory
                        if (FAILED(IStream_WriteByte(pstm, CACHE_CHDIR)) ||
                            FAILED(IStream_WritePidl(pstm, ILFindKnownChild(prt->_pidl, pdir->Pidl()))))
                        {
                            goto panic;
                        }
                    }

                    // Now write out the shortcut
                    if (FAILED(IStream_WriteByte(pstm, CACHE_ITEM)) ||
                        FAILED(IStream_WritePidl(pstm, pscut->RelativePidl())))
                    {
                        goto panic;
                    }
                }
            }

            // Now write out the terminator
            if (FAILED(IStream_WriteByte(pstm, CACHE_END)))
            {
                goto panic;
            }

        }

        fSuccess = TRUE;

    panic:
        pstm->Release();

        if (!fSuccess)
        {
            SHDeleteValue(HKEY_CURRENT_USER, REGSTR_PATH_STARTFAVS, REGSTR_VAL_PROGLIST);
        }
    }
}


void CMenuItemsCache::StartEnum()
{
    _iCurrentRoot = 0;
    _iCurrentIndex = 0;
}

void CMenuItemsCache::EndEnum()
{
}

ByUsageShortcut *CMenuItemsCache::GetNextShortcut()
{
    ByUsageShortcut *pscut = NULL;

    if (_iCurrentRoot < NUM_PROGLIST_ROOTS)
    {
        if (_rgrt[_iCurrentRoot]._sl && _iCurrentIndex < _rgrt[_iCurrentRoot]._sl.GetPtrCount())
        {
            pscut = _rgrt[_iCurrentRoot]._sl.FastGetPtr(_iCurrentIndex);
            _iCurrentIndex++;
        }
        else
        {
            // Go to next root
            _iCurrentIndex = 0;
            _iCurrentRoot++;
            pscut = GetNextShortcut();
        }
    }

    return pscut;
}

//****************************************************************************

void AppendString(CDPA<TCHAR> dpa, LPCTSTR psz)
{
    LPTSTR pszDup = StrDup(psz);
    if (pszDup && dpa.AppendPtr(pszDup) < 0)
    {
        LocalFree(pszDup);  // Append failed
    }
}

BOOL LocalFreeCallback(LPTSTR psz, LPVOID)
{
    LocalFree(psz);
    return TRUE;
}

BOOL ILFreeCallback(LPITEMIDLIST pidl, LPVOID)
{
    ILFree(pidl);
    return TRUE;
}

int ByUsage::CompareItems(PaneItem *p1, PaneItem *p2)
{
    //
    //  The separator comes before regular items.
    //
    if (p1->IsSeparator())
    {
        return -1;
    }

    if (p2->IsSeparator())
    {
        return +1;
    }

    ByUsageItem *pitem1 = static_cast<ByUsageItem *>(p1);
    ByUsageItem *pitem2 = static_cast<ByUsageItem *>(p2);

    return CompareUEMInfo(&pitem1->_uei, &pitem2->_uei);
}

// Sort by most frequently used - break ties by most recently used
int ByUsage::CompareUEMInfo(UEMINFO *puei1, UEMINFO *puei2)
{
    int iResult = puei2->cHit - puei1->cHit;
    if (iResult == 0)
    {
        iResult = ::CompareFileTime(&puei2->ftExecute, &puei1->ftExecute);
    }

    return iResult;
}

LPITEMIDLIST ByUsage::GetFullPidl(PaneItem *p)
{
    ByUsageItem *pitem = static_cast<ByUsageItem *>(p);

    return pitem->CreateFullPidl();
}


HRESULT ByUsage::GetFolderAndPidl(PaneItem *p,
        IShellFolder **ppsfOut, LPCITEMIDLIST *ppidlOut)
{
    ByUsageItem *pitem = static_cast<ByUsageItem *>(p);

    // If a single-level child pidl, then we can short-circuit the
    // SHBindToFolderIDListParent
    if (_ILNext(pitem->_pidl)->mkid.cb == 0)
    {
        *ppsfOut = pitem->_pdir->Folder(); (*ppsfOut)->AddRef();
        *ppidlOut = pitem->_pidl;
        return S_OK;
    }
    else
    {
        // Multi-level child pidl
        return SHBindToFolderIDListParent(pitem->_pdir->Folder(), pitem->_pidl,
                    IID_PPV_ARG(IShellFolder, ppsfOut), ppidlOut);
    }
}

HRESULT ByUsage::ContextMenuDeleteItem(PaneItem *p, IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici)
{
    IShellFolder *psf;
    LPCITEMIDLIST pidlItem;
    ByUsageItem *pitem = static_cast<ByUsageItem *>(p);

    HRESULT hr = GetFolderAndPidl(pitem, &psf, &pidlItem);
    if (SUCCEEDED(hr))
    {
        // Unpin the item - we go directly to the IStartMenuPin because
        // the context menu handler might decide not to support pin/unpin
        // for this item because it doesn't satisfy some criteria or other.
        LPITEMIDLIST pidlFull = pitem->CreateFullPidl();
        if (pidlFull)
        {
            _psmpin->Modify(pidlFull, NULL); // delete from pin list
            ILFree(pidlFull);
        }

        // Set hit count for shortcut to zero
        UEMINFO uei;
        ZeroMemory(&uei, sizeof(UEMINFO));
        uei.cbSize = sizeof(UEMINFO);
        uei.dwMask = UEIM_HIT;
        uei.cHit = 0;

        _SetUEMPidlInfo(psf, pidlItem, &uei);

        // Set hit count for target app to zero
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(_GetShortcutExeTarget(psf, pidlItem, szPath, ARRAYSIZE(szPath))))
        {
            _SetUEMPathInfo(szPath, &uei);
        }

        // Set hit count for Darwin target to zero
        ByUsageHiddenData hd;
        hd.Get(pidlItem, ByUsageHiddenData::BUHD_MSIPATH);
        if (hd._pwszMSIPath && hd._pwszMSIPath[0])
        {
            _SetUEMPathInfo(hd._pwszMSIPath, &uei);
        }
        hd.Clear();

        psf->Release();

        if (IsSpecialPinnedItem(pitem))
        {
            c_tray.CreateStartButtonBalloon(0, IDS_STARTPANE_SPECIALITEMSTIP);
        }

        // If the item wasn't pinned, then all we did was dork some usage
        // counts, which does not trigger an automatic refresh.  So do a
        // manual one.
        _pByUsageUI->Invalidate();
        PostMessage(_pByUsageUI->_hwnd, ByUsageUI::SFTBM_REFRESH, TRUE, 0);

    }

    return hr;
}

HRESULT ByUsage::ContextMenuInvokeItem(PaneItem *pitem, IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici, LPCTSTR pszVerb)
{
    ASSERT(_pByUsageUI);

    HRESULT hr;
    if (StrCmpIC(pszVerb, TEXT("delete")) == 0)
    {
        hr = ContextMenuDeleteItem(pitem, pcm, pici);
    }
    else
    {
        // Don't need to refresh explicitly if the command is pin/unpin
        // because the changenotify will do it for us
        hr = _pByUsageUI->SFTBarHost::ContextMenuInvokeItem(pitem, pcm, pici, pszVerb);
    }

    return hr;
}

int ByUsage::ReadIconSize()
{
    COMPILETIME_ASSERT(SFTBarHost::ICONSIZE_SMALL == 0);
    COMPILETIME_ASSERT(SFTBarHost::ICONSIZE_LARGE == 1);
    return SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, REGSTR_VAL_DV2_LARGEICONS, FALSE, TRUE /* default to large*/);
}

BOOL ByUsage::_IsPinnedExe(ByUsageItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlItem)
{
    //
    //  Early-out: Not even pinned.
    //
    if (!_IsPinned(pitem))
    {
        return FALSE;
    }

    //
    //  See if it's an EXE.
    //

    BOOL fIsExe;

    LPTSTR pszFileName = _DisplayNameOf(psf, pidlItem, SHGDN_INFOLDER | SHGDN_FORPARSING);

    if (pszFileName)
    {
        LPCTSTR pszExt = PathFindExtension(pszFileName);
        fIsExe = StrCmpICW(pszExt, TEXT(".exe")) == 0;
        SHFree(pszFileName);
    }
    else
    {
        fIsExe = FALSE;
    }

    return fIsExe;
}

HRESULT ByUsage::ContextMenuRenameItem(PaneItem *p, LPCTSTR ptszNewName)
{
    ByUsageItem *pitem = static_cast<ByUsageItem *>(p);

    IShellFolder *psf;
    LPCITEMIDLIST pidlItem;
    HRESULT hr;

    hr = GetFolderAndPidl(pitem, &psf, &pidlItem);
    if (SUCCEEDED(hr))
    {
        if (_IsPinnedExe(pitem, psf, pidlItem))
        {
            // Renaming a pinned exe consists merely of changing the
            // display name inside the pidl.
            //
            // Note!  SetAltName frees the pidl on failure.

            LPITEMIDLIST pidlNew;
            if ((pidlNew = ILClone(pitem->RelativePidl())) &&
                (pidlNew = ByUsageHiddenData::SetAltName(pidlNew, ptszNewName)))
            {
                hr = _psmpin->Modify(pitem->RelativePidl(), pidlNew);
                if (SUCCEEDED(hr))
                {
                    pitem->SetRelativePidl(pidlNew);
                }
                else
                {
                    ILFree(pidlNew);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            LPITEMIDLIST pidlNew;
            hr = psf->SetNameOf(_hwnd, pidlItem, ptszNewName, SHGDN_INFOLDER, &pidlNew);

            //
            //  Warning!  SetNameOf can set pidlNew == NULL if the rename
            //  was handled by some means outside of the pidl (so the pidl
            //  is unchanged).  This means that the rename succeeded and
            //  we can keep using the old pidl.
            //

            if (SUCCEEDED(hr) && pidlNew)
            {
                //
                // The old Start Menu renames the UEM data when we rename
                // the shortcut, but we cannot guarantee that the old
                // Start Menu is around, so we do it ourselves.  Fortunately,
                // the old Start Menu does not attempt to move the data if
                // the hit count is zero, so if it gets moved twice, the
                // second person who does the move sees cHit=0 and skips
                // the operation.
                //
                UEMINFO uei;
                _GetUEMPidlInfo(psf, pidlItem, &uei);
                if (uei.cHit > 0)
                {
                    _SetUEMPidlInfo(psf, pidlNew, &uei);
                    uei.cHit = 0;
                    _SetUEMPidlInfo(psf, pidlItem, &uei);
                }

                //
                // Update the pitem with the new pidl.
                //
                if (_IsPinned(pitem))
                {
                    LPITEMIDLIST pidlDad = ILCloneParent(pitem->RelativePidl());
                    if (pidlDad)
                    {
                        LPITEMIDLIST pidlFullNew = ILCombine(pidlDad, pidlNew);
                        if (pidlFullNew)
                        {
                            _psmpin->Modify(pitem->RelativePidl(), pidlFullNew);
                            pitem->SetRelativePidl(pidlFullNew);    // takes ownership
                        }
                        ILFree(pidlDad);
                    }
                    ILFree(pidlNew);
                }
                else
                {
                    ASSERT(pidlItem == pitem->RelativePidl());
                    pitem->SetRelativePidl(pidlNew);
                }
            }
        }
        psf->Release();
    }

    return hr;
}


//
//  If asking for the display (not for parsing) name of a pinned EXE,
//  we need to return the "secret display name".  Otherwise, we can
//  use the default implementation.
//
LPTSTR ByUsage::DisplayNameOfItem(PaneItem *p, IShellFolder *psf, LPCITEMIDLIST pidlItem, SHGNO shgno)
{
    ByUsageItem *pitem = static_cast<ByUsageItem *>(p);

    LPTSTR pszName = NULL;

    // Only display (not for-parsing) names of EXEs need to be hooked.
    if (!(shgno & SHGDN_FORPARSING) && _IsPinnedExe(pitem, psf, pidlItem))
    {
        //
        //  EXEs get their name from the hidden data.
        //
        pszName = ByUsageHiddenData::GetAltName(pidlItem);
    }

    return pszName ? pszName
                   : _pByUsageUI->SFTBarHost::DisplayNameOfItem(p, psf, pidlItem, shgno);
}

//
//  "Internet" and "Email" get subtitles consisting of the friendly app name.
//
LPTSTR ByUsage::SubtitleOfItem(PaneItem *p, IShellFolder *psf, LPCITEMIDLIST pidlItem)
{
    ASSERT(p->HasSubtitle());

    LPTSTR pszName = NULL;

    IAssociationElement *pae = GetAssociationElementFromSpecialPidl(psf, pidlItem);
    if (pae)
    {
        // We detect error by looking at pszName
        pae->QueryString(AQS_FRIENDLYTYPENAME, NULL, &pszName);
        pae->Release();
    }

    return pszName ? pszName
                   : _pByUsageUI->SFTBarHost::SubtitleOfItem(p, psf, pidlItem);
}

HRESULT ByUsage::MovePinnedItem(PaneItem *p, int iInsert)
{
    ByUsageItem *pitem = static_cast<ByUsageItem *>(p);
    ASSERT(_IsPinned(pitem));

    return _psmpin->Modify(pitem->RelativePidl(), SMPIN_POS(iInsert));
}

//
//  For drag-drop purposes, we let you drop anything, not just EXEs.
//  We just reject slow media.
//
BOOL ByUsage::IsInsertable(IDataObject *pdto)
{
    return _psmpin->IsPinnable(pdto, SMPINNABLE_REJECTSLOWMEDIA, NULL) == S_OK;
}

HRESULT ByUsage::InsertPinnedItem(IDataObject *pdto, int iInsert)
{
    HRESULT hr = E_FAIL;

    LPITEMIDLIST pidlItem;
    if (_psmpin->IsPinnable(pdto, SMPINNABLE_REJECTSLOWMEDIA, &pidlItem) == S_OK)
    {
        if (SUCCEEDED(hr = _psmpin->Modify(NULL, pidlItem)) &&
            SUCCEEDED(hr = _psmpin->Modify(pidlItem, SMPIN_POS(iInsert))))
        {
            // Woo-hoo!
        }
        ILFree(pidlItem);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\proglist.h ===
//
//  Plug-in for the "Program Files" pane.  In principle you could do other
//  trees with this plug-in, but it's really tailored to the special way
//  we do Program Files.
//
//  Only shortcuts count, and the shortcuts are sorted by frequency of use.
//

#include "sfthost.h"

//****************************************************************************
//
//  Helper classes

class ByUsageItem;                          // "item", "pitem"
class ByUsageShortcut;                      // "scut", "pscut"
class ByUsageDir;                           // "dir", "pdir"
class ByUsageAppInfo;                       // "app", "papp"
class ByUsageHiddenData;                    // "hd", "phd"

// fwd declares
class ByUsageUI;
class ByUsageDUI;

typedef CDPA<ByUsageShortcut> ByUsageShortcutList;  // "sl", "psl"
typedef CDPA<UNALIGNED ITEMIDLIST> CDPAPidl;// save typing
typedef CDPA<ByUsageAppInfo>  ByUsageAppInfoList;

// Helper routines
BOOL LocalFreeCallback(LPTSTR psz, LPVOID);
BOOL ILFreeCallback(LPITEMIDLIST pidl, LPVOID);
void AppendString(CDPA<TCHAR> dpa, LPCTSTR psz);

class ByUsageRoot {                         // "rt", "prt"
public:
    ByUsageShortcutList _sl;                // The list of shortcuts
    ByUsageShortcutList _slOld;             // The previous list (used when merging)
    LPITEMIDLIST    _pidl;                  // Where we started enumerating
    BOOL            _fNeedRefresh;          // Does the list need to be refreshed?
    BOOL            _fRegistered;           // Has this directory been registered for ShellChangeNotifies?

    // these next fields are used during re-enumeration
    int             _iOld;                  // First unprocessed item in _slOld
    int             _cOld;                  // Number of elements in _slOld

    // NOTE!  Cannot use destructor here because we need to destroy them
    // in a specific order.  See ~ByUsage().
    void Reset();

    void SetNeedRefresh() { _fNeedRefresh = TRUE; }
    void ClearNeedRefresh() { _fNeedRefresh = FALSE; }
    BOOL NeedsRefresh() const { return _fNeedRefresh; }
    
    void SetRegistered() { _fRegistered = TRUE; }
    void ClearRegistered() { _fRegistered = FALSE; }
    BOOL NeedsRegister() const { return !_fRegistered; }
};



class CMenuItemsCache {
public:
    CMenuItemsCache();
    LONG AddRef();
    LONG Release();

    HRESULT Initialize(ByUsageUI *pbuUI, FILETIME *ftOSInstall);
    HRESULT AttachUI(ByUsageUI *pbuUI);
    BOOL InitCache();
    HRESULT UpdateCache();

    BOOL IsCacheUpToDate() { return _fIsCacheUpToDate; }

    HRESULT GetFileCreationTimes();
    void DelayGetFileCreationTimes() { _fCheckNew = FALSE; }
    void DelayGetDarwinInfo() { _fCheckDarwin = FALSE; }
    void AllowGetDarwinInfo() { _fCheckDarwin = TRUE; }

    void Lock()
    {
        EnterCriticalSection(&_csInUse);
    }
    void Unlock()
    {
        LeaveCriticalSection(&_csInUse);
    }
    BOOL IsLocked()
    {
        return _csInUse.OwningThread == UlongToHandle(GetCurrentThreadId());
    }

    // Use a separate (heavyweight) sync object for deferral.
    // Keep Lock/Unlock light since we use it a lot.  Deferral is
    // comparatively rare.  Note that we process incoming SendMessage
    // while waiting for the popup lock.  This prevents deadlocks.
    void LockPopup()
    {
        ASSERT(!IsLocked()); // enforce mutex hierarchy;
        SHWaitForSendMessageThread(_hPopupReady, INFINITE);
    }
    void UnlockPopup()
    {
        ReleaseMutex(_hPopupReady);
    }

    void OnChangeNotify(UINT id, LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    void UnregisterNotifyAll();

    ByUsageAppInfoList *GetAppList() { return &_dpaAppInfo ; }
    ByUsageAppInfo *GetAppInfo(LPTSTR pszAppPath, bool fIgnoreTimestamp);
    ByUsageAppInfo *GetAppInfoFromHiddenData(ByUsageHiddenData *phd);
    ByUsageAppInfo *GetAppInfoFromSpecialPidl(LPCITEMIDLIST pidl);


    void StartEnum();
    void EndEnum();
    ByUsageShortcut *GetNextShortcut();

    static DWORD WINAPI ReInitCacheThreadProc(void *pv);
    static HRESULT ReCreateMenuItemsCache(ByUsageUI *pbuUI, FILETIME *ftOSInstall, CMenuItemsCache **ppMenuCache);
    void RefreshDarwinShortcuts(ByUsageRoot *prt);
    void RefreshCachedDarwinShortcuts();

    ByUsageShortcut *CreateShortcutFromHiddenData(ByUsageDir *pdir, LPCITEMIDLIST pidl, ByUsageHiddenData *phd, BOOL fForce = FALSE);

    //
    //  Called from helper objects.
    //

    //
    //  An app is newly created if...
    //
    //  It was created less than a week ago (_ftOldApps), and
    //  It was created after the OS was installed.
    //
    bool IsNewlyCreated(const FILETIME *pftCreated) const
    {
        return CompareFileTime(pftCreated, &_ftOldApps) >= 0;
    }

    enum { MAXNOTIFY = 6 }; // Number of ChangeNotify slots we use in the cache

protected:
    ~CMenuItemsCache();

    LONG        _cref;
    ByUsageUI * _pByUsageUI;    // BEWARE: DO NOT use this member outside of a LockPopup/UnlockPopup pair.

    mutable CRITICAL_SECTION    _csInUse;

    FILETIME                _ftOldApps;  // apps older than this are not new

    // Flags that control enumeration
    enum ENUMFL {
        ENUMFL_RECURSE = 0,
        ENUMFL_NORECURSE = 1,

        ENUMFL_CHECKNEW = 0,
        ENUMFL_NOCHECKNEW = 2,

        ENUMFL_DONTCHECKIFCHILD = 0,
        ENUMFL_CHECKISCHILDOFPREVIOUS = 4,

        ENUMFL_ISNOTSTARTMENU = 0,
        ENUMFL_ISSTARTMENU  = 8,
    };

    UINT                    _enumfl;

    struct ROOTFOLDERINFO {
        int _csidl;
        UINT _enumfl;
    };

    enum { NUM_PROGLIST_ROOTS = 6 };

    typedef struct ENUMFOLDERINFO
    {
        CMenuItemsCache *self;
        ByUsageDir *pdir;
        ByUsageRoot *prt;
    } ENUMFOLDERINFO;

    void _SaveCache();

    BOOL _ShouldProcessRoot(int iRoot);

    void _FillFolderCache(ByUsageDir *pdir, ByUsageRoot *prt);
    void _MergeIntoFolderCache(ByUsageRoot *prt, ByUsageDir *pdir, CDPAPidl dpaFiles);
    ByUsageShortcut *_NextFromCacheInDir(ByUsageRoot *prt, ByUsageDir *pdir);
    ByUsageShortcut *_CreateFromCachedPidl(ByUsageRoot *prt, ByUsageDir *pdir, LPITEMIDLIST pidl);

    void _AddShortcutToCache(ByUsageDir *pdir, LPITEMIDLIST pidl, ByUsageShortcutList slFiles);
    void _TransferShortcutToCache(ByUsageRoot *prt, ByUsageShortcut *pscut);

    BOOL _GetExcludedDirectories();
    BOOL _IsExcludedDirectory(IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwAttributes);
    BOOL _IsInterestingDirectory(ByUsageDir *pdir);

    static void _InitStringList(HKEY hk, LPCTSTR pszValue, CDPA<TCHAR> dpa);
    void _InitKillList();
    bool _SetInterestingLink(ByUsageShortcut *pscut);
    BOOL _PathIsInterestingExe(LPCTSTR pszPath);
    BOOL _IsExcludedExe(LPCTSTR pszPath);

    HRESULT _UpdateMSIPath(ByUsageShortcut *pscut);

    inline static BOOL IsRestrictedCsidl(int csidl)
    {
        return (csidl == CSIDL_COMMON_PROGRAMS || csidl == CSIDL_COMMON_DESKTOPDIRECTORY || csidl == CSIDL_COMMON_STARTMENU) &&
                SHRestricted(REST_NOCOMMONGROUPS);
    }

    static FolderEnumCallback(LPITEMIDLIST pidlChild, ENUMFOLDERINFO *pinfo);

    ByUsageDir *            _pdirDesktop; // ByUsageDir for the desktop

    int                     _iCurrentRoot;  // For Enumeration
    int                     _iCurrentIndex;

    // The directories we care about.
    ByUsageRoot             _rgrt[NUM_PROGLIST_ROOTS];

    ByUsageAppInfoList      _dpaAppInfo; // apps we've seen so far

    IQueryAssociations *    _pqa;

    CDPA<TCHAR>             _dpaNotInteresting; // directories that yield shortcuts that we want to ignore
    CDPA<TCHAR>             _dpaKill;    // program names to ignore
    CDPA<TCHAR>             _dpaKillLink;// link names (substrings) to ignore

    BOOL                    _fIsCacheUpToDate;  // Do we need to walk the start menu dirs?
    BOOL                    _fIsInited;
    BOOL                    _fCheckNew;         // Do we want to extract creation time for apps?
    BOOL                    _fCheckDarwin;      // Do we want to fetch Darwin info?
    BOOL                    _fCSInited;         // Did we successfully initialize the critsec?

    HANDLE                  _hPopupReady;       // mutex handle - controls access to cache (re)initialization

    static const struct ROOTFOLDERINFO c_rgrfi[NUM_PROGLIST_ROOTS];
};


//****************************************************************************

class ByUsage
{
    friend class ByUsageUI;
    friend class ByUsageDUI;

public:        // Methods required by SFTBarHost
    ByUsage(ByUsageUI *pByUsageUI, ByUsageDUI *pByUsageDUI);
    virtual ~ByUsage();

    virtual HRESULT Initialize();
    virtual void EnumItems();
    virtual LPITEMIDLIST GetFullPidl(PaneItem *p);

    static int CompareUEMInfo(UEMINFO *puei1, UEMINFO *puei2);

    virtual int CompareItems(PaneItem *p1, PaneItem *p2);

    HRESULT GetFolderAndPidl(PaneItem *pitem, IShellFolder **ppsfOut, LPCITEMIDLIST *ppidlOut);
    int ReadIconSize();
    LRESULT OnWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT ContextMenuDeleteItem(PaneItem *pitem, IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici);
    HRESULT ContextMenuInvokeItem(PaneItem *pitem, IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici, LPCTSTR pszVerb);
    HRESULT ContextMenuRenameItem(PaneItem *pitem, LPCTSTR ptszNewName);
    LPTSTR DisplayNameOfItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlItem, SHGNO shgno);
    LPTSTR SubtitleOfItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlItem);
    HRESULT MovePinnedItem(PaneItem *pitem, int iInsert);
    void PrePopulate();

    CMenuItemsCache *GetMenuCache() { return _pMenuCache; }
    BOOL IsInsertable(IDataObject *pdto);
    HRESULT InsertPinnedItem(IDataObject *pdto, int iInsert);
    void OnChangeNotify(UINT id, LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    void OnPinListChange();

private:
    // Private messages start at WM_APP
    enum {
        BUM_SETNEWITEMS = WM_APP,
    };

    enum {
        //  We use the first slot not used by the menu items cache.
        NOTIFY_PINCHANGE = CMenuItemsCache::MAXNOTIFY,
    };


    inline BOOL _IsPinned(ByUsageItem *pitem);
    BOOL _IsPinnedExe(ByUsageItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlItem);
    HRESULT _GetShortcutExeTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPTSTR pszPath, UINT cchPath);

    void _FillPinnedItemsCache();
    void _EnumPinnedItemsFromCache();
    void _NotifyDesiredSize();

    void EnumFolderFromCache();
    void AfterEnumItems();

    typedef struct AFTERENUMINFO {
        ByUsage *self;
        CDPAPidl dpaNew;
    } AFTERENUMINFO;
    static BOOL CALLBACK _AfterEnumCB(ByUsageAppInfo *papp, AFTERENUMINFO *paei);


    static int UEMNotifyCB(void *param, const GUID *pguidGrp, int eCmd);

    BOOL _GetExcludedDirectories();
    bool _IsShortcutNew(ByUsageShortcut *pscut, ByUsageAppInfo *papp, const UEMINFO *puei);
    void _DestroyExcludedDirectories();
    LRESULT _ModifySMInfo(PSMNMMODIFYSMINFO pmsi);

    LRESULT _OnNotify(LPNMHDR pnm);
    LRESULT _OnSetNewItems(HDPA dpaNew);

    BOOL IsSpecialPinnedItem(ByUsageItem *pitem);
    BOOL IsSpecialPinnedPidl(LPCITEMIDLIST pidl);
public:
    //
    //  Executions within the grace period of app install are not counted
    //  against "new"ness.
    //
    static inline __int64 FT_NEWAPPGRACEPERIOD() { return FT_ONEHOUR; }

private:
    CDPAPidl _dpaNew;                    // the new guys

    IStartMenuPin *         _psmpin;     // to access the pin list
    LPITEMIDLIST            _pidlBrowser;  // Special pinned items with special names
    LPITEMIDLIST            _pidlEmail;     // ditto

    FILETIME                _ftStartTime;    /* The time when StartMenu was first invoked */
    FILETIME                _ftNewestApp;   // The time of the newest app

    ByUsageRoot             _rtPinned;

    ULONG                   _ulPinChange; // detect if the pinlinst changed

    ByUsageDir *            _pdirDesktop; // ByUsageDir for the desktop

    ByUsageUI  *            _pByUsageUI;
    HWND                    _hwnd;

    ByUsageDUI  *           _pByUsageDUI;

    CMenuItemsCache *       _pMenuCache;

    BOOL                    _fUEMRegistered;
    int                     _cMFUDesired;
};

class ByUsageUI : public SFTBarHost
{
    friend class ByUsage;
    friend class CMenuItemsCache;
public:
    friend SFTBarHost *ByUsage_CreateInstance();

private:        // Methods required by SFTBarHost
    HRESULT Initialize() { return _byUsage.Initialize(); }
    void EnumItems() { _byUsage.EnumItems(); }
    int CompareItems(PaneItem *p1, PaneItem *p2) { return _byUsage.CompareItems(p1, p2); }
    HRESULT GetFolderAndPidl(PaneItem *pitem, IShellFolder **ppsfOut, LPCITEMIDLIST *ppidlOut)
    {
        return _byUsage.GetFolderAndPidl(pitem, ppsfOut, ppidlOut);
    }
    void OnChangeNotify(UINT id, LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
    {
        _byUsage.OnChangeNotify(id, lEvent, pidl1, pidl2);
    }
    int ReadIconSize() { return _byUsage.ReadIconSize(); }
    LRESULT OnWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) { return _byUsage.OnWndProc(hwnd, uMsg, wParam, lParam); }
    HRESULT ContextMenuInvokeItem(PaneItem *pitem, IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici, LPCTSTR pszVerb) { return _byUsage.ContextMenuInvokeItem(pitem, pcm, pici, pszVerb); }
    HRESULT ContextMenuRenameItem(PaneItem *pitem, LPCTSTR ptszNewName) { return _byUsage.ContextMenuRenameItem(pitem, ptszNewName); }
    LPTSTR DisplayNameOfItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlItem, SHGNO shgno) { return _byUsage.DisplayNameOfItem(pitem, psf, pidlItem, shgno); }
    LPTSTR SubtitleOfItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlItem) { return _byUsage.SubtitleOfItem(pitem, psf, pidlItem); }
    HRESULT MovePinnedItem(PaneItem *pitem, int iInsert) { return _byUsage.MovePinnedItem(pitem, iInsert); }
    void PrePopulate() { _byUsage.PrePopulate(); }
    BOOL IsInsertable(IDataObject *pdto) { return _byUsage.IsInsertable(pdto); }
    HRESULT InsertPinnedItem(IDataObject *pdto, int iInsert) { return _byUsage.InsertPinnedItem(pdto, iInsert); }
    UINT AdjustDeleteMenuItem(PaneItem *pitem, UINT *puiFlags) { return IDS_SFTHOST_REMOVEFROMLIST; }

    BOOL NeedBackgroundEnum() { return TRUE; }
    BOOL HasDynamicContent() { return TRUE; }

    void RefreshNow() { PostMessage(_hwnd, SFTBM_REFRESH, FALSE, 0); }

private:
    ByUsageUI();
private:
    ByUsage                 _byUsage;

};

class ByUsageDUI
{
public:
    /*
     * Add a PaneItem to the list - if add fails, item will be delete'd.
     *
     * CLEANUP psf must be NULL; pidl must be the absolute pidl to the item
     * being added.  Leftover from dead HOSTF_PINITEMSBYFOLDER feature.
     * Needs to be cleaned up.
     *
     * Passing psf and pidlChild are for perf.
     */
    virtual BOOL AddItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlChild) PURE;
    /*
     * Hooking into change notifications
     */
    virtual BOOL RegisterNotify(UINT id, LONG lEvents, LPITEMIDLIST pidl, BOOL fRecursive) PURE;
    virtual BOOL UnregisterNotify(UINT id) PURE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\resource.h ===
#ifndef DESKTOP2_RESOURCE_H
#define DESKTOP2_RESOURCE_H

#define IDS_CUSTOMTIP_MYDOCS    300
#define IDS_CUSTOMTIP_RECENT    301
#define IDS_CUSTOMTIP_MYMUSIC   302
#define IDS_CUSTOMTIP_MYPICS    303
#define IDS_CUSTOMTIP_MYCOMP    304
#define IDS_CUSTOMTIP_MYNETPLACES 305
#define IDS_CUSTOMTIP_CONNECTTO 306
#define IDS_CUSTOMTIP_CTRLPANEL 307

#define ID_CMD_CHANGE_PICTURE   42

#define MENU_CONNECTTO             6000
#define IDM_OPENCONFOLDER          1

// reserved ids for Start Pane infotip strings - 7000 to 7999
// reserved ids for Start Pane infotip strings - 7000 to 7999

#define IDS_STARTPANE_INFOTIP_SEARCH    7000
#define IDS_STARTPANE_INFOTIP_HELP      7001
#define IDS_STARTPANE_INFOTIP_WINSECURITY 7002
#define IDS_STARTPANE_INFOTIP_FILERUN   7003
#define IDS_STARTPANE_INFOTIP_CLIENTINET 7004
#define IDS_STARTPANE_INFOTIP_CLIENTMAIL 7005

#define IDS_STARTPANE_TITLE_SEARCH      7020
#define IDS_STARTPANE_TITLE_HELP        7021
#define IDS_STARTPANE_TITLE_WINSECURITY 7022
#define IDS_STARTPANE_TITLE_FILERUN     7023
#define IDS_STARTPANE_TITLE_CLIENTINET  7024
#define IDS_STARTPANE_TITLE_CLIENTMAIL  7025

#define IDS_SFTHOST_OFFERREMOVEITEM     0x2020
#define IDS_SFTHOST_REMOVEFROMLIST      0x2021
#define IDS_STARTPANE_MOREPROGRAMS      0x2022
#define IDS_STARTPANE_MOREPROGRAMS_TIP  0x2023
#define IDS_CONNECTTO_OPENFOLDER        0x2024
#define IDS_STARTPANE_MOREPROGRAMS_BALLOONTITLE 0x2025
#define IDS_STARTPANE_SPECIALITEMSTIP   0x2026
#define IDS_STARTPANE_CLIPPED_TITLE     0x2027
#define IDS_STARTPANE_CLIPPED_TEXT      0x2028
#define IDS_STARTPANE_CONNECTTO         0x2029
#define IDS_STARTPANE_CONTROLPANEL      0x202A
#define IDS_STARTPANE_FAVORITES         0x202B
#define IDS_STARTPANE_RECENT            0x202C

#define IDS_STARTPANE_TOTALHEIGHT       0x2040
#define IDS_STARTPANE_TOTALWIDTH        0x2041
#define IDS_STARTPANE_USERHEIGHT        0x2042
#define IDS_STARTPANE_MOREPROGHEIGHT    0x2043
#define IDS_STARTPANE_LOGOFFHEIGHT      0x2044

#define IDS_SFTHOST_SHOWONDESKTOP       0x2050

#define IDB_LOGOFF_NORMAL 7010
#define IDB_LOGOFF_HOT    7011
#define IDS_LOGOFF_TEXT_FRIENDLY   7012
#define IDS_LOGOFF_TEXT_DOMAIN     7013
#define IDS_LOGOFF_TIP_EJECT       7014
#define IDS_LOGOFF_TIP_LOGOFF      7015
#define IDS_LOGOFF_TIP_SHUTDOWN    7016
#define IDS_LOGOFF_TIP_DISCONNECT  7017

#endif   // DESKTOP2_RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\specfldr.h ===
//
//  Plug-in to enumerate a list of folders from a registry key
//
//
//  Property bag:
//
//      "Target"    - name of registry key to enumerate
//

#include "sfthost.h"

class SpecialFolderList : public SFTBarHost
{
public:

    friend SFTBarHost *SpecList_CreateInstance()
        { return new SpecialFolderList(); }

    SpecialFolderList() : SFTBarHost(HOSTF_CANRENAME | HOSTF_REVALIDATE |
                                     HOSTF_RELOADTEXT |
                                     HOSTF_CASCADEMENU)
        {
            _iThemePart = SPP_PLACESLIST;
            _iThemePartSep = SPP_PLACESLISTSEPARATOR;
        }

private:
    ~SpecialFolderList();
    HRESULT Initialize();
    void EnumItems();
    int CompareItems(PaneItem *p1, PaneItem *p2);
    HRESULT GetFolderAndPidl(PaneItem *pitem, IShellFolder **ppsfOut, LPCITEMIDLIST *ppidlOut);
    HRESULT ContextMenuRenameItem(PaneItem *p, LPCTSTR ptszNewName);
    BOOL IsItemStillValid(PaneItem *p);
    HRESULT GetCascadeMenu(PaneItem *pitem, IShellMenu **ppsm);
    int ReadIconSize() { return ICONSIZE_MEDIUM; }
    BOOL NeedBackgroundEnum() { return TRUE; }
    int AddImageForItem(PaneItem *p, IShellFolder *psf, LPCITEMIDLIST pidl, int iPos);
    LPTSTR DisplayNameOfItem(PaneItem *p, IShellFolder *psf, LPCITEMIDLIST pidlItem, SHGNO shgno);
    TCHAR GetItemAccelerator(PaneItem *pitem, int iItemStart);
    void OnChangeNotify(UINT id, LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    BOOL IsBold(PaneItem *pitem);
    void GetItemInfoTip(PaneItem *pitem, LPTSTR pszText, DWORD cch);
    void UpdateImage(int iImage) { }
    HRESULT ContextMenuInvokeItem(PaneItem *p, IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici, LPCTSTR pszVerb);
    UINT AdjustDeleteMenuItem(PaneItem *pitem, UINT *puiFlags);
    LRESULT OnWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT _GetUIObjectOfItem(PaneItem *p, REFIID riid, LPVOID *ppv);


private:
    static DWORD WINAPI _HasEnoughChildrenThreadProc(LPVOID pvData);

    UINT    _cNotify;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\sfthost.h ===
//
//  Win32 window that hosts a pane on the desktop.
//
//  You are expected to derive from this class and implement the virtual
//  methods.
//
#ifndef __SFTHOST_H__
#define __SFTHOST_H__

#include "uemapp.h"
#include "runtask.h"
#include "hostutil.h"
#include "dobjutil.h"

//****************************************************************************
//
//  Miscellaneous helper functions
//

STDAPI_(HFONT) LoadControlFont(HTHEME hTheme, int iPart, BOOL fUnderline, DWORD dwSizePercentage);

STDAPI_(HRESULT)
    IDataObject_DragQueryFile(IDataObject *pdto, UINT iFile, LPTSTR pszBuf, UINT cch, UINT *puFiles);

STDAPI_(LPITEMIDLIST)
    ConvertToLogIL(LPITEMIDLIST pidl);

LRESULT _SendNotify(HWND hwndFrom, UINT code, OPTIONAL NMHDR *pnm = NULL);

BOOL GetFileCreationTime(LPCTSTR pszFile, LPFILETIME pftCreate);

/* Simple wrapper - the string needs to be freed with SHFree */
LPTSTR _DisplayNameOf(IShellFolder *psf, LPCITEMIDLIST pidl, UINT shgno);

HICON _IconOf(IShellFolder *psf, LPCITEMIDLIST pidl, int cxIcon);

BOOL ShowInfoTip();

//****************************************************************************

//  The base class uses the following properties in the initializing
//  property bag:
//
//
//      "type"      - type of host to use (see HOSTTYPE array)
//      "asyncEnum" - 1 = enumerate in background; 0 = foreground
//      "iconSize"  - 0 = small, 1 = large
//      "horizontal" - 0 = vertical (default), n = horizontal
//                    n = number of items to show

class PaneItem;

class PaneItem
{
public:
    PaneItem() : _iPos(-1), _iPinPos(PINPOS_UNPINNED) {}
    virtual ~PaneItem() { SHFree(_pszAccelerator); }
    static int CALLBACK DPAEnumCallback(PaneItem *self, LPVOID pData)
        { delete self; return TRUE; }

    BOOL IsPinned() const { return _iPinPos >= 0; }
    BOOL IsSeparator() const { return _iPinPos == PINPOS_SEPARATOR; }
    BOOL GetPinPos() const { return _iPinPos; }
    BOOL IsCascade() const { return _dwFlags & ITEMFLAG_CASCADE; }
    void EnableCascade() { _dwFlags |= ITEMFLAG_CASCADE; }
    BOOL HasSubtitle() const { return _dwFlags & ITEMFLAG_SUBTITLE; }
    void EnableSubtitle() { _dwFlags |= ITEMFLAG_SUBTITLE; }
    BOOL IsDropTarget() const { return _dwFlags & ITEMFLAG_DROPTARGET; }
    void EnableDropTarget() { _dwFlags |= ITEMFLAG_DROPTARGET; }
    BOOL HasAccelerator() { return _pszAccelerator != NULL; }

    virtual BOOL IsEqual(PaneItem *pItem) const { return FALSE; }

    enum {
        PINPOS_UNPINNED = -1,
        PINPOS_SEPARATOR = -2,
    };

    enum {
        ITEMFLAG_CASCADE    = 0x0001,
        ITEMFLAG_SUBTITLE   = 0x0002,
        ITEMFLAG_DROPTARGET = 0x0004,
    };

private:
    friend class SFTBarHost;
    int             _iPos;          /* Position on screen (or garbage if not on screen) */
public:
    int             _iPinPos;       /* Pin position (or special PINPOS value) */
    DWORD           _dwFlags;       /* ITEMFLAG_* values */
    LPTSTR          _pszAccelerator;/* Text with ampersand (for keyboard accelerator) */
};

//
//  Note: Since this is a base class, we can't use ATL because the base
//  class's CreateInstance won't know how to construct the derived classes.
//
class SFTBarHost
    : public IDropTarget
    , public IDropSource
    , public CAccessible
{
public:
    static BOOL Register();
    static BOOL Unregister();

// Would normally be "protected" except that proglist.cpp actually implements
// in a separate class and forwards.
public:
    /*
     *  Classes which derive from this class are expected to implement
     *  the following methods.
     */

    /* Constructor with return code */
    virtual HRESULT Initialize() PURE;

    /* Destructor */
    virtual ~SFTBarHost();

    /* Enumerate the objects and call AddItem for each one you find */
    // TODO: Maybe the EnumItems should be moved to a background thread
    virtual void EnumItems() PURE;

    virtual BOOL NeedBackgroundEnum() { return FALSE; }
    virtual BOOL HasDynamicContent() { return FALSE; }

    /* Compare two objects, tell me which one should come first */
    virtual int CompareItems(PaneItem *p1, PaneItem *p2) PURE;

    /*
     * Given a PaneItem, produce the pidl and IShellFolder associated with it.
     * The IShellFolder will be Release()d when no longer needed.
     */
    virtual HRESULT GetFolderAndPidl(PaneItem *pitem, IShellFolder **ppsfOut, LPCITEMIDLIST *ppidlOut) PURE;

    // An over-ridable method to add an image to our private imagelist for an item (virtual but not pure)
    virtual int AddImageForItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidl, int iPos);

    /*
     *  Dispatch a shell notification.  Default handler ignores.
     */
    virtual void OnChangeNotify(UINT id, LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) { }

    /*
     *  Allows derived classes to control their own icon size.
     */
     enum ICONSIZE {
        ICONSIZE_SMALL,     // typically 16x16
        ICONSIZE_LARGE,     // typically 32x32
        ICONSIZE_MEDIUM,    // typically 24x24
    };

    virtual int ReadIconSize() PURE;


    /*
     *  Optional hook into window procedure.
     *
     *  Default behavior is just to call DefWindowProc.
     */
    virtual LRESULT OnWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    /*
     *  Required if AdjustDeleteMenuItem is customized.
     *  Invoked when a context menu command is invoked.
     *  Host must intercept the
     *  "delete" command.  Other commands can also be intercepted as
     *  necessary.
     */
    virtual HRESULT ContextMenuInvokeItem(PaneItem *pitem, IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici, LPCTSTR pszVerb);

    /*
     *  Required if HOSTF_CANRENAME is passed:  Invoked when an item
     *  is renamed.
     *
     *  Note: The client is allowed to change the pidl associated with an
     *  item during a rename.  (In fact, it's expected to!)  So callers
     *  which have called GetFolderAndPidl need to call it again after the
     *  rename to get the correct post-rename pidl.
     */
    virtual HRESULT ContextMenuRenameItem(PaneItem *pitem, LPCTSTR ptszNewName) { return E_NOTIMPL; }

    /*
     *  Optional hook for obtaining the display name of an item.
     *  The default implementation calls IShellFolder::GetDisplayNameOf.
     *  If hooked, the returned string should be allocated by SHAlloc().
     */
    virtual LPTSTR DisplayNameOfItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlItem, SHGNO shgno)
    {
        return _DisplayNameOf(psf, pidlItem, shgno);
    }

    /*
     *  Required if pinnned items are created.  Invoked when the user moves
     *  a pinned item.
     */
    virtual HRESULT MovePinnedItem(PaneItem *pitem, int iInsert) { return E_NOTIMPL; }

    /*
     *  Optional hook into the SMN_INITIALUPDATE notification.
     */
    virtual void PrePopulate() { }

    /*
     *  Optional handler that says whether an item is still valid.
     */
    virtual BOOL IsItemStillValid(PaneItem *pitem) { return TRUE; }

    /*
     *  Required if HOSTF_CASCADEMENU.  Invoked when user wants to view
     *  a cascaded menu.
     */
    virtual HRESULT GetCascadeMenu(PaneItem *pitem, IShellMenu **ppsm) { return E_FAIL; }

    /*
     *  Required if any items have subtitles.  Returns the subtitle of the item.
     */
    virtual LPTSTR SubtitleOfItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlItem) { return NULL; }

    /*
     *  Optionally over-ridable method to ge the infotip for an item.  Default does a GetFolderAndPidl/GetInfoTip.
     */
    virtual void GetItemInfoTip(PaneItem *pitem, LPTSTR pszText, DWORD cch);

    /*
     *  Specify whether the data object can be inserted into the pin list.
     *  (Default: No.)
     */
    virtual BOOL IsInsertable(IDataObject *pdto) { return FALSE; }

    /*
     *  If you say that something is insertable, they you may be asked to
     *  insert it.
     */
    virtual HRESULT InsertPinnedItem(IDataObject *pdto, int iInsert)
    {
        ASSERT(FALSE); // You must implement this if you implement IsInsertable
        return E_FAIL;
    }

    /*
     *  An over-ridable method to allow hooking into keyboard accelerators.
     */
    virtual TCHAR GetItemAccelerator(PaneItem *pitem, int iItemStart);

    /*
     *  Specify whether the item should be displayed as bold.
     *  Default is to boldface if pinned.
     */
    virtual BOOL IsBold(PaneItem *pitem) { return pitem->IsPinned(); }

    /*
     *  Notify the client that a system imagelist index has changed.
     *  Default is to re-extract icons for any matching listview items.
     */
    virtual void UpdateImage(int iImage);

    /*
     *  Optional method to allow clients to specify how "Delete"
     *  should be exposed (if at all).  Return 0 to disallow "Delete".
     *  Return the string ID of the string to show for the command.
     *  Set *puiFlags to any additional flags to pass to ModifyMenu.
     *  Default is to disallow delete.
     */
    virtual UINT AdjustDeleteMenuItem(PaneItem *pitem, UINT *puiFlags) { return 0; }

    /*
     *  Allow client to reject/over-ride the IContextMenu on a per-item basis
     */

    virtual HRESULT _GetUIObjectOfItem(PaneItem *pitem, REFIID riid, LPVOID *ppv);

protected:
    /*
     *  Classes which derive from this class may call the following
     *  helper methods.
     */

    /*
     * Add a PaneItem to the list - if add fails, item will be delete'd.
     *
     * CLEANUP psf must be NULL; pidl must be the absolute pidl to the item
     * being added.  Leftover from dead HOSTF_PINITEMSBYFOLDER feature.
     * Needs to be cleaned up.
     *
     * Passing psf and pidlChild are for perf.
     */
    BOOL AddItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlChild);

    /* 
     * Use AddImage when you already have a HICON that needs to go to the private image list.
     */
    int AddImage(HICON hIcon);

    /*
     * Hooking into change notifications
     */
    enum {
        SFTHOST_MAXCLIENTNOTIFY = 7,        // Clients get this many notifications
        SFTHOST_MAXHOSTNOTIFY = 1,          // We use this many ourselves
        SFTHOST_HOSTNOTIFY_UPDATEIMAGE = SFTHOST_MAXCLIENTNOTIFY,
        SFTHOST_MAXNOTIFY = SFTHOST_MAXCLIENTNOTIFY + SFTHOST_MAXHOSTNOTIFY,
    };

    BOOL RegisterNotify(UINT id, LONG lEvents, LPCITEMIDLIST pidl, BOOL fRecursive)
    {
        ASSERT(id < SFTHOST_MAXCLIENTNOTIFY);
        return _RegisterNotify(id, lEvents, pidl, fRecursive);
    }

    BOOL UnregisterNotify(UINT id);

    /*
     * Forcing a re-enumeration.
     */
    void Invalidate() { _fEnumValid = FALSE; }

    /*
     * Informing host of desired size.
     */
    void SetDesiredSize(int cPinned, int cNormal)
    {
        _cPinnedDesired = cPinned;
        _cNormalDesired = cNormal;
    }

    BOOL AreNonPinnedItemsDesired()
    {
        return _cNormalDesired;
    }

    void StartRefreshTimer() { SetTimer(_hwnd, IDT_REFRESH, 5000, NULL); }

    void ForceChange() { _fForceChange = TRUE; }
protected:
    /*
     *  The constructor must be marked "protected" so people can derive
     *  from us.
     */

    enum {
        HOSTF_FIREUEMEVENTS     = 0x00000001,
        HOSTF_CANDELETE         = 0x00000002,
        HOSTF_Unused            = 0x00000004, // recycle me!
        HOSTF_CANRENAME         = 0x00000008,
        HOSTF_REVALIDATE        = 0x00000010,
        HOSTF_RELOADTEXT        = 0x00000020, // requires HOSTF_REVALIDATE
        HOSTF_CASCADEMENU       = 0x00000040,
    };

    SFTBarHost(DWORD dwFlags = 0)
                : _dwFlags(dwFlags)
                , _lRef(1)
                , _iInsert(-1)
                , _clrBG(CLR_INVALID)
                , _iCascading(-1)
    {
    }
    
    enum {
        SFTBM_REPOPULATE = WM_USER,
        SFTBM_CHANGENOTIFY,
        SFTBM_REFRESH = SFTBM_CHANGENOTIFY + SFTHOST_MAXNOTIFY,
        SFTBM_CASCADE,
        SFTBM_ICONUPDATE,
    };

public:
    /*
     *  Interface stuff...
     */

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvOut);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // *** IDropTarget ***
    STDMETHODIMP DragEnter(IDataObject *pdto, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pdto, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** IDropSource ***
    STDMETHODIMP GiveFeedback(DWORD dwEffect);
    STDMETHODIMP QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState);

    // *** IAccessible overridden methods ***
    STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);
    STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut);
    STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction);
    STDMETHODIMP accDoDefaultAction(VARIANT varChild);

    // Helpers

    //
    //  It is pointless to move an object to a place adjacent to itself,
    //  because the end result is that nothing happens.
    //
    inline IsInsertMarkPointless(int iInsert)
    {
        return _fDragToSelf &&
               IsInRange(iInsert, _iPosDragOut, _iPosDragOut + 1);
    }

    void _PurgeDragDropData();
    HRESULT _DragEnter(IDataObject *pdto, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    HRESULT _TryInnerDropTarget(int iItem, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    void _ClearInnerDropTarget();
    void _SetDragOver(int iItem);

    // Insert mark stuff
    void _SetInsertMarkPosition(int iInsert);
    void _InvalidateInsertMark();
    BOOL _GetInsertMarkRect(LPRECT prc);
    BOOL _IsInsertionMarkActive() { return _iInsert >= 0; }
    void _DrawInsertionMark(LPNMLVCUSTOMDRAW plvcd);

    /*
     *  End of drag/drop stuff...
     */

private:
    /*
     *  Background enumeration stuff...
     */
    class CBGEnum : public CRunnableTask {
    public:
        CBGEnum(SFTBarHost *phost, BOOL fUrgent)
            : CRunnableTask(RTF_DEFAULT)
            , _fUrgent(fUrgent)
            , _phost(phost) { phost->AddRef(); }
        ~CBGEnum() 
        {
            // We should not be the last release or else we are going to deadlock here, when _phost
            // tries to release the scheduler
            ASSERT(_phost->_lRef > 1);
            _phost->Release(); 
        }
        STDMETHODIMP RunInitRT()
        {
            _phost->_EnumerateContentsBackground();
            if (_phost->_hwnd) PostMessage(_phost->_hwnd, SFTBM_REPOPULATE, _fUrgent, 0);
            return S_OK;
        }
    private:
        SFTBarHost *_phost;
        BOOL _fUrgent;
    };

    friend class SFTBarHost::CBGEnum;

private:
    /* Window procedure helpers */

    static LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT _OnNcCreate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnCreate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnNcDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LRESULT _OnNotify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnSize(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnContextMenu(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnCtlColorStatic(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnMenuMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnEraseBackground(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnTimer(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnSetFocus(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnSysColorChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnForwardMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnUpdateUIState(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LRESULT _OnRepopulate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnChangeNotify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnRefresh(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnCascade(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT _OnIconUpdate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LRESULT _OnLVCustomDraw(LPNMLVCUSTOMDRAW plvcd);
    LRESULT _OnLVNItemActivate(LPNMITEMACTIVATE pnmia);
    LRESULT _OnLVNGetInfoTip(LPNMLVGETINFOTIP plvn);
    LRESULT _OnLVNGetEmptyText(NMLVDISPINFO *plvdi);
    LRESULT _OnLVNBeginDrag(LPNMLISTVIEW plv);
    LRESULT _OnLVNBeginLabelEdit(NMLVDISPINFO *pldvi);
    LRESULT _OnLVNEndLabelEdit(NMLVDISPINFO *pldvi);
    LRESULT _OnLVNKeyDown(LPNMLVKEYDOWN pkd);
    LRESULT _OnSMNGetMinSize(PSMNGETMINSIZE pgms);
    LRESULT _OnSMNFindItem(PSMNDIALOGMESSAGE pdm);
    LRESULT _OnSMNFindItemWorker(PSMNDIALOGMESSAGE pdm);
    LRESULT _OnSMNDismiss();
    LRESULT _OnHover();

    /* Custom draw helpers */
    LRESULT _OnLVPrePaint(LPNMLVCUSTOMDRAW plvcd);
    LRESULT _OnLVItemPrePaint(LPNMLVCUSTOMDRAW plvcd);
    LRESULT _OnLVSubItemPrePaint(LPNMLVCUSTOMDRAW plvcd);
    LRESULT _OnLVItemPostPaint(LPNMLVCUSTOMDRAW plvcd);
    LRESULT _OnLVPostPaint(LPNMLVCUSTOMDRAW plvcd);

    /* Custom draw push/pop */
    void    _CustomDrawPush(BOOL fReal);
    BOOL    _IsRealCustomDraw();
    void    _CustomDrawPop();
    static LRESULT CALLBACK s_DropTargetSubclassProc(
                             HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                             UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

    /* Other helpers */
    void _SetMaxShow(int cx, int cy);
    void _EnumerateContents(BOOL fUrgent);
    void _EnumerateContentsBackground();
    void _RevalidateItems();
    void _RevalidatePostPopup();
    void _ReloadText();
    static int CALLBACK _SortItemsAfterEnum(PaneItem *p1, PaneItem *p2, SFTBarHost *self);
    void _RepopulateList();
    void _InternalRepopulateList();
    int _InsertListViewItem(int iPos, PaneItem *pitem);
    void _ComputeListViewItemPosition(int iItem, POINT *pptOut);
    int _AppendEnumPaneItem(PaneItem *pitem);
    void _RepositionItems();
    void _ComputeTileMetrics();
    void _SetTileWidth(int cxTile);
    BOOL _CreateMarlett();
    void _CreateBoldFont();
    int  _GetLVCurSel() {
            return ListView_GetNextItem(_hwndList, -1, LVNI_FOCUSED);
    }
    BOOL _OnCascade(int iItem, DWORD dwFlags);
    BOOL _IsPrivateImageList() const { return _iconsize == ICONSIZE_MEDIUM; }
    BOOL _CanHaveSubtitles() const { return _iconsize == ICONSIZE_LARGE; }
    int _ExtractImageForItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidl);
    void _ClearListView();
    void _EditLabel(int iItem);
    BOOL _RegisterNotify(UINT id, LONG lEvents, LPCITEMIDLIST pidl, BOOL fRecursive);
    void _OnUpdateImage(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);

    /* Returns E_FAIL for separators; otherwise calls client */
    HRESULT _GetFolderAndPidl(PaneItem *pitem, IShellFolder **ppsfOut, LPCITEMIDLIST *ppidlOut);

    /* Simple wrappers - the string needs to be freed with SHFree */
    LPTSTR _DisplayNameOfItem(PaneItem *pitem, UINT shgno);
    HRESULT _GetUIObjectOfItem(int iItem, REFIID riid, LPVOID *ppv);

    inline PaneItem *_GetItemFromLVLParam(LPARAM lParam)
        { return reinterpret_cast<PaneItem*>(lParam); }
    PaneItem *_GetItemFromLV(int iItem);

    enum {
        AIF_KEYBOARD = 1,
    };

    int _ContextMenuCoordsToItem(LPARAM lParam, POINT *pptOut);
    LRESULT _ActivateItem(int iItem, DWORD dwFlags); // AIF_* values
    HRESULT _InvokeDefaultCommand(int iItem, IShellFolder *psf, LPCITEMIDLIST pidl);
    void _OfferDeleteBrokenItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidl);

    // If you hover the mouse for this much time, we will open it if it
    // cascades.  This is the same value that USER uses for auto-cascading
    // menus.
    DWORD _GetCascadeHoverTime() { return GetDoubleClickTime() * 4 / 5; }

    static void CALLBACK SetIconAsync(LPCITEMIDLIST pidl, LPVOID pvData, LPVOID pvHint, INT iIconIndex, INT iOpenIconIndex);

    /*
     *  Custom commands we add to the context menu.
     */
    enum {
        IDM_REMOVEFROMLIST = 1,
        // Insert private menu items here

        // range used for client QueryContextMenu
        IDM_QCM_MIN   = 0x0100,
        IDM_QCM_MAX   = 0x7000,

    };

    /*
     *  Timer IDs
     */
    enum {
        IDT_ASYNCENUM  = 1,
        IDT_RELOADTEXT = 2,
        IDT_REFRESH    = 3,
    };

    /*
     *  Miscellaneous settings.
     */
    enum {
        MAX_SEPARATORS = 3,                 /* Maximum number of separators allowed */
    };

    /*
     *  Pinning helpers...
     */
    BOOL NeedSeparator() const { return _cPinned; }
    BOOL _HasSeparators() const { return _rgiSep[0] >= 0; }
    void _DrawSeparator(HDC hdc, int x, int y);
    void _DrawSeparators(LPNMLVCUSTOMDRAW plvcd);

    /*
     *  Bookkeeping.
     */
    int _PosToItemNo(int iPos);
    int _ItemNoToPos(int iItem);

    /*
     *  Accessibility helpers...
     */
    PaneItem *_GetItemFromAccessibility(const VARIANT& varChild);

    /*
     *  Debugging helpers...
     */
#if defined(DEBUG) && defined(FULL_DEBUG)
    void _DebugConsistencyCheck();
#else
    inline void _DebugConsistencyCheck() { }
#endif
    BOOL _AreChangesRestricted() 
    {
        return (IsRestrictedOrUserSetting(HKEY_CURRENT_USER, REST_NOCHANGESTARMENU, TEXT("Advanced"), TEXT("Start_EnableDragDrop"), ROUS_DEFAULTALLOW | ROUS_KEYALLOWS));
    }

protected:
    HTHEME                  _hTheme;        // theme handle, can be NULL
    int                     _iThemePart;    // SPP_PROGLIST SPP_PLACESLIST
    int                     _iThemePartSep; // theme part for the separator
    HWND                    _hwnd;          /* Our window handle */
    HIMAGELIST              _himl;          // Imagelist handle
    int                     _cxIcon;        /* Icon size for imagelist */
    int                     _cyIcon;        /* Icon size for imagelist */
    ICONSIZE                _iconsize;      /* ICONSIZE_* value */

private:
    HWND                    _hwndList;      /* Handle of inner listview */

    MARGINS                 _margins;       // margins for children (listview and oobe static) valid in theme and non-theme case

    int                     _cPinned;       /* Number of those items that are pinned */

    DWORD                   _dwFlags;       /* Misc flags that derived classes can set */

    //  _dpaEnum is the DPA of enumerated items, sorted in the
    //  _SortItemsAfterEnum sense, which prepares them for _RepopulateList.
    //  When _dpaEnum is destroyed, its pointers must be delete'd.
    CDPA<PaneItem>          _dpaEnum;
    CDPA<PaneItem>          _dpaEnumNew; // Used during background enumerations

    int                     _rgiSep[MAX_SEPARATORS];    /* Only _cSep elements are meaningful */
    int                     _cSep;          /* Number of separators */

    //
    //  Context menu handling
    //
    IContextMenu2 *         _pcm2Pop;       /* Currently popped-up context menu */
    IContextMenu3 *         _pcm3Pop;       /* Currently popped-up context menu */

    IDropTargetHelper *     _pdth;          /* For cool-looking drag/drop */
    IDragSourceHelper *     _pdsh;          /* For cool-looking drag/drop */
    IDataObject *           _pdtoDragOut;   /* Data object being dragged out */
    IDataObject *           _pdtoDragIn;    /* Data object being dragged in */
    IDropTarget *           _pdtDragOver;   /* Object being dragged over (if any) */

    IShellTaskScheduler *   _psched;        /* Task scheduler */

    int                     _iDragOut;      /* The item being dragged out (-1 if none) */
    int                     _iPosDragOut;   /* The position of item _iDragOut */
    int                     _iDragOver;     /* The item being dragged over (-1 if none) */
    DWORD                   _tmDragOver;    /* Time the dragover started (to see if we need to auto-open) */

    int                     _iInsert;       /* Where the insert mark should be drawn (-1 if none) */
    BOOL                    _fForceArrowCursor; /* Should we force a regular cursor during drag/drop? */
    BOOL                    _fDragToSelf;   /* Are we dragging an object to ourselves? */
    BOOL                    _fInsertable;   /* Is item being dragged pinnable? */
    DWORD                   _grfKeyStateLast; /* Last grfKeyState passed to DragOver */

    int                     _cyTile;        /* Height of a tile */
    int                     _cxTile;        /* Width of a tile */
    int                     _cyTilePadding; /* Extra vertical space between tiles */
    int                     _cySepTile;     /* Height of a separator tile */
    int                     _cySep;         /* Height of a separator line */

    int                     _cxMargin;      /* Left margin */
    int                     _cyMargin;      /* Top margin */
    int                     _cxIndent;      /* So bonus texts line up with listview text */
    COLORREF                _clrBG;         /* Color for background */
    COLORREF                _clrHot;        /* Color for hot text*/
    COLORREF                _clrSubtitle;   /* Color for subtitle text*/


    LONG                    _lRef;          /* Reference count */
    BOOL                    _fBGTask;       /* Is a background task already scheduled? */
    BOOL                    _fRestartEnum;  /* Should in-progress enumeration be restarted? */
    BOOL                    _fRestartUrgent;/* Is the _fRestartEnum urgent? */
    BOOL                    _fEnumValid;    /* Is the list of items all fine? */
    BOOL                    _fNeedsRepopulate; /* Do we need to call _RepopulateList ? */
    BOOL                    _fForceChange;  /* Should we act as if there was a change even if there didn't seem to be one? */
    ULONG                   _rguChangeNotify[SFTHOST_MAXNOTIFY];
                                            /* Outstanding change notification (if any) */

    BOOL                    _fAllowEditLabel; /* Is this an approved label-editing state? */

    HFONT                   _hfList;        /* Custom listview font (if required) */
    HFONT                   _hfBold;        /* Bold listview font (if required) */
    HFONT                   _hfMarlett;     /* Marlett font (if required) */
    int                     _cxMarlett;     /* Width of the menu cascade glyph */
    int                     _tmAscentMarlett; /* Font ascent for Marlett */

    HWND                    _hwndAni;       /* Handle of flashlight animation, if present */
    UINT                    _idtAni;        /* Animation timer handle */
    HBRUSH                  _hBrushAni;     /* Background brush for the Ani window */

    int                     _cPinnedDesired;/* SetDesiredSize */
    int                     _cNormalDesired;/* SetDesiredSize */

    int                     _iCascading;    /* Which item is the cascade menu appearing over? */
    DWORD                   _dwCustomDrawState; /* Keeps track of whether customdraw is real or fake */
    int                     _cPaint;        /* How many (nested) paint messages are we handling? */
#ifdef DEBUG
    BOOL                    _fEnumerating;  /* Are we enumerating client items? */
    BOOL                    _fPopulating;   /* Are we populating the listview? */
    BOOL                    _fListUnstable; /* The listview is unstable; don't get upset */

    //
    //  To verify that we manage the inner drop target correctly.
    //
    enum {
        DRAGSTATE_UNINITIALIZED = 0,
        DRAGSTATE_ENTERED = 1,
    };
    int                     _iDragState;    /* for debugging */

#endif

    /* Large structures go at the end */
};

_inline SMPANEDATA* PaneDataFromCreateStruct(LPARAM lParam)
{
    LPCREATESTRUCT lpcs = reinterpret_cast<LPCREATESTRUCT>(lParam);
    return reinterpret_cast<SMPANEDATA*>(lpcs->lpCreateParams);
}

//****************************************************************************
//
//  Helper functions for messing with UEM info
//

void _GetUEMInfo(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, UEMINFO *pueiOut);

#define _GetUEMPidlInfo(psf, pidl, pueiOut)                 \
        _GetUEMInfo(&UEMIID_SHELL, UEME_RUNPIDL,            \
                reinterpret_cast<WPARAM>(psf),              \
                reinterpret_cast<LPARAM>(pidl), pueiOut)

#define _GetUEMPathInfo(pszPath, pueiOut)                   \
    _GetUEMInfo(&UEMIID_SHELL, UEME_RUNPATH, (WPARAM)-1,    \
                reinterpret_cast<LPARAM>(pszPath), pueiOut)

#define _SetUEMPidlInfo(psf, pidl, pueiInOut)               \
        UEMSetEvent(&UEMIID_SHELL, UEME_RUNPIDL,            \
                reinterpret_cast<WPARAM>(psf),              \
                reinterpret_cast<LPARAM>(pidl), pueiInOut)

#define _SetUEMPathInfo(pszPath, pueiInOut)                 \
    UEMSetEvent(&UEMIID_SHELL, UEME_RUNPATH, (WPARAM)-1,    \
                reinterpret_cast<LPARAM>(pszPath), pueiInOut)

// SOMEDAY: Figure out what UEMF_XEVENT means.  I just stole the code
//          from startmnu.cpp.

#define _FireUEMPidlEvent(psf, pidl)                        \
    UEMFireEvent(&UEMIID_SHELL, UEME_RUNPIDL, UEMF_XEVENT,  \
                reinterpret_cast<WPARAM>(psf),              \
                reinterpret_cast<LPARAM>(pidl))


//****************************************************************************
//
//  Constructors for derived classes
//

typedef SFTBarHost *(CALLBACK *PFNHOSTCONSTRUCTOR)(void);

STDAPI_(SFTBarHost *) ByUsage_CreateInstance();
STDAPI_(SFTBarHost *) SpecList_CreateInstance();
STDAPI_(SFTBarHost *) RecentDocs_CreateInstance();

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

#endif // __SFTHOST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\specfldr.cpp ===
#include "stdafx.h"
#include "specfldr.h"
#include "hostutil.h"
#include "rcids.h"              // for IDM_PROGRAMS etc.
#include "ras.h"
#include "raserror.h"
#include "netcon.h"
#include "netconp.h"
#include <cowsite.h>

//
//  This definition is stolen from shell32\unicpp\dcomp.h
//
#define REGSTR_PATH_HIDDEN_DESKTOP_ICONS_STARTPANEL \
     REGSTR_PATH_EXPLORER TEXT("\\HideDesktopIcons\\NewStartPanel")

HRESULT CRecentShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc);
HRESULT CNoSubdirShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc);
HRESULT CMyComputerShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc);
HRESULT CNoFontsShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc);
HRESULT CConnectToShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc);
LPTSTR _Static_LoadString(const struct SpecialFolderDesc *pdesc);
BOOL ShouldShowWindowsSecurity();
BOOL ShouldShowOEMLink();

typedef HRESULT (CALLBACK *CREATESHELLMENUCALLBACK)(IShellMenuCallback **ppsmc);
typedef BOOL (CALLBACK *SHOULDSHOWFOLDERCALLBACK)();

EXTERN_C HINSTANCE hinstCabinet;

void ShowFolder(UINT csidl);
BOOL IsNetConPidlRAS(IShellFolder2 *psfNetCon, LPCITEMIDLIST pidlNetConItem);

//****************************************************************************
//
//  SpecialFolderDesc
//
//  Describes a special folder.
//

#define SFD_SEPARATOR       ((LPTSTR)-1)

// Flags for SpecialFolderDesc._uFlags

enum {
    // These values are collectively known as the
    // "display mode" and match the values set by regtreeop.

    SFD_HIDE     = 0x0000,
    SFD_SHOW     = 0x0001,
    SFD_CASCADE  = 0x0002,
    SFD_MODEMASK = 0x0003,

    SFD_DROPTARGET      = 0x0004,
    SFD_CANCASCADE      = 0x0008,
    SFD_FORCECASCADE    = 0x0010,
    SFD_BOLD            = 0x0020,
    SFD_WASSHOWN        = 0x0040,
    SFD_PREFIX          = 0x0080,
    SFD_USEBGTHREAD     = 0x0100,
};

struct SpecialFolderDesc {
    typedef BOOL (SpecialFolderDesc::*CUSTOMFOLDERNAMECALLBACK)(LPTSTR *ppsz) const;

    LPCTSTR _pszTarget;         // or MAKEINTRESOURCE(csidl)
    RESTRICTIONS _rest;         // optional restriction
    LPCTSTR _pszShow;           // REGSTR_EXPLORER_ADVANCED!_pszShow
    UINT _uFlags;               // SFD_* values
    CREATESHELLMENUCALLBACK _CreateShellMenuCallback; // Which IShellMenuCallback do we want?
    LPCTSTR _pszCustomizeKey;   // Optional location where customizations are saved
    DWORD _dwShellFolderFlags;  // Optional restrictions for cascading folder
    UINT _idsCustomName;        // Optional override (CUSTOMFOLDERNAMECALLBACK)
    UINT _iToolTip;             // Optional resource ID for a custom tooltip
    CUSTOMFOLDERNAMECALLBACK _CustomName; // Over-ride the filesys name
    SHOULDSHOWFOLDERCALLBACK _ShowFolder;
    LPCTSTR _pszCanHideOnDesktop; // Optional {guid} that controls desktop visibility

    DWORD GetDisplayMode(BOOL *pbIgnoreRule) const;

    void AdjustForSKU();

    void SetDefaultDisplayMode(UINT iNewMode)
    {
        _uFlags = (_uFlags & ~SFD_MODEMASK) | iNewMode;
    }

    BOOL IsDropTarget() const { return _uFlags & SFD_DROPTARGET; }
    BOOL IsCacheable() const { return _uFlags & SFD_USEBGTHREAD; }

    int IsCSIDL() const { return IS_INTRESOURCE(_pszTarget); }
    BOOL IsBold() const { return _uFlags & SFD_BOLD; }
    int IsSeparator() const { return _pszTarget == SFD_SEPARATOR; }

    int GetCSIDL() const {
        ASSERT(IsCSIDL());
        return (short)PtrToLong(_pszTarget);
    }

    HRESULT CreateShellMenuCallback(IShellMenuCallback **ppsmc) const {
        return _CreateShellMenuCallback ? _CreateShellMenuCallback(ppsmc) : S_OK;
    }

    BOOL GetCustomName(LPTSTR *ppsz) const {
        if (_CustomName)
            return (this->*_CustomName)(ppsz);
        else
            return FALSE;
    }

    LPWSTR GetShowCacheRegName() const;
    BOOL LoadStringAsOLESTR(LPTSTR *ppsz) const;
    BOOL ConnectToName(LPTSTR *ppsz) const;
};

static SpecialFolderDesc s_rgsfd[] = {

    /* My Documents */
    {
        MAKEINTRESOURCE(CSIDL_PERSONAL),    // pszTarget
        REST_NOSMMYDOCS,                    // restriction
        REGSTR_VAL_DV2_SHOWMYDOCS,
        SFD_SHOW | SFD_DROPTARGET | SFD_CANCASCADE | SFD_BOLD,
                                            // show by default, is drop target
        NULL,                               // no custom cascade 
        NULL,                               // no drag/drop customization
        0,                                  // no special flags for cascaded menu
        0,                                  // (no custom name)
        IDS_CUSTOMTIP_MYDOCS,
        NULL,                               // (no custom name)
        NULL,                               // (no custom display rule)
        TEXT("{450D8FBA-AD25-11D0-98A8-0800361B1103}"), // desktop visibility control
    },

    /* Recent */
    {
        MAKEINTRESOURCE(CSIDL_RECENT),      // pszTarget
        REST_NORECENTDOCSMENU,              // restriction
        REGSTR_VAL_DV2_SHOWRECDOCS,         // customize show
        SFD_HIDE | SFD_CANCASCADE | SFD_BOLD | SFD_PREFIX, // hide by default
        CRecentShellMenuCallback_CreateInstance, // custom callback
        NULL,                               // no drag/drop customization
        SMINIT_RESTRICT_DRAGDROP,           // disallow drag/drop in cascaded menu
        IDS_STARTPANE_RECENT,               // override filesys name
        IDS_CUSTOMTIP_RECENT,
        &SpecialFolderDesc::LoadStringAsOLESTR, // override filesys name with _idsCustomName
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* My Pictures */
    {
        MAKEINTRESOURCE(CSIDL_MYPICTURES),  // pszTarget
        REST_NOSMMYPICS,                    // restriction
        REGSTR_VAL_DV2_SHOWMYPICS,
        SFD_SHOW | SFD_DROPTARGET | SFD_CANCASCADE | SFD_BOLD,
                                            // show by default, is drop target
        NULL,                               // no custom cascade 
        NULL,                               // no drag/drop customization
        0,                                  // no special flags for cascaded menu
        0,                                  // (no custom name)
        IDS_CUSTOMTIP_MYPICS,
        NULL,                               // (no custom name)
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)

    },

    /* My Music */
    {
        MAKEINTRESOURCE(CSIDL_MYMUSIC),     // pszTarget
        REST_NOSMMYMUSIC,                   // restriction
        REGSTR_VAL_DV2_SHOWMYMUSIC,
        SFD_SHOW | SFD_DROPTARGET | SFD_CANCASCADE | SFD_BOLD,
                                            // show by default, is drop target
        NULL,                               // no custom cascade 
        NULL,                               // no drag/drop customization
        0,                                  // no special flags for cascaded menu
        0,                                  // (no custom name)
        IDS_CUSTOMTIP_MYMUSIC,
        NULL,                               // (no custom name)
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* Favorites */
    {
        MAKEINTRESOURCE(CSIDL_FAVORITES),   // pszTarget
        REST_NOFAVORITESMENU,               // restriction
        REGSTR_VAL_DV2_FAVORITES,           // customize show (shared w/classic)
        SFD_HIDE | SFD_DROPTARGET |
        SFD_CANCASCADE | SFD_FORCECASCADE | SFD_BOLD | SFD_PREFIX,
                                            // hide by default, is drop target
        NULL,                               // unrestricted cascading
        STRREG_FAVORITES,                   // drag/drop customization key
        0,                                  // no special flags for cascaded menu
        IDS_STARTPANE_FAVORITES,            // override filesys name
        0,                                  // no custom tip
        &SpecialFolderDesc::LoadStringAsOLESTR, // override filesys name with _idsCustomName
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* My Computer */
    {
        MAKEINTRESOURCE(CSIDL_DRIVES),      // pszTarget
        REST_NOMYCOMPUTERICON,              // restriction
        REGSTR_VAL_DV2_SHOWMC,              // customize show
        SFD_SHOW | SFD_CANCASCADE | SFD_BOLD, // show by default
        CMyComputerShellMenuCallback_CreateInstance, // custom callback
        NULL,                               // no drag/drop customization
        0,                                  // no special flags for cascaded menu
        0,                                  // (no custom name)
        IDS_CUSTOMTIP_MYCOMP,
        NULL,                               // (no custom name)
        NULL,                               // (no custom display rule)
        TEXT("{20D04FE0-3AEA-1069-A2D8-08002B30309D}"), // desktop visibility control
    },

    /* My Network Places */
    {
        MAKEINTRESOURCE(CSIDL_NETWORK),     // pszTarget
        REST_NOSMNETWORKPLACES,             // restriction
        REGSTR_VAL_DV2_SHOWNETPL,           // customize show
        SFD_SHOW | SFD_CANCASCADE | SFD_BOLD | SFD_USEBGTHREAD, // show by default
        CNoSubdirShellMenuCallback_CreateInstance, // only cascade one level
        NULL,                               // no drag/drop customization
        0,                                  // no special flags for cascaded menu
        0,                                  // (no custom name)
        IDS_CUSTOMTIP_MYNETPLACES,
        NULL,                               // (no custom name)
        ShouldShowNetPlaces,
        TEXT("{208D2C60-3AEA-1069-A2D7-08002B30309D}"), // desktop visibility control
    },

    /* Separator line */
    {
        SFD_SEPARATOR,                      // separator
        REST_NONE,                          // no restriction
        NULL,                               // no customize show
        SFD_SHOW,                           // show by default
        NULL,                               // (not cascadable)
        NULL,                               // (not cascadable)
        0,                                  // (not cascadable)
        0,                                  // (no custom name)
        0,                                  // no custom tip
        NULL,                               // (no custom name)
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* Control Panel */
    {
        MAKEINTRESOURCE(CSIDL_CONTROLS),    // pszTarget
        REST_NOCONTROLPANEL,                // restriction
        REGSTR_VAL_DV2_SHOWCPL,
        SFD_SHOW | SFD_CANCASCADE | SFD_PREFIX, // show by default
        CNoFontsShellMenuCallback_CreateInstance, // custom callback
        NULL,                               // no drag/drop customization
        0,                                  // no special flags for cascaded menu
        IDS_STARTPANE_CONTROLPANEL,         // override filesys name
        IDS_CUSTOMTIP_CTRLPANEL,            // no custom tip
        &SpecialFolderDesc::LoadStringAsOLESTR, // override filesys name with _idsCustomName
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* Admin Tools */
    {
        // Using the ::{guid} gets the icon right
        TEXT("shell:::{D20EA4E1-3957-11d2-A40B-0C5020524153}"), // pszTarget
        REST_NONE,                          // no restriction
        REGSTR_VAL_DV2_ADMINTOOLSROOT,
        SFD_HIDE | SFD_CANCASCADE | SFD_FORCECASCADE,        // hide by default, force to cascade
        NULL,                               // no custom callback
        NULL,                               // no drag/drop customization
        0,                                  // no special flags for cascaded menu
        NULL,                               // no custom name
        NULL,                               // no custom tip
        NULL,                               // no custom name
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* Network Connections */
    {
        MAKEINTRESOURCE(CSIDL_CONNECTIONS), // pszTarget
        REST_NONETWORKCONNECTIONS,          // restriction
        REGSTR_VAL_DV2_SHOWNETCONN,         // customize show
        SFD_CASCADE | SFD_CANCASCADE | SFD_PREFIX | SFD_USEBGTHREAD, // cascade by default
        CConnectToShellMenuCallback_CreateInstance, // do special Connect To filtering
        NULL,                               // no drag/drop customization
        0,                                  // no special flags for cascaded menu
        IDS_STARTPANE_CONNECTTO,            // override filesys name
        IDS_CUSTOMTIP_CONNECTTO,
        &SpecialFolderDesc::ConnectToName,  // override filesys name with _idsCustomName
        ShouldShowConnectTo,                // see if we should be shown
        NULL,                               // (no desktop visibility control)
    },

    /* Printers */
    {
        MAKEINTRESOURCE(CSIDL_PRINTERS),    // pszTarget
        REST_NONE,                          // no restriction
        REGSTR_VAL_DV2_SHOWPRINTERS,        // customize show
        SFD_HIDE,                           // hide by default, can't cascade
        NULL,                               // (not cascadable)
        NULL,                               // no drag/drop customization
        0,                                  // no special flags for cascaded menu
        0,                                  // (no custom name)
        0,                                  // no custom tip
        NULL,                               // (no custom name)
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* Separator line */
    {
        SFD_SEPARATOR,                      // separator
        REST_NONE,                          // no restriction
        NULL,                               // no customize show
        SFD_SHOW,                           // show by default
        NULL,                               // (not cascadable)
        NULL,                               // (not cascadable)
        0,                                  // (not cascadable)
        0,                                  // (no custom name)
        0,                                  // no custom tip
        NULL,                               // (no custom name)
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* Help */
    {
        TEXT("shell:::{2559a1f1-21d7-11d4-bdaf-00c04f60b9f0}"), // pszTarget
        REST_NOSMHELP,                      // restriction
        REGSTR_VAL_DV2_SHOWHELP,            // customize show
        SFD_SHOW | SFD_PREFIX,              // show by default, use & prefix
        NULL,                               // (not cascadable)
        NULL,                               // (not cascadable)
        0,                                  // (not cascadable)
        0,                                  // (no custom name)
        0,                                  // no custom tip
        NULL,                               // (no custom name)
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* Search */
    {
        TEXT("shell:::{2559a1f0-21d7-11d4-bdaf-00c04f60b9f0}"), // pszTarget
        REST_NOFIND,                        // restriction
        REGSTR_VAL_DV2_SHOWSEARCH,          // customize show
        SFD_SHOW | SFD_PREFIX,              // show by default, use & prefix
        NULL,                               // (not cascadable)
        NULL,                               // (not cascadable)
        0,                                  // (not cascadable)
        0,                                  // (no custom name)
        0,                                  // no custom tip
        NULL,                               // (no custom name)
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* Run */
    {
        TEXT("shell:::{2559a1f3-21d7-11d4-bdaf-00c04f60b9f0}"), // pszTarget
        REST_NORUN,                         // restriction
        REGSTR_VAL_DV2_SHOWRUN,             // customize show
        SFD_SHOW | SFD_PREFIX,              // show by default, use & prefix
        NULL,                               // (not cascadable)
        NULL,                               // (not cascadable)
        0,                                  // (not cascadable)
        0,                                  // (no custom name)
        0,                                  // no custom tip
        NULL,                               // (no custom name)
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* Separator line */
    {
        SFD_SEPARATOR,                      // separator
        REST_NONE,                          // no restriction
        NULL,                               // no customize show
        SFD_SHOW,                           // show by default
        NULL,                               // (not cascadable)
        NULL,                               // (not cascadable)
        0,                                  // (not cascadable)
        0,                                  // (no custom name)
        0,                                  // no custom tip
        NULL,                               // (no custom name)
        NULL,                               // (no custom display rule)
        NULL,                               // (no desktop visibility control)
    },

    /* Windows Security */
    {
        TEXT("shell:::{2559a1f2-21d7-11d4-bdaf-00c04f60b9f0}"), // pszTarget
        REST_NOSECURITY,                    // restriction
        NULL,                               // not customizable
        SFD_SHOW | SFD_PREFIX,              // show by default, use & prefix
        NULL,                               // (not cascadable)
        NULL,                               // (not cascadable)
        0,                                  // (not cascadable)
        0,                                  // (no custom name)
        0,                                  // no custom tip
        NULL,                               // (no custom name)
        ShouldShowWindowsSecurity,          // custom display rule
        NULL,                               // (no desktop visibility control)
    },

    /* OEM Command */
    {
        TEXT("shell:::{2559a1f6-21d7-11d4-bdaf-00c04f60b9f0}"), // pszTarget
        REST_NONE,                          // no restriction
        REGSTR_VAL_DV2_SHOWOEM,             // customizable
        SFD_SHOW | SFD_PREFIX,              // show by default, use & prefix
        NULL,                               // (not cascadable)
        NULL,                               // (not cascadable)
        0,                                  // (not cascadable)
        0,                                  // (no custom name)
        0,                                  // no custom tip
        NULL,                               // (no custom name)
        ShouldShowOEMLink,                  // custom display rule
        NULL,                               // (no desktop visibility control)
    },

};

//
//  These are the items whose defaults change depending on the SKU.
//  Changing the defaults for the SKU means chasing down all the
//  places defaults are computed (here, the property sheets,
//  the regtreeop) and updating them all.  Someday, they should
//  be reduced down to one.
//
void SpecialFolderDesc::AdjustForSKU()
{
    if (IsCSIDL())
    {
        switch (GetCSIDL())
        {
            case CSIDL_MYPICTURES:
            case CSIDL_MYMUSIC:
                SetDefaultDisplayMode(IsOS(OS_ANYSERVER) ? SFD_HIDE : SFD_SHOW);
                break;

            case CSIDL_RECENT:
                SetDefaultDisplayMode(IsOS(OS_PERSONAL) ? SFD_HIDE : SFD_CASCADE);
                break;

            case CSIDL_PRINTERS:
                SetDefaultDisplayMode(IsOS(OS_PERSONAL) ? SFD_HIDE : SFD_SHOW);
                break;
        }
    }
}

LPWSTR SpecialFolderDesc::GetShowCacheRegName() const
{
    const WCHAR szCached[] = L"_ShouldShow";
    WCHAR *pszShowCache = (WCHAR *)LocalAlloc(LPTR, ((lstrlenW(_pszShow)+1) * sizeof (WCHAR)) + sizeof(szCached));
    if (pszShowCache)
    {
        StrCpy(pszShowCache, _pszShow);
        StrCat(pszShowCache, szCached);
    }
    return pszShowCache;
}


//
//  First try to read the display mode from the registry.
//  Failing that, use the default value.
//  Also fill in whether to ignore the custom display rule or not
//
DWORD SpecialFolderDesc::GetDisplayMode(BOOL *pbIgnoreRule) const
{
    *pbIgnoreRule = FALSE;

    // Restrictions always take top priority
    if (SHRestricted(_rest))
    {
        return SFD_HIDE;
    }

    DWORD dwMode = _uFlags & SFD_MODEMASK;

    // See if there is a user setting to override

    if (_pszShow)
    {
        DWORD dwNewMode, cb = sizeof(DWORD);
        if (SHRegGetUSValue(REGSTR_EXPLORER_ADVANCED, _pszShow, NULL, &dwNewMode, &cb, FALSE, NULL, 0) == ERROR_SUCCESS)
        {
            // User has forced show or forced no-show
            // Do not call the custom show logic
            dwMode = dwNewMode;
            *pbIgnoreRule = TRUE;
        }
        else
        {
            WCHAR *pszShowCache = GetShowCacheRegName();
            if (pszShowCache)
            {
                if (SHGetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, pszShowCache, NULL, &dwNewMode, &cb) == ERROR_SUCCESS)
                {
                    dwMode = dwNewMode;
                }
                LocalFree(pszShowCache);
            }
        }
    }

    //
    //  Some items are cascade-only (Favorites).
    //  Others never cascade (Run).
    //
    //  Enforce those rules here.
    //

    if (dwMode == SFD_CASCADE && !(_uFlags & SFD_CANCASCADE))
    {
        dwMode = SFD_SHOW;
    }
    else if (dwMode == SFD_SHOW && (_uFlags & SFD_FORCECASCADE))
    {
        dwMode = SFD_CASCADE;
    }

    return dwMode;
}

//****************************************************************************
//
//  SpecialFolderListItem
//
//  A PaneItem for the benefit of SFTBarHost.
//

class SpecialFolderListItem : public PaneItem
{

public:
    LPITEMIDLIST _pidl;             //  Full Pidl to each item
    const SpecialFolderDesc *_psfd; //  Describes this item

    TCHAR   _chMnem;                // Keyboard accelerator
    LPTSTR  _pszDispName;            // Display name
    HICON   _hIcon;                 // Icon

    SpecialFolderListItem(const SpecialFolderDesc *psfd) : _pidl(NULL), _psfd(psfd)
    {
        if (_psfd->IsSeparator())
        {
            // Make sure that SFD_SEPARATOR isn't accidentally recognized
            // as a separator.
            ASSERT(!_psfd->IsCSIDL());

            _iPinPos = PINPOS_SEPARATOR;
        }
        else if (_psfd->IsCSIDL())
        {
            SHGetSpecialFolderLocation(NULL, _psfd->GetCSIDL(), &_pidl);
        }
        else
        {
            SHILCreateFromPath(_psfd->_pszTarget, &_pidl, NULL);
        }
    };

    ~SpecialFolderListItem() 
    {
        ILFree(_pidl);
        if (_hIcon)
        {
            DestroyIcon(_hIcon);
        }
        SHFree(_pszDispName);
    };

    void ReplaceLastPidlElement(LPITEMIDLIST pidlNew)
    { 
        ASSERT(ILFindLastID(pidlNew) == pidlNew);   // the ILAppend below won't work otherwise
        ILRemoveLastID(_pidl);
        LPITEMIDLIST pidlCombined = ILAppendID(_pidl, &pidlNew->mkid, TRUE);
        if (pidlCombined)
            _pidl = pidlCombined;
    }

    //
    //  Values that are derived from CSIDL values need to be revalidated
    //  because the user can rename a special folder, and we need to track
    //  it to its new location.
    //
    BOOL IsStillValid()
    {
        BOOL fValid = TRUE;
        if (_psfd->IsCSIDL())
        {
            LPITEMIDLIST pidlNew;
            if (SHGetSpecialFolderLocation(NULL, _psfd->GetCSIDL(), &pidlNew) == S_OK)
            {
                UINT cbSizeNew = ILGetSize(pidlNew);
                if (cbSizeNew != ILGetSize(_pidl) ||
                    memcmp(_pidl, pidlNew, cbSizeNew) != 0)
                {
                    fValid = FALSE;
                }
                ILFree(pidlNew);
            }
        }
        return fValid;
    }
};

SpecialFolderList::~SpecialFolderList()
{
}

HRESULT SpecialFolderList::Initialize()
{
    for(int i=0;i < ARRAYSIZE(s_rgsfd); i++)
        s_rgsfd[i].AdjustForSKU();

    return S_OK;
}

// return TRUE if there are the requisite number of kids
BOOL MinKidsHelper(UINT csidl, BOOL bOnlyRASCON, DWORD dwMinKids)
{
    DWORD dwCount = 0;

    IShellFolder2 *psf;
    LPITEMIDLIST pidlBind = NULL;
    if (SHGetSpecialFolderLocation(NULL, csidl, &pidlBind) == S_OK)
    {
        if (SUCCEEDED(SHBindToObjectEx(NULL, pidlBind, NULL, IID_PPV_ARG(IShellFolder2, &psf))))
        {
            IEnumIDList *penum;
            if (S_OK == psf->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penum))
            {
                LPITEMIDLIST pidl;
                ULONG celt;
                while (S_OK == penum->Next(1, &pidl, &celt))
                {
                    if (bOnlyRASCON)
                    {
                        ASSERT(csidl == CSIDL_CONNECTIONS); // we better be in the net con folder
                        if (IsNetConPidlRAS(psf, pidl))
                            dwCount++;
                    }
                    else
                        dwCount++;

                    SHFree(pidl);

                    if (dwCount >= dwMinKids)
                        break;
                }
                penum->Release();
            }
            psf->Release();
        }
        ILFree(pidlBind);
    }
    return dwCount >= dwMinKids;
}

BOOL ShouldShowNetPlaces()
{
    return MinKidsHelper(CSIDL_NETHOOD, FALSE, 1);  // see bug 317893 for details on when to show net places
}

BOOL ShouldShowConnectTo()
{
    return MinKidsHelper(CSIDL_CONNECTIONS, TRUE, 1); // see bug 226855 (and the associated spec) for when to show Connect To
}

BOOL ShouldShowWindowsSecurity()
{
    return SHGetMachineInfo(GMI_TSCLIENT);
}

BOOL ShouldShowOEMLink()
{
    // Only show the OEM link if the OPK tool has added the appropriate registry entries...
    BOOL bRet = FALSE;
    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID\\{2559a1f6-21d7-11d4-bdaf-00c04f60b9f0}"), 0, KEY_READ, &hk))
    {
        DWORD cb;
        // Check to make sure its got a name, and a the parameter is registered properly...
        if (ERROR_SUCCESS == RegQueryValue(hk, NULL, NULL, (LONG*) &cb) &&
            ERROR_SUCCESS == SHGetValue(hk, TEXT("Instance\\InitPropertyBag"), TEXT("Param1"), NULL, NULL, &cb))
        {
            bRet = TRUE;
        }
        RegCloseKey(hk);
    }

    return bRet;
}


DWORD WINAPI SpecialFolderList::_HasEnoughChildrenThreadProc(void *pvData)
{
    SpecialFolderList *pThis = reinterpret_cast<SpecialFolderList *>(pvData);

    HRESULT hr = SHCoInitialize();
    if (SUCCEEDED(hr))
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < ARRAYSIZE(s_rgsfd); dwIndex++)
        {
            const SpecialFolderDesc *pdesc = &s_rgsfd[dwIndex];

            BOOL bIgnoreRule;
            DWORD dwMode = pdesc->GetDisplayMode(&bIgnoreRule);

            if (pdesc->IsCacheable() && pdesc->_ShowFolder)
            {
                ASSERT(pdesc->_pszShow);

                // We need to recount now
                if (!bIgnoreRule && pdesc->_ShowFolder())
                {
                    // We have enough kids
                    // Let's see if the state changed from last time
                    if (!(dwMode & SFD_WASSHOWN))
                    {
                        WCHAR *pszShowCache = pdesc->GetShowCacheRegName();
                        if (pszShowCache)
                        {
                            dwMode |= SFD_WASSHOWN;
                            SHSetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, pszShowCache, REG_DWORD, &dwMode, sizeof(dwMode));
                            pThis->Invalidate();
                            LocalFree(pszShowCache);
                        }
                    }
                    continue;
                }

                // just create the item to get a pidl for it....
                SpecialFolderListItem *pitem = new SpecialFolderListItem(pdesc);

                if (pitem && pitem->_pidl)
                {
                    // We don't have enough kids but we might gain them dynamically.
                    // Register for notifications that can indicate that there are new
                    // items.
                    ASSERT(pThis->_cNotify < SFTHOST_MAXNOTIFY);
                    if (pThis->RegisterNotify(pThis->_cNotify, SHCNE_CREATE | SHCNE_MKDIR | SHCNE_UPDATEDIR,
                                       pitem->_pidl, FALSE))
                    {
                        pThis->_cNotify++;
                    }
                }
                delete pitem;

                // Let's see if the state changed from last time
                if (dwMode & SFD_WASSHOWN)
                {
                    // Reset it to the default
                    WCHAR *pszShowCache = pdesc->GetShowCacheRegName();
                    if (pszShowCache)
                    {
                        SHDeleteValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, pszShowCache);
                        pThis->Invalidate();
                        LocalFree(pszShowCache);
                    }
                }
            }
        }
        pThis->Release();
    }
    SHCoUninitialize(hr);
    return 0;
}

BOOL ShouldShowItem(const SpecialFolderDesc *pdesc, BOOL bIgnoreRule, DWORD dwMode)
{
    if (bIgnoreRule)
        return TRUE;        // registry is over-riding whatever special rules exist...

    // if we've got a special rule, then the background thread will check it, so return false for now unless we showed it last time
    if (pdesc->_ShowFolder) 
    {
        if (pdesc->IsCacheable())
        {
            if (dwMode & SFD_WASSHOWN)
            {
                // Last time we looked, there were enough kids so let's assume it hasn't changed for now
                return TRUE;
            }

            return FALSE;
        }
        else
        {
            return pdesc->_ShowFolder();
        }
    }

    return TRUE;
}

void SpecialFolderList::EnumItems()
{

    // Clean out any previous register notifies.
    UINT id;
    for (id = 0; id < _cNotify; id++)
    {
        UnregisterNotify(id);
    }
    _cNotify = 0;

    // Start background enum for the MinKids since they can get hung up on the network
    AddRef();
    if (!SHQueueUserWorkItem(SpecialFolderList::_HasEnoughChildrenThreadProc, this, 0, 0, NULL, NULL, 0))
    {
        Release();
    }

    DWORD dwIndex;

    // Restrictions may result in an entire section disappearing,
    // so don't create two separators in a row.  Preinitialize to TRUE
    // so we don't get separators at the top of the list.
    BOOL fIgnoreSeparators = TRUE;
    int  iItems=0;

    for (dwIndex = 0; dwIndex < ARRAYSIZE(s_rgsfd); dwIndex++)
    {
        const SpecialFolderDesc *pdesc = &s_rgsfd[dwIndex];

        BOOL bIgnoreRule;
        DWORD dwMode = pdesc->GetDisplayMode(&bIgnoreRule);

        if (dwMode != SFD_HIDE)
        {
            SpecialFolderListItem *pitem = new SpecialFolderListItem(pdesc);
            if (pitem)
            {
                if ((pitem->IsSeparator() && !fIgnoreSeparators) ||
                    (pitem->_pidl && ShouldShowItem(pdesc, bIgnoreRule, dwMode))) 
                {
                    if ((dwMode & SFD_MODEMASK) == SFD_CASCADE)
                    {
                        pitem->EnableCascade();
                    }
                    if (pdesc->IsDropTarget())
                    {
                        pitem->EnableDropTarget();
                    }

                    // Get the icon and display name now.
                    if (!pitem->IsSeparator())
                    {
                        IShellFolder *psf;
                        LPCITEMIDLIST pidlItem;

                        HRESULT hr = SHBindToIDListParent(pitem->_pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlItem);
                        if (SUCCEEDED(hr))
                        {
                            if (!pitem->_psfd->GetCustomName(&pitem->_pszDispName))
                                pitem->_pszDispName = _DisplayNameOf(psf, pidlItem, SHGDN_NORMAL);
                            pitem->_hIcon = _IconOf(psf, pidlItem, _cxIcon);
                            psf->Release();
                        }
                    }

                    fIgnoreSeparators = pitem->IsSeparator();
                    // add the item
                    AddItem(pitem, NULL, pitem->_pidl);
                    if (!pitem->IsSeparator())
                        iItems++;
                }
                else
                    delete pitem;
            }
        }
    }
    SetDesiredSize(0, iItems);
}

int SpecialFolderList::AddImageForItem(PaneItem *p, IShellFolder *psf, LPCITEMIDLIST pidl, int iPos)
{
    int iIcon = -1;     // assume no icon
    SpecialFolderListItem *pitem = static_cast<SpecialFolderListItem *>(p);

    if (pitem->_hIcon)
    {
        iIcon = AddImage(pitem->_hIcon);
        DestroyIcon(pitem->_hIcon);
        pitem->_hIcon = NULL;
    }
    return iIcon;
}

LPTSTR SpecialFolderList::DisplayNameOfItem(PaneItem *p, IShellFolder *psf, LPCITEMIDLIST pidlItem, SHGNO shgno)
{
    LPTSTR psz = NULL;
    SpecialFolderListItem *pitem = static_cast<SpecialFolderListItem *>(p);
    if (shgno == SHGDN_NORMAL && pitem->_pszDispName)
    {
        // We are going to transfer ownership
        psz = pitem->_pszDispName;
        pitem->_pszDispName = NULL;
    }
    else
    {
        if (!pitem->_psfd->GetCustomName(&psz))
        {
            psz = SFTBarHost::DisplayNameOfItem(p, psf, pidlItem, shgno);
        }
    }

    if ((pitem->_psfd->_uFlags & SFD_PREFIX) && psz)
    {
        SHFree(pitem->_pszAccelerator);
        pitem->_pszAccelerator = NULL;
        SHStrDup(psz, &pitem->_pszAccelerator); // if it fails, then tough, no mnemonic
        pitem->_chMnem = CharUpperChar(SHStripMneumonic(psz));
    }

    return psz;
}

int SpecialFolderList::CompareItems(PaneItem *p1, PaneItem *p2)
{
//    SpecialFolderListItem *pitem1 = static_cast<SpecialFolderListItem *>(p1);
//    SpecialFolderListItem *pitem2 = static_cast<SpecialFolderListItem *>(p2);

    return 0; // we added them in the right order the first time
}

HRESULT SpecialFolderList::GetFolderAndPidl(PaneItem *p,
        IShellFolder **ppsfOut, LPCITEMIDLIST *ppidlOut)
{
    SpecialFolderListItem *pitem = static_cast<SpecialFolderListItem *>(p);
    return SHBindToIDListParent(pitem->_pidl, IID_PPV_ARG(IShellFolder, ppsfOut), ppidlOut);
}

void SpecialFolderList::GetItemInfoTip(PaneItem *p, LPTSTR pszText, DWORD cch)
{
    SpecialFolderListItem *pitem = (SpecialFolderListItem*)p;
    if (pitem->_psfd->_iToolTip)
        LoadString(_Module.GetResourceInstance(), pitem->_psfd->_iToolTip, pszText, cch);
    else
        SFTBarHost::GetItemInfoTip(p, pszText, cch);    // call the base class
}

HRESULT SpecialFolderList::ContextMenuRenameItem(PaneItem *p, LPCTSTR ptszNewName)
{
    SpecialFolderListItem *pitem = (SpecialFolderListItem*)p;
    IShellFolder *psf;
    LPCITEMIDLIST pidlItem;
    HRESULT hr = GetFolderAndPidl(pitem, &psf, &pidlItem);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlNew;
        hr = psf->SetNameOf(_hwnd, pidlItem, ptszNewName, SHGDN_INFOLDER, &pidlNew);
        if (SUCCEEDED(hr))
        {
            pitem->ReplaceLastPidlElement(pidlNew);
        }
        psf->Release();
    }

    return hr;
}

//
//  If we get any changenotify, it means that somebody added (or thought about
//  adding) an item to one of our minkids folders, so we'll have to look to see
//  if it crossed the minkids threshold.
//
void SpecialFolderList::OnChangeNotify(UINT id, LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    Invalidate();
    for (id = 0; id < _cNotify; id++)
    {
        UnregisterNotify(id);
    }
    _cNotify = 0;
    PostMessage(_hwnd, SFTBM_REFRESH, TRUE, 0);
}


BOOL SpecialFolderList::IsItemStillValid(PaneItem *p)
{
    SpecialFolderListItem *pitem = static_cast<SpecialFolderListItem *>(p);
    return pitem->IsStillValid();
}

BOOL SpecialFolderList::IsBold(PaneItem *p)
{
    SpecialFolderListItem *pitem = static_cast<SpecialFolderListItem *>(p);
    return pitem->_psfd->IsBold();
}

HRESULT SpecialFolderList::GetCascadeMenu(PaneItem *p, IShellMenu **ppsm)
{
    SpecialFolderListItem *pitem = static_cast<SpecialFolderListItem *>(p);
    IShellFolder *psf;
    HRESULT hr = SHBindToObjectEx(NULL, pitem->_pidl, NULL, IID_PPV_ARG(IShellFolder, &psf));
    if (SUCCEEDED(hr))
    {
        IShellMenu *psm;
        hr = CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER,
                              IID_PPV_ARG(IShellMenu, &psm));
        if (SUCCEEDED(hr))
        {

            //
            //  Recent Documents requires special treatment.
            //
            IShellMenuCallback *psmc = NULL;
            hr = pitem->_psfd->CreateShellMenuCallback(&psmc);

            if (SUCCEEDED(hr))
            {
                DWORD dwFlags = SMINIT_TOPLEVEL | SMINIT_VERTICAL | pitem->_psfd->_dwShellFolderFlags;
                if (IsRestrictedOrUserSetting(HKEY_CURRENT_USER, REST_NOCHANGESTARMENU,
                                              TEXT("Advanced"), TEXT("Start_EnableDragDrop"),
                                              ROUS_DEFAULTALLOW | ROUS_KEYALLOWS))
                {
                    dwFlags |= SMINIT_RESTRICT_DRAGDROP | SMINIT_RESTRICT_CONTEXTMENU;
                }
                psm->Initialize(psmc, 0, 0, dwFlags);

                HKEY hkCustom = NULL;
                if (pitem->_psfd->_pszCustomizeKey)
                {
                    RegCreateKeyEx(HKEY_CURRENT_USER, pitem->_psfd->_pszCustomizeKey,
                                   NULL, NULL, REG_OPTION_NON_VOLATILE,
                                   KEY_READ | KEY_WRITE, NULL, &hkCustom, NULL);
                }

                dwFlags = SMSET_USEBKICONEXTRACTION;
                hr = psm->SetShellFolder(psf, pitem->_pidl, hkCustom, dwFlags);
                if (SUCCEEDED(hr))
                {
                    // SetShellFolder takes ownership of hkCustom
                    *ppsm = psm;
                    psm->AddRef();
                }
                else
                {
                    // Clean up the registry key since SetShellFolder
                    // did not take ownership
                    if (hkCustom)
                    {
                        RegCloseKey(hkCustom);
                    }
                }

                ATOMICRELEASE(psmc); // psmc can be NULL
            }
            psm->Release();
        }
        psf->Release();
    }

    return hr;
}

TCHAR SpecialFolderList::GetItemAccelerator(PaneItem *p, int iItemStart)
{
    SpecialFolderListItem *pitem = static_cast<SpecialFolderListItem *>(p);

    if (pitem->_chMnem)
    {
        return pitem->_chMnem;
    }
    else
    {
        // Default: First letter is accelerator.
        return SFTBarHost::GetItemAccelerator(p, iItemStart);
    }
}

LRESULT SpecialFolderList::OnWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_NOTIFY:
        switch (((NMHDR*)(lParam))->code)
        {
        // When the user connects/disconnects via TS, we need to recalc
        // the "Windows Security" item
        case SMN_REFRESHLOGOFF:
            Invalidate();
            break;
        }
    }

    // Else fall back to parent implementation
    return SFTBarHost::OnWndProc(hwnd, uMsg, wParam, lParam);
}

BOOL _IsItemHiddenOnDesktop(LPCTSTR pszGuid)
{
    return SHRegGetBoolUSValue(REGSTR_PATH_HIDDEN_DESKTOP_ICONS_STARTPANEL,
                               pszGuid, FALSE, FALSE);
}

UINT SpecialFolderList::AdjustDeleteMenuItem(PaneItem *p, UINT *puiFlags)
{
    SpecialFolderListItem *pitem = static_cast<SpecialFolderListItem *>(p);
    if (pitem->_psfd->_pszCanHideOnDesktop)
    {
        // Set MF_CHECKED if the item is visible on the desktop
        if (!_IsItemHiddenOnDesktop(pitem->_psfd->_pszCanHideOnDesktop))
        {
            // Item is visible - show the checkbox
            *puiFlags |= MF_CHECKED;
        }

        return IDS_SFTHOST_SHOWONDESKTOP;
    }
    else
    {
        return 0; // not deletable
    }
}

HRESULT SpecialFolderList::ContextMenuInvokeItem(PaneItem *p, IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici, LPCTSTR pszVerb)
{
    SpecialFolderListItem *pitem = static_cast<SpecialFolderListItem *>(p);
    HRESULT hr;

    if (StrCmpIC(pszVerb, TEXT("delete")) == 0)
    {
        ASSERT(pitem->_psfd->_pszCanHideOnDesktop);

        // Toggle the hide/unhide state
        DWORD dwHide = !_IsItemHiddenOnDesktop(pitem->_psfd->_pszCanHideOnDesktop);
        LONG lErr = SHRegSetUSValue(REGSTR_PATH_HIDDEN_DESKTOP_ICONS_STARTPANEL,
                                    pitem->_psfd->_pszCanHideOnDesktop,
                                    REG_DWORD, &dwHide, sizeof(dwHide),
                                    SHREGSET_FORCE_HKCU);
        hr = HRESULT_FROM_WIN32(lErr);
        if (SUCCEEDED(hr))
        {
            // explorer\rcids.h and shell32\unicpp\resource.h have DIFFERENT
            // VALUES FOR FCIDM_REFRESH!  We want the one in unicpp\resource.h
            // because that's the correct one...
#define FCIDM_REFRESH_REAL 0x0a220
            PostMessage(GetShellWindow(), WM_COMMAND, FCIDM_REFRESH_REAL, 0); // refresh desktop
        }
    }
    else
    {
        hr = SFTBarHost::ContextMenuInvokeItem(pitem, pcm, pici, pszVerb);
    }

    return hr;
}

HRESULT SpecialFolderList::_GetUIObjectOfItem(PaneItem *p, REFIID riid, LPVOID *ppv)
{
    SpecialFolderListItem *pitem = static_cast<SpecialFolderListItem *>(p);
    if (pitem->_psfd->IsCSIDL() && (CSIDL_RECENT == pitem->_psfd->GetCSIDL()))
    {
        *ppv = NULL;
        return E_NOTIMPL;
    }
    return SFTBarHost::_GetUIObjectOfItem(p, riid, ppv);
}



//****************************************************************************
//
//  IShellMenuCallback helper for Recent Documents
//
//  We want to restrict to the first MAXRECDOCS items.
//

class CRecentShellMenuCallback
    : public CUnknown
    , public IShellMenuCallback
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CUnknown::AddRef(); }
    STDMETHODIMP_(ULONG) Release(void) { return CUnknown::Release(); }

    // *** IShellMenuCallback ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    friend HRESULT CRecentShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc);
    HRESULT _FilterRecentPidl(IShellFolder *psf, LPCITEMIDLIST pidlItem);

    int     _nShown;
    int     _iMaxRecentDocs;
};

HRESULT CRecentShellMenuCallback::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CRecentShellMenuCallback, IShellMenuCallback),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CRecentShellMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case SMC_BEGINENUM:
        _nShown = 0;
        _iMaxRecentDocs = SHRestricted(REST_MaxRecentDocs);
        if (_iMaxRecentDocs < 1)
            _iMaxRecentDocs = 15;       // default from shell32\recdocs.h
        return S_OK;

    case SMC_FILTERPIDL:
        ASSERT(psmd->dwMask & SMDM_SHELLFOLDER);
        return _FilterRecentPidl(psmd->psf, psmd->pidlItem);

    }
    return S_FALSE;
}

//
//  Return S_FALSE to allow the item to show, S_OK to hide it
//

HRESULT CRecentShellMenuCallback::_FilterRecentPidl(IShellFolder *psf, LPCITEMIDLIST pidlItem)
{
    HRESULT hrRc = S_OK;      // Assume hidden

    if (_nShown < _iMaxRecentDocs)
    {
        IShellLink *psl;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidlItem, IID_X_PPV_ARG(IShellLink, NULL, &psl))))
        {
            LPITEMIDLIST pidlTarget;
            if (SUCCEEDED(psl->GetIDList(&pidlTarget)) && pidlTarget)
            {
                DWORD dwAttr = SFGAO_FOLDER;
                if (SUCCEEDED(SHGetAttributesOf(pidlTarget, &dwAttr)) &&
                    !(dwAttr & SFGAO_FOLDER))
                {
                    // We found a shortcut to a nonfolder - keep it!
                    _nShown++;
                    hrRc = S_FALSE;
                }
                ILFree(pidlTarget);
            }

            psl->Release();
        }
    }

    return hrRc;
}

HRESULT CRecentShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc)
{
    *ppsmc = new CRecentShellMenuCallback;
    return *ppsmc ? S_OK : E_OUTOFMEMORY;
}

//****************************************************************************
//
//  IShellMenuCallback helper that disallows cascading into subfolders
//

class CNoSubdirShellMenuCallback
    : public CUnknown
    , public IShellMenuCallback
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CUnknown::AddRef(); }
    STDMETHODIMP_(ULONG) Release(void) { return CUnknown::Release(); }

    // *** IShellMenuCallback ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    friend HRESULT CNoSubdirShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc);
};

HRESULT CNoSubdirShellMenuCallback::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CNoSubdirShellMenuCallback, IShellMenuCallback),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CNoSubdirShellMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case SMC_GETSFINFO:
        {
            // Turn off the SMIF_SUBMENU flag on everybody.  This
            // prevents us from cascading more than one level deel.
            SMINFO *psminfo = reinterpret_cast<SMINFO *>(lParam);
            psminfo->dwFlags &= ~SMIF_SUBMENU;
            return S_OK;
        }
    }
    return S_FALSE;
}

HRESULT CNoSubdirShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc)
{
    *ppsmc = new CNoSubdirShellMenuCallback;
    return *ppsmc ? S_OK : E_OUTOFMEMORY;
}

//****************************************************************************
//
//  IShellMenuCallback helper for My Computer
//
//  Disallow cascading into subfolders and also force the default
//  drag/drop effect to DROPEFFECT_LINK.
//

class CMyComputerShellMenuCallback
    : public CNoSubdirShellMenuCallback
{
public:
    typedef CNoSubdirShellMenuCallback super;

    // *** IShellMenuCallback ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    friend HRESULT CMyComputerShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc);
};

HRESULT CMyComputerShellMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case SMC_BEGINDRAG:
        *(DWORD*)wParam = DROPEFFECT_LINK;
        return S_OK;

    }
    return super::CallbackSM(psmd, uMsg, wParam, lParam);
}

HRESULT CMyComputerShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc)
{
    *ppsmc = new CMyComputerShellMenuCallback;
    return *ppsmc ? S_OK : E_OUTOFMEMORY;
}

//****************************************************************************
//
//  IShellMenuCallback helper that prevents Fonts from cascading
//  Used by Control Panel.
//

class CNoFontsShellMenuCallback
    : public CUnknown
    , public IShellMenuCallback
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CUnknown::AddRef(); }
    STDMETHODIMP_(ULONG) Release(void) { return CUnknown::Release(); }

    // *** IShellMenuCallback ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    friend HRESULT CNoFontsShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc);
};

HRESULT CNoFontsShellMenuCallback::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CNoFontsShellMenuCallback, IShellMenuCallback),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

BOOL _IsFontsFolderShortcut(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    TCHAR sz[MAX_PATH];
    return SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, sz, ARRAYSIZE(sz))) &&
           lstrcmpi(sz, TEXT("::{D20EA4E1-3957-11d2-A40B-0C5020524152}")) == 0;
}

HRESULT CNoFontsShellMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case SMC_GETSFINFO:
        {
            // If this is the Fonts item, then remove the SUBMENU attribute.
            SMINFO *psminfo = reinterpret_cast<SMINFO *>(lParam);
            if ((psminfo->dwMask & SMIM_FLAGS) &&
                (psminfo->dwFlags & SMIF_SUBMENU) &&
                _IsFontsFolderShortcut(psmd->psf, psmd->pidlItem))
            {
                psminfo->dwFlags &= ~SMIF_SUBMENU;
            }
            return S_OK;
        }
    }
    return S_FALSE;
}

HRESULT CNoFontsShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc)
{
    *ppsmc = new CNoFontsShellMenuCallback;
    return *ppsmc ? S_OK : E_OUTOFMEMORY;
}

//****************************************************************************
//
//  IShellMenuCallback helper that filters the "connect to" menu
//

class CConnectToShellMenuCallback
    : public CUnknown
    , public IShellMenuCallback
    , public CObjectWithSite
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CUnknown::AddRef(); }
    STDMETHODIMP_(ULONG) Release(void) { return CUnknown::Release(); }

    // *** IShellMenuCallback ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** IObjectWithSite ***
    // inherited from CObjectWithSite

private:
    HRESULT _OnGetSFInfo(SMDATA *psmd, SMINFO *psminfo);
    HRESULT _OnGetInfo(SMDATA *psmd, SMINFO *psminfo);
    HRESULT _OnEndEnum(SMDATA *psmd);

    friend HRESULT CConnectToShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc);
    BOOL _bAnyRAS;
};

#define ICOL_NETCONMEDIATYPE       0x101 // from netshell
#define ICOL_NETCONSUBMEDIATYPE    0x102 // from netshell
#define ICOL_NETCONSTATUS          0x103 // from netshell
#define ICOL_NETCONCHARACTERISTICS 0x104 // from netshell

BOOL IsMediaRASType(NETCON_MEDIATYPE ncm)
{
    return (ncm == NCM_DIRECT || ncm == NCM_ISDN || ncm == NCM_PHONE || ncm == NCM_TUNNEL || ncm == NCM_PPPOE);  // REVIEW DIRECT correct?
}

BOOL IsNetConPidlRAS(IShellFolder2 *psfNetCon, LPCITEMIDLIST pidlNetConItem)
{
    BOOL bRet = FALSE;
    SHCOLUMNID scidMediaType, scidSubMediaType, scidCharacteristics;
    VARIANT v;
    
    scidMediaType.fmtid       = GUID_NETSHELL_PROPS;
    scidMediaType.pid         = ICOL_NETCONMEDIATYPE;

    scidSubMediaType.fmtid    = GUID_NETSHELL_PROPS;
    scidSubMediaType.pid      = ICOL_NETCONSUBMEDIATYPE;
    
    scidCharacteristics.fmtid = GUID_NETSHELL_PROPS;
    scidCharacteristics.pid   = ICOL_NETCONCHARACTERISTICS;

    if (SUCCEEDED(psfNetCon->GetDetailsEx(pidlNetConItem, &scidMediaType, &v)))
    {
        // Is this a RAS connection
        if (IsMediaRASType((NETCON_MEDIATYPE)v.lVal))
        {
            VariantClear(&v);
         
            // Make sure it's not incoming
            if (SUCCEEDED(psfNetCon->GetDetailsEx(pidlNetConItem, &scidCharacteristics, &v)))
            {
                if (!(NCCF_INCOMING_ONLY & v.lVal))
                    bRet = TRUE;
            }
        }

        // Is this a Wireless LAN connection?
        if (NCM_LAN == (NETCON_MEDIATYPE)v.lVal)
        {
            VariantClear(&v);
            
            if (SUCCEEDED(psfNetCon->GetDetailsEx(pidlNetConItem, &scidSubMediaType, &v)))
            {
                if (NCSM_WIRELESS == (NETCON_SUBMEDIATYPE)v.lVal)
                    bRet = TRUE;
            }
        }

        VariantClear(&v);
    }
    return bRet;
}

HRESULT CConnectToShellMenuCallback::_OnGetInfo(SMDATA *psmd, SMINFO *psminfo)
{
    HRESULT hr = S_FALSE;
    if (psminfo->dwMask & SMIM_ICON)
    {
        if (psmd->uId == IDM_OPENCONFOLDER)
        {
            LPITEMIDLIST pidl = SHCloneSpecialIDList(NULL, CSIDL_CONNECTIONS, FALSE);
            if (pidl)
            {
                LPCITEMIDLIST pidlObject;
                IShellFolder *psf;
                hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlObject);
                if (SUCCEEDED(hr))
                {
                    SHMapPIDLToSystemImageListIndex(psf, pidlObject, &psminfo->iIcon);
                    psminfo->dwFlags |= SMIF_ICON;
                    psf->Release();
                }
                ILFree(pidl);
            }
        }
    }
    return hr;
}

HRESULT CConnectToShellMenuCallback::_OnGetSFInfo(SMDATA *psmd, SMINFO *psminfo)
{
    IShellFolder2 *psf2;
    ASSERT(psminfo->dwMask & SMIM_FLAGS);                       // ??
    psminfo->dwFlags &= ~SMIF_SUBMENU;

    if (SUCCEEDED(psmd->psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        if (!IsNetConPidlRAS(psf2, psmd->pidlItem))
            psminfo->dwFlags |= SMIF_HIDDEN;
        else
            _bAnyRAS = TRUE;

        psf2->Release();
    }

    return S_OK;
}

HRESULT CConnectToShellMenuCallback::_OnEndEnum(SMDATA *psmd)
{
    HRESULT hr = S_FALSE;
    IShellMenu* psm;

    if (psmd->punk && SUCCEEDED(hr = psmd->punk->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
    {
        // load the static portion of the connect to menu, and add it to the bottom
        HMENU hmStatic = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(MENU_CONNECTTO));

        if (hmStatic)
        {
            // if there aren't any dynamic items (RAS connections), then delete the separator
            if (!_bAnyRAS)
                DeleteMenu(hmStatic, 0, MF_BYPOSITION);

            HWND hwnd = NULL;
            IUnknown *punk;
            if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IUnknown, &punk))))
            {
                IUnknown_GetWindow(punk, &hwnd);
                punk->Release();
            }
            psm->SetMenu(hmStatic, hwnd, SMSET_NOEMPTY | SMSET_BOTTOM);
        }
        psm->Release();
    }
    return hr;
}


HRESULT CConnectToShellMenuCallback::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CConnectToShellMenuCallback, IShellMenuCallback),
        QITABENT(CConnectToShellMenuCallback, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CConnectToShellMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case SMC_GETINFO:
        return _OnGetInfo(psmd, (SMINFO *)lParam);

    case SMC_GETSFINFO:
        return _OnGetSFInfo(psmd, (SMINFO *)lParam);

    case SMC_BEGINENUM:
        _bAnyRAS = FALSE;

    case SMC_ENDENUM:
        return _OnEndEnum(psmd);

    case SMC_EXEC:
        switch (psmd->uId)
        {
            case IDM_OPENCONFOLDER:
                ShowFolder(CSIDL_CONNECTIONS);
                return S_OK;
        }
        break;
    }

    return S_FALSE;
}

HRESULT CConnectToShellMenuCallback_CreateInstance(IShellMenuCallback **ppsmc)
{
    *ppsmc = new CConnectToShellMenuCallback;
    return *ppsmc ? S_OK : E_OUTOFMEMORY;
}

BOOL SpecialFolderDesc::LoadStringAsOLESTR(LPTSTR *ppsz) const
{
    BOOL bRet = FALSE;
    TCHAR szTmp[MAX_PATH];
    if (_idsCustomName && LoadString(_Module.GetResourceInstance(), _idsCustomName, szTmp, ARRAYSIZE(szTmp)))
    {
        if (ppsz)
            SHStrDup(szTmp, ppsz);
        bRet = TRUE;
    }
    return bRet;
}

BOOL SpecialFolderDesc::ConnectToName(LPTSTR *ppsz) const
{
    BOOL bIgnoreRule;
    DWORD dwMode = GetDisplayMode(&bIgnoreRule);

    // if Connect To is displayed as a link, then don't over-ride the name (i.e. use Network Connections)
    if ((dwMode & SFD_MODEMASK) == SFD_SHOW)
        return FALSE;
    else
        return LoadStringAsOLESTR(ppsz);
}


void ShowFolder(UINT csidl)
{
    LPITEMIDLIST pidl;
    if (SUCCEEDED(SHGetFolderLocation(NULL, csidl, NULL, 0, &pidl)))
    {
        SHELLEXECUTEINFO shei = { 0 };

        shei.cbSize     = sizeof(shei);
        shei.fMask      = SEE_MASK_IDLIST;
        shei.nShow      = SW_SHOWNORMAL;
        shei.lpVerb     = TEXT("open");
        shei.lpIDList   = pidl;
        ShellExecuteEx(&shei);
        ILFree(pidl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\pidlbutton.h ===
/*
 * PIDLButton header
 */


namespace DirectUI
{

// Class definition
class PIDLButton : public Button
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(NULL, AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(LPITEMIDLIST pidl, OUT Element** ppElement) { return Create(pidl, AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(LPITEMIDLIST pidl, UINT nActive, OUT Element** ppElement);

    static void SetImageSize(int nImageSize) { s_nImageSize = nImageSize; }

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);
    virtual void OnEvent(Event* pEvent);
    virtual void OnInput(InputEvent* pie);


    HRESULT OnContextMenu(POINT *ppt);
    LRESULT OnMenuMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT Initialize(LPITEMIDLIST pidl, UINT nActive);
    HRESULT InvokePidl();

    /*
     *  Message exchanged with host to handle IContextMenu2 and IContextMenu3
     */
    enum {
        PBM_SETMENUFORWARD = WM_USER + 1    // WM_USER is used by DirectUI
    };

    // Property definitions

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    virtual HRESULT Register();

    PIDLButton() { };

protected:
    virtual ~PIDLButton();

    HWNDElement *GetHWNDHost()
    {
        if (!_peHost)
        {
            Element *pe = GetRoot();
            if (pe && pe->GetClassInfo()->IsSubclassOf(HWNDElement::Class))
            {
                _peHost = reinterpret_cast<HWNDElement *>(pe);
            }
        }
        return _peHost;
    }


    HWND GetHWND() 
    {
        HWNDElement *phe = GetHWNDHost();
        if (phe)
        {
            return phe->GetHWND();
        }
        return NULL;
    }

    /*
     *  Custom commands we add to the context menu.
     */
    enum {
        // none yet
        IDM_QCM_MIN   = 0x0100,
        IDM_QCM_MAX   = 0x7FFF,
    };


private:
    LPITEMIDLIST _pidl;

    static int s_nImageSize;

    // Caching host information
    HWNDElement *           _peHost;


    //
    //  Context menu handling
    //
    IContextMenu2 *         _pcm2Pop;       /* Currently popped-up context menu */
    IContextMenu3 *         _pcm3Pop;       /* Currently popped-up context menu */
};

}  // namespace DirectUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\wrapctl.cpp ===
#include "stdafx.h"
#include "sfthost.h"
#include "proglist.h"

BOOL UserPane_RegisterClass();
BOOL MorePrograms_RegisterClass();
BOOL LogoffPane_RegisterClass();

void RegisterDesktopControlClasses()
{
    SFTBarHost::Register();
    UserPane_RegisterClass();
    MorePrograms_RegisterClass();
    LogoffPane_RegisterClass();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\sfthost.cpp ===
#include "stdafx.h"
#include <browseui.h>
#include "sfthost.h"
#include <shellp.h>
#include "startmnu.h"

#define TF_HOST     0x00000010
#define TF_HOSTDD   0x00000040 // drag/drop
#define TF_HOSTPIN  0x00000080 // pin

#define ANIWND_WIDTH  80
#define ANIWND_HEIGHT 50

//---------BEGIN HACKS OF DEATH -------------

// HACKHACK - desktopp.h and browseui.h both define SHCreateFromDesktop
// What's worse, browseui.h includes desktopp.h! So you have to sneak it
// out in this totally wacky way.
#include <desktopp.h>
#define SHCreateFromDesktop _SHCreateFromDesktop
#include <browseui.h>

//---------END HACKS OF DEATH -------------


//****************************************************************************
//
//  Dummy IContextMenu
//
//  We use this when we can't get the real IContextMenu for an item.
//  If the user pins an object and then deletes the underlying
//  file, attempting to get the IContextMenu from the shell will fail,
//  but we need something there so we can add the "Remove from this list"
//  menu item.
//
//  Since this dummy context menu has no state, we can make it a static
//  singleton object.

class CEmptyContextMenu
    : public IContextMenu
{
public:
    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj)
    {
        static const QITAB qit[] = {
            QITABENT(CEmptyContextMenu, IContextMenu),
            { 0 },
        };
        return QISearch(this, qit, riid, ppvObj);
    }

    STDMETHODIMP_(ULONG) AddRef(void) { return 3; }
    STDMETHODIMP_(ULONG) Release(void) { return 2; }

    // *** IContextMenu ***
    STDMETHODIMP  QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
    {
        return ResultFromShort(0);  // No items added
    }

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pici)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwRes, LPSTR pszName, UINT cchMax)
    {
        return E_INVALIDARG; // no commands; therefore, no command strings!
    }

public:
    IContextMenu *GetContextMenu()
    {
        // Don't need to AddRef since we are a static object
        return this;
    }
};

static CEmptyContextMenu s_EmptyContextMenu;

//****************************************************************************

#define WC_SFTBARHOST       TEXT("DesktopSFTBarHost")

BOOL GetFileCreationTime(LPCTSTR pszFile, FILETIME *pftCreate)
{
    WIN32_FILE_ATTRIBUTE_DATA wfad;
    BOOL fRc = GetFileAttributesEx(pszFile, GetFileExInfoStandard, &wfad);
    if (fRc)
    {
        *pftCreate = wfad.ftCreationTime;
    }

    return fRc;
}

// {2A1339D7-523C-4E21-80D3-30C97B0698D2}
const CLSID TOID_SFTBarHostBackgroundEnum = {
    0x2A1339D7, 0x523C, 0x4E21,
    { 0x80, 0xD3, 0x30, 0xC9, 0x7B, 0x06, 0x98, 0xD2} };

BOOL SFTBarHost::Register()
{
    WNDCLASS wc;
    wc.style = 0;
    wc.lpfnWndProc = _WndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(void *);
    wc.hInstance = _Module.GetModuleInstance();
    wc.hIcon = 0;
    // We specify a cursor so the OOBE window gets something
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName = 0;
    wc.lpszClassName = WC_SFTBARHOST;
    return ::SHRegisterClass(&wc);
}

BOOL SFTBarHost::Unregister()
{
    return ::UnregisterClass(WC_SFTBARHOST, _Module.GetModuleInstance());
}

LRESULT CALLBACK SFTBarHost::_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SFTBarHost *self = reinterpret_cast<SFTBarHost *>(GetWindowPtr0(hwnd));

    if (uMsg == WM_NCCREATE)
    {
        return _OnNcCreate(hwnd, uMsg, wParam, lParam);
    }
    else if (self)
    {

#define HANDLE_SFT_MESSAGE(wm, fn) case wm: return self->fn(hwnd, uMsg, wParam, lParam)

        switch (uMsg)
        {
        HANDLE_SFT_MESSAGE(WM_CREATE,       _OnCreate);
        HANDLE_SFT_MESSAGE(WM_DESTROY,      _OnDestroy);
        HANDLE_SFT_MESSAGE(WM_NCDESTROY,    _OnNcDestroy);
        HANDLE_SFT_MESSAGE(WM_NOTIFY,       _OnNotify);
        HANDLE_SFT_MESSAGE(WM_SIZE,         _OnSize);
        HANDLE_SFT_MESSAGE(WM_ERASEBKGND,   _OnEraseBackground);
        HANDLE_SFT_MESSAGE(WM_CONTEXTMENU,  _OnContextMenu);
        HANDLE_SFT_MESSAGE(WM_CTLCOLORSTATIC,_OnCtlColorStatic);
        HANDLE_SFT_MESSAGE(WM_TIMER,        _OnTimer);
        HANDLE_SFT_MESSAGE(WM_SETFOCUS,     _OnSetFocus);

        HANDLE_SFT_MESSAGE(WM_INITMENUPOPUP,_OnMenuMessage);
        HANDLE_SFT_MESSAGE(WM_DRAWITEM,     _OnMenuMessage);
        HANDLE_SFT_MESSAGE(WM_MENUCHAR,     _OnMenuMessage);
        HANDLE_SFT_MESSAGE(WM_MEASUREITEM,  _OnMenuMessage);

        HANDLE_SFT_MESSAGE(WM_SYSCOLORCHANGE,   _OnSysColorChange);
        HANDLE_SFT_MESSAGE(WM_DISPLAYCHANGE,    _OnForwardMessage);
        HANDLE_SFT_MESSAGE(WM_SETTINGCHANGE,    _OnForwardMessage);

        HANDLE_SFT_MESSAGE(WM_UPDATEUISTATE,    _OnUpdateUIState);

        HANDLE_SFT_MESSAGE(SFTBM_REPOPULATE,_OnRepopulate);
        HANDLE_SFT_MESSAGE(SFTBM_CHANGENOTIFY+0,_OnChangeNotify);
        HANDLE_SFT_MESSAGE(SFTBM_CHANGENOTIFY+1,_OnChangeNotify);
        HANDLE_SFT_MESSAGE(SFTBM_CHANGENOTIFY+2,_OnChangeNotify);
        HANDLE_SFT_MESSAGE(SFTBM_CHANGENOTIFY+3,_OnChangeNotify);
        HANDLE_SFT_MESSAGE(SFTBM_CHANGENOTIFY+4,_OnChangeNotify);
        HANDLE_SFT_MESSAGE(SFTBM_CHANGENOTIFY+5,_OnChangeNotify);
        HANDLE_SFT_MESSAGE(SFTBM_CHANGENOTIFY+6,_OnChangeNotify);
        HANDLE_SFT_MESSAGE(SFTBM_CHANGENOTIFY+7,_OnChangeNotify);
        HANDLE_SFT_MESSAGE(SFTBM_REFRESH,       _OnRefresh);
        HANDLE_SFT_MESSAGE(SFTBM_CASCADE,       _OnCascade);
        HANDLE_SFT_MESSAGE(SFTBM_ICONUPDATE,    _OnIconUpdate);
        }

        // If this assert fires, you need to add more
        // HANDLE_SFT_MESSAGE(SFTBM_CHANGENOTIFY+... entries.
        COMPILETIME_ASSERT(SFTHOST_MAXNOTIFY == 8);

#undef HANDLE_SFT_MESSAGE

        return self->OnWndProc(hwnd, uMsg, wParam, lParam);
    }

    return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT SFTBarHost::_OnNcCreate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SMPANEDATA *pspld = PaneDataFromCreateStruct(lParam);
    SFTBarHost *self = NULL;

    switch (pspld->iPartId)
    {
        case SPP_PROGLIST:
            self = ByUsage_CreateInstance();
            break;
        case SPP_PLACESLIST:
            self = SpecList_CreateInstance();
            break;
        default:
            TraceMsg(TF_ERROR, "Unknown panetype %d", pspld->iPartId);
    }

    if (self)
    {
        SetWindowPtr0(hwnd, self);

        self->_hwnd = hwnd;
        self->_hTheme = pspld->hTheme;

        if (FAILED(self->Initialize()))
        {
            TraceMsg(TF_ERROR, "SFTBarHost::NcCreate Initialize call failed");
            return FALSE;
        }

        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return FALSE;
}

//
//  The tile height is max(imagelist height, text height) + some margin
//  The margin is "scientifically computed" to be the value that looks
//  reasonably close to the bitmaps the designers gave us.
//
void SFTBarHost::_ComputeTileMetrics()
{
    int cyTile = _cyIcon;

    HDC hdc = GetDC(_hwndList);
    if (hdc)
    {
        // SOMEDAY - get this to play friendly with themes
        HFONT hf = GetWindowFont(_hwndList);
        HFONT hfPrev = SelectFont(hdc, hf);
        SIZE siz;
        if (GetTextExtentPoint(hdc, TEXT("0"), 1, &siz))
        {
            if (_CanHaveSubtitles())
            {
                // Reserve space for the subtitle too
                siz.cy *= 2;
            }

            if (cyTile < siz.cy)
                cyTile = siz.cy;
        }

        SelectFont(hdc, hfPrev);
        ReleaseDC(_hwndList, hdc);
    }

    // Listview draws text at left margin + icon + edge
    _cxIndent = _cxMargin + _cxIcon + GetSystemMetrics(SM_CXEDGE);
    _cyTile = cyTile + (4 * _cyMargin) + _cyTilePadding;
}

void SFTBarHost::_SetTileWidth(int cxTile)
{
    LVTILEVIEWINFO tvi;
    tvi.cbSize = sizeof(tvi);
    tvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS;
    tvi.dwFlags = LVTVIF_FIXEDSIZE;

    // If we support cascading, then reserve space for the cascade arrows
    if (_dwFlags & HOSTF_CASCADEMENU)
    {
        // WARNING!  _OnLVItemPostPaint uses these margins
        tvi.dwMask |= LVTVIM_LABELMARGIN;
        tvi.rcLabelMargin.left   = 0;
        tvi.rcLabelMargin.top    = 0;
        tvi.rcLabelMargin.right  = _cxMarlett;
        tvi.rcLabelMargin.bottom = 0;
    }

    // Reserve space for subtitles if necessary
    tvi.cLines = _CanHaveSubtitles() ? 1 : 0;

    // _cyTile has the padding into account, but we want each item to be the height without padding
    tvi.sizeTile.cy = _cyTile - _cyTilePadding;
    tvi.sizeTile.cx = cxTile;
    ListView_SetTileViewInfo(_hwndList, &tvi);
    _cxTile = cxTile;
}

LRESULT SFTBarHost::_OnSize(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (_hwndList)
    {
        SIZE sizeClient = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
        sizeClient.cx -= (_margins.cxLeftWidth + _margins.cxRightWidth);
        sizeClient.cy -= (_margins.cyTopHeight + _margins.cyBottomHeight);

        SetWindowPos(_hwndList, NULL, _margins.cxLeftWidth, _margins.cyTopHeight,
                     sizeClient.cx, sizeClient.cy,
                     SWP_NOZORDER | SWP_NOOWNERZORDER);

        _SetTileWidth(sizeClient.cx);
        if (HasDynamicContent())
        {
            _InternalRepopulateList();
        }
    }
    return 0;
}

LRESULT SFTBarHost::_OnSysColorChange(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // if we're in unthemed mode, then we need to update our colors
    if (!_hTheme)
    {
        ListView_SetTextColor(_hwndList, GetSysColor(COLOR_MENUTEXT));
        _clrHot = GetSysColor(COLOR_MENUTEXT);
        _clrBG = GetSysColor(COLOR_MENU);
        _clrSubtitle = CLR_NONE;

        ListView_SetBkColor(_hwndList, _clrBG);
        ListView_SetTextBkColor(_hwndList, _clrBG);
    }

    return _OnForwardMessage(hwnd, uMsg, wParam, lParam);
}


LRESULT SFTBarHost::_OnCtlColorStatic(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Use the same colors as the listview itself.
    HDC hdc = GET_WM_CTLCOLOR_HDC(wParam, lParam, uMsg);
    SetTextColor(hdc, ListView_GetTextColor(_hwndList));
    COLORREF clrBk = ListView_GetTextBkColor(_hwndList);
    if (clrBk == CLR_NONE)
    {
        // The animate control really wants to get a text background color.
        // It doesn't support transparency.
        if (GET_WM_CTLCOLOR_HWND(wParam, lParam, uMsg) == _hwndAni)
        {
            if (_hTheme)
            {
                if (!_hBrushAni)
                {
                    // We need to paint the theme background in a bitmap and use that
                    // to create a brush for the background of the flashlight animation
                    RECT rcClient;
                    GetClientRect(hwnd, &rcClient);
                    int x = (RECTWIDTH(rcClient) - ANIWND_WIDTH)/2;     // IDA_SEARCH is ANIWND_WIDTH pix wide
                    int y = (RECTHEIGHT(rcClient) - ANIWND_HEIGHT)/2;    // IDA_SEARCH is ANIWND_HEIGHT pix tall
                    RECT rc;
                    rc.top = y;
                    rc.bottom = y + ANIWND_HEIGHT;
                    rc.left = x;
                    rc.right = x + ANIWND_WIDTH;
                    HDC hdcBMP = CreateCompatibleDC(hdc);
                    HBITMAP hbmp = CreateCompatibleBitmap(hdc, ANIWND_WIDTH, ANIWND_HEIGHT);
                    POINT pt = {0, 0};

                    // Offset the viewport so that DrawThemeBackground draws the part that we care about
                    // at the right place
                    OffsetViewportOrgEx(hdcBMP, -x, -y, &pt);
                    SelectObject(hdcBMP, hbmp);
                    DrawThemeBackground(_hTheme, hdcBMP, _iThemePart, 0, &rcClient, 0);

                    // Our bitmap is now ready!
                    _hBrushAni = CreatePatternBrush(hbmp);

                    // Cleanup
                    SelectObject(hdcBMP, NULL);
                    DeleteObject(hbmp);
                    DeleteObject(hdcBMP);
                }
                return (LRESULT)_hBrushAni;
            }
            else
            {
                return (LRESULT)GetSysColorBrush(COLOR_MENU);
            }
        }

        SetBkMode(hdc, TRANSPARENT);
        return (LRESULT)GetStockBrush(HOLLOW_BRUSH);
    }
    else
    {
        return (LRESULT)GetSysColorBrush(COLOR_MENU);
    }
}

//
//  Appends the PaneItem to _dpaEnum, or deletes it (and nulls it out)
//  if unable to append.
//
int SFTBarHost::_AppendEnumPaneItem(PaneItem *pitem)
{
    int iItem = _dpaEnumNew.AppendPtr(pitem);
    if (iItem < 0)
    {
        delete pitem;
        iItem = -1;
    }
    return iItem;
}

BOOL SFTBarHost::AddItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlChild)
{
    BOOL fSuccess = FALSE;

    ASSERT(_fEnumerating);
    if (_AppendEnumPaneItem(pitem) >= 0)
    {
        fSuccess = TRUE;
    }
    return fSuccess;
}

void SFTBarHost::_RepositionItems()
{
    DEBUG_CODE(_fListUnstable++);

    int iItem;
    for (iItem = ListView_GetItemCount(_hwndList) - 1; iItem >= 0; iItem--)
    {
        PaneItem *pitem = _GetItemFromLV(iItem);
        if (pitem)
        {
            POINT pt;
            _ComputeListViewItemPosition(pitem->_iPos, &pt);
            ListView_SetItemPosition(_hwndList, iItem, pt.x, pt.y);
        }
    }
    DEBUG_CODE(_fListUnstable--);
}

int SFTBarHost::AddImage(HICON hIcon)
{
    int iIcon = -1;
    if (_IsPrivateImageList())
    {
        iIcon = ImageList_AddIcon(_himl, hIcon);
    }
    return iIcon;
}

//
//  pvData = the window to receive the icon
//  pvHint = pitem whose icon we just extracted
//  iIconIndex = the icon we got
//
void SFTBarHost::SetIconAsync(LPCITEMIDLIST pidl, LPVOID pvData, LPVOID pvHint, INT iIconIndex, INT iOpenIconIndex)
{
    HWND hwnd = (HWND)pvData;
    if (IsWindow(hwnd))
    {
        PostMessage(hwnd, SFTBM_ICONUPDATE, iIconIndex, (LPARAM)pvHint);
    }
}

//
//  wParam = icon index
//  lParam = pitem to update
//
LRESULT SFTBarHost::_OnIconUpdate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    //  Do not dereference lParam (pitem) until we are sure it is valid.
    //

    LVFINDINFO fi;
    LVITEM lvi;

    fi.flags = LVFI_PARAM;
    fi.lParam = lParam;
    lvi.iItem = ListView_FindItem(_hwndList, -1, &fi);
    if (lvi.iItem >= 0)
    {
        lvi.mask = LVIF_IMAGE;
        lvi.iSubItem = 0;
        lvi.iImage = (int)wParam;
        ListView_SetItem(_hwndList, &lvi);
        // Now, we need to go update our cached bitmap version of the start menu.
        _SendNotify(_hwnd, SMN_NEEDREPAINT, NULL);
    }
    return 0;
}

// An over-ridable method to let client direct an item at a particular image
int SFTBarHost::AddImageForItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidl, int iPos)
{
    if (_IsPrivateImageList())
    {
        return _ExtractImageForItem(pitem, psf, pidl);
    }
    else
    {
        // system image list: Make the shell do the work.
        int iIndex;
        SHMapIDListToImageListIndexAsync(_psched, psf, pidl, 0, SetIconAsync, _hwnd, pitem, &iIndex, NULL);
        return iIndex;
    }
}

HICON _IconOf(IShellFolder *psf, LPCITEMIDLIST pidl, int cxIcon)
{
    HRESULT hr;
    HICON hicoLarge = NULL, hicoSmall = NULL;
    IExtractIcon *pxi;

    hr = psf->GetUIObjectOf(NULL, 1, &pidl, IID_PPV_ARG_NULL(IExtractIcon, &pxi));
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        int iIndex;
        UINT uiFlags;

        hr = pxi->GetIconLocation(0, szPath, ARRAYSIZE(szPath), &iIndex, &uiFlags);

        // S_FALSE means "Please use the generic document icon"
        if (hr == S_FALSE)
        {
            StrCpyN(szPath, TEXT("shell32.dll"), ARRAYSIZE(szPath));
            iIndex = II_DOCNOASSOC;
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            // Even though we don't care about the small icon, we have to
            // ask for it anyway because some people fault on NULL.
            hr = pxi->Extract(szPath, iIndex, &hicoLarge, &hicoSmall, cxIcon);

            // S_FALSE means "I am too lazy to extract the icon myself.
            // You do it for me."
            if (hr == S_FALSE)
            {
                hr = SHDefExtractIcon(szPath, iIndex, uiFlags, &hicoLarge, &hicoSmall, cxIcon);
            }
        }

        pxi->Release();

    }

    // If we can't get an icon (e.g., object is on a slow link),
    // then use a generic folder or generic document, as appropriate.
    if (FAILED(hr))
    {
        SFGAOF attr = SFGAO_FOLDER;
        int iIndex;
        if (SUCCEEDED(psf->GetAttributesOf(1, &pidl, &attr)) &&
            (attr & SFGAO_FOLDER))
        {
            iIndex = II_FOLDER;
        }
        else
        {
            iIndex = II_DOCNOASSOC;
        }
        hr = SHDefExtractIcon(TEXT("shell32.dll"), iIndex, 0, &hicoLarge, &hicoSmall, cxIcon);
    }

    // Finally! we have an icon or have exhausted all attempts at getting
    // one.  If we got one, go add it and clean up.
    if (hicoSmall)
        DestroyIcon(hicoSmall);

    return hicoLarge;
}

int SFTBarHost::_ExtractImageForItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    int iIcon = -1;     // assume no icon
    HICON hIcon = _IconOf(psf, pidl, _cxIcon);

    if (hIcon)
    {
        iIcon = AddImage(hIcon);
        DestroyIcon(hIcon);
    }

    return iIcon;
}

//
//  There are two sets of numbers that keep track of items.  Sorry.
//  (I tried to reduce it to one, but things got hairy.)
//
//  1. Position numbers.  Separators occupy a position number.
//  2. Item numbers (listview).  Separators do not consume an item number.
//
//  Example:
//
//              iPos        iItem
//
//  A           0           0
//  B           1           1
//  ----        2           N/A
//  C           3           2
//  ----        4           N/A
//  D           5           3
//
//  _rgiSep[] = { 2, 4 };
//
//  _PosToItemNo and _ItemNoToPos do the conversion.

int SFTBarHost::_PosToItemNo(int iPos)
{
    // Subtract out the slots occupied by separators.
    int iItem = iPos;
    for (int i = 0; i < _cSep && _rgiSep[i] < iPos; i++)
    {
        iItem--;
    }
    return iItem;
}

int SFTBarHost::_ItemNoToPos(int iItem)
{
    // Add in the slots occupied by separators.
    int iPos = iItem;
    for (int i = 0; i < _cSep && _rgiSep[i] <= iPos; i++)
    {
        iPos++;
    }
    return iPos;
}

void SFTBarHost::_ComputeListViewItemPosition(int iItem, POINT *pptOut)
{
    // WARNING!  _InternalRepopulateList uses an incremental version of this
    // algorithm.  Keep the two in sync!

    ASSERT(_cyTilePadding >= 0);

    int y = iItem * _cyTile;

    // Adjust for all the separators in the list
    for (int i = 0; i < _cSep; i++)
    {
        if (_rgiSep[i] < iItem)
        {
            y = y - _cyTile + _cySepTile;
        }
    }

    pptOut->x = _cxMargin;
    pptOut->y = y;
}

int SFTBarHost::_InsertListViewItem(int iPos, PaneItem *pitem)
{
    ASSERT(pitem);

    int iItem = -1;
    IShellFolder *psf = NULL;
    LPCITEMIDLIST pidl = NULL;
    LVITEM lvi;
    lvi.pszText = NULL;

    lvi.mask = 0;

    // If necessary, tell listview that we want to use column 1
    // as the subtitle.
    if (_iconsize == ICONSIZE_LARGE && pitem->HasSubtitle())
    {
        const static UINT One = 1;
        lvi.mask = LVIF_COLUMNS;
        lvi.cColumns = 1;
        lvi.puColumns = const_cast<UINT*>(&One);
    }

    ASSERT(!pitem->IsSeparator());

    lvi.mask |= LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    if (FAILED(GetFolderAndPidl(pitem, &psf, &pidl)))
    {
        goto exit;
    }

    if (lvi.mask & LVIF_IMAGE)
    {
        lvi.iImage = AddImageForItem(pitem, psf, pidl, iPos);
    }

    if (lvi.mask & LVIF_TEXT)
    {
        if (_iconsize == ICONSIZE_SMALL && pitem->HasSubtitle())
        {
            lvi.pszText = SubtitleOfItem(pitem, psf, pidl);
        }
        else
        {
            lvi.pszText = DisplayNameOfItem(pitem, psf, pidl, SHGDN_NORMAL);
        }
        if (!lvi.pszText)
        {
            goto exit;
        }
    }

    lvi.iItem = iPos;
    lvi.iSubItem = 0;
    lvi.lParam = reinterpret_cast<LPARAM>(pitem);
    iItem = ListView_InsertItem(_hwndList, &lvi);

    // If the item has a subtitle, add it.
    // If this fails, don't worry.  The subtitle is just a fluffy bonus thing.
    if (iItem >= 0 && (lvi.mask & LVIF_COLUMNS))
    {
        lvi.iItem = iItem;
        lvi.iSubItem = 1;
        lvi.mask = LVIF_TEXT;
        SHFree(lvi.pszText);
        lvi.pszText = SubtitleOfItem(pitem, psf, pidl);
        if (lvi.pszText)
        {
            ListView_SetItem(_hwndList, &lvi);
        }
    }

exit:
    ATOMICRELEASE(psf);
    SHFree(lvi.pszText);
    return iItem;
}


// Add items to our view, or at least as many as will fit

void SFTBarHost::_RepopulateList()
{
    //
    //  Kill the async enum animation now that we're ready
    //
    if (_idtAni)
    {
        KillTimer(_hwnd, _idtAni);
        _idtAni = 0;
    }
    if (_hwndAni)
    {
        if (_hBrushAni)
        {
            DeleteObject(_hBrushAni);
            _hBrushAni = NULL;
        }
        DestroyWindow(_hwndAni);
        _hwndAni = NULL;
    }

    // Let's see if anything changed
    BOOL fChanged = FALSE;
    if (_fForceChange)
    {
        _fForceChange = FALSE;
        fChanged = TRUE;
    }
    else if (_dpaEnum.GetPtrCount() == _dpaEnumNew.GetPtrCount())
    {
        int iMax = _dpaEnum.GetPtrCount();
        int i;
        for (i=0; i<iMax; i++)
        {
            if (!_dpaEnum.FastGetPtr(i)->IsEqual(_dpaEnumNew.FastGetPtr(i)))
            {
                fChanged = TRUE;
                break;
            }
        }
    }
    else
    {
        fChanged = TRUE;
    }


    // No need to do any real work if nothing changed.
    if (fChanged)
    {
        // Now move the _dpaEnumNew to _dpaEnum
        // Clear out the old DPA, we don't need it anymore
        _dpaEnum.EnumCallbackEx(PaneItem::DPAEnumCallback, (void *)NULL);
        _dpaEnum.DeleteAllPtrs();

        // switch DPAs now
        CDPA<PaneItem> dpaTemp = _dpaEnum;
        _dpaEnum = _dpaEnumNew;
        _dpaEnumNew = dpaTemp;

        _InternalRepopulateList();
    }
    else
    {
        // Clear out the new DPA, we don't need it anymore
        _dpaEnumNew.EnumCallbackEx(PaneItem::DPAEnumCallback, (void *)NULL);
        _dpaEnumNew.DeleteAllPtrs();
    }

    _fNeedsRepopulate = FALSE;
}

// The internal version is when we decide to repopulate on our own,
// not at the prompting of the background thread.  (Therefore, we
// don't nuke the animation.)

void SFTBarHost::_InternalRepopulateList()
{

    //
    //  Start with a clean slate.
    //

    ListView_DeleteAllItems(_hwndList);
    if (_IsPrivateImageList())
    {
        ImageList_RemoveAll(_himl);
    }

    int cPinned = 0;
    int cNormal = 0;

    _DebugConsistencyCheck();

    SetWindowRedraw(_hwndList, FALSE);

    DEBUG_CODE(_fPopulating++);

    //
    //  To populate the list, we toss the pinned items at the top,
    //  then let the enumerated items flow beneath them.
    //
    //  Separator "items" don't get added to the listview.  They
    //  are added to the special "separators list".
    //
    //  WARNING!  We are computing incrementally the same values as
    //  _ComputeListViewItemPosition.  Keep the two in sync.
    //

    int iPos;                   // the slot we are trying to fill
    int iEnum;                  // the item index we will fill it from
    int y = 0;                  // where the next item should be placed
    BOOL fSepSeen = FALSE;      // have we seen a separator yet?
    PaneItem *pitem;            // the item that will fill it

    _cSep = 0;                  // no separators (yet)

    RECT rc;
    GetClientRect(_hwndList, &rc);
    //
    //  Subtract out the bonus separator used by SPP_PROGLIST
    //
    if (_iThemePart == SPP_PROGLIST)
    {
        rc.bottom -= _cySep;
    }

    // Note that the loop control must be a _dpaEnum.GetPtr(), not a
    // _dpaEnum.FastGetPtr(), because iEnum can go past the end of the
    // array if we do't have enough items to fill the view.
    //
    //
    // The "while" condition is "there is room for another non-separator
    // item and there are items remaining in the enumeration".

    BOOL fCheckMaxLength = HasDynamicContent();

    for (iPos = iEnum = 0;
        (pitem = _dpaEnum.GetPtr(iEnum)) != NULL;
        iEnum++)
    {
        if (fCheckMaxLength)
        {
            if (y + _cyTile > rc.bottom)
            {
                break;
            }

            // Once we hit a separator, check if we satisfied the number
            // of normal items.  We have to wait until a separator is
            // hit, because _cNormalDesired can be zero; otherwise we
            // would end up stopping before adding even the pinned items!
            if (fSepSeen && cNormal >= _cNormalDesired)
            {
                break;
            }
        }

#ifdef DEBUG
        // Make sure that we are in sync with _ComputeListViewItemPosition
        POINT pt;
        _ComputeListViewItemPosition(iPos, &pt);
        ASSERT(pt.x == _cxMargin);
        ASSERT(pt.y == y);
#endif
        if (pitem->IsSeparator())
        {
            fSepSeen = TRUE;

            // Add the separator, but only if it actually separate something.
            // If this EVAL fires, it means somebody added a separator
            // and MAX_SEPARATORS needs to be increased.
            if (iPos > 0 && EVAL(_cSep < ARRAYSIZE(_rgiSep)))
            {
                _rgiSep[_cSep++] = iPos++;
                y += _cySepTile;
            }
        }
        else
        {
            if (_InsertListViewItem(iPos, pitem) >= 0)
            {
                pitem->_iPos = iPos++;
                y += _cyTile;
                if (pitem->IsPinned())
                {
                    cPinned++;
                }
                else
                {
                    cNormal++;
                }
            }
        }
    }

    //
    //  If the last item was a separator, then delete it
    //  since it's not actually separating anything.
    //
    if (_cSep && _rgiSep[_cSep-1] == iPos - 1)
    {
        _cSep--;
    }


    _cPinned = cPinned;

    //
    //  Now put the items where they belong.
    //
    _RepositionItems();

    DEBUG_CODE(_fPopulating--);

    SetWindowRedraw(_hwndList, TRUE);

    // Now, we need to go update our cached bitmap version of the start menu.
    _SendNotify(_hwnd, SMN_NEEDREPAINT, NULL);

    _DebugConsistencyCheck();
}

LRESULT SFTBarHost::_OnCreate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    GetClientRect(_hwnd, &rc);

    if (_hTheme)
    {
        GetThemeMargins(_hTheme, NULL, _iThemePart, 0, TMT_CONTENTMARGINS, &rc, &_margins);
    }
    else
    {
        _margins.cyTopHeight = 2*GetSystemMetrics(SM_CXEDGE);
        _margins.cxLeftWidth = 2*GetSystemMetrics(SM_CXEDGE);
        _margins.cxRightWidth = 2*GetSystemMetrics(SM_CXEDGE);
    }


    //
    //  Now to create the listview.
    //

    DWORD dwStyle = WS_CHILD | WS_VISIBLE |
              WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
              // Do not set WS_TABSTOP; SFTBarHost handles tabbing
              LVS_LIST |
              LVS_SINGLESEL |
              LVS_NOSCROLL |
              LVS_SHAREIMAGELISTS;

    if (_dwFlags & HOSTF_CANRENAME)
    {
        dwStyle |= LVS_EDITLABELS;
    }

    DWORD dwExStyle = 0;

    _hwndList = CreateWindowEx(dwExStyle, WC_LISTVIEW, NULL, dwStyle,
                               _margins.cxLeftWidth, _margins.cyTopHeight, rc.right, rc.bottom,     // no point in being too exact, we'll be resized later
                               _hwnd, NULL,
                               _Module.GetModuleInstance(), NULL);
    if (!_hwndList) 
        return -1;

    //
    //  Don't freak out if this fails.  It just means that the accessibility
    //  stuff won't be perfect.
    //
    SetAccessibleSubclassWindow(_hwndList);

    //
    //  Create two dummy columns.  We will never display them, but they
    //  are necessary so that we have someplace to put our subtitle.
    //
    LVCOLUMN lvc;
    lvc.mask = LVCF_WIDTH;
    lvc.cx = 1;
    ListView_InsertColumn(_hwndList, 0, &lvc);
    ListView_InsertColumn(_hwndList, 1, &lvc);

    //
    //  If we are topmost, then force the tooltip topmost, too.
    //  Otherwise we end up covering our own tooltip!
    //
    if (GetWindowExStyle(GetAncestor(_hwnd, GA_ROOT)) & WS_EX_TOPMOST)
    {
        HWND hwndTT = ListView_GetToolTips(_hwndList);
        if (hwndTT)
        {
            SetWindowPos(hwndTT, HWND_TOPMOST, 0, 0, 0, 0,
                         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
        }
    }

    // Must do Marlett after doing the listview font, because we base the
    // Marlett font metrics on the listview font metrics (so they match)
    if (_dwFlags & HOSTF_CASCADEMENU)
    {
        if (!_CreateMarlett()) 
            return -1;
    }

    // We can survive if these objects fail to be created
    CoCreateInstance(CLSID_DragDropHelper, NULL, CLSCTX_INPROC_SERVER,
                     IID_PPV_ARG(IDropTargetHelper, &_pdth));
    CoCreateInstance(CLSID_DragDropHelper, NULL, CLSCTX_INPROC_SERVER,
                     IID_PPV_ARG(IDragSourceHelper, &_pdsh));

    //
    // If this fails, no big whoop - you just don't get
    // drag/drop, boo hoo.
    //
    RegisterDragDrop(_hwndList, this);

    //  If this fails, then disable "fancy droptarget" since we won't be
    //  able to manage it properly.
    if (!SetWindowSubclass(_hwndList, s_DropTargetSubclassProc, 0,
                           reinterpret_cast<DWORD_PTR>(this)))
    {
        ATOMICRELEASE(_pdth);
    }

    if (!_dpaEnum.Create(4)) 
        return -1;

    if (!_dpaEnumNew.Create(4)) 
        return -1;

    //-------------------------
    // Imagelist goo

    int iIconSize = ReadIconSize();

    Shell_GetImageLists(iIconSize ? &_himl : NULL, iIconSize ? NULL : &_himl);

    if (!_himl) 
        return -1;

    // Preload values in case GetIconSize barfs
    _cxIcon = GetSystemMetrics(iIconSize ? SM_CXICON : SM_CXSMICON);
    _cyIcon = GetSystemMetrics(iIconSize ? SM_CYICON : SM_CYSMICON);
    ImageList_GetIconSize(_himl, &_cxIcon, &_cyIcon);

    //
    //  If we asked for the MEDIUM-sized icons, then create the real
    //  image list based on the system image list.
    //
    _iconsize = (ICONSIZE)iIconSize;
    if (_iconsize == ICONSIZE_MEDIUM)
    {
        // These upcoming computations rely on the fact that ICONSIZE_LARGE
        // and ICONSIZE_MEDIUM are both nonzero so when we fetched the icon
        // sizes for ICONSIZE_MEDIUM, we got SM_CXICON (large).
        COMPILETIME_ASSERT(ICONSIZE_LARGE && ICONSIZE_MEDIUM);

        // SM_CXICON is the size of shell large icons.  SM_CXSMICON is *not*
        // the size of shell small icons!  It is the size of caption small
        // icons.  Shell small icons are always 50% of shell large icons.
        // We want to be halfway between shell small (50%) and shell
        // large (100%); i.e., we want 75%.
        _cxIcon = _cxIcon * 3 / 4;
        _cyIcon = _cyIcon * 3 / 4;

        //
        //  When the user is in Large Icon mode, we end up choosing 36x36
        //  (halfway between 24x24 and 48x48), but there is no 36x36 icon
        //  in the icon resource.  But we do have a 32, which is close
        //  enough.  (If we didn't do this, then the 36x36 icon would be
        //  the 32x32 icon stretched, which looks ugly.)
        //
        //  So any square icon in the range 28..36 we round to 32.
        //
        if (_cxIcon == _cyIcon && _cxIcon >= 28 && _cxIcon <= 36)
        {
            _cxIcon = _cyIcon = 32;
        }

        // It is critical that we overwrite _himl even on failure, so our
        // destructor doesn't try to destroy a system image list!
        _himl = ImageList_Create(_cxIcon, _cyIcon, ImageList_GetFlags(_himl), 8, 2);
        if (!_himl)
        {
            return -1;
        }
    }

    ListView_SetImageList(_hwndList, _himl, LVSIL_NORMAL);

    // Register for SHCNE_UPDATEIMAGE so we know when to reload our icons
    _RegisterNotify(SFTHOST_HOSTNOTIFY_UPDATEIMAGE, SHCNE_UPDATEIMAGE, NULL, FALSE);

    //-------------------------

    _cxMargin = GetSystemMetrics(SM_CXEDGE);
    _cyMargin = GetSystemMetrics(SM_CYEDGE);

    _cyTilePadding = 0;

    _ComputeTileMetrics();

    //
    //  In the themed case, the designers want a narrow separator.
    //  In the nonthemed case, we need a fat separator because we need
    //  to draw an etch (which requires two pixels).
    //
    if (_hTheme)
    {
        SIZE siz={0};
        GetThemePartSize(_hTheme, NULL, _iThemePartSep, 0, NULL, TS_TRUE, &siz);
        _cySep = siz.cy;
    }
    else
    {
        _cySep = GetSystemMetrics(SM_CYEDGE);
    }

    _cySepTile = 4 * _cySep;

    ASSERT(rc.left == 0 && rc.top == 0); // Should still be a client rectangle
    _SetTileWidth(rc.right);             // so rc.right = RCWIDTH and rc.bottom = RCHEIGHT

    // In tile view, full-row-select really means full-tile-select
    DWORD dwLvExStyle = LVS_EX_INFOTIP |
                        LVS_EX_FULLROWSELECT;

    if (!GetSystemMetrics(SM_REMOTESESSION) && !GetSystemMetrics(SM_REMOTECONTROL))
    {
        dwLvExStyle |= LVS_EX_DOUBLEBUFFER;
    }

    ListView_SetExtendedListViewStyleEx(_hwndList, dwLvExStyle,
                                                   dwLvExStyle);
    if (!_hTheme)
    {
        ListView_SetTextColor(_hwndList, GetSysColor(COLOR_MENUTEXT));
        _clrHot = GetSysColor(COLOR_MENUTEXT);
        _clrBG = GetSysColor(COLOR_MENU);       // default color for no theme case
        _clrSubtitle = CLR_NONE;

    }
    else
    {
        COLORREF clrText;

        GetThemeColor(_hTheme, _iThemePart, 0, TMT_HOTTRACKING, &_clrHot);  // todo - use state
        GetThemeColor(_hTheme, _iThemePart, 0, TMT_CAPTIONTEXT, &_clrSubtitle);
        _clrBG = CLR_NONE; 
    
        GetThemeColor(_hTheme, _iThemePart, 0, TMT_TEXTCOLOR, &clrText);
        ListView_SetTextColor(_hwndList, clrText);
        ListView_SetOutlineColor(_hwndList, _clrHot);
    }

    ListView_SetBkColor(_hwndList, _clrBG);
    ListView_SetTextBkColor(_hwndList, _clrBG);


    ListView_SetView(_hwndList, LV_VIEW_TILE);

    // USER will send us a WM_SIZE after the WM_CREATE, which will cause
    // the listview to repopulate, if we chose to repopulate in the
    // foreground.

    return 0;

}

BOOL SFTBarHost::_CreateMarlett()
{
    HDC hdc = GetDC(_hwndList);
    if (hdc)
    {
        HFONT hfPrev = SelectFont(hdc, GetWindowFont(_hwndList));
        if (hfPrev)
        {
            TEXTMETRIC tm;
            if (GetTextMetrics(hdc, &tm))
            {
                LOGFONT lf;
                ZeroMemory(&lf, sizeof(lf));
                lf.lfHeight = tm.tmAscent;
                lf.lfWeight = FW_NORMAL;
                lf.lfCharSet = SYMBOL_CHARSET;
                StrCpyN(lf.lfFaceName, TEXT("Marlett"), ARRAYSIZE(lf.lfFaceName));
                _hfMarlett = CreateFontIndirect(&lf);

                if (_hfMarlett)
                {
                    SelectFont(hdc, _hfMarlett);
                    if (GetTextMetrics(hdc, &tm))
                    {
                        _tmAscentMarlett = tm.tmAscent;
                        SIZE siz;
                        if (GetTextExtentPoint(hdc, TEXT("8"), 1, &siz))
                        {
                            _cxMarlett = siz.cx;
                        }
                    }
                }
            }

            SelectFont(hdc, hfPrev);
        }
        ReleaseDC(_hwndList, hdc);
    }

    return _cxMarlett;
}

void SFTBarHost::_CreateBoldFont()
{
    if (!_hfBold)
    {
        HFONT hf = GetWindowFont(_hwndList);
        if (hf)
        {
            LOGFONT lf;
            if (GetObject(hf, sizeof(lf), &lf))
            {
                lf.lfWeight = FW_BOLD;
                SHAdjustLOGFONT(&lf); // locale-specific adjustments
                _hfBold = CreateFontIndirect(&lf);
            }
        }
    }
}

void SFTBarHost::_ReloadText()
{
    int iItem;
    for (iItem = ListView_GetItemCount(_hwndList) - 1; iItem >= 0; iItem--)
    {
        TCHAR szText[MAX_PATH];
        LVITEM lvi;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_PARAM | LVIF_TEXT;
        lvi.pszText = szText;
        lvi.cchTextMax = ARRAYSIZE(szText);
        if (ListView_GetItem(_hwndList, &lvi))
        {
            PaneItem *pitem = _GetItemFromLVLParam(lvi.lParam);
            if (!pitem)
            {
                break;
            }


            // Update the display name in case it changed behind our back.
            // Note that this is not redundant with the creation of the items
            // in _InsertListViewItem because this is done only on the second
            // and subsequent enumeration.  (We assume the first enumeration
            // is just peachy.)
            lvi.iItem = iItem;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_TEXT;
            lvi.pszText = _DisplayNameOfItem(pitem, SHGDN_NORMAL);
            if (lvi.pszText)
            {
                if (StrCmpN(szText, lvi.pszText, ARRAYSIZE(szText)) != 0)
                {
                    ListView_SetItem(_hwndList, &lvi);
                    _SendNotify(_hwnd, SMN_NEEDREPAINT, NULL);
                }
                SHFree(lvi.pszText);
            }
        }
    }
}

void SFTBarHost::_RevalidateItems()
{
    // If client does not require revalidation, then assume still valid
    if (!(_dwFlags & HOSTF_REVALIDATE))
    {
        return;
    }

    int iItem;
    for (iItem = ListView_GetItemCount(_hwndList) - 1; iItem >= 0; iItem--)
    {
        PaneItem *pitem = _GetItemFromLV(iItem);
        if (!pitem || !IsItemStillValid(pitem))
        {
            _fEnumValid = FALSE;
            break;
        }
    }
}

void SFTBarHost::_RevalidatePostPopup()
{
    _RevalidateItems();

    if (_dwFlags & HOSTF_RELOADTEXT)
    {
        SetTimer(_hwnd, IDT_RELOADTEXT, 250, NULL);
    }
    // If the list is still good, then don't bother redoing it
    if (!_fEnumValid)
    {
        _EnumerateContents(FALSE);
    }
}

void SFTBarHost::_EnumerateContents(BOOL fUrgent)
{
    // If we have deferred refreshes until the window closes, then
    // leave it alone.
    if (!fUrgent && _fNeedsRepopulate)
    {
        return;
    }

    // If we're already enumerating, then just remember to do it again
    if (_fBGTask)
    {
        // accumulate urgency so a low-priority request + an urgent request
        // is treated as urgent
        _fRestartUrgent |= fUrgent;
        _fRestartEnum = TRUE;
        return;
    }

    _fRestartEnum = FALSE;
    _fRestartUrgent = FALSE;

    // If the list is still good, then don't bother redoing it
    if (_fEnumValid && !fUrgent)
    {
        return;
    }

    // This re-enumeration will make everything valid.
    _fEnumValid = TRUE;

    // Clear out all the leftover stuff from the previous enumeration

    _dpaEnumNew.EnumCallbackEx(PaneItem::DPAEnumCallback, (void *)NULL);
    _dpaEnumNew.DeleteAllPtrs();

    // Let client do some work on the foreground thread
    PrePopulate();

    // Finish the enumeration either on the background thread (if requested)
    // or on the foreground thread (if can't enumerate in the background).

    HRESULT hr;
    if (NeedBackgroundEnum())
    {
        if (_psched)
        {
            hr = S_OK;
        }
        else
        {
            // We need a separate task scheduler for each instance
            hr = CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC_SERVER,
                                  IID_PPV_ARG(IShellTaskScheduler, &_psched));
        }

        if (SUCCEEDED(hr))
        {
            CBGEnum *penum = new CBGEnum(this, fUrgent);
            if (penum)
            {

            // We want to run at a priority slightly above normal
            // because the user is sitting there waiting for the
            // enumeration to complete.
#define ITSAT_BGENUM_PRIORITY (ITSAT_DEFAULT_PRIORITY + 0x1000)

                hr = _psched->AddTask(penum, TOID_SFTBarHostBackgroundEnum, (DWORD_PTR)this, ITSAT_BGENUM_PRIORITY);
                if (SUCCEEDED(hr))
                {
                    _fBGTask = TRUE;

                    if (ListView_GetItemCount(_hwndList) == 0)
                    {
                        //
                        //  Set a timer that will create the "please wait"
                        //  animation if the enumeration takes too long.
                        //
                        _idtAni = IDT_ASYNCENUM;
                        SetTimer(_hwnd, _idtAni, 1000, NULL);
                    }
                }
                penum->Release();
            }
        }
    }

    if (!_fBGTask)
    {
        // Fallback: Do it on the foreground thread
        _EnumerateContentsBackground();
        _RepopulateList();
    }
}


void SFTBarHost::_EnumerateContentsBackground()
{
    // Start over

    DEBUG_CODE(_fEnumerating = TRUE);
    EnumItems();
    DEBUG_CODE(_fEnumerating = FALSE);

#ifdef _ALPHA_
    // Alpha compiler is lame
    _dpaEnumNew.Sort((CDPA<PaneItem>::_PFNDPACOMPARE)_SortItemsAfterEnum, (LPARAM)this);
#else
    _dpaEnumNew.SortEx(_SortItemsAfterEnum, this);
#endif
}

int CALLBACK SFTBarHost::_SortItemsAfterEnum(PaneItem *p1, PaneItem *p2, SFTBarHost *self)
{

    //
    //  Put all pinned items (sorted by pin position) ahead of unpinned items.
    //
    if (p1->IsPinned())
    {
        if (p2->IsPinned())
        {
            return p1->GetPinPos() - p2->GetPinPos();
        }
        return -1;
    }
    else if (p2->IsPinned())
    {
        return +1;
    }

    //
    //  Both unpinned - let the client decide.
    //
    return self->CompareItems(p1, p2);
}

SFTBarHost::~SFTBarHost()
{
    // We shouldn't be destroyed while in these temporary states.
    // If this fires, it's possible that somebody incremented
    // _fListUnstable/_fPopulating and forgot to decrement it.
    ASSERT(!_fListUnstable);
    ASSERT(!_fPopulating);

    ATOMICRELEASE(_pdth);
    ATOMICRELEASE(_pdsh);
    ATOMICRELEASE(_psched);
    ASSERT(_pdtoDragOut == NULL);

    if (_dpaEnum)
    {
        _dpaEnum.DestroyCallbackEx(PaneItem::DPAEnumCallback, (void *)NULL);
    }

    if (_dpaEnumNew)
    {
        _dpaEnumNew.DestroyCallbackEx(PaneItem::DPAEnumCallback, (void *)NULL);
    }

    if (_IsPrivateImageList() && _himl)
    {
        ImageList_Destroy(_himl);
    }

    if (_hfList)
    {
        DeleteObject(_hfList);
    }

    if (_hfBold)
    {
        DeleteObject(_hfBold);
    }

    if (_hfMarlett)
    {
        DeleteObject(_hfMarlett);
    }

    if (_hBrushAni)
    {
        DeleteObject(_hBrushAni);
    }
}

LRESULT SFTBarHost::_OnDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UINT id;
    for (id = 0; id < SFTHOST_MAXNOTIFY; id++)
    {
        UnregisterNotify(id);
    }

    if (_hwndList)
    {
        RevokeDragDrop(_hwndList);
    }
    return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT SFTBarHost::_OnNcDestroy(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // WARNING!  "this" might be NULL (if WM_NCCREATE failed).
    LRESULT lres = DefWindowProc(hwnd, uMsg, wParam, lParam);
    SetWindowPtr0(hwnd, 0);
    if (this) {
        _hwndList = NULL;
        _hwnd = NULL;
        if (_psched)
        {
            // Remove all tasks now, and wait for them to finish
            _psched->RemoveTasks(TOID_NULL, ITSAT_DEFAULT_LPARAM, TRUE);
            ATOMICRELEASE(_psched);
        }
        Release();
    }
    return lres;
}

LRESULT SFTBarHost::_OnNotify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPNMHDR pnm = reinterpret_cast<LPNMHDR>(lParam);
    if (pnm->hwndFrom == _hwndList)
    {
        switch (pnm->code)
        {
        case NM_CUSTOMDRAW:
            return _OnLVCustomDraw(CONTAINING_RECORD(
                                   CONTAINING_RECORD(pnm, NMCUSTOMDRAW, hdr),
                                                          NMLVCUSTOMDRAW, nmcd));
        case NM_CLICK:
            return _OnLVNItemActivate(CONTAINING_RECORD(pnm, NMITEMACTIVATE, hdr));

        case NM_RETURN:
            return _ActivateItem(_GetLVCurSel(), AIF_KEYBOARD);

        case NM_KILLFOCUS:
            // On loss of focus, deselect all items so they all draw
            // in the plain state.
            ListView_SetItemState(_hwndList, -1, 0, LVIS_SELECTED | LVIS_FOCUSED);
            break;

        case LVN_GETINFOTIP:
            return _OnLVNGetInfoTip(CONTAINING_RECORD(pnm, NMLVGETINFOTIP, hdr));

        case LVN_BEGINDRAG:
        case LVN_BEGINRDRAG:
            return _OnLVNBeginDrag(CONTAINING_RECORD(pnm, NMLISTVIEW, hdr));

        case LVN_BEGINLABELEDIT:
            return _OnLVNBeginLabelEdit(CONTAINING_RECORD(pnm, NMLVDISPINFO, hdr));

        case LVN_ENDLABELEDIT:
            return _OnLVNEndLabelEdit(CONTAINING_RECORD(pnm, NMLVDISPINFO, hdr));

        case LVN_KEYDOWN:
            return _OnLVNKeyDown(CONTAINING_RECORD(pnm, NMLVKEYDOWN, hdr));
        }
    }
    else
    {
        switch (pnm->code)
        {
        case SMN_INITIALUPDATE:
            _EnumerateContents(FALSE);
            break;

        case SMN_POSTPOPUP:
            _RevalidatePostPopup();
            break;

        case SMN_GETMINSIZE:
            return _OnSMNGetMinSize(CONTAINING_RECORD(pnm, SMNGETMINSIZE, hdr));
            break;

        case SMN_FINDITEM:
            return _OnSMNFindItem(CONTAINING_RECORD(pnm, SMNDIALOGMESSAGE, hdr));
        case SMN_DISMISS:
            return _OnSMNDismiss();

        case SMN_APPLYREGION:
            return HandleApplyRegion(_hwnd, _hTheme, (SMNMAPPLYREGION *)lParam, _iThemePart, 0);

        case SMN_SHELLMENUDISMISSED:
            _iCascading = -1;
            return 0;
        }
    }

    // Give derived class a chance to respond
    return OnWndProc(hwnd, uMsg, wParam, lParam);
}

LRESULT SFTBarHost::_OnTimer(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wParam)
    {
    case IDT_ASYNCENUM:
        KillTimer(hwnd, wParam);

        // For some reason, we sometimes get spurious WM_TIMER messages,
        // so ignore them if we aren't expecting them.
        if (_idtAni)
        {
            _idtAni = 0;
            if (_hwndList && !_hwndAni)
            {
                DWORD dwStyle = WS_CHILD | WS_VISIBLE |
                                WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                                ACS_AUTOPLAY | ACS_TIMER | ACS_TRANSPARENT;

                RECT rcClient;
                GetClientRect(_hwnd, &rcClient);
                int x = (RECTWIDTH(rcClient) - ANIWND_WIDTH)/2;     // IDA_SEARCH is ANIWND_WIDTH pix wide
                int y = (RECTHEIGHT(rcClient) - ANIWND_HEIGHT)/2;    // IDA_SEARCH is ANIWND_HEIGHT pix tall

                _hwndAni = CreateWindow(ANIMATE_CLASS, NULL, dwStyle,
                                        x, y, 0, 0,
                                        _hwnd, NULL,
                                        _Module.GetModuleInstance(), NULL);
                if (_hwndAni)
                {
                    SetWindowPos(_hwndAni, HWND_TOP, 0, 0, 0, 0,
                                 SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);
                    #define IDA_SEARCH 150 // from shell32
                    Animate_OpenEx(_hwndAni, GetModuleHandle(TEXT("SHELL32")), MAKEINTRESOURCE(IDA_SEARCH));
                }
            }
        }
        return 0;
    case IDT_RELOADTEXT:
        KillTimer(hwnd, wParam);
        _ReloadText();
        break;

    case IDT_REFRESH:
        KillTimer(hwnd, wParam);
        PostMessage(hwnd, SFTBM_REFRESH, FALSE, 0);
        break;
    }

    // Give derived class a chance to respond
    return OnWndProc(hwnd, uMsg, wParam, lParam);
}

LRESULT SFTBarHost::_OnSetFocus(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (_hwndList)
    {
        SetFocus(_hwndList);
    }
    return 0;
}

LRESULT SFTBarHost::_OnEraseBackground(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    GetClientRect(hwnd, &rc);
    if (_hTheme)
        DrawThemeBackground(_hTheme, (HDC)wParam, _iThemePart, 0, &rc, 0);
    else
    {
        SHFillRectClr((HDC)wParam, &rc, _clrBG);
        if (_iThemePart == SPP_PLACESLIST)                  // we set this even in non-theme case, its how we tell them apart
            DrawEdge((HDC)wParam, &rc, EDGE_ETCHED, BF_LEFT);
    }

    return TRUE;
}

LRESULT SFTBarHost::_OnLVCustomDraw(LPNMLVCUSTOMDRAW plvcd)
{
    _DebugConsistencyCheck();

    switch (plvcd->nmcd.dwDrawStage)
    {
    case CDDS_PREPAINT:
        return _OnLVPrePaint(plvcd);

    case CDDS_ITEMPREPAINT:
        return _OnLVItemPrePaint(plvcd);

    case CDDS_ITEMPREPAINT | CDDS_SUBITEM:
        return _OnLVSubItemPrePaint(plvcd);

    case CDDS_ITEMPOSTPAINT:
        return _OnLVItemPostPaint(plvcd);

    case CDDS_POSTPAINT:
        return _OnLVPostPaint(plvcd);
    }

    return CDRF_DODEFAULT;
}

//
//  Catch WM_PAINT messages headed to ListView and hide any drop effect
//  so it doesn't interfere with painting.  WM_PAINT messages might nest
//  under extreme conditions, so do this only at outer level.
//
LRESULT CALLBACK SFTBarHost::s_DropTargetSubclassProc(
                             HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                             UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    SFTBarHost *self = reinterpret_cast<SFTBarHost *>(dwRefData);
    LRESULT lres;

    switch (uMsg)
    {
    case WM_PAINT:

        // If entering outermost paint cycle, hide the drop feedback
        ++self->_cPaint;
        if (self->_cPaint == 1 && self->_pdth)
        {
            self->_pdth->Show(FALSE);
        }
        lres = DefSubclassProc(hwnd, uMsg, wParam, lParam);

        // If exiting outermost paint cycle, restore the drop feedback
        // Don't decrement _cPaint until really finished because
        // Show() will call UpdateWindow and trigger a nested paint cycle.
        if (self->_cPaint == 1 && self->_pdth)
        {
            self->_pdth->Show(TRUE);
        }
        --self->_cPaint;

        return lres;

    case WM_NCDESTROY:
        RemoveWindowSubclass(hwnd, s_DropTargetSubclassProc, uIdSubclass);
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

//
//  Listview makes it hard to detect whether you are in a real customdraw
//  or a fake customdraw, since it frequently "gets confused" and gives
//  you a 0x0 rectangle even though it really wants you to draw something.
//
//  Even worse, within a single paint cycle, Listview uses multiple
//  NMLVCUSTOMDRAW structures so you can't stash state inside the customdraw
//  structure.  You have to save it externally.
//
//  The only trustworthy guy is CDDS_PREPAINT.  Use his rectangle to
//  determine whether this is a real or fake customdraw...
//
//  What's even weirder is that inside a regular paint cycle, you
//  can get re-entered with a sub-paint cycle, so we have to maintain
//  a stack of "is the current customdraw cycle real or fake?" bits.

void SFTBarHost::_CustomDrawPush(BOOL fReal)
{
    _dwCustomDrawState = (_dwCustomDrawState << 1) | fReal;
}

BOOL SFTBarHost::_IsRealCustomDraw()
{
    return _dwCustomDrawState & 1;
}

void SFTBarHost::_CustomDrawPop()
{
    _dwCustomDrawState >>= 1;
}

LRESULT SFTBarHost::_OnLVPrePaint(LPNMLVCUSTOMDRAW plvcd)
{
    LRESULT lResult;

    // Always ask for postpaint so we can maintain our customdraw stack
    lResult = CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
    BOOL fReal = !IsRectEmpty(&plvcd->nmcd.rc);
    _CustomDrawPush(fReal);

    return lResult;
}

//
//  Hack!  We want to know in _OnLvSubItemPrePaint whether the item
//  is selected or not,  We borrow the CDIS_CHECKED bit, which is
//  otherwise used only by toolbar controls.
//
#define CDIS_WASSELECTED        CDIS_CHECKED

LRESULT SFTBarHost::_OnLVItemPrePaint(LPNMLVCUSTOMDRAW plvcd)
{
    LRESULT lResult = CDRF_DODEFAULT;

    plvcd->nmcd.uItemState &= ~CDIS_WASSELECTED;

    if (GetFocus() == _hwndList &&
        (plvcd->nmcd.uItemState & CDIS_SELECTED))
    {
        plvcd->nmcd.uItemState |= CDIS_WASSELECTED;

        // menu-highlighted tiles are always opaque
        if (_hTheme)
        {
            plvcd->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
            plvcd->clrFace = plvcd->clrTextBk = GetSysColor(COLOR_MENUHILIGHT);
        }
        else
        {
            plvcd->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
            plvcd->clrFace = plvcd->clrTextBk = GetSysColor(COLOR_HIGHLIGHT);
        }
    }

    // Turn off CDIS_SELECTED because it causes the icon to get alphablended
    // and we don't want that.  Turn off CDIS_FOCUS because that draws a
    // focus rectangle and we don't want that either.

    plvcd->nmcd.uItemState &= ~(CDIS_SELECTED | CDIS_FOCUS);

    //
    if (plvcd->nmcd.uItemState & CDIS_HOT && _clrHot != CLR_NONE)
        plvcd->clrText = _clrHot;

    // Turn off selection highlighting for everyone except
    // the drop target highlight
    if ((int)plvcd->nmcd.dwItemSpec != _iDragOver || !_pdtDragOver)
    {
        lResult |= LVCDRF_NOSELECT;
    }

    PaneItem *pitem = _GetItemFromLVLParam(plvcd->nmcd.lItemlParam);
    if (!pitem)
    {
        // Sometimes ListView doesn't give us an lParam so we have to
        // get it ourselves
        pitem = _GetItemFromLV((int)plvcd->nmcd.dwItemSpec);
    }

    if (pitem)
    {
        if (IsBold(pitem))
        {
            _CreateBoldFont();
            SelectFont(plvcd->nmcd.hdc, _hfBold);
            lResult |= CDRF_NEWFONT;
        }
        if (pitem->IsCascade())
        {
            // Need subitem notification because that's what sets the colors
            lResult |= CDRF_NOTIFYPOSTPAINT | CDRF_NOTIFYSUBITEMDRAW;
        }
        if (pitem->HasAccelerator())
        {
            // Need subitem notification because that's what sets the colors
            lResult |= CDRF_NOTIFYPOSTPAINT | CDRF_NOTIFYSUBITEMDRAW;
        }
        if (pitem->HasSubtitle())
        {
            lResult |= CDRF_NOTIFYSUBITEMDRAW;
        }
    }
    return lResult;
}

LRESULT SFTBarHost::_OnLVSubItemPrePaint(LPNMLVCUSTOMDRAW plvcd)
{
    LRESULT lResult = CDRF_DODEFAULT;
    if (plvcd->iSubItem == 1)
    {
        // Second line uses the regular font (first line was bold)
        SelectFont(plvcd->nmcd.hdc, GetWindowFont(_hwndList));
        lResult |= CDRF_NEWFONT;

        if (GetFocus() == _hwndList &&
            (plvcd->nmcd.uItemState & CDIS_WASSELECTED))
        {
            plvcd->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
        }
        else
        // Maybe there's a custom subtitle color
        if (_clrSubtitle != CLR_NONE)
        {
            plvcd->clrText = _clrSubtitle;
        }
        else
        {
            plvcd->clrText = GetSysColor(COLOR_MENUTEXT);
        }
    }
    return lResult;
}

// QUIRK!  Listview often sends item postpaint messages even though we
// didn't ask for one.  It does this because we set NOTIFYPOSTPAINT on
// the CDDS_PREPAINT notification ("please notify me when the entire
// listview is finished painting") and it thinks that that flag also
// turns on postpaint notifications for each item...

LRESULT SFTBarHost::_OnLVItemPostPaint(LPNMLVCUSTOMDRAW plvcd)
{
    PaneItem *pitem = _GetItemFromLVLParam(plvcd->nmcd.lItemlParam);
    if (_IsRealCustomDraw() && pitem)
    {
        RECT rc;
        if (ListView_GetItemRect(_hwndList, plvcd->nmcd.dwItemSpec, &rc, LVIR_LABEL))
        {
            COLORREF clrBkPrev = SetBkColor(plvcd->nmcd.hdc, plvcd->clrFace);
            COLORREF clrTextPrev = SetTextColor(plvcd->nmcd.hdc, plvcd->clrText);
            int iModePrev = SetBkMode(plvcd->nmcd.hdc, TRANSPARENT);
            BOOL fRTL = GetLayout(plvcd->nmcd.hdc) & LAYOUT_RTL;

            if (pitem->IsCascade())
            {
                {
                    HFONT hfPrev = SelectFont(plvcd->nmcd.hdc, _hfMarlett);
                    if (hfPrev)
                    {
                        TCHAR chOut = fRTL ? TEXT('w') : TEXT('8');
                        UINT fuOptions = 0;
                        if (fRTL)
                        {
                            fuOptions |= ETO_RTLREADING;
                        }

                        ExtTextOut(plvcd->nmcd.hdc, rc.right - _cxMarlett,
                                   rc.top + (rc.bottom - rc.top - _tmAscentMarlett)/2,
                                   fuOptions, &rc, &chOut, 1, NULL);
                        SelectFont(plvcd->nmcd.hdc, hfPrev);
                    }
                }
            }

            if (pitem->HasAccelerator() &&
                (plvcd->nmcd.uItemState & CDIS_SHOWKEYBOARDCUES))
            {
                // Subtitles mess up our computations...
                ASSERT(!pitem->HasSubtitle());

                rc.right -= _cxMarlett; // Subtract out our margin

                UINT uFormat = DT_VCENTER | DT_SINGLELINE | DT_PREFIXONLY |
                               DT_WORDBREAK | DT_EDITCONTROL | DT_WORD_ELLIPSIS;
                if (fRTL)
                {
                    uFormat |= DT_RTLREADING;
                }

                DrawText(plvcd->nmcd.hdc, pitem->_pszAccelerator, -1, &rc, uFormat);
                rc.right += _cxMarlett; // restore it
            }

            SetBkMode(plvcd->nmcd.hdc, iModePrev);
            SetTextColor(plvcd->nmcd.hdc, clrTextPrev);
            SetBkColor(plvcd->nmcd.hdc, clrBkPrev);
        }
    }

    return CDRF_DODEFAULT;
}

LRESULT SFTBarHost::_OnLVPostPaint(LPNMLVCUSTOMDRAW plvcd)
{
    if (_IsRealCustomDraw())
    {
        _DrawInsertionMark(plvcd);
        _DrawSeparators(plvcd);
    }
    _CustomDrawPop();
    return CDRF_DODEFAULT;
}

LRESULT SFTBarHost::_OnUpdateUIState(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Only need to do this when the Start Menu is visible; if not visible, then
    // don't waste your time invalidating useless rectangles (and paging them in!)
    if (IsWindowVisible(GetAncestor(_hwnd, GA_ROOT)))
    {
        // All UIS_SETs should happen when the Start Menu is hidden;
        // we assume that the only thing we will be asked to do is to
        // start showing the underlines

        ASSERT(LOWORD(wParam) != UIS_SET);

        DWORD dwLvExStyle = 0;

        if (!GetSystemMetrics(SM_REMOTESESSION) && !GetSystemMetrics(SM_REMOTECONTROL))
        {
            dwLvExStyle |= LVS_EX_DOUBLEBUFFER;
        }

        if ((ListView_GetExtendedListViewStyle(_hwndList) & LVS_EX_DOUBLEBUFFER) != dwLvExStyle)
        {
            ListView_SetExtendedListViewStyleEx(_hwndList, LVS_EX_DOUBLEBUFFER, dwLvExStyle);
        }

        int iItem;
        for (iItem = ListView_GetItemCount(_hwndList) - 1; iItem >= 0; iItem--)
        {
            PaneItem *pitem = _GetItemFromLV(iItem);
            if (pitem && pitem->HasAccelerator())
            {
                RECT rc;
                if (ListView_GetItemRect(_hwndList, iItem, &rc, LVIR_LABEL))
                {
                    // We need to repaint background because of cleartype double print issues
                    InvalidateRect(_hwndList, &rc, TRUE);
                }
            }
        }
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

PaneItem *SFTBarHost::_GetItemFromLV(int iItem)
{
    LVITEM lvi;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;
    if (iItem >= 0 && ListView_GetItem(_hwndList, &lvi))
    {
        PaneItem *pitem = _GetItemFromLVLParam(lvi.lParam);
        return pitem;
    }
    return NULL;
}

LRESULT SFTBarHost::_OnMenuMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;
    if (_pcm3Pop && SUCCEEDED(_pcm3Pop->HandleMenuMsg2(uMsg, wParam, lParam, &lres)))
    {
        return lres;
    }

    if (_pcm2Pop && SUCCEEDED(_pcm2Pop->HandleMenuMsg(uMsg, wParam, lParam)))
    {
        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

LRESULT SFTBarHost::_OnForwardMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SHPropagateMessage(hwnd, uMsg, wParam, lParam, SPM_SEND | SPM_ONELEVEL);
    // Give derived class a chance to get the message, too
    return OnWndProc(hwnd, uMsg, wParam, lParam);
}

BOOL SFTBarHost::UnregisterNotify(UINT id)
{
    ASSERT(id < SFTHOST_MAXNOTIFY);

    if (id < SFTHOST_MAXNOTIFY && _rguChangeNotify[id])
    {
        UINT uChangeNotify = _rguChangeNotify[id];
        _rguChangeNotify[id] = 0;
        return SHChangeNotifyDeregister(uChangeNotify);
    }
    return FALSE;
}

BOOL SFTBarHost::_RegisterNotify(UINT id, LONG lEvents, LPCITEMIDLIST pidl, BOOL fRecursive)
{
    ASSERT(id < SFTHOST_MAXNOTIFY);

    if (id < SFTHOST_MAXNOTIFY)
    {
        UnregisterNotify(id);

        SHChangeNotifyEntry fsne;
        fsne.fRecursive = fRecursive;
        fsne.pidl = pidl;

        int fSources = SHCNRF_NewDelivery | SHCNRF_ShellLevel | SHCNRF_InterruptLevel;
        if (fRecursive)
        {
            // SHCNRF_RecursiveInterrupt means "Please use a recursive FindFirstChangeNotify"
            fSources |= SHCNRF_RecursiveInterrupt;
        }
        _rguChangeNotify[id] = SHChangeNotifyRegister(_hwnd, fSources, lEvents,
                                                      SFTBM_CHANGENOTIFY + id, 1, &fsne);
        return _rguChangeNotify[id];
    }
    return FALSE;
}

//
//  wParam = 0 if this is not an urgent refresh (can be postponed)
//  wParam = 1 if this is urgent (must refresh even if menu is open)
//
LRESULT SFTBarHost::_OnRepopulate(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Don't update the list now if we are visible, except if the list was empty
    _fBGTask = FALSE;

    if (wParam || !IsWindowVisible(_hwnd) || ListView_GetItemCount(_hwndList) == 0)
    {
        _RepopulateList();
    }
    else
    {
        _fNeedsRepopulate = TRUE;
    }

    if (_fRestartEnum)
    {
        _EnumerateContents(_fRestartUrgent);
    }

    return 0;
}


LRESULT SFTBarHost::_OnChangeNotify(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPITEMIDLIST *ppidl;
    LONG lEvent;
    LPSHChangeNotificationLock pshcnl;
    pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);

    if (pshcnl)
    {
        UINT id = uMsg - SFTBM_CHANGENOTIFY;
        if (id < SFTHOST_MAXCLIENTNOTIFY)
        {
            OnChangeNotify(id, lEvent, ppidl[0], ppidl[1]);
        }
        else if (id == SFTHOST_HOSTNOTIFY_UPDATEIMAGE)
        {
            _OnUpdateImage(ppidl[0], ppidl[1]);
        }
        else
        {
            // Our wndproc shouldn't have dispatched to us
            ASSERT(0);
        }

        SHChangeNotification_Unlock(pshcnl);
    }
    return 0;
}

void SFTBarHost::_OnUpdateImage(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra)
{
    // Must use pidl and not pidlExtra because pidlExtra is sometimes NULL
    SHChangeDWORDAsIDList *pdwidl = (SHChangeDWORDAsIDList *)pidl;
    if (pdwidl->dwItem1 == 0xFFFFFFFF)
    {
        // Wholesale icon rebuild; just pitch everything and start over
        ::PostMessage(v_hwndTray, SBM_REBUILDMENU, 0, 0);
    }
    else
    {
        int iImage = SHHandleUpdateImage(pidlExtra);
        if (iImage >= 0)
        {
            UpdateImage(iImage);
        }
    }
}

//
//  See if anybody is using this image; if so, invalidate the cached bitmap.
//
void SFTBarHost::UpdateImage(int iImage)
{
    ASSERT(!_IsPrivateImageList());

    int iItem;
    for (iItem = ListView_GetItemCount(_hwndList) - 1; iItem >= 0; iItem--)
    {
        LVITEM lvi;
        lvi.iItem = iItem;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_IMAGE;
        if (ListView_GetItem(_hwndList, &lvi) && lvi.iImage == iImage)
        {
            // The cached bitmap is no good; an icon changed
            _SendNotify(_hwnd, SMN_NEEDREPAINT, NULL);
            break;
        }
    }
}

//
//  wParam = 0 if this is not an urgent refresh (can be postponed)
//  wParam = 1 if this is urgen (must refresh even if menu is open)
//
LRESULT SFTBarHost::_OnRefresh(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    _EnumerateContents((BOOL)wParam);
    return 0;
}

LPTSTR _DisplayNameOf(IShellFolder *psf, LPCITEMIDLIST pidl, UINT shgno)
{
    LPTSTR pszOut;
    DisplayNameOfAsOLESTR(psf, pidl, shgno, &pszOut);
    return pszOut;
}

LPTSTR SFTBarHost::_DisplayNameOfItem(PaneItem *pitem, UINT shgno)
{
    IShellFolder *psf;
    LPCITEMIDLIST pidl;
    LPTSTR pszOut = NULL;

    if (SUCCEEDED(_GetFolderAndPidl(pitem, &psf, &pidl)))
    {
        pszOut = DisplayNameOfItem(pitem, psf, pidl, (SHGNO)shgno);
        psf->Release();
    }
    return pszOut;
}

HRESULT SFTBarHost::_GetUIObjectOfItem(PaneItem *pitem, REFIID riid, void * *ppv)
{
    *ppv = NULL;

    IShellFolder *psf;
    LPCITEMIDLIST pidlItem;
    HRESULT hr = _GetFolderAndPidl(pitem, &psf, &pidlItem);
    if (SUCCEEDED(hr))
    {
        hr = psf->GetUIObjectOf(_hwnd, 1, &pidlItem, riid, NULL, ppv);
        psf->Release();
    }

    return hr;
}

HRESULT SFTBarHost::_GetUIObjectOfItem(int iItem, REFIID riid, void * *ppv)
{
    PaneItem *pitem = _GetItemFromLV(iItem);
    if (pitem)
    {
        HRESULT hr = _GetUIObjectOfItem(pitem, riid, ppv);
        return hr;
    }
    return E_FAIL;
}

HRESULT SFTBarHost::_GetFolderAndPidl(PaneItem *pitem, IShellFolder **ppsfOut, LPCITEMIDLIST *ppidlOut)
{
    *ppsfOut = NULL;
    *ppidlOut = NULL;
    return pitem->IsSeparator() ? E_FAIL : GetFolderAndPidl(pitem, ppsfOut, ppidlOut);
}

//
//  Given the coordinates of a context menu (lParam from WM_CONTEXTMENU),
//  determine which item's context menu should be activated, or -1 if the
//  context menu is not for us.
//
//  Also, returns on success in *ppt the coordinates at which the
//  context menu should be displayed.
//
int SFTBarHost::_ContextMenuCoordsToItem(LPARAM lParam, POINT *ppt)
{
    int iItem;
    ppt->x = GET_X_LPARAM(lParam);
    ppt->y = GET_Y_LPARAM(lParam);

    // If initiated from keyboard, act like they clicked on the center
    // of the focused icon.
    if (IS_WM_CONTEXTMENU_KEYBOARD(lParam))
    {
        iItem = _GetLVCurSel();
        if (iItem >= 0)
        {
            RECT rc;
            if (ListView_GetItemRect(_hwndList, iItem, &rc, LVIR_ICON))
            {
                MapWindowRect(_hwndList, NULL, &rc);
                ppt->x = (rc.left+rc.right)/2;
                ppt->y = (rc.top+rc.bottom)/2;
            }
            else
            {
                iItem = -1;
            }
        }
    }
    else
    {
        // Initiated from mouse; find the item they clicked on
        LVHITTESTINFO hti;
        hti.pt = *ppt;
        MapWindowPoints(NULL, _hwndList, &hti.pt, 1);
        iItem = ListView_HitTest(_hwndList, &hti);
    }

    return iItem;
}

LRESULT SFTBarHost::_OnContextMenu(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if(_AreChangesRestricted())
    {
        return 0;
    }

    TCHAR szBuf[MAX_PATH];
    _DebugConsistencyCheck();

    BOOL fSuccess = FALSE;

    POINT pt;
    int iItem = _ContextMenuCoordsToItem(lParam, &pt);

    if (iItem >= 0)
    {
        PaneItem *pitem = _GetItemFromLV(iItem);
        if (pitem)
        {
            // If we can't get the official shell context menu,
            // then use a dummy one.
            IContextMenu *pcm;
            if (FAILED(_GetUIObjectOfItem(pitem, IID_PPV_ARG(IContextMenu, &pcm))))
            {
                pcm = s_EmptyContextMenu.GetContextMenu();
            }

            HMENU hmenu = ::CreatePopupMenu();

            if (hmenu)
            {
                UINT uFlags = CMF_NORMAL;
                if (GetKeyState(VK_SHIFT) < 0)
                {
                    uFlags |= CMF_EXTENDEDVERBS;
                }

                if (_dwFlags & HOSTF_CANRENAME)
                {
                    uFlags |= CMF_CANRENAME;
                }

                pcm->QueryContextMenu(hmenu, 0, IDM_QCM_MIN, IDM_QCM_MAX, uFlags);

                // Remove "Create shortcut" from context menu because it creates
                // the shortcut on the desktop, which the user can't see...
                ContextMenu_DeleteCommandByName(pcm, hmenu, IDM_QCM_MIN, TEXT("link"));

                // Remove "Cut" from context menu because we don't want objects
                // to be deleted.
                ContextMenu_DeleteCommandByName(pcm, hmenu, IDM_QCM_MIN, TEXT("cut"));

                // Let clients override the "delete" option.

                // Change "Delete" to "Remove from this list".
                // If client doesn't support "delete" then nuke it outright.
                // If client supports "delete" but the IContextMenu didn't create one,
                // then create a fake one so we cn add the "Remove from list" option.
                UINT uPosDelete = GetMenuIndexForCanonicalVerb(hmenu, pcm, IDM_QCM_MIN, TEXT("delete"));
                UINT uiFlags = 0;
                UINT idsDelete = AdjustDeleteMenuItem(pitem, &uiFlags);
                if (idsDelete)
                {
                    if (LoadString(_Module.GetResourceInstance(), idsDelete, szBuf, ARRAYSIZE(szBuf)))
                    {
                        if (uPosDelete != -1)
                        {
                            ModifyMenu(hmenu, uPosDelete, uiFlags | MF_BYPOSITION | MF_STRING, IDM_REMOVEFROMLIST, szBuf);
                        }
                        else
                        {
                            AppendMenu(hmenu, MF_SEPARATOR, -1, NULL);
                            AppendMenu(hmenu, uiFlags | MF_STRING, IDM_REMOVEFROMLIST, szBuf);
                        }
                    }
                }
                else
                {
                    DeleteMenu(hmenu, uPosDelete, MF_BYPOSITION);
                }

                _SHPrettyMenu(hmenu);

                ASSERT(_pcm2Pop == NULL);   // Shouldn't be recursing
                pcm->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pcm2Pop));

                ASSERT(_pcm3Pop == NULL);   // Shouldn't be recursing
                pcm->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm3Pop));

                int idCmd = TrackPopupMenuEx(hmenu,
                    TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    pt.x, pt.y, hwnd, NULL);

                ATOMICRELEASE(_pcm2Pop);
                ATOMICRELEASE(_pcm3Pop);

                if (idCmd)
                {
                    switch (idCmd)
                    {
                    case IDM_REMOVEFROMLIST:
                        StrCpyN(szBuf, TEXT("delete"), ARRAYSIZE(szBuf));
                        break;

                    default:
                        ContextMenu_GetCommandStringVerb(pcm, idCmd - IDM_QCM_MIN, szBuf, ARRAYSIZE(szBuf));
                        break;
                    }

                    idCmd -= IDM_QCM_MIN;

                    CMINVOKECOMMANDINFOEX ici = {
                        sizeof(ici),            // cbSize
                        CMIC_MASK_FLAG_LOG_USAGE | // this was an explicit user action
                        CMIC_MASK_ASYNCOK,      // fMask
                        hwnd,                   // hwnd
                        (LPCSTR)IntToPtr(idCmd),// lpVerb
                        NULL,                   // lpParameters
                        NULL,                   // lpDirectory
                        SW_SHOWDEFAULT,         // nShow
                        0,                      // dwHotKey
                        0,                      // hIcon
                        NULL,                   // lpTitle
                        (LPCWSTR)IntToPtr(idCmd),// lpVerbW
                        NULL,                   // lpParametersW
                        NULL,                   // lpDirectoryW
                        NULL,                   // lpTitleW
                        { pt.x, pt.y },         // ptInvoke
                    };

                    if ((_dwFlags & HOSTF_CANRENAME) &&
                        StrCmpI(szBuf, TEXT("rename")) == 0)
                    {
                        _EditLabel(iItem);
                    }
                    else
                    {
                        ContextMenuInvokeItem(pitem, pcm, &ici, szBuf);
                    }
                }

                DestroyMenu(hmenu);

                fSuccess = TRUE;
            }
            pcm->Release();
        }

    }

    _DebugConsistencyCheck();

    return fSuccess ? 0 : DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void SFTBarHost::_EditLabel(int iItem)
{
    _fAllowEditLabel = TRUE;
    ListView_EditLabel(_hwndList, iItem);
    _fAllowEditLabel = FALSE;
}


HRESULT SFTBarHost::ContextMenuInvokeItem(PaneItem *pitem, IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici, LPCTSTR pszVerb)
{
    // Make sure none of our private menu items leaked through
    ASSERT(PtrToLong(pici->lpVerb) >= 0);

    // FUSION: When we call out to 3rd party code we want it to use 
    // the process default context. This means that the 3rd party code will get
    // v5 in the explorer process. However, if shell32 is hosted in a v6 process,
    // then the 3rd party code will still get v6. 
    ULONG_PTR cookie = 0;
    ActivateActCtx(NULL, &cookie); 

    HRESULT hr = pcm->InvokeCommand(reinterpret_cast<LPCMINVOKECOMMANDINFO>(pici));
    
    if (cookie != 0)
    {
        DeactivateActCtx(0, cookie);
    }

    return hr;
}

LRESULT SFTBarHost::_OnLVNItemActivate(LPNMITEMACTIVATE pnmia)
{
    return _ActivateItem(pnmia->iItem, 0);
}

LRESULT SFTBarHost::_ActivateItem(int iItem, DWORD dwFlags)
{
    PaneItem *pitem;
    IShellFolder *psf;
    LPCITEMIDLIST pidl;

    DWORD dwCascadeFlags = 0;
    if (dwFlags & AIF_KEYBOARD)
    {
        dwCascadeFlags = MPPF_KEYBOARD | MPPF_INITIALSELECT;
    }

    if (_OnCascade(iItem, dwCascadeFlags))
    {
        // We did the cascade thing; all finished!
    }
    else
    if ((pitem = _GetItemFromLV(iItem)) &&
        SUCCEEDED(_GetFolderAndPidl(pitem, &psf, &pidl)))
    {
        // See if the item is still valid.
        // Do this only for SFGAO_FILESYSTEM objects because
        // we can't be sure that other folders support SFGAO_VALIDATE,
        // and besides, you can't resolve any other types of objects
        // anyway...

        DWORD dwAttr = SFGAO_FILESYSTEM | SFGAO_VALIDATE;
        if (FAILED(psf->GetAttributesOf(1, &pidl, &dwAttr)) ||
            (dwAttr & SFGAO_FILESYSTEM | SFGAO_VALIDATE) == SFGAO_FILESYSTEM ||
            FAILED(_InvokeDefaultCommand(iItem, psf, pidl)))
        {
            // Object is bogus - offer to delete it
            if ((_dwFlags & HOSTF_CANDELETE) && pitem->IsPinned())
            {
                _OfferDeleteBrokenItem(pitem, psf, pidl);
            }
        }

        psf->Release();
    }
    return 0;
}

HRESULT SFTBarHost::_InvokeDefaultCommand(int iItem, IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = SHInvokeDefaultCommand(GetShellWindow(), psf, pidl);
    if (SUCCEEDED(hr))
    {
        if (_dwFlags & HOSTF_FIREUEMEVENTS)
        {
            _FireUEMPidlEvent(psf, pidl);
        }
        SMNMCOMMANDINVOKED ci;
        ListView_GetItemRect(_hwndList, iItem, &ci.rcItem, LVIR_BOUNDS);
        MapWindowRect(_hwndList, NULL, &ci.rcItem);
        _SendNotify(_hwnd, SMN_COMMANDINVOKED, &ci.hdr);
    }
    return hr;
}

class OfferDelete
{
public:

    LPTSTR          _pszName;
    LPITEMIDLIST    _pidlFolder;
    LPITEMIDLIST    _pidlFull;
    IStartMenuPin * _psmpin;
    HWND            _hwnd;

    ~OfferDelete()
    {
        SHFree(_pszName);
        ILFree(_pidlFolder);
        ILFree(_pidlFull);
    }

    BOOL _RepairBrokenItem();
    void _ThreadProc();

    static DWORD s_ThreadProc(LPVOID lpParameter)
    {
        OfferDelete *poffer = (OfferDelete *)lpParameter;
        poffer->_ThreadProc();
        delete poffer;
        return 0;
    }
};


BOOL OfferDelete::_RepairBrokenItem()
{
    BOOL fSuccess = FALSE;
    LPITEMIDLIST pidlNew;
    HRESULT hr = _psmpin->Resolve(_hwnd, 0, _pidlFull, &pidlNew);
    if (pidlNew)
    {
        ASSERT(hr == S_OK); // only the S_OK case should alloc a new pidl

        // Update to reflect the new pidl
        ILFree(_pidlFull);
        _pidlFull = pidlNew;

        // Re-invoke the default command; if it fails the second time,
        // then I guess the Resolve didn't work after all.
        IShellFolder *psf;
        LPCITEMIDLIST pidlChild;
        if (SUCCEEDED(SHBindToIDListParent(_pidlFull, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
        {
            if (SUCCEEDED(SHInvokeDefaultCommand(_hwnd, psf, pidlChild)))
            {
                fSuccess = TRUE;
            }
            psf->Release();
        }

    }
    return fSuccess;
}

void OfferDelete::_ThreadProc()
{
    _hwnd = SHCreateWorkerWindow(NULL, NULL, 0, 0, NULL, NULL);
    if (_hwnd)
    {
        if (SUCCEEDED(CoCreateInstance(CLSID_StartMenuPin, NULL, CLSCTX_INPROC_SERVER,
                                       IID_PPV_ARG(IStartMenuPin, &_psmpin))))
        {
            //
            //  First try to repair it by invoking the shortcut tracking code.
            //  If that fails, then offer to delete.
            if (!_RepairBrokenItem() &&
                ShellMessageBox(_Module.GetResourceInstance(), NULL,
                                MAKEINTRESOURCE(IDS_SFTHOST_OFFERREMOVEITEM),
                                _pszName, MB_YESNO) == IDYES)
            {
                _psmpin->Modify(_pidlFull, NULL);
            }
            ATOMICRELEASE(_psmpin);
        }
        DestroyWindow(_hwnd);
    }
}

void SFTBarHost::_OfferDeleteBrokenItem(PaneItem *pitem, IShellFolder *psf, LPCITEMIDLIST pidlChild)
{
    //
    //  The offer is done on a separate thread because putting up modal
    //  UI while the Start Menu is open creates all sorts of weirdness.
    //  (The user might decide to switch to Classic Start Menu
    //  while the dialog is still up, and we get our infrastructure
    //  ripped out from underneath us and then USER faults inside
    //  MessageBox...  Not good.)
    //
    OfferDelete *poffer = new OfferDelete;
    if (poffer)
    {
        if ((poffer->_pszName = DisplayNameOfItem(pitem, psf, pidlChild, SHGDN_NORMAL)) != NULL &&
            SUCCEEDED(SHGetIDListFromUnk(psf, &poffer->_pidlFolder)) &&
            (poffer->_pidlFull = ILCombine(poffer->_pidlFolder, pidlChild)) != NULL &&
            SHCreateThread(OfferDelete::s_ThreadProc, poffer, CTF_COINIT, NULL))
        {
            poffer = NULL;       // thread took ownership
        }
        delete poffer;
    }
}

BOOL ShowInfoTip()
{
    // find out if infotips are on or off, from the registry settings
    SHELLSTATE ss;
    // force a refresh
    SHGetSetSettings(&ss, 0, TRUE);
    SHGetSetSettings(&ss, SSF_SHOWINFOTIP, FALSE);
    return ss.fShowInfoTip;
}

// over-ridable method for getting the infotip on an item
void SFTBarHost::GetItemInfoTip(PaneItem *pitem, LPTSTR pszText, DWORD cch)
{
    IShellFolder *psf;
    LPCITEMIDLIST pidl;

    if (pszText && cch)
    {
        *pszText = 0;

        if (SUCCEEDED(_GetFolderAndPidl(pitem, &psf, &pidl)))
        {
            GetInfoTip(psf, pidl, pszText, cch);
            psf->Release();
        }
    }
}

LRESULT SFTBarHost::_OnLVNGetInfoTip(LPNMLVGETINFOTIP plvn)
{
    _DebugConsistencyCheck();

    PaneItem *pitem;

    if (ShowInfoTip() && 
        (pitem = _GetItemFromLV(plvn->iItem)) &&
        !pitem->IsCascade())
    {
        int cchName = (plvn->dwFlags & LVGIT_UNFOLDED) ? 0 : lstrlen(plvn->pszText);

        if (cchName)
        {
            StrCatBuff(plvn->pszText, TEXT("\r\n"), plvn->cchTextMax);
            cchName = lstrlen(plvn->pszText);
        }

        // If there is room in the buffer after we added CRLF, append the
        // infotip text.  We succeeded if there was nontrivial infotip text.

        if (cchName < plvn->cchTextMax)
        {
            GetItemInfoTip(pitem, plvn->pszText + cchName, plvn->cchTextMax - cchName);
        }
    }

    return 0;
}

LRESULT _SendNotify(HWND hwndFrom, UINT code, OPTIONAL NMHDR *pnm)
{
    NMHDR nm;
    if (pnm == NULL)
    {
        pnm = &nm;
    }
    pnm->hwndFrom = hwndFrom;
    pnm->idFrom = GetDlgCtrlID(hwndFrom);
    pnm->code = code;
    return SendMessage(GetParent(hwndFrom), WM_NOTIFY, pnm->idFrom, (LPARAM)pnm);
}

//****************************************************************************
//
//  Drag sourcing
//

// *** IDropSource::GiveFeedback ***

HRESULT SFTBarHost::GiveFeedback(DWORD dwEffect)
{
    if (_fForceArrowCursor)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return S_OK;
    }

    return DRAGDROP_S_USEDEFAULTCURSORS;
}

// *** IDropSource::QueryContinueDrag ***

HRESULT SFTBarHost::QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState)
{
    if (fEscapePressed ||
        (grfKeyState & (MK_LBUTTON | MK_RBUTTON)) == (MK_LBUTTON | MK_RBUTTON))
    {
        return DRAGDROP_S_CANCEL;
    }
    if ((grfKeyState & (MK_LBUTTON | MK_RBUTTON)) == 0)
    {
        return DRAGDROP_S_DROP;
    }
    return S_OK;
}

LRESULT SFTBarHost::_OnLVNBeginDrag(LPNMLISTVIEW plv)
{
    //If changes are restricted, don't allow drag and drop!
    if(_AreChangesRestricted())
        return 0;

    _DebugConsistencyCheck();

    ASSERT(_pdtoDragOut == NULL);
    _pdtoDragOut = NULL;

    PaneItem *pitem = _GetItemFromLV(plv->iItem);
    ASSERT(pitem);

    IDataObject *pdto;
    if (pitem && SUCCEEDED(_GetUIObjectOfItem(pitem, IID_PPV_ARG(IDataObject, &pdto))))
    {
        POINT pt;

        pt = plv->ptAction;
        ClientToScreen(_hwndList, &pt);

        if (_pdsh)
        {
            _pdsh->InitializeFromWindow(_hwndList, &pt, pdto);
        }

        CLIPFORMAT cfOFFSETS = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLISTOFFSET);

        POINT *apts = (POINT*)GlobalAlloc(GPTR, sizeof(POINT)*2);
        if (NULL != apts)
        {
            POINT ptOrigin = {0};
            POINT ptItem = {0};

            ListView_GetOrigin(_hwndList, &ptOrigin);
            apts[0].x = plv->ptAction.x + ptOrigin.x;
            apts[0].y = plv->ptAction.y + ptOrigin.y;

            ListView_GetItemPosition(_hwndList,plv->iItem,&ptItem);
            apts[1].x = ptItem.x - apts[0].x;
            apts[1].y = ptItem.y - apts[0].y;

            HRESULT hr = DataObj_SetGlobal(pdto, cfOFFSETS, apts);
            if (FAILED(hr))
            {
                GlobalFree((HGLOBAL)apts);
            }
        }

        // We don't need to refcount _pdtoDragOut since its lifetime
        // is the same as pdto.
        _pdtoDragOut = pdto;
        _iDragOut = plv->iItem;
        _iPosDragOut = pitem->_iPos;

        // Notice that DROPEFFECT_MOVE is explicitly forbidden.
        // You cannot move things out of the control.
        DWORD dwEffect = DROPEFFECT_LINK | DROPEFFECT_COPY;
        DoDragDrop(pdto, this, dwEffect, &dwEffect);

        _pdtoDragOut = NULL;
        pdto->Release();
    }
    return 0;
}

//
//  Must perform validation of SFGAO_CANRENAME when the label edit begins
//  because John Gray somehow can trick the listview into going into edit
//  mode by clicking in the right magic place, so this is the only chance
//  we get to reject things that aren't renamable...
//

LRESULT SFTBarHost::_OnLVNBeginLabelEdit(NMLVDISPINFO *plvdi)
{
    LRESULT lres = 1;

    PaneItem *pitem = _GetItemFromLVLParam(plvdi->item.lParam);

    IShellFolder *psf;
    LPCITEMIDLIST pidl;

    if (_fAllowEditLabel &&
        pitem && SUCCEEDED(_GetFolderAndPidl(pitem, &psf, &pidl)))
    {
        DWORD dwAttr = SFGAO_CANRENAME;
        if (SUCCEEDED(psf->GetAttributesOf(1, &pidl, &dwAttr)) &&
            (dwAttr & SFGAO_CANRENAME))
        {
            LPTSTR ptszName = _DisplayNameOf(psf, pidl,
                                    SHGDN_INFOLDER | SHGDN_FOREDITING);
            if (ptszName)
            {
                HWND hwndEdit = ListView_GetEditControl(_hwndList);
                if (hwndEdit)
                {
                    SetWindowText(hwndEdit, ptszName);

                    int cchLimit = MAX_PATH;
                    IItemNameLimits *pinl;
                    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IItemNameLimits, &pinl))))
                    {
                        pinl->GetMaxLength(ptszName, &cchLimit);
                        pinl->Release();
                    }
                    Edit_LimitText(hwndEdit, cchLimit);

                    // use way-cool helper which pops up baloon tips if they enter an invalid folder....
                    SHLimitInputEdit(hwndEdit, psf);

                    // Block menu mode during editing so the user won't
                    // accidentally cancel out of rename mode just because
                    // they moved the mouse.
                    SMNMBOOL nmb;
                    nmb.f = TRUE;
                    _SendNotify(_hwnd, SMN_BLOCKMENUMODE, &nmb.hdr);

                    lres = 0;
                }
                SHFree(ptszName);
            }
        }
        psf->Release();
    }

    return lres;
}

LRESULT SFTBarHost::_OnLVNEndLabelEdit(NMLVDISPINFO *plvdi)
{
    // Unblock menu mode now that editing is over.
    SMNMBOOL nmb;
    nmb.f = FALSE;
    _SendNotify(_hwnd, SMN_BLOCKMENUMODE, &nmb.hdr);

    // If changing to NULL pointer, then user is cancelling
    if (!plvdi->item.pszText)
        return FALSE;

    // Note: We allow the user to type blanks. Regfolder treats a blank
    // name as "restore default name".
    PathRemoveBlanks(plvdi->item.pszText);
    PaneItem *pitem = _GetItemFromLVLParam(plvdi->item.lParam);

    HRESULT hr = ContextMenuRenameItem(pitem, plvdi->item.pszText);

    if (SUCCEEDED(hr))
    {
        LPTSTR ptszName = _DisplayNameOfItem(pitem, SHGDN_NORMAL);
        if (ptszName)
        {
            ListView_SetItemText(_hwndList, plvdi->item.iItem, 0, ptszName);
            _SendNotify(_hwnd, SMN_NEEDREPAINT, NULL);
        }
    }
    else if (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED))
    {
        _EditLabel(plvdi->item.iItem);
    }

    // Always return FALSE to prevent listview from changing the
    // item text to what the user typed.  If the rename succeeded,
    // we manually set the name to the new name (which might not be
    // the same as what the user typed).
    return FALSE;
}

LRESULT SFTBarHost::_OnLVNKeyDown(LPNMLVKEYDOWN pkd)
{
    // Plain F2 (no shift, ctrl or alt) = rename
    if (pkd->wVKey == VK_F2 && GetKeyState(VK_SHIFT) >= 0 &&
        GetKeyState(VK_CONTROL) >= 0 && GetKeyState(VK_MENU) >= 0 &&
        (_dwFlags & HOSTF_CANRENAME))
    {
        int iItem = _GetLVCurSel();
        if (iItem >= 0)
        {
            _EditLabel(iItem);
            // cannot return TRUE because listview mistakenly thinks
            // that all WM_KEYDOWNs lead to WM_CHARs (but this one doesn't)
        }
    }

    return 0;
}

LRESULT SFTBarHost::_OnSMNGetMinSize(PSMNGETMINSIZE pgms)
{
    // We need to synchronize here to get the proper size
    if (_fBGTask && !HasDynamicContent())
    {
        // Wait for the enumeration to be done
        while (TRUE)
        {
            MSG msg;
            // Need to peek messages for all queues here or else WaitMessage will say
            // that some messages are ready to be processed and we'll end up with an
            // active loop
            if (PeekMessage(&msg, NULL, NULL, NULL, PM_NOREMOVE))
            {
                if (PeekMessage(&msg, _hwnd, SFTBM_REPOPULATE, SFTBM_REPOPULATE, PM_REMOVE))
                {
                    DispatchMessage(&msg);
                    break;
                }
            }
            WaitMessage();
        }
    }

    int cItems = _cPinnedDesired + _cNormalDesired;
    int cSep = _cSep;

    // if the repopulate hasn't happened yet, but we've got pinned items, we're going to have a separator
    if (_cSep == 0 && _cPinnedDesired > 0)
        cSep = 1;
    int cy = (_cyTile * cItems) + (_cySepTile * cSep);

    // add in theme margins
    cy += _margins.cyTopHeight + _margins.cyBottomHeight;

    // SPP_PROGLIST gets a bonus separator at the bottom
    if (_iThemePart == SPP_PROGLIST)
    {
        cy += _cySep;
    }

    pgms->siz.cy = cy;

    return 0;
}

LRESULT SFTBarHost::_OnSMNFindItem(PSMNDIALOGMESSAGE pdm)
{
    LRESULT lres = _OnSMNFindItemWorker(pdm);

    if (lres)
    {
        //
        //  If caller requested that the item also be selected, then do so.
        //
        if (pdm->flags & SMNDM_SELECT)
        {
            ListView_SetItemState(_hwndList, pdm->itemID,
                                  LVIS_SELECTED | LVIS_FOCUSED,
                                  LVIS_SELECTED | LVIS_FOCUSED);
            if ((pdm->flags & SMNDM_FINDMASK) != SMNDM_HITTEST)
            {
                ListView_KeyboardSelected(_hwndList, pdm->itemID);
            }
        }
    }
    else
    {
        //
        //  If not found, then tell caller what our orientation is (vertical)
        //  and where the currently-selected item is.
        //

        pdm->flags |= SMNDM_VERTICAL;
        int iItem = _GetLVCurSel();
        RECT rc;
        if (iItem >= 0 &&
            ListView_GetItemRect(_hwndList, iItem, &rc, LVIR_BOUNDS))
        {
            pdm->pt.x = (rc.left + rc.right)/2;
            pdm->pt.y = (rc.top + rc.bottom)/2;
        }
        else
        {
            pdm->pt.x = 0;
            pdm->pt.y = 0;
        }

    }
    return lres;
}

TCHAR SFTBarHost::GetItemAccelerator(PaneItem *pitem, int iItemStart)
{
    TCHAR sz[2];
    ListView_GetItemText(_hwndList, iItemStart, 0, sz, ARRAYSIZE(sz));
    return CharUpperChar(sz[0]);
}

LRESULT SFTBarHost::_OnSMNFindItemWorker(PSMNDIALOGMESSAGE pdm)
{
    LVFINDINFO lvfi;
    LVHITTESTINFO lvhti;

    switch (pdm->flags & SMNDM_FINDMASK)
    {
    case SMNDM_FINDFIRST:
    L_SMNDM_FINDFIRST:
        // Note: We can't just return item 0 because drag/drop pinning
        // may have gotten the physical locations out of sync with the
        // item numbers.
        lvfi.vkDirection = VK_HOME;
        lvfi.flags = LVFI_NEARESTXY;
        pdm->itemID = ListView_FindItem(_hwndList, -1, &lvfi);
        return pdm->itemID >= 0;

    case SMNDM_FINDLAST:
        // Note: We can't just return cItems-1 because drag/drop pinning
        // may have gotten the physical locations out of sync with the
        // item numbers.
        lvfi.vkDirection = VK_END;
        lvfi.flags = LVFI_NEARESTXY;
        pdm->itemID = ListView_FindItem(_hwndList, -1, &lvfi);
        return pdm->itemID >= 0;

    case SMNDM_FINDNEAREST:
        lvfi.pt = pdm->pt;
        lvfi.vkDirection = VK_UP;
        lvfi.flags = LVFI_NEARESTXY;
        pdm->itemID = ListView_FindItem(_hwndList, -1, &lvfi);
        return pdm->itemID >= 0;

    case SMNDM_HITTEST:
        lvhti.pt = pdm->pt;
        pdm->itemID = ListView_HitTest(_hwndList, &lvhti);
        return pdm->itemID >= 0;

    case SMNDM_FINDFIRSTMATCH:
    case SMNDM_FINDNEXTMATCH:
        {
            int iItemStart;
            if ((pdm->flags & SMNDM_FINDMASK) == SMNDM_FINDFIRSTMATCH)
            {
                iItemStart = 0;
            }
            else
            {
                iItemStart = _GetLVCurSel() + 1;
            }
            TCHAR tch = CharUpperChar((TCHAR)pdm->pmsg->wParam);
            int iItems = ListView_GetItemCount(_hwndList);
            for (iItemStart; iItemStart < iItems; iItemStart++)
            {
                PaneItem *pitem = _GetItemFromLV(iItemStart);
                if (GetItemAccelerator(pitem, iItemStart) == tch)
                {
                    pdm->itemID = iItemStart;
                    return TRUE;
                }
            }
            return FALSE;
        }
        break;

    case SMNDM_FINDNEXTARROW:
        if (pdm->pmsg->wParam == VK_UP)
        {
            pdm->itemID = ListView_GetNextItem(_hwndList, _GetLVCurSel(), LVNI_ABOVE);
            return pdm->itemID >= 0;
        }

        if (pdm->pmsg->wParam == VK_DOWN)
        {
            // HACK! ListView_GetNextItem explicitly fails to find a "next item"
            // if you tell it to start at -1 (no current item), so if there is no
            // focus item, we have to change it to a SMNDM_FINDFIRST.
            int iItem = _GetLVCurSel();
            if (iItem == -1)
            {
                goto L_SMNDM_FINDFIRST;
            }
            pdm->itemID = ListView_GetNextItem(_hwndList, iItem, LVNI_BELOW);
            return pdm->itemID >= 0;
        }

        if (pdm->flags & SMNDM_TRYCASCADE)
        {
            pdm->itemID = _GetLVCurSel();
            return _OnCascade((int)pdm->itemID, MPPF_KEYBOARD | MPPF_INITIALSELECT);
        }

        return FALSE;

    case SMNDM_INVOKECURRENTITEM:
        {
            int iItem = _GetLVCurSel();
            if (iItem >= 0)
            {
                DWORD aif = 0;
                if (pdm->flags & SMNDM_KEYBOARD)
                {
                    aif |= AIF_KEYBOARD;
                }
                _ActivateItem(iItem, aif);
                return TRUE;
            }
        }
        return FALSE;

    case SMNDM_OPENCASCADE:
        {
            DWORD mppf = 0;
            if (pdm->flags & SMNDM_KEYBOARD)
            {
                mppf |= MPPF_KEYBOARD | MPPF_INITIALSELECT;
            }
            pdm->itemID = _GetLVCurSel();
            return _OnCascade((int)pdm->itemID, mppf);
        }

    case SMNDM_FINDITEMID:
        return TRUE;

    default:
        ASSERT(!"Unknown SMNDM command");
        break;
    }

    return FALSE;
}

LRESULT SFTBarHost::_OnSMNDismiss()
{
    if (_fNeedsRepopulate)
    {
        _RepopulateList();
    }
    return 0;
}

LRESULT SFTBarHost::_OnCascade(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return _OnCascade((int)wParam, (DWORD)lParam);
}

BOOL SFTBarHost::_OnCascade(int iItem, DWORD dwFlags)
{
    BOOL fSuccess = FALSE;
    SMNTRACKSHELLMENU tsm;
    tsm.dwFlags = dwFlags;
    tsm.itemID = iItem;

    if (iItem >= 0 &&
        ListView_GetItemRect(_hwndList, iItem, &tsm.rcExclude, LVIR_BOUNDS))
    {
        PaneItem *pitem = _GetItemFromLV(iItem);
        if (pitem && pitem->IsCascade())
        {
            if (SUCCEEDED(GetCascadeMenu(pitem, &tsm.psm)))
            {
                MapWindowRect(_hwndList, NULL, &tsm.rcExclude);
                HWND hwnd = _hwnd;
                _iCascading = iItem;
                _SendNotify(_hwnd, SMN_TRACKSHELLMENU, &tsm.hdr);
                tsm.psm->Release();
                fSuccess = TRUE;
            }
        }
    }
    return fSuccess;
}

HRESULT SFTBarHost::QueryInterface(REFIID riid, void * *ppvOut)
{
    static const QITAB qit[] = {
        QITABENT(SFTBarHost, IDropTarget),
        QITABENT(SFTBarHost, IDropSource),
        QITABENT(SFTBarHost, IAccessible),
        QITABENT(SFTBarHost, IDispatch), // IAccessible derives from IDispatch
        { 0 },
    };
    return QISearch(this, qit, riid, ppvOut);
}

ULONG SFTBarHost::AddRef()
{
    return InterlockedIncrement(&_lRef);
}

ULONG SFTBarHost::Release()
{
    ASSERT( 0 != _lRef );
    ULONG cRef = InterlockedDecrement(&_lRef);
    if ( 0 == cRef ) 
    {
        delete this;
    }
    return cRef;
}

void SFTBarHost::_SetDragOver(int iItem)
{
    if (_iDragOver >= 0)
    {
        ListView_SetItemState(_hwndList, _iDragOver, 0, LVIS_DROPHILITED);
    }

    _iDragOver = iItem;

    if (_iDragOver >= 0)
    {
        ListView_SetItemState(_hwndList, _iDragOver, LVIS_DROPHILITED, LVIS_DROPHILITED);

        _tmDragOver = NonzeroGetTickCount();
    }
    else
    {
        _tmDragOver = 0;
    }
}

void SFTBarHost::_ClearInnerDropTarget()
{
    if (_pdtDragOver)
    {
        ASSERT(_iDragState == DRAGSTATE_ENTERED);
        _pdtDragOver->DragLeave();
        _pdtDragOver->Release();
        _pdtDragOver = NULL;
        DEBUG_CODE(_iDragState = DRAGSTATE_UNINITIALIZED);
    }
    _SetDragOver(-1);
}

HRESULT SFTBarHost::_TryInnerDropTarget(int iItem, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    HRESULT hr;

    if (_iDragOver != iItem)
    {
        _ClearInnerDropTarget();

        // Even if it fails, remember that we have this item so we don't
        // query for the drop target again (and have it fail again).
        _SetDragOver(iItem);

        ASSERT(_pdtDragOver == NULL);
        ASSERT(_iDragState == DRAGSTATE_UNINITIALIZED);

        PaneItem *pitem = _GetItemFromLV(iItem);
        if (pitem && pitem->IsDropTarget())
        {
            hr = _GetUIObjectOfItem(pitem, IID_PPV_ARG(IDropTarget, &_pdtDragOver));
            if (SUCCEEDED(hr))
            {
                hr = _pdtDragOver->DragEnter(_pdtoDragIn, grfKeyState, ptl, pdwEffect);
                if (SUCCEEDED(hr) && *pdwEffect)
                {
                    DEBUG_CODE(_iDragState = DRAGSTATE_ENTERED);
                }
                else
                {
                    DEBUG_CODE(_iDragState = DRAGSTATE_UNINITIALIZED);
                    ATOMICRELEASE(_pdtDragOver);
                }
            }
        }
    }

    ASSERT(_iDragOver == iItem);

    if (_pdtDragOver)
    {
        ASSERT(_iDragState == DRAGSTATE_ENTERED);
        hr = _pdtDragOver->DragOver(grfKeyState, ptl, pdwEffect);
    }
    else
    {
        hr = E_FAIL;            // No drop target
    }

    return hr;
}

void SFTBarHost::_PurgeDragDropData()
{
    _SetInsertMarkPosition(-1);
    _fForceArrowCursor = FALSE;
    _ClearInnerDropTarget();
    ATOMICRELEASE(_pdtoDragIn);
}

// *** IDropTarget::DragEnter ***

HRESULT SFTBarHost::DragEnter(IDataObject *pdto, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    if(_AreChangesRestricted())
    {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }
        
    POINT pt = { ptl.x, ptl.y };
    if (_pdth) {
        _pdth->DragEnter(_hwnd, pdto, &pt, *pdwEffect);
    }

    return _DragEnter(pdto, grfKeyState, ptl, pdwEffect);
}

HRESULT SFTBarHost::_DragEnter(IDataObject *pdto, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    _PurgeDragDropData();

    _fDragToSelf = SHIsSameObject(pdto, _pdtoDragOut);
    _fInsertable = IsInsertable(pdto);

    ASSERT(_pdtoDragIn == NULL);
    _pdtoDragIn = pdto;
    _pdtoDragIn->AddRef();

    return DragOver(grfKeyState, ptl, pdwEffect);
}

// *** IDropTarget::DragOver ***

HRESULT SFTBarHost::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    if(_AreChangesRestricted())
    {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }
    
    _DebugConsistencyCheck();
    ASSERT(_pdtoDragIn);

    POINT pt = { ptl.x, ptl.y };
    if (_pdth) {
        _pdth->DragOver(&pt, *pdwEffect);
    }

    _fForceArrowCursor = FALSE;

    // Need to remember this because at the point of the drop, OLE gives
    // us the keystate after the user releases the button, so we can't
    // tell what kind of a drag operation the user performed!
    _grfKeyStateLast = grfKeyState;

#ifdef DEBUG
    if (_fDragToSelf)
    {
        ASSERT(_pdtoDragOut);
        ASSERT(_iDragOut >= 0);
        PaneItem *pitem = _GetItemFromLV(_iDragOut);
        ASSERT(pitem && (pitem->_iPos == _iPosDragOut));
    }
#endif

    //  Find the last item above the cursor position.  This allows us
    //  to treat the entire blank space at the bottom as belonging to the
    //  last item, and separators end up belonging to the item immediately
    //  above them.  Note that we don't bother testing item zero since
    //  he is always above everything (since he's the first item).

    ScreenToClient(_hwndList, &pt);

    POINT ptItem;
    int cItems = ListView_GetItemCount(_hwndList);
    int iItem;

    for (iItem = cItems - 1; iItem >= 1; iItem--)
    {
        ListView_GetItemPosition(_hwndList, iItem, &ptItem);
        if (ptItem.y <= pt.y)
        {
            break;
        }
    }

    //
    //  We didn't bother checking item 0 because we knew his position
    //  (by treating him special, this also causes all negative coordinates
    //  to be treated as belonging to item zero also).
    //
    if (iItem <= 0)
    {
        ptItem.y = 0;
        iItem = 0;
    }

    //
    //  Decide whether this is a drag-between or a drag-over...
    //
    //  For computational purposes, we treat each tile as four
    //  equal-sized "units" tall.  For each unit, we consider the
    //  possible actions in the order listed.
    //
    //  +-----
    //  |  0   insert above, drop on, reject
    //  | ----
    //  |  1                 drop on, reject
    //  | ----
    //  |  2                 drop on, reject
    //  | ----
    //  |  3   insert below, drop on, reject
    //  +-----
    //
    //  If the listview is empty, then treat as an
    //  insert before (imaginary) item zero; i.e., pin
    //  to top of the list.
    //

    UINT uUnit = 0;
    if (_cyTile && cItems)
    {
        int dy = pt.y - ptItem.y;

        // Peg out-of-bounds values to the nearest edge.
        if (dy < 0) dy = 0;
        if (dy >= _cyTile) dy = _cyTile - 1;

        // Decide which unit we are in.
        uUnit = 4 * dy / _cyTile;

        ASSERT(uUnit < 4);
    }

    //
    //  Now determine the appropriate action depending on which unit
    //  we are in.
    //

    int iInsert = -1;                   // Assume not inserting

    if (_fInsertable)
    {
        // Note!  Spec says that if you are in the non-pinned part of
        // the list, we draw the insert bar at the very bottom of
        // the pinned area.

        switch (uUnit)
        {
        case 0:
            iInsert = min(iItem, _cPinned);
            break;

        case 3:
            iInsert = min(iItem+1, _cPinned);
            break;
        }
    }

    //
    //  If inserting above or below isn't allowed, try dropping on.
    //
    if (iInsert < 0)
    {
        _SetInsertMarkPosition(-1);         // Not inserting

        // Up above, we let separators be hit-tested as if they
        // belongs to the item above them.  But that doesn't work for
        // drops, so reject them now.
        //
        // Also reject attempts to drop on the nonexistent item zero,
        // and don't let the user drop an item on itself.

        if (InRange(pt.y, ptItem.y, ptItem.y + _cyTile - 1) &&
            cItems &&
            !(_fDragToSelf && _iDragOut == iItem) &&
            SUCCEEDED(_TryInnerDropTarget(iItem, grfKeyState, ptl, pdwEffect)))
        {
            // Woo-hoo, happy joy!
        }
        else
        {
            // Note that we need to convert a failed drop into a DROPEFFECT_NONE
            // rather than returning a flat-out error code, because if we return
            // an error code, OLE will stop sending us drag/drop notifications!
            *pdwEffect = DROPEFFECT_NONE;
        }

        // If the user is hovering over a cascadable item, then open it.
        // First see if the user has hovered long enough...

        if (_tmDragOver && (GetTickCount() - _tmDragOver) >= _GetCascadeHoverTime())
        {
            _tmDragOver = 0;

            // Now see if it's cascadable
            PaneItem *pitem = _GetItemFromLV(_iDragOver);
            if (pitem && pitem->IsCascade())
            {
                // Must post this message because the cascading is modal
                // and we have to return a result to OLE
                PostMessage(_hwnd, SFTBM_CASCADE, _iDragOver, 0);
            }
        }
    }
    else
    {
        _ClearInnerDropTarget();    // Not dropping

        if (_fDragToSelf)
        {
            // Even though we're going to return DROPEFFECT_LINK,
            // tell the drag source (namely, ourselves) that we would
            // much prefer a regular arrow cursor because this is
            // a Move operation from the user's point of view.
            _fForceArrowCursor = TRUE;
        }

        //
        //  If user is dropping to a place where nothing would change,
        //  then don't draw an insert mark.
        //
        if (IsInsertMarkPointless(iInsert))
        {
            _SetInsertMarkPosition(-1);
        }
        else
        {
            _SetInsertMarkPosition(iInsert);
        }

        //  Sigh.  MergedFolder (used by the merged Start Menu)
        //  won't let you create shortcuts, so we pretend that
        //  we're copying if the data object doesn't permit
        //  linking.

        if (*pdwEffect & DROPEFFECT_LINK)
        {
            *pdwEffect = DROPEFFECT_LINK;
        }
        else
        {
            *pdwEffect = DROPEFFECT_COPY;
        }
    }

    return S_OK;
}

// *** IDropTarget::DragLeave ***

HRESULT SFTBarHost::DragLeave()
{
    if(_AreChangesRestricted())
    {
        return S_OK;
    }
    
    if (_pdth) {
        _pdth->DragLeave();
    }

    _PurgeDragDropData();
    return S_OK;
}

// *** IDropTarget::Drop ***

HRESULT SFTBarHost::Drop(IDataObject *pdto, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    if(_AreChangesRestricted())
    {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }
    
    _DebugConsistencyCheck();

    // Use the key state from the last DragOver call
    grfKeyState = _grfKeyStateLast;

    // Need to go through the whole _DragEnter thing again because who knows
    // maybe the data object and coordinates of the drop are different from
    // the ones we got in DragEnter/DragOver...  We use _DragEnter, which
    // bypasses the IDropTargetHelper::DragEnter.
    //
    _DragEnter(pdto, grfKeyState, ptl, pdwEffect);

    POINT pt = { ptl.x, ptl.y };
    if (_pdth) {
        _pdth->Drop(pdto, &pt, *pdwEffect);
    }

    int iInsert = _iInsert;
    _SetInsertMarkPosition(-1);

    if (*pdwEffect)
    {
        ASSERT(_pdtoDragIn);
        if (iInsert >= 0)                           // "add to pin" or "move"
        {
            BOOL fTriedMove = FALSE;

            // First see if it was just a move of an existing pinned item
            if (_fDragToSelf)
            {
                PaneItem *pitem = _GetItemFromLV(_iDragOut);
                if (pitem)
                {
                    if (pitem->IsPinned())
                    {
                        // Yup, it was a move - so move it.
                        if (SUCCEEDED(MovePinnedItem(pitem, iInsert)))
                        {
                            // We used to try to update all the item positions
                            // incrementally.  This was a major pain in the neck.
                            //
                            // So now we just do a full refresh.  Turns out that a
                            // full refresh is fast enough anyway.
                            //
                            PostMessage(_hwnd, SFTBM_REFRESH, TRUE, 0);
                        }

                        // We tried to move a pinned item (return TRUE even if
                        // we actually failed).
                        fTriedMove = TRUE;
                    }
                }
            }

            if (!fTriedMove)
            {
                if (SUCCEEDED(InsertPinnedItem(_pdtoDragIn, iInsert)))
                {
                    PostMessage(_hwnd, SFTBM_REFRESH, TRUE, 0);
                }
            }
        }
        else if (_pdtDragOver) // Not an insert, maybe it was a plain drop
        {
            ASSERT(_iDragState == DRAGSTATE_ENTERED);
            _pdtDragOver->Drop(_pdtoDragIn, grfKeyState, ptl, pdwEffect);
        }
    }

    _PurgeDragDropData();
    _DebugConsistencyCheck();

    return S_OK;
}

void SFTBarHost::_SetInsertMarkPosition(int iInsert)
{
    if (_iInsert != iInsert)
    {
        _InvalidateInsertMark();
        _iInsert = iInsert;
        _InvalidateInsertMark();
    }
}

BOOL SFTBarHost::_GetInsertMarkRect(LPRECT prc)
{
    if (_iInsert >= 0)
    {
        GetClientRect(_hwndList, prc);
        POINT pt;
        _ComputeListViewItemPosition(_iInsert, &pt);
        int iBottom = pt.y;
        int cyEdge = GetSystemMetrics(SM_CYEDGE);
        prc->top = iBottom - cyEdge;
        prc->bottom = iBottom + cyEdge;
        return TRUE;
    }

    return FALSE;

}

void SFTBarHost::_InvalidateInsertMark()
{
    RECT rc;
    if (_GetInsertMarkRect(&rc))
    {
        InvalidateRect(_hwndList, &rc, TRUE);
    }
}

void SFTBarHost::_DrawInsertionMark(LPNMLVCUSTOMDRAW plvcd)
{
    RECT rc;
    if (_GetInsertMarkRect(&rc))
    {
        FillRect(plvcd->nmcd.hdc, &rc, GetSysColorBrush(COLOR_WINDOWTEXT));
    }
}

void SFTBarHost::_DrawSeparator(HDC hdc, int x, int y)
{
    RECT rc;
    rc.left = x;
    rc.top = y;
    rc.right = rc.left + _cxTile;
    rc.bottom = rc.top + _cySep;

    if (!_hTheme)
    {
        DrawEdge(hdc, &rc, EDGE_ETCHED,BF_TOPLEFT);
    }
    else
    {
        DrawThemeBackground(_hTheme, hdc, _iThemePartSep, 0, &rc, 0);
    }
}

void SFTBarHost::_DrawSeparators(LPNMLVCUSTOMDRAW plvcd)
{
    POINT pt;
    RECT rc;

    for (int iSep = 0; iSep < _cSep; iSep++)
    {
        _ComputeListViewItemPosition(_rgiSep[iSep], &pt);
        pt.y = pt.y - _cyTilePadding + (_cySepTile - _cySep + _cyTilePadding)/2;
        _DrawSeparator(plvcd->nmcd.hdc, pt.x, pt.y);
    }

    // Also draw a bonus separator at the bottom of the list to separate
    // the MFU list from the More Programs button.

    if (_iThemePart == SPP_PROGLIST)
    {
        _ComputeListViewItemPosition(0, &pt);
        GetClientRect(_hwndList, &rc);
        rc.bottom -= _cySep;
        _DrawSeparator(plvcd->nmcd.hdc, pt.x, rc.bottom);

    }
}

//****************************************************************************
//
//  Accessibility
//

PaneItem *SFTBarHost::_GetItemFromAccessibility(const VARIANT& varChild)
{
    if (varChild.lVal)
    {
        return _GetItemFromLV(varChild.lVal - 1);
    }
    return NULL;
}

//
//  The default accessibility object reports listview items as
//  ROLE_SYSTEM_LISTITEM, but we know that we are really a menu.
//
//  Our items are either ROLE_SYSTEM_MENUITEM or ROLE_SYSTEM_MENUPOPUP.
//
HRESULT SFTBarHost::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    HRESULT hr = _paccInner->get_accRole(varChild, pvarRole);
    if (SUCCEEDED(hr) && V_VT(pvarRole) == VT_I4)
    {
        switch (V_I4(pvarRole))
        {
        case ROLE_SYSTEM_LIST:
            V_I4(pvarRole) = ROLE_SYSTEM_MENUPOPUP;
            break;

        case ROLE_SYSTEM_LISTITEM:
            V_I4(pvarRole) = ROLE_SYSTEM_MENUITEM;
            break;
        }
    }
    return hr;
}

HRESULT SFTBarHost::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    HRESULT hr = _paccInner->get_accState(varChild, pvarState);
    if (SUCCEEDED(hr) && V_VT(pvarState) == VT_I4)
    {
        PaneItem *pitem = _GetItemFromAccessibility(varChild);
        if (pitem && pitem->IsCascade())
        {
            V_I4(pvarState) |= STATE_SYSTEM_HASPOPUP;
        }

    }
    return hr;
}

HRESULT SFTBarHost::get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut)
{
    if (varChild.lVal)
    {
        PaneItem *pitem = _GetItemFromAccessibility(varChild);
        if (pitem)
        {
            return CreateAcceleratorBSTR(GetItemAccelerator(pitem, varChild.lVal - 1), pszKeyboardShortcut);
        }
    }
    *pszKeyboardShortcut = NULL;
    return E_NOT_APPLICABLE;
}


//
//  Default action for cascading menus is Open/Close (depending on
//  whether the item is already open); for regular items
//  is Execute.
//
HRESULT SFTBarHost::get_accDefaultAction(VARIANT varChild, BSTR *pszDefAction)
{
    *pszDefAction = NULL;
    if (varChild.lVal)
    {
        PaneItem *pitem = _GetItemFromAccessibility(varChild);
        if (pitem && pitem->IsCascade())
        {
            DWORD dwRole = varChild.lVal - 1 == _iCascading ? ACCSTR_CLOSE : ACCSTR_OPEN;
            return GetRoleString(dwRole, pszDefAction);
        }

        return GetRoleString(ACCSTR_EXECUTE, pszDefAction);
    }
    return E_NOT_APPLICABLE;
}

HRESULT SFTBarHost::accDoDefaultAction(VARIANT varChild)
{
    if (varChild.lVal)
    {
        PaneItem *pitem = _GetItemFromAccessibility(varChild);
        if (pitem && pitem->IsCascade())
        {
            if (varChild.lVal - 1 == _iCascading)
            {
                _SendNotify(_hwnd, SMN_CANCELSHELLMENU);
                return S_OK;
            }
        }
    }
    return CAccessible::accDoDefaultAction(varChild);
}



//****************************************************************************
//
//  Debugging helpers
//

#ifdef FULL_DEBUG

void SFTBarHost::_DebugConsistencyCheck()
{
    int i;
    int citems;

    if (_hwndList && !_fListUnstable)
    {
        //
        //  Check that the items in the listview are in their correct positions.
        //

        citems = ListView_GetItemCount(_hwndList);
        for (i = 0; i < citems; i++)
        {
            PaneItem *pitem = _GetItemFromLV(i);
            if (pitem)
            {
                // Make sure the item number and the iPos are in agreement
                ASSERT(pitem->_iPos == _ItemNoToPos(i));
                ASSERT(_PosToItemNo(pitem->_iPos) == i);

                // Make sure the item is where it should be
                POINT pt, ptShould;
                _ComputeListViewItemPosition(pitem->_iPos, &ptShould);
                ListView_GetItemPosition(_hwndList, i, &pt);
                ASSERT(pt.x == ptShould.x);
                ASSERT(pt.y == ptShould.y);
            }
        }
    }

}
#endif

//  iFile is the zero-based index of the file being requested
//        or 0xFFFFFFFF if you don't care about any particular file
//
//  puFiles receives the number of files in the HDROP
//        or NULL if you don't care about the number of files
//

STDAPI_(HRESULT)
IDataObject_DragQueryFile(IDataObject *pdto, UINT iFile, LPTSTR pszBuf, UINT cch, UINT *puFiles)
{
    static FORMATETC const feHdrop =
        { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    STGMEDIUM stgm;
    HRESULT hr;

    // Sigh.  IDataObject::GetData has a bad prototype and says that
    // the first parameter is a modifiable FORMATETC, even though it
    // isn't.
    hr = pdto->GetData(const_cast<FORMATETC*>(&feHdrop), &stgm);
    if (SUCCEEDED(hr))
    {
        HDROP hdrop = reinterpret_cast<HDROP>(stgm.hGlobal);
        if (puFiles)
        {
            *puFiles = DragQueryFile(hdrop, 0xFFFFFFFF, NULL, 0);
        }

        if (iFile != 0xFFFFFFFF)
        {
            hr = DragQueryFile(hdrop, iFile, pszBuf, cch) ? S_OK : E_FAIL;
        }
        ReleaseStgMedium(&stgm);
    }
    return hr;
}

/*
 * If pidl has an alias, free the original pidl and return the alias.
 * Otherwise, just return pidl unchanged.
 *
 * Expected usage is
 *
 *          pidlTarget = ConvertToLogIL(pidlTarget);
 *
 */
STDAPI_(LPITEMIDLIST) ConvertToLogIL(LPITEMIDLIST pidl)
{
    LPITEMIDLIST pidlAlias = SHLogILFromFSIL(pidl);
    if (pidlAlias)
    {
        ILFree(pidl);
        return pidlAlias;
    }
    return pidl;
}

//****************************************************************************
//

STDAPI_(HFONT) LoadControlFont(HTHEME hTheme, int iPart, BOOL fUnderline, DWORD dwSizePercentage)
{
    LOGFONT lf;
    BOOL bSuccess;

    if (hTheme)
    {
        bSuccess = SUCCEEDED(GetThemeFont(hTheme, NULL, iPart, 0, TMT_FONT, &lf));
    }
    else
    {
        bSuccess = SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
    }

    if (bSuccess)
    {
        // only apply size scaling factor in non-theme case, for themes it makes sense to specify the exact font in the theme
        if (!hTheme && dwSizePercentage && dwSizePercentage != 100)
        {
            lf.lfHeight = (lf.lfHeight * (int)dwSizePercentage) / 100;
            lf.lfWidth = 0; // get the closest based on aspect ratio
        }

        if (fUnderline)
        {
            lf.lfUnderline = TRUE;
        }

       return CreateFontIndirect(&lf);
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\stdafx.h ===
#define UXCTRL_VERSION 0x0100

#include <w4warn.h>
/*
 *   Level 4 warnings to be turned on.
 *   Do not disable any more level 4 warnings.
 */
#pragma warning(disable:4189)    // local variable is initialized but not referenced
#pragma warning(disable:4245)    // conversion from 'const int' to 'UINT', signed/unsign
#pragma warning(disable:4701)    // local variable 'pszPic' may be used without having been initiali
#pragma warning(disable:4706)    // assignment within conditional expression
#pragma warning(disable:4328)    // indirection alignment of formal parameter 1(4) is greater than the actual argument alignment (1)

#define _BROWSEUI_          // See HACKS OF DEATH in sfthost.cpp
#include <shlobj.h>
#include <shlobjp.h>
#include <shguidp.h>
#include <ieguidp.h>
#include <shlwapi.h>
#include <ccstock.h>
#include <port32.h>
#include <debug.h>
#include <varutil.h>
#include <dpa.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <desktop2.h>
#include <shsemip.h>
#include <runonce.h>
#include "regstr.h"
#include <shfusion.h>

#define REGSTR_EXPLORER_ADVANCED REGSTR_PATH_EXPLORER TEXT("\\Advanced")

#include <windowsx.h>

EXTERN_C HWND v_hwndTray;
EXTERN_C HWND v_hwndStartPane;

#define REGSTR_PATH_STARTFAVS       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartPage")
#define REGSTR_VAL_STARTFAVS        TEXT("Favorites")
#define REGSTR_VAL_STARTFAVCHANGES  TEXT("FavoritesChanges")

#define REGSTR_VAL_PROGLIST         TEXT("ProgramsCache")

// IAccessible
#include <oleacc.h>

// When we want to get a tick count for the starting time of some interval
// and ensure that it is not zero (because we use zero to mean "not started").
// If we actually get zero back, then change it to -1.  Don't change it
// to 1, or somebody who does GetTickCount() - dwStart will get a time of
// 49 days.

__inline DWORD NonzeroGetTickCount()
{
    DWORD dw = GetTickCount();
    return dw ? dw : -1;
}

#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\userpane.h ===
#include <lmcons.h> // for UNLEN

// window class name of user pane control
#define WC_USERPANE TEXT("Desktop User Pane")

// hardcoded width and height of user picture
#define USERPICWIDTH 48
#define USERPICHEIGHT 48

class CUserPane
{
public:
    CUserPane();
    ~CUserPane();

    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void Paint(HDC hdc);
    void OnDrawItem(DRAWITEMSTRUCT *pdis);
    LRESULT OnSize();
    BOOL _IsCursorInPicture();

private:
    HRESULT _UpdateUserInfo();

    HWND _hwnd;
    HWND _hwndStatic;

    TCHAR _szUserName[UNLEN + 1];

    HTHEME _hTheme;

    MARGINS _mrgnPictureFrame;  // the margins for the frame around the user picture
    int _iFramedPicHeight;
    int _iFramedPicWidth;
    int _iUnframedPicHeight;
    int _iUnframedPicWidth;

    UINT _uidChangeRegister;

    HFONT _hFont;
    COLORREF _crColor;
    HBITMAP _hbmUserPicture;

    enum { UPM_CHANGENOTIFY = WM_USER };

    friend BOOL UserPane_RegisterClass();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\explorer\desktop2\userpane.cpp ===
#include "stdafx.h"
#include "sfthost.h"
#include "userpane.h"

CUserPane::CUserPane()
{
    ASSERT(_hwnd == NULL);
    ASSERT(*_szUserName == 0);
    ASSERT(_crColor == 0);
    ASSERT(_hFont == NULL);
    ASSERT(_hbmUserPicture== NULL);

    //Initialize the _rcColor to an invalid color
    _crColor = CLR_INVALID;
}

CUserPane::~CUserPane()
{
    if (_uidChangeRegister)
        SHChangeNotifyDeregister(_uidChangeRegister);

    if (_hFont)
      DeleteObject(_hFont);

    if (_hbmUserPicture)
        DeleteObject(_hbmUserPicture);
}

LRESULT CALLBACK CUserPane::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUserPane *pThis = reinterpret_cast<CUserPane *>(GetWindowPtr(hwnd, GWLP_USERDATA));

    if (!pThis && (WM_NCDESTROY != uMsg))
    {
        pThis = new CUserPane;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pThis);
    }

    if (pThis)
        return pThis->WndProc(hwnd, uMsg, wParam, lParam);

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

BOOL CUserPane::_IsCursorInPicture()
{
    if (!_hbmUserPicture)
        return FALSE;

    RECT rc;
    POINT p;

    GetCursorPos(&p);
    MapWindowPoints(NULL, _hwnd, &p, 1);

    GetClientRect(_hwnd, &rc);
    int iOffset = (RECTHEIGHT(rc) - _iFramedPicHeight) / 2;

    return ((p.x > iOffset && p.x < iOffset + _iFramedPicWidth) &&
            (p.y > iOffset && p.y < iOffset + _iFramedPicHeight));
}

void CUserPane::OnDrawItem(DRAWITEMSTRUCT *pdis)
{
    HFONT hfPrev = SelectFont(pdis->hDC, _hFont);
    int cchName = lstrlen(_szUserName);

    int iOldMode = SetBkMode(pdis->hDC, TRANSPARENT);

    // display the text centered
    SIZE siz;
    RECT rc;
    int iOffset=0;
    int iOffsetX = 0;
    GetTextExtentPoint32(pdis->hDC, _szUserName, cchName, &siz);
    GetClientRect(_hwnd, &rc);

    iOffset = (RECTHEIGHT(rc) - siz.cy)/2;
    if (!_hbmUserPicture)
        iOffsetX = iOffset;

    if (iOffset < 0)
        iOffset = 0;

    // later - read more precise offsets from theme file
    if (_hTheme)
    {
        RECT rcUser;
        rcUser.left = pdis->rcItem.left+ iOffsetX;
        rcUser.top = pdis->rcItem.top+iOffset;
        rcUser.bottom = pdis->rcItem.bottom + iOffset;
        rcUser.right = pdis->rcItem.right + iOffsetX;

        // First calculate the bounding rectangle to reduce the cost of DrawShadowText
        DrawText(pdis->hDC, _szUserName, cchName, &rcUser, DT_SINGLELINE | DT_NOPREFIX | DT_END_ELLIPSIS | DT_CALCRECT);

        DrawThemeText(_hTheme, pdis->hDC, SPP_USERPANE, 0, _szUserName, cchName, DT_SINGLELINE | DT_NOPREFIX | DT_END_ELLIPSIS, 0, &rcUser);
    }
    else
    {
        ExtTextOut(pdis->hDC, pdis->rcItem.left+ iOffsetX, pdis->rcItem.top+iOffset, 0, NULL, _szUserName, cchName, NULL);
    }

    SetBkMode(pdis->hDC, iOldMode);

    SelectFont(pdis->hDC, hfPrev);
}


LRESULT CALLBACK CUserPane::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lr = 0L;

    switch (uMsg)
    {
        case WM_NCCREATE:
        {
            _hwnd = hwnd;

            _hTheme = (PaneDataFromCreateStruct(lParam))->hTheme;

            //Check for policy restrictions.
            //If No Name policy is in place, the username will continue to be a NULL string!
            ASSERT(*_szUserName == 0);

            _UpdateUserInfo();
            
            if (_hTheme)
            {
                GetThemeColor(_hTheme, SPP_USERPANE, 0, TMT_TEXTCOLOR, &_crColor);
                _hFont = LoadControlFont(_hTheme, SPP_USERPANE, FALSE, 150);
            }
            else
            {
                HFONT hfTemp = (HFONT) GetStockObject(DEFAULT_GUI_FONT);
                LOGFONT lf = {0};
                GetObject(hfTemp, sizeof(lf), &lf);
                lf.lfItalic = TRUE;
                lf.lfHeight = (lf.lfHeight * 175) / 100;
                lf.lfWidth = 0; // get the closest based on aspect ratio
                lf.lfWeight = FW_BOLD;
                lf.lfQuality = DEFAULT_QUALITY;
                SHAdjustLOGFONT(&lf); // apply locale-specific adjustments
                _hFont = CreateFontIndirect(&lf);
                _crColor = GetSysColor(COLOR_CAPTIONTEXT);
                // no need to free hfTemp
            }


            return TRUE;
        }


        case WM_NCDESTROY:
        {
            lr = DefWindowProc(hwnd, uMsg, wParam, lParam);

            SetWindowLongPtr(hwnd, GWLP_USERDATA, 0);
            delete this;

            return lr;
        }

        case WM_CREATE:
        {
            // create the user name static control and set its font if specified
            DWORD dwStyle = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VISIBLE |
                            SS_OWNERDRAW | SS_NOTIFY;

            _hwndStatic = CreateWindowEx(0, TEXT("static"), NULL, dwStyle,
                                         0, 0, 0, 0,                                        // we'll be sized properly on WM_SIZE
                                         _hwnd, NULL, _Module.GetModuleInstance(), NULL);
            if (_hwndStatic)
            {
                if (_hFont)
                    SetWindowFont(_hwndStatic, _hFont, FALSE);

                if (*_szUserName)
                    SetWindowText(_hwndStatic, _szUserName);

                return TRUE;
            }

            return FALSE;
        }

        case WM_SIZE:
        {
            return OnSize();
        }

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc;

            hdc = BeginPaint(_hwnd, &ps);
            if (hdc)
            {
                Paint(hdc);
                EndPaint(_hwnd, &ps);
            }

            return lr;
        }

        case WM_ERASEBKGND:
        {
            RECT rc;
            GetClientRect(_hwnd, &rc);
            if (!_hTheme)
            {
                // DrawCaption will draw the caption in its gradient glory so we don't
                // have to!  Since we don't want any text to be drawn (we'll draw it ourselves)
                // we pass the handle of a window which has blank text.  And despite
                // the documentation, you have to pass DC_TEXT or nothing draws!
                UINT uFlags = DC_ACTIVE | DC_TEXT;
                if (SHGetCurColorRes() > 8)
                    uFlags |= DC_GRADIENT;

                DrawCaption(hwnd, (HDC)wParam, &rc, uFlags);
            }
            else
            {
                DrawThemeBackground(_hTheme, (HDC)wParam, SPP_USERPANE, 0, &rc, 0);
            }
            return TRUE;
        }


        case WM_PRINTCLIENT:
        {
            // paint user picture
            Paint((HDC)wParam);

            // Then forward the message to the static child window.
            lParam = lParam & ~PRF_ERASEBKGND;  //Strip out the erase bkgnd. We want transparency!
            // We need to pass this message to the children, or else, they do not paint!
            // This break will result in calling DefWindowProc below and that in turn passes
            // this message to the children of this window.
            break;
        }

        case WM_CTLCOLORSTATIC:
            SetTextColor((HDC)wParam, _crColor);
            return (LRESULT)(GetStockObject(HOLLOW_BRUSH));

        case WM_DRAWITEM:
            OnDrawItem((LPDRAWITEMSTRUCT)lParam);
            return 0;

        case WM_SETCURSOR:
            // Change the cursor to a hand when its over the user picture
            if (_IsCursorInPicture())
            {
                SetCursor(LoadCursor(NULL, IDC_HAND));
                return TRUE;
            }
            break;

        case WM_LBUTTONUP:
            // Launch the cpl to change the picture, if the user clicks on it.
            // note that this is not exposed to accessibility, as this is a secondary access point for changing the picture
            // and we don't want to clutter the start panel's keyboard navigation for a minor fluff helper like this...
            if (_IsCursorInPicture())
            {
                // wow this is slow, should we shellexec "mshta.exe res://nusrmgr.cpl/nusrmgr.hta" ourselves, 
                // since this will only happen when we know we are not on a domain.
                SHRunControlPanel(TEXT("nusrmgr.cpl ,initialTask=ChangePicture"), _hwnd);
                return 0;
            }
            break;

        case WM_SYSCOLORCHANGE:
        case WM_DISPLAYCHANGE:
        case WM_SETTINGCHANGE:
            SHPropagateMessage(hwnd, uMsg, wParam, lParam, SPM_SEND | SPM_ONELEVEL);
            break;


        case WM_NOTIFY:
            {
                NMHDR *pnm = (NMHDR*)lParam;
                switch (pnm->code)
                {
                case SMN_APPLYREGION:
                    return HandleApplyRegion(_hwnd, _hTheme, (SMNMAPPLYREGION *)lParam, SPP_USERPANE, 0);
                }
            }
            break;

        case UPM_CHANGENOTIFY:
            {
                LPITEMIDLIST *ppidl;
                LONG lEvent;
                LPSHChangeNotificationLock pshcnl;
                pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);

                if (pshcnl)
                {
                    if (lEvent == SHCNE_EXTENDED_EVENT && ppidl[0])
                    {
                        SHChangeDWORDAsIDList *pdwidl = (SHChangeDWORDAsIDList *)ppidl[0];
                        if (pdwidl->dwItem1 == SHCNEE_USERINFOCHANGED)
                        {
                            _UpdateUserInfo();
                        }
                    }
                    SHChangeNotification_Unlock(pshcnl);
                }
            }
            break;

    }

    return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void CUserPane::Paint(HDC hdc)
{
    // paint user picture if there is one
    if (_hbmUserPicture)
    {
        RECT rc;
        int iOffset;
        BITMAP bm;
        HDC hdcTmp;

        GetClientRect(_hwnd, &rc);
        iOffset = (RECTHEIGHT(rc) - _iFramedPicHeight) / 2;
        GetObject(_hbmUserPicture, sizeof(bm), &bm);

        hdcTmp = CreateCompatibleDC(hdc);
        if (hdcTmp)
        {
            // draw the frame behind the user picture
            if (_hTheme && (_iFramedPicWidth != USERPICWIDTH || _iFramedPicHeight != USERPICHEIGHT))
            {
                RECT rcFrame;
                rcFrame.left     = iOffset;
                rcFrame.top      = iOffset;
                rcFrame.right    = rcFrame.left + _iFramedPicWidth;
                rcFrame.bottom   = rcFrame.top + _iFramedPicHeight;

                DrawThemeBackground(_hTheme, hdc, SPP_USERPICTURE, 0, &rcFrame, 0);
            }

            // draw the user picture
            SelectObject(hdcTmp, _hbmUserPicture);
            int iStretchMode = SetStretchBltMode(hdc, COLORONCOLOR);
            StretchBlt(hdc, iOffset + _mrgnPictureFrame.cxLeftWidth + (USERPICWIDTH - _iUnframedPicWidth)/2, iOffset + _mrgnPictureFrame.cyTopHeight + (USERPICHEIGHT - _iUnframedPicHeight)/2, _iUnframedPicWidth, _iUnframedPicHeight, 
                    hdcTmp, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
            SetStretchBltMode(hdc, iStretchMode);
            DeleteDC(hdcTmp);
        }
    }
}

LRESULT CUserPane::OnSize()
{
    RECT rc;
    GetClientRect(_hwnd, &rc);

    if (_hbmUserPicture)
    {
        // if we've got a picture, start the text 2 edges over from the right edge of the user picture
        // note - temp code - we'll read margins from the theme file shortly
        int iPicOffset = (RECTHEIGHT(rc) - _iFramedPicHeight) / 2;
        if (iPicOffset < 0)
            iPicOffset = 0;
        rc.left += iPicOffset + _iFramedPicWidth + GetSystemMetrics(SM_CYEDGE) * 2;
    }

    if (_hwndStatic)
        MoveWindow(_hwndStatic, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), FALSE);

    return 0;
}


HRESULT CUserPane::_UpdateUserInfo()
{
    HRESULT hr = S_OK;

    if(!SHRestricted(REST_NOUSERNAMEINSTARTPANEL))
    {
        //No restrictions!
        //Try to get the fiendly name or if it fails get the login name.
        ULONG uLen = ARRAYSIZE(_szUserName);
        SHGetUserDisplayName(_szUserName, &uLen); // Ignore failure. The string will be empty by default
    }

    // see if we should load the picture
    BOOL bShowPicture = FALSE;
    if (_hTheme)
        GetThemeBool(_hTheme, SPP_USERPANE, 0, TMT_USERPICTURE, &bShowPicture);

    // add FriendlyLogonUI check here, since SHGetUserPicturePath 
    if (bShowPicture && IsOS(OS_FRIENDLYLOGONUI))
    {
        TCHAR szUserPicturePath[MAX_PATH];
        szUserPicturePath[0] = _T('0');

        SHGetUserPicturePath(NULL, SHGUPP_FLAG_CREATE, szUserPicturePath);

        if (szUserPicturePath[0])
        {
            if (_hbmUserPicture)
            {
                DeleteObject(_hbmUserPicture);
                _hbmUserPicture = NULL;
            }

            _hbmUserPicture = (HBITMAP)LoadImage(NULL, szUserPicturePath, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE  | LR_CREATEDIBSECTION);
            if (_hbmUserPicture)
            {
                BITMAP bm;

                GetObject(_hbmUserPicture, sizeof(bm), &bm);

                // Preferred dimensions
                _iUnframedPicHeight = USERPICHEIGHT;
                _iUnframedPicWidth = USERPICWIDTH;

                // If it's not square, scale the smaller dimension
                // to maintain the aspect ratio.
                if (bm.bmWidth > bm.bmHeight)
                {
                    _iUnframedPicHeight = MulDiv(_iUnframedPicWidth, bm.bmHeight, bm.bmWidth);
                }
                else if (bm.bmHeight > bm.bmWidth)
                {
                    _iUnframedPicWidth = MulDiv(_iUnframedPicHeight, bm.bmWidth, bm.bmHeight);
                }

                _iFramedPicHeight = USERPICHEIGHT;
                _iFramedPicWidth = USERPICWIDTH;

                if (_hTheme)
                {
                    if (SUCCEEDED(GetThemeMargins(_hTheme, NULL, SPP_USERPICTURE, 0, TMT_CONTENTMARGINS, NULL,
                        &_mrgnPictureFrame)))
                    {
                        _iFramedPicHeight += _mrgnPictureFrame.cyTopHeight + _mrgnPictureFrame.cyBottomHeight;
                        _iFramedPicWidth += _mrgnPictureFrame.cxLeftWidth + _mrgnPictureFrame.cxRightWidth;
                    }
                    else
                    {
                        // Sometimes GetThemeMargins gets confused and returns failure
                        // *and* puts garbage data in _mrgnPictureFrame.
                        ZeroMemory(&_mrgnPictureFrame, sizeof(_mrgnPictureFrame));
                    }
                }
            }
        }

        if (!_uidChangeRegister)
        {
            SHChangeNotifyEntry fsne;
            fsne.fRecursive = FALSE;
            fsne.pidl = NULL;

            _uidChangeRegister = SHChangeNotifyRegister(_hwnd, SHCNRF_NewDelivery | SHCNRF_ShellLevel, SHCNE_EXTENDED_EVENT, 
                                    UPM_CHANGENOTIFY, 1, &fsne);
        }
    }

    OnSize();
    NMHDR nm;
    nm.hwndFrom = _hwnd;
    nm.idFrom = 0;
    nm.code = SMN_NEEDREPAINT;
    SendMessage(GetParent(_hwnd), WM_NOTIFY, nm.idFrom, (LPARAM)&nm);


    return hr;
}

BOOL WINAPI UserPane_RegisterClass()
{
    WNDCLASSEX wc;
    ZeroMemory(&wc, sizeof(wc));
    
    wc.cbSize        = sizeof(wc);
    wc.style         = CS_GLOBALCLASS;
    wc.lpfnWndProc   = CUserPane::s_WndProc;
    wc.hInstance     = _Module.GetModuleInstance();
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(NULL);
    wc.lpszClassName = WC_USERPANE;

    return RegisterClassEx(&wc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\biologon\biologon.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: BioLogon.cpp
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  File that implements a publicly declared import that forwards to an
//  implementation in shgina.dll
//
//  History:    2001-04-10  vtan        created
//  --------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <windows.h>

HANDLE  g_hLSA  =   NULL;

//  --------------------------------------------------------------------------
//  CheckTCBPrivilege
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether the thread impersonation token or the process
//              level token has SE_TCB_PRIVILEGE.
//
//  History:    2001-06-04  vtan        created
//  --------------------------------------------------------------------------

BOOL    CheckTCBPrivilege (void)

{
    BOOL    fResult;
    HANDLE  hToken;

    fResult = FALSE;
    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken) == FALSE)
    {
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) == FALSE)
        {
            hToken = NULL;
        }
    }
    if (hToken != NULL)
    {
        DWORD   dwReturnLength;

        dwReturnLength = 0;
        (BOOL)GetTokenInformation(hToken,
                                  TokenPrivileges,
                                  NULL,
                                  0,
                                  &dwReturnLength);
        if (dwReturnLength != 0)
        {
            TOKEN_PRIVILEGES    *pTokenPrivileges;

            pTokenPrivileges = static_cast<TOKEN_PRIVILEGES*>(LocalAlloc(LMEM_FIXED, dwReturnLength));
            if (pTokenPrivileges != NULL)
            {
                if (GetTokenInformation(hToken,
                                        TokenPrivileges,
                                        pTokenPrivileges,
                                        dwReturnLength,
                                        &dwReturnLength) != FALSE)
                {
                    bool    fFound;
                    DWORD   dwIndex;
                    LUID    luidPrivilege;

                    luidPrivilege.LowPart = SE_TCB_PRIVILEGE;
                    luidPrivilege.HighPart = 0;
                    for (fFound = false, dwIndex = 0; !fFound && (dwIndex < pTokenPrivileges->PrivilegeCount); ++dwIndex)
                    {
                        fFound = RtlEqualLuid(&pTokenPrivileges->Privileges[dwIndex].Luid, &luidPrivilege);
                    }
                    if (fFound)
                    {
                        fResult = TRUE;
                    }
                    else
                    {
                        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
                    }
                }
                (HLOCAL)LocalFree(pTokenPrivileges);
            }
        }
        (BOOL)CloseHandle(hToken);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  ::EnableBlankPasswords
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Uses the MSV1_0 package via LSA to enable blank passwords for
//              this process.
//
//  History:    2001-06-04  vtan        created
//  --------------------------------------------------------------------------

BOOL    EnableBlankPasswords (void)

{
    NTSTATUS    status;

    if (g_hLSA == NULL)
    {
        LSA_OPERATIONAL_MODE    LSAOperationalMode;
        STRING                  strLogonProcess;

        RtlInitString(&strLogonProcess, "BioLogon");
        status = LsaRegisterLogonProcess(&strLogonProcess, &g_hLSA, &LSAOperationalMode);
        if (NT_SUCCESS(status))
        {
            ULONG       ulPackageID;
            STRING      strMSVPackage;

            RtlInitString(&strMSVPackage, MSV1_0_PACKAGE_NAME);
            status = LsaLookupAuthenticationPackage(g_hLSA,
                                                    &strMSVPackage,
                                                    &ulPackageID);
            if (NT_SUCCESS(status))
            {
                NTSTATUS                            statusProtocol;
                ULONG                               ulResponseSize;
                MSV1_0_SETPROCESSOPTION_REQUEST     request;
                void*                               pResponse;

                ZeroMemory(&request, sizeof(request));
                request.MessageType = MsV1_0SetProcessOption;
                request.ProcessOptions = MSV1_0_OPTION_ALLOW_BLANK_PASSWORD;
                request.DisableOptions = FALSE;
                status = LsaCallAuthenticationPackage(g_hLSA,
                                                      ulPackageID,
                                                      &request,
                                                      sizeof(request),
                                                      &pResponse,
                                                      &ulResponseSize,
                                                      &statusProtocol);
                if (NT_SUCCESS(status))
                {
                    status = statusProtocol;
                }
            }
        }
        if (!NT_SUCCESS(status))
        {
            SetLastError(RtlNtStatusToDosError(status));
        }
    }
    else
    {
        SetLastError(ERROR_ALREADY_INITIALIZED);
        status = STATUS_UNSUCCESSFUL;
    }
    return(NT_SUCCESS(status));
}

//  --------------------------------------------------------------------------
//  ::InitializeBioLogon
//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Initialize the biologon DLL. This call is required if you
//              want to be able to use blank passwords. This will check that
//              the caller has SE_TCB_PRIVILEGE.
//
//  History:    2001-06-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  InitializeBioLogon (void)

{
    return(CheckTCBPrivilege() && EnableBlankPasswords());
}


//  --------------------------------------------------------------------------
//  ::InitiateInteractiveLogonWithTimeout
//
//  Arguments:  pszUsername     =   User name.
//              pszPassword     =   Password.
//              dwTimeout       =   Time out in milliseconds.
//
//  Returns:    BOOL
//
//  Purpose:    External entry point function exported by name to initiate
//              an interactive logon with specified timeout.
//
//  History:    2001-06-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  InitiateInteractiveLogonWithTimeout (const WCHAR *pszUsername, WCHAR *pszPassword, DWORD dwTimeout)

{
    typedef BOOL    (WINAPI * PFNIIL) (const WCHAR *pszUsername, WCHAR *pszPassword, DWORD dwTimeout);

            BOOL        fResult;
    static  HMODULE     s_hModule   =   reinterpret_cast<HMODULE>(-1);
    static  PFNIIL      s_pfnIIL    =   NULL;

    if (s_hModule == reinterpret_cast<HMODULE>(-1))
    {
        s_hModule = LoadLibrary(TEXT("shgina.dll"));
        if (s_hModule != NULL)
        {
            s_pfnIIL = reinterpret_cast<PFNIIL>(GetProcAddress(s_hModule, MAKEINTRESOURCEA(6)));
            if (s_pfnIIL != NULL)
            {
                fResult = s_pfnIIL(pszUsername, pszPassword, dwTimeout);
            }
            else
            {
                fResult = FALSE;
            }
        }
        else
        {
            fResult = FALSE;
        }
    }
    else if (s_pfnIIL != NULL)
    {
        fResult = s_pfnIIL(pszUsername, pszPassword, dwTimeout);
    }
    else
    {
        fResult = FALSE;
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  ::InitiateInteractiveLogon
//
//  Arguments:  pszUsername     =   User name.
//              pszPassword     =   Password.
//
//  Returns:    BOOL
//
//  Purpose:    External entry point function exported by name to initiate
//              an interactive logon. This passes an INFINITE timeout. Use
//              this function with care.
//
//  History:    2001-06-04  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  InitiateInteractiveLogon (const WCHAR *pszUsername, WCHAR *pszPassword)

{
    return(InitiateInteractiveLogonWithTimeout(pszUsername, pszPassword, INFINITE));
}

//  --------------------------------------------------------------------------
//  ::DllMain
//
//  Arguments:  See the platform SDK under DllMain.
//
//  Returns:    BOOL
//
//  Purpose:    DllMain for the DLL. Recognizes only DLL_PROCESS_DETACH to do
//              some clean up.
//
//  History:    2001-06-05  vtan        created
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  DllMain (HINSTANCE hInstance, DWORD dwReason, void *pvReserved)

{
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(pvReserved);

    switch (dwReason)
    {
        case DLL_PROCESS_DETACH:
            if (g_hLSA != NULL)
            {
                (BOOL)CloseHandle(g_hLSA);
                g_hLSA = NULL;
            }
            break;
        default:
            break;
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\brfcase.c ===
/*
 * brfcase.c - Briefcase ADT module.
 */

/*



 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "findbc.h"


/* Constants
 ************/

/* database file attributes */

#define DB_FILE_ATTR                (FILE_ATTRIBUTE_HIDDEN)

/* database cache lengths */

#define DEFAULT_DATABASE_CACHE_LEN  (32)
#define MAX_DATABASE_CACHE_LEN      (32 * 1024)

/* string table allocation constants */

#define NUM_NAME_HASH_BUCKETS       (67)


/* Types
 ********/

/* briefcase database description */

typedef struct _brfcasedb
{
    /*
     * handle to path of folder of open database (stored in briefcase path list)
     */

    HPATH hpathDBFolder;

    /* name of database file */

    LPTSTR pszDBName;

    /* handle to open cached database file */

    HCACHEDFILE hcfDB;

    /*
     * handle to path of folder that database was last saved in (stored in
     * briefcase's path list), only valid during OpenBriefcase() and
     * SaveBriefcase()
     */

    HPATH hpathLastSavedDBFolder;
}
BRFCASEDB;
DECLARE_STANDARD_TYPES(BRFCASEDB);

/*
 * briefcase flags
 *
 * N.b., the private BR_ flags must not collide with the public OB_ flags!
 */

typedef enum _brfcaseflags
{
    /* The briefcase database has been opened. */

    BR_FL_DATABASE_OPENED      = 0x00010000,

    /* The pimkRoot field is valid. */

    BR_FL_ROOT_MONIKER_VALID   = 0x00020000,

#ifdef DEBUG

    /* Briefcase is being deleted. */

    BR_FL_BEING_DELETED        = 0x01000000,

#endif

    /* flag combinations */

    ALL_BR_FLAGS               = (BR_FL_DATABASE_OPENED |
            BR_FL_ROOT_MONIKER_VALID
#ifdef DEBUG
            | BR_FL_BEING_DELETED
#endif
            ),

    ALL_BRFCASE_FLAGS          = (ALL_OB_FLAGS |
            ALL_BR_FLAGS)
}
BRFCASEFLAGS;

/* briefcase structure */

typedef struct _brfcase
{
    /* flags */

    DWORD dwFlags;

    /* handle to name string table */

    HSTRINGTABLE hstNames;

    /* handle to list of paths */

    HPATHLIST hpathlist;

    /* handle to array of pointers to twin families */

    HPTRARRAY hpaTwinFamilies;

    /* handle to array of pointers to folder pairs */

    HPTRARRAY hpaFolderPairs;

    /*
     * handle to parent window, only valid if OB_FL_ALLOW_UI is set in dwFlags
     * field
     */

    HWND hwndOwner;

    /* briewfcase database folder moniker */

    PIMoniker pimkRoot;

    /* database description */

    BRFCASEDB bcdb;
}
BRFCASE;
DECLARE_STANDARD_TYPES(BRFCASE);

/* database briefcase structure */

typedef struct _dbbrfcase
{
    /* old handle to folder that database was saved in */

    HPATH hpathLastSavedDBFolder;
}
DBBRFCASE;
DECLARE_STANDARD_TYPES(DBBRFCASE);

#ifdef DEBUG

/* debug flags */

typedef enum _dbdebugflags
{
    BRFCASE_DFL_NO_DB_SAVE     = 0x0001,

    BRFCASE_DFL_NO_DB_RESTORE  = 0x0002,

    ALL_BRFCASE_DFLAGS         = (BRFCASE_DFL_NO_DB_SAVE |
            BRFCASE_DFL_NO_DB_RESTORE)
}
DBDEBUGFLAGS;

#endif


/* Module Variables
 *******************/

/*
 * RAIDRAID: (16273) The use of MnrcsBriefcase in a shared data section is
 * broken under NT.  To run under NT, this code should be changed to use a
 * shared mutex.
 */

/* critical section used for briefcase access serialization */

PRIVATE_DATA NONREENTRANTCRITICALSECTION MnrcsBriefcase =
{
    { 0 },

#ifdef DEBUG
    INVALID_THREAD_ID,
#endif   /* DEBUG */

    FALSE
};

/* open briefcases */

PRIVATE_DATA HLIST MhlistOpenBriefcases = NULL;

/* database cache size */

PRIVATE_DATA DWORD MdwcbMaxDatabaseCacheLen = MAX_DATABASE_CACHE_LEN;

#ifdef DEBUG

/* debug flags */

PRIVATE_DATA DWORD MdwBriefcaseModuleFlags = 0;

/* .ini file switch descriptions */

PRIVATE_DATA CBOOLINISWITCH cbisNoDatabaseSave =
{
    IST_BOOL,
    TEXT("NoDatabaseSave"),
    &MdwBriefcaseModuleFlags,
    BRFCASE_DFL_NO_DB_SAVE
};

PRIVATE_DATA CBOOLINISWITCH cbisNoDatabaseRestore =
{
    IST_BOOL,
    TEXT("NoDatabaseRestore"),
    &MdwBriefcaseModuleFlags,
    BRFCASE_DFL_NO_DB_RESTORE
};

PRIVATE_DATA CUNSDECINTINISWITCH cdiisMaxDatabaseCacheLen =
{
    IST_UNS_DEC_INT,
    TEXT("MaxDatabaseCacheLen"),
    (PUINT)&MdwcbMaxDatabaseCacheLen
};

PRIVATE_DATA const PCVOID MrgcpcvisBriefcaseModule[] =
{
    &cbisNoDatabaseSave,
    &cbisNoDatabaseRestore,
    &cdiisMaxDatabaseCacheLen
};

#endif   /* DEBUG */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT OpenBriefcaseDatabase(PBRFCASE, LPCTSTR);
PRIVATE_CODE TWINRESULT CloseBriefcaseDatabase(PBRFCASEDB);
PRIVATE_CODE BOOL CreateBriefcase(PBRFCASE *, DWORD, HWND);
PRIVATE_CODE void UnlinkBriefcase(PBRFCASE);
PRIVATE_CODE TWINRESULT DestroyBriefcase(PBRFCASE);
PRIVATE_CODE TWINRESULT MyWriteDatabase(PBRFCASE);
PRIVATE_CODE TWINRESULT MyReadDatabase(PBRFCASE, DWORD);

#ifdef DEBUG

PRIVATE_CODE BOOL DestroyBriefcaseWalker(PVOID, PVOID);

#endif

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCBRFCASE(PCBRFCASE);
PRIVATE_CODE BOOL IsValidPCBRFCASEDB(PCBRFCASEDB);
PRIVATE_CODE BOOL IsValidPCOPENBRFCASEINFO(PCOPENBRFCASEINFO);

#endif


/*
 ** OpenBriefcaseDatabase()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT OpenBriefcaseDatabase(PBRFCASE pbr, LPCTSTR pcszPath)
{
    TWINRESULT tr;
    TCHAR rgchCanonicalPath[MAX_SEPARATED_PATH_LEN];
    DWORD dwOutFlags;
    TCHAR rgchNetResource[MAX_PATH_LEN];
    LPTSTR pszRootPathSuffix;

    ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));
    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

    if (GetCanonicalPathInfo(pcszPath, rgchCanonicalPath, &dwOutFlags,
                rgchNetResource, &pszRootPathSuffix))
    {
        LPTSTR pszDBName;

        pszDBName = (LPTSTR)ExtractFileName(pszRootPathSuffix);

        ASSERT(IS_SLASH(*(pszDBName - 1)));

        if (StringCopy(pszDBName, &(pbr->bcdb.pszDBName)))
        {
            if (pszDBName == pszRootPathSuffix)
            {
                /* Database in root. */

                *pszDBName = TEXT('\0');

                ASSERT(IsRootPath(rgchCanonicalPath));
            }
            else
            {
                ASSERT(pszDBName > pszRootPathSuffix);
                *(pszDBName - 1) = TEXT('\0');
            }

            tr = TranslatePATHRESULTToTWINRESULT(
                    AddPath(pbr->hpathlist, rgchCanonicalPath,
                        &(pbr->bcdb.hpathDBFolder)));

            if (tr == TR_SUCCESS)
            {
                if (IsPathVolumeAvailable(pbr->bcdb.hpathDBFolder))
                {
                    TCHAR rgchDBPath[MAX_PATH_LEN];
                    CACHEDFILE cfDB;

                    GetPathString(pbr->bcdb.hpathDBFolder, rgchDBPath, ARRAYSIZE(rgchDBPath));
                    CatPath(rgchDBPath, pbr->bcdb.pszDBName, ARRAYSIZE(rgchDBPath));

                    /* Assume sequential reads and writes. */

                    /* Share read access, but not write access. */

                    cfDB.pcszPath = rgchDBPath;
                    cfDB.dwOpenMode = (GENERIC_READ | GENERIC_WRITE);
                    cfDB.dwSharingMode = FILE_SHARE_READ;
                    cfDB.psa = NULL;
                    cfDB.dwCreateMode = OPEN_ALWAYS;
                    cfDB.dwAttrsAndFlags = (DB_FILE_ATTR | FILE_FLAG_SEQUENTIAL_SCAN);
                    cfDB.hTemplateFile = NULL;
                    cfDB.dwcbDefaultCacheSize = DEFAULT_DATABASE_CACHE_LEN;

                    tr = TranslateFCRESULTToTWINRESULT(
                            CreateCachedFile(&cfDB, &(pbr->bcdb.hcfDB)));

                    if (tr == TR_SUCCESS)
                    {
                        pbr->bcdb.hpathLastSavedDBFolder = NULL;

                        ASSERT(IS_FLAG_CLEAR(pbr->dwFlags, BR_FL_DATABASE_OPENED));
                        SET_FLAG(pbr->dwFlags, BR_FL_DATABASE_OPENED);
                    }
                    else
                    {
                        DeletePath(pbr->bcdb.hpathDBFolder);
OPENBRIEFCASEDATABASE_BAIL:
                        FreeMemory(pbr->bcdb.pszDBName);
                    }
                }
                else
                {
                    tr = TR_UNAVAILABLE_VOLUME;
                    goto OPENBRIEFCASEDATABASE_BAIL;
                }
            }
        }
        else
            tr = TR_OUT_OF_MEMORY;
    }
    else
        tr = TWINRESULTFromLastError(TR_INVALID_PARAMETER);

    return(tr);
}


/*
 ** CloseBriefcaseDatabase()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT CloseBriefcaseDatabase(PBRFCASEDB pbcdb)
{
    TWINRESULT tr;
    TCHAR rgchDBPath[MAX_PATH_LEN];
    FILESTAMP fsDB;

    tr = CloseCachedFile(pbcdb->hcfDB) ? TR_SUCCESS : TR_BRIEFCASE_WRITE_FAILED;

    if (tr == TR_SUCCESS)
        TRACE_OUT((TEXT("CloseBriefcaseDatabase(): Closed cached briefcase database file %s\\%s."),
                    DebugGetPathString(pbcdb->hpathDBFolder),
                    pbcdb->pszDBName));
    else
        WARNING_OUT((TEXT("CloseBriefcaseDatabase(): Failed to close cached briefcase database file %s\\%s."),
                    DebugGetPathString(pbcdb->hpathDBFolder),
                    pbcdb->pszDBName));

    /* Try not to leave a 0-length database laying around. */

    GetPathString(pbcdb->hpathDBFolder, rgchDBPath, ARRAYSIZE(rgchDBPath));
    CatPath(rgchDBPath, pbcdb->pszDBName, ARRAYSIZE(rgchDBPath));

    MyGetFileStamp(rgchDBPath, &fsDB);

    if (fsDB.fscond == FS_COND_EXISTS &&
            (! fsDB.dwcbLowLength && ! fsDB.dwcbHighLength))
    {
        if (DeleteFile(rgchDBPath))
            WARNING_OUT((TEXT("CloseBriefcaseDatabase(): Deleted 0 length database %s\\%s."),
                        DebugGetPathString(pbcdb->hpathDBFolder),
                        pbcdb->pszDBName));
    }

    FreeMemory(pbcdb->pszDBName);
    DeletePath(pbcdb->hpathDBFolder);

    return(tr);
}


/*
 ** CreateBriefcase()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CreateBriefcase(PBRFCASE *ppbr, DWORD dwInFlags,
        HWND hwndOwner)
{
    BOOL bResult = FALSE;

    ASSERT(IS_VALID_WRITE_PTR(ppbr, PBRFCASE));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_BRFCASE_FLAGS));
    ASSERT(IS_FLAG_CLEAR(dwInFlags, OB_FL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));

    if (AllocateMemory(sizeof(**ppbr), ppbr))
    {
        DWORD dwCPLFlags;

        dwCPLFlags = (RLI_IFL_CONNECT |
                RLI_IFL_UPDATE |
                RLI_IFL_LOCAL_SEARCH);

        if (IS_FLAG_SET(dwInFlags, OB_FL_ALLOW_UI))
            SET_FLAG(dwCPLFlags, RLI_IFL_ALLOW_UI);

        if (CreatePathList(dwCPLFlags, hwndOwner, &((*ppbr)->hpathlist)))
        {
            NEWSTRINGTABLE nszt;

            nszt.hbc = NUM_NAME_HASH_BUCKETS;

            if (CreateStringTable(&nszt, &((*ppbr)->hstNames)))
            {
                if (CreateTwinFamilyPtrArray(&((*ppbr)->hpaTwinFamilies)))
                {
                    if (CreateFolderPairPtrArray(&((*ppbr)->hpaFolderPairs)))
                    {
                        HNODE hnode;

                        if (InsertNodeAtFront(MhlistOpenBriefcases, NULL, (*ppbr), &hnode))
                        {
                            (*ppbr)->dwFlags = dwInFlags;
                            (*ppbr)->hwndOwner = hwndOwner;

                            bResult = TRUE;
                        }
                        else
                        {
                            DestroyFolderPairPtrArray((*ppbr)->hpaFolderPairs);
CREATEBRIEFCASE_BAIL1:
                            DestroyTwinFamilyPtrArray((*ppbr)->hpaTwinFamilies);
CREATEBRIEFCASE_BAIL2:
                            DestroyStringTable((*ppbr)->hstNames);
CREATEBRIEFCASE_BAIL3:
                            DestroyPathList((*ppbr)->hpathlist);
CREATEBRIEFCASE_BAIL4:
                            FreeMemory((*ppbr));
                        }
                    }
                    else
                        goto CREATEBRIEFCASE_BAIL1;
                }
                else
                    goto CREATEBRIEFCASE_BAIL2;
            }
            else
                goto CREATEBRIEFCASE_BAIL3;
        }
        else
            goto CREATEBRIEFCASE_BAIL4;
    }

    ASSERT(! bResult ||
            IS_VALID_STRUCT_PTR(*ppbr, CBRFCASE));

    return(bResult);
}


/*
 ** UnlinkBriefcase()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void UnlinkBriefcase(PBRFCASE pbr)
{
    BOOL bContinue;
    HNODE hnode;

    ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));

    for (bContinue = GetFirstNode(MhlistOpenBriefcases, &hnode);
            bContinue;
            bContinue = GetNextNode(hnode, &hnode))
    {
        PBRFCASE pbrTest;

        pbrTest = GetNodeData(hnode);

        ASSERT(IS_VALID_STRUCT_PTR(pbrTest, CBRFCASE));

        if (pbrTest == pbr)
        {
            DeleteNode(hnode);
            break;
        }
    }

    ASSERT(bContinue);

    return;
}


/*
 ** DestroyBriefcase()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT DestroyBriefcase(PBRFCASE pbr)
{
    TWINRESULT tr;

    ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));

#ifdef DEBUG

    SET_FLAG(pbr->dwFlags, BR_FL_BEING_DELETED);

#endif

    if (IS_FLAG_SET(pbr->dwFlags, BR_FL_DATABASE_OPENED))
        tr = CloseBriefcaseDatabase(&(pbr->bcdb));
    else
        tr = TR_SUCCESS;

    if (IS_FLAG_SET(pbr->dwFlags, BR_FL_ROOT_MONIKER_VALID))
        pbr->pimkRoot->lpVtbl->Release(pbr->pimkRoot);

    DestroyFolderPairPtrArray(pbr->hpaFolderPairs);

    DestroyTwinFamilyPtrArray(pbr->hpaTwinFamilies);

    ASSERT(! GetStringCount(pbr->hstNames));
    DestroyStringTable(pbr->hstNames);

    ASSERT(! GetPathCount(pbr->hpathlist));
    DestroyPathList(pbr->hpathlist);

    FreeMemory(pbr);

    return(tr);
}


/*
 ** MyWriteDatabase()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT MyWriteDatabase(PBRFCASE pbr)
{
    TWINRESULT tr;

    ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));

    ASSERT(IS_FLAG_SET(pbr->dwFlags, BR_FL_DATABASE_OPENED));

#ifdef DEBUG
    if (IS_FLAG_CLEAR(MdwBriefcaseModuleFlags, BRFCASE_DFL_NO_DB_SAVE))
#endif
    {
        /* Grow the database cache in preparation for writing. */

        ASSERT(MdwcbMaxDatabaseCacheLen > 0);

        if (SetCachedFileCacheSize(pbr->bcdb.hcfDB, MdwcbMaxDatabaseCacheLen)
                != FCR_SUCCESS)
            WARNING_OUT((TEXT("MyWriteDatabase(): Unable to grow database cache to %lu bytes.  Using default database write cache of %lu bytes."),
                        MdwcbMaxDatabaseCacheLen,
                        (DWORD)DEFAULT_DATABASE_CACHE_LEN));

        /* Write the database. */

        tr = WriteTwinDatabase(pbr->bcdb.hcfDB, (HBRFCASE)pbr);

        if (tr == TR_SUCCESS)
        {
            if (CommitCachedFile(pbr->bcdb.hcfDB))
            {
                /* Shrink the database cache back down to its default size. */

                EVAL(SetCachedFileCacheSize(pbr->bcdb.hcfDB,
                            DEFAULT_DATABASE_CACHE_LEN)
                        == FCR_SUCCESS);

                TRACE_OUT((TEXT("MyWriteDatabase(): Wrote database %s\\%s."),
                            DebugGetPathString(pbr->bcdb.hpathDBFolder),
                            pbr->bcdb.pszDBName));
            }
            else
                tr = TR_BRIEFCASE_WRITE_FAILED;
        }
    }
#ifdef DEBUG
    else
    {
        WARNING_OUT((TEXT("MyWriteDatabase(): Twin database %s\\%s not saved, by request."),
                    DebugGetPathString(pbr->bcdb.hpathDBFolder),
                    pbr->bcdb.pszDBName));

        tr = TR_SUCCESS;
    }
#endif

    return(tr);
}


/*
 ** MyReadDatabase()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT MyReadDatabase(PBRFCASE pbr, DWORD dwInFlags)
{
    TWINRESULT tr;

    ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));
    ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_OB_FLAGS));

#ifdef DEBUG
    if (IS_FLAG_CLEAR(MdwBriefcaseModuleFlags, BRFCASE_DFL_NO_DB_RESTORE))
#endif
    {
        DWORD dwcbDatabaseSize;

        /* Is there an exising database to read? */

        dwcbDatabaseSize = GetCachedFileSize(pbr->bcdb.hcfDB);

        if (dwcbDatabaseSize > 0)
        {
            DWORD dwcbMaxCacheSize;

            /* Yes.  Grow the database cache in preparation for reading. */

            /*
             * Use file length instead of MdwcbMaxDatabaseCacheLen if file length
             * is smaller.
             */

            ASSERT(MdwcbMaxDatabaseCacheLen > 0);

            if (dwcbDatabaseSize < MdwcbMaxDatabaseCacheLen)
            {
                dwcbMaxCacheSize = dwcbDatabaseSize;

                WARNING_OUT((TEXT("MyReadDatabase(): Using file size %lu bytes as read cache size for database %s\\%s."),
                            dwcbDatabaseSize,
                            DebugGetPathString(pbr->bcdb.hpathDBFolder),
                            pbr->bcdb.pszDBName));
            }
            else
                dwcbMaxCacheSize = MdwcbMaxDatabaseCacheLen;

            if (TranslateFCRESULTToTWINRESULT(SetCachedFileCacheSize(
                            pbr->bcdb.hcfDB,
                            dwcbMaxCacheSize))
                    != TR_SUCCESS)
                WARNING_OUT((TEXT("MyReadDatabase(): Unable to grow database cache to %lu bytes.  Using default database read cache of %lu bytes."),
                            dwcbMaxCacheSize,
                            (DWORD)DEFAULT_DATABASE_CACHE_LEN));

            tr = ReadTwinDatabase((HBRFCASE)pbr, pbr->bcdb.hcfDB);

            if (tr == TR_SUCCESS)
            {
                ASSERT(! pbr->bcdb.hpathLastSavedDBFolder ||
                        IS_VALID_HANDLE(pbr->bcdb.hpathLastSavedDBFolder, PATH));

                if (pbr->bcdb.hpathLastSavedDBFolder)
                {
                    if (IS_FLAG_SET(dwInFlags, OB_FL_TRANSLATE_DB_FOLDER) &&
                            ComparePaths(pbr->bcdb.hpathLastSavedDBFolder,
                                pbr->bcdb.hpathDBFolder) != CR_EQUAL)
                        tr = MyTranslateFolder((HBRFCASE)pbr,
                                pbr->bcdb.hpathLastSavedDBFolder,
                                pbr->bcdb.hpathDBFolder);

                    DeletePath(pbr->bcdb.hpathLastSavedDBFolder);
                    pbr->bcdb.hpathLastSavedDBFolder = NULL;
                }

                if (tr == TR_SUCCESS)
                    TRACE_OUT((TEXT("MyReadDatabase(): Read database %s\\%s."),
                                DebugGetPathString(pbr->bcdb.hpathDBFolder),
                                pbr->bcdb.pszDBName));
            }

            /* Shrink the database cache back down to its default size. */

            EVAL(TranslateFCRESULTToTWINRESULT(SetCachedFileCacheSize(
                            pbr->bcdb.hcfDB,
                            DEFAULT_DATABASE_CACHE_LEN))
                    == TR_SUCCESS);
        }
        else
        {
            tr = TR_SUCCESS;

            WARNING_OUT((TEXT("MyReadDatabase(): Database %s\\%s not found."),
                        DebugGetPathString(pbr->bcdb.hpathDBFolder),
                        pbr->bcdb.pszDBName));
        }
    }
#ifdef DEBUG
    else
    {
        WARNING_OUT((TEXT("MyReadDatabase(): Twin database %s\\%s not read, by request."),
                    DebugGetPathString(pbr->bcdb.hpathDBFolder),
                    pbr->bcdb.pszDBName));

        tr = TR_SUCCESS;
    }
#endif

    return(tr);
}


#ifdef DEBUG

/*
 ** DestroyBriefcaseWalker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL DestroyBriefcaseWalker(PVOID pbr, PVOID pvUnused)
{
    ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));
    ASSERT(! pvUnused);

    EVAL(DestroyBriefcase(pbr) == TR_SUCCESS);

    return(TRUE);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */

#endif


#ifdef VSTF

/*
 ** IsValidPCBRFCASE()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCBRFCASE(PCBRFCASE pcbr)
{
    BOOL bResult = FALSE;

    if (IS_VALID_READ_PTR(pcbr, CBRFCASE))
    {
        if (FLAGS_ARE_VALID(pcbr->dwFlags, ALL_BRFCASE_FLAGS))
        {
#ifdef DEBUG
            if (IS_FLAG_SET(pcbr->dwFlags, BR_FL_BEING_DELETED))
                bResult = TRUE;
            else
#endif
                bResult = (IS_VALID_HANDLE(pcbr->hstNames, STRINGTABLE) &&
                        IS_VALID_HANDLE(pcbr->hpathlist, PATHLIST) &&
                        IS_VALID_HANDLE(pcbr->hpaTwinFamilies, PTRARRAY) &&
                        IS_VALID_HANDLE(pcbr->hpaFolderPairs, PTRARRAY) &&
                        (IS_FLAG_CLEAR(pcbr->dwFlags, OB_FL_ALLOW_UI) ||
                         IS_VALID_HANDLE(pcbr->hwndOwner, WND)) &&
                        (IS_FLAG_CLEAR(pcbr->dwFlags, BR_FL_ROOT_MONIKER_VALID) ||
                         IS_VALID_STRUCT_PTR(pcbr->pimkRoot, CIMoniker)) &&
                        (IS_FLAG_CLEAR(pcbr->dwFlags, BR_FL_DATABASE_OPENED) ||
                         (IS_FLAG_SET(pcbr->dwFlags, OB_FL_OPEN_DATABASE) &&
                          IS_VALID_STRUCT_PTR(&(pcbr->bcdb), CBRFCASEDB))));
        }
    }

    return(bResult);
}


/*
 ** IsValidPCBRFCASEDB()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCBRFCASEDB(PCBRFCASEDB pcbcdb)
{
    return(IS_VALID_READ_PTR(pcbcdb, CBRFCASEDB) &&
            IS_VALID_HANDLE(pcbcdb->hpathDBFolder, PATH) &&
            IS_VALID_STRING_PTR(pcbcdb->pszDBName, STR) &&
            IS_VALID_HANDLE(pcbcdb->hcfDB, CACHEDFILE) &&
            (! pcbcdb->hpathLastSavedDBFolder ||
             IS_VALID_HANDLE(pcbcdb->hpathLastSavedDBFolder, PATH)));
}


/*
 ** IsValidPCOPENBRFCASEINFO()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCOPENBRFCASEINFO(PCOPENBRFCASEINFO pcobri)
{
    return(IS_VALID_READ_PTR(pcobri, COPENBRFCASEINFO) &&
            EVAL(pcobri->ulSize == sizeof(*pcobri)) &&
            FLAGS_ARE_VALID(pcobri->dwFlags, ALL_OB_FLAGS) &&
            ((IS_FLAG_CLEAR(pcobri->dwFlags, OB_FL_ALLOW_UI) &&
              ! pcobri->hwndOwner) ||
             (IS_FLAG_SET(pcobri->dwFlags, OB_FL_ALLOW_UI) &&
              IS_VALID_HANDLE(pcobri->hwndOwner, WND))) &&
            ((IS_FLAG_CLEAR(pcobri->dwFlags, OB_FL_OPEN_DATABASE) &&
              ! pcobri->hvid &&
              ! (pcobri->rgchDatabasePath[0]))) ||
            ((IS_FLAG_SET(pcobri->dwFlags, OB_FL_OPEN_DATABASE) &&
              IS_VALID_HANDLE(pcobri->hvid, VOLUMEID) &&
              IS_VALID_STRING_PTR(pcobri->rgchDatabasePath, CSTR))));
}

#endif


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
 ** SetBriefcaseModuleIniSwitches()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL SetBriefcaseModuleIniSwitches(void)
{
    BOOL bResult;

    bResult = SetIniSwitches(MrgcpcvisBriefcaseModule,
            ARRAY_ELEMENTS(MrgcpcvisBriefcaseModule));

    if (! EVAL(MdwcbMaxDatabaseCacheLen > 0))
    {
        MdwcbMaxDatabaseCacheLen = 1;

        WARNING_OUT((TEXT("SetBriefcaseModuleIniSwitches(): Using maximum database cache length of %lu."),
                    MdwcbMaxDatabaseCacheLen));
    }

    ASSERT(FLAGS_ARE_VALID(MdwBriefcaseModuleFlags, ALL_BRFCASE_DFLAGS));

    return(bResult);
}

#endif


/*
 ** InitBriefcaseModule()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL InitBriefcaseModule(void)
{
    NEWLIST nl;

    ASSERT(! MhlistOpenBriefcases);

    /* Create the module list of open briefcases. */

    ReinitializeNonReentrantCriticalSection(&MnrcsBriefcase);

    nl.dwFlags = 0;

    return(CreateList(&nl, &MhlistOpenBriefcases));
}


/*
 ** ExitBriefcaseModule()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void ExitBriefcaseModule(void)
{

#ifdef DEBUG

    if (MhlistOpenBriefcases)
    {
        /* Destroy all open briefcases. */

        /*
         * Don't destroy the list of open briefcases in the retail build.  Assume
         * that callers will have closed all open briefcases, so that there are
         * no remaining connections to shut down.
         */

        EVAL(WalkList(MhlistOpenBriefcases, &DestroyBriefcaseWalker, NULL));

        /* Now wipe out the list. */

        DestroyList(MhlistOpenBriefcases);
        MhlistOpenBriefcases = NULL;
    }
    else
        WARNING_OUT((TEXT("ExitBriefcaseModule() called when MhlistOpenBriefcases is NULL.")));

#endif

    DeleteCriticalSection(&MnrcsBriefcase.critsec);

    return;
}


/*
 ** GetBriefcaseNameStringTable()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HSTRINGTABLE GetBriefcaseNameStringTable(HBRFCASE hbr)
{
    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

    return(((PCBRFCASE)hbr)->hstNames);
}


/*
 ** GetBriefcaseTwinFamilyPtrArray()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HPTRARRAY GetBriefcaseTwinFamilyPtrArray(HBRFCASE hbr)
{
    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

    return(((PCBRFCASE)hbr)->hpaTwinFamilies);
}


/*
 ** GetBriefcaseFolderPairPtrArray()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HPTRARRAY GetBriefcaseFolderPairPtrArray(HBRFCASE hbr)
{
    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

    return(((PCBRFCASE)hbr)->hpaFolderPairs);
}


/*
 ** GetBriefcasePathList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HPATHLIST GetBriefcasePathList(HBRFCASE hbr)
{
    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

    return(((PCBRFCASE)hbr)->hpathlist);
}


/*
 ** GetBriefcaseRootMoniker()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE HRESULT GetBriefcaseRootMoniker(HBRFCASE hbr, PIMoniker *pimk)
{
    HRESULT hr;

    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
    ASSERT(IS_VALID_WRITE_PTR(pimk, CIMoniker));

    if (IS_FLAG_CLEAR(((PCBRFCASE)hbr)->dwFlags, BR_FL_ROOT_MONIKER_VALID))
    {
        if (IS_FLAG_SET(((PCBRFCASE)hbr)->dwFlags, BR_FL_DATABASE_OPENED))
        {
            TCHAR rgchRoot[MAX_PATH_LEN];
            WCHAR rgwchUnicodeRoot[MAX_PATH_LEN];
            PIMoniker pimkRoot;

            rgchRoot[0] = TEXT('\0');
            GetPathString(((PCBRFCASE)hbr)->bcdb.hpathDBFolder, rgchRoot, ARRAYSIZE(rgchRoot));

#ifdef UNICODE

            hr = CreateFileMoniker(rgchRoot, &pimkRoot);
#else

            /* Translate ANSI string into Unicode for OLE. */

            if (0 == MultiByteToWideChar(CP_ACP, 0, rgchRoot, -1, rgwchUnicodeRoot,
                        ARRAY_ELEMENTS(rgwchUnicodeRoot)))
            {
                hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
            }
            else
            {            
                hr = CreateFileMoniker(rgwchUnicodeRoot, &pimkRoot);
            }

#endif

            if (SUCCEEDED(hr))
            {
                ((PBRFCASE)hbr)->pimkRoot = pimkRoot;
                SET_FLAG(((PBRFCASE)hbr)->dwFlags, BR_FL_ROOT_MONIKER_VALID);

                TRACE_OUT((TEXT("GetBriefcaseRootMoniker(): Created briefcase root moniker %s."),
                            rgchRoot));
            }
        }
        else
            hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND);
    }
    else
        hr = S_OK;

    if (SUCCEEDED(hr))
        *pimk = ((PCBRFCASE)hbr)->pimkRoot;

    ASSERT(FAILED(hr) ||
            IS_VALID_STRUCT_PTR(*pimk, CIMoniker));

    return(hr);
}


/*
 ** BeginExclusiveBriefcaseAccess()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL BeginExclusiveBriefcaseAccess(void)
{
    return(EnterNonReentrantCriticalSection(&MnrcsBriefcase));
}


/*
 ** EndExclusiveBriefcaseAccess()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void EndExclusiveBriefcaseAccess(void)
{
    LeaveNonReentrantCriticalSection(&MnrcsBriefcase);

    return;
}


#ifdef DEBUG

/*
 ** BriefcaseAccessIsExclusive()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL BriefcaseAccessIsExclusive(void)
{
    return(NonReentrantCriticalSectionIsOwned(&MnrcsBriefcase));
}

#endif   /* DEBUG */


/*
 ** IsValidHBRFCASE()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHBRFCASE(HBRFCASE hbr)
{
    return(IS_VALID_STRUCT_PTR((PCBRFCASE)hbr, CBRFCASE));
}


/*
 ** WriteBriefcaseInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT WriteBriefcaseInfo(HCACHEDFILE hcf, HBRFCASE hbr)
{
    TWINRESULT tr;
    DBBRFCASE dbbr;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

    /* Set up briefcase database structure. */

    ASSERT(IS_VALID_HANDLE(((PCBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder, PATH));

    dbbr.hpathLastSavedDBFolder = ((PCBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder;

    /* Save briefcase database structure. */

    if (WriteToCachedFile(hcf, (PCVOID)&dbbr, sizeof(dbbr), NULL))
    {
        tr = TR_SUCCESS;

        TRACE_OUT((TEXT("WriteBriefcaseInfo(): Wrote last saved database folder %s."),
                    DebugGetPathString(dbbr.hpathLastSavedDBFolder)));
    }
    else
        tr = TR_BRIEFCASE_WRITE_FAILED;

    return(tr);
}


/*
 ** ReadBriefcaseInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT ReadBriefcaseInfo(HCACHEDFILE hcf, HBRFCASE hbr,
        HHANDLETRANS hhtFolderTrans)
{
    TWINRESULT tr;
    DBBRFCASE dbbr;
    DWORD dwcbRead;
    HPATH hpath;

    ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
    ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));

    /* Read briefcase database structure. */

    if ((ReadFromCachedFile(hcf, &dbbr, sizeof(dbbr), &dwcbRead) &&
                dwcbRead == sizeof(dbbr)) &&
            TranslateHandle(hhtFolderTrans, (HGENERIC)(dbbr.hpathLastSavedDBFolder),
                (PHGENERIC)&hpath))
    {
        HPATH hpathLastSavedDBFolder;

        /*
         * Bump last saved database folder path's lock count in the briefcase's
         * path list.
         */

        if (CopyPath(hpath, ((PCBRFCASE)hbr)->hpathlist, &hpathLastSavedDBFolder))
        {
            ((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder = hpathLastSavedDBFolder;

            tr = TR_SUCCESS;

            TRACE_OUT((TEXT("ReadBriefcaseInfo(): Read last saved database folder %s."),
                        DebugGetPathString(((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder)));
        }
        else
            tr = TR_OUT_OF_MEMORY;
    }
    else
        tr = TR_CORRUPT_BRIEFCASE;

    return(tr);
}


/***************************** Exported Functions ****************************/


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | OpenBriefcase | Opens an existing briefcase database, or
  creates a new briefcase.

  @parm PCSTR | pcszPath | A pointer to a path string indicating the briefcase
  database to be opened or created.  This parameter is ignored unless the
  OB_FL_OPEN_DATABASE flag is set in dwFlags.

  @parm DWORD | dwInFlags | A bit mask of flags.  This parameter may be any
  combination of the following values:
  OB_FL_OPEN_DATABASE - Open the briefcase database specified by pcszPath.
  OB_FL_TRANSLATE_DB_FOLDER - Translate the folder where the briefcase
  database was last saved to the folder where the briefcase database was
  opened.
  OB_FL_ALLOW_UI - Allow interaction with the user during briefcase
  operations.

  @parm HWND | hwndOwner | A handle to the parent window to be used when
  requesting user interaction.  This parameter is ignored if the OB_FL_ALLOW_UI
  flag is clear.

  @parm PHBRFCASE | phbr | A pointer to an HBRFCASE to be filled in with a
  handle to the open briefcase.  *phbr is only valid if TR_SUCCESS is returned.

  @rdesc If the briefcase was opened or created successfully, TR_SUCCESS is
  returned, and *phbr contains a handle to the open briefcase.  Otherwise, the
  briefcase was not opened or created successfully, the return value indicates
  the error that occurred, and *phbr is undefined.

  @comm If the OB_FL_OPEN_DATABASE flag is set in dwFlags, the database specified
  by pcszPath is associated with the briefcase.  If the database specified does
  not exist, the database is created.<nl>
  If the OB_FL_OPEN_DATABASE flag is clear in dwFlags, no persistent database is
  associated with the briefcase.  SaveBriefcase() will fail if called on a
  briefcase with no associated database.<nl>
  Once the caller is finished with the briefcase handle returned by
  OpenBriefcase(), CloseBriefcase() should be called to release the briefcase.
  SaveBriefcase() may be called before CloseBriefcase() to save the current
  contents of the briefcase.

  @xref SaveBriefcase CloseBriefcase

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI OpenBriefcase(LPCTSTR pcszPath, DWORD dwInFlags,
        HWND hwndOwner, PHBRFCASE phbr)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(OpenBriefcase);

#ifdef EXPV
        /* Verify parameters. */

        if (FLAGS_ARE_VALID(dwInFlags, ALL_OB_FLAGS) &&
                IS_VALID_WRITE_PTR(phbr, HBRFCASE) &&
                (IS_FLAG_CLEAR(dwInFlags, OB_FL_OPEN_DATABASE) ||
                 IS_VALID_STRING_PTR(pcszPath, CSTR)) &&
                (IS_FLAG_CLEAR(dwInFlags, OB_FL_ALLOW_UI) ||
                 IS_VALID_HANDLE(hwndOwner, WND)))
#endif
        {
            PBRFCASE pbr;

            if (CreateBriefcase(&pbr, dwInFlags, hwndOwner))
            {
                if (IS_FLAG_SET(dwInFlags, OB_FL_OPEN_DATABASE))
                {
                    tr = OpenBriefcaseDatabase(pbr, pcszPath);

                    if (tr == TR_SUCCESS)
                    {
                        tr = MyReadDatabase(pbr, dwInFlags);

                        if (tr == TR_SUCCESS)
                        {
                            if (IS_FLAG_SET(dwInFlags, OB_FL_LIST_DATABASE))
                                EVAL(AddBriefcaseToSystem(pcszPath) == TR_SUCCESS);

                            *phbr = (HBRFCASE)pbr;
                        }
                        else
                        {
OPENBRIEFCASE_BAIL:
                            UnlinkBriefcase(pbr);
                            EVAL(DestroyBriefcase(pbr) == TR_SUCCESS);
                        }
                    }
                    else
                        goto OPENBRIEFCASE_BAIL;
                }
                else
                {
                    *phbr = (HBRFCASE)pbr;
                    tr = TR_SUCCESS;

                    TRACE_OUT((TEXT("OpenBriefcase(): Opened briefcase %#lx with no associated database, by request."),
                                *phbr));
                }
            }
            else
                tr = TR_OUT_OF_MEMORY;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(OpenBriefcase, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | SaveBriefcase | Saves the contents of an open briefcase to a
  briefcase database.

  @parm HBRFCASE | hbr | A handle to the briefcase to be saved.  This handle may
  be obtained by calling OpenBriefcase() with a briefcase database path and with
  the OB_FL_OPEN_DATABASE flag set.  SaveBriefcase() will return
  TR_INVALID_PARAMETER if called on a briefcase with no associated briefcase
  database.

  @rdesc If the contents of the briefcase was saved to the briefcase database
  successfully, TR_SUCCESS is returned.  Otherwise, the contents of the briefcase
  was not saved to the briefcase database successfully, and the return value
  indicates the error that occurred.

  @xref OpenBriefcase CloseBriefcase

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI SaveBriefcase(HBRFCASE hbr)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(SaveBriefcase);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hbr, BRFCASE) &&
                IS_FLAG_SET(((PBRFCASE)hbr)->dwFlags, BR_FL_DATABASE_OPENED))
#endif
        {
            ((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder = ((PCBRFCASE)hbr)->bcdb.hpathDBFolder;

            tr = MyWriteDatabase((PBRFCASE)hbr);

            ((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder = NULL;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(SaveBriefcase, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | CloseBriefcase | Closes an open briefcase.

  @parm HBRFCASE | hbr | A handle to the briefcase to be closed.  This handle may
  be obtained by calling OpenBriefcase().

  @rdesc If the briefcase was closed successfully, TR_SUCCESS is returned.
  Otherwise, the briefcase was not closed successfully, and the return value
  indicates the error that occurred.

  @xref OpenBriefcase SaveBriefcase

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CloseBriefcase(HBRFCASE hbr)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(CloseBriefcase);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hbr, BRFCASE))
#endif
        {
            UnlinkBriefcase((PBRFCASE)hbr);

            tr = DestroyBriefcase((PBRFCASE)hbr);
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(CloseBriefcase, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | DeleteBriefcase | Deletes a closed briefcase's database file.

  @parm PCSTR | pcszPath | A pointer to a path string indicating the briefcase
  database that is to be deleted.

  @rdesc If the briefcase database was deleted successfully, TR_SUCCESS is
  returned.  Otherwise, the briefcase database was not deleted successfully, and
  the return value indicates the error that occurred.

  @comm Clients should call DeleteBriefcase() instead of DeleteFile() to delete
  an unwanted briefcase database so that the the synchronization engine may
  verify that the given briefcase database is not in use before deleting it.

  @xref OpenBriefcase SaveBriefcase CloseBriefcase

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI DeleteBriefcase(LPCTSTR pcszPath)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(DeleteBriefcase);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_STRING_PTR(pcszPath, CSTR))
#endif
        {
            /*
             * RAIDRAID: (16275) Check database header here to verify that the
             * file is a briefcase database file.
             */

            if (DeleteFile(pcszPath))
            {
                EVAL(RemoveBriefcaseFromSystem(pcszPath) == TR_SUCCESS);

                tr = TR_SUCCESS;
            }
            else
            {
                switch (GetLastError())
                {
                    /* Returned when file opened by local machine. */
                    case ERROR_SHARING_VIOLATION:
                        tr = TR_BRIEFCASE_LOCKED;
                        break;

                    default:
                        tr = TR_BRIEFCASE_OPEN_FAILED;
                        break;
                }
            }
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(DeleteBriefcase, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | GetOpenBriefcaseInfo | Describes an open briefcase.

  @parm HBRFCASE | hbr | A handle to the open briefcase to be described.

  @parm POPENBRFCASEINFO | pobri | A pointer to an OPENBRFCASEINFO to be filled
  in with information describing the open briefcase.  The ulSize field of the
  OPENBRFCASEINFO structure should be filled in with sizeof(OPENBRFCASEINFO)
  before calling GetOpenBriefcaseInfo().

  @rdesc If the open briefcase was described successfully, TR_SUCCESS is
  returned.  Otherwise, the open briefcase was not described successfully, and
  the return value indicates the error that occurred.

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI GetOpenBriefcaseInfo(HBRFCASE hbr,
        POPENBRFCASEINFO pobri)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(GetBriefcaseInfo);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hbr, BRFCASE) &&
                IS_VALID_WRITE_PTR(pobri, OPENBRFCASEINFO) &&
                EVAL(pobri->ulSize == sizeof(*pobri)))
#endif
        {
            pobri->dwFlags = (((PBRFCASE)hbr)->dwFlags & ~ALL_BR_FLAGS);

            if (IS_FLAG_SET(((PBRFCASE)hbr)->dwFlags, OB_FL_ALLOW_UI))
                pobri->hwndOwner = ((PBRFCASE)hbr)->hwndOwner;
            else
            {
                pobri->hwndOwner = NULL;

                WARNING_OUT((TEXT("GetBriefcaseInfo(): Briefcase %#lx has no associated parent window."),
                            hbr));
            }

            if (IS_FLAG_SET(((PBRFCASE)hbr)->dwFlags, BR_FL_DATABASE_OPENED))
            {
                pobri->hvid = (HVOLUMEID)(((PCBRFCASE)hbr)->bcdb.hpathDBFolder);
                GetPathString(((PCBRFCASE)hbr)->bcdb.hpathDBFolder,
                        pobri->rgchDatabasePath, ARRAYSIZE(pobri->rgchDatabasePath));
                CatPath(pobri->rgchDatabasePath, ((PCBRFCASE)hbr)->bcdb.pszDBName, 
                        ARRAYSIZE(pobri->rgchDatabasePath));
            }
            else
            {
                pobri->hvid = NULL;
                pobri->rgchDatabasePath[0] = TEXT('\0');

                WARNING_OUT((TEXT("GetBriefcaseInfo(): Briefcase %#lx has no associated database."),
                            hbr));
            }

            tr = TR_SUCCESS;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        ASSERT(tr != TR_SUCCESS ||
                IS_VALID_STRUCT_PTR(pobri, COPENBRFCASEINFO));

        DebugExitTWINRESULT(GetBriefcaseInfo, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | ClearBriefcaseCache | Wipes out cached information in an open
  briefcase.

  @parm HBRFCASE | hbr | A handle to the open briefcase whose cached information
  is to be cleared.

  @rdesc If the open briefcase's cached information was cleared successfully,
  TR_SUCCESS is returned.  Otherwise, the briefcase's cached information was not
  cleared successfully, and the return value indicates the error that occurred.

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI ClearBriefcaseCache(HBRFCASE hbr)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(ClearBriefcaseCache);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hbr, BRFCASE))
#endif
        {
            ClearPathListInfo(((PBRFCASE)hbr)->hpathlist);

            tr = TR_SUCCESS;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(ClearBriefcaseCache, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\clsiface.h ===
/*
 * clsiface.h - Class interface cache ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HCLSIFACECACHE);
DECLARE_STANDARD_TYPES(HCLSIFACECACHE);


/* Prototypes
 *************/

/* rhcache.c */

extern BOOL CreateClassInterfaceCache(PHCLSIFACECACHE);
extern void DestroyClassInterfaceCache(HCLSIFACECACHE);
extern HRESULT GetClassInterface(HCLSIFACECACHE, PCCLSID, PCIID, PVOID *);

#ifdef DEBUG

extern BOOL IsValidHCLSIFACECACHE(HCLSIFACECACHE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\brfcase.h ===
/*
 * brfcase.h - Briefcase ADT description.
 */


/* Prototypes
 *************/

/* brfcase.c */

extern BOOL SetBriefcaseModuleIniSwitches(void);
extern BOOL InitBriefcaseModule(void);
extern void ExitBriefcaseModule(void);
extern HSTRINGTABLE GetBriefcaseNameStringTable(HBRFCASE);
extern HPTRARRAY GetBriefcaseTwinFamilyPtrArray(HBRFCASE);
extern HPTRARRAY GetBriefcaseFolderPairPtrArray(HBRFCASE);
extern HPATHLIST GetBriefcasePathList(HBRFCASE);
extern HRESULT GetBriefcaseRootMoniker(HBRFCASE, PIMoniker *);
extern BOOL BeginExclusiveBriefcaseAccess(void);
extern void EndExclusiveBriefcaseAccess(void);

#ifdef DEBUG

extern BOOL BriefcaseAccessIsExclusive(void);

#endif

extern BOOL IsValidHBRFCASE(HBRFCASE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\comc.c ===
/*
 * comc.c - Shared routines.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/****************************** Public Functions *****************************/


/*
 ** CatPath()
 **
 ** Appends a filename to a path string.
 **
 ** Arguments:     pszPath - path string that file name is to be appended to
 **                pcszSubPath - path to append
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 **
 ** N.b., truncates path to MAX_PATH_LEN characters in length.
 **
 ** Examples:
 **
 **    input path        input file name      output path
 **    ----------        ---------------      -----------
 **    c:\               foo                  c:\foo
 **    c:                foo                  c:foo
 **    c:\foo\bar\       goo                  c:\foo\bar\goo
 **    c:\foo\bar\       \goo                 c:\foo\bar\goo
 **    c:\foo\bar\       goo\shoe             c:\foo\bar\goo\shoe
 **    c:\foo\bar\       \goo\shoe\           c:\foo\bar\goo\shoe\
 **    foo\bar\          goo                  foo\bar\goo
 **    <empty string>    <empty string>       <empty string>
 **    <empty string>    foo                  foo
 **    foo               <empty string>       foo
 **    fred              bird                 fred\bird
 */
PUBLIC_CODE void CatPath(LPTSTR pszPath, LPCTSTR pcszSubPath, int cchMax)
{
    LPTSTR pcsz;
    LPTSTR pcszLast;

    ASSERT(IS_VALID_STRING_PTR(pszPath, STR));
    ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPath, STR, cchMax));

    /* Find last character in path string. */

    for (pcsz = pcszLast = pszPath; *pcsz; pcsz = CharNext(pcsz))
        pcszLast = pcsz;

    if (IS_SLASH(*pcszLast) && IS_SLASH(*pcszSubPath))
        pcszSubPath++;
    else if (! IS_SLASH(*pcszLast) && ! IS_SLASH(*pcszSubPath))
    {
        if (*pcszLast && *pcszLast != COLON && *pcszSubPath && ((lstrlen(pszPath) + 1) < cchMax))
            *pcsz++ = TEXT('\\');
    }

    MyLStrCpyN(pcsz, pcszSubPath, cchMax - (int)(pcsz - pszPath));

    ASSERT(IS_VALID_STRING_PTR(pszPath, STR));

    return;
}


/*
 ** MapIntToComparisonResult()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE COMPARISONRESULT MapIntToComparisonResult(int nResult)
{
    COMPARISONRESULT cr;

    /* Any integer is valid input. */

    if (nResult < 0)
        cr = CR_FIRST_SMALLER;
    else if (nResult > 0)
        cr = CR_FIRST_LARGER;
    else
        cr = CR_EQUAL;

    return(cr);
}


/*
 ** MyLStrCpyN()
 **
 ** Like lstrcpyn(), but the copy is limited to ucb bytes.  The destination
 ** string is always null-terminated.
 **
 ** Arguments:     pszDest - pointer to destination buffer
 **                pcszSrc - pointer to source string
 **                ncb - maximum number of bytes to copy, including null
 **                      terminator
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 **
 ** N.b., this function behaves quite differently than strncpy()!  It does not
 ** pad out the destination buffer with null characters, and it always null
 ** terminates the destination string.
 */
PUBLIC_CODE void MyLStrCpyN(LPTSTR pszDest, LPCTSTR pcszSrc, int ncch)
{
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszDest, STR, ncch * sizeof(TCHAR)));
    ASSERT(IS_VALID_STRING_PTR(pcszSrc, CSTR));
    ASSERT(ncch > 0);

    while (ncch > 1)
    {
        ncch--;

        *pszDest = *pcszSrc;

        if (*pcszSrc)
        {
            pszDest++;
            pcszSrc++;
        }
        else
            break;
    }

    if (ncch == 1)
        *pszDest = TEXT('\0');

    ASSERT(IS_VALID_STRING_PTR(pszDest, STR));
    ASSERT(lstrlen(pszDest) < ncch);
    ASSERT(lstrlen(pszDest) <= lstrlen(pcszSrc));

    return;
}


#ifdef DEBUG

/*
 ** IsStringContained()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsStringContained(LPCTSTR pcszBigger, LPCTSTR pcszSuffix)
{
    ASSERT(IS_VALID_STRING_PTR(pcszBigger, CSTR));
    ASSERT(IS_VALID_STRING_PTR(pcszSuffix, CSTR));

    return(pcszSuffix >= pcszBigger &&
            pcszSuffix <= pcszBigger + lstrlen(pcszBigger));
}

#endif


#if defined(_SYNCENG_) || defined(_LINKINFO_)

/*
 ** DeleteLastPathElement()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DeleteLastPathElement(LPTSTR pszPath)
{
    LPTSTR psz;
    LPTSTR pszLastSep;

    ASSERT(IS_VALID_STRING_PTR(pszPath, STR));

    psz = pszPath;
    pszLastSep = psz;

    while (*psz)
    {
        if (*psz == TEXT('\\'))
            pszLastSep = psz;

        psz = CharNext(psz);
    }

    /*
     * Now truncate the path at the last separator found, or the beginning of
     * the path if no path separators were found.
     */

    *pszLastSep = TEXT('\0');

    ASSERT(IS_VALID_STRING_PTR(pszPath, STR));

    return;
}


/*
 ** GetDefaultRegKeyValue()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE LONG GetDefaultRegKeyValue(HKEY hkeyParent, LPCTSTR pcszSubKey,
        LPTSTR pszBuf, PDWORD pdwcbBufLen)
{
    LONG lResult;
    HKEY hkeySubKey;

    ASSERT(IS_VALID_HANDLE(hkeyParent, KEY));
    ASSERT(IS_VALID_STRING_PTR(pcszSubKey, CSTR));
    ASSERT(! pszBuf ||
            IS_VALID_WRITE_BUFFER_PTR(pszBuf, STR, *pdwcbBufLen));

    lResult = RegOpenKeyEx(hkeyParent, pcszSubKey, 0, KEY_QUERY_VALUE,
            &hkeySubKey);

    if (lResult == ERROR_SUCCESS)
    {
        DWORD dwValueType;

        lResult = RegQueryValueEx(hkeySubKey, NULL, NULL, &dwValueType,
                (PBYTE)pszBuf, pdwcbBufLen);

        if (lResult == ERROR_SUCCESS)
        {
            ASSERT(dwValueType == REG_SZ);
            /* (+ 1) for null terminator. */
            ASSERT(! pszBuf ||
                    (DWORD)(lstrlen(pszBuf) + 1) * sizeof(TCHAR) == *pdwcbBufLen);

            TRACE_OUT((TEXT("GetDefaultRegKeyValue(): Default key value for subkey %s is \"%s\"."),
                        pcszSubKey,
                        pszBuf));
        }
        else
            TRACE_OUT((TEXT("GetDefaultRegKeyValue(): RegQueryValueEx() for subkey %s failed, returning %ld."),
                        pcszSubKey,
                        lResult));

        EVAL(RegCloseKey(hkeySubKey) == ERROR_SUCCESS);
    }
    else
        TRACE_OUT((TEXT("GetDefaultRegKeyValue(): RegOpenKeyEx() for subkey %s failed, returning %ld."),
                    pcszSubKey,
                    lResult));

    return(lResult);
}


/*
 ** StringCopy()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL StringCopy(LPCTSTR pcszSrc, LPTSTR *ppszCopy)
{
    BOOL bResult;

    ASSERT(IS_VALID_STRING_PTR(pcszSrc, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(ppszCopy, LPTSTR));

    /* (+ 1) for null terminator. */

    bResult = AllocateMemory((lstrlen(pcszSrc) + 1) * sizeof(TCHAR), ppszCopy);

    if (bResult)
        lstrcpy(*ppszCopy, pcszSrc); // allocated dynamically above

    ASSERT(! bResult ||
            IS_VALID_STRING_PTR(*ppszCopy, STR));

    return(bResult);
}


/*
 ** ComparePathStrings()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE COMPARISONRESULT ComparePathStrings(LPCTSTR pcszFirst, LPCTSTR pcszSecond)
{
    ASSERT(IS_VALID_STRING_PTR(pcszFirst, CSTR));
    ASSERT(IS_VALID_STRING_PTR(pcszSecond, CSTR));

    return(MapIntToComparisonResult(lstrcmpi(pcszFirst, pcszSecond)));
}


/*
 ** MyStrChr()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL MyStrChr(LPCTSTR pcsz, TCHAR chTarget, LPCTSTR *ppcszTarget)
{
    LPCTSTR pcszFound;

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
    ASSERT(! ppcszTarget || IS_VALID_WRITE_PTR(ppcszTarget, LPCTSTR));

    /* This works correctly if chTarget is the null terminator '\0'. */

    while (*pcsz && *pcsz != chTarget)
        pcsz = CharNext(pcsz);

    if (*pcsz == chTarget)
        pcszFound = pcsz;
    else
        pcszFound = NULL;

    if (ppcszTarget)
        *ppcszTarget = pcszFound;

    return(pcszFound != NULL);
}


/*
 ** PathExists()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL PathExists(LPCTSTR pcszPath)
{
    DWORD dwErrMode;
    BOOL fResult;

    ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

    dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    fResult = (GetFileAttributes(pcszPath) != -1);

    SetErrorMode(dwErrMode);

    return fResult;
}


/*
 ** IsDrivePath()
 **
 ** Determines whether or not a path is in "c:\" form.
 **
 ** Arguments:     pcszPath - path to examine
 **
 ** Returns:       TRUE if path is in "c:\" form.  FALSE if not.
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsDrivePath(LPCTSTR pcszFullPath)
{
    BOOL bResult;

    ASSERT(IsFullPath(pcszFullPath));

    if (lstrlen(pcszFullPath) >= 3 &&
            IsCharAlpha(pcszFullPath[0]) &&
            pcszFullPath[1] == COLON &&
            IS_SLASH(pcszFullPath[2]))
        bResult = TRUE;
    else
        bResult = FALSE;

    return(bResult);
}


#if defined(DEBUG) || defined(VSTF)

/*
 ** IsValidDriveType()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidDriveType(UINT uDriveType)
{
    BOOL bResult;

    switch (uDriveType)
    {
        case DRIVE_UNKNOWN:
        case DRIVE_NO_ROOT_DIR:
        case DRIVE_REMOVABLE:
        case DRIVE_FIXED:
        case DRIVE_REMOTE:
        case DRIVE_CDROM:
        case DRIVE_RAMDISK:
            bResult = TRUE;
            break;

        default:
            ERROR_OUT((TEXT("IsValidDriveType(): Invalid drive type %u."),
                        uDriveType));
            bResult = FALSE;
            break;
    }

    return(bResult);
}


/*
 ** IsValidPathSuffix()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** A path suffix should not begin or end with a slash.
 */
PUBLIC_CODE BOOL IsValidPathSuffix(LPCTSTR pcszPathSuffix)
{
    return(IS_VALID_STRING_PTR(pcszPathSuffix, CSTR) &&
            EVAL(lstrlen(pcszPathSuffix) < MAX_PATH_LEN) &&
            EVAL(! IS_SLASH(*pcszPathSuffix)) &&
            EVAL(! IS_SLASH(*CharPrev(pcszPathSuffix, pcszPathSuffix + lstrlen(pcszPathSuffix)))));
}

#endif   /* DEBUG || VSTF */


#ifdef DEBUG

/*
 ** IsRootPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsRootPath(LPCTSTR pcszFullPath)
{
    TCHAR rgchCanonicalPath[MAX_PATH_LEN];
    DWORD dwOutFlags;
    TCHAR rgchNetResource[MAX_PATH_LEN];
    LPTSTR pszRootPathSuffix;

    ASSERT(IsFullPath(pcszFullPath));

    return(GetCanonicalPathInfo(pcszFullPath, rgchCanonicalPath, &dwOutFlags,
                rgchNetResource, &pszRootPathSuffix) &&
            ! *pszRootPathSuffix);
}


/*
 ** IsTrailingSlashCanonicalized()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsTrailingSlashCanonicalized(LPCTSTR pcszFullPath)
{
    BOOL bResult;
    BOOL bSlashLast;
    LPCTSTR pcszLastPathChar;

    ASSERT(IsFullPath(pcszFullPath));

    /* Make sure that the path only ends in a slash for root paths. */

    pcszLastPathChar = CharPrev(pcszFullPath, pcszFullPath + lstrlen(pcszFullPath));

    ASSERT(pcszLastPathChar >= pcszFullPath);

    bSlashLast = IS_SLASH(*pcszLastPathChar);

    /* Is this a root path? */

    if (IsRootPath(pcszFullPath))
        bResult = bSlashLast;
    else
        bResult = ! bSlashLast;

    return(bResult);
}


/*
 ** IsFullPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsFullPath(LPCTSTR pcszPath)
{
    BOOL bResult = FALSE;
    TCHAR rgchFullPath[MAX_PATH_LEN];

    if (IS_VALID_STRING_PTR(pcszPath, CSTR) &&
            EVAL(lstrlen(pcszPath) < MAX_PATH_LEN))
    {
        DWORD dwPathLen;
        LPTSTR pszFileName;

        dwPathLen = GetFullPathName(pcszPath, ARRAYSIZE(rgchFullPath), rgchFullPath,
                &pszFileName);

        if (EVAL(dwPathLen > 0) &&
                EVAL(dwPathLen < ARRAYSIZE(rgchFullPath)))
            bResult = EVAL(ComparePathStrings(pcszPath, rgchFullPath) == CR_EQUAL);
    }

    return(bResult);
}


/*
 ** IsCanonicalPath()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsCanonicalPath(LPCTSTR pcszPath)
{
    return(EVAL(IsFullPath(pcszPath)) &&
            EVAL(IsTrailingSlashCanonicalized(pcszPath)));

}


/*
 ** IsValidCOMPARISONRESULT()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT cr)
{
    BOOL bResult;

    switch (cr)
    {
        case CR_FIRST_SMALLER:
        case CR_EQUAL:
        case CR_FIRST_LARGER:
            bResult = TRUE;
            break;

        default:
            WARNING_OUT((TEXT("IsValidCOMPARISONRESULT(): Unknown COMPARISONRESULT %d."),
                        cr));
            bResult = FALSE;
            break;
    }

    return(bResult);
}

#endif   /* DEBUG */

#endif   /* _SYNCENG_ || _LINKINFO_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\copy.h ===
/*
 * copy.h - File copy handler module description.
 */


/* Prototypes
 *************/

/* copy.c */

extern void BeginCopy(void);
extern void EndCopy(void);
extern TWINRESULT CopyHandler(PRECNODE, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
extern BOOL NotifyReconciliationStatus(RECSTATUSPROC, UINT, LPARAM, LPARAM);
extern TWINRESULT CreateFolders(LPCTSTR, HPATH);
extern TWINRESULT DestroySubtree(LPCTSTR, HPATH);

#ifdef DEBUG

extern BOOL IsValidRecStatusProcMsg(UINT);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\comc.h ===
/*
 * comc.h - Shared routines description.
 */


/* Prototypes
 *************/

/* comc.c */

extern void CatPath(LPTSTR, LPCTSTR, int);
extern COMPARISONRESULT MapIntToComparisonResult(int);
extern void MyLStrCpyN(LPTSTR, LPCTSTR, int);

#ifdef DEBUG

extern BOOL IsStringContained(LPCTSTR, LPCTSTR);

#endif   /* DEBUG */

#if defined(_SYNCENG_) || defined(_LINKINFO_)

extern void DeleteLastPathElement(LPTSTR);
extern LONG GetDefaultRegKeyValue(HKEY, LPCTSTR, LPTSTR, PDWORD);
extern BOOL StringCopy(LPCTSTR, LPTSTR *);
extern void CopyRootPath(LPCTSTR, LPTSTR);
extern COMPARISONRESULT ComparePathStrings(LPCTSTR, LPCTSTR);
extern BOOL MyStrChr(LPCTSTR, TCHAR, LPCTSTR *);
extern BOOL PathExists(LPCTSTR);
extern BOOL IsDrivePath(LPCTSTR);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidDriveType(UINT);
extern BOOL IsValidPathSuffix(LPCTSTR);

#endif   /* DEBUG || VSTF */

#ifdef DEBUG

extern BOOL IsRootPath(LPCTSTR);
extern BOOL IsTrailingSlashCanonicalized(LPCTSTR);
extern BOOL IsFullPath(LPCTSTR);
extern BOOL IsCanonicalPath(LPCTSTR);
extern BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT);

#endif   /* DEBUG */

#endif   /* _SYNCENG_ || _LINKINFO_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\cstring.h ===
/*
 * string.h - String table ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HSTRING);
DECLARE_STANDARD_TYPES(HSTRING);
DECLARE_HANDLE(HSTRINGTABLE);
DECLARE_STANDARD_TYPES(HSTRINGTABLE);

/* count of hash buckets in a string table */

typedef UINT HASHBUCKETCOUNT;
DECLARE_STANDARD_TYPES(HASHBUCKETCOUNT);

/* string table hash function */

typedef HASHBUCKETCOUNT (*STRINGTABLEHASHFUNC)(LPCTSTR, HASHBUCKETCOUNT);

/* new string table */

typedef struct _newstringtable
{
   HASHBUCKETCOUNT hbc;
   STRINGTABLEHASHFUNC HashFunc;
}
NEWSTRINGTABLE;
DECLARE_STANDARD_TYPES(NEWSTRINGTABLE);


/* Prototypes
 *************/

/* string.c */

extern BOOL CreateStringTable(PCNEWSTRINGTABLE, PHSTRINGTABLE);
extern void DestroyStringTable(HSTRINGTABLE);
extern BOOL AddString(LPCTSTR, HSTRINGTABLE, PHSTRING);
extern void DeleteString(HSTRING);
extern void LockString(HSTRING);
extern COMPARISONRESULT CompareStringsI(HSTRING, HSTRING);
extern LPCTSTR GetString(HSTRING);

#if defined(DEBUG) || defined (VSTF)

extern BOOL IsValidHSTRING(HSTRING);
extern BOOL IsValidHSTRINGTABLE(HSTRINGTABLE);

#endif

#ifdef DEBUG

extern ULONG GetStringCount(HSTRINGTABLE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\clsiface.c ===
/*
 * clsiface.c - Class interface cache ADT module.
 */


/*



 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "oleutil.h"


/* Constants
 ************/

/* class interface cache pointer array allocation parameters */

#define NUM_START_CLS_IFACES           (0)
#define NUM_CLS_IFACES_TO_ADD          (16)


/* Types
 ********/

/* class interface cache */

typedef struct _clsifacecache
{
    HPTRARRAY hpa;
}
CLSIFACECACHE;
DECLARE_STANDARD_TYPES(CLSIFACECACHE);

/* class interface */

typedef struct _clsiface
{
    /* class ID */

    PCCLSID pcclsid;

    /* interface ID */

    PCIID pciid;

    /* interface */

    PVOID pvInterface;
}
CLSIFACE;
DECLARE_STANDARD_TYPES(CLSIFACE);

/* class interface search structure for ClassInterfaceSearchCmp() */

typedef struct _clsifacesearchinfo
{
    /* class ID */

    PCCLSID pcclsid;

    /* interface ID */

    PCIID pciid;
}
CLSIFACESEARCHINFO;
DECLARE_STANDARD_TYPES(CLSIFACESEARCHINFO);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL CreateClassInterfacePtrArray(PHPTRARRAY);
PRIVATE_CODE void DestroyClassInterfacePtrArray(HPTRARRAY);
PRIVATE_CODE HRESULT CreateClassInterface(PCCLSIFACECACHE, PCCLSID, PCIID, PCLSIFACE *);
PRIVATE_CODE void DestroyClassInterface(PCLSIFACE);
PRIVATE_CODE COMPARISONRESULT ClassInterfaceSortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT ClassInterfaceSearchCmp(PCVOID, PCVOID);

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCCLSIFACECACHE(PCCLSIFACECACHE);
PRIVATE_CODE BOOL IsValidPCCLSIFACE(PCCLSIFACE);
PRIVATE_CODE BOOL IsValidPCCLSIFACESEARCHINFO(PCCLSIFACESEARCHINFO);

#endif


/*
 ** CreateClassInterfacePtrArray()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CreateClassInterfacePtrArray(PHPTRARRAY phpa)
{
    NEWPTRARRAY npa;

    ASSERT(IS_VALID_WRITE_PTR(phpa, HPTRARRAY));

    npa.aicInitialPtrs = NUM_START_CLS_IFACES;
    npa.aicAllocGranularity = NUM_CLS_IFACES_TO_ADD;
    npa.dwFlags = NPA_FL_SORTED_ADD;

    return(CreatePtrArray(&npa, phpa));
}


/*
 ** DestroyClassInterfacePtrArray()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyClassInterfacePtrArray(HPTRARRAY hpa)
{
    ARRAYINDEX aicPtrs;
    ARRAYINDEX ai;

    ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

    /* First free all class interfaces in array. */

    aicPtrs = GetPtrCount(hpa);

    for (ai = 0; ai < aicPtrs; ai++)
        DestroyClassInterface(GetPtr(hpa, ai));

    /* Now wipe out the array. */

    DestroyPtrArray(hpa);

    return;
}


/*
 ** CreateClassInterface()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE HRESULT CreateClassInterface(PCCLSIFACECACHE pccic,
        PCCLSID pcclsid, PCIID pciid,
        PCLSIFACE *ppci)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(pccic, CCLSIFACECACHE));
    ASSERT(IS_VALID_STRUCT_PTR(pcclsid, CCLSID));
    ASSERT(IS_VALID_STRUCT_PTR(pciid, CIID));
    ASSERT(IS_VALID_WRITE_PTR(ppci, PCLSIFACE));

    if (AllocateMemory(sizeof(**ppci), ppci))
    {
        /* Use inproc servers and local servers. */

        // Security: Per the comment above removing CLSCTS_SERVER and
        // replacing with just inproc and local (no remote).
        hr = CoCreateInstance(pcclsid, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, 
                pciid, &((*ppci)->pvInterface));

        if (SUCCEEDED(hr))
        {
            ARRAYINDEX ai;

            (*ppci)->pcclsid = pcclsid;
            (*ppci)->pciid = pciid;

            if (! AddPtr(pccic->hpa, ClassInterfaceSortCmp, *ppci, &ai))
            {
                hr = E_OUTOFMEMORY;
CREATECLASSINTERFACE_BAIL:
                FreeMemory(*ppci);
            }
        }
        else
        {
            WARNING_OUT((TEXT("CreateClassInterface(): CoCreateInstance() failed, returning %s."),
                        GetHRESULTString(hr)));

            goto CREATECLASSINTERFACE_BAIL;
        }
    }
    else
        hr = E_OUTOFMEMORY;

    ASSERT(FAILED(hr) ||
            IS_VALID_STRUCT_PTR(*ppci, CCLSIFACE));

    return(hr);
}


/*
 ** DestroyClassInterface()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyClassInterface(PCLSIFACE pci)
{
    ASSERT(IS_VALID_STRUCT_PTR(pci, CCLSIFACE));

    ((PCIUnknown)(pci->pvInterface))->lpVtbl->Release(pci->pvInterface);
    FreeMemory(pci);

    return;
}


/*
 ** ClassInterfaceSortCmp()
 **
 ** Pointer comparison function used to sort an array of pointers to class
 ** interfaces.
 **
 ** Arguments:     pcci1 - pointer to first class interface
 **                pcci2 - pointer to second class interface
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** The class interfaces are sorted by:
 **    1) CLSID
 **    2) IID
 */
PRIVATE_CODE COMPARISONRESULT ClassInterfaceSortCmp(PCVOID pcci1, PCVOID pcci2)
{
    COMPARISONRESULT cr;

    ASSERT(IS_VALID_STRUCT_PTR(pcci1, CCLSIFACE));
    ASSERT(IS_VALID_STRUCT_PTR(pcci2, CCLSIFACE));

    cr = CompareClassIDs(((PCCLSIFACE)pcci1)->pcclsid,
            ((PCCLSIFACE)pcci2)->pcclsid);

    if (cr == CR_EQUAL)
        cr = CompareInterfaceIDs(((PCCLSIFACE)pcci1)->pciid,
                ((PCCLSIFACE)pcci2)->pciid);

    return(cr);
}


/*
 ** ClassInterfaceSearchCmp()
 **
 ** Pointer comparison function used to search an array of pointers to class
 ** interfaces.
 **
 ** Arguments:     pccisi - pointer to class interface search information
 **                pcci - pointer to class interface to examine
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE COMPARISONRESULT ClassInterfaceSearchCmp(PCVOID pccisi,
        PCVOID pcci)
{
    COMPARISONRESULT cr;

    ASSERT(IS_VALID_STRUCT_PTR(pccisi, CCLSIFACESEARCHINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pcci, CCLSIFACE));

    cr = CompareClassIDs(((PCCLSIFACESEARCHINFO)pccisi)->pcclsid,
            ((PCCLSIFACE)pcci)->pcclsid);

    if (cr == CR_EQUAL)
        cr = CompareInterfaceIDs(((PCCLSIFACESEARCHINFO)pccisi)->pciid,
                ((PCCLSIFACE)pcci)->pciid);

    return(cr);
}


#ifdef DEBUG

/*
 ** IsValidPCCLSIFACECACHE()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCCLSIFACECACHE(PCCLSIFACECACHE pccic)
{
    return(IS_VALID_READ_PTR(pccic, CLSIFACECACHE) &&
            IS_VALID_HANDLE(pccic->hpa, PTRARRAY));
}


/*
 ** IsValidPCCLSIFACE()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCCLSIFACE(PCCLSIFACE pcci)
{
    return(IS_VALID_READ_PTR(pcci, CCLSIFACE) &&
            IS_VALID_STRUCT_PTR(pcci->pcclsid, CCLSID) &&
            IS_VALID_STRUCT_PTR(pcci->pciid, CIID) &&
            IS_VALID_STRUCT_PTR(pcci->pvInterface, CInterface));
}


/*
 ** IsValidPCCLSIFACESEARCHINFO()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCCLSIFACESEARCHINFO(PCCLSIFACESEARCHINFO pccisi)
{
    return(IS_VALID_READ_PTR(pccisi, CCLSIFACESEARCHINFO) &&
            IS_VALID_STRUCT_PTR(pccisi->pcclsid, CCLSID) &&
            IS_VALID_STRUCT_PTR(pccisi->pciid, CIID));
}

#endif


/****************************** Public Functions *****************************/


/*
 ** CreateClassInterfaceCache()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL CreateClassInterfaceCache(PHCLSIFACECACHE phcic)
{
    BOOL bResult = FALSE;
    PCLSIFACECACHE pcic;

    ASSERT(IS_VALID_WRITE_PTR(phcic, HCLSIFACECACHE));

    if (AllocateMemory(sizeof(*pcic), &pcic))
    {
        if (CreateClassInterfacePtrArray(&(pcic->hpa)))
        {
            *phcic = (HCLSIFACECACHE)pcic;
            bResult = TRUE;
        }
        else
            FreeMemory(pcic);
    }

    ASSERT(! bResult ||
            IS_VALID_HANDLE(*phcic, CLSIFACECACHE));

    return(bResult);
}


/*
 ** DestroyClassInterfaceCache()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void DestroyClassInterfaceCache(HCLSIFACECACHE hcic)
{
    ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));

    DestroyClassInterfacePtrArray(((PCLSIFACECACHE)hcic)->hpa);
    FreeMemory(hcic);

    return;
}


/*
 ** GetClassInterface()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** N.b., this function assumes that pcclsid and pciid are valid until hcic is
 ** destroyed with DestroyClassInterfaceCache().
 */
PUBLIC_CODE HRESULT GetClassInterface(HCLSIFACECACHE hcic, PCCLSID pcclsid,
        PCIID pciid, PVOID *ppvInterface)
{
    HRESULT hr;
    CLSIFACESEARCHINFO cisi;
    ARRAYINDEX ai;
    PCLSIFACE pci;

    ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));

    /* Is this class interface already in the cache? */

    cisi.pcclsid = pcclsid;
    cisi.pciid = pciid;

    if (SearchSortedArray(((PCCLSIFACECACHE)hcic)->hpa,
                &ClassInterfaceSearchCmp, &cisi, &ai))
    {
        /* Yes.  Use it. */

        pci = GetPtr(((PCCLSIFACECACHE)hcic)->hpa, ai);

        hr = S_OK;
    }
    else
        /* No.  Add it. */
        hr = CreateClassInterface((PCCLSIFACECACHE)hcic, pcclsid, pciid, &pci);

    if (SUCCEEDED(hr))
    {
        ASSERT(IS_VALID_STRUCT_PTR(pci, CCLSIFACE));

        *ppvInterface = pci->pvInterface;
    }

    ASSERT(FAILED(hr) ||
            IS_VALID_STRUCT_PTR(*ppvInterface, CInterface));

    return(hr);
}


#ifdef DEBUG

/*
 ** IsValidHCLSIFACECACHE()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidHCLSIFACECACHE(HCLSIFACECACHE hcic)
{
    return(IS_VALID_STRUCT_PTR((PCCLSIFACECACHE)hcic, CCLSIFACECACHE));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\copy.c ===
/*
 * copy.c - File copy handler module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "oleutil.h"


/* Constants
 ************/

/* size of file copy buffer in bytes */

#define COPY_BUF_SIZE               (64 * 1024)


/* Module Variables
 *******************/

/* lock count for file copy buffer */

PRIVATE_DATA ULONG MulcCopyBufLock = 0;

/* buffer for file copying */

PRIVATE_DATA PBYTE MpbyteCopyBuf = NULL;

/* length of file copy buffer in bytes */

PRIVATE_DATA UINT MucbCopyBufLen = 0;


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT SimpleCopy(PRECNODE, RECSTATUSPROC, LPARAM);
PRIVATE_CODE TWINRESULT CreateDestinationFolders(PCRECNODE);
PRIVATE_CODE TWINRESULT CreateCopyBuffer(void);
PRIVATE_CODE void DestroyCopyBuffer(void);
PRIVATE_CODE TWINRESULT CopyFileByHandle(HANDLE, HANDLE, RECSTATUSPROC, LPARAM, ULONG, PULONG);
PRIVATE_CODE TWINRESULT CopyFileByName(PCRECNODE, PRECNODE, RECSTATUSPROC, LPARAM, ULONG, PULONG);
PRIVATE_CODE ULONG DetermineCopyScale(PCRECNODE);
PRIVATE_CODE BOOL IsCopyDestination(PCRECNODE);
PRIVATE_CODE BOOL SetDestinationTimeStamps(PCRECNODE);
PRIVATE_CODE BOOL DeleteFolderProc(LPCTSTR, PCWIN32_FIND_DATA, PVOID);

#ifdef DEBUG

PRIVATE_CODE BOOL CopyBufferIsOk(void);
PRIVATE_CODE BOOL VerifyRECITEMAndSrcRECNODE(PCRECNODE);

#endif


/*
 ** SimpleCopy()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT SimpleCopy(PRECNODE prnSrc, RECSTATUSPROC rsp,
        LPARAM lpCallbackData)
{
    TWINRESULT tr;
    ULONG ulScale;
    PRECNODE prnDest;
    ULONG ulCurrent = 0;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(prnSrc, CRECNODE));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));

    ulScale = DetermineCopyScale(prnSrc);

    /* Copy the source file to each destination file. */

    tr = TR_SUCCESS;

    BeginCopy();

    for (prnDest = prnSrc->priParent->prnFirst;
            prnDest;
            prnDest = prnDest->prnNext)
    {
        if (prnDest != prnSrc)
        {
            if (IsCopyDestination(prnDest))
            {
                tr = CopyFileByName(prnSrc, prnDest, rsp, lpCallbackData,
                        ulScale, &ulCurrent);

                if (tr != TR_SUCCESS)
                    break;

                ASSERT(ulCurrent <= ulScale);
            }
        }
    }

    EndCopy();

    return(tr);
}


/*
 ** CreateDestinationFolders()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT CreateDestinationFolders(PCRECNODE pcrnSrc)
{
    TWINRESULT tr = TR_SUCCESS;
    PCRECNODE pcrnDest;

    for (pcrnDest = pcrnSrc->priParent->prnFirst;
            pcrnDest;
            pcrnDest = pcrnDest->prnNext)
    {
        if (pcrnDest->rnaction == RNA_COPY_TO_ME)
        {
            tr = CreateFolders(pcrnDest->pcszFolder,
                    ((PCOBJECTTWIN)(pcrnDest->hObjectTwin))->hpath);

            if (tr != TR_SUCCESS)
                break;
        }
    }

    return(tr);
}


/*
 ** CreateCopyBuffer()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT CreateCopyBuffer(void)
{
    TWINRESULT tr;

    ASSERT(CopyBufferIsOk());

    /* Has the copy buffer already been allocated? */

    if (MpbyteCopyBuf)
        /* Yes. */
        tr = TR_SUCCESS;
    else
    {
        /* No.  Allocate it. */

        if (AllocateMemory(COPY_BUF_SIZE, &MpbyteCopyBuf))
        {
            MucbCopyBufLen = COPY_BUF_SIZE;
            tr = TR_SUCCESS;

            TRACE_OUT((TEXT("CreateCopyBuffer(): %u byte file copy buffer allocated."),
                        MucbCopyBufLen));
        }
        else
            tr = TR_OUT_OF_MEMORY;
    }

    ASSERT(CopyBufferIsOk());

    return(tr);
}


/*
 ** DestroyCopyBuffer()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyCopyBuffer(void)
{
    ASSERT(CopyBufferIsOk());

    /* Has the copy buffer already been allocated? */

    if (MpbyteCopyBuf)
    {
        /* Yes.  Free it. */

        FreeMemory(MpbyteCopyBuf);
        MpbyteCopyBuf = NULL;
        TRACE_OUT((TEXT("DestroyCopyBuffer(): %u byte file copy buffer freed."),
                    MucbCopyBufLen));
        MucbCopyBufLen = 0;
    }

    ASSERT(CopyBufferIsOk());

    return;
}


/*
 ** CopyFileByHandle()
 **
 ** Copies one file to another.
 **
 ** Arguments:     hfSrc - file handle to open source file
 **                hfDest - file handle to open destination file
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  Leaves the file pointer of each file at the end of the file.
 */
PRIVATE_CODE TWINRESULT CopyFileByHandle(HANDLE hfSrc, HANDLE hfDest,
        RECSTATUSPROC rsp, LPARAM lpCallbackData,
        ULONG ulScale, PULONG pulcbTotal)
{
    TWINRESULT tr;

    /* lpCallbackData may be any value. */
    /* ulScale may be any value. */

    ASSERT(IS_VALID_HANDLE(hfSrc, FILE));
    ASSERT(IS_VALID_HANDLE(hfDest, FILE));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSROC));
    ASSERT(IS_VALID_WRITE_PTR(pulcbTotal, ULONG));

    /* Make sure the copy buffer has been created. */

    tr = CreateCopyBuffer();

    if (tr == TR_SUCCESS)
    {
        BeginCopy();

        /* Move to the beginning of the files. */

        if (SetFilePointer(hfSrc, 0, NULL, FILE_BEGIN) != INVALID_SEEK_POSITION)
        {
            if (SetFilePointer(hfDest, 0, NULL, FILE_BEGIN) != INVALID_SEEK_POSITION)
            {
                do
                {
                    DWORD dwcbRead;

                    if (ReadFile(hfSrc, MpbyteCopyBuf, MucbCopyBufLen, &dwcbRead,
                                NULL))
                    {
                        if (dwcbRead)
                        {
                            DWORD dwcbWritten;

                            if (WriteFile(hfDest, MpbyteCopyBuf, dwcbRead,
                                        &dwcbWritten, NULL) &&
                                    dwcbWritten == dwcbRead)
                            {
                                RECSTATUSUPDATE rsu;

                                ASSERT(*pulcbTotal <= ULONG_MAX - dwcbRead);

                                *pulcbTotal += dwcbRead;

                                rsu.ulProgress = *pulcbTotal;
                                rsu.ulScale = ulScale;

                                if (! NotifyReconciliationStatus(rsp, RS_DELTA_COPY,
                                            (LPARAM)&rsu,
                                            lpCallbackData))
                                    tr = TR_ABORT;
                            }
                            else
                                tr = TR_DEST_WRITE_FAILED;
                        }
                        else
                            /* Hit EOF.  Stop. */
                            break;
                    }
                    else
                        tr = TR_SRC_READ_FAILED;
                } while (tr == TR_SUCCESS);
            }
            else
                tr = TR_DEST_WRITE_FAILED;
        }
        else
            tr = TR_SRC_READ_FAILED;

        EndCopy();
    }

    return(tr);
}

// MakeAnsiPath
//
// Copys path pszIn to pszOut, ensuring that pszOut has a valid ANSI mapping

void MakeAnsiPath(LPTSTR pszIn, LPTSTR pszOut, int cchMax)
{
#ifdef UNICODE
    CHAR szAnsi[MAX_PATH];
    pszOut[0] = L'\0';

    WideCharToMultiByte(CP_ACP, 0, pszIn, -1, szAnsi, ARRAYSIZE(szAnsi), NULL, NULL);
    MultiByteToWideChar(CP_ACP, 0, szAnsi,   -1, pszOut, cchMax);
    if (lstrcmp(pszOut, pszIn))
    {
        // Cannot convert losslessly from Unicode -> Ansi, so get the short path

        lstrcpyn(pszOut, pszIn, cchMax);
        SheShortenPath(pszOut, TRUE);
    }
#else
    lstrcpyn(pszOut, pszIn, cchMax);
#endif
}

/*
 ** CopyFileByName()
 **
 ** Copies one file over another.
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  Copies source file's time stamp to destination file.
 */
PRIVATE_CODE TWINRESULT CopyFileByName(PCRECNODE pcrnSrc, PRECNODE prnDest,
        RECSTATUSPROC rsp, LPARAM lpCallbackData,
        ULONG ulScale, PULONG pulcbTotal)
{
    TWINRESULT tr;
    TCHAR rgchSrcPath[MAX_PATH_LEN];
    TCHAR rgchDestPath[MAX_PATH_LEN];

    /* lpCallbackData may be any value. */
    /* ulScale may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pcrnSrc, CRECNODE));
    ASSERT(IS_VALID_STRUCT_PTR(prnDest, CRECNODE));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSROC));
    ASSERT(IS_VALID_WRITE_PTR(pulcbTotal, ULONG));

    /* Create source path string. */

    ComposePath(rgchSrcPath, pcrnSrc->pcszFolder, pcrnSrc->priParent->pcszName, ARRAYSIZE(rgchSrcPath));
    ASSERT(lstrlen(rgchSrcPath) < ARRAYSIZE(rgchSrcPath));

    /* Create destination path string. */

    ComposePath(rgchDestPath, prnDest->pcszFolder, prnDest->priParent->pcszName, ARRAYSIZE(rgchDestPath));
    ASSERT(lstrlen(rgchDestPath) < ARRAYSIZE(rgchDestPath));

    /* Check volumes. */

    if (MyIsPathOnVolume(rgchSrcPath, (HPATH)(pcrnSrc->hvid)) &&
            MyIsPathOnVolume(rgchDestPath, (HPATH)(prnDest->hvid)))
    {
        FILESTAMP fsSrc;
        FILESTAMP fsDest;

        /* Compare current file stamps with recorded file stamps. */

        MyGetFileStamp(rgchSrcPath, &fsSrc);
        MyGetFileStamp(rgchDestPath, &fsDest);

        if (! MyCompareFileStamps(&(pcrnSrc->fsCurrent), &fsSrc) &&
                ! MyCompareFileStamps(&(prnDest->fsCurrent), &fsDest))
        {
            HANDLE hfSrc;

            /* Open source file.  Assume source file will be read sequentially. */

            hfSrc = CreateFile(rgchSrcPath, GENERIC_READ, FILE_SHARE_READ, NULL,
                    OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

            if (hfSrc != INVALID_HANDLE_VALUE)
            {
                HANDLE hfDest;

                /*
                 * Create destination file.  Assume destination file will be
                 * written sequentially.
                 */

                TCHAR szAnsiPath[MAX_PATH];
                MakeAnsiPath(rgchDestPath, szAnsiPath, ARRAYSIZE(szAnsiPath));

                hfDest = CreateFile(szAnsiPath, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS,
                        (FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN),
                        NULL);

                if (hfDest != INVALID_HANDLE_VALUE)
                {
                    /* Everything is cool.  Copy the file. */

                    tr = CopyFileByHandle(hfSrc, hfDest, rsp,
                            lpCallbackData, ulScale,
                            pulcbTotal);

                    if (tr == TR_SUCCESS)
                    {
                        /*
                         * Set the destination file's time stamp to the source
                         * file's time stamp to assist clients that don't maintain
                         * a persistent briefcase database, like MPR.  Failure to
                         * set the time stamp is not fatal.
                         */

                        if (! SetFileTime(hfDest, NULL, NULL,
                                    &(pcrnSrc->fsCurrent.ftMod)))
                            WARNING_OUT((TEXT("CopyFileByName(): Failed to set last modification time stamp of destination file %s to match source file %s."),
                                        rgchDestPath,
                                        rgchSrcPath));
                    }

                    /* Failing to close the destination file is fatal here. */

                    if (! CloseHandle(hfDest) && tr == TR_SUCCESS)
                        tr = TR_DEST_WRITE_FAILED;
                }
                else
                    tr = TR_DEST_OPEN_FAILED;

                /* Failing to close the source file successfully is not fatal. */

                CloseHandle(hfSrc);
            }
            else
                tr = TR_SRC_OPEN_FAILED;
        }
        else
            tr = TR_FILE_CHANGED;
    }
    else
        tr = TR_UNAVAILABLE_VOLUME;

#ifdef DEBUG

    if (tr == TR_SUCCESS)
        TRACE_OUT((TEXT("CopyFileByName(): %s\\%s copied to %s\\%s."),
                    pcrnSrc->pcszFolder,
                    pcrnSrc->priParent->pcszName,
                    prnDest->pcszFolder,
                    prnDest->priParent->pcszName));

    else
        TRACE_OUT((TEXT("CopyFileByName(): Failed to copy %s\\%s to %s\\%s."),
                    pcrnSrc->pcszFolder,
                    pcrnSrc->priParent->pcszName,
                    prnDest->pcszFolder,
                    prnDest->priParent->pcszName));

#endif

    return(tr);
}


/*
 ** DetermineCopyScale()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE ULONG DetermineCopyScale(PCRECNODE pcrnSrc)
{
    DWORD dwcbSrcFileLen;
    PCRECNODE pcrn;
    ULONG ulScale = 0;

    ASSERT(IS_VALID_STRUCT_PTR(pcrnSrc, CRECNODE));

    /*
     * RAIDRAID: (16257) If anyone tries to copy more than 4 Gb of files, this
     * scaling calculation is broken.
     */

    ASSERT(! pcrnSrc->fsCurrent.dwcbHighLength);
    dwcbSrcFileLen = pcrnSrc->fsCurrent.dwcbLowLength;

    for (pcrn = pcrnSrc->priParent->prnFirst; pcrn; pcrn = pcrn->prnNext)
    {
        if (pcrn != pcrnSrc)
        {
            if (IsCopyDestination(pcrn))
            {
                ASSERT(ulScale < ULONG_MAX - dwcbSrcFileLen);
                ulScale += dwcbSrcFileLen;
            }
        }
    }

    TRACE_OUT((TEXT("DetermineCopyScale(): Scale for %s is %lu."),
                pcrnSrc->priParent->pcszName,
                ulScale));

    return(ulScale);
}


/*
 ** IsCopyDestination()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsCopyDestination(PCRECNODE pcrn)
{
    BOOL bDest = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(pcrn, CRECNODE));

    switch (pcrn->priParent->riaction)
    {
        case RIA_COPY:
            switch (pcrn->rnaction)
            {
                case RNA_COPY_TO_ME:
                    bDest = TRUE;
                    break;

                default:
                    break;
            }
            break;

        case RIA_MERGE:
            switch (pcrn->rnaction)
            {
                case RNA_COPY_TO_ME:
                case RNA_MERGE_ME:
                    bDest = TRUE;
                    break;

                default:
                    break;
            }
            break;

        default:
            ERROR_OUT((TEXT("IsCopyDestination(): Bad RECITEM action %d."),
                        pcrn->priParent->riaction));
            break;
    }

    return(bDest);
}


/*
 ** SetDestinationTimeStamps()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL SetDestinationTimeStamps(PCRECNODE pcrnSrc)
{
    BOOL bResult = TRUE;
    PCRECNODE pcrn;

    ASSERT(IS_VALID_STRUCT_PTR(pcrnSrc, CRECNODE));

    for (pcrn = pcrnSrc->priParent->prnFirst;
            pcrn;
            pcrn = pcrn->prnNext)
    {
        if (pcrn->rnaction == RNA_COPY_TO_ME)
        {
            TCHAR rgchPath[MAX_PATH_LEN];
            HANDLE hfDest;

            ComposePath(rgchPath, pcrn->pcszFolder, pcrn->priParent->pcszName, ARRAYSIZE(rgchPath));
            ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

            hfDest = CreateFile(rgchPath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, NULL);

            if (hfDest != INVALID_HANDLE_VALUE)
            {
                if (! SetFileTime(hfDest, NULL, NULL, &(pcrnSrc->fsCurrent.ftMod)))
                    bResult = FALSE;

                if (! CloseHandle(hfDest))
                    bResult = FALSE;
            }
            else
                bResult = FALSE;

            if (bResult)
                TRACE_OUT((TEXT("SetDestinationTimeStamps(): Set last modification time stamp of %s to match last modification time stamp of %s\\%s."),
                            rgchPath,
                            pcrnSrc->pcszFolder,
                            pcrnSrc->priParent->pcszName));
            else
                WARNING_OUT((TEXT("SetDestinationTimeStamps(): Failed to set last modification time stamp of %s to match last modification time stamp of %s\\%s."),
                            rgchPath,
                            pcrnSrc->pcszFolder,
                            pcrnSrc->priParent->pcszName));
        }
    }

    return(bResult);
}


/*
 ** DeleteFolderProc()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL DeleteFolderProc(LPCTSTR pcszFolder, PCWIN32_FIND_DATA pcwfd,
        PVOID ptr)
{
    ASSERT(IsCanonicalPath(pcszFolder));
    ASSERT(IS_VALID_READ_PTR(pcwfd, CWIN32_FIND_DATA));
    ASSERT(IS_VALID_WRITE_PTR(ptr, TWINRESULT));

    if (IS_ATTR_DIR(pcwfd->dwFileAttributes))
    {
        TCHAR rgchPath[MAX_PATH_LEN];

        ComposePath(rgchPath, pcszFolder, pcwfd->cFileName, ARRAYSIZE(rgchPath));
        ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

        if (RemoveDirectory(rgchPath))
        {
            WARNING_OUT((TEXT("DeleteFolderProc(): Removed folder %s."),
                        rgchPath));

            NotifyShell(rgchPath, NSE_DELETE_FOLDER);
        }
        else
        {
            WARNING_OUT((TEXT("DeleteFolderProc(): Failed to remove folder %s."),
                        rgchPath));

            *(PTWINRESULT)ptr = TR_DEST_WRITE_FAILED;
        }
    }
    else
        TRACE_OUT((TEXT("DeleteFolderProc(): Skipping file %s\\%s."),
                    pcszFolder,
                    pcwfd->cFileName));

    return(TRUE);
}


#ifdef DEBUG

/*
 ** CopyBufferIsOk()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL CopyBufferIsOk(void)
{
    /* Are the module copy buffer variables in a correct state? */

    return((! MucbCopyBufLen &&
                ! MpbyteCopyBuf) ||
            (MucbCopyBufLen > 0 &&
             IS_VALID_WRITE_BUFFER_PTR(MpbyteCopyBuf, BYTE, MucbCopyBufLen)));
}


/*
 ** VerifyRECITEMAndSrcRECNODE()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL VerifyRECITEMAndSrcRECNODE(PCRECNODE pcrnSrc)
{
    /* Do the RECITEM and source RECNODE actions match? */

    return((pcrnSrc->priParent->riaction == RIA_COPY &&
                pcrnSrc->rnaction == RNA_COPY_FROM_ME) ||
            (pcrnSrc->priParent->riaction == RIA_MERGE &&
             pcrnSrc->rnaction == RNA_MERGE_ME));
}

#endif


/****************************** Public Functions *****************************/


/*
 ** BeginCopy()
 **
 ** Increments copy buffer lock count.
 **
 ** Arguments:
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void BeginCopy(void)
{
    ASSERT(CopyBufferIsOk());

    ASSERT(MulcCopyBufLock < ULONG_MAX);
    MulcCopyBufLock++;

    ASSERT(CopyBufferIsOk());

    return;
}


/*
 ** EndCopy()
 **
 ** Decrements copy buffer lock count.
 **
 ** Arguments:
 **
 ** Returns:       void
 **
 ** Side Effects:  Frees copy buffer if lock count goes to 0.
 */
PUBLIC_CODE void EndCopy(void)
{
    ASSERT(CopyBufferIsOk());

    /* Is the copy buffer still locked? */

    if (! --MulcCopyBufLock)
        DestroyCopyBuffer();

    ASSERT(CopyBufferIsOk());

    return;
}


/*
 ** CopyHandler()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT CopyHandler(PRECNODE prnSrc, RECSTATUSPROC rsp,
        LPARAM lpCallbackData, DWORD dwFlags,
        HWND hwndOwner, HWND hwndProgressFeedback)
{
    TWINRESULT tr;
    RECSTATUSUPDATE rsu;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(prnSrc, CRECNODE));
    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSPROC));
    ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RI_FLAGS));
    ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_ALLOW_UI) ||
            IS_VALID_HANDLE(hwndOwner, WND));
    ASSERT(IS_FLAG_CLEAR(dwFlags, RI_FL_FEEDBACK_WINDOW_VALID) ||
            IS_VALID_HANDLE(hwndProgressFeedback, WND));

    ASSERT(VerifyRECITEMAndSrcRECNODE(prnSrc));

    /* 0% complete. */

    rsu.ulScale = 1;
    rsu.ulProgress = 0;

    if (NotifyReconciliationStatus(rsp, RS_BEGIN_COPY, (LPARAM)&rsu,
                lpCallbackData))
    {
        tr = CreateDestinationFolders(prnSrc);

        if (tr == TR_SUCCESS)
        {
            TCHAR rgchPath[MAX_PATH_LEN];
            CLSID clsidReconciler;
            HRESULT hr;

            ComposePath(rgchPath, prnSrc->pcszFolder, prnSrc->priParent->pcszName, ARRAYSIZE(rgchPath));
            ASSERT(lstrlen(rgchPath) < ARRAYSIZE(rgchPath));

            if (SUCCEEDED(GetCopyHandlerClassID(rgchPath, &clsidReconciler)))
            {
                hr = OLECopy(prnSrc, &clsidReconciler, rsp, lpCallbackData,
                        dwFlags, hwndOwner, hwndProgressFeedback);

                if (SUCCEEDED(hr))
                {
                    if (hr != S_FALSE)
                    {
                        /*
                         * Set the destination files' time stamps to the source
                         * file's time stamp to assist clients that don't maintain
                         * a persistent briefcase database, like MPR.  Failure to
                         * set the time stamps is not fatal.
                         */

                        ASSERT(hr == REC_S_IDIDTHEUPDATES);
                        TRACE_OUT((TEXT("CopyHandler(): OLECopy() on %s returned %s."),
                                    rgchPath,
                                    GetHRESULTString(hr)));

                        if (! SetDestinationTimeStamps(prnSrc))
                            WARNING_OUT((TEXT("CopyHandler(): SetDestinationTimeStamps() failed.  Not all destination files have been marked with source file's time stamp.")));

                        tr = TR_SUCCESS;
                    }
                    else
                    {
                        WARNING_OUT((TEXT("CopyHandler(): OLECopy() on %s returned %s.  Resorting to internal copy routine."),
                                    rgchPath,
                                    GetHRESULTString(hr)));

                        /*
                         * Update the source RECNODE's file stamp in case it was
                         * changed by the reconciler.
                         */

                        MyGetFileStampByHPATH(((PCOBJECTTWIN)(prnSrc->hObjectTwin))->hpath,
                                GetString(((PCOBJECTTWIN)(prnSrc->hObjectTwin))->ptfParent->hsName),
                                &(prnSrc->fsCurrent));

                        tr = SimpleCopy(prnSrc, rsp, lpCallbackData);
                    }
                }
                else
                    tr = TranslateHRESULTToTWINRESULT(hr);
            }
            else
                tr = SimpleCopy(prnSrc, rsp, lpCallbackData);

            if (tr == TR_SUCCESS)
            {
                /* 100% complete. */

                rsu.ulScale = 1;
                rsu.ulProgress = 1;

                /* Don't allow abort here. */

                NotifyReconciliationStatus(rsp, RS_END_COPY, (LPARAM)&rsu,
                        lpCallbackData);
            }
        }
    }
    else
        tr = TR_ABORT;

    return(tr);
}


/*
 ** NotifyReconciliationStatus()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL NotifyReconciliationStatus(RECSTATUSPROC rsp, UINT uMsg, LPARAM lp,
        LPARAM lpCallbackData)
{
    BOOL bContinue;

    /* lp may be any value. */
    /* lpCallbackData may be any value. */

    ASSERT(! rsp ||
            IS_VALID_CODE_PTR(rsp, RECSTATUSROC));
    ASSERT(IsValidRecStatusProcMsg(uMsg));

    if (rsp)
    {
        TRACE_OUT((TEXT("NotifyReconciliationStatus(): Calling RECSTATUSPROC with message %s, ulProgress %lu, ulScale %lu, callback data %#lx."),
                    GetRECSTATUSPROCMSGString(uMsg),
                    ((PCRECSTATUSUPDATE)lp)->ulProgress,
                    ((PCRECSTATUSUPDATE)lp)->ulScale,
                    lpCallbackData));

        bContinue = (*rsp)(uMsg, lp, lpCallbackData);
    }
    else
    {
        TRACE_OUT((TEXT("NotifyReconciliationStatus(): Not calling NULL RECSTATUSPROC with message %s, ulProgress %lu, ulScale %lu, callback data %#lx."),
                    GetRECSTATUSPROCMSGString(uMsg),
                    ((PCRECSTATUSUPDATE)lp)->ulProgress,
                    ((PCRECSTATUSUPDATE)lp)->ulScale,
                    lpCallbackData));

        bContinue = TRUE;
    }

    if (! bContinue)
        WARNING_OUT((TEXT("NotifyReconciliationStatus(): Client callback aborted reconciliation.")));

    return(bContinue);
}


/*
 ** CreateFolders()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT CreateFolders(LPCTSTR pcszPath, HPATH hpath)
{
    TWINRESULT tr;

    ASSERT(IsCanonicalPath(pcszPath));
    ASSERT(IS_VALID_HANDLE(hpath, PATH));

    if (MyIsPathOnVolume(pcszPath, hpath))
    {
        TCHAR rgchPath[MAX_PATH_LEN];
        LPTSTR pszRootEnd;
        LPTSTR pszHackSlash;

        /* Create working copy of path. */

        ASSERT(lstrlen(pcszPath) < ARRAYSIZE(rgchPath));
        lstrcpyn(rgchPath, pcszPath, ARRAYSIZE(rgchPath));

        pszRootEnd = FindEndOfRootSpec(rgchPath, hpath);

        /*
         * Hack off the path at each successive slash, and check to see if that
         * folder needs to be created.
         */

        tr = TR_SUCCESS;

        pszHackSlash = pszRootEnd;

        while (*pszHackSlash)
        {
            TCHAR chReplaced;

            while (*pszHackSlash && *pszHackSlash != TEXT('\\'))
                pszHackSlash = CharNext(pszHackSlash);

            /* Replace the slash with a null terminator to set the current folder. */

            chReplaced = *pszHackSlash;
            *pszHackSlash = TEXT('\0');

            /* Does the folder exist? */

            if (! PathExists(rgchPath))
            {
                /* No.  Try to create it. */

                TCHAR szAnsiPath[MAX_PATH];
                MakeAnsiPath(rgchPath, szAnsiPath, ARRAYSIZE(szAnsiPath));

                if (CreateDirectory(szAnsiPath, NULL))
                {
                    WARNING_OUT((TEXT("CreateFolders(): Created folder %s."),
                                rgchPath));

                    NotifyShell(rgchPath, NSE_CREATE_FOLDER);
                }
                else
                {
                    WARNING_OUT((TEXT("CreateFolders(): Failed to create folder %s."),
                                rgchPath));

                    tr = TR_DEST_OPEN_FAILED;
                    break;
                }
            }

            *pszHackSlash = chReplaced;

            if (chReplaced)
                pszHackSlash++;
        }
    }
    else
        tr = TR_UNAVAILABLE_VOLUME;

    return(tr);
}


/*
 ** DestroySubtree()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT DestroySubtree(LPCTSTR pcszPath, HPATH hpath)
{
    TWINRESULT tr;

    ASSERT(IsCanonicalPath(pcszPath));
    ASSERT(IS_VALID_HANDLE(hpath, PATH));

    if (MyIsPathOnVolume(pcszPath, hpath))
    {
        tr = ExpandSubtree(hpath, &DeleteFolderProc, &tr);

        if (tr == TR_SUCCESS)
        {
            if (RemoveDirectory(pcszPath))
            {
                WARNING_OUT((TEXT("DestroySubtree(): Subtree %s removed successfully."),
                            pcszPath));

                NotifyShell(pcszPath, NSE_DELETE_FOLDER);
            }
            else
            {
                if (PathExists(pcszPath))
                {
                    /* Still there. */

                    WARNING_OUT((TEXT("DestroySubtree(): Failed to remove subtree root %s."),
                                pcszPath));

                    tr = TR_DEST_WRITE_FAILED;
                }
                else
                    /* Already gone. */
                    tr = TR_SUCCESS;
            }
        }
    }
    else
        tr = TR_UNAVAILABLE_VOLUME;

    return(tr);
}


#ifdef DEBUG

/*
 ** IsValidRecStatusProcMsg()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidRecStatusProcMsg(UINT uMsg)
{
    BOOL bResult;

    switch (uMsg)
    {
        case RS_BEGIN_COPY:
        case RS_DELTA_COPY:
        case RS_END_COPY:
        case RS_BEGIN_MERGE:
        case RS_DELTA_MERGE:
        case RS_END_MERGE:
        case RS_BEGIN_DELETE:
        case RS_DELTA_DELETE:
        case RS_END_DELETE:
            bResult = TRUE;
            break;

        default:
            bResult = FALSE;
            ERROR_OUT((TEXT("IsValidRecStatusProcMsg(): Invalid RecStatusProc() message %u."),
                        uMsg));
            break;
    }

    return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\db.c ===
/*
 * db.c - Twin database module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"


/* Constants
 ************/

/* database header magic id string */

#define MAGIC_HEADER             "DDSH\x02\x05\x01\x14"

/* length of MAGIC_HEADER (no null terminator) */

#define MAGIC_HEADER_LEN         (8)

/* Types
 ********/

typedef struct _dbheader
{
   BYTE rgbyteMagic[MAGIC_HEADER_LEN];
   DWORD dwcbHeaderLen;
   DWORD dwMajorVer;
   DWORD dwMinorVer;
}
DBHEADER;
DECLARE_STANDARD_TYPES(DBHEADER);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT WriteDBHeader(HCACHEDFILE, PDBHEADER);
PRIVATE_CODE TWINRESULT ReadDBHeader(HCACHEDFILE, PDBHEADER);
PRIVATE_CODE TWINRESULT CheckDBHeader(PCDBHEADER);
PRIVATE_CODE TWINRESULT WriteTwinInfo(HCACHEDFILE, HBRFCASE);
PRIVATE_CODE TWINRESULT ReadTwinInfo(HCACHEDFILE, HBRFCASE, PCDBVERSION);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCDBHEADER(PCDBHEADER);

#endif


/*
** WriteDBHeader()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WriteDBHeader(HCACHEDFILE hcf, PDBHEADER pdbh)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pdbh, CDBHEADER));

   if (WriteToCachedFile(hcf, (PCVOID)pdbh, sizeof(*pdbh), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** ReadDBHeader()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ReadDBHeader(HCACHEDFILE hcf, PDBHEADER pdbh)
{
   TWINRESULT tr;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(pdbh, DBHEADER));

   if (ReadFromCachedFile(hcf, pdbh, sizeof(*pdbh), &dwcbRead) &&
       dwcbRead == sizeof(*pdbh))
      tr = CheckDBHeader(pdbh);
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


/*
** CheckDBHeader()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT CheckDBHeader(PCDBHEADER pcdbh)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;

   ASSERT(IS_VALID_READ_PTR(pcdbh, CDBHEADER));

   if (MyMemComp(pcdbh->rgbyteMagic, MAGIC_HEADER, sizeof(pcdbh->rgbyteMagic)) == CR_EQUAL)
   {
      /* Treat older databases as corrupt.  Support M8 databases. */

      if (pcdbh->dwMajorVer == HEADER_MAJOR_VER && 
          (pcdbh->dwMinorVer == HEADER_MINOR_VER || pcdbh->dwMinorVer == HEADER_M8_MINOR_VER))
      {
         if (pcdbh->dwcbHeaderLen == sizeof(*pcdbh))
            tr = TR_SUCCESS;
      }
      else if (pcdbh->dwMajorVer > HEADER_MAJOR_VER ||
               (pcdbh->dwMajorVer == HEADER_MAJOR_VER &&
                pcdbh->dwMinorVer > HEADER_MINOR_VER))
      {
         tr = TR_NEWER_BRIEFCASE;

         WARNING_OUT((TEXT("CheckDBHeader(): Newer database version %lu.%lu."),
                      pcdbh->dwMajorVer,
                      pcdbh->dwMinorVer));
      }
      else
      {
         tr = TR_CORRUPT_BRIEFCASE;

         WARNING_OUT((TEXT("CheckDBHeader(): Treating old database version %lu.%lu as corrupt.  Current database version is %lu.%lu."),
                      pcdbh->dwMajorVer,
                      pcdbh->dwMinorVer,
                      (DWORD)HEADER_MAJOR_VER,
                      (DWORD)HEADER_MINOR_VER));
      }
   }

   return(tr);
}


/*
** WriteTwinInfo()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WriteTwinInfo(HCACHEDFILE hcf, HBRFCASE hbr)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   tr = WritePathList(hcf, GetBriefcasePathList(hbr));

   if (tr == TR_SUCCESS)
   {
      tr = WriteBriefcaseInfo(hcf, hbr);

      if (tr == TR_SUCCESS)
      {
         tr = WriteStringTable(hcf, GetBriefcaseNameStringTable(hbr));

         if (tr == TR_SUCCESS)
         {
            tr = WriteTwinFamilies(hcf, GetBriefcaseTwinFamilyPtrArray(hbr));

            if (tr == TR_SUCCESS)
               tr = WriteFolderPairList(hcf, GetBriefcaseFolderPairPtrArray(hbr));
         }
      }
   }

   return(tr);
}


/*
** ReadTwinInfo()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ReadTwinInfo(HCACHEDFILE hcf, HBRFCASE hbr,
                                     PCDBVERSION pcdbver)
{
   TWINRESULT tr;
   HHANDLETRANS hhtPathTrans;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   tr = ReadPathList(hcf, GetBriefcasePathList(hbr), &hhtPathTrans);

   if (tr == TR_SUCCESS)
   {
      tr = ReadBriefcaseInfo(hcf, hbr, hhtPathTrans);

      if (tr == TR_SUCCESS)
      {
         HHANDLETRANS hhtNameTrans;

         tr = ReadStringTable(hcf, GetBriefcaseNameStringTable(hbr), &hhtNameTrans);

         if (tr == TR_SUCCESS)
         {
            tr = ReadTwinFamilies(hcf, hbr, pcdbver, hhtPathTrans, hhtNameTrans);

            if (tr == TR_SUCCESS)
               tr = ReadFolderPairList(hcf, hbr, hhtPathTrans, hhtNameTrans);

            DestroyHandleTranslator(hhtNameTrans);
         }
      }

      DestroyHandleTranslator(hhtPathTrans);
   }

   return(tr);
}


#ifdef VSTF

/*
** IsValidPCDBHEADER()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCDBHEADER(PCDBHEADER pcdbh)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pcdbh, CDBHEADER) &&
       EVAL(MyMemComp(pcdbh->rgbyteMagic, MAGIC_HEADER, sizeof(pcbdh->rgbyteMagic)) == CR_EQUAL) &&
       EVAL(pcdbh->dwcbHeaderLen == sizeof(*pcdbh)) &&
       EVAL(pcdbh->dwMajorVer == HEADER_MAJOR_VER) &&
       EVAL(pcdbh->dwMinorVer == HEADER_MINOR_VER || pcdbh->dwMinorVer == HEADER_M8_MINOR_VER))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}

#endif


/****************************** Public Functions *****************************/


/*
** WriteTwinDatabase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT WriteTwinDatabase(HCACHEDFILE hcf, HBRFCASE hbr)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   if (! SeekInCachedFile(hcf, 0, FILE_BEGIN))
   {
      DBHEADER dbh;

      /* Set up database header. */

      CopyMemory(dbh.rgbyteMagic, MAGIC_HEADER, sizeof(dbh.rgbyteMagic));
      dbh.dwcbHeaderLen = sizeof(dbh);
      dbh.dwMajorVer = HEADER_MAJOR_VER;
      dbh.dwMinorVer = HEADER_MINOR_VER;

      tr = WriteDBHeader(hcf, &dbh);

      if (tr == TR_SUCCESS)
      {
         TRACE_OUT((TEXT("WriteTwinDatabase(): Wrote database header version %lu.%lu."),
                    dbh.dwMajorVer,
                    dbh.dwMinorVer));

         tr = WriteTwinInfo(hcf, hbr);

         if (tr == TR_SUCCESS && ! SetEndOfCachedFile(hcf))
            tr = TR_BRIEFCASE_WRITE_FAILED;
      }
   }
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** ReadTwinDatabase()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT ReadTwinDatabase(HBRFCASE hbr, HCACHEDFILE hcf)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   if (! SeekInCachedFile(hcf, 0, FILE_BEGIN))
   {
      DBHEADER dbh;

      tr = ReadDBHeader(hcf, &dbh);

      if (tr == TR_SUCCESS)
      {
         TRACE_OUT((TEXT("ReadTwinDatabase(): Read database header version %lu.%lu."),
                    dbh.dwMajorVer,
                    dbh.dwMinorVer));

         tr = ReadTwinInfo(hcf, hbr, (PCDBVERSION)&dbh.dwMajorVer);

         if (tr == TR_SUCCESS)
            ASSERT(GetCachedFilePointerPosition(hcf) == GetCachedFileSize(hcf));
      }
   }
   else
      tr = TR_BRIEFCASE_READ_FAILED;

   return(tr);
}


/*
** WriteDBSegmentHeader()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT WriteDBSegmentHeader(HCACHEDFILE hcf,
                                       LONG lcbDBSegmentHeaderOffset,
                                       PCVOID pcvSegmentHeader,
                                       UINT ucbSegmentHeaderLen)
{
   TWINRESULT tr;
   DWORD dwcbStartOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(lcbDBSegmentHeaderOffset >= 0);
   ASSERT(ucbSegmentHeaderLen > 0);
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcvSegmentHeader, BYTE, ucbSegmentHeaderLen));

   dwcbStartOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbStartOffset != INVALID_SEEK_POSITION &&
       SeekInCachedFile(hcf, lcbDBSegmentHeaderOffset, SEEK_SET) != INVALID_SEEK_POSITION &&
       WriteToCachedFile(hcf, pcvSegmentHeader, ucbSegmentHeaderLen, NULL) &&
       SeekInCachedFile(hcf, dwcbStartOffset, SEEK_SET) != INVALID_SEEK_POSITION)
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** TranslateFCRESULTToTWINRESULT()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT TranslateFCRESULTToTWINRESULT(FCRESULT fcr)
{
   TWINRESULT tr;

   switch (fcr)
   {
      case FCR_SUCCESS:
         tr = TR_SUCCESS;
         break;

      case FCR_OUT_OF_MEMORY:
         tr = TR_OUT_OF_MEMORY;
         break;

      case FCR_OPEN_FAILED:
         tr = TR_BRIEFCASE_OPEN_FAILED;
         break;

      case FCR_CREATE_FAILED:
         tr = TR_BRIEFCASE_OPEN_FAILED;
         break;

      case FCR_WRITE_FAILED:
         tr = TR_BRIEFCASE_WRITE_FAILED;
         break;

      default:
         ASSERT(fcr == FCR_FILE_LOCKED);
         tr = TR_BRIEFCASE_LOCKED;
         break;
   }

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\db.h ===
/*
 * db.c - Twin database module description.
 */


/* Types
 ********/

/* database header version numbers */

#define HEADER_MAJOR_VER         (0x0001)
#define HEADER_MINOR_VER         (0x0005)

/* old (but supported) version numbers */

#define HEADER_M8_MINOR_VER      (0x0004)


typedef struct _dbversion
{
    DWORD dwMajorVer;
    DWORD dwMinorVer;
}
DBVERSION;
DECLARE_STANDARD_TYPES(DBVERSION);


/* Prototypes
 *************/

/* db.c */

extern TWINRESULT WriteTwinDatabase(HCACHEDFILE, HBRFCASE);
extern TWINRESULT ReadTwinDatabase(HBRFCASE, HCACHEDFILE);
extern TWINRESULT WriteDBSegmentHeader(HCACHEDFILE, LONG, PCVOID, UINT);
extern TWINRESULT TranslateFCRESULTToTWINRESULT(FCRESULT);

/* path.c */

extern TWINRESULT WritePathList(HCACHEDFILE, HPATHLIST);
extern TWINRESULT ReadPathList(HCACHEDFILE, HPATHLIST, PHHANDLETRANS);

/* brfcase.c */

extern TWINRESULT WriteBriefcaseInfo(HCACHEDFILE, HBRFCASE);
extern TWINRESULT ReadBriefcaseInfo(HCACHEDFILE, HBRFCASE, HHANDLETRANS);

/* string.c */

extern TWINRESULT WriteStringTable(HCACHEDFILE, HSTRINGTABLE);
extern TWINRESULT ReadStringTable(HCACHEDFILE, HSTRINGTABLE, PHHANDLETRANS);

/* twin.c */

extern TWINRESULT WriteTwinFamilies(HCACHEDFILE, HPTRARRAY);
extern TWINRESULT ReadTwinFamilies(HCACHEDFILE, HBRFCASE, PCDBVERSION, HHANDLETRANS, HHANDLETRANS);

/* foldtwin.c */

extern TWINRESULT WriteFolderPairList(HCACHEDFILE, HPTRARRAY);
extern TWINRESULT ReadFolderPairList(HCACHEDFILE, HBRFCASE, HHANDLETRANS, HHANDLETRANS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\debug.c ===
/*
 * debug.c - Debug functions module.
 */


/* Headers
 **********/

#include "project.h"
#include <shlwapi.h>
#pragma hdrstop


/* Constants
 ************/

#ifdef DEBUG

#define LOG_FILE_NAME               TEXT("debug.log")

#endif


/* Types
 ********/

#ifdef DEBUG

/* debug flags */

typedef enum _debugdebugflags
{
    DEBUG_DFL_ENABLE_TRACE_MESSAGES  = 0x0001,

    DEBUG_DFL_LOG_TRACE_MESSAGES     = 0x0002,

    DEBUG_DFL_DUMP_THREAD_ID         = 0x0004,

    DEBUG_DFL_DUMP_LAST_ERROR        = 0x0008,

    ALL_DEBUG_DFLAGS                 = (DEBUG_DFL_ENABLE_TRACE_MESSAGES |
            DEBUG_DFL_LOG_TRACE_MESSAGES |
            DEBUG_DFL_DUMP_THREAD_ID |
            DEBUG_DFL_DUMP_LAST_ERROR)
}
DEBUGDEBUGFLAGS;

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* parameters used by SpewOut() */

PUBLIC_DATA DWORD GdwSpewFlags = 0;
PUBLIC_DATA UINT GuSpewSev = 0;
PUBLIC_DATA UINT GuSpewLine = 0;
PUBLIC_DATA LPCTSTR GpcszSpewFile = NULL;

#endif   /* DEBUG */


/* Module Variables
 *******************/

#ifdef DEBUG

/* TLS slot used to store stack depth for SpewOut() indentation */

PRIVATE_DATA DWORD MdwStackDepthSlot = TLS_OUT_OF_INDEXES;

/* hack stack depth counter used until MdwStackDepthSlot is not available */

PRIVATE_DATA ULONG MulcHackStackDepth = 0;

/* debug flags */

PRIVATE_DATA DWORD MdwDebugModuleFlags = 0;

/* .ini file switch descriptions */

PRIVATE_DATA CBOOLINISWITCH cbisEnableTraceMessages =
{
    IST_BOOL,
    TEXT("EnableTraceMessages"),
    &MdwDebugModuleFlags,
    DEBUG_DFL_ENABLE_TRACE_MESSAGES
};

PRIVATE_DATA CBOOLINISWITCH cbisLogTraceMessages =
{
    IST_BOOL,
    TEXT("LogTraceMessages"),
    &MdwDebugModuleFlags,
    DEBUG_DFL_LOG_TRACE_MESSAGES
};

PRIVATE_DATA CBOOLINISWITCH cbisDumpThreadID =
{
    IST_BOOL,
    TEXT("DumpThreadID"),
    &MdwDebugModuleFlags,
    DEBUG_DFL_DUMP_THREAD_ID
};

PRIVATE_DATA CBOOLINISWITCH cbisDumpLastError =
{
    IST_BOOL,
    TEXT("DumpLastError"),
    &MdwDebugModuleFlags,
    DEBUG_DFL_DUMP_LAST_ERROR
};

PRIVATE_DATA const PCVOID MrgcpcvisDebugModule[] =
{
    &cbisLogTraceMessages,
    &cbisEnableTraceMessages,
    &cbisDumpThreadID,
    &cbisDumpLastError
};

#endif   /* DEBUG */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL LogOutputDebugString(LPCTSTR);
PRIVATE_CODE BOOL IsValidSpewSev(UINT);

#endif   /* DEBUG */


#ifdef DEBUG

/*
 ** LogOutputDebugString()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL LogOutputDebugString(LPCTSTR pcsz)
{
    BOOL bResult = FALSE;
    UINT ucb;
    TCHAR rgchLogFile[MAX_PATH_LEN];

    ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));

    ucb = GetWindowsDirectory(rgchLogFile, ARRAYSIZE(rgchLogFile));

    if (ucb > 0 && ucb < ARRAYSIZE(rgchLogFile))
    {
        HANDLE hfLog;

        StrCatBuff(rgchLogFile, TEXT("\\"), ARRAYSIZE(rgchLogFile));
        StrCatBuff(rgchLogFile, LOG_FILE_NAME, ARRAYSIZE(rgchLogFile));
        hfLog = CreateFile(rgchLogFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS,
                FILE_FLAG_WRITE_THROUGH, NULL);

        if (hfLog != INVALID_HANDLE_VALUE)
        {
            if (SetFilePointer(hfLog, 0, NULL, FILE_END) != INVALID_SEEK_POSITION)
            {
                DWORD dwcbWritten;

                bResult = WriteFile(hfLog, pcsz, lstrlen(pcsz)*SIZEOF(TCHAR), &dwcbWritten, NULL);

                if (! CloseHandle(hfLog) && bResult)
                    bResult = FALSE;
            }
        }
    }
    return(bResult);
}


/*
 ** IsValidSpewSev()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidSpewSev(UINT uSpewSev)
{
    BOOL bResult;

    switch (uSpewSev)
    {
        case SPEW_TRACE:
        case SPEW_WARNING:
        case SPEW_ERROR:
        case SPEW_FATAL:
            bResult = TRUE;
            break;

        default:
            ERROR_OUT((TEXT("IsValidSpewSev(): Invalid debug spew severity %u."),
                        uSpewSev));
            bResult = FALSE;
            break;
    }

    return(bResult);
}

#endif   /* DEBUG */


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
 ** SetDebugModuleIniSwitches()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL SetDebugModuleIniSwitches(void)
{
    BOOL bResult;

    bResult = SetIniSwitches(MrgcpcvisDebugModule,
            ARRAY_ELEMENTS(MrgcpcvisDebugModule));

    ASSERT(FLAGS_ARE_VALID(MdwDebugModuleFlags, ALL_DEBUG_DFLAGS));

    return(bResult);
}


/*
 ** InitDebugModule()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL InitDebugModule(void)
{
    ASSERT(MdwStackDepthSlot == TLS_OUT_OF_INDEXES);

    MdwStackDepthSlot = TlsAlloc();

    if (MdwStackDepthSlot != TLS_OUT_OF_INDEXES)
    {
        EVAL(TlsSetValue(MdwStackDepthSlot, IntToPtr(MulcHackStackDepth)));

        TRACE_OUT((TEXT("InitDebugModule(): Using thread local storage slot %lu for debug stack depth counter."),
                    MdwStackDepthSlot));
    }
    else
        WARNING_OUT((TEXT("InitDebugModule(): TlsAlloc() failed to allocate thread local storage for debug stack depth counter.")));

    return(TRUE);
}


/*
 ** ExitDebugModule()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void ExitDebugModule(void)
{
    if (MdwStackDepthSlot != TLS_OUT_OF_INDEXES)
    {
        MulcHackStackDepth = PtrToUlong(TlsGetValue(MdwStackDepthSlot));

        /* Leave MulcHackStackDepth == 0 if TlsGetValue() fails. */

        EVAL(TlsFree(MdwStackDepthSlot));
        MdwStackDepthSlot = TLS_OUT_OF_INDEXES;
    }

    return;
}


/*
 ** StackEnter()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void StackEnter(void)
{
    if (MdwStackDepthSlot != TLS_OUT_OF_INDEXES)
    {
        ULONG ulcDepth;

        ulcDepth = PtrToUlong(TlsGetValue(MdwStackDepthSlot));

        ASSERT(ulcDepth < ULONG_MAX);

        EVAL(TlsSetValue(MdwStackDepthSlot, IntToPtr(ulcDepth + 1)));
    }
    else
    {
        ASSERT(MulcHackStackDepth < ULONG_MAX);
        InterlockedIncrement(&MulcHackStackDepth);
    }

    return;
}


/*
 ** StackLeave()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void StackLeave(void)
{
    if (MdwStackDepthSlot != TLS_OUT_OF_INDEXES)
    {
        ULONG ulcDepth;

        ulcDepth = PtrToUlong(TlsGetValue(MdwStackDepthSlot));

        if (EVAL(ulcDepth > 0))
            EVAL(TlsSetValue(MdwStackDepthSlot, IntToPtr(ulcDepth - 1)));
    }
    else
    {
        if (EVAL(MulcHackStackDepth > 0))
            InterlockedDecrement(&MulcHackStackDepth);
    }

    return;
}


/*
 ** GetStackDepth()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE ULONG GetStackDepth(void)
{
    ULONG ulcDepth;

    if (MdwStackDepthSlot != TLS_OUT_OF_INDEXES)
        ulcDepth = PtrToUlong(TlsGetValue(MdwStackDepthSlot));
    else
        ulcDepth = MulcHackStackDepth;

    return(ulcDepth);
}


/*
 ** SpewOut()
 **
 ** Spews out a formatted message to the debug terminal.
 **
 ** Arguments:     pcszFormat - pointer to wvnsprintf() format string
 **                ... - formatting arguments ala wvnsprintf()
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 **
 ** N.b., this function assumes the global variables GdwSpewFlags, GuSpewSev,
 ** GpcszSpewModule, GpcszSpewFile, and GpcszSpewLine are filled in.
 **
 ** SpewOut() uses global variables to set the message parameters in order to
 ** permit printf()-style macro expansion.
 */
PUBLIC_CODE void __cdecl SpewOut(LPCTSTR pcszFormat, ...)
{
    va_list  arglist;

    ASSERT(IS_VALID_STRING_PTR(pcszFormat, CSTR));

    ASSERT(FLAGS_ARE_VALID(GdwSpewFlags, ALL_SPEW_FLAGS));
    ASSERT(IsValidSpewSev(GuSpewSev));
    ASSERT(IS_FLAG_CLEAR(GdwSpewFlags, SPEW_FL_SPEW_LOCATION) ||
            (IS_VALID_STRING_PTR(GpcszSpewFile, CSTR) &&
             IS_VALID_STRING_PTR(GpcszSpewModule, CSTR)));

    if (GuSpewSev != SPEW_TRACE || IS_FLAG_SET(MdwDebugModuleFlags, DEBUG_DFL_ENABLE_TRACE_MESSAGES))
    {
        int nMsgLen;
        TCHAR rgchMsg[1024];

        if (IS_FLAG_SET(GdwSpewFlags, SPEW_FL_SPEW_PREFIX))
        {
            static TCHAR SrgchSpewLeader[] = TEXT("                                                                                ");
            ULONG ulcStackDepth;
            TCHAR chReplaced;
            LPTSTR pszSpewLeaderEnd;
            LPCTSTR pcszSpewPrefix;

            /* Build spew message space leader string. */

            ulcStackDepth = GetStackDepth();

            if (ulcStackDepth < ARRAYSIZE(SrgchSpewLeader))
                pszSpewLeaderEnd = SrgchSpewLeader + ulcStackDepth;
            else
                pszSpewLeaderEnd = SrgchSpewLeader + ARRAYSIZE(SrgchSpewLeader) - 1;

            chReplaced = *pszSpewLeaderEnd;
            *pszSpewLeaderEnd = TEXT('\0');

            /* Determine spew prefix. */

            switch (GuSpewSev)
            {
                case SPEW_TRACE:
                    pcszSpewPrefix = TEXT("t");
                    break;

                case SPEW_WARNING:
                    pcszSpewPrefix = TEXT("w");
                    break;

                case SPEW_ERROR:
                    pcszSpewPrefix = TEXT("e");
                    break;

                case SPEW_FATAL:
                    pcszSpewPrefix = TEXT("f");
                    break;

                default:
                    pcszSpewPrefix = TEXT("u");
                    ERROR_OUT((TEXT("SpewOut(): Invalid GuSpewSev %u."),
                                GuSpewSev));
                    break;
            }

            nMsgLen = wnsprintf(rgchMsg, ARRAYSIZE(rgchMsg), TEXT("%s%s %s "), SrgchSpewLeader, pcszSpewPrefix, GpcszSpewModule);

            /* Restore spew leader. */

            *pszSpewLeaderEnd = chReplaced;

            ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));
        }
        else
            nMsgLen = 0;

        /* Append thread ID. */

        if (IS_FLAG_SET(MdwDebugModuleFlags, DEBUG_DFL_DUMP_THREAD_ID))
        {
            nMsgLen += wnsprintf(rgchMsg + nMsgLen, ARRAYSIZE(rgchMsg) - nMsgLen, TEXT("%#lx "), GetCurrentThreadId());

            ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));
        }

        /* Build position string. */

        if (IS_FLAG_SET(GdwSpewFlags, SPEW_FL_SPEW_LOCATION))
        {
            nMsgLen += wnsprintf(rgchMsg + nMsgLen, ARRAYSIZE(rgchMsg) - nMsgLen, TEXT("(%s line %u): "), GpcszSpewFile, GuSpewLine);

            ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));
        }

        /* Append message string. */

        va_start(arglist,pcszFormat);
        nMsgLen += wvnsprintf(rgchMsg + nMsgLen, ARRAYSIZE(rgchMsg) - nMsgLen, pcszFormat, arglist);
        va_end(arglist);

        ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));

        if (IS_FLAG_SET(GdwSpewFlags, DEBUG_DFL_DUMP_THREAD_ID))
        {
            if (GuSpewSev == SPEW_ERROR ||
                    GuSpewSev == SPEW_FATAL)
            {
                nMsgLen += wnsprintf(rgchMsg + nMsgLen, ARRAYSIZE(rgchMsg) - nMsgLen, TEXT(" (GetLastError() == %lu)"), GetLastError());

                ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));
            }
        }

        nMsgLen += wnsprintf(rgchMsg + nMsgLen, ARRAYSIZE(rgchMsg) - nMsgLen, TEXT("\r\n"));

        ASSERT(nMsgLen < ARRAYSIZE(rgchMsg));

        OutputDebugString(rgchMsg);

        if (IS_FLAG_SET(MdwDebugModuleFlags, DEBUG_DFL_LOG_TRACE_MESSAGES))
        {
            LogOutputDebugString(rgchMsg);
            LogOutputDebugString(TEXT("\r\n"));
        }
    }

    /* Break here on errors and fatal errors. */

    if (GuSpewSev == SPEW_ERROR || GuSpewSev == SPEW_FATAL)
        DebugBreak();

    return;
}

#endif   /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\expandft.c ===
/*
 * expandft.c - Routines for expanding folder twins to object twins.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"


/* Constants
 ************/

/* for subtree folder searching */

#define STAR_DOT_STAR            TEXT("*.*")


/* Macros
 *********/

/* name component macros used by NameComponentsIntersect() */

#define COMPONENT_CHARS_MATCH(ch1, ch2)   (CharLower((PTSTR)(DWORD_PTR)ch1) == CharLower((PTSTR)(DWORD_PTR)ch2) || (ch1) == QMARK || (ch2) == QMARK)

#define IS_COMPONENT_TERMINATOR(ch)       (! (ch) || (ch) == PERIOD || (ch) == ASTERISK)


/* Types
 ********/

/* find structure used by ExpandSubtree() */

typedef struct _findstate
{
    HANDLE hff;

    WIN32_FIND_DATA wfd;
}
FINDSTATE;
DECLARE_STANDARD_TYPES(FINDSTATE);

/* information structure passed to GenerateObjectTwinFromFolderTwinProc() */

typedef struct _expandsubtreetwininfo
{
    PFOLDERPAIR pfp;

    UINT ucbSubtreeRootPathLen;

    HCLSIFACECACHE hcic;

    CREATERECLISTPROC crlp;

    LPARAM lpCallbackData;

    TWINRESULT tr;
}
EXPANDSUBTREETWININFO;
DECLARE_STANDARD_TYPES(EXPANDSUBTREETWININFO);


/* Module Variables
 *******************/

/*
 * folder names to be avoided during subtree expansion (comparison is
 * case-insensitive)
 */

PRIVATE_DATA CONST LPCTSTR MrgcpcszFoldersToAvoid[] =
{
    TEXT("."),
    TEXT("..")
};


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL SetObjectTwinFileStamp(POBJECTTWIN, PVOID);
PRIVATE_CODE void MarkFolderTwinDeletionPending(PFOLDERPAIR);
PRIVATE_CODE void UnmarkFolderTwinDeletionPending(PFOLDERPAIR);
PRIVATE_CODE TWINRESULT ExpandFolderTwin(PFOLDERPAIR, HCLSIFACECACHE, CREATERECLISTPROC, LPARAM);
PRIVATE_CODE BOOL GenerateObjectTwinFromFolderTwinProc(LPCTSTR, PCWIN32_FIND_DATA, PVOID);
PRIVATE_CODE TWINRESULT ExpandSubtreeTwin(PFOLDERPAIR, HCLSIFACECACHE, CREATERECLISTPROC, LPARAM);
PRIVATE_CODE BOOL IsFolderToExpand(LPCTSTR);
PRIVATE_CODE TWINRESULT FakeObjectTwinFromFolderTwin(PCFOLDERPAIR, LPCTSTR, LPCTSTR, HCLSIFACECACHE, POBJECTTWIN *, POBJECTTWIN *);
PRIVATE_CODE TWINRESULT AddFolderObjectTwinFromFolderTwin(PCFOLDERPAIR, LPCTSTR, HCLSIFACECACHE);
PRIVATE_CODE TWINRESULT AddFileObjectTwinFromFolderTwin(PCFOLDERPAIR, LPCTSTR, PCWIN32_FIND_DATA, HCLSIFACECACHE);
PRIVATE_CODE BOOL NameComponentsIntersect(LPCTSTR, LPCTSTR);
PRIVATE_CODE BOOL AttributesMatch(DWORD, DWORD);
PRIVATE_CODE void PrepareForFolderTwinExpansion(HBRFCASE);
PRIVATE_CODE TWINRESULT MyExpandIntersectingFolderTwins(PFOLDERPAIR, HCLSIFACECACHE, CREATERECLISTPROC, LPARAM);
PRIVATE_CODE TWINRESULT HalfExpandIntersectingFolderTwins(PFOLDERPAIR, HCLSIFACECACHE, CREATERECLISTPROC, LPARAM);

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCEXPANDSUBTREETWININFO(PCEXPANDSUBTREETWININFO);

#endif


/*
 ** SetObjectTwinFileStampCondition()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL SetObjectTwinFileStampCondition(POBJECTTWIN pot,
        PVOID fscond)
{
    ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
    ASSERT(IsValidFILESTAMPCONDITION((FILESTAMPCONDITION)PtrToUlong(fscond)));

    ZeroMemory(&(pot->fsCurrent), sizeof(pot->fsCurrent));
    pot->fsCurrent.fscond = (FILESTAMPCONDITION)PtrToUlong(fscond);

    SetStubFlag(&(pot->stub), STUB_FL_FILE_STAMP_VALID);

    return(TRUE);
}


/*
 ** MarkFolderTwinDeletionPending()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void MarkFolderTwinDeletionPending(PFOLDERPAIR pfp)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

    if (IsStubFlagClear(&(pfp->stub), STUB_FL_DELETION_PENDING))
    {
        TCHAR rgchRootPath[MAX_PATH_LEN];

        GetPathRootString(pfp->hpath, rgchRootPath, ARRAYSIZE(rgchRootPath));

        if (PathExists(rgchRootPath))
        {
            SetStubFlag(&(pfp->stub), STUB_FL_DELETION_PENDING);

            TRACE_OUT((TEXT("MarkFolderTwinDeletionPending(): Folder twin deletion pending for deleted folder %s."),
                        DebugGetPathString(pfp->hpath)));
        }
        else
            WARNING_OUT((TEXT("MarkFolderTwinDeletionPending(): Root path %s of folder %s does not exist."),
                        rgchRootPath,
                        DebugGetPathString(pfp->hpath)));
    }

    return;
}


/*
 ** UnmarkFolderTwinDeletionPending()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void UnmarkFolderTwinDeletionPending(PFOLDERPAIR pfp)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

    if (IsStubFlagSet(&(pfp->stub), STUB_FL_DELETION_PENDING))
        WARNING_OUT((TEXT("UnmarkFolderTwinDeletionPending(): Folder twin %s was deleted but has been recreated."),
                    DebugGetPathString(pfp->hpath)));

    ClearStubFlag(&(pfp->stub), STUB_FL_DELETION_PENDING);

    return;
}


/*
 ** ExpandFolderTwin()
 **
 ** Expands a single folder of half of a folder pair into object twins.
 **
 ** Arguments:     pfp - pointer to folder pair whose folder is to be expanded
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT ExpandFolderTwin(PFOLDERPAIR pfp, HCLSIFACECACHE hcic,
        CREATERECLISTPROC crlp,
        LPARAM lpCallbackData)
{
    TWINRESULT tr = TR_SUCCESS;
    TCHAR rgchSearchSpec[MAX_PATH_LEN];

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
    ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
    ASSERT(! crlp ||
            IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

    ASSERT(IsPathVolumeAvailable(pfp->hpath));
    ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_SUBTREE));
    ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_USED));

    /* Build search specification. */

    GetPathString(pfp->hpath, rgchSearchSpec, ARRAYSIZE(rgchSearchSpec));

    if (PathExists(rgchSearchSpec))
    {
        WIN32_FIND_DATA wfd;
        HANDLE hff;

        UnmarkFolderTwinDeletionPending(pfp);

        TRACE_OUT((TEXT("ExpandFolderTwin(): Expanding folder %s for objects matching %s."),
                    rgchSearchSpec,
                    GetString(pfp->pfpd->hsName)));

        tr = AddFolderObjectTwinFromFolderTwin(pfp, EMPTY_STRING, hcic);

        if (tr == TR_SUCCESS)
        {
            CatPath(rgchSearchSpec, GetString(pfp->pfpd->hsName), ARRAYSIZE(rgchSearchSpec));

            hff = FindFirstFile(rgchSearchSpec, &wfd);

            /* Did we find a matching object? */

            if (hff != INVALID_HANDLE_VALUE)
            {
                /* Yes. */

                do
                {
                    /* Ping. */

                    if (NotifyCreateRecListStatus(crlp, CRLS_DELTA_CREATE_REC_LIST,
                                0, lpCallbackData))
                    {
                        if (AttributesMatch(pfp->pfpd->dwAttributes,
                                    wfd.dwFileAttributes))
                        {
                            TRACE_OUT((TEXT("ExpandFolderTwin(): Found matching object %s."),
                                        &(wfd.cFileName)));

                            tr = AddFileObjectTwinFromFolderTwin(pfp, EMPTY_STRING,
                                    &wfd, hcic);

                            if (tr != TR_SUCCESS)
                                break;
                        }
                    }
                    else
                        tr = TR_ABORT;

                } while (FindNextFile(hff, &wfd));
            }

            if (hff != INVALID_HANDLE_VALUE)
                FindClose(hff);
        }

        TRACE_OUT((TEXT("ExpandFolderTwin(): Folder expansion complete.")));
    }
    else
        MarkFolderTwinDeletionPending(pfp);

    return(tr);
}


/*
 ** GenerateObjectTwinFromFolderTwinProc()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL GenerateObjectTwinFromFolderTwinProc(LPCTSTR pcszFolder,
        PCWIN32_FIND_DATA pcwfd,
        PVOID pvpesti)
{
    TWINRESULT tr;
    PEXPANDSUBTREETWININFO pesti = pvpesti;

    ASSERT(IsCanonicalPath(pcszFolder));
    ASSERT(IS_VALID_READ_PTR(pcwfd, CWIN32_FIND_DATA));
    ASSERT(IS_VALID_STRUCT_PTR(pesti, CEXPANDSUBTREETWININFO));

    /* Ping. */

    if (NotifyCreateRecListStatus(pesti->crlp, CRLS_DELTA_CREATE_REC_LIST, 0,
                pesti->lpCallbackData))
    {
        if (IS_ATTR_DIR(pcwfd->dwFileAttributes))
        {
            TCHAR rgchFolder[MAX_PATH_LEN];

            /* Add any folder as a folder object twin. */

            ComposePath(rgchFolder, pcszFolder, pcwfd->cFileName, ARRAYSIZE(rgchFolder));
            ASSERT(lstrlen(rgchFolder) < ARRAYSIZE(rgchFolder));

            tr = AddFolderObjectTwinFromFolderTwin(
                    pesti->pfp,
                    rgchFolder + (pesti->ucbSubtreeRootPathLen / sizeof(TCHAR)),
                    pesti->hcic);
        }
        else
        {
            /* Does this file match the requested attributes? */

            if (NamesIntersect(pcwfd->cFileName,
                        GetString(pesti->pfp->pfpd->hsName)) &&
                    AttributesMatch(pesti->pfp->pfpd->dwAttributes,
                        pcwfd->dwFileAttributes))
            {
                /* Yes.  Twin it. */

                TRACE_OUT((TEXT("GenerateObjectTwinFromFolderTwinProc(): Found matching object %s in subfolder %s."),
                            pcwfd->cFileName,
                            pcszFolder));

                tr = AddFileObjectTwinFromFolderTwin(
                        pesti->pfp,
                        pcszFolder + (pesti->ucbSubtreeRootPathLen / sizeof(TCHAR)),
                        pcwfd, pesti->hcic);
            }
            else
            {
                TRACE_OUT((TEXT("GenerateObjectTwinFromFolderTwinProc(): Skipping unmatched object %s in subfolder %s."),
                            pcwfd->cFileName,
                            pcszFolder));

                tr = TR_SUCCESS;
            }
        }
    }
    else
        tr = TR_ABORT;

    pesti->tr = tr;

    ASSERT(IS_VALID_STRUCT_PTR(pvpesti, CEXPANDSUBTREETWININFO));

    return(tr == TR_SUCCESS);
}


/*
 ** ExpandSubtreeTwin()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT ExpandSubtreeTwin(PFOLDERPAIR pfp, HCLSIFACECACHE hcic,
        CREATERECLISTPROC crlp,
        LPARAM lpCallbackData)
{
    TWINRESULT tr = TR_SUCCESS;
    TCHAR rgchPath[MAX_PATH_LEN];

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
    ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
    ASSERT(! crlp ||
            IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

    ASSERT(IsPathVolumeAvailable(pfp->hpath));
    ASSERT(IsStubFlagSet(&(pfp->stub), STUB_FL_SUBTREE));
    ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_USED));

    GetPathString(pfp->hpath, rgchPath, ARRAYSIZE(rgchPath));

    if (PathExists(rgchPath))
    {
        UnmarkFolderTwinDeletionPending(pfp);

        tr = AddFolderObjectTwinFromFolderTwin(pfp, EMPTY_STRING, hcic);

        if (tr == TR_SUCCESS)
        {
            EXPANDSUBTREETWININFO esti;

            esti.pfp = pfp;
            esti.ucbSubtreeRootPathLen = lstrlen(rgchPath) * sizeof(TCHAR); // UNICODE really cb?
            esti.hcic = hcic;
            esti.crlp = crlp;
            esti.lpCallbackData = lpCallbackData;
            esti.tr = TR_SUCCESS;

            tr = ExpandSubtree(pfp->hpath, &GenerateObjectTwinFromFolderTwinProc,
                    &esti);

            ASSERT(tr != TR_SUCCESS ||
                    esti.tr == TR_SUCCESS);

            if (tr == TR_SUCCESS ||
                    tr == TR_ABORT)
                tr = esti.tr;
        }
    }
    else
        MarkFolderTwinDeletionPending(pfp);

    return(tr);
}


/*
 ** IsFolderToExpand()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsFolderToExpand(LPCTSTR pcszFolder)
{
    BOOL bExpandMe = TRUE;
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(MrgcpcszFoldersToAvoid); i++)
    {
        if (ComparePathStrings(pcszFolder, MrgcpcszFoldersToAvoid[i])
                == CR_EQUAL)
        {
            bExpandMe = FALSE;
            break;
        }
    }

    return(bExpandMe);
}


/*
 ** FakeObjectTwinFromFolderTwin()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT FakeObjectTwinFromFolderTwin(PCFOLDERPAIR pcfp,
        LPCTSTR pcszSubPath,
        LPCTSTR pcszName,
        HCLSIFACECACHE hcic,
        POBJECTTWIN *ppot1,
        POBJECTTWIN *ppot2)
{
    TWINRESULT tr = TR_OUT_OF_MEMORY;
    HPATHLIST hpl;
    HPATH hpath1;

    ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
    ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
    ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
    ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
    ASSERT(IS_VALID_WRITE_PTR(ppot1, POBJECTTWIN));
    ASSERT(IS_VALID_WRITE_PTR(ppot2, POBJECTTWIN));

    /* If the common sub path is non-empty, append it to the path strings. */

    hpl = GetBriefcasePathList(pcfp->pfpd->hbr);

    if (AddChildPath(hpl, pcfp->hpath, pcszSubPath, &hpath1))
    {
        HPATH hpath2;

        if (AddChildPath(hpl, pcfp->pfpOther->hpath, pcszSubPath, &hpath2))
        {
            /* Add the two object twins. */

            tr = TwinObjects(pcfp->pfpd->hbr, hcic, hpath1, hpath2, pcszName,
                    ppot1, ppot2);

            DeletePath(hpath2);
        }

        DeletePath(hpath1);
    }

    return(tr);
}


/*
 ** AddFolderObjectTwinFromFolderTwin()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT AddFolderObjectTwinFromFolderTwin(PCFOLDERPAIR pcfp,
        LPCTSTR pcszSubPath,
        HCLSIFACECACHE hcic)
{
    TWINRESULT tr;
    POBJECTTWIN pot1;
    POBJECTTWIN pot2;

    ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
    ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
    ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));

    /* Add the two object twins. */

    tr = FakeObjectTwinFromFolderTwin(pcfp, pcszSubPath, EMPTY_STRING, hcic,
            &pot1, &pot2);

    /* An attempted redundant add is ok. */

    if (tr == TR_DUPLICATE_TWIN)
        tr = TR_SUCCESS;

    if (tr == TR_SUCCESS)
        /* Cache folder object twin file stamps. */
        SetObjectTwinFileStampCondition(pot1, IntToPtr(FS_COND_EXISTS));

    return(tr);
}


/*
 ** AddFileObjectTwinFromFolderTwin()
 **
 ** Adds a pair of object twins generated by a folder twin.
 **
 ** Arguments:     pfp - pointer to folder pair that generated the two object
 **                      twins
 **                pcszSubPath - common path off of folder pair roots describing
 **                              object's location
 **                pcszName - name of object twins
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT AddFileObjectTwinFromFolderTwin(PCFOLDERPAIR pcfp,
        LPCTSTR pcszSubPath,
        PCWIN32_FIND_DATA pcwfd,
        HCLSIFACECACHE hcic)
{
    TWINRESULT tr;
    POBJECTTWIN pot1;
    POBJECTTWIN pot2;

    ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
    ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
    ASSERT(IS_VALID_READ_PTR(pcwfd, CWIN32_FIND_DATA));
    ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));

    /* Add the two object twins. */

    tr = FakeObjectTwinFromFolderTwin(pcfp, pcszSubPath, pcwfd->cFileName, hcic,
            &pot1, &pot2);

    /* An attempted redundant add is ok. */

    if (tr == TR_DUPLICATE_TWIN)
        tr = TR_SUCCESS;

    if (tr == TR_SUCCESS)
    {
        /* Cache object twin file stamp. */

        CopyFileStampFromFindData(pcwfd, &(pot1->fsCurrent));

        SetStubFlag(&(pot1->stub), STUB_FL_FILE_STAMP_VALID);
    }

    return(tr);
}


/*
 ** NameComponentsIntersect()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL NameComponentsIntersect(LPCTSTR pcszComponent1,
        LPCTSTR pcszComponent2)
{
    BOOL bIntersect;

    ASSERT(IS_VALID_STRING_PTR(pcszComponent1, CSTR));
    ASSERT(IS_VALID_STRING_PTR(pcszComponent2, CSTR));

    while (! IS_COMPONENT_TERMINATOR(*pcszComponent1) && ! IS_COMPONENT_TERMINATOR(*pcszComponent2) &&
            COMPONENT_CHARS_MATCH(*pcszComponent1, *pcszComponent2))
    {
        pcszComponent1 = CharNext(pcszComponent1);
        pcszComponent2 = CharNext(pcszComponent2);
    }

    if (*pcszComponent1 == ASTERISK ||
            *pcszComponent2 == ASTERISK ||
            *pcszComponent1 == *pcszComponent2)
        bIntersect = TRUE;
    else
    {
        LPCTSTR pcszTrailer;

        if (! *pcszComponent1 || *pcszComponent1 == PERIOD)
            pcszTrailer = pcszComponent2;
        else
            pcszTrailer = pcszComponent1;

        while (*pcszTrailer == QMARK)
            pcszTrailer++;

        if (IS_COMPONENT_TERMINATOR(*pcszTrailer))
            bIntersect = TRUE;
        else
            bIntersect = FALSE;
    }

    return(bIntersect);
}


/*
 ** AttributesMatch()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** An object's attributes match the master attributes iff the object's
 ** attributes do not contain any set bits that are not also set in the master
 ** attributes.
 */
PRIVATE_CODE BOOL AttributesMatch(DWORD dwMasterAttributes,
        DWORD dwObjectAttributes)
{
    // We don't consider a difference in compression to be enough to call
    // the file different, especially since that attribute is impossible
    // to reconcile in some cases.

    dwObjectAttributes &= ~(FILE_ATTRIBUTE_COMPRESSED);

    return(! (dwObjectAttributes & (~dwMasterAttributes)));
}


/*
 ** PrepareForFolderTwinExpansion()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       void
 **
 ** Side Effects:  none
 **
 ** N.b., this function should be called before the outermost call to
 ** MyExpandIntersectingFolderTwins().
 */
PRIVATE_CODE void PrepareForFolderTwinExpansion(HBRFCASE hbr)
{
    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

    ClearFlagInArrayOfStubs(GetBriefcaseFolderPairPtrArray(hbr), STUB_FL_USED);

    EVAL(EnumObjectTwins(hbr,
                (ENUMGENERATEDOBJECTTWINSPROC)&ClearStubFlagWrapper,
                IntToPtr(STUB_FL_FILE_STAMP_VALID)));

    return;
}


/*
 ** MyExpandIntersectingFolderTwins()
 **
 ** Expands all folder twins intersecting a pair of folder twins.
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  Marks expanded folder pairs used.
 **
 ** N.b., PrepareForFolderTwinExpansion(pfp->pfpd->hbr) should be called before
 ** the first time this function is called.
 */
PRIVATE_CODE TWINRESULT MyExpandIntersectingFolderTwins(PFOLDERPAIR pfp,
        HCLSIFACECACHE hcic,
        CREATERECLISTPROC crlp,
        LPARAM lpCallbackData)
{
    TWINRESULT tr;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
    ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
    ASSERT(! crlp ||
            IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

    /*
     * N.b., pfp may already be marked used here, but may intersect folder twins
     * that have not yet been expanded.
     */

    tr = HalfExpandIntersectingFolderTwins(pfp, hcic, crlp, lpCallbackData);

    if (tr == TR_SUCCESS)
    {
        ASSERT(IsStubFlagSet(&(pfp->stub), STUB_FL_USED));

        tr = HalfExpandIntersectingFolderTwins(pfp->pfpOther, hcic, crlp,
                lpCallbackData);
    }

    return(tr);
}


/*
 ** HalfExpandIntersectingFolderTwins()
 **
 ** Expands all folder twins intersecting one half of a pair of folder twins.
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  Marks expanded folder pairs used.
 **
 ** N.b., this function is only meant to be called from
 ** MyExpandIntersectingFolderTwins().
 */
PRIVATE_CODE TWINRESULT HalfExpandIntersectingFolderTwins(
        PFOLDERPAIR pfp,
        HCLSIFACECACHE hcic,
        CREATERECLISTPROC crlp,
        LPARAM lpCallbackData)
{
    TWINRESULT tr = TR_SUCCESS;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
    ASSERT(IS_VALID_HANDLE(hcic, CLSIFACECACHE));
    ASSERT(! crlp ||
            IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

    if (IsStubFlagClear(&(pfp->stub), STUB_FL_UNLINKED))
    {
        BOOL bArgIsSubtree;
        HPTRARRAY hpaFolderPairs;
        ARRAYINDEX ai;
        ARRAYINDEX aicFolderPairs;

        bArgIsSubtree = IsStubFlagSet(&(pfp->stub), STUB_FL_SUBTREE);

        hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pfp->pfpd->hbr);
        aicFolderPairs = GetPtrCount(hpaFolderPairs);

        for (ai = 0; ai < aicFolderPairs; ai++)
        {
            PFOLDERPAIR pfpCur;

            pfpCur = (PFOLDERPAIR)GetPtr(hpaFolderPairs, ai);

            ASSERT(IS_VALID_STRUCT_PTR(pfpCur, CFOLDERPAIR));

            if (IsStubFlagClear(&(pfpCur->stub), STUB_FL_USED) &&
                    NamesIntersect(GetString(pfp->pfpd->hsName),
                        GetString(pfpCur->pfpd->hsName)))
            {
                BOOL bCurIsSubtree;
                BOOL bExpand = FALSE;

                bCurIsSubtree = IsStubFlagSet(&(pfpCur->stub), STUB_FL_SUBTREE);

                if (bCurIsSubtree)
                {
                    if (bArgIsSubtree)
                        bExpand = SubtreesIntersect(pfp->hpath, pfpCur->hpath);
                    else
                        bExpand = IsPathPrefix(pfp->hpath, pfpCur->hpath);
                }
                else
                {
                    if (bArgIsSubtree)
                        bExpand = IsPathPrefix(pfpCur->hpath, pfp->hpath);
                    else
                        bExpand = (ComparePaths(pfp->hpath, pfpCur->hpath) == CR_EQUAL);
                }

                /* Expand folder twin and mark it used. */

                if (bExpand)
                {
                    /*
                     * Mark all generated object twins as non-existent or unavailable.
                     * Expand available folder twin.
                     */

                    if (IsPathVolumeAvailable(pfp->hpath))
                    {
                        EVAL(EnumGeneratedObjectTwins(pfp,
                                    &SetObjectTwinFileStampCondition,
                                    IntToPtr(FS_COND_DOES_NOT_EXIST)));

                        if (bCurIsSubtree)
                            tr = ExpandSubtreeTwin(pfpCur, hcic, crlp, lpCallbackData);
                        else
                            tr = ExpandFolderTwin(pfpCur, hcic, crlp, lpCallbackData);

                        if (tr != TR_SUCCESS)
                            break;
                    }
                    else
                    {
                        EVAL(EnumGeneratedObjectTwins(pfp, &SetObjectTwinFileStampCondition,
                                    IntToPtr(FS_COND_UNAVAILABLE)));

                        WARNING_OUT((TEXT("HalfExpandIntersectingFolderTwins(): Unavailable folder %s skipped."),
                                    DebugGetPathString(pfp->hpath)));
                    }

                    SetStubFlag(&(pfp->stub), STUB_FL_USED);
                }
            }
        }
    }

    return(tr);
}


#ifdef DEBUG

/*
 ** IsValidPCEXPANDSUBTREETWININFO()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCEXPANDSUBTREETWININFO(PCEXPANDSUBTREETWININFO pcesi)
{
    /* lpCallbackData may be any value. */

    return(IS_VALID_READ_PTR(pcesi, CEXPANDSUBTREETWININFO) &&
            IS_VALID_STRUCT_PTR(pcesi->pfp, CFOLDERPAIR) &&
            EVAL(pcesi->ucbSubtreeRootPathLen > 0) &&
            IS_VALID_HANDLE(pcesi->hcic, CLSIFACECACHE) &&
            IsValidTWINRESULT(pcesi->tr));
}

#endif


/****************************** Public Functions *****************************/


/*
 ** ExpandSubtree()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT ExpandSubtree(HPATH hpathRoot, EXPANDSUBTREEPROC esp,
        PVOID pvRefData)
{
    TWINRESULT tr;
    PFINDSTATE pfs;

    /* pvRefData may be any value. */

    ASSERT(IS_VALID_HANDLE(hpathRoot, PATH));
    ASSERT(IS_VALID_CODE_PTR(esp, EXPANDSUBTREEPROC));

    ASSERT(IsPathVolumeAvailable(hpathRoot));

    if (AllocateMemory(MAX_FOLDER_DEPTH * sizeof(pfs[0]), &pfs))
    {
        /* Copy subtree root folder to beginning of search path buffer. */

        TCHAR rgchSearchSpec[MAX_PATH_LEN];
        LPTSTR pszPathSuffix;
        int iFind;
        LPTSTR pszStartOfSubPath;
        BOOL bFound;
#ifdef DEBUG
        /* Are we leaking WIN32_FIND_DATA structures? */
        ULONG ulcOpenFinds = 0;
#endif

        rgchSearchSpec[0] = TEXT('\0');
        GetPathRootString(hpathRoot, rgchSearchSpec, ARRAYSIZE(rgchSearchSpec));
        pszPathSuffix = rgchSearchSpec + lstrlen(rgchSearchSpec);
        GetPathSuffixString(hpathRoot, pszPathSuffix);

        pszStartOfSubPath = rgchSearchSpec + lstrlen(rgchSearchSpec);

        TRACE_OUT((TEXT("ExpandSubtree(): Expanding subtree rooted at %s."),
                    rgchSearchSpec));

        /* Append *.* file specification. */

        CatPath(rgchSearchSpec, STAR_DOT_STAR, ARRAYSIZE(rgchSearchSpec));

        /* Begin search at subtree root. */

        iFind = 0;

        pfs[iFind].hff = FindFirstFile(rgchSearchSpec, &(pfs[iFind].wfd));

#ifdef DEBUG
        if (pfs[iFind].hff != INVALID_HANDLE_VALUE)
            ulcOpenFinds++;
#endif

        bFound = (pfs[iFind].hff != INVALID_HANDLE_VALUE);

        /* Rip off *.*. */

        DeleteLastPathElement(pszPathSuffix);

        /* Search subtree depth first. */

        tr = TR_SUCCESS;

        while (bFound && tr == TR_SUCCESS)
        {
            /* Did we find a directory to expand? */

            if (IS_ATTR_DIR(pfs[iFind].wfd.dwFileAttributes))
            {
                if (IsFolderToExpand(pfs[iFind].wfd.cFileName))
                {
                    /* Yes.  Dive down into it. */

                    /* Append the new directory to the current search path. */

                    CatPath(rgchSearchSpec, pfs[iFind].wfd.cFileName, ARRAYSIZE(rgchSearchSpec));

                    TRACE_OUT((TEXT("ExpandSubtree(): Diving into subfolder %s."),
                                rgchSearchSpec));

                    /* Append *.* file specification. */

                    CatPath(rgchSearchSpec, STAR_DOT_STAR, ARRAYSIZE(rgchSearchSpec));

                    /* Start search in the new directory. */

                    ASSERT(iFind < INT_MAX);
                    iFind++;
                    pfs[iFind].hff = FindFirstFile(rgchSearchSpec, &(pfs[iFind].wfd));

                    bFound = (pfs[iFind].hff != INVALID_HANDLE_VALUE);

#ifdef DEBUG
                    if (bFound)
                        ulcOpenFinds++;
#endif

                    /* Rip off *.*. */

                    DeleteLastPathElement(pszPathSuffix);
                }
                else
                    /* Continue search in this directory. */
                    bFound = FindNextFile(pfs[iFind].hff, &(pfs[iFind].wfd));
            }
            else
            {
                /* Found a file. */

                TRACE_OUT((TEXT("ExpandSubtree(): Found file %s\\%s."),
                            rgchSearchSpec,
                            pfs[iFind].wfd.cFileName));

                if ((*esp)(rgchSearchSpec, &(pfs[iFind].wfd), pvRefData))
                    bFound = FindNextFile(pfs[iFind].hff, &(pfs[iFind].wfd));
                else
                    tr = TR_ABORT;
            }

            if (tr == TR_SUCCESS)
            {
                while (! bFound)
                {
                    /* Find failed.  Climb back up one directory level. */

                    if (pfs[iFind].hff != INVALID_HANDLE_VALUE)
                    {
                        FindClose(pfs[iFind].hff);
#ifdef DEBUG
                        ulcOpenFinds--;
#endif
                    }

                    if (iFind > 0)
                    {
                        DeleteLastPathElement(pszPathSuffix);
                        iFind--;

                        if (IsFolderToExpand(pfs[iFind].wfd.cFileName))
                        {
                            TRACE_OUT((TEXT("ExpandSubtree(): Found folder %s\\%s."),
                                        rgchSearchSpec,
                                        pfs[iFind].wfd.cFileName));

                            if (! (*esp)(rgchSearchSpec, &(pfs[iFind].wfd), pvRefData))
                            {
                                tr = TR_ABORT;
                                break;
                            }
                        }

                        bFound = FindNextFile(pfs[iFind].hff, &(pfs[iFind].wfd));
                    }
                    else
                    {
                        ASSERT(! iFind);
                        break;
                    }
                }
            }
        }

        if (tr != TR_SUCCESS)
        {
            /* Close all open find operations on failure. */

            while (iFind >= 0)
            {
                if (pfs[iFind].hff != INVALID_HANDLE_VALUE)
                {
                    FindClose(pfs[iFind].hff);
                    iFind--;
#ifdef DEBUG
                    ulcOpenFinds--;
#endif
                }
            }
        }

        ASSERT(! ulcOpenFinds);

        FreeMemory(pfs);

        TRACE_OUT((TEXT("ExpandSubtree(): Subtree expansion complete.")));
    }
    else
        tr = TR_OUT_OF_MEMORY;

    return(tr);
}


/*
 ** ClearStubFlagWrapper()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL ClearStubFlagWrapper(PSTUB pstub, PVOID dwFlags)
{
    ASSERT(IS_VALID_STRUCT_PTR(pstub, CSTUB));
    ASSERT(FLAGS_ARE_VALID(PtrToUlong(dwFlags), ALL_STUB_FLAGS));

    ClearStubFlag(pstub, PtrToUlong(dwFlags));

    return(TRUE);
}


/*
 ** SetStubFlagWrapper()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL SetStubFlagWrapper(PSTUB pstub, PVOID dwFlags)
{
    ASSERT(IS_VALID_STRUCT_PTR(pstub, CSTUB));
    ASSERT(FLAGS_ARE_VALID(PtrToUlong(dwFlags), ALL_STUB_FLAGS));

    SetStubFlag(pstub, PtrToUlong(dwFlags));

    return(TRUE);
}


/*
 ** ExpandIntersectingFolderTwins()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  Leaves only the folder pairs expanded marked used.
 */
PUBLIC_CODE TWINRESULT ExpandIntersectingFolderTwins(PFOLDERPAIR pfp,
        CREATERECLISTPROC crlp,
        LPARAM lpCallbackData)
{
    TWINRESULT tr;
    HCLSIFACECACHE hcic;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
    ASSERT(! crlp ||
            IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

    ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_UNLINKED));

    if (CreateClassInterfaceCache(&hcic))
    {
        /* Prepare for call to MyExpandIntersectingFolderTwins(). */

        PrepareForFolderTwinExpansion(pfp->pfpd->hbr);

        tr = MyExpandIntersectingFolderTwins(pfp, hcic, crlp, lpCallbackData);

        DestroyClassInterfaceCache(hcic);
    }
    else
        tr = TR_OUT_OF_MEMORY;

    return(tr);
}


/*
 ** ExpandFolderTwinsIntersectingTwinList()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  Leaves only the folder pairs expanded marked used.
 */
PUBLIC_CODE TWINRESULT ExpandFolderTwinsIntersectingTwinList(
        HTWINLIST htl,
        CREATERECLISTPROC crlp,
        LPARAM lpCallbackData)
{
    TWINRESULT tr;
    HCLSIFACECACHE hcic;

    /* lpCallbackData may be any value. */

    ASSERT(IS_VALID_HANDLE(htl, TWINLIST));
    ASSERT(! crlp ||
            IS_VALID_CODE_PTR(crlp, CREATERECLISTPROC));

    if (CreateClassInterfaceCache(&hcic))
    {
        ARRAYINDEX aicTwins;
        ARRAYINDEX ai;

        tr = TR_SUCCESS;

        /* Prepare for calls to MyExpandIntersectingFolderTwins(). */

        PrepareForFolderTwinExpansion(GetTwinListBriefcase(htl));

        aicTwins = GetTwinListCount(htl);

        for (ai = 0; ai < aicTwins; ai++)
        {
            HTWIN htwin;

            htwin = GetTwinFromTwinList(htl, ai);

            /* Expand only live folder twins. */

            if (((PCSTUB)htwin)->st == ST_FOLDERPAIR)
            {
                tr = MyExpandIntersectingFolderTwins((PFOLDERPAIR)htwin, hcic,
                        crlp, lpCallbackData);

                if (tr != TR_SUCCESS)
                    break;
            }
        }

        DestroyClassInterfaceCache(hcic);
    }
    else
        tr = TR_OUT_OF_MEMORY;

    return(tr);
}


/*
 ** TryToGenerateObjectTwin()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT TryToGenerateObjectTwin(HBRFCASE hbr, HPATH hpathFolder,
        LPCTSTR pcszName,
        PBOOL pbGenerated,
        POBJECTTWIN *ppot)
{
    TWINRESULT tr;
    HCLSIFACECACHE hcic;

    ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
    ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
    ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
    ASSERT(IS_VALID_WRITE_PTR(pbGenerated, BOOL));
    ASSERT(IS_VALID_WRITE_PTR(ppot, POBJECTTWIN));

    if (CreateClassInterfaceCache(&hcic))
    {
        HPTRARRAY hpaFolderPairs;
        ARRAYINDEX aicPtrs;
        ARRAYINDEX ai;

        tr = TR_SUCCESS;
        *pbGenerated = FALSE;

        hpaFolderPairs = GetBriefcaseFolderPairPtrArray(hbr);

        aicPtrs = GetPtrCount(hpaFolderPairs);
        ASSERT(! (aicPtrs % 2));

        for (ai = 0; ai < aicPtrs; ai++)
        {
            PCFOLDERPAIR pcfp;

            pcfp = GetPtr(hpaFolderPairs, ai);

            if (FolderTwinGeneratesObjectTwin(pcfp, hpathFolder, pcszName))
            {
                TCHAR rgchSubPath[MAX_PATH_LEN];
                LPCTSTR pcszSubPath;
                POBJECTTWIN potOther;

                if (IsStubFlagSet(&(pcfp->stub), STUB_FL_SUBTREE))
                    pcszSubPath = FindChildPathSuffix(pcfp->hpath, hpathFolder,
                            rgchSubPath);
                else
                    pcszSubPath = EMPTY_STRING;

                tr = FakeObjectTwinFromFolderTwin(pcfp, pcszSubPath, pcszName,
                        hcic, ppot, &potOther);

                if (tr == TR_SUCCESS)
                    *pbGenerated = TRUE;
                else
                    ASSERT(tr != TR_DUPLICATE_TWIN);

                break;
            }
        }

        DestroyClassInterfaceCache(hcic);
    }
    else
        tr = TR_OUT_OF_MEMORY;

    ASSERT(tr != TR_SUCCESS ||
            ! *pbGenerated ||
            IS_VALID_STRUCT_PTR(*ppot, COBJECTTWIN));

    return(tr);
}


/*
 ** NamesIntersect()
 **
 ** Determines whether or not two names may refer to the same object.  Both
 ** names may contain wildcards ('*' or '?').
 **
 ** Arguments:     pcszName1 - first name
 **                pcszName2 - second name
 **
 ** Returns:       TRUE if the two names intersect.  FALSE if not.
 **
 ** Side Effects:  none
 **
 ** A "name" is broken up into two components: a "base" and an optional
 ** "extension", e.g., "BASE" or "BASE.EXT".
 **
 ** "Intersecting names" are defined as follows:
 **
 **    1) An asterisk matches 0 or more characters in the base or extension.
 **    2) Any characters after an asterisk in the base or extension are ignored.
 **    3) A question mark matches exactly one character, or no character if it
 **       appears at the end of the base or extension.
 **
 ** N.b., this function does not perform any checking on the validity of the two
 ** names.
 */
PUBLIC_CODE BOOL NamesIntersect(LPCTSTR pcszName1, LPCTSTR pcszName2)
{
    BOOL bIntersect = FALSE;

    ASSERT(IS_VALID_STRING_PTR(pcszName1, CSTR));
    ASSERT(IS_VALID_STRING_PTR(pcszName2, CSTR));

    if (NameComponentsIntersect(pcszName1, pcszName2))
    {
        LPCTSTR pcszExt1;
        LPCTSTR pcszExt2;

        /* Get extensions, skipping leading periods. */

        pcszExt1 = ExtractExtension(pcszName1);
        if (*pcszExt1 == PERIOD)
            pcszExt1 = CharNext(pcszExt1);

        pcszExt2 = ExtractExtension(pcszName2);
        if (*pcszExt2 == PERIOD)
            pcszExt2 = CharNext(pcszExt2);

        bIntersect = NameComponentsIntersect(pcszExt1, pcszExt2);
    }

    return(bIntersect);
}


#ifdef DEBUG

/*
 ** IsValidTWINRESULT()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE BOOL IsValidTWINRESULT(TWINRESULT tr)
{
    BOOL bResult;

    switch (tr)
    {
        case TR_SUCCESS:
        case TR_RH_LOAD_FAILED:
        case TR_SRC_OPEN_FAILED:
        case TR_SRC_READ_FAILED:
        case TR_DEST_OPEN_FAILED:
        case TR_DEST_WRITE_FAILED:
        case TR_ABORT:
        case TR_UNAVAILABLE_VOLUME:
        case TR_OUT_OF_MEMORY:
        case TR_FILE_CHANGED:
        case TR_DUPLICATE_TWIN:
        case TR_DELETED_TWIN:
        case TR_HAS_FOLDER_TWIN_SRC:
        case TR_INVALID_PARAMETER:
        case TR_REENTERED:
        case TR_SAME_FOLDER:
        case TR_SUBTREE_CYCLE_FOUND:
        case TR_NO_MERGE_HANDLER:
        case TR_MERGE_INCOMPLETE:
        case TR_TOO_DIFFERENT:
        case TR_BRIEFCASE_LOCKED:
        case TR_BRIEFCASE_OPEN_FAILED:
        case TR_BRIEFCASE_READ_FAILED:
        case TR_BRIEFCASE_WRITE_FAILED:
        case TR_CORRUPT_BRIEFCASE:
        case TR_NEWER_BRIEFCASE:
        case TR_NO_MORE:
            bResult = TRUE;
            break;

        default:
            bResult = FALSE;
            ERROR_OUT((TEXT("IsValidTWINRESULT(): Invalid TWINRESULT %d."),
                        tr));
            break;
    }

    return(bResult);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\expandft.h ===
/*
 * expandft.h - Routines for expanding folder twins to object twins
 *              description.
 */


/* Types
 ********/

/* subtree enumeration callback function called by ExpandSubtree() */

typedef BOOL (*EXPANDSUBTREEPROC)(LPCTSTR, PCWIN32_FIND_DATA, PVOID);


/* Prototypes
 *************/

/* expandft.c */

extern TWINRESULT ExpandSubtree(HPATH, EXPANDSUBTREEPROC, PVOID);
extern TWINRESULT ExpandFolderTwinsIntersectingTwinList(HTWINLIST, CREATERECLISTPROC, LPARAM);
extern BOOL NamesIntersect(LPCTSTR, LPCTSTR);

#ifdef DEBUG

extern BOOL IsValidTWINRESULT(TWINRESULT);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\dllinit.c ===
/*
 * dllinit.c - Initialization and termination routines.
 */

/*

Implementation Notes
--------------------

   Here are a few conventions I have attempted to follow in the object
synchronization engine:

1) Functions have only one exit point.

2) When calling a function that takes one or more pointers to variables to be
filled in with a result, the caller may only depend upon the variables being
filled in correctly if the function returns success.

3) AllocateMemory() and FreeMemory() are called instead of _fmalloc() and
_ffree() to allow debug manipulation of the heap.

4) Two layers of parameter validation have been implemented - validation of
parameters passed in from external callers and validation of parameters passed
in from internal callers.  #defining EXPV enables the external parameter
validation layer.  The internal parameter validation layer is only included in
the debug build.  The external parameter validation layer fails any call with
an invalid parameter, returning TR_INVALID_PARAMETER.  The internal parameter
validation layer displays a debug message when a call is made with an invalid
parameter, but allows the call to proceed.  External parameter validation is
available in all builds.  Internal parameter validation is only available in
the DEBUG build.

5) In addition to the two layers of parameter validation, validation of fields
of structures passed as arguments may be enabled by #defining VSTF.  Full
parent and child structure field validation can be quite time-consuming.  Field
validation for external structure parameters is available in all builds.  Field
validation for internal structure parameters is only available in the DEBUG
build.  (Full parameter and structure field validation has proven very valuable
in debugging.)

6) Some debug bounds check ASSERT()s use floating point math.  These floating
point bounds checks are only enabled if DBLCHECK is #defined.  Defining
DBLCHECK requires linking with the CRT library for floating point support.

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "init.h"


/* Module Prototypes
 ********************/

PRIVATE_CODE BOOL MyAttachProcess(HMODULE);
PRIVATE_CODE BOOL MyDetachProcess(HMODULE);


/* Global Variables
 *******************/

/* serialization control structure */

PUBLIC_DATA CSERIALCONTROL g_cserctrl =
{
   MyAttachProcess,
   MyDetachProcess,
   NULL,
   NULL
};

#ifdef DEBUG

/* .ini file name and section used by inifile.c!SetIniSwitches() */

PUBLIC_DATA LPCTSTR GpcszIniFile = TEXT("rover.ini");
PUBLIC_DATA LPCTSTR GpcszIniSection = TEXT("SyncEngineDebugOptions");

/* module name used by debug.c!SpewOut() */

PUBLIC_DATA LPCTSTR GpcszSpewModule = TEXT("SyncEng");

#endif


/***************************** Private Functions *****************************/


#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

/*
** MyAttachProcess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL MyAttachProcess(HMODULE hmod)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   DebugEntry(MyAttachProcess);

   bResult = (ProcessInitOLEPigModule() &&
              ProcessInitStorageModule());

   DebugExitBOOL(MyAttachProcess, bResult);

   return(bResult);
}


/*
** MyDetachProcess()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL MyDetachProcess(HMODULE hmod)
{
   BOOL bResult = TRUE;

   ASSERT(IS_VALID_HANDLE(hmod, MODULE));

   DebugEntry(MyDetachProcess);

   ProcessExitStorageModule();

   ProcessExitOLEPigModule();

   DebugExitBOOL(MyDetachProcess, bResult);

   return(bResult);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/****************************** Public Functions *****************************/


#ifdef DEBUG

/*
** SetAllIniSwitches()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL SetAllIniSwitches(void)
{
   BOOL bResult;

   bResult = SetDebugModuleIniSwitches();
   bResult = SetSerialModuleIniSwitches() && bResult;
   bResult = SetMemoryManagerModuleIniSwitches() && bResult;
   bResult = SetBriefcaseModuleIniSwitches() && bResult;

   return(bResult);
}

#endif


/*
** InitializeDLL()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL InitializeDLL(void)
{
   BOOL bResult;

#ifdef DEBUG
   DebugEntry(InitializeDLL);

   EVAL(InitDebugModule());

#endif

   bResult = (InitMemoryManagerModule() &&
              InitBriefcaseModule());

#ifdef DEBUG

   if (bResult)
   {
       SpewHeapSummary(0);
   }

#endif

   DebugExitBOOL(InitializeDLL, bResult);

   return(bResult);
}


/*
** TerminateDLL()
**
**
**
** Arguments:
**
** Returns:       TRUE
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL TerminateDLL(void)
{
   BOOL bResult = TRUE;

   DebugEntry(TerminateDLL);

#ifdef DEBUG

   SpewHeapSummary(0);

   TRACE_OUT((TEXT("TerminateDLL(): Starting heap cleanup.")));

#endif

   ExitBriefcaseModule();

#ifdef DEBUG

   TRACE_OUT((TEXT("TerminateDLL(): Heap cleanup complete.")));

   SpewHeapSummary(SHS_FL_SPEW_USED_INFO);

#endif

   ExitMemoryManagerModule();

#ifdef DEBUG

   ExitDebugModule();

#endif

   DebugExitBOOL(TerminateDLL, bResult);

   return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\fcache.h ===
/*
 * fcache.h - File cache ADT description.
 */


/* Types
 ********/

/* return code */

typedef enum _fcresult
{
   FCR_SUCCESS,
   FCR_OUT_OF_MEMORY,
   FCR_OPEN_FAILED,
   FCR_CREATE_FAILED,
   FCR_WRITE_FAILED,
   FCR_FILE_LOCKED
}
FCRESULT;
DECLARE_STANDARD_TYPES(FCRESULT);

/* handles */

#ifdef NOFCACHE
typedef HANDLE HCACHEDFILE;
#else
DECLARE_HANDLE(HCACHEDFILE);
#endif
DECLARE_STANDARD_TYPES(HCACHEDFILE);

/* cached file description */

typedef struct _cachedfile
{
   LPCTSTR pcszPath;

   DWORD dwcbDefaultCacheSize;

   DWORD dwOpenMode;

   DWORD dwSharingMode;

   PSECURITY_ATTRIBUTES psa;

   DWORD dwCreateMode;

   DWORD dwAttrsAndFlags;

   HANDLE hTemplateFile;
}
CACHEDFILE;
DECLARE_STANDARD_TYPES(CACHEDFILE);


/* Prototypes
 *************/

/* fcache.c */

extern FCRESULT CreateCachedFile(PCCACHEDFILE, PHCACHEDFILE);
extern FCRESULT SetCachedFileCacheSize(HCACHEDFILE, DWORD);
extern DWORD SeekInCachedFile(HCACHEDFILE, DWORD, DWORD);
extern BOOL SetEndOfCachedFile(HCACHEDFILE);
extern DWORD GetCachedFilePointerPosition(HCACHEDFILE);
extern DWORD GetCachedFileSize(HCACHEDFILE);
extern BOOL ReadFromCachedFile(HCACHEDFILE, PVOID, DWORD, PDWORD);
extern BOOL WriteToCachedFile(HCACHEDFILE, PCVOID, DWORD, PDWORD);
extern BOOL CommitCachedFile(HCACHEDFILE);
extern HANDLE GetFileHandle(HCACHEDFILE);
extern BOOL CloseCachedFile(HCACHEDFILE);
extern HANDLE GetFileHandle(HCACHEDFILE);

#if defined(DEBUG) || defined(VSTF)

extern BOOL IsValidHCACHEDFILE(HCACHEDFILE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\fcache.c ===
/*
 * fcache.c - File cache ADT module.
 */

/*

   The file cache ADT may be disabled by #defining NOFCACHE.  If NOFCACHE is
#defined, file cache ADT calls are translated into their direct Win32 file
system API equivalents.

*/


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Constants
 ************/

/* last resort default minimum cache size */

#define DEFAULT_MIN_CACHE_SIZE      (32)


/* Types
 ********/

#ifndef NOFCACHE

/* cached file description structure */

typedef struct _icachedfile
{
   /* current position of file pointer in file */

   DWORD dwcbCurFilePosition;

   /* file handle of cached file */

   HANDLE hfile;

   /* file open mode */

   DWORD dwOpenMode;

   /* size of cache in bytes */

   DWORD dwcbCacheSize;

   /* pointer to base of cache */

   PBYTE pbyteCache;

   /* size of default cache in bytes */

   DWORD dwcbDefaultCacheSize;

   /* default cache */

   PBYTE pbyteDefaultCache;

   /* length of file (including data written to cache) */

   DWORD dwcbFileLen;

   /* offset of start of cache in file */

   DWORD dwcbFileOffsetOfCache;

   /* number of valid bytes in cache, starting at beginning of cache */

   DWORD dwcbValid;

   /* number of uncommitted bytes in cache, starting at beginning of cache */

   DWORD dwcbUncommitted;

   /* path of cached file */

   LPTSTR pszPath;
}
ICACHEDFILE;
DECLARE_STANDARD_TYPES(ICACHEDFILE);

#endif   /* NOFCACHE */


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE FCRESULT SetUpCachedFile(PCCACHEDFILE, PHCACHEDFILE);

#ifndef NOFCACHE

PRIVATE_CODE void BreakDownCachedFile(PICACHEDFILE);
PRIVATE_CODE void ResetCacheToEmpty(PICACHEDFILE);
PRIVATE_CODE DWORD ReadFromCache(PICACHEDFILE, PVOID, DWORD);
PRIVATE_CODE DWORD GetValidReadData(PICACHEDFILE, PBYTE *);
PRIVATE_CODE BOOL FillCache(PICACHEDFILE, PDWORD);
PRIVATE_CODE DWORD WriteToCache(PICACHEDFILE, PCVOID, DWORD);
PRIVATE_CODE DWORD GetAvailableWriteSpace(PICACHEDFILE, PBYTE *);
PRIVATE_CODE BOOL CommitCache(PICACHEDFILE);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCICACHEDFILE(PCICACHEDFILE);

#endif   /* VSTF */

#endif   /* NOFCACHE */

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCCACHEDFILE(PCCACHEDFILE);

#endif   /* VSTF */


/*
** SetUpCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE FCRESULT SetUpCachedFile(PCCACHEDFILE pccf, PHCACHEDFILE phcf)
{
   FCRESULT fcr;
   HANDLE hfNew;

   ASSERT(IS_VALID_STRUCT_PTR(pccf, CCACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(phcf, HCACHEDFILE));

   /* Open the file with the requested open and sharing flags. */

   hfNew = CreateFile(pccf->pcszPath, pccf->dwOpenMode, pccf->dwSharingMode,
                      pccf->psa, pccf->dwCreateMode, pccf->dwAttrsAndFlags,
                      pccf->hTemplateFile);

   if (hfNew != INVALID_HANDLE_VALUE)
   {

#ifdef NOFCACHE

      *phcf = hfNew;

      fcr = FCR_SUCCESS;

#else
      PICACHEDFILE picf;

      fcr = FCR_OUT_OF_MEMORY;

      /* Try to allocate a new cached file structure. */

      if (AllocateMemory(sizeof(*picf), &picf))
      {
         DWORD dwcbDefaultCacheSize;

         /* Allocate the default cache for the cached file. */

         if (pccf->dwcbDefaultCacheSize > 0)
            dwcbDefaultCacheSize = pccf->dwcbDefaultCacheSize;
         else
         {
            dwcbDefaultCacheSize = DEFAULT_MIN_CACHE_SIZE;

            WARNING_OUT((TEXT("SetUpCachedFile(): Using minimum cache size of %lu instead of %lu."),
                         dwcbDefaultCacheSize,
                         pccf->dwcbDefaultCacheSize));
         }

         if (AllocateMemory(dwcbDefaultCacheSize, &(picf->pbyteDefaultCache)))
         {
            if (StringCopy(pccf->pcszPath, &(picf->pszPath)))
            {
               DWORD dwcbFileLenHigh;

               picf->dwcbFileLen = GetFileSize(hfNew, &dwcbFileLenHigh);

               if (picf->dwcbFileLen != INVALID_FILE_SIZE && ! dwcbFileLenHigh)
               {
                  /* Success!  Fill in cached file structure fields. */

                  picf->hfile = hfNew;
                  picf->dwcbCurFilePosition = 0;
                  picf->dwcbCacheSize = dwcbDefaultCacheSize;
                  picf->pbyteCache = picf->pbyteDefaultCache;
                  picf->dwcbDefaultCacheSize = dwcbDefaultCacheSize;
                  picf->dwOpenMode = pccf->dwOpenMode;

                  ResetCacheToEmpty(picf);

                  *phcf = (HCACHEDFILE)picf;
                  fcr = FCR_SUCCESS;

                  ASSERT(IS_VALID_HANDLE(*phcf, CACHEDFILE));

                  TRACE_OUT((TEXT("SetUpCachedFile(): Created %lu byte default cache for file %s."),
                             picf->dwcbCacheSize,
                             picf->pszPath));
               }
               else
               {
                  fcr = FCR_OPEN_FAILED;

SETUPCACHEDFILE_BAIL1:
                  FreeMemory(picf->pbyteDefaultCache);
SETUPCACHEDFILE_BAIL2:
                  FreeMemory(picf);
SETUPCACHEDFILE_BAIL3:
                  /*
                   * Failing to close the file properly is not a failure
                   * condition here.
                   */
                  CloseHandle(hfNew);
               }
            }
            else
               goto SETUPCACHEDFILE_BAIL1;
         }
         else
            goto SETUPCACHEDFILE_BAIL2;
      }
      else
         goto SETUPCACHEDFILE_BAIL3;

#endif   /* NOFCACHE */

   }
   else
   {
      switch (GetLastError())
      {
         /* Returned when file opened by local machine. */
         case ERROR_SHARING_VIOLATION:
            fcr = FCR_FILE_LOCKED;
            break;

         default:
            fcr = FCR_OPEN_FAILED;
            break;
      }
   }

   return(fcr);
}


#ifndef NOFCACHE

/*
** BreakDownCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void BreakDownCachedFile(PICACHEDFILE picf)
{
   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));

   /* Are we using the default cache? */

   if (picf->pbyteCache != picf->pbyteDefaultCache)
      /* No.  Free the cache. */
      FreeMemory(picf->pbyteCache);

   /* Free the default cache. */

   FreeMemory(picf->pbyteDefaultCache);

   TRACE_OUT((TEXT("BreakDownCachedFile(): Destroyed cache for file %s."),
              picf->pszPath));

   FreeMemory(picf->pszPath);
   FreeMemory(picf);

   return;
}


/*
** ResetCacheToEmpty()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void ResetCacheToEmpty(PICACHEDFILE picf)
{
   /*
    * Don't fully validate *picf here since we may be called by
    * SetUpCachedFile() before *picf has been set up.
    */

   ASSERT(IS_VALID_WRITE_PTR(picf, ICACHEDFILE));

   picf->dwcbFileOffsetOfCache = picf->dwcbCurFilePosition;
   picf->dwcbValid = 0;
   picf->dwcbUncommitted = 0;

   return;
}


/*
** ReadFromCache()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD ReadFromCache(PICACHEDFILE picf, PVOID hpbyteBuffer, DWORD dwcb)
{
   DWORD dwcbRead;
   PBYTE pbyteStart;
   DWORD dwcbValid;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_READ));
   ASSERT(dwcb > 0);

   /* Is there any valid data that can be read from the cache? */

   dwcbValid = GetValidReadData(picf, &pbyteStart);

   if (dwcbValid > 0)
   {
      /* Yes.  Copy it into the buffer. */

      dwcbRead = min(dwcbValid, dwcb);

      CopyMemory(hpbyteBuffer, pbyteStart, dwcbRead);

      picf->dwcbCurFilePosition += dwcbRead;
   }
   else
      dwcbRead = 0;

   return(dwcbRead);
}


/*
** GetValidReadData()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD GetValidReadData(PICACHEDFILE picf, PBYTE *ppbyteStart)
{
   DWORD dwcbValid;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(ppbyteStart, PBYTE *));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_READ));

   /* Is there any valid read data in the cache? */

   /* The current file position must be inside the valid data in the cache. */

   /* Watch out for overflow. */

   ASSERT(picf->dwcbFileOffsetOfCache <= DWORD_MAX - picf->dwcbValid);

   if (picf->dwcbCurFilePosition >= picf->dwcbFileOffsetOfCache &&
       picf->dwcbCurFilePosition < picf->dwcbFileOffsetOfCache + picf->dwcbValid)
   {
      DWORD dwcbStartBias;

      /* Yes. */

      dwcbStartBias = picf->dwcbCurFilePosition - picf->dwcbFileOffsetOfCache;

      *ppbyteStart = picf->pbyteCache + dwcbStartBias;

      /* The second clause above protects against underflow here. */

      dwcbValid = picf->dwcbValid - dwcbStartBias;
   }
   else
      /* No. */
      dwcbValid = 0;

   return(dwcbValid);
}


/*
** FillCache()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FillCache(PICACHEDFILE picf, PDWORD pdwcbNewData)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(pdwcbNewData, DWORD));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_READ));

   if (CommitCache(picf))
   {
      DWORD dwcbOffset;

      ResetCacheToEmpty(picf);

      /* Seek to start position. */

      dwcbOffset = SetFilePointer(picf->hfile, picf->dwcbCurFilePosition, NULL, FILE_BEGIN);

      if (dwcbOffset != INVALID_SEEK_POSITION)
      {
         DWORD dwcbRead;

         ASSERT(dwcbOffset == picf->dwcbCurFilePosition);

         /* Fill cache from file. */

         if (ReadFile(picf->hfile, picf->pbyteCache, picf->dwcbCacheSize, &dwcbRead, NULL))
         {
            picf->dwcbValid = dwcbRead;

            *pdwcbNewData = dwcbRead;
            bResult = TRUE;

            TRACE_OUT((TEXT("FillCache(): Read %lu bytes into cache starting at offset %lu in file %s."),
                       dwcbRead,
                       dwcbOffset,
                       picf->pszPath));
         }
      }
   }

   return(bResult);
}


/*
** WriteToCache()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD WriteToCache(PICACHEDFILE picf, PCVOID hpbyteBuffer, DWORD dwcb)
{
   DWORD dwcbAvailable;
   PBYTE pbyteStart;
   DWORD dwcbWritten;
   DWORD dwcbNewUncommitted;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_READ_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_WRITE));
   ASSERT(dwcb > 0);

   /* Is there any room left to write data into the cache? */

   dwcbAvailable = GetAvailableWriteSpace(picf, &pbyteStart);

   /* Yes.  Determine how much to copy into cache. */

   dwcbWritten = min(dwcbAvailable, dwcb);

   /* Can we write anything into the cache? */

   if (dwcbWritten > 0)
   {
      /* Yes.  Write it. */

      CopyMemory(pbyteStart, hpbyteBuffer, dwcbWritten);

      /* Watch out for overflow. */

      ASSERT(picf->dwcbCurFilePosition <= DWORD_MAX - dwcbWritten);

      picf->dwcbCurFilePosition += dwcbWritten;

      /* Watch out for underflow. */

      ASSERT(picf->dwcbCurFilePosition >= picf->dwcbFileOffsetOfCache);

      dwcbNewUncommitted = picf->dwcbCurFilePosition - picf->dwcbFileOffsetOfCache;

      if (picf->dwcbUncommitted < dwcbNewUncommitted)
         picf->dwcbUncommitted = dwcbNewUncommitted;

      if (picf->dwcbValid < dwcbNewUncommitted)
      {
         DWORD dwcbNewFileLen;

         picf->dwcbValid = dwcbNewUncommitted;

         /* Watch out for overflow. */

         ASSERT(picf->dwcbFileOffsetOfCache <= DWORD_MAX - dwcbNewUncommitted);

         dwcbNewFileLen = picf->dwcbFileOffsetOfCache + dwcbNewUncommitted;

         if (picf->dwcbFileLen < dwcbNewFileLen)
            picf->dwcbFileLen = dwcbNewFileLen;
      }
   }

   return(dwcbWritten);
}


/*
** GetAvailableWriteSpace()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE DWORD GetAvailableWriteSpace(PICACHEDFILE picf, PBYTE *ppbyteStart)
{
   DWORD dwcbAvailable;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(ppbyteStart, PBYTE *));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_WRITE));

   /* Is there room to write data in the cache? */

   /*
    * The current file position must be inside or just after the end of the
    * valid data in the cache, or at the front of the cache when there is no
    * valid data in the cache.
    */

   /* Watch out for overflow. */

   ASSERT(picf->dwcbFileOffsetOfCache <= DWORD_MAX - picf->dwcbValid);

   if (picf->dwcbCurFilePosition >= picf->dwcbFileOffsetOfCache &&
       picf->dwcbCurFilePosition <= picf->dwcbFileOffsetOfCache + picf->dwcbValid)
   {
      DWORD dwcbStartBias;

      /* Yes. */

      dwcbStartBias = picf->dwcbCurFilePosition - picf->dwcbFileOffsetOfCache;

      *ppbyteStart = picf->pbyteCache + dwcbStartBias;

      /* Watch out for underflow. */

      ASSERT(picf->dwcbCacheSize >= dwcbStartBias);

      dwcbAvailable = picf->dwcbCacheSize - dwcbStartBias;
   }
   else
      /* No. */
      dwcbAvailable = 0;

   return(dwcbAvailable);
}


/*
** CommitCache()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Calling CommitCache() on a file opened without write access is a NOP.
*/
PRIVATE_CODE BOOL CommitCache(PICACHEDFILE picf)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));

   /* Any data to commit? */

   if (IS_FLAG_SET(picf->dwOpenMode, GENERIC_WRITE) &&
       picf->dwcbUncommitted > 0)
   {
      DWORD dwcbOffset;

      /* Yes.  Seek to start position of cache in file. */

      bResult = FALSE;

      dwcbOffset = SetFilePointer(picf->hfile, picf->dwcbFileOffsetOfCache, NULL, FILE_BEGIN);

      if (dwcbOffset != INVALID_SEEK_POSITION)
      {
         DWORD dwcbWritten;

         ASSERT(dwcbOffset == picf->dwcbFileOffsetOfCache);

         /* Write to file from cache. */

         if (WriteFile(picf->hfile, picf->pbyteCache, picf->dwcbUncommitted, &dwcbWritten, NULL) &&
             dwcbWritten == picf->dwcbUncommitted)
         {
            TRACE_OUT((TEXT("CommitCache(): Committed %lu uncommitted bytes starting at offset %lu in file %s."),
                       dwcbWritten,
                       dwcbOffset,
                       picf->pszPath));

            bResult = TRUE;
         }
      }
   }
   else
      bResult = TRUE;

   return(bResult);
}


#ifdef VSTF

/*
** IsValidPCICACHEDFILE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCICACHEDFILE(PCICACHEDFILE pcicf)
{
   return(IS_VALID_READ_PTR(pcicf, CICACHEDFILE) &&
          IS_VALID_HANDLE(pcicf->hfile, FILE) &&
          FLAGS_ARE_VALID(pcicf->dwOpenMode, ALL_FILE_ACCESS_FLAGS) &&
          EVAL(pcicf->dwcbCacheSize > 0) &&
          IS_VALID_WRITE_BUFFER_PTR(pcicf->pbyteCache, BYTE, (UINT)(pcicf->dwcbCacheSize)) &&
          IS_VALID_WRITE_BUFFER_PTR(pcicf->pbyteDefaultCache, BYTE, (UINT)(pcicf->dwcbDefaultCacheSize)) &&
          EVAL(pcicf->dwcbCacheSize > pcicf->dwcbDefaultCacheSize ||
               pcicf->pbyteCache == pcicf->pbyteDefaultCache) &&
          IS_VALID_STRING_PTR(pcicf->pszPath, STR) &&
          EVAL(IS_FLAG_SET(pcicf->dwOpenMode, GENERIC_WRITE) ||
               ! pcicf->dwcbUncommitted) &&
          (EVAL(pcicf->dwcbValid <= pcicf->dwcbCacheSize) &&
           EVAL(pcicf->dwcbUncommitted <= pcicf->dwcbCacheSize) &&
           EVAL(pcicf->dwcbUncommitted <= pcicf->dwcbValid) &&
           (EVAL(! pcicf->dwcbValid ||
                 pcicf->dwcbFileLen >= pcicf->dwcbFileOffsetOfCache + pcicf->dwcbValid) &&
            EVAL(! pcicf->dwcbUncommitted ||
                 pcicf->dwcbFileLen >= pcicf->dwcbFileOffsetOfCache + pcicf->dwcbUncommitted))));
}

#endif   /* VSTF */

#endif   /* NOFCACHE */


#ifdef VSTF

/*
** IsValidPCCACHEDFILE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCCACHEDFILE(PCCACHEDFILE pccf)
{
   return(IS_VALID_READ_PTR(pccf, CCACHEDFILE) &&
          IS_VALID_STRING_PTR(pccf->pcszPath, CSTR) &&
          EVAL(pccf->dwcbDefaultCacheSize > 0) &&
          FLAGS_ARE_VALID(pccf->dwOpenMode, ALL_FILE_ACCESS_FLAGS) &&
          FLAGS_ARE_VALID(pccf->dwSharingMode, ALL_FILE_SHARING_FLAGS) &&
          (! pccf->psa ||
           IS_VALID_STRUCT_PTR(pccf->psa, CSECURITY_ATTRIBUTES)) &&
          IsValidFileCreationMode(pccf->dwCreateMode) &&
          FLAGS_ARE_VALID(pccf->dwAttrsAndFlags, ALL_FILE_ATTRIBUTES_AND_FLAGS) &&
          IS_VALID_HANDLE(pccf->hTemplateFile, TEMPLATEFILE));
}

#endif   /* VSTF */


/****************************** Public Functions *****************************/


/*
** CreateCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE FCRESULT CreateCachedFile(PCCACHEDFILE pccf, PHCACHEDFILE phcf)
{
   ASSERT(IS_VALID_STRUCT_PTR(pccf, CCACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(phcf, HCACHEDFILE));

   return(SetUpCachedFile(pccf, phcf));
}


/*
** SetCachedFileCacheSize()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  Commits the cache, and discards cached data.
*/
PUBLIC_CODE FCRESULT SetCachedFileCacheSize(HCACHEDFILE hcf, DWORD dwcbNewCacheSize)
{
   FCRESULT fcr;

   /* dwcbNewCacheSize may be any value here. */

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

#ifdef NOFCACHE

   fcr = FCR_SUCCESS;

#else

   /* Use default cache size instead of 0. */

   if (! dwcbNewCacheSize)
   {
      ASSERT(((PICACHEDFILE)hcf)->dwcbDefaultCacheSize > 0);

      dwcbNewCacheSize = ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize;
   }

   /* Is the cache size changing? */

   if (dwcbNewCacheSize == ((PICACHEDFILE)hcf)->dwcbCacheSize)
      /* No.  Whine about it. */
      WARNING_OUT((TEXT("SetCachedFileCacheSize(): Cache size is already %lu bytes."),
                   dwcbNewCacheSize));

   /* Commit the cache so we can change its size. */

   if (CommitCache((PICACHEDFILE)hcf))
   {
      PBYTE pbyteNewCache;

      /* Throw away cached data. */

      ResetCacheToEmpty((PICACHEDFILE)hcf);

      /* Do we need to allocate a new cache? */

      if (dwcbNewCacheSize <= ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize)
      {
         /* No. */

         pbyteNewCache = ((PICACHEDFILE)hcf)->pbyteDefaultCache;

         fcr = FCR_SUCCESS;

         TRACE_OUT((TEXT("SetCachedFileCacheSize(): Using %lu bytes of %lu bytes allocated to default cache."),
                    dwcbNewCacheSize,
                    ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize));
      }
      else
      {
         /* Yes. */

         if (AllocateMemory(dwcbNewCacheSize, &pbyteNewCache))
         {
            fcr = FCR_SUCCESS;

            TRACE_OUT((TEXT("SetCachedFileCacheSize(): Allocated %lu bytes for new cache."),
                       dwcbNewCacheSize));
         }
         else
            fcr = FCR_OUT_OF_MEMORY;
      }

      if (fcr == FCR_SUCCESS)
      {
         /* Do we need to free the old cache? */

         if (((PICACHEDFILE)hcf)->pbyteCache != ((PICACHEDFILE)hcf)->pbyteDefaultCache)
         {
            /* Yes. */

            ASSERT(((PICACHEDFILE)hcf)->dwcbCacheSize > ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize);

            FreeMemory(((PICACHEDFILE)hcf)->pbyteCache);
         }

         /* Use new cache. */

         ((PICACHEDFILE)hcf)->pbyteCache = pbyteNewCache;
         ((PICACHEDFILE)hcf)->dwcbCacheSize = dwcbNewCacheSize;
      }
   }
   else
      fcr = FCR_WRITE_FAILED;

#endif

   return(fcr);
}


/*
** SeekInCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE DWORD SeekInCachedFile(HCACHEDFILE hcf, DWORD dwcbSeek, DWORD uOrigin)
{
   DWORD dwcbResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(uOrigin == FILE_BEGIN || uOrigin == FILE_CURRENT || uOrigin == FILE_END);

#ifdef NOFCACHE

   dwcbResult = SetFilePointer(hcf, dwcbSeek, NULL, uOrigin);

#else

   {
      BOOL bValidTarget = TRUE;
      DWORD dwcbWorkingOffset = 0;

      /* Determine seek base. */

      switch (uOrigin)
      {
         case SEEK_CUR:
            dwcbWorkingOffset = ((PICACHEDFILE)hcf)->dwcbCurFilePosition;
            break;

         case SEEK_SET:
            break;

         case SEEK_END:
            dwcbWorkingOffset = ((PICACHEDFILE)hcf)->dwcbFileLen;
            break;

         default:
            bValidTarget = FALSE;
            break;
      }

      if (bValidTarget)
      {
         /* Add bias. */

         /* Watch out for overflow. */

         ASSERT(dwcbWorkingOffset <= DWORD_MAX - dwcbSeek);

         dwcbWorkingOffset += dwcbSeek;

         ((PICACHEDFILE)hcf)->dwcbCurFilePosition = dwcbWorkingOffset;
         dwcbResult = dwcbWorkingOffset;
      }
      else
         dwcbResult = INVALID_SEEK_POSITION;
   }

#endif   /* NOFCACHE */

   return(dwcbResult);
}


/*
** SetEndOfCachedFile()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  Commits cache.
*/
PUBLIC_CODE BOOL SetEndOfCachedFile(HCACHEDFILE hcf)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   bResult = CommitCache((PICACHEDFILE)hcf);

   if (bResult)
   {
      bResult = (SetFilePointer(((PICACHEDFILE)hcf)->hfile,
                                ((PICACHEDFILE)hcf)->dwcbCurFilePosition, NULL,
                                FILE_BEGIN) ==
                 ((PICACHEDFILE)hcf)->dwcbCurFilePosition);

      if (bResult)
      {
         bResult = SetEndOfFile(((PICACHEDFILE)hcf)->hfile);

         if (bResult)
         {
            ResetCacheToEmpty((PICACHEDFILE)hcf);

            ((PICACHEDFILE)hcf)->dwcbFileLen = ((PICACHEDFILE)hcf)->dwcbCurFilePosition;

#ifdef DEBUG

            {
               DWORD dwcbFileSizeHigh;
               DWORD dwcbFileSizeLow;

               dwcbFileSizeLow = GetFileSize(((PICACHEDFILE)hcf)->hfile, &dwcbFileSizeHigh);

               ASSERT(! dwcbFileSizeHigh);
               ASSERT(((PICACHEDFILE)hcf)->dwcbFileLen == dwcbFileSizeLow);
               ASSERT(((PICACHEDFILE)hcf)->dwcbCurFilePosition == dwcbFileSizeLow);
            }

#endif

         }
      }
   }

   return(bResult);
}


/*
** GetCachedFilePointerPosition()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE DWORD GetCachedFilePointerPosition(HCACHEDFILE hcf)
{
   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   return(((PICACHEDFILE)hcf)->dwcbCurFilePosition);
}


/*
** GetCachedFileSize()
**
** 
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE DWORD GetCachedFileSize(HCACHEDFILE hcf)
{
   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   return(((PICACHEDFILE)hcf)->dwcbFileLen);
}


/*
** ReadFromCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL ReadFromCachedFile(HCACHEDFILE hcf, PVOID hpbyteBuffer, DWORD dwcb,
                               PDWORD pdwcbRead)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));
   ASSERT(! pdwcbRead || IS_VALID_WRITE_PTR(pdwcbRead, DWORD));

   *pdwcbRead = 0;

#ifdef NOFCACHE

   bResult = ReadFile(hcf, hpbyteBuffer, dwcb, pdwcbRead, NULL);

#else

   /*
    * Make sure that the cached file has been set up for read access before
    * allowing a read.
    */

   if (IS_FLAG_SET(((PICACHEDFILE)hcf)->dwOpenMode, GENERIC_READ))
   {
      DWORD dwcbToRead = dwcb;

      /* Read requested data. */

      bResult = TRUE;

      while (dwcbToRead > 0)
      {
         DWORD dwcbRead;

         dwcbRead = ReadFromCache((PICACHEDFILE)hcf, hpbyteBuffer, dwcbToRead);

         /* Watch out for underflow. */

         ASSERT(dwcbRead <= dwcbToRead);

         dwcbToRead -= dwcbRead;

         if (dwcbToRead > 0)
         {
            DWORD dwcbNewData;

            if (FillCache((PICACHEDFILE)hcf, &dwcbNewData))
            {
               hpbyteBuffer = (PBYTE)hpbyteBuffer + dwcbRead;

               if (! dwcbNewData)
                  break;
            }
            else
            {
               bResult = FALSE;
               break;
            }
         }
      }

      /* Watch out for underflow. */

      ASSERT(dwcb >= dwcbToRead);

      if (bResult && pdwcbRead)
         *pdwcbRead = dwcb - dwcbToRead;
   }
   else
      bResult = FALSE;

#endif   /* NOFCACHE */

   ASSERT(! pdwcbRead ||
          ((bResult && *pdwcbRead <= dwcb) ||
           (! bResult && ! *pdwcbRead)));

   return(bResult);
}


/*
** WriteToCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** N.b., callers don't currently check that *pdwcbWritten == dwcb when
** WriteToCachedFile() returns TRUE.
*/
PUBLIC_CODE BOOL WriteToCachedFile(HCACHEDFILE hcf, PCVOID hpbyteBuffer, DWORD dwcb,
                              PDWORD pdwcbWritten)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_READ_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));

   ASSERT(dwcb > 0);

#ifdef NOFCACHE

   bResult = WriteFile(hcf, hpbyteBuffer, dwcb, pdwcbWritten, NULL);

#else

   /*
    * Make sure that the cached file has been set up for write access before
    * allowing a write.
    */

   if (IS_FLAG_SET(((PICACHEDFILE)hcf)->dwOpenMode, GENERIC_WRITE))
   {
      DWORD dwcbToWrite = dwcb;

      /* Write requested data. */

      bResult = TRUE;

      while (dwcbToWrite > 0)
      {
         DWORD dwcbWritten;

         dwcbWritten = WriteToCache((PICACHEDFILE)hcf, hpbyteBuffer, dwcbToWrite);

         /* Watch out for underflow. */

         ASSERT(dwcbWritten <= dwcbToWrite);

         dwcbToWrite -= dwcbWritten;

         if (dwcbToWrite > 0)
         {
            if (CommitCache((PICACHEDFILE)hcf))
            {
               ResetCacheToEmpty((PICACHEDFILE)hcf);

               hpbyteBuffer = (PCBYTE)hpbyteBuffer + dwcbWritten;
            }
            else
            {
               bResult = FALSE;

               break;
            }
         }
      }

      ASSERT(dwcb >= dwcbToWrite);

      if (pdwcbWritten)
      {
         if (bResult)
         {
            ASSERT(! dwcbToWrite);

            *pdwcbWritten = dwcb;
         }
         else
            *pdwcbWritten = 0;
      }
   }
   else
      bResult = FALSE;

#endif   /* NOFCACHE */

   ASSERT(! pdwcbWritten ||
          ((bResult && *pdwcbWritten == dwcb) ||
           (! bResult && ! *pdwcbWritten)));

   return(bResult);
}


/*
** CommitCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CommitCachedFile(HCACHEDFILE hcf)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

#ifdef NOFCACHE

   bResult = TRUE;

#else

   /*
    * Make sure that the cached file has been set up for write access before
    * allowing a commit.
    */

   if (IS_FLAG_SET(((PICACHEDFILE)hcf)->dwOpenMode, GENERIC_WRITE))
      bResult = CommitCache((PICACHEDFILE)hcf);
   else
      bResult = FALSE;

#endif   /* NOFCACHE */

   return(bResult);
}


/*
** GetFileHandle()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE HANDLE GetFileHandle(HCACHEDFILE hcf)
{
   HANDLE hfResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

#ifdef NOFCACHE

   hfResult = hcf;

#else

   hfResult = ((PCICACHEDFILE)hcf)->hfile;

#endif   /* NOFCACHE */

   return(hfResult);
}


/*
** CloseCachedFile()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CloseCachedFile(HCACHEDFILE hcf)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

#ifdef NOFCACHE

   bResult = CloseHandle(hcf);

#else

   {
      BOOL bCommit;
      BOOL bClose;

      bCommit = CommitCache((PICACHEDFILE)hcf);

      bClose = CloseHandle(((PCICACHEDFILE)hcf)->hfile);

      BreakDownCachedFile((PICACHEDFILE)hcf);

      bResult = bCommit && bClose;
   }

#endif   /* NOFCACHE */

   return(bResult);
}


#if defined(DEBUG) || defined(VSTF)

/*
** IsValidHCACHEDFILE()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHCACHEDFILE(HCACHEDFILE hcf)
{
   BOOL bResult;

#ifdef NOFCACHE

   bResult = TRUE;

#else

   bResult = IS_VALID_STRUCT_PTR((PCICACHEDFILE)hcf, CICACHEDFILE);

#endif   /* NOFCACHE */

   return(bResult);
}

#endif   /* DEBUG || VSTF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\file.h ===
/*
 * file.h - File routines module description.
 */


/* Constants
 ************/

/*
 * maximum length of unique name created by MakeUniqueName(), including null
 * terminator
 */

#define MAX_UNIQUE_NAME_LEN            (8 + 1 + 3 + 1)

/* file-related flag combinations */

#define ALL_FILE_ACCESS_FLAGS          (GENERIC_READ |\
                                        GENERIC_WRITE)

#define ALL_FILE_SHARING_FLAGS         (FILE_SHARE_READ |\
                                        FILE_SHARE_WRITE)

#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                        FILE_ATTRIBUTE_HIDDEN |\
                                        FILE_ATTRIBUTE_SYSTEM |\
                                        FILE_ATTRIBUTE_DIRECTORY |\
                                        FILE_ATTRIBUTE_ARCHIVE |\
                                        FILE_ATTRIBUTE_NORMAL |\
                                        FILE_ATTRIBUTE_TEMPORARY)


#define ALL_FILE_FLAGS                 (FILE_FLAG_WRITE_THROUGH |\
                                        FILE_FLAG_OVERLAPPED |\
                                        FILE_FLAG_NO_BUFFERING |\
                                        FILE_FLAG_RANDOM_ACCESS |\
                                        FILE_FLAG_SEQUENTIAL_SCAN |\
                                        FILE_FLAG_DELETE_ON_CLOSE |\
                                        FILE_FLAG_BACKUP_SEMANTICS |\
                                        FILE_FLAG_POSIX_SEMANTICS)

#define ALL_FILE_ATTRIBUTES_AND_FLAGS  (ALL_FILE_ATTRIBUTES |\
                                        ALL_FILE_FLAGS)


/* Macros
 *********/

/* file attribute manipulation */

#define IS_ATTR_DIR(attr)              (IS_FLAG_SET((attr), FILE_ATTRIBUTE_DIRECTORY))
#define IS_ATTR_VOLUME(attr)           (IS_FLAG_SET((attr), FILE_ATTRIBUTE_VOLUME))


/* Prototypes
 *************/

PUBLIC_CODE void BeginComp(void);
PUBLIC_CODE void EndComp(void);
PUBLIC_CODE TWINRESULT CompareFilesByHandle(HANDLE, HANDLE, PBOOL);
PUBLIC_CODE TWINRESULT CompareFilesByName(HPATH, HPATH, PBOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\debug.h ===
/*
 * debug.h - Debug macros and their retail translations.
 */


/* Macros
 *********/

/* debug output macros */

/*
 * Do not call SPEW_OUT directly.  Instead, call TRACE_OUT, WARNING_OUT,
 * ERROR_OUT, or FATAL_OUT.
 */

/*
 * call like printf(), but with an extra pair of parentheses:
 *
 * ERROR_OUT(("'%s' too big by %d bytes.", pszName, nExtra));
 */

#ifdef DEBUG

#define SPEW_OUT(args) \
((void)(GpcszSpewFile = TEXT(__FILE__), GuSpewLine = __LINE__, SpewOut args, 0))

#define PLAIN_TRACE_OUT(args) \
(GdwSpewFlags = 0, GuSpewSev = SPEW_TRACE, SPEW_OUT(args))

#define TRACE_OUT(args) \
(GdwSpewFlags = SPEW_FL_SPEW_PREFIX, GuSpewSev = SPEW_TRACE, SPEW_OUT(args))

#define WARNING_OUT(args) \
(GdwSpewFlags = SPEW_FL_SPEW_PREFIX | SPEW_FL_SPEW_LOCATION, GuSpewSev = SPEW_WARNING, SPEW_OUT(args))

#define ERROR_OUT(args) \
(GdwSpewFlags = SPEW_FL_SPEW_PREFIX | SPEW_FL_SPEW_LOCATION, GuSpewSev = SPEW_ERROR, SPEW_OUT(args))

#define FATAL_OUT(args) \
(GdwSpewFlags = SPEW_FL_SPEW_PREFIX | SPEW_FL_SPEW_LOCATION, GuSpewSev = SPEW_FATAL, SPEW_OUT(args))

#else

#define PLAIN_TRACE_OUT(args)
#define TRACE_OUT(args)
#define WARNING_OUT(args)
#define ERROR_OUT(args)
#define FATAL_OUT(args)

#endif

    /* parameter validation macros */

    /*
     * call as:
     *
     * bPTwinOK = IS_VALID_READ_PTR(ptwin, CTWIN);
     *
     * bHTwinOK = IS_VALID_HANDLE(htwin, TWIN);
     */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
    ((ptr == NULL) ? \
     (ERROR_OUT((TEXT("invalid %s read pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
     TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
    ((ptr == NULL) ? \
     (ERROR_OUT((TEXT("invalid %s write pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
     TRUE)

#define IS_VALID_STRING_PTRA(ptr, type) \
    ((ptr == NULL) ? \
     (ERROR_OUT((TEXT("invalid %s pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
     TRUE)

#define IS_VALID_STRING_PTRW(ptr, type) \
    ((ptr == NULL) ? \
     (ERROR_OUT((TEXT("invalid %s pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
     TRUE)

#ifdef UNICODE
#define IS_VALID_STRING_PTR(ptr, type) IS_VALID_STRING_PTRW(ptr, type)
#else
#define IS_VALID_STRING_PTR(ptr, type) IS_VALID_STRING_PTRA(ptr, type)
#endif

#define IS_VALID_CODE_PTR(ptr, type) \
    ((ptr == NULL) ? \
     (ERROR_OUT((TEXT("invalid %s code pointer - %#08lx"), (LPCTSTR)TEXT(#type), (ptr))), FALSE) : \
     TRUE)

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
    ((ptr == NULL) ? \
     (ERROR_OUT((TEXT("invalid %s read pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
     TRUE)

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
    ((ptr == NULL) ? \
     (ERROR_OUT((TEXT("invalid %s write pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
     TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
    (((dwFlags) & (~(dwAllFlags))) ? \
     (ERROR_OUT((TEXT("invalid flags set - %#08lx"), ((dwFlags) & (~(dwAllFlags))))), FALSE) : \
     TRUE)

#else

#define IS_VALID_READ_PTR(ptr, type) \
(ptr != NULL)

#define IS_VALID_WRITE_PTR(ptr, type) \
(ptr != NULL)

#define IS_VALID_STRING_PTR(ptr, type) \
(ptr != NULL)

#define IS_VALID_CODE_PTR(ptr, type) \
(ptr != NULL)

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
(ptr != NULL)

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
(ptr != NULL)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
(((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#endif

    /* handle validation macros */

#define IS_VALID_HANDLE(hnd, type) \
(IsValidH##type(hnd))

    /* structure validation macros */

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
    (IsValidP##type(ptr) ? \
     TRUE : \
     (ERROR_OUT((TEXT("invalid %s pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
(IsValidP##type(ptr))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
(ptr != NULL)

#endif

    /* debug assertion macro */

    /*
     * ASSERT() may only be used as a statement, not as an expression.
     *
     * call as:
     *
     * ASSERT(pszRest);
     */

#ifdef DEBUG

#define ASSERT(exp) \
    if (exp) \
    ; \
    else \
    ERROR_OUT((TEXT("assertion failed '%s'"), (LPCTSTR)TEXT(#exp)))

#else

#define ASSERT(exp)

#endif

    /* debug evaluation macro */

    /*
     * EVAL() may be used as an expression.
     *
     * call as:
     *
     * if (EVAL(pszFoo))
     *    bResult = TRUE;
     */

#ifdef DEBUG

#define EVAL(exp) \
    ((exp) || (ERROR_OUT((TEXT("evaluation failed '%s'"), (LPCTSTR)TEXT(#exp))), 0))

#else

#define EVAL(exp) \
(exp)

#endif

    /* debug break */

#ifndef DEBUG

#define DebugBreak()

#endif

    /* debug exported function entry */

#ifdef DEBUG

#define DebugEntry(szFunctionName) \
    (TRACE_OUT((TEXT(#szFunctionName) TEXT("() entered."))), StackEnter())

#else

#define DebugEntry(szFunctionName)

#endif

    /* debug exported function exit */

#ifdef DEBUG

#define DebugExitVOID(szFunctionName) \
    (StackLeave(), TRACE_OUT((TEXT("%s() exiting."), TEXT(#szFunctionName))))

#define DebugExit(szFunctionName, szResult) \
    (StackLeave(), TRACE_OUT((TEXT("%s() exiting, returning %s."), TEXT(#szFunctionName), szResult)))

#define DebugExitINT(szFunctionName, n) \
DebugExit(szFunctionName, GetINTString(n))

#define DebugExitULONG(szFunctionName, ul) \
DebugExit(szFunctionName, GetULONGString(ul))

#define DebugExitBOOL(szFunctionName, bool) \
DebugExit(szFunctionName, GetBOOLString(bool))

#define DebugExitHRESULT(szFunctionName, hr) \
DebugExit(szFunctionName, GetHRESULTString(hr))

#define DebugExitCOMPARISONRESULT(szFunctionName, cr) \
DebugExit(szFunctionName, GetCOMPARISONRESULTString(cr))

#define DebugExitTWINRESULT(szFunctionName, tr) \
DebugExit(szFunctionName, GetTWINRESULTString(tr))

#define DebugExitRECRESULT(szFunctionName, rr) \
DebugExit(szFunctionName, GetRECRESULTString(rr))

#else

#define DebugExitVOID(szFunctionName)
#define DebugExit(szFunctionName, szResult)
#define DebugExitINT(szFunctionName, n)
#define DebugExitULONG(szFunctionName, ul)
#define DebugExitBOOL(szFunctionName, bool)
#define DebugExitHRESULT(szFunctionName, hr)
#define DebugExitCOMPARISONRESULT(szFunctionName, cr)
#define DebugExitTWINRESULT(szFunctionName, tr)
#define DebugExitRECRESULT(szFunctionName, rr)

#endif


    /* Types
     ********/

    /* GdwSpewFlags flags */

    typedef enum _spewflags
{
    SPEW_FL_SPEW_PREFIX     = 0x0001,

    SPEW_FL_SPEW_LOCATION   = 0x0002,

    ALL_SPEW_FLAGS          = (SPEW_FL_SPEW_PREFIX |
            SPEW_FL_SPEW_LOCATION)
}
SPEWFLAGS;

/* GuSpewSev values */

typedef enum _spewsev
{
    SPEW_TRACE              = 1,

    SPEW_WARNING            = 2,

    SPEW_ERROR              = 3,

    SPEW_FATAL              = 4
}
SPEWSEV;


/* Prototypes
 *************/

/* debug.c */

#ifdef DEBUG

extern BOOL SetDebugModuleIniSwitches(void);
extern BOOL InitDebugModule(void);
extern void ExitDebugModule(void);
extern void StackEnter(void);
extern void StackLeave(void);
extern ULONG GetStackDepth(void);
extern void __cdecl SpewOut(LPCTSTR pcszFormat, ...);

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* debug.c */

extern DWORD GdwSpewFlags;
extern UINT GuSpewSev;
extern UINT GuSpewLine;
extern LPCTSTR GpcszSpewFile;

/* defined by client */

extern LPCTSTR GpcszSpewModule;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\file.c ===
/*
 * file.c - File routines module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Constants
 ************/

/* size of file comparison buffer in bytes */

#define COMP_BUF_SIZE      (16U * 1024U)


/* Module Variables
 *******************/

/* lock count for file comparison buffer */

PRIVATE_DATA ULONG MulcCompBufLock = 0;

/* buffers for file comparison */

PRIVATE_DATA PBYTE MrgbyteCompBuf1 = NULL;
PRIVATE_DATA PBYTE MrgbyteCompBuf2 = NULL;

/* length of file comparison buffers in bytes */

PRIVATE_DATA UINT MucbCompBufLen = 0;


/****************************** Public Functions *****************************/


/*
 ** BeginComp()
 **
 ** Increments file comparison buffers' lock count.
 **
 ** Arguments:     void
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE void BeginComp(void)
{
    ASSERT((MrgbyteCompBuf1 && MrgbyteCompBuf2 && MucbCompBufLen > 0) ||
            (! MrgbyteCompBuf1 && ! MrgbyteCompBuf2 && ! MucbCompBufLen));

    ASSERT(MulcCompBufLock < ULONG_MAX);
    MulcCompBufLock++;

    return;
}


/*
 ** EndComp()
 **
 ** Decrements file comparison buffers' lock count.
 **
 ** Arguments:     void
 **
 ** Returns:       void
 **
 ** Side Effects:  Frees file comparison buffers if lock count goes to 0.
 */
PUBLIC_CODE void EndComp(void)
{
    ASSERT((MrgbyteCompBuf1 && MrgbyteCompBuf2 && MucbCompBufLen > 0) ||
            (! MrgbyteCompBuf1 && ! MrgbyteCompBuf2 && ! MucbCompBufLen));
    ASSERT(MulcCompBufLock > 0 || (! MrgbyteCompBuf1 && ! MrgbyteCompBuf2 && ! MucbCompBufLen));

    if (EVAL(MulcCompBufLock > 0))
        MulcCompBufLock--;

    /* Are the comparison buffers still locked? */

    if (! MulcCompBufLock && MrgbyteCompBuf1 && MrgbyteCompBuf2)
    {
        /* No.  Free them. */

        FreeMemory(MrgbyteCompBuf1);
        MrgbyteCompBuf1 = NULL;

        FreeMemory(MrgbyteCompBuf2);
        MrgbyteCompBuf2 = NULL;

        TRACE_OUT((TEXT("EndComp(): Two %u byte file comparison buffers freed."),
                    MucbCompBufLen));

        MucbCompBufLen = 0;
    }

    return;
}


/*
 ** CompareFilesByHandle()
 **
 ** Determines whether or not two files are the same.
 **
 ** Arguments:     h1 - DOS file handle to first open file
 **                h2 - DOS file handle to second open file
 **                pbIdentical - pointer to BOOL to be filled in with value
 **                               indicating whether or not the files are
 **                               identical
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  Changes the position of the file pointer of each file.
 */
PUBLIC_CODE TWINRESULT CompareFilesByHandle(HANDLE h1, HANDLE h2,
        PBOOL pbIdentical)
{
    TWINRESULT tr;

    ASSERT(IS_VALID_HANDLE(h1, FILE));
    ASSERT(IS_VALID_HANDLE(h2, FILE));
    ASSERT(IS_VALID_WRITE_PTR(pbIdentical, BOOL));

    ASSERT((MrgbyteCompBuf1 && MrgbyteCompBuf2 && MucbCompBufLen > 0) ||
            (! MrgbyteCompBuf1 && ! MrgbyteCompBuf2 && ! MucbCompBufLen));
    ASSERT(MulcCompBufLock || (! MrgbyteCompBuf1 && ! MrgbyteCompBuf2 && ! MucbCompBufLen));

    /* Have the comparison buffers already been allocated? */

    if (MrgbyteCompBuf1)
        tr = TR_SUCCESS;
    else
    {
        /* No.  Allocate them. */

        tr = TR_OUT_OF_MEMORY;

        if (AllocateMemory(COMP_BUF_SIZE, &MrgbyteCompBuf1))
        {
            if (AllocateMemory(COMP_BUF_SIZE, &MrgbyteCompBuf2))
            {
                /* Success! */

                MucbCompBufLen = COMP_BUF_SIZE;
                tr = TR_SUCCESS;

                TRACE_OUT((TEXT("CompareFilesByHandle(): Two %u byte file comparison buffers allocated."),
                            MucbCompBufLen));
            }
            else
            {
                FreeMemory(MrgbyteCompBuf1);
                MrgbyteCompBuf1 = NULL;
            }
        }
    }

    if (tr == TR_SUCCESS)
    {
        DWORD dwcbLen1;

        BeginComp();

        /* Get file lengths to compare. */

        tr = TR_SRC_READ_FAILED;

        dwcbLen1 = SetFilePointer(h1, 0, NULL, FILE_END);

        if (dwcbLen1 != INVALID_SEEK_POSITION)
        {
            DWORD dwcbLen2;

            dwcbLen2 = SetFilePointer(h2, 0, NULL, FILE_END);

            if (dwcbLen2 != INVALID_SEEK_POSITION)
            {
                /* Are the files the same length? */

                if (dwcbLen1 == dwcbLen2)
                {
                    /* Yes.  Move to the beginning of the files. */

                    if (SetFilePointer(h1, 0, NULL, FILE_BEGIN) != INVALID_SEEK_POSITION)
                    {
                        if (SetFilePointer(h2, 0, NULL, FILE_BEGIN) != INVALID_SEEK_POSITION)
                        {
                            tr = TR_SUCCESS;

                            do
                            {
                                DWORD dwcbRead1;

                                if (ReadFile(h1, MrgbyteCompBuf1, MucbCompBufLen, &dwcbRead1, NULL))
                                {
                                    DWORD dwcbRead2;

                                    if (ReadFile(h2, MrgbyteCompBuf2, MucbCompBufLen, &dwcbRead2, NULL))
                                    {
                                        if (dwcbRead1 == dwcbRead2)
                                        {
                                            /* At EOF? */

                                            if (! dwcbRead1)
                                            {
                                                /* Yes. */

                                                *pbIdentical = TRUE;
                                                break;
                                            }
                                            else if (MyMemComp(MrgbyteCompBuf1, MrgbyteCompBuf2, dwcbRead1) != CR_EQUAL)
                                            {
                                                /* Yes. */

                                                *pbIdentical = FALSE;
                                                break;
                                            }
                                        }
                                        else
                                            tr = TR_SRC_READ_FAILED;
                                    }
                                    else
                                        tr = TR_SRC_READ_FAILED;
                                }
                                else
                                    tr = TR_SRC_READ_FAILED;
                            } while (tr == TR_SUCCESS);
                        }
                    }
                }
                else
                {
                    /* No.  Files different lengths. */

                    *pbIdentical = FALSE;

                    tr = TR_SUCCESS;
                }
            }
        }

        EndComp();
    }

    return(tr);
}


/*
 ** CompareFilesByName()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:       TWINRESULT
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT CompareFilesByName(HPATH hpath1, HPATH hpath2,
        PBOOL pbIdentical)
{
    TWINRESULT tr;

    ASSERT(IS_VALID_HANDLE(hpath1, PATH));
    ASSERT(IS_VALID_HANDLE(hpath2, PATH));
    ASSERT(IS_VALID_WRITE_PTR(pbIdentical, BOOL));

    /* Only verify source and destination volumes once up front. */

    if (IsPathVolumeAvailable(hpath1) &&
            IsPathVolumeAvailable(hpath2))
    {
        HANDLE h1;
        TCHAR rgchFile1[MAX_PATH_LEN];

        /* Try to open files.  Assume sequential reads. */

        GetPathString(hpath1, 0, rgchFile1, ARRAYSIZE(rgchFile1));

        h1 = CreateFile(rgchFile1, GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        if (h1 != INVALID_HANDLE_VALUE)
        {
            HANDLE h2;
            TCHAR rgchFile2[MAX_PATH_LEN];

            GetPathString(hpath2, 0, rgchFile2, ARRAYSIZE(rgchFile2));

            h2 = CreateFile(rgchFile2, GENERIC_READ, FILE_SHARE_READ, NULL,
                    OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

            if (h2 != INVALID_HANDLE_VALUE)
            {
                TRACE_OUT((TEXT("CompareFilesByHandle(): Comparing files %s and %s."),
                            DebugGetPathString(hpath1),
                            DebugGetPathString(hpath2)));

                tr = CompareFilesByHandle(h1, h2, pbIdentical);

#ifdef DEBUG

                if (tr == TR_SUCCESS)
                {
                    if (*pbIdentical)
                        TRACE_OUT((TEXT("CompareFilesByHandle(): %s and %s are identical."),
                                    DebugGetPathString(hpath1),
                                    DebugGetPathString(hpath2)));
                    else
                        TRACE_OUT((TEXT("CompareFilesByHandle(): %s and %s are different."),
                                    DebugGetPathString(hpath1),
                                    DebugGetPathString(hpath2)));
                }

#endif

                /*
                 * Failing to close the file properly is not a failure condition here.
                 */

                CloseHandle(h2);
            }
            else
                tr = TR_DEST_OPEN_FAILED;

            /*
             * Failing to close the file properly is not a failure condition here.
             */

            CloseHandle(h1);
        }
        else
            tr = TR_SRC_OPEN_FAILED;
    }
    else
        tr = TR_UNAVAILABLE_VOLUME;

    return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\findbc.c ===
/*
 * findbc.c - Briefcase enumeration module.
 */

/*



 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "findbc.h"


/* Macros
 *********/

/* macro for translating an LRESULT to a TWINRESULT */

#define LRESULTToTWINRESULT(lr, TR)    case lr: tr = TR; break


/* Constants
 ************/

/* briefcase registry keys */

#define HKEY_BRIEFCASE_ROOT         HKEY_CURRENT_USER
#ifdef DEBUG
#define HKEY_BRIEFCASE_ROOT_STRING  TEXT("HKEY_CURRENT_USER")
#endif

#define BRIEFCASE_SUBKEY            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Briefcase\\Briefcases")

/* maximum briefcase value name length, including null terminator */

#define MAX_VALUE_NAME_LEN          (8 + 1)


/* Types
 ********/

/* EnumBriefcases() callback function */

typedef LONG (*ENUMBRIEFCASESPROC)(PCLINKINFO, PCVOID, PBOOL);

/* briefcase iterator */

typedef struct _brfcaseiter
{
    HPTRARRAY hpa;

    ARRAYINDEX aiNext;
}
BRFCASEITER;
DECLARE_STANDARD_TYPES(BRFCASEITER);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT LinkInfoSortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT LinkInfoSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE TWINRESULT TranslateLRESULTToTWINRESULT(LONG);
PRIVATE_CODE LONG AllocateValueDataBuffer(HKEY, PVOID *, PDWORD);
PRIVATE_CODE LONG EnumBriefcases(HKEY, ENUMBRIEFCASESPROC, PCVOID, LPTSTR, PBOOL);
PRIVATE_CODE LONG GetUnusedBriefcaseValueName(HKEY, LPTSTR, int);
PRIVATE_CODE TWINRESULT CreateBriefcaseIterator(PBRFCASEITER *);
PRIVATE_CODE TWINRESULT GetNextBriefcaseIterator(PBRFCASEITER, PBRFCASEINFO);
PRIVATE_CODE void DestroyBriefcaseIterator(PBRFCASEITER);
PRIVATE_CODE LONG AddBriefcaseToIteratorProc(PCLINKINFO, PCVOID, PBOOL);
PRIVATE_CODE LONG CompareLinkInfoProc(PCLINKINFO, PCVOID, PBOOL);
PRIVATE_CODE TWINRESULT MyAddBriefcaseToSystem(PCLINKINFO);
PRIVATE_CODE TWINRESULT MyRemoveBriefcaseFromSystem(PCLINKINFO);
PRIVATE_CODE TWINRESULT UpdateBriefcaseLinkInfo(PCLINKINFO, PCLINKINFO);

#if defined(DEBUG) || defined(VSTF)

PRIVATE_CODE BOOL IsValidPCBRFCASEITER(PCBRFCASEITER);

#endif

#ifdef EXPV

PRIVATE_CODE BOOL IsValidHBRFCASEITER(HBRFCASEITER);

#endif


/*
 ** LinkInfoSortCmp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** LinkInfo structures are sorted by:
 **    1) LinkInfo referent
 **    2) pointer
 */
PRIVATE_CODE COMPARISONRESULT LinkInfoSortCmp(PCVOID pcli1, PCVOID pcli2)
{
    COMPARISONRESULT cr;

    ASSERT(IS_VALID_STRUCT_PTR(pcli1, CLINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pcli2, CLINKINFO));

    cr = CompareLinkInfoReferents((PCLINKINFO)pcli1, (PCLINKINFO)pcli2);

    if (cr == CR_EQUAL)
        cr = ComparePointers(pcli1, pcli2);

    return(cr);
}


/*
 ** LinkInfoSearchCmp()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 **
 ** LinkInfo structures are searched by:
 **    1) LinkInfo referent
 */
PRIVATE_CODE COMPARISONRESULT LinkInfoSearchCmp(PCVOID pcliTarget,
        PCVOID pcliCurrent)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcliTarget, CLINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pcliCurrent, CLINKINFO));

    return(CompareLinkInfoReferents(pcliTarget, pcliCurrent));
}


/*
 ** TranslateLRESULTToTWINRESULT()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT TranslateLRESULTToTWINRESULT(LONG lResult)
{
    TWINRESULT tr;

    switch (lResult)
    {
        LRESULTToTWINRESULT(ERROR_SUCCESS, TR_SUCCESS);

        default:
        tr = TR_OUT_OF_MEMORY;
        if (lResult != ERROR_OUTOFMEMORY)
            WARNING_OUT((TEXT("TranslateLRESULTToTWINRESULT(): Translating unlisted LRESULT %ld to TWINRESULT %s."),
                        lResult,
                        GetTWINRESULTString(tr)));
        break;
    }

    return(tr);
}


/*
 ** AllocateValueDataBuffer()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
LONG PRIVATE_CODE AllocateValueDataBuffer(HKEY hkey, PVOID *ppvData,
        PDWORD pdwcbLen)
{
    LONG lResult;

    ASSERT(IS_VALID_HANDLE(hkey, KEY));
    ASSERT(IS_VALID_WRITE_PTR(ppvData, PVOID));
    ASSERT(IS_VALID_WRITE_PTR(pdwcbLen, DWORD));

    lResult = RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
            NULL, pdwcbLen, NULL, NULL);

    if (lResult == ERROR_SUCCESS)
    {
        if (! AllocateMemory(*pdwcbLen, ppvData))
            lResult = ERROR_OUTOFMEMORY;
    }

    ASSERT(lResult != ERROR_SUCCESS ||
            IS_VALID_WRITE_BUFFER_PTR(*ppvData, VOID, *pdwcbLen));

    return(lResult);
}


/*
 ** EnumBriefcases()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE LONG EnumBriefcases(HKEY hkeyBriefcases, ENUMBRIEFCASESPROC ebcp,
        PCVOID pcvRefData, LPTSTR pszValueNameBuf,
        PBOOL pbAbort)
{
    LONG lResult;
    DWORD dwcbMaxValueDataLen;
    PLINKINFO pli;

    /* pcvRefData may be any value. */

    ASSERT(IS_VALID_HANDLE(hkeyBriefcases, KEY));
    ASSERT(IS_VALID_CODE_PTR(ebcp, ENUMBRIEFCASESPROC));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszValueNameBuf, STR, MAX_VALUE_NAME_LEN));
    ASSERT(IS_VALID_WRITE_PTR(pbAbort, BOOL));

    /* Allocate a buffer to hold the largest value's data. */

    lResult = AllocateValueDataBuffer(hkeyBriefcases, &pli,
            &dwcbMaxValueDataLen);

    if (lResult == ERROR_SUCCESS)
    {
        DWORD dwiValue;

        /* Look through the briefcases looking for matching LinkInfo. */

        *pbAbort = FALSE;
        dwiValue = 0;

        do
        {
            DWORD dwcbValueNameLen;
            DWORD dwType;
            DWORD dwcbDataLen;

            dwcbValueNameLen = MAX_VALUE_NAME_LEN;
            dwcbDataLen = dwcbMaxValueDataLen;
            lResult = RegEnumValue(hkeyBriefcases, dwiValue, pszValueNameBuf,
                    &dwcbValueNameLen, NULL, &dwType, (PBYTE)pli,
                    &dwcbDataLen);

            switch (lResult)
            {
                case ERROR_SUCCESS:
                    if (dwcbDataLen >= sizeof(pli->ucbSize) &&
                            pli->ucbSize == dwcbDataLen)
                        lResult = (*ebcp)(pli, pcvRefData, pbAbort);
                    else
                        WARNING_OUT((TEXT("EnumBriefcases(): Value %s under %s\\%s is not a valid LinkInfo structure."),
                                    pszValueNameBuf,
                                    HKEY_BRIEFCASE_ROOT_STRING,
                                    BRIEFCASE_SUBKEY));
                    break;

                case ERROR_MORE_DATA:
                    /*
                     * Watch out for value names that are too long, and added
                     * data values that are too long.
                     */

                    /* (+ 1) for null terminator. */

                    if (dwcbValueNameLen >= MAX_VALUE_NAME_LEN)
                        WARNING_OUT((TEXT("EnumBriefcases(): Value %s under %s\\%s is too long.  %u bytes > %u bytes."),
                                    pszValueNameBuf,
                                    HKEY_BRIEFCASE_ROOT_STRING,
                                    BRIEFCASE_SUBKEY,
                                    dwcbValueNameLen + 1,
                                    MAX_VALUE_NAME_LEN));
                    if (dwcbDataLen > dwcbMaxValueDataLen)
                        WARNING_OUT((TEXT("EnumBriefcases(): Value %s's data under %s\\%s is too long.  %u bytes > %u bytes."),
                                    pszValueNameBuf,
                                    HKEY_BRIEFCASE_ROOT_STRING,
                                    BRIEFCASE_SUBKEY,
                                    dwcbDataLen,
                                    dwcbMaxValueDataLen));

                    /* Skip this value. */

                    lResult = ERROR_SUCCESS;
                    break;

                default:
                    break;
            }
        } while (lResult == ERROR_SUCCESS &&
                ! *pbAbort &&
                dwiValue++ < DWORD_MAX);

        if (lResult == ERROR_NO_MORE_ITEMS)
            lResult = ERROR_SUCCESS;

        FreeMemory(pli);
    }

    return(lResult);
}


/*
 ** GetUnusedBriefcaseValueName()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE LONG GetUnusedBriefcaseValueName(HKEY hkeyBriefcases,
        LPTSTR pszValueNameBuf,
        int cchMax)
{
    LONG lResult;
    DWORD dwValueNumber;
    BOOL bFound;

    ASSERT(IS_VALID_HANDLE(hkeyBriefcases, KEY));
    ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszValueNameBuf, STR, MAX_VALUE_NAME_LEN));

    dwValueNumber = 0;
    bFound = FALSE;

    do
    {
        wnsprintf(pszValueNameBuf, cchMax, TEXT("%lu"), dwValueNumber);
        ASSERT((DWORD)lstrlen(pszValueNameBuf) < MAX_VALUE_NAME_LEN);

        lResult = RegQueryValueEx(hkeyBriefcases, pszValueNameBuf, NULL, NULL,
                NULL, NULL);

        switch (lResult)
        {
            case ERROR_SUCCESS:
                /* Used value name.  Continue searching. */
                TRACE_OUT((TEXT("GetUnusedBriefcaseValueName(): Found used briefcase value name %s."),
                            pszValueNameBuf));
                break;

            case ERROR_FILE_NOT_FOUND:
                /* Unused value name.  Stop searching. */
                lResult = ERROR_SUCCESS;
                bFound = TRUE;
                TRACE_OUT((TEXT("GetUnusedBriefcaseValueName(): Found unused briefcase value name %s."),
                            pszValueNameBuf));
                break;

            default:
                WARNING_OUT((TEXT("GetUnusedBriefcaseValueName(): RegQueryValueEx() failed, returning %ld."),
                            lResult));
                break;
        }
    } while (lResult == ERROR_SUCCESS &&
            ! bFound &&
            dwValueNumber++ < DWORD_MAX);

    if (dwValueNumber == DWORD_MAX)
    {
        ASSERT(lResult == ERROR_SUCCESS &&
                ! bFound);
        WARNING_OUT((TEXT("GetUnusedBriefcaseValueName(): All value names in use.")));

        lResult = ERROR_CANTWRITE;
    }

    return(lResult);
}


/*
 ** CreateBriefcaseIterator()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT CreateBriefcaseIterator(PBRFCASEITER *ppbciter)
{
    TWINRESULT tr;
    LONG lResult;
    HKEY hkeyBriefcases;

    ASSERT(IS_VALID_WRITE_PTR(ppbciter, PBRFCASEITER));

    lResult = RegOpenKeyEx(HKEY_BRIEFCASE_ROOT, BRIEFCASE_SUBKEY, 0,
            (KEY_QUERY_VALUE | KEY_SET_VALUE), &hkeyBriefcases);

    if (lResult == ERROR_SUCCESS)
    {
        DWORD dwcBriefcases;

        lResult = RegQueryInfoKey(hkeyBriefcases, NULL, NULL, NULL, NULL, NULL,
                NULL, NULL, &dwcBriefcases, NULL, NULL, NULL);

        if (lResult == ERROR_SUCCESS)
        {
            if (dwcBriefcases > 0)
            {
                tr = TR_OUT_OF_MEMORY;

                if (AllocateMemory(sizeof(**ppbciter), ppbciter))
                {
                    NEWPTRARRAY npa;

                    npa.aicInitialPtrs = dwcBriefcases;
                    npa.aicAllocGranularity = 1;
                    npa.dwFlags = NPA_FL_SORTED_ADD;

                    if (CreatePtrArray(&npa, &((*ppbciter)->hpa)))
                    {
                        TCHAR rgchValueName[MAX_VALUE_NAME_LEN];
                        BOOL bAbort;

                        (*ppbciter)->aiNext = 0;

                        tr = TranslateLRESULTToTWINRESULT(
                                EnumBriefcases(hkeyBriefcases,
                                    &AddBriefcaseToIteratorProc,
                                    *ppbciter, rgchValueName, &bAbort));

                        if (tr == TR_SUCCESS)
                        {
                            ASSERT(! bAbort);
                        }
                        else
                        {
                            DestroyPtrArray((*ppbciter)->hpa);
CREATEBRIEFCASEITERATOR_BAIL:
                            FreeMemory(*ppbciter);
                        }
                    }
                    else
                    {
                        goto CREATEBRIEFCASEITERATOR_BAIL;
                    }
                }
            }
            else
            {
                tr = TR_NO_MORE;
            }
        }
        else
        {
            tr = TranslateLRESULTToTWINRESULT(lResult);
        }
        
        RegCloseKey(hkeyBriefcases);
    }
    else
    {
        /* ERROR_FILE_NOT_FOUND is returned for a non-existent key. */

        if (lResult == ERROR_FILE_NOT_FOUND)
        {
            tr = TR_NO_MORE;
        }
        else
        {
            /* RAIDRAID: (16279) We should map to other TWINRESULTs here. */
            tr = TR_OUT_OF_MEMORY;
        }
    }

    ASSERT(tr != TR_SUCCESS ||
            IS_VALID_STRUCT_PTR(*ppbciter, CBRFCASEITER));

    return(tr);
}


/*
 ** GetNextBriefcaseIterator()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT GetNextBriefcaseIterator(PBRFCASEITER pbciter,
        PBRFCASEINFO pbcinfo)
{
    TWINRESULT tr = TR_NO_MORE;
    ARRAYINDEX aicBriefcases;

    ASSERT(IS_VALID_STRUCT_PTR(pbciter, CBRFCASEITER));
    ASSERT(IS_VALID_WRITE_PTR(pbcinfo, BRFCASEINFO));
    ASSERT(pbcinfo->ulSize == sizeof(*pbcinfo));

    aicBriefcases = GetPtrCount(pbciter->hpa);

    while (pbciter->aiNext < aicBriefcases)
    {
        PCLINKINFO pcli;
        DWORD dwOutFlags;
        PLINKINFO pliUpdated;
        BOOL bRemoveBriefcase = FALSE;

        pcli = GetPtr(pbciter->hpa, pbciter->aiNext);

        if (ResolveLinkInfo(pcli, pbcinfo->rgchDatabasePath, 
                    (RLI_IFL_UPDATE | RLI_IFL_LOCAL_SEARCH), NULL, &dwOutFlags, 
                    &pliUpdated))
        {
            if (PathExists(pbcinfo->rgchDatabasePath))
            {
                /* Found an existing briefcase database. */

                if (IS_FLAG_SET(dwOutFlags, RLI_OFL_UPDATED))
                {
                    if (UpdateBriefcaseLinkInfo(pcli, pliUpdated))
                        TRACE_OUT((TEXT("GetNextBriefcaseIterator(): Updated LinkInfo for briefcase database %s."),
                                    pbcinfo->rgchDatabasePath));
                    else
                        WARNING_OUT((TEXT("GetNextBriefcaseIterator(): Failed to update LinkInfo for briefcase database %s."),
                                    pbcinfo->rgchDatabasePath));
                }

                tr = TR_SUCCESS;
            }
            else
                bRemoveBriefcase = TRUE;

            if (IS_FLAG_SET(dwOutFlags, RLI_OFL_UPDATED))
                DestroyLinkInfo(pliUpdated);
        }
        else
        {
            /*
             * GetLastError() here to differentiate an out of memory condition and
             * all other errors.  Remove the briefcase from the system for all
             * errors except out of memory, e.g., unavailable volume or invalid
             * parameter.
             */

            if (GetLastError() != ERROR_OUTOFMEMORY)
                bRemoveBriefcase = TRUE;
        }

        if (bRemoveBriefcase)
        {
            if (MyRemoveBriefcaseFromSystem(pcli) == TR_SUCCESS)
                TRACE_OUT((TEXT("GetNextBriefcaseIterator(): Unavailable/missing briefcase removed from system.")));
            else
                WARNING_OUT((TEXT("GetNextBriefcaseIterator(): Failed to remove unavailable/missing briefcase from system.")));
        }

        ASSERT(pbciter->aiNext < ARRAYINDEX_MAX);
        pbciter->aiNext++;

        if (tr == TR_SUCCESS)
            break;
    }

    return(tr);
}


/*
 ** DestroyBriefcaseIterator()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE void DestroyBriefcaseIterator(PBRFCASEITER pbciter)
{
    ARRAYINDEX ai;
    ARRAYINDEX aicPtrs;

    ASSERT(IS_VALID_STRUCT_PTR(pbciter, CBRFCASEITER));

    aicPtrs = GetPtrCount(pbciter->hpa);

    for (ai = 0; ai < aicPtrs; ai++)
        FreeMemory(GetPtr(pbciter->hpa, ai));

    DestroyPtrArray(pbciter->hpa);
    FreeMemory(pbciter);

    return;
}


/*
 ** AddBriefcaseToIteratorProc()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE LONG AddBriefcaseToIteratorProc(PCLINKINFO pcli, PCVOID pcbciter,
        PBOOL pbAbort)
{
    LONG lResult;
    PLINKINFO pliCopy;

    ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pcbciter, CBRFCASEITER));
    ASSERT(IS_VALID_WRITE_PTR(pbAbort, BOOL));

    /* Add this briefcase database's LinkInfo to the iterator's list. */

    *pbAbort = TRUE;
    lResult = ERROR_OUTOFMEMORY;

    if (CopyLinkInfo(pcli, &pliCopy))
    {
        ARRAYINDEX ai;

        if (AddPtr(((PCBRFCASEITER)pcbciter)->hpa, LinkInfoSortCmp, pliCopy, &ai))
        {
            *pbAbort = FALSE;
            lResult = ERROR_SUCCESS;
        }
        else
            FreeMemory(pliCopy);
    }

    if (lResult == ERROR_SUCCESS)
        TRACE_OUT((TEXT("AddBriefcaseToIteratorProc(): Added LinkInfo for briefcase to briefcase iterator %#lx."),
                    pcbciter));
    else
        WARNING_OUT((TEXT("AddBriefcaseToIteratorProc(): Failed to add LinkInfo for briefcase to briefcase iterator %#lx."),
                    pcbciter));

    return(lResult);
}


/*
 ** CompareLinkInfoProc()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE LONG CompareLinkInfoProc(PCLINKINFO pcli, PCVOID pcliTarget,
        PBOOL pbAbort)
{
    ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pcliTarget, CLINKINFO));
    ASSERT(IS_VALID_WRITE_PTR(pbAbort, BOOL));

    /* Does this LinkInfo match our target LinkInfo? */

    *pbAbort = (LinkInfoSearchCmp(pcli, pcliTarget) == CR_EQUAL);

    return(ERROR_SUCCESS);
}


/*
 ** MyAddBriefcaseToSystem()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT MyAddBriefcaseToSystem(PCLINKINFO pcli)
{
    LONG lResult;
    HKEY hkeyBriefcases;
    DWORD dwDisposition;

    ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));

    /* Open briefcase list registry key for common access. */

    lResult = RegCreateKeyEx(HKEY_BRIEFCASE_ROOT, BRIEFCASE_SUBKEY, 0, NULL,
            REG_OPTION_NON_VOLATILE,
            (KEY_QUERY_VALUE | KEY_SET_VALUE), NULL,
            &hkeyBriefcases, &dwDisposition);

    if (lResult == ERROR_SUCCESS)
    {
        TCHAR rgchValueName[MAX_VALUE_NAME_LEN];
        BOOL bFound;
        LONG lClose;

        lResult = EnumBriefcases(hkeyBriefcases, &CompareLinkInfoProc, pcli,
                rgchValueName, &bFound);

        if (lResult == ERROR_SUCCESS)
        {
            if (bFound)
                TRACE_OUT((TEXT("AddBriefcaseToSystem(): Briefcase database already in registry list as value %s under %s\\%s."),
                            rgchValueName,
                            HKEY_BRIEFCASE_ROOT_STRING,
                            BRIEFCASE_SUBKEY));
            else
            {
                lResult = GetUnusedBriefcaseValueName(hkeyBriefcases,
                        rgchValueName, 
                        ARRAYSIZE(rgchValueName));

                if (lResult == ERROR_SUCCESS)
                {
                    lResult = RegSetValueEx(hkeyBriefcases, rgchValueName, 0,
                            REG_BINARY, (PCBYTE)pcli,
                            pcli->ucbSize);

                    if (lResult == ERROR_SUCCESS)
                        TRACE_OUT((TEXT("AddBriefcaseToSystem(): Briefcase database added to registry list as value %s under %s\\%s."),
                                    rgchValueName,
                                    HKEY_BRIEFCASE_ROOT_STRING,
                                    BRIEFCASE_SUBKEY));
                }
            }
        }

        lClose = RegCloseKey(hkeyBriefcases);

        if (lResult == ERROR_SUCCESS)
            lResult = lClose;
    }

    return(TranslateLRESULTToTWINRESULT(lResult));
}


/*
 ** MyRemoveBriefcaseFromSystem()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT MyRemoveBriefcaseFromSystem(PCLINKINFO pcli)
{
    LONG lResult;
    HKEY hkeyBriefcases;

    ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));

    /* Open briefcase list registry key for common access. */

    lResult = RegOpenKeyEx(HKEY_BRIEFCASE_ROOT, BRIEFCASE_SUBKEY, 0,
            (KEY_QUERY_VALUE | KEY_SET_VALUE), &hkeyBriefcases);

    if (lResult == ERROR_SUCCESS)
    {
        TCHAR rgchValueName[MAX_VALUE_NAME_LEN];
        BOOL bFound;
        LONG lClose;

        lResult = EnumBriefcases(hkeyBriefcases, &CompareLinkInfoProc, pcli,
                rgchValueName, &bFound);

        if (lResult == ERROR_SUCCESS)
        {
            if (bFound)
            {
                lResult = RegDeleteValue(hkeyBriefcases, rgchValueName);

                if (lResult == ERROR_SUCCESS)
                    TRACE_OUT((TEXT("MyRemoveBriefcaseFromSystem(): Briefcase database removed from registry list as value %s under %s\\%s."),
                                rgchValueName,
                                HKEY_BRIEFCASE_ROOT_STRING,
                                BRIEFCASE_SUBKEY));
            }
            else
                WARNING_OUT((TEXT("MyRemoveBriefcaseFromSystem(): Briefcase database not in registry list under %s\\%s."),
                            HKEY_BRIEFCASE_ROOT_STRING,
                            BRIEFCASE_SUBKEY));
        }

        lClose = RegCloseKey(hkeyBriefcases);

        if (lResult == ERROR_SUCCESS)
            lResult = lClose;
    }
    else if (lResult == ERROR_FILE_NOT_FOUND)
    {
        WARNING_OUT((TEXT("MyRemoveBriefcaseFromSystem(): Briefcase key %s\\%s does not exist."),
                    HKEY_BRIEFCASE_ROOT_STRING,
                    BRIEFCASE_SUBKEY));

        lResult = ERROR_SUCCESS;
    }

    return(TranslateLRESULTToTWINRESULT(lResult));
}


/*
 ** UpdateBriefcaseLinkInfo()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE TWINRESULT UpdateBriefcaseLinkInfo(PCLINKINFO pcliOriginal,
        PCLINKINFO pcliUpdated)
{
    LONG lResult;
    HKEY hkeyBriefcases;
    DWORD dwDisposition;

    ASSERT(IS_VALID_STRUCT_PTR(pcliOriginal, CLINKINFO));
    ASSERT(IS_VALID_STRUCT_PTR(pcliUpdated, CLINKINFO));

    /* Open briefcase list registry key for common access. */

    lResult = RegCreateKeyEx(HKEY_BRIEFCASE_ROOT, BRIEFCASE_SUBKEY, 0, NULL,
            REG_OPTION_NON_VOLATILE,
            (KEY_QUERY_VALUE | KEY_SET_VALUE), NULL,
            &hkeyBriefcases, &dwDisposition);

    if (lResult == ERROR_SUCCESS)
    {
        TCHAR rgchValueName[MAX_VALUE_NAME_LEN];
        BOOL bFound;
        LONG lClose;

        lResult = EnumBriefcases(hkeyBriefcases, &CompareLinkInfoProc,
                pcliOriginal, rgchValueName, &bFound);

        if (lResult == ERROR_SUCCESS)
        {
            if (bFound)
            {
                lResult = RegSetValueEx(hkeyBriefcases, rgchValueName, 0,
                        REG_BINARY, (PCBYTE)pcliUpdated,
                        pcliUpdated->ucbSize);

                if (lResult == ERROR_SUCCESS)
                    TRACE_OUT((TEXT("UpdateBriefcaseLinkInfo(): Briefcase database LinkInfo updated in registry list as value %s under %s\\%s."),
                                rgchValueName,
                                HKEY_BRIEFCASE_ROOT_STRING,
                                BRIEFCASE_SUBKEY));
            }
            else
                WARNING_OUT((TEXT("UpdateBriefcaseLinkInfo(): Briefcase database LinkInfo not found in registry list under %s\\%s."),
                            HKEY_BRIEFCASE_ROOT_STRING,
                            BRIEFCASE_SUBKEY));
        }

        lClose = RegCloseKey(hkeyBriefcases);

        if (lResult == ERROR_SUCCESS)
            lResult = lClose;
    }

    return(TranslateLRESULTToTWINRESULT(lResult));
}


#if defined(DEBUG) || defined(VSTF)

/*
 ** IsValidPCBRFCASEITER()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidPCBRFCASEITER(PCBRFCASEITER pcbciter)
{
    BOOL bResult = FALSE;

    if (IS_VALID_READ_PTR(pcbciter, CBRFCASEITER) &&
            IS_VALID_HANDLE(pcbciter->hpa, PTRARRAY))
    {
        ARRAYINDEX aicPtrs;
        ARRAYINDEX ai;

        aicPtrs = GetPtrCount(pcbciter->hpa);

        for (ai = 0; ai < aicPtrs; ai++)
        {
            if (! IS_VALID_STRUCT_PTR(GetPtr(pcbciter->hpa, ai), CLINKINFO))
                break;
        }

        bResult = (ai == aicPtrs);
    }

    return(bResult);
}

#endif


#ifdef EXPV

/*
 ** IsValidHBRFCASEITER()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL IsValidHBRFCASEITER(HBRFCASEITER hbciter)
{
    return(IS_VALID_STRUCT_PTR((PCBRFCASEITER)hbciter, CBRFCASEITER));
}

#endif


/****************************** Public Functions *****************************/


/*
 ** AddBriefcaseToSystem()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT AddBriefcaseToSystem(LPCTSTR pcszBriefcaseDatabase)
{
    TWINRESULT tr;
    PLINKINFO pli;

    ASSERT(IsFullPath(pcszBriefcaseDatabase));

    if (CreateLinkInfo(pcszBriefcaseDatabase, &pli))
    {
        tr = MyAddBriefcaseToSystem(pli);

        DestroyLinkInfo(pli);
    }
    else
    {
        /*
         * GetLastError() here to differentiate between TR_UNAVAILABLE_VOLUME and
         * TR_OUT_OF_MEMORY.
         */

        if (GetLastError() == ERROR_OUTOFMEMORY)
            tr = TR_OUT_OF_MEMORY;
        else
            tr = TR_UNAVAILABLE_VOLUME;
    }

    return(tr);
}


/*
 ** RemoveBriefcaseFromSystem()
 **
 **
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PUBLIC_CODE TWINRESULT RemoveBriefcaseFromSystem(LPCTSTR pcszBriefcaseDatabase)
{
    TWINRESULT tr;
    PLINKINFO pli;

    ASSERT(IsFullPath(pcszBriefcaseDatabase));

    if (CreateLinkInfo(pcszBriefcaseDatabase, &pli))
    {
        tr = MyRemoveBriefcaseFromSystem(pli);

        DestroyLinkInfo(pli);
    }
    else
    {
        /*
         * GetLastError() here to differentiate between TR_UNAVAILABLE_VOLUME and
         * TR_OUT_OF_MEMORY.
         */

        if (GetLastError() == ERROR_OUTOFMEMORY)
            tr = TR_OUT_OF_MEMORY;
        else
            tr = TR_UNAVAILABLE_VOLUME;
    }

    return(tr);
}


/***************************** Exported Functions ****************************/


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | FindFirstBriefcase | Finds the first briefcase in the current
  user's list of briefcases.

  @parm PHBRFCASEITER | phbciter | A pointer to an HBRFCASEITER to be filled in
  with a handle identifying the briefcase enumeration data associated with this
  call to FindFirstBriefcase().  This handle may be passed to FindNextBriefcase()
  amd FindCloseBriefcase().  This handle is only valid until FindBriefcaseClose()
  is called on it.

  @parm PBRFCASEINFO | pbcinfo | A pointer to a BRFCASEINFO to be filled in with
  information describing the first enumerated briefcase.  The information in
 *pbcinfo is only valid until FindBriefcaseClose() is called on *phbciter.

 @rdesc If there is at least one existing briefcase in the user's list of
 briefcases, TR_SUCCESS is returned, *phbciter is filled in with a handle
 identifying the briefcase enumeration data associated with this call, and
 *pbcinfo contains information describing the first briefcase in the user's list
 of briefcases.  If there are no existing briefcases in the user's list of
 briefcases, TR_NO_MORE is returned.  Otherwise, the return value indicates the
 error that occurred.  *phbciter and *pbcinfo are only valid if TR_SUCCESS is
 returned.

 @comm To find the next briefcase in the user's list of briefcases, call
 FindNextBriefcase() with *phbciter.  Once the caller is finished enumerating
 briefcases, FindBriefcaseClose() should be called with *phbciter to free the
 briefcase enumeration data.

 @xref FindNextBriefcase() FindBriefcaseClose()

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI FindFirstBriefcase(PHBRFCASEITER phbciter,
        PBRFCASEINFO pbcinfo)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(FindFirstBriefcase);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_WRITE_PTR(phbciter, HBRFCASEITER) &&
                IS_VALID_WRITE_PTR(pbcinfo, BRFCASEINFO) &&
                EVAL(pbcinfo->ulSize == sizeof(*pbcinfo)))
#endif
        {
            PBRFCASEITER pbciter;

            tr = CreateBriefcaseIterator(&pbciter);

            if (tr == TR_SUCCESS)
            {
                tr = GetNextBriefcaseIterator(pbciter, pbcinfo);

                if (tr == TR_SUCCESS)
                    *phbciter = (HBRFCASEITER)pbciter;
                else
                    DestroyBriefcaseIterator(pbciter);
            }
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(FindFirstBriefcase, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | FindNextBriefcase | Finds the next briefcase in the current
  user's list of briefcases.

  @parm HBRFCASEITER | hbciter | A handle identifying the briefcase enumeration
  data associated with a call to FindFirstBriefcase().

  @parm PBRFCASEINFO | pbcinfo | A pointer to a BRFCASEINFO to be filled in with
  information describing the next enumerated briefcase.  The information in
 *pbcinfo is only valid until FindBriefcaseClose() is called on hbciter.

 @rdesc If there is at least one more existing briefcase in the user's list of
 briefcases, TR_SUCCESS is returned, and *pbcinfo contains information
 describing the next briefcase in the user's list of briefcases.  If there are
 no more existing briefcases in the user's list of briefcases, TR_NO_MORE is
 returned.  Otherwise, the return value indicates the error that occurred.
 *pbcinfo is only valid if TR_SUCCESS is returned.

 @xref FindFirstBriefcase() FindBriefcaseClose()

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI FindNextBriefcase(HBRFCASEITER hbciter,
        PBRFCASEINFO pbcinfo)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(FindNextBriefcase);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hbciter, BRFCASEITER) &&
                IS_VALID_WRITE_PTR(pbcinfo, BRFCASEINFO) &&
                EVAL(pbcinfo->ulSize == sizeof(*pbcinfo)))
#endif
        {
            tr = GetNextBriefcaseIterator((PBRFCASEITER)hbciter, pbcinfo);
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(FindNextBriefcase, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}


/******************************************************************************

  @doc SYNCENGAPI

  @api TWINRESULT | FindBriefcaseClose | Terminates briefcase enumeration started
  by FindFirstBriefcase().

  @parm HBRFCASEITER | hbciter | A handle identifying the briefcase enumeration
  data associated with a call to FindFirstBriefcase().  This handle is invalid
  after calling FindBriefcaseClose().

  @rdesc If the briefcase enumeration was terminated successfully, TR_SUCCESS is
  returned.  Otherwise, the return value indicates the error that occurred.

  @comm The information in any BRFCASEINFO structures returned by the call to
  FindFirstBriefcase() that returned hbciter, and by any subsequent calls to
  FindNextBriefcase() with hbciter, is invalid after FindBriefcaseClose() is
  called on hbciter.

  @xref FindFirstBriefcase() FindNextBriefcase()

 ******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI FindBriefcaseClose(HBRFCASEITER hbciter)
{
    TWINRESULT tr;

    if (BeginExclusiveBriefcaseAccess())
    {
        DebugEntry(FindBriefcaseClose);

#ifdef EXPV
        /* Verify parameters. */

        if (IS_VALID_HANDLE(hbciter, BRFCASEITER))
#endif
        {
            DestroyBriefcaseIterator((PBRFCASEITER)hbciter);

            tr = TR_SUCCESS;
        }
#ifdef EXPV
        else
            tr = TR_INVALID_PARAMETER;
#endif

        DebugExitTWINRESULT(FindBriefcaseClose, tr);

        EndExclusiveBriefcaseAccess();
    }
    else
        tr = TR_REENTERED;

    return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\findbc.h ===
/*
 * findbc.h - Briefcase enumeration module description.
 */


/* Prototypes
 *************/

/* findbc.c */

extern TWINRESULT AddBriefcaseToSystem(LPCTSTR);
extern TWINRESULT RemoveBriefcaseFromSystem(LPCTSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\guids.c ===
/*
 * guids.c - GUID definitions.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#pragma warning(disable:4001) /* "single line comment" warning */

#include <initguid.h>

#pragma warning(default:4001) /* "single line comment" warning */

#include <recguids.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\foldtwin.h ===
/*
 * foldtwin.h - Folder twin ADT description.
 */


/* Prototypes
 *************/

/* foldtwin.c */

extern BOOL CreateFolderPairPtrArray(PHPTRARRAY);
extern void DestroyFolderPairPtrArray(HPTRARRAY);
extern TWINRESULT MyTranslateFolder(HBRFCASE, HPATH, HPATH);
extern BOOL IsValidHFOLDERTWIN(HFOLDERTWIN);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\hndtrans.c ===
/*
 * hndtrans.c - Handle translation module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "sortsrch.h"


/* Macros
 *********/

#define ARRAY_ELEMENT(pht, ai)   ((((PHANDLETRANS)(hht))->hpHandlePairs)[(ai)])


/* Types
 ********/

/* handle translation unit */

typedef struct _handlepair
{
   HGENERIC hgenOld;
   HGENERIC hgenNew;
}
HANDLEPAIR;
DECLARE_STANDARD_TYPES(HANDLEPAIR);

/* handle translation structure */

typedef struct _handletrans
{
   /* pointer to array of handle translation units */

   HANDLEPAIR *hpHandlePairs;

   /* number of handle pairs in array */

   LONG lcTotalHandlePairs;

   /* number of used handle pairs in array */

   LONG lcUsedHandlePairs;
}
HANDLETRANS;
DECLARE_STANDARD_TYPES(HANDLETRANS);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE COMPARISONRESULT CompareHandlePairs(PCVOID, PCVOID);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCHANDLETRANS(PCHANDLETRANS);
PRIVATE_CODE BOOL IsValidPCHANDLEPAIR(PCHANDLEPAIR);

#endif


/*
** CompareHandlePairs()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE COMPARISONRESULT CompareHandlePairs(PCVOID pchp1, PCVOID pchp2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pchp1, CHANDLEPAIR));
   ASSERT(IS_VALID_STRUCT_PTR(pchp2, CHANDLEPAIR));

   if (((PHANDLEPAIR)pchp1)->hgenOld < ((PHANDLEPAIR)pchp2)->hgenOld)
      cr = CR_FIRST_SMALLER;
   else if (((PHANDLEPAIR)pchp1)->hgenOld > ((PHANDLEPAIR)pchp2)->hgenOld)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   return(cr);
}


#ifdef VSTF

/*
** IsValidPCHANDLETRANS()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCHANDLETRANS(PCHANDLETRANS pcht)
{
   BOOL bResult;

   if (IS_VALID_READ_PTR(pcht, CHANDLETRANS) &&
       EVAL(pcht->lcTotalHandlePairs >= 0) &&
       (EVAL(pcht->lcUsedHandlePairs >= 0) &&
        EVAL(pcht->lcUsedHandlePairs <= pcht->lcTotalHandlePairs)) &&
       IS_VALID_READ_BUFFER_PTR(pcht->hpHandlePairs, HANDLEPAIR, (UINT)(pcht->lcTotalHandlePairs)))
      bResult = TRUE;
   else
      bResult = FALSE;

   return(bResult);
}


/*
** IsValidPCHANDLEPAIR()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCHANDLEPAIR(PCHANDLEPAIR pchp)
{
   return(IS_VALID_READ_PTR(pchp, CHANDLEPAIR));
}

#endif


/****************************** Public Functions *****************************/


/*
** CreateHandleTranslator()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateHandleTranslator(LONG lcHandles, PHHANDLETRANS phht)
{
   PHANDLEPAIR hpHandlePairs;

   ASSERT(IS_VALID_WRITE_PTR(phht, HHANDLETRANS));

   *phht = NULL;

#ifdef DBLCHECK
   ASSERT((double)sizeof(HANDLEPAIR) * (double)lcHandles <= DWORD_MAX);
#endif

   if (AllocateMemory(sizeof(HANDLEPAIR) * lcHandles, &hpHandlePairs))
   {
      PHANDLETRANS phtNew;

      if (AllocateMemory(sizeof(*phtNew), &phtNew))
      {
         /* Success!  Fill in HANDLETRANS fields. */

         phtNew->hpHandlePairs = hpHandlePairs;
         phtNew->lcTotalHandlePairs = lcHandles;
         phtNew->lcUsedHandlePairs = 0;

         *phht = (HHANDLETRANS)phtNew;

         ASSERT(IS_VALID_HANDLE(*phht, HANDLETRANS));
      }
      else
         FreeMemory(hpHandlePairs);
   }

   return(*phht != NULL);
}


/*
** DestroyHandleTranslator()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyHandleTranslator(HHANDLETRANS hht)
{
   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));

   ASSERT(((PHANDLETRANS)hht)->hpHandlePairs);

   FreeMemory(((PHANDLETRANS)hht)->hpHandlePairs);

   FreeMemory((PHANDLETRANS)hht);

   return;
}


/*
** AddHandleToHandleTranslator()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL AddHandleToHandleTranslator(HHANDLETRANS hht,
                                               HGENERIC hgenOld,
                                               HGENERIC hgenNew)
{
   BOOL bRet;

   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));

   if (((PHANDLETRANS)hht)->lcUsedHandlePairs < ((PHANDLETRANS)hht)->lcTotalHandlePairs)
   {
      ARRAY_ELEMENT((PHANDLETRANS)hht, ((PHANDLETRANS)hht)->lcUsedHandlePairs).hgenOld = hgenOld;
      ARRAY_ELEMENT((PHANDLETRANS)hht, ((PHANDLETRANS)hht)->lcUsedHandlePairs).hgenNew = hgenNew;

      ((PHANDLETRANS)hht)->lcUsedHandlePairs++;

      bRet = TRUE;
   }
   else
      bRet = FALSE;

   return(bRet);
}


/*
** PrepareForHandleTranslation()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE void PrepareForHandleTranslation(HHANDLETRANS hht)
{
   HANDLEPAIR hpTemp;

   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));

   HeapSort(((PHANDLETRANS)hht)->hpHandlePairs,
            ((PHANDLETRANS)hht)->lcUsedHandlePairs,
            sizeof((((PHANDLETRANS)hht)->hpHandlePairs)[0]),
            &CompareHandlePairs,
            &hpTemp);

   return;
}


/*
** TranslateHandle()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL TranslateHandle(HHANDLETRANS hht, HGENERIC hgenOld,
                                   PHGENERIC phgenNew)
{
   BOOL bFound;
   HANDLEPAIR hpTemp;
   LONG liTarget;

   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));
   ASSERT(IS_VALID_WRITE_PTR(phgenNew, HGENERIC));

   hpTemp.hgenOld = hgenOld;

   bFound = BinarySearch(((PHANDLETRANS)hht)->hpHandlePairs,
                         ((PHANDLETRANS)hht)->lcUsedHandlePairs,
                         sizeof((((PHANDLETRANS)hht)->hpHandlePairs)[0]),
                         &CompareHandlePairs,
                         &hpTemp,
                         &liTarget);

   if (bFound)
   {
      ASSERT(liTarget < ((PHANDLETRANS)hht)->lcUsedHandlePairs);

      *phgenNew = ARRAY_ELEMENT((PHANDLETRANS)hht, liTarget).hgenNew;
   }

   return(bFound);
}


#ifdef DEBUG

/*
** IsValidHHANDLETRANS()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHHANDLETRANS(HHANDLETRANS hht)
{
   return(IS_VALID_STRUCT_PTR((PHANDLETRANS)hht, CHANDLETRANS));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\hndtrans.h ===
/*
 * hndtrans.h - Handle translation description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HHANDLETRANS);
DECLARE_STANDARD_TYPES(HHANDLETRANS);

DECLARE_HANDLE(HGENERIC);
DECLARE_STANDARD_TYPES(HGENERIC);


/* Prototypes
 *************/

/* hndtrans.c */

extern BOOL CreateHandleTranslator(LONG, PHHANDLETRANS);
extern void DestroyHandleTranslator(HHANDLETRANS);
extern BOOL AddHandleToHandleTranslator(HHANDLETRANS, HGENERIC, HGENERIC);
extern void PrepareForHandleTranslation(HHANDLETRANS);
extern BOOL TranslateHandle(HHANDLETRANS, HGENERIC, PHGENERIC);

#ifdef DEBUG

extern BOOL IsValidHHANDLETRANS(HHANDLETRANS);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\foldtwin.c ===
/*
 * foldtwin.c - Folder twin ADT module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop

#include "stub.h"
#include "subcycle.h"


/* Constants
 ************/

/* pointer array allocation constants */

#define NUM_START_FOLDER_TWIN_PTRS     (16)
#define NUM_FOLDER_TWIN_PTRS_TO_ADD    (16)


/* Types
 ********/

/* internal new folder twin description */

typedef struct _inewfoldertwin
{
   HPATH hpathFirst;
   HPATH hpathSecond;
   HSTRING hsName;
   DWORD dwAttributes;
   HBRFCASE hbr;
   DWORD dwFlags;
}
INEWFOLDERTWIN;
DECLARE_STANDARD_TYPES(INEWFOLDERTWIN);

/* database folder twin list header */

typedef struct _dbfoldertwinlistheader
{
   LONG lcFolderPairs;
}
DBFOLDERTWINLISTHEADER;
DECLARE_STANDARD_TYPES(DBFOLDERTWINLISTHEADER);

/* database folder twin structure */

typedef struct _dbfoldertwin
{
   /* shared stub flags */

   DWORD dwStubFlags;

   /* old handle to first folder path */

   HPATH hpath1;

   /* old handle to second folder path */

   HPATH hpath2;

   /* old handle to name string */

   HSTRING hsName;

   /* attributes to match */

   DWORD dwAttributes;
}
DBFOLDERTWIN;
DECLARE_STANDARD_TYPES(DBFOLDERTWIN);


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

PRIVATE_CODE TWINRESULT MakeINewFolderTwin(HBRFCASE, PCNEWFOLDERTWIN, PINEWFOLDERTWIN);
PRIVATE_CODE void ReleaseINewFolderTwin(PINEWFOLDERTWIN);
PRIVATE_CODE TWINRESULT TwinFolders(PCINEWFOLDERTWIN, PFOLDERPAIR *);
PRIVATE_CODE BOOL FindFolderPair(PCINEWFOLDERTWIN, PFOLDERPAIR *);
PRIVATE_CODE BOOL CreateFolderPair(PCINEWFOLDERTWIN, PFOLDERPAIR *);
PRIVATE_CODE BOOL CreateHalfOfFolderPair(HPATH, HBRFCASE, PFOLDERPAIR *);
PRIVATE_CODE void DestroyHalfOfFolderPair(PFOLDERPAIR);
PRIVATE_CODE BOOL CreateSharedFolderPairData(PCINEWFOLDERTWIN, PFOLDERPAIRDATA *);
PRIVATE_CODE void DestroySharedFolderPairData(PFOLDERPAIRDATA);
PRIVATE_CODE COMPARISONRESULT FolderPairSortCmp(PCVOID, PCVOID);
PRIVATE_CODE COMPARISONRESULT FolderPairSearchCmp(PCVOID, PCVOID);
PRIVATE_CODE BOOL RemoveSourceFolderTwin(POBJECTTWIN, PVOID);
PRIVATE_CODE void UnlinkHalfOfFolderPair(PFOLDERPAIR);
PRIVATE_CODE BOOL FolderTwinIntersectsFolder(PCFOLDERPAIR, HPATH);
PRIVATE_CODE TWINRESULT CreateListOfFolderTwins(HBRFCASE, ARRAYINDEX, HPATH, PFOLDERTWIN *, PARRAYINDEX);
PRIVATE_CODE void DestroyListOfFolderTwins(PFOLDERTWIN);
PRIVATE_CODE TWINRESULT AddFolderTwinToList(PFOLDERPAIR, PFOLDERTWIN, PFOLDERTWIN *);
PRIVATE_CODE TWINRESULT TransplantFolderPair(PFOLDERPAIR, HPATH, HPATH);
PRIVATE_CODE TWINRESULT WriteFolderPair(HCACHEDFILE, PFOLDERPAIR);
PRIVATE_CODE TWINRESULT ReadFolderPair(HCACHEDFILE, HBRFCASE, HHANDLETRANS, HHANDLETRANS);

#ifdef VSTF

PRIVATE_CODE BOOL IsValidPCNEWFOLDERTWIN(PCNEWFOLDERTWIN);
PRIVATE_CODE BOOL IsValidPCFOLDERTWINLIST(PCFOLDERTWINLIST);
PRIVATE_CODE BOOL IsValidPCFOLDERTWIN(PCFOLDERTWIN);
PRIVATE_CODE BOOL IsValidFolderPairHalf(PCFOLDERPAIR);
PRIVATE_CODE BOOL IsValidPCFOLDERPAIRDATA(PCFOLDERPAIRDATA);

#endif

#ifdef DEBUG

PRIVATE_CODE BOOL IsValidPCINEWFOLDERTWIN(PCINEWFOLDERTWIN);
PRIVATE_CODE BOOL AreFolderPairsValid(HPTRARRAY);

#endif


/*
** MakeINewFolderTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT MakeINewFolderTwin(HBRFCASE hbr,
                                           PCNEWFOLDERTWIN pcnftSrc,
                                           PINEWFOLDERTWIN pinftDest)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_STRUCT_PTR(pcnftSrc, CNEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(pinftDest, CINEWFOLDERTWIN));

   if (AddString(pcnftSrc->pcszName, GetBriefcaseNameStringTable(hbr),
                 GetHashBucketIndex, &(pinftDest->hsName)))
   {
      HPATHLIST hpl;

      hpl = GetBriefcasePathList(hbr);

      tr = TranslatePATHRESULTToTWINRESULT(
            AddPath(hpl, pcnftSrc->pcszFolder1, &(pinftDest->hpathFirst)));

      if (tr == TR_SUCCESS)
      {
         tr = TranslatePATHRESULTToTWINRESULT(
               AddPath(hpl, pcnftSrc->pcszFolder2, &(pinftDest->hpathSecond)));

         if (tr == TR_SUCCESS)
         {
            pinftDest->dwAttributes = pcnftSrc->dwAttributes;
            pinftDest->dwFlags = pcnftSrc->dwFlags;
            pinftDest->hbr = hbr;
         }
         else
         {
            DeletePath(pinftDest->hpathFirst);
MAKEINEWFOLDERTWIN_BAIL:
            DeleteString(pinftDest->hsName);
         }
      }
      else
         goto MAKEINEWFOLDERTWIN_BAIL;
   }
   else
      tr = TR_OUT_OF_MEMORY;

   ASSERT(tr != TR_SUCCESS ||
          IS_VALID_STRUCT_PTR(pinftDest, CINEWFOLDERTWIN));

   return(tr);
}


/*
** ReleaseINewFolderTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void ReleaseINewFolderTwin(PINEWFOLDERTWIN pinft)
{
   ASSERT(IS_VALID_STRUCT_PTR(pinft, CINEWFOLDERTWIN));

   DeletePath(pinft->hpathFirst);
   DeletePath(pinft->hpathSecond);
   DeleteString(pinft->hsName);

   return;
}


/*
** TwinFolders()
**
** Twins two folders.
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT TwinFolders(PCINEWFOLDERTWIN pcinft, PFOLDERPAIR *ppfp)
{
   PFOLDERPAIR pfp;
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pcinft, CINEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppfp, PFOLDERPAIR));

   /* Are the two folders the same? */

   if (ComparePaths(pcinft->hpathFirst, pcinft->hpathSecond) != CR_EQUAL)
   {
      /* Look for the two folders in existing folder pairs. */

      if (FindFolderPair(pcinft, &pfp))
      {
         /* Found a existing matching folder pair.  Complain. */

         *ppfp = pfp;

         tr = TR_DUPLICATE_TWIN;
      }
      else
      {
         /*
          * No existing matching folder pairs found.  Only allowing twinning to
          * paths whose roots are available.
          */

         if (IsPathVolumeAvailable(pcinft->hpathFirst) &&
             IsPathVolumeAvailable(pcinft->hpathSecond))
         {
            /*
             * If this is a new folder subtree pair, check to see if it would
             * create a cycle.
             */

            if (IS_FLAG_SET(pcinft->dwFlags, NFT_FL_SUBTREE))
               tr = CheckForSubtreeCycles(
                        GetBriefcaseFolderPairPtrArray(pcinft->hbr),
                        pcinft->hpathFirst, pcinft->hpathSecond,
                        pcinft->hsName);
            else
               tr = TR_SUCCESS;

            if (tr == TR_SUCCESS)
            {
               if (CreateFolderPair(pcinft, &pfp))
               {
                  *ppfp = pfp;

                  TRACE_OUT((TEXT("TwinFolders(): Creating %s twin pair %s and %s, files %s."),
                             IS_FLAG_SET(pcinft->dwFlags, NFT_FL_SUBTREE) ? TEXT("subtree") : TEXT("folder"),
                             DebugGetPathString(pcinft->hpathFirst),
                             DebugGetPathString(pcinft->hpathSecond),
                             GetString(pcinft->hsName)));
               }
               else
                  tr = TR_OUT_OF_MEMORY;
            }
         }
         else
            tr = TR_UNAVAILABLE_VOLUME;
      }
   }
   else
      tr = TR_SAME_FOLDER;

   return(tr);
}


/*
** FindFolderPair()
**
** Looks for a folder pair matching the given description.
**
** Arguments:     pcinft - pointer to INEWFOLDERTWIN describing folder pair to
**                          search for
**
** Returns:       Pointer to PFOLDERPAIR if found.  NULL if not found.
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FindFolderPair(PCINEWFOLDERTWIN pcinft, PFOLDERPAIR *ppfp)
{
   ARRAYINDEX aiFirst;

   ASSERT(IS_VALID_STRUCT_PTR(pcinft, CINEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppfp, PFOLDERPAIR));

   /*
    * Search all folder pairs containing the first folder.  Then scan all these
    * folder pairs for the second folder.
    */

   *ppfp = NULL;

   if (SearchSortedArray(GetBriefcaseFolderPairPtrArray(pcinft->hbr),
                         &FolderPairSearchCmp, pcinft->hpathFirst, &aiFirst))
   {
      ARRAYINDEX aicPtrs;
      HPTRARRAY hpaFolderPairs;
      LONG ai;
      PFOLDERPAIR pfp;

      /*
       * aiFirst holds the index of the first folder pair that
       * contains the first folder name.
       */

      /*
       * Now search each of these folder pairs for all paired folders
       * using the second folder name.
       */

      hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pcinft->hbr);

      aicPtrs = GetPtrCount(hpaFolderPairs);
      ASSERT(aicPtrs > 0);
      ASSERT(! (aicPtrs % 2));
      ASSERT(aiFirst >= 0);
      ASSERT(aiFirst < aicPtrs);

      for (ai = aiFirst; ai < aicPtrs; ai++)
      {
         pfp = GetPtr(hpaFolderPairs, ai);

         ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

         /* Does this folder pair match the proposed folder pair? */

         if (ComparePaths(pfp->hpath, pcinft->hpathFirst) == CR_EQUAL)
         {
            /*
             * An existing pair of folder twins is considered the same as a
             * proposed new pair of folder twins when the two pairs of folder
             * twins share the same:
             *    1) pair of PATHs
             *    2) name specification
             *    3) file attributes
             *    4) subtree flag setting
             */

            if (ComparePaths(pfp->pfpOther->hpath, pcinft->hpathSecond) == CR_EQUAL &&
                CompareNameStringsByHandle(pfp->pfpd->hsName, pcinft->hsName) == CR_EQUAL &&
                pfp->pfpd->dwAttributes == pcinft->dwAttributes &&
                ((IS_FLAG_SET(pfp->stub.dwFlags, STUB_FL_SUBTREE) &&
                  IS_FLAG_SET(pcinft->dwFlags, NFT_FL_SUBTREE)) ||
                 (IS_FLAG_CLEAR(pfp->stub.dwFlags, STUB_FL_SUBTREE) &&
                  IS_FLAG_CLEAR(pcinft->dwFlags, NFT_FL_SUBTREE))))
            {
               /* Yes. */

               *ppfp = pfp;
               break;
            }
         }
         else
            break;
      }
   }

   return(*ppfp != NULL);
}


/*
** CreateFolderPair()
**
** Creates a new folder pair, and adds them to a briefcase's list of folder
** pairs.
**
** Arguments:     pcinft - pointer to INEWFOLDERTWIN describing folder pair to
**                         create
**                ppfp - pointer to PFOLDERPAIR to be filled in with pointer to
**                       half of new folder pair representing
**                       pcnft->pcszFolder1
**
** Returns:
**
** Side Effects:  Adds the new folder pair to the global array of folder pairs.
**
** N.b., this function does not first check to see if the folder pair already
** exists in the global list of folder pairs.
*/
PRIVATE_CODE BOOL CreateFolderPair(PCINEWFOLDERTWIN pcinft, PFOLDERPAIR *ppfp)
{
   BOOL bResult = FALSE;
   PFOLDERPAIRDATA pfpd;

   ASSERT(IS_VALID_STRUCT_PTR(pcinft, CINEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppfp, PFOLDERPAIR));

   /* Try to create the shared folder data structure. */

   if (CreateSharedFolderPairData(pcinft, &pfpd))
   {
      PFOLDERPAIR pfpNew1;
      BOOL bPtr1Loose = TRUE;

      if (CreateHalfOfFolderPair(pcinft->hpathFirst, pcinft->hbr, &pfpNew1))
      {
         PFOLDERPAIR pfpNew2;

         if (CreateHalfOfFolderPair(pcinft->hpathSecond, pcinft->hbr,
                                    &pfpNew2))
         {
            HPTRARRAY hpaFolderPairs;
            ARRAYINDEX ai1;

            /* Combine the two folder pair halves. */

            pfpNew1->pfpd = pfpd;
            pfpNew1->pfpOther = pfpNew2;

            pfpNew2->pfpd = pfpd;
            pfpNew2->pfpOther = pfpNew1;

            /* Set flags. */

            if (IS_FLAG_SET(pcinft->dwFlags, NFT_FL_SUBTREE))
            {
               SetStubFlag(&(pfpNew1->stub), STUB_FL_SUBTREE);
               SetStubFlag(&(pfpNew2->stub), STUB_FL_SUBTREE);
            }

            /*
             * Try to add the two folder pairs to the global list of folder
             * pairs.
             */

            hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pcinft->hbr);

            if (AddPtr(hpaFolderPairs, FolderPairSortCmp, pfpNew1, &ai1))
            {
               ARRAYINDEX ai2;

               bPtr1Loose = FALSE;

               if (AddPtr(hpaFolderPairs, FolderPairSortCmp, pfpNew2, &ai2))
               {
                  ASSERT(IS_VALID_STRUCT_PTR(pfpNew1, CFOLDERPAIR));
                  ASSERT(IS_VALID_STRUCT_PTR(pfpNew2, CFOLDERPAIR));

                  if (ApplyNewFolderTwinsToTwinFamilies(pfpNew1))
                  {
                     *ppfp = pfpNew1;
                     bResult = TRUE;
                  }
                  else
                  {
                     DeletePtr(hpaFolderPairs, ai2);

CREATEFOLDERPAIR_BAIL1:
                     DeletePtr(hpaFolderPairs, ai1);

CREATEFOLDERPAIR_BAIL2:
                     /*
                      * Don't try to remove pfpNew2 from the global list of
                      * folder pairs here since it was never added
                      * successfully.
                      */
                     DestroyHalfOfFolderPair(pfpNew2);

CREATEFOLDERPAIR_BAIL3:
                     /*
                      * Don't try to remove pfpNew1 from the global list of
                      * folder pairs here since it was never added
                      * successfully.
                      */
                     DestroyHalfOfFolderPair(pfpNew1);

CREATEFOLDERPAIR_BAIL4:
                     DestroySharedFolderPairData(pfpd);
                  }
               }
               else
                  goto CREATEFOLDERPAIR_BAIL1;
            }
            else
               goto CREATEFOLDERPAIR_BAIL2;
         }
         else
            goto CREATEFOLDERPAIR_BAIL3;
      }
      else
         goto CREATEFOLDERPAIR_BAIL4;
   }

   return(bResult);
}


/*
** CreateHalfOfFolderPair()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateHalfOfFolderPair(HPATH hpathFolder, HBRFCASE hbr,
                                    PFOLDERPAIR *ppfp)
{
   BOOL bResult = FALSE;
   PFOLDERPAIR pfpNew;

   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_WRITE_PTR(ppfp, PFOLDERPAIR));

   /* Try to create a new FOLDERPAIR structure. */

   if (AllocateMemory(sizeof(*pfpNew), &pfpNew))
   {
      /* Try to add the folder string to the folder string table. */

      if (CopyPath(hpathFolder, GetBriefcasePathList(hbr), &(pfpNew->hpath)))
      {
         /* Fill in the fields of the new FOLDERPAIR structure. */

         InitStub(&(pfpNew->stub), ST_FOLDERPAIR);

         *ppfp = pfpNew;
         bResult = TRUE;
      }
      else
         FreeMemory(pfpNew);
   }

   return(bResult);
}


/*
** DestroyHalfOfFolderPair()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyHalfOfFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   TRACE_OUT((TEXT("DestroyHalfOfFolderPair(): Destroying folder twin %s."),
              DebugGetPathString(pfp->hpath)));

   /* Has the other half of this folder pair already been destroyed? */

   if (IsStubFlagClear(&(pfp->stub), STUB_FL_BEING_DELETED))
      /* No.  Indicate that this half has already been deleted. */
      SetStubFlag(&(pfp->pfpOther->stub), STUB_FL_BEING_DELETED);

   /* Destroy FOLDERPAIR fields. */

   DeletePath(pfp->hpath);
   FreeMemory(pfp);

   return;
}


/*
** CreateSharedFolderPairData()
**
** Creates a shared folder pair data structure.
**
** Arguments:     pcinft - pointer to INEWFOLDERTWIN describing folder pair
**                          being created
**
** Returns:       Pointer to new folder pair data structure if successful.
**                NULL if unsuccessful.
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL CreateSharedFolderPairData(PCINEWFOLDERTWIN pcinft,
                                        PFOLDERPAIRDATA *ppfpd)
{
   PFOLDERPAIRDATA pfpd;

   ASSERT(IS_VALID_STRUCT_PTR(pcinft, CINEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppfpd, PFOLDERPAIRDATA));

   /* Try to allocate a new shared folder pair data data structure. */

   *ppfpd = NULL;

   if (AllocateMemory(sizeof(*pfpd), &pfpd))
   {
      /* Fill in the FOLDERPAIRDATA structure fields. */

      LockString(pcinft->hsName);
      pfpd->hsName = pcinft->hsName;

      pfpd->dwAttributes = pcinft->dwAttributes;
      pfpd->hbr = pcinft->hbr;

      ASSERT(! IS_ATTR_DIR(pfpd->dwAttributes));

      CLEAR_FLAG(pfpd->dwAttributes, FILE_ATTRIBUTE_DIRECTORY);

      *ppfpd = pfpd;

      ASSERT(IS_VALID_STRUCT_PTR(*ppfpd, CFOLDERPAIRDATA));
   }

   return(*ppfpd != NULL);
}


/*
** DestroySharedFolderPairData()
**
** Destroys shared folder pair data.
**
** Arguments:     pfpd - pointer to shared folder pair data to destroy
**
** Returns:       void
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroySharedFolderPairData(PFOLDERPAIRDATA pfpd)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfpd, CFOLDERPAIRDATA));

   /* Destroy FOLDERPAIRDATA fields. */

   DeleteString(pfpd->hsName);
   FreeMemory(pfpd);

   return;
}


/*
** FolderPairSortCmp()
**
** Pointer comparison function used to sort the global array of folder pairs.
**
** Arguments:     pcfp1 - pointer to FOLDERPAIR describing first folder pair
**                pcfp2 - pointer to FOLDERPAIR describing second folder pair
**
** Returns:
**
** Side Effects:  none
**
** Folder pairs are sorted by:
**    1) path
**    2) pointer value
*/
PRIVATE_CODE COMPARISONRESULT FolderPairSortCmp(PCVOID pcfp1, PCVOID pcfp2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp1, CFOLDERPAIR));
   ASSERT(IS_VALID_STRUCT_PTR(pcfp2, CFOLDERPAIR));

   cr = ComparePaths(((PCFOLDERPAIR)pcfp1)->hpath,
                     ((PCFOLDERPAIR)pcfp2)->hpath);

   if (cr == CR_EQUAL)
      cr = ComparePointers(pcfp1, pcfp2);

   return(cr);
}


/*
** FolderPairSearchCmp()
**
** Pointer comparison function used to search the global array of folder pairs
** for the first folder pair for a given folder.
**
** Arguments:     hpath - folder pair to search for
**                pcfp - pointer to FOLDERPAIR to examine
**
** Returns:
**
** Side Effects:  none
**
** Folder pairs are searched by:
**    1) path
*/
PRIVATE_CODE COMPARISONRESULT FolderPairSearchCmp(PCVOID hpath, PCVOID pcfp)
{
   ASSERT(IS_VALID_HANDLE((HPATH)hpath, PATH));
   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

   return(ComparePaths((HPATH)hpath, ((PCFOLDERPAIR)pcfp)->hpath));
}


/*
** RemoveSourceFolderTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

PRIVATE_CODE BOOL RemoveSourceFolderTwin(POBJECTTWIN pot, PVOID pv)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pv);

   if (EVAL(pot->ulcSrcFolderTwins > 0))
      pot->ulcSrcFolderTwins--;

   /*
    * If there are no more source folder twins for this object twin, and this
    * object twin is not a separate "orphan" object twin, wipe it out.
    */

   if (! pot->ulcSrcFolderTwins &&
       IsStubFlagClear(&(pot->stub), STUB_FL_FROM_OBJECT_TWIN))
      EVAL(DestroyStub(&(pot->stub)) == TR_SUCCESS);

   return(TRUE);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


/*
** UnlinkHalfOfFolderPair()
**
** Unlinks one half of a pair of folder twins.
**
** Arguments:     pfp - pointer to folder pair half to unlink
**
** Returns:       void
**
** Side Effects:  Removes a source folder twin from each of the object twin's
**                in the folder pair's list of generated object twins.  May
**                cause object twins and twin families to be destroyed.
*/
PRIVATE_CODE void UnlinkHalfOfFolderPair(PFOLDERPAIR pfp)
{
   HPTRARRAY hpaFolderPairs;
   ARRAYINDEX aiUnlink;

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   TRACE_OUT((TEXT("UnlinkHalfOfFolderPair(): Unlinking folder twin %s."),
              DebugGetPathString(pfp->hpath)));

   /* Search for the folder pair to be unlinked. */

   hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pfp->pfpd->hbr);

   if (EVAL(SearchSortedArray(hpaFolderPairs, &FolderPairSortCmp, pfp,
                              &aiUnlink)))
   {
      /* Unlink folder pair. */

      ASSERT(GetPtr(hpaFolderPairs, aiUnlink) == pfp);

      DeletePtr(hpaFolderPairs, aiUnlink);

      /*
       * Don't mark folder pair stub unlinked here.  Let caller do that after
       * both folder pair halves have been unlinked.
       */

      /* Remove a source folder twin from all generated object twins. */

      EVAL(EnumGeneratedObjectTwins(pfp, &RemoveSourceFolderTwin, NULL));
   }

   return;
}


/*
** FolderTwinIntersectsFolder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL FolderTwinIntersectsFolder(PCFOLDERPAIR pcfp, HPATH hpathFolder)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));

   if (IsStubFlagSet(&(pcfp->stub), STUB_FL_SUBTREE))
      bResult = IsPathPrefix(hpathFolder, pcfp->hpath);
   else
      bResult = (ComparePaths(hpathFolder, pcfp->hpath) == CR_EQUAL);

   return(bResult);
}


/*
** CreateListOfFolderTwins()
**
** Creates a list of folder twins from a block of folder pairs.
**
** Arguments:     aiFirst - index of first folder pair in the array of folder
**                          pairs
**                hpathFolder - folder that list of folder twins is to be
**                              created for
**                ppftHead - pointer to PFOLDERTWIN to be filled in with
**                           pointer to first folder twin in new list
**                paic - pointer to ARRAYINDEX to be filled in with number of
**                       folder twins in new list
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT CreateListOfFolderTwins(HBRFCASE hbr, ARRAYINDEX aiFirst,
                                           HPATH hpathFolder,
                                           PFOLDERTWIN *ppftHead,
                                           PARRAYINDEX paic)
{
   TWINRESULT tr;
   PFOLDERPAIR pfp;
   HPATH hpath;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;
   PFOLDERTWIN pftHead;
   HPTRARRAY hpaFolderTwins;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_WRITE_PTR(ppftHead, PFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(paic, ARRAYINDEX));

   /*
    * Get the handle to the common folder that the list of folder twins is
    * being prepared for.
    */

   hpaFolderTwins = GetBriefcaseFolderPairPtrArray(hbr);

   pfp = GetPtr(hpaFolderTwins, aiFirst);

   hpath = pfp->hpath;

   /*
    * Add the other half of each matching folder pair to the folder twin list
    * as a folder twin.
    */

   aicPtrs = GetPtrCount(hpaFolderTwins);
   ASSERT(aicPtrs > 0);
   ASSERT(! (aicPtrs % 2));
   ASSERT(aiFirst >= 0);
   ASSERT(aiFirst < aicPtrs);

   /* Start with an empty list of folder twins. */

   pftHead = NULL;

   /*
    * A pointer to the first folder pair is already in pfp, but we'll look it
    * up again.
    */

   TRACE_OUT((TEXT("CreateListOfFolderTwins(): Creating list of folder twins of folder %s."),
              DebugGetPathString(hpath)));

   tr = TR_SUCCESS;

   for (ai = aiFirst; ai < aicPtrs && tr == TR_SUCCESS; ai++)
   {
      pfp = GetPtr(hpaFolderTwins, ai);

      if (ComparePaths(pfp->hpath, hpathFolder) == CR_EQUAL)
         tr = AddFolderTwinToList(pfp, pftHead, &pftHead);
      else
         break;
   }

   TRACE_OUT((TEXT("CreateListOfFolderTwins(): Finished creating list of folder twins of folder %s."),
              DebugGetPathString(hpath)));

   if (tr == TR_SUCCESS)
   {
      /* Success!  Fill in the result parameters. */

      *ppftHead = pftHead;
      *paic = ai - aiFirst;
   }
   else
      /* Free any folder twins that have been added to the list. */
      DestroyListOfFolderTwins(pftHead);

   return(tr);
}


/*
** DestroyListOfFolderTwins()
**
** Wipes out the folder twins in a folder twin list.
**
** Arguments:     pftHead - pointer to first folder twin in list
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE void DestroyListOfFolderTwins(PFOLDERTWIN pftHead)
{
   while (pftHead)
   {
      PFOLDERTWIN pftOldHead;

      ASSERT(IS_VALID_STRUCT_PTR(pftHead, CFOLDERTWIN));

      UnlockStub(&(((PFOLDERPAIR)(pftHead->hftSrc))->stub));
      UnlockStub(&(((PFOLDERPAIR)(pftHead->hftOther))->stub));

      pftOldHead = pftHead;
      pftHead = (PFOLDERTWIN)(pftHead->pcftNext);

      FreeMemory((LPTSTR)(pftOldHead->pcszSrcFolder));
      FreeMemory((LPTSTR)(pftOldHead->pcszOtherFolder));

      FreeMemory(pftOldHead);
   }

   return;
}


/*
** AddFolderTwinToList()
**
** Adds a folder twin to a list of folder twins.
**
** Arguments:     pfpSrc - pointer to source folder pair to be added
**                pftHead - pointer to head of folder twin list, may be NULL
**                ppft - pointer to PFOLDERTWIN to be filled in with pointer
**                         to new folder twin, ppft may be &pftHead
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT AddFolderTwinToList(PFOLDERPAIR pfpSrc,
                                            PFOLDERTWIN pftHead,
                                            PFOLDERTWIN *ppft)
{
   TWINRESULT tr = TR_OUT_OF_MEMORY;
   PFOLDERTWIN pftNew;

   ASSERT(IS_VALID_STRUCT_PTR(pfpSrc, CFOLDERPAIR));
   ASSERT(! pftHead || IS_VALID_STRUCT_PTR(pftHead, CFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppft, PFOLDERTWIN));

   /* Try to create a new FOLDERTWIN structure. */

   if (AllocateMemory(sizeof(*pftNew), &pftNew))
   {
      LPTSTR pszFirstFolder;

      if (AllocatePathString(pfpSrc->hpath, &pszFirstFolder))
      {
         LPTSTR pszSecondFolder;

         if (AllocatePathString(pfpSrc->pfpOther->hpath, &pszSecondFolder))
         {
            /* Fill in FOLDERTWIN structure fields. */

            pftNew->pcftNext = pftHead;
            pftNew->hftSrc = (HFOLDERTWIN)pfpSrc;
            pftNew->hvidSrc = (HVOLUMEID)(pfpSrc->hpath);
            pftNew->pcszSrcFolder = pszFirstFolder;
            pftNew->hftOther = (HFOLDERTWIN)(pfpSrc->pfpOther);
            pftNew->hvidOther = (HVOLUMEID)(pfpSrc->pfpOther->hpath);
            pftNew->pcszOtherFolder = pszSecondFolder;
            pftNew->pcszName = GetString(pfpSrc->pfpd->hsName);

            pftNew->dwFlags = 0;

            if (IsStubFlagSet(&(pfpSrc->stub), STUB_FL_SUBTREE))
               pftNew->dwFlags = FT_FL_SUBTREE;

            LockStub(&(pfpSrc->stub));
            LockStub(&(pfpSrc->pfpOther->stub));

            *ppft = pftNew;
            tr = TR_SUCCESS;

            TRACE_OUT((TEXT("AddFolderTwinToList(): Added folder twin %s of folder %s matching objects %s."),
                       pftNew->pcszSrcFolder,
                       pftNew->pcszOtherFolder,
                       pftNew->pcszName));
         }
         else
         {
            FreeMemory(pszFirstFolder);
ADDFOLDERTWINTOLIST_BAIL:
            FreeMemory(pftNew);
         }
      }
      else
         goto ADDFOLDERTWINTOLIST_BAIL;
   }

   ASSERT(tr != TR_SUCCESS ||
          IS_VALID_STRUCT_PTR(*ppft, CFOLDERTWIN));

   return(tr);
}


/*
** TransplantFolderPair()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT TransplantFolderPair(PFOLDERPAIR pfp,
                                             HPATH hpathOldFolder,
                                             HPATH hpathNewFolder)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hpathOldFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hpathNewFolder, PATH));

   /* Is this folder pair rooted in the renamed folder's subtree? */

   if (IsPathPrefix(pfp->hpath, hpathOldFolder))
   {
      TCHAR rgchPathSuffix[MAX_PATH_LEN];
      LPCTSTR pcszSubPath;
      HPATH hpathNew;

      /* Yes.  Change the folder pair's root. */

      pcszSubPath = FindChildPathSuffix(hpathOldFolder, pfp->hpath,
                                        rgchPathSuffix);

      if (AddChildPath(GetBriefcasePathList(pfp->pfpd->hbr), hpathNewFolder,
                       pcszSubPath, &hpathNew))
      {
         if (IsStubFlagSet(&(pfp->stub), STUB_FL_SUBTREE))
         {
            ASSERT(IsStubFlagSet(&(pfp->pfpOther->stub), STUB_FL_SUBTREE));

            BeginTranslateFolder(pfp);

            tr = CheckForSubtreeCycles(
                     GetBriefcaseFolderPairPtrArray(pfp->pfpd->hbr), hpathNew,
                     pfp->pfpOther->hpath, pfp->pfpd->hsName);

            EndTranslateFolder(pfp);
         }
         else
            tr = TR_SUCCESS;

         if (tr == TR_SUCCESS)
         {
            TRACE_OUT((TEXT("TransplantFolderPair(): Transplanted folder twin %s to %s."),
                       DebugGetPathString(pfp->hpath),
                       DebugGetPathString(hpathNew)));

            DeletePath(pfp->hpath);
            pfp->hpath = hpathNew;
         }
         else
            DeletePath(hpathNew);
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_SUCCESS;

   return(tr);
}


/*
** WriteFolderPair()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT WriteFolderPair(HCACHEDFILE hcf, PFOLDERPAIR pfp)
{
   TWINRESULT tr;
   DBFOLDERTWIN dbft;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   /* Set up folder pair database structure. */

   dbft.dwStubFlags = (pfp->stub.dwFlags & DB_STUB_FLAGS_MASK);
   dbft.hpath1 = pfp->hpath;
   dbft.hpath2 = pfp->pfpOther->hpath;
   dbft.hsName = pfp->pfpd->hsName;
   dbft.dwAttributes = pfp->pfpd->dwAttributes;

   /* Save folder pair database structure. */

   if (WriteToCachedFile(hcf, (PCVOID)&dbft, sizeof(dbft), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


/*
** ReadFolderPair()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PRIVATE_CODE TWINRESULT ReadFolderPair(HCACHEDFILE hcf, HBRFCASE hbr,
                                  HHANDLETRANS hhtFolderTrans,
                                  HHANDLETRANS hhtNameTrans)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
   DBFOLDERTWIN dbft;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbft, sizeof(dbft), &dwcbRead) &&
       dwcbRead == sizeof(dbft))
   {
      INEWFOLDERTWIN inft;

      if (TranslateHandle(hhtFolderTrans, (HGENERIC)(dbft.hpath1), (PHGENERIC)&(inft.hpathFirst)))
      {
         if (TranslateHandle(hhtFolderTrans, (HGENERIC)(dbft.hpath2), (PHGENERIC)&(inft.hpathSecond)))
         {
            if (TranslateHandle(hhtNameTrans, (HGENERIC)(dbft.hsName), (PHGENERIC)&(inft.hsName)))
            {
               PFOLDERPAIR pfp;

               inft.dwAttributes = dbft.dwAttributes;
               inft.hbr = hbr;

               if (IS_FLAG_SET(dbft.dwStubFlags, STUB_FL_SUBTREE))
                  inft.dwFlags = NFT_FL_SUBTREE;
               else
                  inft.dwFlags = 0;

               if (CreateFolderPair(&inft, &pfp))
                  tr = TR_SUCCESS;
               else
                  tr = TR_OUT_OF_MEMORY;
            }
         }
      }
   }

   return(tr);
}


#ifdef VSTF

/*
** IsValidPCNEWFOLDERTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCNEWFOLDERTWIN(PCNEWFOLDERTWIN pcnft)
{
   return(IS_VALID_READ_PTR(pcnft, CNEWFOLDERTWIN) &&
          EVAL(pcnft->ulSize == sizeof(*pcnft)) &&
          IS_VALID_STRING_PTR(pcnft->pcszFolder1, CSTR) &&
          IS_VALID_STRING_PTR(pcnft->pcszFolder2, CSTR) &&
          IS_VALID_STRING_PTR(pcnft->pcszName, CSTR) &&
          FLAGS_ARE_VALID(pcnft->dwAttributes, ALL_FILE_ATTRIBUTES) &&
          FLAGS_ARE_VALID(pcnft->dwFlags, ALL_NFT_FLAGS));
}


/*
** IsValidPCFOLDERTWINLIST()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCFOLDERTWINLIST(PCFOLDERTWINLIST pcftl)
{
   BOOL bResult = FALSE;

   if (IS_VALID_READ_PTR(pcftl, CFOLDERTWINLIST) &&
       IS_VALID_HANDLE(pcftl->hbr, BRFCASE))
   {
      PCFOLDERTWIN pcft;
      ULONG ulcFolderTwins = 0;

      for (pcft = pcftl->pcftFirst;
           pcft && IS_VALID_STRUCT_PTR(pcft, CFOLDERTWIN);
           pcft = pcft->pcftNext)
      {
         ASSERT(ulcFolderTwins < ULONG_MAX);
         ulcFolderTwins++;
      }

      if (! pcft && EVAL(ulcFolderTwins == pcftl->ulcItems))
         bResult = TRUE;
   }

   return(bResult);
}


/*
** IsValidPCFOLDERTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCFOLDERTWIN(PCFOLDERTWIN pcft)
{
   /* dwUser may be any value. */

   return(IS_VALID_READ_PTR(pcft, CFOLDERTWIN) &&
          IS_VALID_HANDLE(pcft->hftSrc, FOLDERTWIN) &&
          IS_VALID_HANDLE(pcft->hvidSrc, VOLUMEID) &&
          IS_VALID_STRING_PTR(pcft->pcszSrcFolder, CSTR) &&
          IS_VALID_HANDLE(pcft->hftOther, FOLDERTWIN) &&
          IS_VALID_HANDLE(pcft->hvidOther, VOLUMEID) &&
          IS_VALID_STRING_PTR(pcft->pcszOtherFolder, CSTR) &&
          IS_VALID_STRING_PTR(pcft->pcszName, CSTR) &&
          FLAGS_ARE_VALID(pcft->dwFlags, ALL_FT_FLAGS));
}


/*
** IsValidFolderPairHalf()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidFolderPairHalf(PCFOLDERPAIR pcfp)
{
   return(IS_VALID_READ_PTR(pcfp, CFOLDERPAIR) &&
          IS_VALID_STRUCT_PTR(&(pcfp->stub), CSTUB) &&
          FLAGS_ARE_VALID(GetStubFlags(&(pcfp->stub)), ALL_FOLDER_TWIN_FLAGS) &&
          IS_VALID_HANDLE(pcfp->hpath, PATH) &&
          IS_VALID_STRUCT_PTR(pcfp->pfpd, CFOLDERPAIRDATA) &&
          (IsStubFlagSet(&(pcfp->stub), STUB_FL_BEING_DELETED) ||
           IS_VALID_READ_PTR(pcfp->pfpOther, CFOLDERPAIR)));
}


/*
** IsValidPCFOLDERPAIRDATA()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCFOLDERPAIRDATA(PCFOLDERPAIRDATA pcfpd)
{
   /* Don't validate hbr. */

   return(IS_VALID_READ_PTR(pcfpd, CFOLDERPAIRDATA) &&
          IS_VALID_HANDLE(pcfpd->hsName, STRING));
}

#endif


#ifdef DEBUG

/*
** IsValidPCINEWFOLDERTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL IsValidPCINEWFOLDERTWIN(PCINEWFOLDERTWIN pcinft)
{
   return(IS_VALID_READ_PTR(pcinft, CINEWFOLDERTWIN) &&
          IS_VALID_HANDLE(pcinft->hpathFirst, PATH) &&
          IS_VALID_HANDLE(pcinft->hpathSecond, PATH) &&
          IS_VALID_HANDLE(pcinft->hsName, STRING) &&
          FLAGS_ARE_VALID(pcinft->dwAttributes, ALL_FILE_ATTRIBUTES) &&
          FLAGS_ARE_VALID(pcinft->dwFlags, ALL_NFT_FLAGS) &&
          IS_VALID_HANDLE(pcinft->hbr, BRFCASE));
}


/*
** AreFolderPairsValid()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PRIVATE_CODE BOOL AreFolderPairsValid(HPTRARRAY hpaFolderPairs)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpaFolderPairs, PTRARRAY));

   aicPtrs = GetPtrCount(hpaFolderPairs);
   ASSERT(! (aicPtrs % 2));

   for (ai = 0;
        ai < aicPtrs && IS_VALID_STRUCT_PTR(GetPtr(hpaFolderPairs, ai), CFOLDERPAIR);
        ai++)
      ;

   return(ai == aicPtrs);
}

#endif


/****************************** Public Functions *****************************/


/*
** CreateFolderPairPtrArray()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL CreateFolderPairPtrArray(PHPTRARRAY phpa)
{
   NEWPTRARRAY npa;

   ASSERT(IS_VALID_WRITE_PTR(phpa, HPTRARRAY));

   /* Try to create a folder pair pointer array. */

   npa.aicInitialPtrs = NUM_START_FOLDER_TWIN_PTRS;
   npa.aicAllocGranularity = NUM_FOLDER_TWIN_PTRS_TO_ADD;
   npa.dwFlags = NPA_FL_SORTED_ADD;

   return(CreatePtrArray(&npa, phpa));
}


/*
** DestroyFolderPairPtrArray()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyFolderPairPtrArray(HPTRARRAY hpa)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* Free all folder pairs in pointer array. */

   aicPtrs = GetPtrCount(hpa);
   ASSERT(! (aicPtrs % 2));

   for (ai = 0; ai < aicPtrs; ai++)
   {
      PFOLDERPAIR pfp;
      PFOLDERPAIR pfpOther;
      PFOLDERPAIRDATA pfpd;
      BOOL bDeleteFolderPairData;

      pfp = GetPtr(hpa, ai);

      ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

      /* Copy fields needed after folder pair half's demise. */

      pfpOther = pfp->pfpOther;
      pfpd = pfp->pfpd;
      bDeleteFolderPairData = IsStubFlagSet(&(pfp->stub), STUB_FL_BEING_DELETED);

      DestroyHalfOfFolderPair(pfp);

      /* Has the other half of this folder pair already been destroyed? */

      if (bDeleteFolderPairData)
         /* Yes.  Destroy the pair's shared data. */
         DestroySharedFolderPairData(pfpd);
   }

   /* Now wipe out the pointer array. */

   DestroyPtrArray(hpa);

   return;
}


/*
** LockFolderPair()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void LockFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_UNLINKED));
   ASSERT(IsStubFlagClear(&(pfp->pfpOther->stub), STUB_FL_UNLINKED));

   ASSERT(pfp->stub.ulcLock < ULONG_MAX);
   pfp->stub.ulcLock++;

   ASSERT(pfp->pfpOther->stub.ulcLock < ULONG_MAX);
   pfp->pfpOther->stub.ulcLock++;

   return;
}


/*
** UnlockFolderPair()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE void UnlockFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   if (EVAL(pfp->stub.ulcLock > 0))
      pfp->stub.ulcLock--;

   if (EVAL(pfp->pfpOther->stub.ulcLock > 0))
      pfp->pfpOther->stub.ulcLock--;

   if (! pfp->stub.ulcLock &&
       IsStubFlagSet(&(pfp->stub), STUB_FL_UNLINKED))
   {
      ASSERT(! pfp->pfpOther->stub.ulcLock);
      ASSERT(IsStubFlagSet(&(pfp->pfpOther->stub), STUB_FL_UNLINKED));

      DestroyFolderPair(pfp);
   }

   return;
}


/*
** UnlinkFolderPair()
**
** Unlinks a folder pair.
**
** Arguments:     pfp - pointer to folder pair to be unlinked
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT UnlinkFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_UNLINKED));
   ASSERT(IsStubFlagClear(&(pfp->pfpOther->stub), STUB_FL_UNLINKED));

   /* Unlink both halves of the folder pair. */

   UnlinkHalfOfFolderPair(pfp);
   UnlinkHalfOfFolderPair(pfp->pfpOther);

   SetStubFlag(&(pfp->stub), STUB_FL_UNLINKED);
   SetStubFlag(&(pfp->pfpOther->stub), STUB_FL_UNLINKED);

   return(TR_SUCCESS);
}


/*
** DestroyFolderPair()
**
** Destroys a folder pair.
**
** Arguments:     pfp - pointer to folder pair to destroy
**
** Returns:       void
**
** Side Effects:  none
*/
PUBLIC_CODE void DestroyFolderPair(PFOLDERPAIR pfp)
{
   PFOLDERPAIRDATA pfpd;

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   /* Destroy both FOLDERPAIR halves, and shared data. */

   pfpd = pfp->pfpd;

   DestroyHalfOfFolderPair(pfp->pfpOther);
   DestroyHalfOfFolderPair(pfp);

   DestroySharedFolderPairData(pfpd);

   return;
}


/*
** MyTranslateFolder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT MyTranslateFolder(HBRFCASE hbr, HPATH hpathOld,
                                         HPATH hpathNew)
{
   TWINRESULT tr = TR_SUCCESS;
   HPTRARRAY hpaFolderPairs;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hpathOld, PATH));
   ASSERT(IS_VALID_HANDLE(hpathNew, PATH));

   /*
    * Change folders of all folder pairs rooted in pcszOldFolder's subtree to
    * being rooted in pcszNewFolder's subtree.
    */

   hpaFolderPairs = GetBriefcaseFolderPairPtrArray(hbr);
   aicPtrs = GetPtrCount(hpaFolderPairs);
   ASSERT(! (aicPtrs % 2));

   for (ai = 0; ai < aicPtrs; ai++)
   {
      tr = TransplantFolderPair(GetPtr(hpaFolderPairs, ai), hpathOld,
                                hpathNew);

      if (tr != TR_SUCCESS)
         break;
   }

   if (tr == TR_SUCCESS)
   {
      HPTRARRAY hpaTwinFamilies;

      /* Restore folder pair array to sorted order. */

      SortPtrArray(hpaFolderPairs, &FolderPairSortCmp);

      TRACE_OUT((TEXT("MyTranslateFolder(): Sorted folder pair array after folder translation.")));

      /*
       * Change folders of all object twins in pcszOldFolder's old subtree to
       * being in pcszNewFolder's subtree.
       */

      hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(hbr);

      aicPtrs = GetPtrCount(hpaTwinFamilies);

      for (ai = 0; ai < aicPtrs; ai++)
      {
         PTWINFAMILY ptf;
         BOOL bContinue;
         HNODE hnode;

         ptf = GetPtr(hpaTwinFamilies, ai);

         ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

         /*
          * Walk each twin family's list of object twins looking for object
          * twins in the translated folder's subtree.
          */

         for (bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnode);
              bContinue;
              bContinue = GetNextNode(hnode, &hnode))
         {
            POBJECTTWIN pot;

            pot = (POBJECTTWIN)GetNodeData(hnode);

            tr = TransplantObjectTwin(pot, hpathOld, hpathNew);

            if (tr != TR_SUCCESS)
               break;
         }

         if (tr != TR_SUCCESS)
            break;
      }

      /* Twin family array is still in sorted order. */
   }

   return(tr);
}


/*
** ApplyNewObjectTwinsToFolderTwins()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  Adds new spin-off object twins to hlistNewObjectTwins as they
**                are created.
**
** N.b., new object twins may have been added to hlistNewObjectTwins even if
** FALSE is returned.  Clean-up of these new object twins in case of failure is
** the caller's responsibility.
**
** A new object twin may generate more new object twins, implied by existing
** folder twins.  E.g., consider the following scenario:
**
** 1) Folder twins (c:\, d:\, *.*) and (d:\, e:\, *.*) exist.
** 2) Files c:\foo, d:\foo, and e:\foo do not exist.
** 3) File e:\foo is created.
** 4) New object twin e:\foo is added.
** 5) d:\foo must be added as a new object twin from the e:\foo object twin
**    because of the (d:\, e:\, *.*) folder twin.
** 6) c:\foo must be added as a new object twin from the d:\foo object twin
**    because of the (c:\, d:\, *.*) folder twin.
**
** So we see that new object twin e:\foo must generate two more new object
** twins, d:\foo and c:\foo, implied by the two existing folder twins,
** (c:\, d:\, *.*) and (d:\, e:\, *.*).
*/
PUBLIC_CODE BOOL ApplyNewObjectTwinsToFolderTwins(HLIST hlistNewObjectTwins)
{
   BOOL bResult = TRUE;
   BOOL bContinue;
   HNODE hnode;

   ASSERT(IS_VALID_HANDLE(hlistNewObjectTwins, LIST));

   /*
    * Don't use WalkList() here because we want to insert new nodes in
    * hlistNewObjectTwins after the current node.
    */

   for (bContinue = GetFirstNode(hlistNewObjectTwins, &hnode);
        bContinue && bResult;
        bContinue = GetNextNode(hnode, &hnode))
   {
      POBJECTTWIN pot;
      HPATHLIST hpl;
      HPTRARRAY hpaFolderPairs;
      ARRAYINDEX aicPtrs;
      ARRAYINDEX ai;

      pot = GetNodeData(hnode);

      ASSERT(! pot->ulcSrcFolderTwins);

      TRACE_OUT((TEXT("ApplyNewObjectTwinsToFolderTwins(): Applying new object twin %s\\%s."),
                 DebugGetPathString(pot->hpath),
                 GetString(pot->ptfParent->hsName)));

      /*
       * Assume that hpl, hpaFolderPairs, and aicPtrs don't change during this
       * loop.  Calculate them outside the loop.
       */

      hpl = GetBriefcasePathList(pot->ptfParent->hbr);
      hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pot->ptfParent->hbr);

      aicPtrs = GetPtrCount(hpaFolderPairs);
      ASSERT(! (aicPtrs % 2));

      for (ai = 0; ai < aicPtrs; ai++)
      {
         PFOLDERPAIR pfp;

         pfp = GetPtr(hpaFolderPairs, ai);

         if (FolderTwinGeneratesObjectTwin(pfp, pot->hpath,
                                           GetString(pot->ptfParent->hsName)))
         {
            HPATH hpathMatchingFolder;
            HNODE hnodeUnused;

            ASSERT(pot->ulcSrcFolderTwins < ULONG_MAX);
            pot->ulcSrcFolderTwins++;

            /*
             * Append the generated object twin's subpath to the matching
             * folder twin's base path for subtree twins.
             */

            if (BuildPathForMatchingObjectTwin(pfp, pot, hpl,
                                               &hpathMatchingFolder))
            {
               /*
                * We don't want to collapse any twin families if the matching
                * object twin is found in a different twin family.  This will
                * be done by ApplyNewFolderTwinsToTwinFamilies() for spin-off
                * object twins generated by new folder twins.
                *
                * Spin-off object twins created by new object twins never
                * require collapsing twin families.  For a spin-off object twin
                * generated by a new object twin to collapse twin families,
                * there would have to have been separate twin families
                * connected by a folder twin.  But if those twin families were
                * already connected by a folder twin, they would not be
                * separate because they would already have been collapsed by
                * ApplyNewFolderTwinsToTwinFamilies() when the connecting
                * folder twin was added.
                */

               if (! FindObjectTwin(pot->ptfParent->hbr, hpathMatchingFolder,
                                    GetString(pot->ptfParent->hsName),
                                    &hnodeUnused))
               {
                  POBJECTTWIN potNew;

                  /*
                   * CreateObjectTwin() ASSERT()s that an object twin for
                   * hpathMatchingFolder is not found, so we don't need to do
                   * that here.
                   */

                  if (CreateObjectTwin(pot->ptfParent, hpathMatchingFolder,
                                       &potNew))
                  {
                     /*
                      * Add the new object twin to hlistNewObjectTwins after
                      * the new object twin currently being processed to make
                      * certain that it gets processed in the outside loop
                      * through hlistNewObjectTwins.
                      */

                     if (! InsertNodeAfter(hnode, NULL, potNew, &hnodeUnused))
                     {
                        DestroyStub(&(potNew->stub));
                        bResult = FALSE;
                        break;
                     }
                  }
               }

               DeletePath(hpathMatchingFolder);
            }
            else
            {
               bResult = FALSE;
               break;
            }
         }
      }
   }

   return(bResult);
}


/*
** BuildPathForMatchingObjectTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  Path is added to object twin's briefcase's path list.
*/
PUBLIC_CODE BOOL BuildPathForMatchingObjectTwin(PCFOLDERPAIR pcfp,
                                                PCOBJECTTWIN pcot,
                                                HPATHLIST hpl, PHPATH phpath)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));
   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
   ASSERT(IS_VALID_WRITE_PTR(phpath, HPATH));

   ASSERT(FolderTwinGeneratesObjectTwin(pcfp, pcot->hpath, GetString(pcot->ptfParent->hsName)));

   /* Is the generating folder twin a subtree twin? */

   if (IsStubFlagSet(&(pcfp->stub), STUB_FL_SUBTREE))
   {
      TCHAR rgchPathSuffix[MAX_PATH_LEN];
      LPCTSTR pcszSubPath;

      /*
       * Yes.  Append the object twin's subpath to the subtree twin's base
       * path.
       */

      pcszSubPath = FindChildPathSuffix(pcfp->hpath, pcot->hpath,
                                        rgchPathSuffix);

      bResult = AddChildPath(hpl, pcfp->pfpOther->hpath, pcszSubPath, phpath);
   }
   else
      /* No.  Just use the matching folder twin's folder. */
      bResult = CopyPath(pcfp->pfpOther->hpath, hpl, phpath);

   return(bResult);
}


/*
** EnumGeneratedObjectTwins()
**
**
**
** Arguments:
**
** Returns:       FALSE if callback aborted.  TRUE if not.
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL EnumGeneratedObjectTwins(PCFOLDERPAIR pcfp,
                                     ENUMGENERATEDOBJECTTWINSPROC egotp,
                                     PVOID pvRefData)
{
   BOOL bResult = TRUE;
   HPTRARRAY hpaTwinFamilies;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   /* pvRefData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_CODE_PTR(egotp, ENUMGENERATEDOBJECTTWINPROC));

   /*
    * Walk the array of twin families, looking for twin families whose names
    * intersect the given folder twin's name specification.
    */

   hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(pcfp->pfpd->hbr);

   aicPtrs = GetPtrCount(hpaTwinFamilies);
   ai = 0;

   while (ai < aicPtrs)
   {
      PTWINFAMILY ptf;
      LPCTSTR pcszName;

      ptf = GetPtr(hpaTwinFamilies, ai);

      ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
      ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED));

      /*
       * Does the twin family's name match the folder twin's name
       * specification?
       */

      pcszName = GetString(ptf->hsName);

      if (IsFolderObjectTwinName(pcszName) ||
          NamesIntersect(pcszName, GetString(pcfp->pfpd->hsName)))
      {
         BOOL bContinue;
         HNODE hnodePrev;

         /* Yes.  Look for a matching folder. */

         /* Lock the twin family so it isn't deleted out from under us. */

         LockStub(&(ptf->stub));

         /*
          * Walk each twin family's list of object twins looking for object
          * twins in the given folder twin's subtree.
          */

         bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnodePrev);

         while (bContinue)
         {
            HNODE hnodeNext;
            POBJECTTWIN pot;

            bContinue = GetNextNode(hnodePrev, &hnodeNext);

            pot = (POBJECTTWIN)GetNodeData(hnodePrev);

            ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

            if (FolderTwinIntersectsFolder(pcfp, pot->hpath))
            {
               /*
                * A given object twin should only be generated by one of the
                * folder twins in a pair of folder twins.
                */

               ASSERT(! FolderTwinGeneratesObjectTwin(pcfp->pfpOther, pot->hpath, GetString(pot->ptfParent->hsName)));

               bResult = (*egotp)(pot, pvRefData);

               if (! bResult)
                  break;
            }

            hnodePrev = hnodeNext;
         }

         /* Was the twin family unlinked? */

         if (IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED))
            /* No. */
            ai++;
         else
         {
            /* Yes. */

            aicPtrs--;
            ASSERT(aicPtrs == GetPtrCount(hpaTwinFamilies));

            TRACE_OUT((TEXT("EnumGeneratedObjectTwins(): Twin family for object %s unlinked by callback."),
                       GetString(ptf->hsName)));
         }

         UnlockStub(&(ptf->stub));

         if (! bResult)
            break;
      }
      else
         /* No.  Skip it. */
         ai++;
   }

   return(bResult);
}


/*
** EnumGeneratingFolderTwins()
**
**
**
** Arguments:
**
** Returns:       FALSE if callback aborted.  TRUE if not.
**
** Side Effects:  none
**
** N.b., if the egftp callback removes a pair of folder twins, it must remove
** the pair from the first folder twin encountered.  If it removes the pair of
** folder twins from the second folder twin encountered, a folder twin will be
** skipped.
*/
PUBLIC_CODE BOOL EnumGeneratingFolderTwins(PCOBJECTTWIN pcot,
                                           ENUMGENERATINGFOLDERTWINSPROC egftp,
                                           PVOID pvRefData,
                                           PULONG pulcGeneratingFolderTwins)
{
   BOOL bResult = TRUE;
   HPTRARRAY hpaFolderPairs;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   /* pvRefData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));
   ASSERT(IS_VALID_CODE_PTR(egftp, ENUMGENERATINGFOLDERTWINSPROC));
   ASSERT(IS_VALID_WRITE_PTR(pulcGeneratingFolderTwins, ULONG));

   *pulcGeneratingFolderTwins = 0;

   hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pcot->ptfParent->hbr);

   aicPtrs = GetPtrCount(hpaFolderPairs);
   ASSERT(! (aicPtrs % 2));

   ai = 0;

   while (ai < aicPtrs)
   {
      PFOLDERPAIR pfp;

      pfp = GetPtr(hpaFolderPairs, ai);

      if (FolderTwinGeneratesObjectTwin(pfp, pcot->hpath,
                                        GetString(pcot->ptfParent->hsName)))
      {
         ASSERT(! FolderTwinGeneratesObjectTwin(pfp->pfpOther, pcot->hpath, GetString(pcot->ptfParent->hsName)));

         ASSERT(*pulcGeneratingFolderTwins < ULONG_MAX);
         (*pulcGeneratingFolderTwins)++;

         /*
          * Lock the pair of folder twins so they don't get deleted out from
          * under us.
          */

         LockStub(&(pfp->stub));

         bResult = (*egftp)(pfp, pvRefData);

         if (IsStubFlagSet(&(pfp->stub), STUB_FL_UNLINKED))
         {
            WARNING_OUT((TEXT("EnumGeneratingFolderTwins(): Folder twin pair unlinked during callback.")));

            aicPtrs -= 2;
            ASSERT(! (aicPtrs % 2));
            ASSERT(aicPtrs == GetPtrCount(hpaFolderPairs));
         }
         else
            ai++;

         UnlockStub(&(pfp->stub));

         if (! bResult)
            break;
      }
      else
         ai++;
   }

   return(bResult);
}


/*
** FolderTwinGeneratesObjectTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** A folder twin or subtree twin is said to generate an object twin when the
** following conditions are met:
**
** 1) The folder twin or subtree twin is on the same volume as the object twin.
**
** 2) The name of the object twin (literal) intersects the objects matched by
**    the folder twin or subtree twin (literal or wildcard).
**
** 3) The folder twin's folder exactly matches the object twin's folder, or the
**    subtree twin's root folder is a path prefix of the object twin's folder.
*/
PUBLIC_CODE BOOL FolderTwinGeneratesObjectTwin(PCFOLDERPAIR pcfp,
                                               HPATH hpathFolder,
                                               LPCTSTR pcszName)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

   return(FolderTwinIntersectsFolder(pcfp, hpathFolder) &&
          (IsFolderObjectTwinName(pcszName) ||
           NamesIntersect(pcszName, GetString(pcfp->pfpd->hsName))));
}


/*
** IsValidHFOLDERTWIN()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidHFOLDERTWIN(HFOLDERTWIN hft)
{
   return(IS_VALID_STRUCT_PTR((PFOLDERPAIR)hft, CFOLDERPAIR));
}


#ifdef VSTF

/*
** IsValidPCFOLDERPAIR()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
PUBLIC_CODE BOOL IsValidPCFOLDERPAIR(PCFOLDERPAIR pcfp)
{
   BOOL bResult = FALSE;

   /* All the fields of an unlinked folder pair should be valid. */

   if (EVAL(IsValidFolderPairHalf(pcfp)))
   {
      if (IsStubFlagSet(&(pcfp->stub), STUB_FL_BEING_DELETED))
         bResult = TRUE;
      else if (EVAL(IsValidFolderPairHalf(pcfp->pfpOther)) &&
               EVAL(pcfp->pfpOther->pfpOther == pcfp) &&
               EVAL(pcfp->pfpd == pcfp->pfpOther->pfpd) &&
               EVAL(pcfp->stub.ulcLock == pcfp->pfpOther->stub.ulcLock))
      {
         BOOL bUnlinked;
         BOOL bOtherUnlinked;

         /*
          * Neither or both folder pair halves may be unlinked, but not only
          * one.
          */

         bUnlinked = IsStubFlagSet(&(pcfp->stub), STUB_FL_UNLINKED);
         bOtherUnlinked = IsStubFlagSet(&(pcfp->pfpOther->stub), STUB_FL_UNLINKED);

         if (EVAL((bUnlinked && bOtherUnlinked) ||
                  (! bUnlinked && ! bOtherUnlinked)))
            bResult = TRUE;
      }
   }

   return(bResult);
}

#endif


/*
** WriteFolderPairList()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT WriteFolderPairList(HCACHEDFILE hcf,
                                      HPTRARRAY hpaFolderPairs)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DWORD dwcbDBFolderTwinListHeaderOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hpaFolderPairs, PTRARRAY));

   /* Save initial file position. */

   dwcbDBFolderTwinListHeaderOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbDBFolderTwinListHeaderOffset != INVALID_SEEK_POSITION)
   {
      DBFOLDERTWINLISTHEADER dbftlh;

      /* Leave space for folder twin data header. */

      ZeroMemory(&dbftlh, sizeof(dbftlh));

      if (WriteToCachedFile(hcf, (PCVOID)&dbftlh, sizeof(dbftlh), NULL))
      {
         ARRAYINDEX aicPtrs;
         ARRAYINDEX ai;

         tr = TR_SUCCESS;

         /* Mark all folder pairs unused. */

         ClearFlagInArrayOfStubs(hpaFolderPairs, STUB_FL_USED);

         aicPtrs = GetPtrCount(hpaFolderPairs);
         ASSERT(! (aicPtrs % 2));

         /* Write all folder pairs. */

         for (ai = 0; ai < aicPtrs; ai++)
         {
            PFOLDERPAIR pfp;

            pfp = GetPtr(hpaFolderPairs, ai);

            ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

            if (IsStubFlagClear(&(pfp->stub), STUB_FL_USED))
            {
               ASSERT(IsStubFlagClear(&(pfp->pfpOther->stub), STUB_FL_USED));

               tr = WriteFolderPair(hcf, pfp);

               if (tr == TR_SUCCESS)
               {
                  SetStubFlag(&(pfp->stub), STUB_FL_USED);
                  SetStubFlag(&(pfp->pfpOther->stub), STUB_FL_USED);
               }
               else
                  break;
            }
         }

         /* Save folder twin data header. */

         if (tr == TR_SUCCESS)
         {
            ASSERT(! (aicPtrs % 2));

            dbftlh.lcFolderPairs = aicPtrs / 2;

            tr = WriteDBSegmentHeader(hcf, dwcbDBFolderTwinListHeaderOffset,
                                      &dbftlh, sizeof(dbftlh));

            if (tr == TR_SUCCESS)
               TRACE_OUT((TEXT("WriteFolderPairList(): Wrote %ld folder pairs."),
                          dbftlh.lcFolderPairs));
         }
      }
   }

   return(tr);
}


/*
** ReadFolderPairList()
**
**
**
** Arguments:
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PUBLIC_CODE TWINRESULT ReadFolderPairList(HCACHEDFILE hcf, HBRFCASE hbr,
                                     HHANDLETRANS hhtFolderTrans,
                                     HHANDLETRANS hhtNameTrans)
{
   TWINRESULT tr;
   DBFOLDERTWINLISTHEADER dbftlh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbftlh, sizeof(dbftlh), &dwcbRead) &&
       dwcbRead == sizeof(dbftlh))
   {
      LONG l;

      tr = TR_SUCCESS;

      TRACE_OUT((TEXT("ReadFolderPairList(): Reading %ld folder pairs."),
                 dbftlh.lcFolderPairs));

      for (l = 0; l < dbftlh.lcFolderPairs && tr == TR_SUCCESS; l++)
         tr = ReadFolderPair(hcf, hbr, hhtFolderTrans, hhtNameTrans);

      ASSERT(tr != TR_SUCCESS || AreFolderPairsValid(GetBriefcaseFolderPairPtrArray(hbr)));
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


/***************************** Exported Functions ****************************/


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | AddFolderTwin | Twins two folders.

@parm HBRFCASE | hbr | A handle to the open briefcase that the new folder twins
are to be added to.

@parm PCNEWFOLDERTWIN | pcnft | A pointer to a CNEWFOLDERTWIN describing the
two folders to be twinned.

@parm PHFOLDERTWIN | phft | A pointer to an HFOLDERTWIN to be filled in with
a handle to the new folder twins.  *phft is only valid if TR_SUCCESS or
TR_DUPLICATE_TWIN is returned.

@rdesc If the folder twins were added successfully, TR_SUCCESS is returned, and
*phFolderTwin contains a handle to the new folder twins.  Otherwise, the
folder twins were not added successfully, the return value indicates the error
that occurred, and *phFolderTwin is undefined.  If one or both of the volumes
specified by the NEWFOLDERTWIN structure is not present, TR_UNAVAILABLE_VOLUME
will be returned, and the folder twin will not be added.


@comm Once the caller is finshed with the twin handle returned by
AddFolderTwin(), ReleaseTwinHandle() should be called to release the twin
handle.  N.b., DeleteTwin() does not release a twin handle returned by
AddFolderTwin().

@xref ReleaseTwinHandle DeleteTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI AddFolderTwin(HBRFCASE hbr, PCNEWFOLDERTWIN pcnft,
                                           PHFOLDERTWIN phft)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(AddFolderTwin);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_STRUCT_PTR(pcnft, CNEWFOLDERTWIN) &&
          EVAL(pcnft->ulSize == sizeof(*pcnft)) &&
          IS_VALID_WRITE_PTR(phft, HFOLDERTWIN))
#endif
      {
         INEWFOLDERTWIN inft;

         InvalidatePathListInfo(GetBriefcasePathList(hbr));

         tr = MakeINewFolderTwin(hbr, pcnft, &inft);

         if (tr == TR_SUCCESS)
         {
            PFOLDERPAIR pfp;

            ASSERT(! IS_ATTR_DIR(pcnft->dwAttributes));

            tr = TwinFolders(&inft, &pfp);

            if (tr == TR_SUCCESS ||
                tr == TR_DUPLICATE_TWIN)
            {
               LockStub(&(pfp->stub));

               *phft = (HFOLDERTWIN)pfp;
            }

            ReleaseINewFolderTwin(&inft);
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(AddFolderTwin, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | IsFolderTwin | Determines whether or not a folder is a
   folder twin.

@parm HBRFCASE | hbr | A handle to the open briefcase to check for the folder
twin.

@parm PCSTR | pcszFolder | A pointer to a string indicating the folder in
question.

@parm PBOOL | pbIsFolderTwin | A pointer to a BOOL to be filled in with TRUE
if the folder is a folder twin, or FALSE if not.  *pbIsFolderTwin is only
valid if TR_SUCCESS is returned.

@rdesc If the lookup was successful, TR_SUCCESS is returned.  Otherwise, the
lookup was not successful, and the return value indicates the error that
occurred.

@xref CreateFolderTwinList DestroyFolderTwinList

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI IsFolderTwin(HBRFCASE hbr, LPCTSTR pcszFolder,
                                          PBOOL pbIsFolderTwin)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(IsFolderTwin);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_STRING_PTR(pcszFolder, CSTR) &&
          IS_VALID_WRITE_PTR(pbIsFolderTwin, BOOL))
#endif
      {
         HPATH hpath;

         InvalidatePathListInfo(GetBriefcasePathList(hbr));

         tr = TranslatePATHRESULTToTWINRESULT(
               AddPath(GetBriefcasePathList(hbr), pcszFolder, &hpath));

         if (tr == TR_SUCCESS)
         {
            ARRAYINDEX aiFirst;

            /* Search for folder pair referencing given folder. */

            *pbIsFolderTwin = SearchSortedArray(
                                       GetBriefcaseFolderPairPtrArray(hbr),
                                       &FolderPairSearchCmp, hpath, &aiFirst);

            if (*pbIsFolderTwin)
               TRACE_OUT((TEXT("IsFolderTwin(): %s is a folder twin."),
                          DebugGetPathString(hpath)));
            else
               TRACE_OUT((TEXT("IsFolderTwin(): %s is not a folder twin."),
                          DebugGetPathString(hpath)));

            DeletePath(hpath);
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(IsFolderTwin, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | CreateFolderTwinList | Creates a list of the folder twins of
a given folder.

@parm HBRFCASE | hbr | A handle to the open briefcase that the folder twin list
is to be created from.

@parm PCSTR | pcszFolder | A pointer to a string indicating the folder whose
folder twins are to be listed.

@parm PFOLDERTWINLIST | ppftl | A pointer to an PFOLDERTWINLIST to be
filled in with a pointer to the new list of folder twins.  *ppFolderTwinList
is only valid if TR_SUCCESS is returned.

@rdesc If the folder twin list was created successfully, TR_SUCCESS is
returned.  Otherwise, the folder twin list was not created successfully, and
the return value indicates the error that occurred.

@xref DestroyFolderTwinList IsFolderTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI CreateFolderTwinList(HBRFCASE hbr,
                                                  LPCTSTR pcszFolder,
                                                  PFOLDERTWINLIST *ppftl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(CreateFolderTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_HANDLE(hbr, BRFCASE) &&
          IS_VALID_STRING_PTR(pcszFolder, CSTR) &&
          IS_VALID_WRITE_PTR(ppftl, PFOLDERTWINLIST))
#endif
      {
         HPATH hpath;

         InvalidatePathListInfo(GetBriefcasePathList(hbr));

         tr = TranslatePATHRESULTToTWINRESULT(
               AddPath(GetBriefcasePathList(hbr), pcszFolder, &hpath));

         if (tr == TR_SUCCESS)
         {
            PFOLDERTWINLIST pftlNew;

            /* Try to create a new folder twin list. */

            if (AllocateMemory(sizeof(*pftlNew), &pftlNew))
            {
               ARRAYINDEX ai;

               /* Initialize FOLDERTWINLIST structure fields. */

               pftlNew->ulcItems = 0;
               pftlNew->pcftFirst = NULL;
               pftlNew->hbr = hbr;

               /* Search for first folder pair referencing given folder. */

               if (SearchSortedArray(GetBriefcaseFolderPairPtrArray(hbr),
                                     &FolderPairSearchCmp, hpath, &ai))
               {
                  PFOLDERTWIN pftHead;
                  ARRAYINDEX aicFolderTwins;

                  tr = CreateListOfFolderTwins(hbr, ai, hpath, &pftHead, &aicFolderTwins);

                  if (tr == TR_SUCCESS)
                  {
                     /* Success!  Update parent folder twin list fields. */

                     pftlNew->pcftFirst = pftHead;
                     pftlNew->ulcItems = aicFolderTwins;
                  }
                  else
                     /* Free data structure, ignoring return value. */
                     FreeMemory(pftlNew);
               }
               else
                  tr = TR_SUCCESS;

               /* Return pointer to new FOLDERTWINLIST. */

               if (tr == TR_SUCCESS)
               {
                  *ppftl = pftlNew;

                  ASSERT(IS_VALID_STRUCT_PTR(*ppftl, CFOLDERTWINLIST));
               }
            }
            else
               tr = TR_OUT_OF_MEMORY;

            DeletePath(hpath);
         }
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(CreateFolderTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}


/******************************************************************************

@doc SYNCENGAPI

@api TWINRESULT | DestroyFolderTwinList | Destroys a folder twin list created
by CreateFolderTwinList().

@parm PFOLDERTWINLIST | pftl | A pointer to the folder twin list to be
destroyed.  The FOLDERTWINLIST pointed to by pftl is not valid after
DestroyFolderTwinList() is called.

@rdesc If the folder twin list was deleted successfully, TR_SUCCESS is
returned.  Otherwise, the folder twin list was not deleted successfully, and
the return value indicates the error that occurred.

@xref CreateFolderTwinList IsFolderTwin

******************************************************************************/

SYNCENGAPI TWINRESULT WINAPI DestroyFolderTwinList(PFOLDERTWINLIST pftl)
{
   TWINRESULT tr;

   if (BeginExclusiveBriefcaseAccess())
   {
      DebugEntry(DestroyFolderTwinList);

#ifdef EXPV
      /* Verify parameters. */

      if (IS_VALID_STRUCT_PTR(pftl, CFOLDERTWINLIST))
#endif
      {
         DestroyListOfFolderTwins((PFOLDERTWIN)(pftl->pcftFirst));
         FreeMemory(pftl);

         tr = TR_SUCCESS;
      }
#ifdef EXPV
      else
         tr = TR_INVALID_PARAMETER;
#endif

      DebugExitTWINRESULT(DestroyFolderTwinList, tr);

      EndExclusiveBriefcaseAccess();
   }
   else
      tr = TR_REENTERED;

   return(tr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\inifile.h ===
/*
 * inifile.h - Initialization file processing module description.
 */


/* Types
 ********/

#ifdef DEBUG

/* .ini switch types */

typedef enum _iniswitchtype
{
   IST_BOOL,
   IST_DEC_INT,
   IST_UNS_DEC_INT
}
INISWITCHTYPE;
DECLARE_STANDARD_TYPES(INISWITCHTYPE);

/* boolean .ini switch */

typedef struct _booliniswitch
{
   INISWITCHTYPE istype;      /* must be IST_BOOL */

   LPCTSTR pcszKeyName;

   PDWORD pdwParentFlags;

   DWORD dwFlag;
}
BOOLINISWITCH;
DECLARE_STANDARD_TYPES(BOOLINISWITCH);

/* decimal integer .ini switch */

typedef struct _decintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_DEC_INT */

   LPCTSTR pcszKeyName;

   PINT pnValue;
}
DECINTINISWITCH;
DECLARE_STANDARD_TYPES(DECINTINISWITCH);

/* unsigned decimal integer .ini switch */

typedef struct _unsdecintiniswitch
{
   INISWITCHTYPE istype;      /* must be IST_UNS_DEC_INT */

   LPCTSTR pcszKeyName;

   PUINT puValue;
}
UNSDECINTINISWITCH;
DECLARE_STANDARD_TYPES(UNSDECINTINISWITCH);

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* defined by client */

extern LPCTSTR GpcszIniFile;
extern LPCTSTR GpcszIniSection;

#endif


/* Prototypes
 *************/

#ifdef DEBUG

/* inifile.c */

extern BOOL SetIniSwitches(const PCVOID *, UINT);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\brfcase\filesync\core\inifile.c ===
/*
 * inifile.c - Initialization file processing module.
 */


/* Headers
 **********/

#include "project.h"
#pragma hdrstop


/* Constants
 ************/

/* maximum length of .ini switch RHS */

#define MAX_INI_SWITCH_RHS_LEN      MAX_PATH_LEN


/* Module Variables
 *******************/

#ifdef DEBUG

/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

PRIVATE_DATA const LPCTSTR MrgcpcszTrue[] =
{
    TEXT("1"),
    TEXT("On"),
    TEXT("True"),
    TEXT("Y"),
    TEXT("Yes")
};

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

PRIVATE_DATA const LPCTSTR MrgcpcszFalse[] =
{
    TEXT("0"),
    TEXT("Off"),
    TEXT("False"),
    TEXT("N"),
    TEXT("No")
};

#endif


/***************************** Private Functions *****************************/

/* Module Prototypes
 ********************/

#ifdef DEBUG

PRIVATE_CODE BOOL SetBOOLIniSwitch(PCBOOLINISWITCH);
PRIVATE_CODE BOOL SetDecimalIntIniSwitch(PCDECINTINISWITCH);
PRIVATE_CODE BOOL SetIniSwitch(PCVOID);
PRIVATE_CODE BOOL IsYesString(LPCTSTR);
PRIVATE_CODE BOOL IsNoString(LPCTSTR);
PRIVATE_CODE BOOL IsStringInList(LPCTSTR, const LPCTSTR *, UINT);
PRIVATE_CODE BOOL IsValidPCBOOLINISWITCH(PCBOOLINISWITCH);
PRIVATE_CODE BOOL IsValidPCDECINTINISWITCH(PCDECINTINISWITCH);
PRIVATE_CODE BOOL IsValidPCUNSDECINTINISWITCH(PCUNSDECINTINISWITCH);

#endif


#ifdef DEBUG

/*
 ** SetBOOLIniSwitch()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL SetBOOLIniSwitch(PCBOOLINISWITCH pcbis)
{
    DWORD dwcbKeyLen;
    TCHAR rgchRHS[MAX_INI_SWITCH_RHS_LEN];

    ASSERT(IS_VALID_STRUCT_PTR(pcbis, CBOOLINISWITCH));

    /* Set boolean .ini switch. */

    dwcbKeyLen = GetPrivateProfileString(GpcszIniSection, pcbis->pcszKeyName,
            TEXT(""), rgchRHS, ARRAYSIZE(rgchRHS),
            GpcszIniFile);

    /* Is the .ini switch set? */

    if (rgchRHS[0])
    {
        /* Yes.  Set or clear flag? */

        if (IsYesString(rgchRHS))
        {
            /* Set flag. */

            if (IS_FLAG_CLEAR(*(pcbis->pdwParentFlags), pcbis->dwFlag))
            {
                SET_FLAG(*(pcbis->pdwParentFlags), pcbis->dwFlag);

                WARNING_OUT((TEXT("SetBOOLIniSwitch(): %s set in %s![%s]."),
                            pcbis->pcszKeyName,
                            GpcszIniFile,
                            GpcszIniSection));
            }
        }
        else if (IsNoString(rgchRHS))
        {
            /* Clear flag. */

            if (IS_FLAG_SET(*(pcbis->pdwParentFlags), pcbis->dwFlag))
            {
                CLEAR_FLAG(*(pcbis->pdwParentFlags), pcbis->dwFlag);

                WARNING_OUT((TEXT("SetBOOLIniSwitch(): %s cleared in %s![%s]."),
                            pcbis->pcszKeyName,
                            GpcszIniFile,
                            GpcszIniSection));
            }
        }
        else
            /* Unknown flag. */
            WARNING_OUT((TEXT("SetBOOLIniSwitch(): Found unknown Boolean RHS %s for %s in %s![%s]."),
                        rgchRHS,
                        pcbis->pcszKeyName,
                        GpcszIniFile,
                        GpcszIniSection));
    }

    return(TRUE);
}


/*
 ** SetDecimalIntIniSwitch()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL SetDecimalIntIniSwitch(PCDECINTINISWITCH pcdiis)
{
    UINT nNewValue;

    ASSERT(IS_VALID_STRUCT_PTR(pcdiis, CDECINTINISWITCH));

    /* Get decimal integer .ini switch. */

    nNewValue = GetPrivateProfileInt(GpcszIniSection, pcdiis->pcszKeyName,
            *(pcdiis->pnValue), GpcszIniFile);

    /* New value? */

    if (nNewValue != *(pcdiis->pnValue))
    {
        /* Yes. */

        *(pcdiis->pnValue) = nNewValue;

        WARNING_OUT((TEXT("SetDecimalIntIniSwitch(): %s set to %d in %s![%s]."),
                    pcdiis->pcszKeyName,
                    *(pcdiis->pnValue),
                    GpcszIniFile,
                    GpcszIniSection));
    }

    return(TRUE);
}


/*
 ** SetUnsignedDecimalIntIniSwitch()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL SetUnsignedDecimalIntIniSwitch(PCUNSDECINTINISWITCH pcudiis)
{
    INT nNewValue;

    ASSERT(IS_VALID_STRUCT_PTR(pcudiis, CUNSDECINTINISWITCH));

    /* Get unsigned decimal integer .ini switch as signed decimal integer. */

    ASSERT(*(pcudiis->puValue) <= INT_MAX);

    nNewValue = GetPrivateProfileInt(GpcszIniSection, pcudiis->pcszKeyName,
            *(pcudiis->puValue), GpcszIniFile);

    if (nNewValue >= 0)
    {
        if ((UINT)nNewValue != *(pcudiis->puValue))
        {
            /* New non-negative value. */

            *(pcudiis->puValue) = nNewValue;

            WARNING_OUT((TEXT("SetUnsignedDecimalIntIniSwitch(): %s set to %u in %s![%s]."),
                        pcudiis->pcszKeyName,
                        *(pcudiis->puValue),
                        GpcszIniFile,
                        GpcszIniSection));
        }
    }
    else
        /* Negative value. */
        WARNING_OUT((TEXT("SetUnsignedDecimalIntIniSwitch(): Unsigned value %s set to %d in %s![%s].  Ignored."),
                    pcudiis->pcszKeyName,
                    nNewValue,
                    GpcszIniFile,
                    GpcszIniSection));

    return(TRUE);
}


/*
 ** SetIniSwitch()
 **
 ** 
 **
 ** Arguments:
 **
 ** Returns:
 **
 ** Side Effects:  none
 */
PRIVATE_CODE BOOL SetIniSwitch(PCVOID pcvIniSwitch)
{
    BOOL bResult;

    ASSERT(IS_VALID_READ_PTR((PCINISWITCHTYPE)pcvIniSwitch, CINISWITCHTYPE));

    /* Set .ini switch based upon type. */

    switch (*(PCINISWITCHTYPE)pcvIniSwitch)
    {
        case IST_BOOL:
            bResult = SetBOOLIniSwitch(pcvIniSwitch);
            break;

        case IST_DEC_INT