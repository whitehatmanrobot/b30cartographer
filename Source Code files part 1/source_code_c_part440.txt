( &Host, HostBuffer );
            Host.MaximumLength = MAX_PATH;
        }

        if ( addSPN )
        {
            Operation = DS_SPN_ADD_SPN_OP;
        }

        if ( deleteSPN )
        {
            Operation = DS_SPN_DELETE_SPN_OP;
        }

        if ( AddRemoveSpn( &HostSpn, &HostDomain, &Host, Operation) )
        {
            printf("Updated object\n");
            Status = 0;
        }
    }
    else if ( listSPN )
    {
        WCHAR HostBuffer[MAX_PATH];

        if ( ( argc - i ) != 1 )
        {
            Usage( argv[0] );
        }

        Scan = argv[ i  ];

        if ( Scan = wcschr( Scan, L'\\' ) )
        {
            *Scan++ = L'\0';
            RtlInitUnicodeString( &HostDomain, argv[i] );
            wcsncpy( HostBuffer, Scan, MAX_PATH-1 );
            HostBuffer[MAX_PATH-2] = L'\0';
            RtlInitUnicodeString( &Host, HostBuffer );
            Host.MaximumLength = MAX_PATH;
        }
        else
        {
            RtlInitUnicodeString( &HostDomain, L"" );
            wcsncpy( HostBuffer, argv[i], MAX_PATH-1 );
            HostBuffer[MAX_PATH-2] = L'\0';
            RtlInitUnicodeString( &Host, HostBuffer );
            Host.MaximumLength = MAX_PATH;
        }

        if (LookupHostSpn( &HostDomain, &Host ))
        {
            Status = 0;
        }
    }

    ExitProcess(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\syskey\makefile.inc ===
res.rc: dialogs.dlg strings.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\syskey\dialogs.h ===
#define IDD_MAIN_DIALOG             100
#define IDD_MAIN_ICON               101
#define IDD_MAIN_TEXT_1             102
#define IDD_MAIN_TEXT_2             103
#define IDD_MAIN_DISABLED           104
#define IDD_MAIN_ENABLED            105
#define IDD_MAIN_UPDATE             106
#define IDD_PASSWORD_DLG            200
#define IDD_PW_GROUP_1              201
#define IDD_PW_PASSWORD_BTN         202
#define IDD_PW_PW_TEXT              203
#define IDD_PW_PW_LABEL             204
#define IDD_PW_PASSWORD             205
#define IDD_PW_CONFIRM_LABEL        206
#define IDD_PW_CONFIRM              207
#define IDD_PW_GROUP_2              208
#define IDD_PW_AUTO                 209
#define IDD_PW_FLOPPY               210
#define IDD_PW_STORE_LOCAL          211
#define IDD_PW_FLOPPY_TEXT          212
#define IDD_PW_LOCAL_TEXT           213

#define IDD_SECURE_BOOT             900
#define IDD_SB_TEXT_1               901
#define IDD_SB_PW_LABEL             902
#define IDD_SB_PASSWORD             903
#define IDD_SB_PW_ICON              904
#define IDD_SECURE_BOOT_DISK        910
#define IDD_SB_DISK_TEXT            911
#define IDD_SB_DISK_TEXT2           912
#define IDD_SB_DISK_ICON            913

#define IDD_SB_ICON_PW              920
#define IDD_SB_ICON_DISK            921
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\syskey\miscid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       miscid.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#define LOCK_ICON   1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\syskey\samlock.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       samlock.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SAMLOCK_H__
#define __SAMLOCK_H__


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>
#include <caiseapi.h>

#include <windows.h>
#include <md5.h>

#include <wxlpc.h>

#include "dialogs.h"
#include "miscid.h"
#include "strings.h"
#include <crypt.h>



#endif //__SAMLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\stampdns\stampdns.c ===
/*--

Copyright (c) 1997-1997  Microsoft Corporation

Module Name:

    trustdom.c

Abstract:

    Command line tool for linking 2 domains

Author:

    1-Apr-1997   Mac McLain (macm)   Created

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <stdio.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <dnsapi.h>

#define PARENT_TAG "-parent:"
#define PARENT_TAG_LEN  (sizeof( PARENT_TAG ) - 1)

typedef struct _TD_DOM_INFO {

    LSA_HANDLE Policy;
    LSA_HANDLE TrustedDomain;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo;

} TD_DOM_INFO, *PTD_DOM_INFO;

BOOLEAN Dbg = FALSE;

VOID
Usage (
    VOID
    )
/*++

Routine Description:

    Displays the expected usage

Arguments:

Return Value:

    VOID

--*/
{
    printf("stampdns [dns_domain_name] [-parent:parent_server_name]\n");
}


NTSTATUS
GetDomainInfoForDomain(
    IN PWSTR    DomainName,
    IN PTD_DOM_INFO Info
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD dwErr;
    UNICODE_STRING Domain;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PDOMAIN_CONTROLLER_INFO DCInfo = NULL;

    if ( DomainName != NULL ) {

        dwErr = DsGetDcName( NULL, (LPCWSTR)DomainName, NULL, NULL,
                             DS_DIRECTORY_SERVICE_REQUIRED, &DCInfo );

        if ( dwErr == ERROR_SUCCESS ) {

            RtlInitUnicodeString( &Domain, DCInfo->DomainControllerName + 2 );

        } else {

            Status = STATUS_UNSUCCESSFUL;

        }

    }

    if ( NT_SUCCESS( Status ) ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = LsaOpenPolicy( DomainName == NULL ? NULL : &Domain,
                                &ObjectAttributes,
                                MAXIMUM_ALLOWED,
                                &Info->Policy
                                );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaQueryInformationPolicy( Info->Policy,
                                                PolicyDnsDomainInformation,
                                                &(Info->DnsDomainInfo )
                                                );

        }

    #if DBG
        if ( Dbg ) {

            printf( "GetDomainInfoForDomain on %ws returned 0x%lx\n", DomainName, Status );
        }
    #endif

    }

    NetApiBufferFree( DCInfo );

    return( Status );
}


VOID
FreeDomainInfo(
    IN PTD_DOM_INFO Info
    )
{
    if ( Info->DnsDomainInfo != NULL ) {

        LsaFreeMemory( Info->DnsDomainInfo );
    }

    if ( Info->Policy ) {

        LsaClose( Info->Policy );
    }

}


INT
__cdecl main (
    int argc,
    char *argv[])
/*++

Routine Description:

    The main the for this executable

Arguments:

    argc - Count of arguments
    argv - List of arguments

Return Value:

    VOID

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR  Buffer[MAX_PATH + 1];
    PWSTR  Server = NULL, DnsName = NULL;
    INT i;
    TD_DOM_INFO Local, Remote;


    RtlZeroMemory( &Local, sizeof( TD_DOM_INFO ) );
    RtlZeroMemory( &Remote, sizeof (TD_DOM_INFO ) );

    if (argc < 2 ) {

        Usage();
        goto Done;

    } else {

        if ( _stricmp( argv[1], "-?") == 0 ) {

            Usage();
            goto Done;

        } else {

            if ( _strnicmp( argv[1], PARENT_TAG, PARENT_TAG_LEN ) == 0 ) {

                mbstowcs( Buffer, argv[1] + PARENT_TAG_LEN , strlen( argv[1] ) - PARENT_TAG_LEN + 1 );
                Server = Buffer;

            } else {

                mbstowcs(Buffer, argv[1], strlen(argv[1]) + 1 );
                DnsName = Buffer;

            }


        }
    }


    Status = GetDomainInfoForDomain( NULL, &Local );

    if ( NT_SUCCESS( Status ) && Server ) {

        Status = GetDomainInfoForDomain( Server, &Remote );
    }

    if ( !NT_SUCCESS( Status ) ) {

        goto Done;
    }

    if ( DnsName ) {

        RtlInitUnicodeString( &Local.DnsDomainInfo->DnsForestName, DnsName );
        RtlInitUnicodeString( &Local.DnsDomainInfo->DnsDomainName, DnsName );

    } else {

        RtlCopyMemory( &Local.DnsDomainInfo->DnsForestName, &Remote.DnsDomainInfo->DnsForestName,
                       sizeof( UNICODE_STRING ) );
    }

    Status = DnsValidateDnsName_W(Local.DnsDomainInfo->DnsForestName.Buffer );
    if ( Status != 0 ) {

        printf( "Stampdns required a valid Dns name.  %wZ is not a valid Dns name\n",
                &Local.DnsDomainInfo->DnsForestName );

    } else {

        printf( "Setting DnsForestName to %wZ\n", &Local.DnsDomainInfo->DnsForestName );
        Status = LsaSetInformationPolicy( Local.Policy,
                                          PolicyDnsDomainInformation,
                                          Local.DnsDomainInfo );

    }

Done:

    FreeDomainInfo( &Local );
    FreeDomainInfo( &Remote );

    if( NT_SUCCESS( Status ) ) {

        printf("The command completed successfully\n");

    } else {

        printf("The command failed with an error 0x%lx\n", Status );

    }

    return( NT_SUCCESS( Status ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\syskey\samlock.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       samlock.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "samlock.h"
#include <stdio.h>
#include <wchar.h>



#if DBG
#define HIDDEN
#else
#define HIDDEN static
#endif


#define MAKE_SAM_CALLS 1

#if MAKE_SAM_CALLS
#define SYSTEM_KEY  TEXT("SecureBoot")
#else
#define SYSTEM_KEY  TEXT("BootType")
#endif

#define KEYFILE         TEXT("A:\\StartKey.Key")
#define KEYFILE_SAVE    TEXT("A:\\StartKey.Bak")


HICON   hLockIcon ;
HICON   KeyDataPwIcon ;
HICON   KeyDataDiskIcon ;
SAMPR_BOOT_TYPE SecureBootOption = 0;
SAMPR_BOOT_TYPE OriginalBootOption = 0 ;
SAM_HANDLE SamHandle ;
SAM_HANDLE DomainHandle ;
HKEY    LsaKey ;
HCURSOR hcurArrow ;
HCURSOR hcurWait ;
BOOL    WaitCursor ;

WCHAR   OptionL[ 4 ];   // Unattended, local store
WCHAR   OptionQ[ 4 ];   // Question (usage)
BOOL    Unattended = FALSE ;

DWORD PwSection[] = { IDD_PW_PW_TEXT, IDD_PW_PW_LABEL, IDD_PW_PASSWORD,
                 IDD_PW_CONFIRM_LABEL, IDD_PW_CONFIRM };

DWORD GenSection[]= { IDD_PW_FLOPPY, IDD_PW_STORE_LOCAL, IDD_PW_FLOPPY_TEXT,
                  IDD_PW_LOCAL_TEXT };


typedef WXHASH HASH, *PHASH;

BOOL ObfuscateKey(PHASH H)
{
    return(NT_SUCCESS(WxSaveSysKey(sizeof(H->Digest),&H->Digest)));
}

BOOL DeobfuscateKey(PHASH H)
{
    ULONG KeyLen = sizeof(H->Digest);

    return(NT_SUCCESS(WxReadSysKey(&KeyLen,&H->Digest)));
}

#if MAKE_SAM_CALLS
#define xSamiGetBootKeyInformation  SamiGetBootKeyInformation
#define xSamiSetBootKeyInformation  SamiSetBootKeyInformation
#else


NTSTATUS
xSamiGetBootKeyInformation(
    SAM_HANDLE Domain,
    SAMPR_BOOT_TYPE * BootType
    )
{
    DWORD Type ;
    DWORD Length ;
    int Result ;

    Length = sizeof( SAMPR_BOOT_TYPE );

    Result = RegQueryValueEx( LsaKey,
                              TEXT("SamiSetting"),
                              0,
                              &Type,
                              (PUCHAR) BootType,
                              &Length );

    if ( Result == 0 )
    {
        NOTHING ;
    }
    else
    {
        *BootType = SamBootKeyNone ;
    }

    return STATUS_SUCCESS ;
}

NTSTATUS
xSamiSetBootKeyInformation(
    SAM_HANDLE Domain,
    SAMPR_BOOT_TYPE BootType,
    PUNICODE_STRING Old,
    PUNICODE_STRING New
    )
{
    DWORD Type ;
    DWORD Length ;
    HASH Hash ;
    int Result ;

    Length = 16 ;

    Result = RegQueryValueEx(   LsaKey,
                                TEXT("SamiKey"),
                                0,
                                &Type,
                                Hash.Digest,
                                &Length );

    if ( Result == 0 )
    {
        if (!RtlEqualMemory( Hash.Digest, Old->Buffer, 16 ) )
        {
            return STATUS_WRONG_PASSWORD ;
        }

    }

    RegSetValueEx( LsaKey,
                   TEXT("SamiKey"),
                   0,
                   REG_BINARY,
                   (PUCHAR) New->Buffer,
                   16 );

    RegSetValueEx( LsaKey,
                   TEXT("SamiSetting"),
                   0,
                   REG_DWORD,
                   (PUCHAR) &BootType,
                   sizeof( DWORD ) );

    return STATUS_SUCCESS ;
}



#endif

BOOL
SetupCursor(
    BOOL fWait
    )
{
    BOOL Current ;

    if ( hcurArrow == NULL )
    {
        hcurArrow = LoadCursor( NULL, IDC_ARROW );
    }

    if ( hcurWait == NULL )
    {
        hcurWait = LoadCursor( NULL, IDC_WAIT );
    }

    if ( WaitCursor != fWait )
    {
        SetCursor( fWait ? hcurWait : hcurArrow );

        Current = WaitCursor ;

        WaitCursor = fWait ;
    }
    else
    {
        Current = fWait ;
    }

    return Current ;
}

int
MyMessageBox(
    HWND hWnd,
    int Text,
    int Caption,
    UINT Flags
    )
{
    WCHAR String1[ MAX_PATH ];
    WCHAR String2[ MAX_PATH ];
    int Result ;
    BOOL Cursor ;

    LoadString( GetModuleHandle(NULL), Caption, String1, MAX_PATH );
    LoadString( GetModuleHandle(NULL), Text, String2, MAX_PATH );

    Cursor = SetupCursor( FALSE );

    Result = MessageBox( hWnd, String2, String1, Flags );

    SetupCursor( Cursor );

    return Result ;
}

int
DisplayError(
    HWND hWnd,
    int Description,
    int Error
    )
{
    TCHAR Message[ MAX_PATH ];
    TCHAR Caption[ MAX_PATH ];
    TCHAR Descr[ MAX_PATH ];
    int Result ;
    BOOL Cursor ;

    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   Error,
                   0,
                   Message,
                   MAX_PATH,
                   NULL );

    LoadString( GetModuleHandle( NULL ), Description, Caption, MAX_PATH );
    wsprintf( Descr, Caption, Message );

    LoadString( GetModuleHandle( NULL ), IDS_ERROR_CAPTION, Caption, MAX_PATH );

    Cursor = SetupCursor( FALSE );

    Result = MessageBox( hWnd, Message, Caption, MB_ICONSTOP | MB_OK );

    SetupCursor( Cursor );

    return Result ;

}

VOID
DisplayErrorAndExit(
    HWND hWnd,
    int Description,
    int Error
    )
{
    DisplayError( hWnd, Description, Error );

    ExitProcess( Error );
}

VOID
EnableSection(
    HWND hDlg,
    BOOL Enable,
    PDWORD IdList,
    DWORD Count
    )
{
    DWORD i ;
    for ( i = 0 ; i < Count ; i++ )
    {
        EnableWindow( GetDlgItem( hDlg, IdList[ i ]), Enable );
    }
}


NTSTATUS
SbLoadKeyFromDisk(
    PUCHAR KeyDataBuffer
    )
{
    HANDLE  hFile ;
    ULONG Actual ;
    ULONG ErrorMode ;

    ErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

    SetupCursor( TRUE );


    hFile = CreateFileA( "A:\\startkey.key",
                         GENERIC_READ,
                         0,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );



    if ( hFile == INVALID_HANDLE_VALUE )
    {
        SetErrorMode( ErrorMode );

        SetupCursor( FALSE );

        return STATUS_OBJECT_NAME_NOT_FOUND ;
    }

    if (!ReadFile( hFile, KeyDataBuffer, 16, &Actual, NULL ) ||
        (Actual != 16 ))
    {
        SetErrorMode( ErrorMode );

        CloseHandle( hFile );

        SetupCursor( FALSE );

        return STATUS_FILE_CORRUPT_ERROR ;

    }

    SetErrorMode( ErrorMode );

    CloseHandle( hFile );

    SetupCursor( FALSE );

    return STATUS_SUCCESS ;
}

DWORD
SaveKeyToDisk(
    HWND hDlg,
    PUCHAR Key
    )
{
    HANDLE  hFile ;
    ULONG Actual ;
    ULONG ErrorMode ;
    DWORD Error ;

    ErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

    SetupCursor( TRUE );

    hFile = CreateFile( KEYFILE,
                         GENERIC_WRITE,
                         0,
                         NULL,
                         CREATE_NEW,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        Error = GetLastError() ;

        if ( Error == ERROR_FILE_EXISTS )
        {
            //
            // This we can handle.
            //

            (VOID) DeleteFile( KEYFILE_SAVE );

            if ( !MoveFile( KEYFILE, KEYFILE_SAVE ) )
            {
                Error = GetLastError() ;
            }
            else
            {
                hFile = CreateFile( KEYFILE,
                                    GENERIC_WRITE,
                                    0,
                                    NULL,
                                    CREATE_NEW,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL );

                if ( hFile == INVALID_HANDLE_VALUE )
                {
                    Error = GetLastError() ;
                }
                else
                {
                    MyMessageBox( hDlg, IDS_RENAMED_OLD,
                                    IDS_WARNING_CAPTION,
                                    MB_OK | MB_ICONINFORMATION );
                    Error = 0 ;
                }
            }

        }

        if ( Error )
        {

            SetErrorMode( ErrorMode );

            SetupCursor( FALSE );

            return Error ;
        }
    }

    if (!WriteFile( hFile, Key, 16, &Actual, NULL ) ||
        (Actual != 16 ))
    {
        SetErrorMode( ErrorMode );

        CloseHandle( hFile );

        SetupCursor( FALSE );

        return GetLastError() ;

    }

    SetErrorMode( ErrorMode );

    CloseHandle( hFile );

    SetupCursor( FALSE );

    return 0 ;

}

LRESULT
ValidateDialog(
    HWND hDlg,
    PSAMPR_BOOT_TYPE Type,
    PHASH NewHash
    )
{
    SAMPR_BOOT_TYPE NewType ;
    WCHAR Password[ MAX_PATH ];
    WCHAR Confirm[ MAX_PATH ];
    PWSTR Scan ;
    DWORD PwLen, ConfLen ;
    BOOL Match ;
    MD5_CTX Md5 ;

    if ( IsDlgButtonChecked( hDlg, IDD_PW_PASSWORD_BTN ) == BST_CHECKED )
    {
        NewType = SamBootKeyPassword ;
    }
    else if ( IsDlgButtonChecked( hDlg, IDD_PW_FLOPPY ) == BST_CHECKED )
    {
        NewType = SamBootKeyDisk ;
    }
    else
    {
        NewType = SamBootKeyStored ;
    }

    *Type = NewType ;

    switch ( NewType )
    {
        case SamBootKeyDisk:
        case SamBootKeyStored:

            if (!RtlGenRandom( NewHash->Digest, 16 ))
            {
                DisplayError( hDlg, IDS_SETPASS_FAILED, ERROR_NOT_ENOUGH_MEMORY);

                return IDCANCEL ;
            }

            break;

        case SamBootKeyPassword:
            PwLen = GetDlgItemText( hDlg, IDD_PW_PASSWORD, Password, MAX_PATH );
            ConfLen = GetDlgItemText( hDlg, IDD_PW_CONFIRM, Confirm, MAX_PATH );

            if ( (PwLen != ConfLen) ||
                 (wcscmp( Password, Confirm ) ) )
            {
                Match = FALSE ;

            }
            else
            {
                Match = TRUE ;
            }

            //
            // Clear the PW from the dialog:
            //

            Scan = Confirm ;
            while ( *Scan != L'\0' )
            {
                *Scan++ = ' ';
            }

            SetDlgItemText( hDlg, IDD_PW_PASSWORD, Confirm );
            SetDlgItemText( hDlg, IDD_PW_CONFIRM, Confirm );
            SetDlgItemText( hDlg, IDD_PW_PASSWORD, L"" );
            SetDlgItemText( hDlg, IDD_PW_CONFIRM, L"" );

            SecureZeroMemory( Confirm, ConfLen * sizeof( WCHAR ) );

            if ( !Match )
            {
                MyMessageBox( hDlg,
                              IDS_NEW_PW_MATCH,
                              IDS_ERROR_CAPTION,
                              MB_OK | MB_ICONSTOP );

                SetFocus( GetDlgItem( hDlg, IDD_PW_PASSWORD ) );

                SecureZeroMemory( Password, PwLen * sizeof( WCHAR ) );

                return IDCANCEL ;
            }

            MD5Init( &Md5 );
            MD5Update( &Md5, (PUCHAR) Password, PwLen * sizeof( WCHAR ) );
            MD5Final( &Md5 );

            SecureZeroMemory( Password, PwLen * sizeof( WCHAR ) );

            CopyMemory( NewHash->Digest, Md5.digest, 16 );

            break;
    }

    return IDOK ;

}

LRESULT
CALLBACK
ConfirmPasswordDlg(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    WCHAR PW[ MAX_PATH ];
    MD5_CTX Md5;
    int PWLen ;
    PUCHAR Hash ;

    switch ( Message )
    {
        case WM_INITDIALOG:
            if ( KeyDataPwIcon == NULL )
            {
                KeyDataPwIcon = LoadImage( GetModuleHandle(NULL),
                                           MAKEINTRESOURCE( IDD_SB_ICON_PW ),
                                           IMAGE_ICON,
                                           64, 72,
                                           LR_DEFAULTCOLOR );

            }

            SendMessage( GetDlgItem( hDlg, IDD_SB_PW_ICON ),
                         STM_SETICON,
                         (WPARAM) KeyDataPwIcon,
                         0 );

            SetWindowLongPtr( hDlg, GWLP_USERDATA, lParam );

            return TRUE ;

        case WM_COMMAND:
            switch ( LOWORD( wParam ) )
            {
                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    return TRUE ;

                case IDOK:

                    // Get text

                    PWLen = GetDlgItemText( hDlg, IDD_SB_PASSWORD, PW, RTL_NUMBER_OF(PW) );

                    // Convert length to bytes

                    PWLen *= sizeof(WCHAR);

                    // hash it

                    MD5Init( &Md5 );
                    MD5Update( &Md5, (PUCHAR) PW, PWLen );
                    MD5Final( &Md5 );

                    // save it

                    Hash = (PUCHAR) GetWindowLongPtr( hDlg, GWLP_USERDATA );

                    CopyMemory( Hash, Md5.digest, 16 );

                    // clean up:

                    EndDialog( hDlg, IDOK );

                    RtlSecureZeroMemory( PW, PWLen );
                    RtlSecureZeroMemory( &Md5, sizeof(Md5) );

                    return TRUE ;
                default:
                    break;

            }
        case WM_CLOSE:
            break;

    }

    return FALSE ;
}


LRESULT
CALLBACK
ConfirmDiskDlg(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    NTSTATUS Status ;
    PUCHAR Hash ;

    switch ( Message )
    {
        case WM_INITDIALOG:
            if ( KeyDataDiskIcon == NULL )
            {
                KeyDataDiskIcon = LoadImage( GetModuleHandle(NULL),
                                           MAKEINTRESOURCE( IDD_SB_ICON_DISK ),
                                           IMAGE_ICON,
                                           64, 72,
                                           LR_DEFAULTCOLOR );

            }

            SendMessage( GetDlgItem( hDlg, IDD_SB_DISK_ICON ),
                         STM_SETICON,
                         (WPARAM) KeyDataDiskIcon,
                         0 );

            SetWindowLongPtr( hDlg, GWLP_USERDATA, lParam );

            return TRUE ;

        case WM_COMMAND:
            switch ( LOWORD( wParam ) )
            {
                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    return TRUE ;

                case IDOK:

                    Hash = (PUCHAR) GetWindowLongPtr( hDlg, GWLP_USERDATA );

                    Status = SbLoadKeyFromDisk( Hash );

                    if ( !NT_SUCCESS( Status ) )
                    {
                        MyMessageBox( hDlg,
                                      IDS_KEYFILE_NOT_FOUND,
                                      IDS_ERROR_CAPTION,
                                      MB_ICONSTOP | MB_OK);

                    }
                    else
                    {
                        EndDialog( hDlg, IDOK );
                    }
                    return TRUE ;
                default:
                    break;

            }
        case WM_CLOSE:
            break;

    }

    return FALSE ;
}




LRESULT
HandleUpdate(
    HWND    hDlg
    )
{
    HASH OldHash ;
    HASH NewHash ;
    SAMPR_BOOT_TYPE NewType ;
    SAMPR_BOOT_TYPE ExtraType ;
    LRESULT Result ;
    NTSTATUS Status ;
    UNICODE_STRING Old ;
    UNICODE_STRING New ;

    Result = ValidateDialog( hDlg, &NewType, &NewHash );

    if ( Result == IDCANCEL )
    {
        return Result ;
    }

    switch ( OriginalBootOption )
    {
        case SamBootKeyNone:
            break;

        case SamBootKeyStored:
            if (!DeobfuscateKey(&OldHash))
            {
                Result = IDCANCEL ;
            }
            break;

        case SamBootKeyPassword:
            Result = DialogBoxParam( GetModuleHandle( NULL ),
                                     MAKEINTRESOURCE( IDD_SECURE_BOOT ),
                                     hDlg,
                                     ConfirmPasswordDlg,
                                     (LPARAM) &OldHash );

            if ( Result == IDCANCEL )
            {
                return Result ;
            }
            break;

        case SamBootKeyDisk:
            Result = DialogBoxParam( GetModuleHandle( NULL ),
                                     MAKEINTRESOURCE( IDD_SECURE_BOOT_DISK ),
                                     hDlg,
                                     ConfirmDiskDlg,
                                     (LPARAM) &OldHash );

            if ( Result == IDCANCEL )
            {
                return Result ;
            }
            break;

    }

    Old.Buffer = (PWSTR) OldHash.Digest ;
    Old.Length = 16 ;
    Old.MaximumLength = 16 ;

    New.Buffer = (PWSTR) NewHash.Digest ;
    New.Length = 16 ;
    New.MaximumLength = 16 ;

    if ( NewType == SamBootKeyDisk )
    {
        ExtraType = SamBootKeyDisk ;
        NewType = SamBootKeyStored ;
    }
    else
    {
        ExtraType = NewType ;
    }

    Status = xSamiSetBootKeyInformation(
                    DomainHandle,
                    NewType,
                    (OriginalBootOption == SamBootKeyNone ? NULL : &Old),
                    &New );


    if ( !NT_SUCCESS( Status ) )
    {
        Result = RtlNtStatusToDosError( Status );

        DisplayError( hDlg, IDS_SETPASS_FAILED, (int) Result );

        return IDCANCEL ;
    }

    Result = RegSetValueEx( LsaKey,
                            SYSTEM_KEY,
                            0,
                            REG_DWORD,
                            (PUCHAR) &NewType,
                            sizeof( NewType ) );

    if ( NewType == SamBootKeyStored )
    {
        ObfuscateKey( &NewHash );
    }


    MyMessageBox( hDlg, IDS_SETPASS_SUCCESS, IDS_SUCCESS_CAPTION,
                    MB_OK | MB_ICONINFORMATION );


    //
    // Switch back to the intended NewType:
    //

    NewType = ExtraType ;


    if ( NewType == SamBootKeyDisk )
    {
        MyMessageBox( hDlg, IDS_INSERT_FLOPPY, IDS_SAVE_KEY_CAPTION,
                        MB_OK | MB_ICONQUESTION );

        Result = SaveKeyToDisk( hDlg, NewHash.Digest );

        while ( Result != 0 )
        {
            MyMessageBox( hDlg, IDS_SAVE_KEY_FAILED, IDS_SAVE_KEY_CAPTION,
                            MB_OK | MB_ICONSTOP );

            Result = SaveKeyToDisk( hDlg, NewHash.Digest );
        }

        //
        // Once the disk has been written successfully, update SAM and the
        // registry with the correct type:
        //

        Status = xSamiSetBootKeyInformation(
                        DomainHandle,
                        NewType,
                        &New,
                        &New );

        if ( NT_SUCCESS( Status ) )
        {
            Result = RegSetValueEx( LsaKey,
                                    SYSTEM_KEY,
                                    0,
                                    REG_DWORD,
                                    (PUCHAR) &NewType,
                                    sizeof( NewType ) );

        }



        MyMessageBox( hDlg, IDS_SAVE_KEY_SUCCESS, IDS_SAVE_KEY_CAPTION,
                                MB_OK | MB_ICONINFORMATION );
    }

    //
    // Now, if the new type isn't Store-local, write some random stuff in
    // there.
    //

    if ( NewType != SamBootKeyStored )
    {
        // no need to check error return since in this case the key is never used
        RtlGenRandom( NewHash.Digest, 16 );
        ObfuscateKey( &NewHash );
    }


    return IDOK ;



}

LRESULT
CALLBACK
UpdateDlg(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    LRESULT Result ;

    switch ( Message )
    {
        case WM_INITDIALOG:
            switch ( SecureBootOption )
            {
                case SamBootKeyPassword:
                    CheckDlgButton( hDlg, IDD_PW_PASSWORD_BTN, BST_CHECKED );
                    CheckDlgButton( hDlg, IDD_PW_STORE_LOCAL, BST_CHECKED );

                    EnableSection( hDlg,
                                   FALSE,
                                   GenSection,
                                   sizeof( GenSection ) /sizeof ( DWORD ) );

                    SetFocus( GetDlgItem( hDlg, IDD_PW_PASSWORD_BTN ) );

                    break;

                case SamBootKeyStored:
                    CheckDlgButton( hDlg, IDD_PW_AUTO, BST_CHECKED );
                    CheckDlgButton( hDlg, IDD_PW_STORE_LOCAL, BST_CHECKED );

                    EnableSection( hDlg,
                                   FALSE,
                                   PwSection,
                                   sizeof( PwSection ) / sizeof( DWORD ) );

                    SetFocus( GetDlgItem( hDlg, IDD_PW_STORE_LOCAL ) );
                    break;

                case SamBootKeyDisk:
                    CheckDlgButton( hDlg, IDD_PW_AUTO, BST_CHECKED );
                    CheckDlgButton( hDlg, IDD_PW_FLOPPY, BST_CHECKED );

                    EnableSection( hDlg,
                                   FALSE,
                                   PwSection,
                                   sizeof( PwSection ) / sizeof( DWORD ) );

                    SetFocus( GetDlgItem( hDlg, IDD_PW_FLOPPY ) );
                    break;

                default:
                    return FALSE ;

            }
            return FALSE ;

        case WM_COMMAND:
            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                    Result = HandleUpdate( hDlg );
                    if ( Result == IDOK )
                    {
                        EndDialog( hDlg, IDOK );
                    }
                    return TRUE ;

                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    return TRUE ;

                case IDD_PW_PASSWORD_BTN:
                    if ( HIWORD( wParam ) == BN_CLICKED )
                    {
                        if ( IsDlgButtonChecked( hDlg, IDD_PW_PASSWORD_BTN )
                                != BST_CHECKED )
                        {
                            break;
                        }
                        EnableSection( hDlg,
                                       TRUE,
                                       PwSection,
                                       sizeof( PwSection ) / sizeof(DWORD) );

                        EnableSection( hDlg,
                                       FALSE,
                                       GenSection,
                                       sizeof( GenSection ) / sizeof( DWORD ) );
                        return TRUE ;
                    }
                    break;

                case IDD_PW_AUTO:
                    if ( HIWORD( wParam ) == BN_CLICKED )
                    {
                        if ( IsDlgButtonChecked( hDlg, IDD_PW_AUTO )
                                != BST_CHECKED )
                        {
                            break;
                        }
                        EnableSection( hDlg,
                                       TRUE,
                                       GenSection,
                                       sizeof( GenSection ) / sizeof( DWORD ) );

                        EnableSection( hDlg,
                                       FALSE,
                                       PwSection,
                                       sizeof( PwSection ) / sizeof( DWORD ) );

                        return TRUE ;
                    }
                    break;

            }
            break;

        default:
            break;
    }
    return FALSE ;
}

LRESULT
CALLBACK
MainDlg(
    HWND    hDlg,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    LRESULT Result ;

    switch ( Message )
    {
        case WM_INITDIALOG:
            if ( hLockIcon == NULL )
            {
                hLockIcon = LoadImage( GetModuleHandle( NULL ),
                                        MAKEINTRESOURCE( LOCK_ICON ),
                                        IMAGE_ICON,
                                        64, 64,
                                        LR_DEFAULTCOLOR );

            }

            SendMessage( GetDlgItem( hDlg, IDD_MAIN_ICON ),
                         STM_SETICON,
                         (WPARAM) hLockIcon,
                         0 );

            if ( SecureBootOption )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_MAIN_DISABLED ), FALSE );
                CheckDlgButton( hDlg, IDD_MAIN_ENABLED, BST_CHECKED );
            }
            else
            {
                EnableWindow( GetDlgItem( hDlg, IDD_MAIN_UPDATE ), FALSE );
                CheckDlgButton( hDlg, IDD_MAIN_DISABLED, BST_CHECKED );
            }

            return TRUE ;

        case WM_COMMAND:
            switch ( LOWORD( wParam ) )
            {
                case IDCANCEL:
                    EndDialog( hDlg, IDOK );
                    return TRUE ;

                case IDOK:
                    if ( IsDlgButtonChecked( hDlg, IDD_MAIN_DISABLED ) ==
                                    BST_CHECKED )
                    {
                        EndDialog( hDlg, IDOK );
                        return TRUE ;
                    }

                    if ( SecureBootOption )
                    {
                        EndDialog( hDlg, IDOK );
                        return TRUE ;
                    }

                    //
                    // Currently disabled, and the user checked enabled, and
                    // pressed OK.  DROP THROUGH to the
                    // Update case.
                    //

                    //
                    // Set default to Local Store:
                    //

                    Result = MyMessageBox( hDlg, IDS_ARE_YOU_SURE,
                                    IDS_ARE_YOU_SURE_CAP,
                                    MB_ICONWARNING | MB_OKCANCEL |
                                    MB_DEFBUTTON2 );

                    if ( Result == IDCANCEL )
                    {
                        return TRUE ;
                    }

                    SecureBootOption = SamBootKeyStored ;

                case IDD_MAIN_UPDATE:
                    Result = DialogBox( GetModuleHandle(NULL),
                               MAKEINTRESOURCE( IDD_PASSWORD_DLG ),
                               hDlg,
                               UpdateDlg
                               );

                    if ( Result == IDOK )
                    {
                        EnableWindow( GetDlgItem( hDlg, IDD_MAIN_DISABLED ), FALSE );
                        CheckDlgButton( hDlg, IDD_MAIN_ENABLED, BST_CHECKED );
                        EndDialog( hDlg, IDOK );

                    }
                    else
                    {
                        SecureBootOption = OriginalBootOption ;
                    }
                    return TRUE ;
            }

        default:
            break;

    }
    return FALSE ;
}

BOOL
UnattendedLocal(
    VOID
    )
{
    HASH OldHash ;
    HASH NewHash ;
    SAMPR_BOOT_TYPE NewType ;
    int Result ;
    NTSTATUS Status ;
    UNICODE_STRING Old ;
    UNICODE_STRING New ;

    Result = 0;

    if ( OriginalBootOption == SamBootKeyStored )
    {
        if ( !DeobfuscateKey( &OldHash ) )
        {
            Result = IDCANCEL ;
        }
    }

    if ( Result == IDCANCEL )
    {
        return FALSE ;
    }

    NewType = SamBootKeyStored ;

    Old.Buffer = (PWSTR) OldHash.Digest ;
    Old.Length = 16 ;
    Old.MaximumLength = 16 ;

    New.Buffer = (PWSTR) NewHash.Digest ;
    New.Length = 16 ;
    New.MaximumLength = 16 ;

    Status = xSamiSetBootKeyInformation(
                    DomainHandle,
                    NewType,
                    (OriginalBootOption == SamBootKeyNone ? NULL : &Old),
                    &New );


    if ( !NT_SUCCESS( Status ) )
    {
        Result = RtlNtStatusToDosError( Status );

        return FALSE ;
    }

    Result = RegSetValueEx( LsaKey,
                            SYSTEM_KEY,
                            0,
                            REG_DWORD,
                            (PUCHAR) &NewType,
                            sizeof( NewType ) );

    ObfuscateKey( &NewHash );

    return TRUE ;

}



DWORD
OpenSamAccountDomain(
    VOID
    )
{
    NTSTATUS Status ;
    UNICODE_STRING String ;
    OBJECT_ATTRIBUTES Obja ;
    LSA_HANDLE LsaHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;
    CAIROSID DomainSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;


    RtlInitUnicodeString( &String, L"" );

    InitializeObjectAttributes( &Obja, NULL, 0, NULL, NULL );

    Status = SamConnect( &String,
                         &SamHandle,
                         MAXIMUM_ALLOWED,
                         &Obja );

    if ( !NT_SUCCESS( Status ) )
    {
        return RtlNtStatusToDosError( Status );

    }

    RtlZeroMemory(&Obja, sizeof(OBJECT_ATTRIBUTES));
    Status = LsaOpenPolicy(
                    &String,
                    &Obja,
                    POLICY_VIEW_LOCAL_INFORMATION,
                    &LsaHandle
                    );
    if (!NT_SUCCESS(Status))
    {
        SamCloseHandle( SamHandle );

        return( RtlNtStatusToDosError( Status ) );

    }
    Status = LsaQueryInformationPolicy(
                    LsaHandle,
                    PolicyAccountDomainInformation,
                    (PVOID *) &DomainInfo
                    );
    if (!NT_SUCCESS(Status))
    {
        LsaClose( LsaHandle);

        SamCloseHandle( SamHandle );

        return( RtlNtStatusToDosError( Status ) );

    }

    RtlCopyMemory(
            &DomainSid,
            DomainInfo->DomainSid,
            RtlLengthSid(DomainInfo->DomainSid)
            );

    LsaFreeMemory(DomainInfo);

    LsaClose( LsaHandle );

    Status = SamOpenDomain(
                SamHandle,
                MAXIMUM_ALLOWED,
                (PSID) &DomainSid,
                &DomainHandle
                );

    return RtlNtStatusToDosError( Status );

}


void
__cdecl
wmain (int argc, WCHAR *argv[])
{
    HKEY    Key ;
    int err ;
    SAMPR_BOOT_TYPE SystemSetting ;
    SAMPR_BOOT_TYPE SamSetting ;
    DWORD Type;
    DWORD Length ;
    NTSTATUS Status ;
    WCHAR MsgBuffer[ MAX_PATH ];


    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                      0,
                      KEY_READ | KEY_WRITE,
                      & Key );

    if ( err )
    {
        DisplayErrorAndExit( NULL, IDS_SYSTEM_ERROR_OCCURRED, err );
    }

    LsaKey = Key ;

    Length = sizeof( SystemSetting );

    err = RegQueryValueEx( Key,
                           SYSTEM_KEY,
                           NULL,
                           &Type,
                           (PUCHAR) &SystemSetting,
                           &Length );

    if ( err )
    {
        SystemSetting = SamBootKeyNone ;
    }

    //
    // Now, compare with SAM:
    //

    err = OpenSamAccountDomain();

    if ( err )
    {
        DisplayErrorAndExit( NULL, IDS_SYSTEM_ERROR_OCCURRED, err );
    }

    Status = xSamiGetBootKeyInformation( DomainHandle,
                                        &SamSetting );

    if ( !NT_SUCCESS( Status ) )
    {
        DisplayErrorAndExit( NULL,
                             IDS_SYSTEM_ERROR_OCCURRED,
                             RtlNtStatusToDosError( Status ) );
    }


    if ( SamSetting != SystemSetting )
    {
        SystemSetting = SamSetting ;

        err = RegSetValueEx( Key,
                             SYSTEM_KEY,
                             0,
                             REG_DWORD,
                             (PUCHAR) &SystemSetting,
                             sizeof( DWORD ) );

        MyMessageBox( NULL, IDS_SAM_NOT_SYNC, IDS_WARNING_CAPTION,
                        MB_ICONHAND | MB_OK );


    }

    SecureBootOption = SamSetting ;

    OriginalBootOption = SamSetting ;

    if ( argc > 1 )
    {
        LoadString( GetModuleHandle( NULL ), IDS_L_OPTION, OptionL, 4 );
        LoadString( GetModuleHandle( NULL ), IDS_Q_OPTION, OptionQ, 4 );
        //
        // Check for unattended:
        //

        if ( (*argv[1] == L'-') ||
             (*argv[1] == L'/') )
        {
            if ( towupper(argv[1][1]) == OptionL[0] )
            {
                Unattended = TRUE ;
            }
        }

    }

    if ( Unattended )
    {
        if ( ( OriginalBootOption == SamBootKeyStored ) ||
             ( OriginalBootOption == SamBootKeyNone ) )
        {
            UnattendedLocal();
        }
        else
        {
            LoadString( GetModuleHandle( NULL ), IDS_NO_UNATTENDED,
                        MsgBuffer, MAX_PATH );

            fprintf( stderr, "%ws\n", MsgBuffer );

        }
    }
    else
    {
        DialogBox(  GetModuleHandle(NULL),
                    MAKEINTRESOURCE( IDD_MAIN_DIALOG ),
                    NULL,
                    MainDlg );

    }



    RegCloseKey( LsaKey );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\syskey\strings.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       strings.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-20-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __STRINGS_H__
#define __STRINGS_H__


#define IDS_SAM_NOT_SYNC            1500
#define IDS_ERROR_CAPTION           1501
#define IDS_SYSTEM_ERROR_OCCURRED   1502
#define IDS_WARNING_CAPTION         1503
#define IDS_NEW_PW_MATCH            1504
#define IDS_KEYFILE_NOT_FOUND       1505
#define IDS_SETPASS_FAILED          1506
#define IDS_SETPASS_SUCCESS         1507
#define IDS_SUCCESS_CAPTION         1508
#define IDS_INSERT_FLOPPY           1509
#define IDS_SAVE_KEY_CAPTION        1510
#define IDS_SAVE_KEY_SUCCESS        1511
#define IDS_SAVE_KEY_FAILED         1512
#define IDS_L_OPTION                1513
#define IDS_Q_OPTION                1514
#define IDS_NO_UNATTENDED           1515
#define IDS_ARE_YOU_SURE            1516
#define IDS_ARE_YOU_SURE_CAP        1517
#define IDS_RENAMED_OLD             1518




#endif // __STRINGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\users\users.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       users.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-10-99   JBrezak   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#define SECURITY_WIN32
#include <rpc.h>
#include <ntsecapi.h>
#include <sspi.h>
extern "C" {
#include <secint.h>
}
#include <stdio.h>
#include <winsta.h>
#include <ntdsapi.h>
#include <shlwapi.h>
#include <assert.h>

#ifndef UNICODE
#define UNICODE
#endif
#define _UNICODE

LPTSTR FormatUserUpn(
    BOOL UseUpn,
    PSECURITY_STRING Domain,
    PSECURITY_STRING User
    )
{
    static TCHAR UName[DOMAIN_LENGTH + USERNAME_LENGTH + 2];
    HANDLE hDs;
    ULONG NetStatus;
    PDS_NAME_RESULT Result;
    TCHAR DName[DOMAIN_LENGTH + 1];
    LPTSTR Name = UName;
    
    swprintf(DName, L"%wZ", Domain);
    swprintf(UName, L"%wZ\\%wZ", Domain, User);

    if (!UseUpn)
	return UName;
	
    NetStatus = DsBind(NULL, DName, &hDs);
    if (NetStatus != 0) {
#ifdef DBGX
	wprintf(L"DsBind failed -0x%x\n", NetStatus);
#endif
	return UName;
    }
    
    NetStatus = DsCrackNames(hDs, DS_NAME_NO_FLAGS, DS_NT4_ACCOUNT_NAME,
			     DS_USER_PRINCIPAL_NAME, 1, &Name, &Result);
    if (NetStatus != 0) {
#ifdef DBGX
	wprintf(L"DsCrackNames failed -0x%x\n", NetStatus);
#endif
	return UName;
    }
    
    if (Result->rItems[0].pName)
	return Result->rItems[0].pName;
    else
	return UName;
}

static LPCTSTR dt_output_dhms   = L"%d %s %02d:%02d:%02d";
static LPCTSTR dt_day_plural    = L"days";
static LPCTSTR dt_day_singular  = L"day";
static LPCTSTR dt_output_donly  = L"%d %s";
static LPCTSTR dt_output_ms     = L"%d:%02d";
static LPCTSTR dt_output_hms    = L"%d:%02d:%02d";
static LPCTSTR ftime_default_fmt = L"%02d/%02d/%02d %02d:%02d";

LPTSTR FormatIdleTime(
    long dt
    )
{
    static TCHAR buf2[80];
    int days, hours, minutes, seconds, tt;
    
    days = (int) (dt / (24*3600l));
    tt = dt % (24*3600l);
    hours = (int) (tt / 3600);
    tt %= 3600;
    minutes = (int) (tt / 60);
    seconds = (int) (tt % 60);

    if (days) {
	if (hours || minutes || seconds) {
	    wnsprintf(buf2, sizeof(buf2)/sizeof(buf2[0]),
		      dt_output_dhms, days,
		     (days > 1) ? dt_day_plural : dt_day_singular,
		     hours, minutes, seconds);
	}
	else {
	    wnsprintf(buf2, sizeof(buf2)/sizeof(buf2[0]),
		      dt_output_donly, days,
		     (days > 1) ? dt_day_plural : dt_day_singular);
	}
    }
    else {
	wnsprintf(buf2, sizeof(buf2)/sizeof(buf2[0]),
		  dt_output_hms, hours, minutes, seconds);
    }

    return buf2;
}

LPTSTR FormatLogonType(
    ULONG LogonType
    )
{
    static TCHAR buf[20];
    
    switch((SECURITY_LOGON_TYPE)LogonType) {
    case Interactive:
	lstrcpy(buf, L"Interactive");
	break;
    case Network:
	lstrcpy(buf, L"Network");
	break;
    case Batch:
	lstrcpy(buf, L"Batch");
	break;
    case Service:
	lstrcpy(buf, L"Service");
	break;
    case Proxy:
	lstrcpy(buf, L"Proxy");
	break;
    case Unlock:
	lstrcpy(buf, L"Unlock");
	break;
    case NetworkCleartext:
	lstrcpy(buf, L"NetworkCleartext");
	break;
    case NewCredentials:
	lstrcpy(buf, L"NewCredentials");
	break;
    default:
	wnsprintf(buf, sizeof(buf)/sizeof(buf[0]), TEXT("(%d)"), LogonType);
	break;
    }
    return buf;
}

void Usage(
    void
    )
{
    wprintf(L"\
Usage: users [-u] [-a]\n\
       -u = Print userPrincipalName\n\
       -a = Print all logon sessions\n");
    ExitProcess(0);
}

void __cdecl main (
    int argc,
    char *argv[]
    )
{
    ULONG LogonSessionCount;
    PLUID LogonSessions;
    int i;
    DWORD err;
    PSECURITY_LOGON_SESSION_DATA SessionData;
    DWORD all = FALSE;
    DWORD UPN = FALSE;
    WINSTATIONINFORMATION WinStationInfo;
    DWORD WinStationInfoLen;
    char *ptr;
    FILETIME LocalTime;
    SYSTEMTIME LogonTime;
    TCHAR DateStr[40], TimeStr[40];
    WINSTATIONNAME WinStationName = L"inactive";
    long IdleTime = 0L;
    
    for (i = 1; i < argc; i++) {
        if ((argv[i][0] == '-') || (argv[i][0] == '/')) {
            for (ptr = (argv[i] + 1); *ptr; ptr++) {
                switch(toupper(*ptr)) {
		case 'A':
                    all = TRUE;
                    break;
		case 'U':
		    UPN = TRUE;
		    break;
		case '?':
		default:
		    Usage();
		    break;
		}
	    }
	}
    }

    err = LsaEnumerateLogonSessions(&LogonSessionCount, &LogonSessions);
    if (err != ERROR_SUCCESS) {
	wprintf(L"LsaEnumeratelogonSession failed - 0x%x\n", err);
	ExitProcess(1);
    }

    for (i = 0; i < (int)LogonSessionCount; i++) {
	err = LsaGetLogonSessionData(&LogonSessions[i], &SessionData);
	if (err != ERROR_SUCCESS) {
	    wprintf(L"LsaGetLogonSessionData failed - 0x%x\n", err);
	    continue;
	}
	
	if (SessionData->LogonType != 0 && 
	    (all || ((SECURITY_LOGON_TYPE)SessionData->LogonType == Interactive))) {
	    ZeroMemory(DateStr, sizeof(DateStr));
	    ZeroMemory(TimeStr, sizeof(TimeStr));
	    if (!FileTimeToLocalFileTime((LPFILETIME)&SessionData->LogonTime,
					 &LocalTime) ||
		!FileTimeToSystemTime(&LocalTime, &LogonTime)) {
		wprintf(L"Time conversion failed - 0x%x\n", GetLastError());
	    }
	    else {
		if (!GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE,
				   &LogonTime, NULL,
				   DateStr, sizeof(DateStr)/sizeof(DateStr[0]))) {
		    wprintf(L"Date format failed - 0x%x\n", GetLastError());
		}
		if (!GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS,
				   &LogonTime, NULL,
				   TimeStr, sizeof(TimeStr)/sizeof(TimeStr[0]))) {
		    wprintf(L"Time format failed - 0x%x\n", GetLastError());
		}
	    }
	    
	    if (WinStationQueryInformation(SERVERNAME_CURRENT,
					   SessionData->Session,
					   WinStationInformation, 
					   &WinStationInfo,
					   sizeof(WinStationInfo),
					   &WinStationInfoLen)) {
		if (WinStationInfo.ConnectState != State_Idle) {
		    
		    wcsncpy(WinStationName, WinStationInfo.WinStationName, sizeof(WinStationName)/sizeof(WinStationName[0]));
		    WinStationName[sizeof(WinStationName)/sizeof(WinStationName[0])-1] = 0;
		}

		const long TPS = (10*1000*1000);
		FILETIME CurrentFileTime;
		LARGE_INTEGER Quad;

		GetSystemTimeAsFileTime(&CurrentFileTime);

		Quad.LowPart = CurrentFileTime.dwLowDateTime;
		Quad.HighPart = CurrentFileTime.dwHighDateTime;

		IdleTime = (long)
		    ((Quad.QuadPart - WinStationInfo.LastInputTime.QuadPart) / TPS);

	    }
	    else if (GetLastError() == ERROR_APP_WRONG_OS) {
		assert(sizeof(WinStationName)/sizeof(WinStationName[0]) >= wcslen(L"Console"));
		wcscpy(WinStationName, L"Console");
	    }
	    else {
#ifdef DBGX
		wprintf(L"Query failed for %wZ\\%wZ @ %d - 0x%x\n",
			&SessionData->LogonDomain, &SessionData->UserName,
			SessionData->Session,
			GetLastError());
#endif
		continue;
	    }
	    wprintf(L"%-30.30s",
		    FormatUserUpn(UPN, &SessionData->LogonDomain,
				 &SessionData->UserName));
		    
	    if (all)
		wprintf(L" %-12.12s",
			FormatLogonType(SessionData->LogonType));

	    wprintf(L" %8.8s %s %s", WinStationName, DateStr, TimeStr);

	    if (all)
		wprintf(L" %wZ",
			&SessionData->AuthenticationPackage);

	    if (all && (IdleTime > 10))
		wprintf(L" %-12.12s", FormatIdleTime(IdleTime));
	    
	    wprintf(L"\n");
	}
    }

    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\webchange\fileandaction.h ===
// FileAndAction.h : Declaration of the CFileAndAction

#pragma once
#include "resource.h"       // main symbols
#include "atlcomcli.h"


// IFileAndAction
[
	object,
	uuid("FBBD73B0-471E-475D-BB10-09A012571FA9"),
	dual,	helpstring("IFileAndAction Interface"),
	pointer_default(unique)
]
__interface IFileAndAction : IDispatch
{
	[propget, id(1), helpstring("property Filename")] HRESULT Filename([out, retval] BSTR* pVal);
	[propput, id(1), helpstring("property Filename")] HRESULT Filename([in] BSTR newVal);
	[propget, id(2), helpstring("property Action. Examples of valid actions are Add, Delete, Edit, and Integrate.")] HRESULT Action([out, retval] BSTR* pVal);
	[propput, id(2), helpstring("property Action. Examples of valid actions are Add, Delete, Edit, and Integrate.")] HRESULT Action([in] BSTR newVal);
	[propget, id(3), helpstring("property Enabled. This controls whether the corresponding file and action will be present in the saved changelist.")] HRESULT Enabled([out, retval] BOOL* pVal);
	[propput, id(3), helpstring("property Enabled. This controls whether the corresponding file and action will be present in the saved changelist.")] HRESULT Enabled([in] BOOL newVal);
};



// CFileAndAction

[
	coclass,
	threading("apartment"),
	vi_progid("WebChange.FileAndAction"),
	progid("WebChange.FileAndAction"),
	version(1.3),
	uuid("A7DDB946-91A9-467F-A00B-CD7397387E4A"),
	helpstring("FileAndAction Class")
]
class ATL_NO_VTABLE CFileAndAction : 
	public IFileAndAction,
	public IObjectSafetyImpl<CFileAndAction,
							 INTERFACESAFE_FOR_UNTRUSTED_CALLER |
							 INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
	CFileAndAction()
		: m_fEnabled(TRUE)
	{
	}

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	
	void FinalRelease() 
	{
	}

	STDMETHOD(get_Filename)(BSTR* pVal);
	STDMETHOD(put_Filename)(BSTR newVal);
	STDMETHOD(get_Action)(BSTR* pVal);
	STDMETHOD(put_Action)(BSTR newVal);
	STDMETHOD(get_Enabled)(BOOL* pVal);
	STDMETHOD(put_Enabled)(BOOL newVal);

private:
	CComBSTR m_Filename;
	CComBSTR m_Action;
	BOOL m_fEnabled;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\webchange\fileandaction.cpp ===
// FileAndAction.cpp : Implementation of CFileAndAction

#include "stdafx.h"
#include "FileAndAction.h"


// CFileAndAction


STDMETHODIMP CFileAndAction::get_Filename(BSTR* pVal)
{
	if (pVal == NULL)
		return E_POINTER;

	return m_Filename.CopyTo(pVal);
}

STDMETHODIMP CFileAndAction::put_Filename(BSTR newVal)
{
	m_Filename = newVal;
	return S_OK;
}

STDMETHODIMP CFileAndAction::get_Action(BSTR* pVal)
{
	if (pVal == NULL)
		return E_POINTER;

	return m_Action.CopyTo(pVal);
}

STDMETHODIMP CFileAndAction::put_Action(BSTR newVal)
{
	m_Action = newVal;
	return S_OK;
}

STDMETHODIMP CFileAndAction::get_Enabled(BOOL* pVal)
{
	if (pVal == NULL)
		return E_POINTER;

	*pVal = m_fEnabled;
	return S_OK;
}

STDMETHODIMP CFileAndAction::put_Enabled(BOOL newVal)
{
	m_fEnabled = newVal;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\webchange\filesandactions.cpp ===
// FilesAndActions.cpp : Implementation of CFilesAndActions

#include "stdafx.h"
#include "FilesAndActions.h"


// CFilesAndActions

STDMETHODIMP CFilesAndActions::Add(VARIANT Item)
{

	if (Item.vt == VT_DISPATCH)
	{
		m_coll.push_back(Item);
		return S_OK;
	}
	else
	{
		return E_INVALIDARG;
	}
}

STDMETHODIMP CFilesAndActions::Remove(long Index)
{
	StdVariantList::iterator iList;

	// Check bounds
	if ((Index <= 0) || (Index > (long)m_coll.size()))
		return E_FAIL;

	iList = m_coll.begin();
	while (Index > 1)
	{
		iList++;
		Index--;
	}
	m_coll.erase(iList);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\trustdom2\trustdom.c ===
/*--

Copyright (c) 1997-1997  Microsoft Corporation

Module Name:

    trustdom.c

Abstract:

    Command line tool for displaying/creating/deleting trust links between 2 domains

Author:

    1-Apr-1997   Mac McLain (macm)   Created
	14-Jun-1998  Cristian Ioneci (cristiai)   Heavily modified
	
Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <dsgetdc.h>

#include <ntrtl.h>

#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmerr.h>

#include <string.h>

#define DEFINES_ONLY
#include "res.rc"


//taken from netlibnt.h; resides in netapi32.dll
NTSTATUS
NetpApiStatusToNtStatus(
    NET_API_STATUS NetStatus
    );


#define DBG 1

//dbgprintf macro: 	call it like dbgprint(("X:%d\n",i)); //notice the xtra paranthesis!!
#ifdef DBG
#define dbgprintf(a) if(Dbg) resprintf a
#else
#define dbgprintf(a)
#endif



/*-------------------------------------------------------*/
HINSTANCE hInst;
#define RBSZ 4096
WCHAR resbuf[RBSZ];
WCHAR outbuf[RBSZ];
			
#define RESPRINT_STDOUT 3
/*-------------------------------------------------------*/
//Printf message with format taken from a resource string
// where: 0 - stdout; 1- stderr; 2 - in the 'output' buffer
//take care: the resulting string must be max. RBSZ wchars (see #define above)
int resprintf(int where, UINT ids, ... )
{
	va_list parlist;
	va_start(parlist,ids);

	if(LoadString(hInst,ids,resbuf,RBSZ)==0)
		swprintf(resbuf,L"(LoadString failed with 0x%08lx)",GetLastError());
	
	switch(where) {
	case 0:
		return(vwprintf(resbuf, parlist));
	case 1:
		return(vfwprintf(stderr, resbuf, parlist));
	case 2:		
		return(vswprintf(outbuf, resbuf, parlist));
	case RESPRINT_STDOUT:
		return(vfwprintf(stdout, resbuf, parlist));

    DEFAULT_UNREACHABLE;

	}
}

enum DomInfoType_e { Minimal=0, Primary, DNS };
	// Minimal mode is used only for 'localonly' flag...
	//Minimal means that the name that was specified on the command line
	//(and copied in the ArgDomName member of the _TD_DOM_INFO structure) will
	//be the only information available about the target domain (that is, just
	//the flat name of the domain). That could happen if the target domain is
	//no longer accessible at the moment when the trustdom is run... 'TrustDom'
	//will try to do its best in this case...

struct LsaTIshot {
	ULONG count;
	PLSA_TRUST_INFORMATION	pTI;
};

typedef struct _TD_DOM_INFO {

	PWSTR pArgDomName; //from the command line...
	UNICODE_STRING uMinimalName;	//in case it is needed...
	LSA_HANDLE Policy;
	DWORD majver;
	LSA_HANDLE TrustedDomain;
	WCHAR DCName[1024];
	enum DomInfoType_e DomInfoType;
	union {
		PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;
	    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo;
	} u;
	PTRUSTED_DOMAIN_INFORMATION_EX pTDIX;	//one shot... Lsa memory space
	ULONG TDIXcEntries;
	struct LsaTIshot *pTIs;	//array of TIshots
	int nTIs;				//no. of TIshots
	ULONG TIcEntries;
	USER_INFO_1 *pUI1;	//one shot...
	DWORD UI1cEntries;

} TD_DOM_INFO, *PTD_DOM_INFO;

typedef struct _TD_VERIFY_INFO {

    PUNICODE_STRING DisplayName;
    PUNICODE_STRING ShortName;
    UNICODE_STRING NameBuffer;
    NTSTATUS IncomingStatus;
    NTSTATUS OutgoingStatus;

} TD_VERIFY_INFO, *PTD_VERIFY_INFO;

//
// Local function prototypes
//
NTSTATUS
GetDomainInfoForDomain(
    IN PWSTR DomainName,
    IN OPTIONAL PWSTR	DCMachineName,	// optional DC machine name
    IN PTD_DOM_INFO Info,
    IN BOOL MitTarget	
    );

NTSTATUS
GetTrustLinks(
    IN PTD_DOM_INFO pInfo
	);

VOID
FreeDomainInfo(
    IN PTD_DOM_INFO Info
    );

//
// Globals
//
BOOLEAN Force = FALSE;
BOOLEAN Nt4 = FALSE;
BOOLEAN Dbg = FALSE;
BOOLEAN SidList = FALSE;
//BOOLEAN Overwritesid = FALSE; actually use Force instead...

ULONG
DisplayErrorMessage(
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This function display the error string for the given error status

Arguments:

    NetStatus - Status to display the message for

Return Value:

    VOID

--*/
{
    ULONG Size = 0;
    PWSTR DisplayString;
    ULONG Options = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;


    Size = FormatMessage( Options,
                          NULL,
                          RtlNtStatusToDosError( Status ),
                          MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                          ( LPTSTR )&DisplayString,
                          0,
                          NULL );

    if ( Size != 0 ) {

        fprintf( stdout, "%ws", DisplayString );
        LocalFree( DisplayString );
    }

    return( Size );
}


VOID
Usage (
    VOID
    )
{
    resprintf(1,IDS_USAGE,VER_FILEVERSION_LSTR);
}


/*---------------------------- printSID --------------------------*/
BOOL
PrintSID(
        IN PSID	s
)
{
        int   i;
        BOOL r=TRUE;
        SID_IDENTIFIER_AUTHORITY        *a;

		if(s==NULL) {
			printf("<NULL sid>");
			return(FALSE);
		}

        if (!IsValidSid(s)) {
            printf("<invalid sid>:");
            r=FALSE;
        }

        a = GetSidIdentifierAuthority(s);

//      printf("S-0x1-%02x%02x%02x%02x%02x%02x",
//				a->Value[0], a->Value[1],
//				a->Value[2], a->Value[3],
//				a->Value[4], a->Value[5]);

		printf("S-0x1-");

		for(i=0; i<6; i++)
			if(a->Value[i]>0)
				break;
		if(i==6)			// hmmm... all zeroes?
			printf("0");	// out one zero then
		else {
			for(   ; i<6; i++) // else dump the remaining ones
					printf("%02x",a->Value[i]);
		}

        for (i = 0; i < (int)(*GetSidSubAuthorityCount(s)); i++) {
                printf("-%lx", *GetSidSubAuthority(s, i));
        }
        return(r);
}



NTSTATUS
GenerateRandomSID(
	OUT PSID *pSID
	)
{	
    NTSTATUS Status = STATUS_SUCCESS;

	SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    LARGE_INTEGER CurrentTime;

    NtQuerySystemTime(&CurrentTime);

    Status = RtlAllocateAndInitializeSid(
                &NtAuthority,
                4,
                SECURITY_NT_NON_UNIQUE,
                0,
                CurrentTime.LowPart,
                CurrentTime.HighPart,
                0,0,0,0,
                pSID
                );

    if (!NT_SUCCESS(Status))
    {
		*pSID=NULL;
		resprintf(0,IDS_GENERATERANDOMSID_F,Status);
    }

    return(Status);
}


//--------------------------zapchr------------------------------------
BOOL zapchr(WCHAR *s,    // zap specified character from the end of string
			WCHAR c,     // usefull to cut things like '\n' or '\\'
			WCHAR rc)    // rc is the char to replace with
{       WCHAR *p;
        if((p=wcsrchr(s,c))!=NULL) {
                *p=rc;
                return(TRUE);   // found smth to cut...
        }
        return(FALSE);          // the string was "clean"...
}


/*----------------------------------------------------------------------------*/
BOOL GetPassword(WCHAR *passwd, size_t n)
{
    /* turn off console echo & read in the password */

    HANDLE      console;
    DWORD       mode;

    *passwd=L'\0';
    if((console = GetStdHandle(STD_INPUT_HANDLE))==INVALID_HANDLE_VALUE)
                return(FALSE);
    if (! GetConsoleMode(console, &mode))
                return(FALSE);
    if (! SetConsoleMode(console, (mode & ~ENABLE_ECHO_INPUT)))
                return(FALSE);
    //fwprintf(stderr, L"Password : ");
    resprintf(1,IDS_PASSWORD_PROMPT);
    if (!fgetws(passwd, n, stdin))
                return(FALSE);
        zapchr(passwd,L'\n',L'\0');
    if (! SetConsoleMode(console, mode))
                return(FALSE);
    if(!CloseHandle(console))
                return(FALSE);
    fwprintf(stderr,L"\n");
    return(TRUE);
}


//UNICODE_STRING uMinimalName; not used anymore... added a field with same name inside each
//TD_DOM_INFO structure that will be used instead... in this way two consecutive calls
//*** FOR TWO STRUCTURES*** will not overwrite it.

//------------------GetFlatName---------------------------
PLSA_UNICODE_STRING GetFlatName(IN PTD_DOM_INFO pInfo)
{
	switch(pInfo->DomInfoType) {
	case DNS:
			return(&pInfo->u.DnsDomainInfo->Name);
	case Primary:
			return(&pInfo->u.PrimaryDomainInfo->Name);
	default:	//Minimal
			RtlInitUnicodeString(&pInfo->uMinimalName,pInfo->pArgDomName);
			return(&pInfo->uMinimalName);
	}
}

//------------------GetName--------------------------------
PLSA_UNICODE_STRING GetName(IN PTD_DOM_INFO pInfo)
{
	//simpler, just a little bit slower... (xtra call)
	//	if(pInfo->DomInfoType==DNS)
	//		return(&pInfo->u.DnsDomainInfo->DnsDomainName);
	//
	//	return(GetFlatName(pInfo));
	
	switch(pInfo->DomInfoType) {
	case DNS:
			return(&pInfo->u.DnsDomainInfo->DnsDomainName);
	case Primary:
			return(&pInfo->u.PrimaryDomainInfo->Name);
	default:	//Minimal
			RtlInitUnicodeString(&pInfo->uMinimalName,pInfo->pArgDomName);
			return(&pInfo->uMinimalName);
	}
}

PSID GetSid(IN PTD_DOM_INFO pInfo)
{
    PSID ReturnSid = NULL;

	switch(pInfo->DomInfoType) {
	case DNS:
        ReturnSid = pInfo->u.DnsDomainInfo->Sid;
        break;

	case Primary:
        ReturnSid = pInfo->u.PrimaryDomainInfo->Sid;
        break;

	}

    return( ReturnSid );
}

WCHAR SrvName[1024];
//----------------MakeSrvName-------------------------------
PWSTR MakeSrvName(IN PWSTR Name)	//add slashes at the beginning
{
	swprintf(SrvName,L"\\\\%ws",Name);
	if(SrvName[0]==L'\0')
		return(NULL);
	return(SrvName);
}

WCHAR Domain[1024];
//----------------AddDlrToDomainName-------------------------
PWSTR AddDlrToDomainName(IN PTD_DOM_INFO pInfo)
{
	swprintf(Domain,L"%wZ$",GetFlatName(pInfo));
	return(Domain);
}
WCHAR CutDlrDomain[1024];
//----------------CutDlrFromName-----------------------------
PWSTR CutDlrFromName(IN PWSTR Name)
{
	wcscpy(CutDlrDomain,Name);
	zapchr(CutDlrDomain,L'$',L'\0');
	return(CutDlrDomain);
}


WCHAR secret[1024];
LSA_UNICODE_STRING uSecret;
//---------------------MakeSecretName------------------
PLSA_UNICODE_STRING MakeSecretName(IN PTD_DOM_INFO pInfo)
{
	swprintf(secret,L"G$$%wZ",GetFlatName(pInfo));
	RtlInitUnicodeString(&uSecret,secret);
	return(&uSecret);
}

//start section inserted from Mac (11/05/1998(Thu) 17:08:53)
NTSTATUS
VerifyIndividualTrust(
    IN PSID InboundDomainSid,
    IN PUNICODE_STRING InboundDomainName,
    IN PLSA_HANDLE OutboundHandle,
    IN PWSTR OutboundServer,
    IN OUT PNTSTATUS VerifyStatus
    )
/*++

Routine Description:

	This routine will verify a single trust in the one direction only.

Arguments:

    InboundDomainSid -- Sid of the inbound side of the trust
    OutboundHandle -- Open policy handle to a domain controller on the outbound side
    OutboundServer -- Name of the domian controller on the outbound side
    VerifyStatus -- Status returned from the verification attempt
	
Return Value:

    STATUS_SUCCESS -- Success
    STATUS_INVALID_SID -- The specified domain sid was invalid

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD SidBuff[ sizeof( SID ) / sizeof( DWORD ) + 5 ];
    PSID DomAdminSid = ( PSID )SidBuff;
    PLSA_REFERENCED_DOMAIN_LIST Domains = NULL;
    PLSA_TRANSLATED_NAME Names = NULL;
    NET_API_STATUS NetStatus;
    PNETLOGON_INFO_2 NetlogonInfo2 = NULL;

    //
    // Assume the trust is invalid until we can prove otherwise.
    //
    *VerifyStatus = STATUS_TRUSTED_DOMAIN_FAILURE;

    ASSERT( RtlValidSid( InboundDomainSid ) );

    if ( !RtlValidSid( InboundDomainSid ) ) {

        return( STATUS_INVALID_SID );
    }

    //
    // Check netlogons secure channel
    //
    if ( NT_SUCCESS( Status )  ) {

        NetStatus = I_NetLogonControl2( OutboundServer,
                                        NETLOGON_CONTROL_TC_QUERY,
                                        2,
                                        ( LPBYTE )&InboundDomainName->Buffer,
                                        ( LPBYTE *)&NetlogonInfo2 );

        if ( NetStatus == NERR_Success ) {

            NetStatus = NetlogonInfo2->netlog2_pdc_connection_status;
            NetApiBufferFree( NetlogonInfo2 );

            if ( NetStatus != NERR_Success ) {

                NetStatus = I_NetLogonControl2( OutboundServer,
                                                NETLOGON_CONTROL_REDISCOVER,
                                                2,
                                                ( LPBYTE )&InboundDomainName->Buffer,
                                                ( LPBYTE *)&NetlogonInfo2 );
            }
        }

        *VerifyStatus = NetpApiStatusToNtStatus( NetStatus );

    }

    //
    // Now, try a lookup
    //
    if ( NT_SUCCESS( Status ) && NT_SUCCESS( *VerifyStatus ) ) {

        //
        // Build the domain admins sid for the inbound side of the trust
        //
        RtlCopyMemory( DomAdminSid,
                       InboundDomainSid,
                       RtlLengthSid( InboundDomainSid ) );


        ( ( PISID )( DomAdminSid ) )->SubAuthorityCount++;
        *( RtlSubAuthoritySid( DomAdminSid,
                               *( RtlSubAuthorityCountSid( InboundDomainSid ) ) ) ) =
                                                                            DOMAIN_GROUP_RID_ADMINS;

        //
        // Now, we'll simply do a remote lookup, and ensure that we get back success
        //
        Status = LsaLookupSids( OutboundHandle,
                                1,
                                &DomAdminSid,
                                &Domains,
                                &Names );

        if ( NT_SUCCESS( Status ) ) {

            LsaFreeMemory( Domains );
            LsaFreeMemory( Names );
            *VerifyStatus = STATUS_SUCCESS;

        } else if ( Status == STATUS_NONE_MAPPED ) {

            *VerifyStatus = STATUS_TRUSTED_DOMAIN_FAILURE;
            Status = STATUS_SUCCESS;

        } else {

            *VerifyStatus = Status;
        }

        //
        // If all of that worked, check netlogons secure channel
        //
        if ( NT_SUCCESS( Status ) && NT_SUCCESS( *VerifyStatus ) ) {

            NetStatus = I_NetLogonControl2( OutboundServer,
                                            NETLOGON_CONTROL_TC_QUERY,
                                            2,
                                            ( LPBYTE )&InboundDomainName->Buffer,
                                            ( LPBYTE *)&NetlogonInfo2 );

            if ( NetStatus == NERR_Success ) {

                NetStatus = NetlogonInfo2->netlog2_pdc_connection_status;
                NetApiBufferFree( NetlogonInfo2 );

                if ( NetStatus != NERR_Success ) {

                    NetStatus = I_NetLogonControl2( OutboundServer,
                                                    NETLOGON_CONTROL_REDISCOVER,
                                                    2,
                                                    ( LPBYTE )&InboundDomainName->Buffer,
                                                    ( LPBYTE *)&NetlogonInfo2 );
                }
            }

            *VerifyStatus = NetpApiStatusToNtStatus( NetStatus );

        }
    }

    return( Status );
}

NTSTATUS
VerifyTrustInbound(
    IN PTD_DOM_INFO LocalDomain,
    IN PUNICODE_STRING RemoteDomain,
    IN OUT PNTSTATUS VerifyStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TD_DOM_INFO RemoteTrustInfo;
    WCHAR  DCname[MAX_PATH + 1]= { L'\0' };



    RtlZeroMemory( &RemoteTrustInfo, sizeof( RemoteTrustInfo ) );
    Status = GetDomainInfoForDomain( RemoteDomain->Buffer, NULL, &RemoteTrustInfo, FALSE );

    if ( NT_SUCCESS( Status ) ) {

        Status= VerifyIndividualTrust( GetSid( LocalDomain ),
                                       GetName( LocalDomain ),
                                       RemoteTrustInfo.Policy,
                                       RemoteTrustInfo.DCName,
                                       VerifyStatus );

        FreeDomainInfo( &RemoteTrustInfo );

    } else {

        *VerifyStatus = Status;
    }

    return( Status );
}

NTSTATUS
VerifyTrustOutbound(
    IN PTD_DOM_INFO LocalDomain,
    IN PUNICODE_STRING RemoteDomain,
    IN OUT PNTSTATUS VerifyStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TD_DOM_INFO RemoteTrustInfo;

    RtlZeroMemory( &RemoteTrustInfo, sizeof( RemoteTrustInfo ) );
    Status = GetDomainInfoForDomain( RemoteDomain->Buffer, NULL, &RemoteTrustInfo, FALSE );

    if ( NT_SUCCESS( Status ) ) {

        Status= VerifyIndividualTrust( GetSid( &RemoteTrustInfo ),
                                       GetName( &RemoteTrustInfo ),
                                       LocalDomain->Policy,
                                       LocalDomain->DCName,
                                       VerifyStatus );

        FreeDomainInfo( &RemoteTrustInfo );

    } else {

        *VerifyStatus = Status;
    }

    return( Status );
}

NTSTATUS
VerifyTrusts(
    IN PWSTR DomainName,
    IN OPTIONAL PWSTR	DCMachineName	// optional DC machine name
    )
/*++

Routine Description:

	This routine will verify the existing trusts with all other NT domains, and display the
    results.

Arguments:

    DomainName -- OPTIONAL name of the domain on which to verify the information

	
Return Value:

    STATUS_SUCCESS -- Success

    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    TD_DOM_INFO TrustInfo;
    PTD_VERIFY_INFO VerifyList = NULL;
    ULONG VerifyCount = 0, VerifyIndex = 0, i, j;
    BOOLEAN InvalidIncoming = FALSE, InvalidOutgoing = FALSE, Valid = FALSE;
    UNICODE_STRING *LocalDomainName = NULL, SamNameAsDomain;
    WCHAR *AccountTrunc;


    RtlZeroMemory( &TrustInfo, sizeof( TrustInfo ) );
    Status = GetDomainInfoForDomain( DomainName, DCMachineName, &TrustInfo, FALSE );

    if ( NT_SUCCESS( Status ) ) {

        Status = GetTrustLinks( &TrustInfo );
    }

    if ( !NT_SUCCESS( Status ) ) {

        goto VerifyExit;
    }

    LocalDomainName = GetName( &TrustInfo );

    //
    // Allocate a list of verify information to correspond to the list we enumerated
    //
    VerifyCount = max( TrustInfo.TDIXcEntries,  TrustInfo.UI1cEntries + TrustInfo.TIcEntries );

    VerifyList = ( PTD_VERIFY_INFO )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                VerifyCount * sizeof( TD_VERIFY_INFO ) );

    if ( !VerifyList ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto VerifyExit;
    }

    //
    // Now, do the verification.
    //
    if ( TrustInfo.TDIXcEntries ) {

        for ( i = 0; i < TrustInfo.TDIXcEntries; i++ ) {

            if ( TrustInfo.pTDIX[ i ].TrustType == TRUST_TYPE_DOWNLEVEL ||
                 TrustInfo.pTDIX[ i ].TrustType == TRUST_TYPE_UPLEVEL ) {

                VerifyList[ VerifyIndex ].DisplayName = &TrustInfo.pTDIX[ i ].Name;
                VerifyList[ VerifyIndex ].ShortName = &TrustInfo.pTDIX[ i ].FlatName;

                resprintf( RESPRINT_STDOUT, IDS_VERIFY_CHECK,
                           LocalDomainName,
                           VerifyList[ VerifyIndex ].DisplayName );

                if ( ( TrustInfo.pTDIX[ i ].TrustDirection & TRUST_DIRECTION_INBOUND ) ) {

                    Status = VerifyTrustInbound( &TrustInfo,
                                                 &TrustInfo.pTDIX[ i ].Name,
                                                 &VerifyList[ VerifyIndex ].IncomingStatus );
                }

                if ( ( TrustInfo.pTDIX[ i ].TrustDirection & TRUST_DIRECTION_OUTBOUND ) &&
                     Status != STATUS_NO_SUCH_DOMAIN ) {

                    Status = VerifyTrustOutbound( &TrustInfo,
                                                 &TrustInfo.pTDIX[ i ].Name,
                                                 &VerifyList[ VerifyIndex ].OutgoingStatus );
                }

                if ( NT_SUCCESS( VerifyList[ VerifyIndex ].OutgoingStatus ) &&
                     NT_SUCCESS( VerifyList[ VerifyIndex ].IncomingStatus ) ) {

                     Valid = TRUE;

                } else {

                    if ( !NT_SUCCESS( VerifyList[ VerifyIndex ].OutgoingStatus ) ) {

                        InvalidOutgoing = TRUE;
                    }

                    if ( !NT_SUCCESS( VerifyList[ VerifyIndex ].IncomingStatus ) ) {

                        InvalidIncoming = TRUE;
                    }
                }

                VerifyIndex++;
            }

            Status = STATUS_SUCCESS;
        }

    } else {
        //
        // Going to have to do the old NT4 style.
        //
        //for ( i = 0; i < TrustInfo.TIcEntries; i++ ) {

    	int shot;
        for ( VerifyIndex=0, shot=0; shot<TrustInfo.nTIs; shot++)
        	for(i=0; i<TrustInfo.pTIs[shot].count; i++) {

	            VerifyList[ VerifyIndex ].DisplayName = &TrustInfo.pTIs[shot].pTI[ i ].Name;
	            VerifyList[ VerifyIndex ].ShortName = &TrustInfo.pTIs[shot].pTI[ i ].Name;
	            resprintf( RESPRINT_STDOUT, IDS_VERIFY_CHECK,
	                       LocalDomainName,
	                       VerifyList[ VerifyIndex ].DisplayName );

	            Status = VerifyTrustOutbound( &TrustInfo,
	                                          &TrustInfo.pTIs[shot].pTI[ i ].Name,
	                                          &VerifyList[ VerifyIndex ].OutgoingStatus );

	            if ( !NT_SUCCESS( VerifyList[ VerifyIndex ].OutgoingStatus ) ) {

	                InvalidOutgoing = TRUE;
	            }
	            VerifyIndex++;
	        }

        //
        // Now, the same with the sam account names
        //
        for ( i = 0; i < TrustInfo.UI1cEntries; i++ ) {

            //
            // Shorten the account name to be a domain name
            //
            AccountTrunc = &TrustInfo.pUI1[ i ].usri1_name[
                                                wcslen( TrustInfo.pUI1[ i ].usri1_name ) - 1 ];
            *AccountTrunc = UNICODE_NULL;

            //
            // See if we already have an entry for this in our verified list
            //
            RtlInitUnicodeString( &SamNameAsDomain, TrustInfo.pUI1[ i ].usri1_name );
            for ( j = 0; j < VerifyIndex; j++ ) {

                if ( RtlEqualUnicodeString( &SamNameAsDomain,
                                            VerifyList[ j ].ShortName, TRUE ) ) {
                    break;
                }
            }

            if ( j == VerifyIndex ) {

                RtlCopyMemory( &VerifyList[ j ].NameBuffer, &SamNameAsDomain,
                              sizeof( UNICODE_STRING ) );
                VerifyList[ j ].DisplayName = &VerifyList[ j ].NameBuffer;
                VerifyList[ j ].ShortName = &VerifyList[ j ].NameBuffer;
                VerifyIndex++;
            }


            resprintf( RESPRINT_STDOUT, IDS_VERIFY_CHECK,
                       LocalDomainName,
                       &SamNameAsDomain );
            Status = VerifyTrustInbound( &TrustInfo,
                                         &SamNameAsDomain,
                                         &VerifyList[ j ].IncomingStatus );

            if ( !NT_SUCCESS( VerifyList[ j ].IncomingStatus ) ) {

                InvalidIncoming = TRUE;
            }

            *AccountTrunc = L'$';

        }

        //
        // Now, walk the list and see if we have any valid domain pairs
        //
        for ( i = 0; i < VerifyIndex; i++ ) {

            if ( NT_SUCCESS( VerifyList[ i ].IncomingStatus ) &&
                 NT_SUCCESS( VerifyList[ i ].OutgoingStatus ) ) {

                Valid = TRUE;
                break;
            }
        }
    }

    //
    // Display the list of valid trusts
    //
    if ( Valid ) {

        resprintf( RESPRINT_STDOUT, IDS_VERIFY_VALID );
        for ( i  = 0; i < VerifyIndex; i++ ) {

            if ( NT_SUCCESS( VerifyList[ i ].IncomingStatus ) &&
                 NT_SUCCESS( VerifyList[ i ].OutgoingStatus ) ) {

                fprintf(stdout, "%wZ\n", VerifyList[ i ].DisplayName );
            }
        }
    }

    if ( InvalidIncoming ) {

        resprintf( RESPRINT_STDOUT, IDS_VERIFY_INVALID_INCOMING );
        for ( i  = 0; i < VerifyIndex; i++ ) {

            if ( !NT_SUCCESS( VerifyList[ i ].IncomingStatus ) ) {

                fprintf( stdout, "%wZ - ", VerifyList[ i ].DisplayName );
                if ( DisplayErrorMessage( VerifyList[ i ].IncomingStatus ) == 0 ) {

                    resprintf( RESPRINT_STDOUT, IDS_VERIFY_UNMAPPABLE,
                               VerifyList[ i ].IncomingStatus );
                }
            }
        }
    }

    if ( InvalidOutgoing ) {

        resprintf( RESPRINT_STDOUT, IDS_VERIFY_INVALID_OUTGOING );
        for ( i  = 0; i < VerifyIndex; i++ ) {

            if ( !NT_SUCCESS( VerifyList[ i ].OutgoingStatus ) ) {

                fprintf( stdout, "%wZ - ", VerifyList[ i ].DisplayName );
                if ( DisplayErrorMessage( VerifyList[ i ].OutgoingStatus ) == 0 ) {

                    resprintf( RESPRINT_STDOUT, IDS_VERIFY_UNMAPPABLE,
                               VerifyList[ i ].OutgoingStatus );
                }
            }
        }
    }


    Status = STATUS_SUCCESS;
VerifyExit:

    LocalFree( VerifyList );
    FreeDomainInfo( &TrustInfo );

    return( Status );
}


//end section insert from Mac (11/05/1998(Thu) 17:09:39)

NTSTATUS
GetDomainInfoForDomain(
    IN PWSTR    		DomainName,
    IN OPTIONAL PWSTR	DCMachineName,	// optional DC machine name
    IN PTD_DOM_INFO		Info,
    BOOL	MitTarget		// TRUE if this call is made for the B domain in a A <-> B Mit type trust link

    )
/*++

Routine Description:

	Tries to fill as much as possible of the TD_DOM_INFO structure for the given domain;
	For a NT4 DC, the DNS name does not exist

Arguments:

    DomainName -- Optional domain to conect to

	    Info -- Information structure to fill in

Return Value:

    STATUS_SUCCESS -- Success

    STATUS_NO_SUCH_DOMAIN -- No server could be located for the domain

--*/
{
	NET_API_STATUS   netstatus=NERR_Success;
	NTSTATUS Status = STATUS_SUCCESS;
	PWSTR pMachine=NULL;
	DWORD dwErr;
	UNICODE_STRING Server;
//  UNICODE_STRING uString;
//	PLSA_UNICODE_STRING puDomName;
//
	OBJECT_ATTRIBUTES ObjectAttributes;
	PDOMAIN_CONTROLLER_INFO DCInfo = NULL;
	SERVER_INFO_101 *p101  = NULL;

	PSID sid=NULL;
	WCHAR *DCInfostr=L"";

	Info->DomInfoType=Minimal;
	Info->pArgDomName=DomainName;
	
	Info->majver=0;	// assume nothing... or a Unix machine... (for a MIT trust)

	Info->DCName[0]=L'\0';

	if(MitTarget)
		return(STATUS_NO_SUCH_DOMAIN);
	
	resprintf(2,IDS_LOCAL);	// printed to outbuf....

    if ( (DomainName != NULL && DomainName[0]!=L'\0') || Nt4 ) {	// try to get local machine name for an Nt4 style operation...

		if(DCMachineName == NULL || DCMachineName[0]==L'\0') {
	        dwErr = DsGetDcName( NULL, (LPCWSTR)DomainName, NULL, NULL,
	                             DS_DIRECTORY_SERVICE_PREFERRED | DS_WRITABLE_REQUIRED,
	                             &DCInfo );

	        if ( dwErr == ERROR_SUCCESS ) {
	        	wcscpy(Info->DCName,DCInfo->DomainControllerName + 2);
	        	pMachine=Info->DCName;
				//set the version
				if((DCInfo->Flags&(DS_DS_FLAG|DS_WRITABLE_FLAG))==DS_WRITABLE_FLAG)
						Info->majver=4;
				else	Info->majver=5;
		        dbgprintf((0,IDS_DSGETDCNAME_DC_D,DomainName!=NULL?DomainName:outbuf,Info->DCName)); //,DCInfo->Flags));
	        } else {
	           	Status = STATUS_NO_SUCH_DOMAIN;
				resprintf(0,IDS_DSGETDCNAME_F,DomainName!=NULL?DomainName:outbuf,dwErr);
				if(Force)
						resprintf(0,IDS_DSGETDCNAME_FFORCE);
				else	resprintf(0,IDS_DSGETDCNAME_FRET,Status);
	        }
		}
		else {
			wcscpy(Info->DCName,DCMachineName);
			pMachine=Info->DCName;
	        dbgprintf((0,IDS_DSGETDCNAME_DC_D,DomainName!=NULL?DomainName:outbuf,Info->DCName));
	        //now trying to get version using some other method than based on the flags returned by DsGetDcName...
		    netstatus = NetServerGetInfo( MakeSrvName(pMachine), 101, ( LPBYTE *) &p101 );
			if(netstatus != NERR_Success) {
	           	Status = STATUS_UNSUCCESSFUL;
				fprintf(stderr,"NetServerGetInfo (101) failed: err 0x%08lx;\n"
							"    ...now returning Status 0x%08lx (STATUS_UNSUCCESSFUL)\n",
									netstatus,Status);
				goto cleanup;
			}
			Info->majver=(p101->sv101_version_major & MAJOR_VERSION_MASK);
		}
    }

	RtlInitUnicodeString( &Server, Info->DCName );

	if(Nt4)	{ // force Nt4 style
		Info->majver=4;
		dbgprintf( (0, IDS_FORCENT4, DomainName!=NULL?DomainName:outbuf) );
	}


//    if ( NT_SUCCESS( Status ) )
//		{
//
//	    netstatus = NetServerGetInfo( pMachine, 101, ( LPBYTE *) &p101 );
//		if(netstatus != NERR_Success) {
//           	Status = STATUS_UNSUCCESSFUL;
//			fprintf(stderr,"NetServerGetInfo (101) failed: err 0x%08lx;\n"
//						"    ...now returning Status 0x%08lx (STATUS_UNSUCCESSFUL)\n",
//								netstatus,Status);
//			goto cleanup;
//		}
//		Info->majver=(p101->sv101_version_major & MAJOR_VERSION_MASK);
//    }
		
    if ( NT_SUCCESS( Status ) ) {

        RtlZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

        Status = LsaOpenPolicy( DomainName == NULL ? NULL : &Server,
                                &ObjectAttributes,
                                MAXIMUM_ALLOWED,
                                &Info->Policy
                                );


		if(!NT_SUCCESS(Status)) {
       		resprintf(0,IDS_LSAOPENPOLICY_F1, (Info->DCName[0]==L'\0')?outbuf:Info->DCName);
	        if ( Status == STATUS_ACCESS_DENIED)
            		resprintf(0,IDS_ACCESS_DENIED);
            else	resprintf(0,IDS_ERROR_FORMAT,Status);
            goto cleanup;
        }

       	Info->DomInfoType=DNS;
       	DCInfostr=L"DNS";
        Status = LsaQueryInformationPolicy( Info->Policy,
                                            PolicyDnsDomainInformation,
                                            &(Info->u.DnsDomainInfo )	//the SID is in here...
                                            );
        dbgprintf( (0,IDS_GETDOMAININFOFORDOMAIN_D, DomainName!=NULL?DomainName:outbuf, DCInfostr, Status ));
        if( !NT_SUCCESS( Status ) || Nt4) {	// try at least Primary....
			Info->majver=4;        	
	       	DCInfostr=L"Primary";
            dbgprintf( (0,IDS_PRIMARY_D) );
	       	Info->DomInfoType=Primary;
            Status = LsaQueryInformationPolicy( Info->Policy,
                                                PolicyPrimaryDomainInformation,
                                                &(Info->u.PrimaryDomainInfo )	//the SID is in here...
                                                );
            dbgprintf( (0,IDS_GETDOMAININFOFORDOMAIN_D, DomainName!=NULL?DomainName:outbuf, DCInfostr, Status ) );
        }
        else	{
        	Info->majver=5;
        }

        switch(Info->DomInfoType) {
        case DNS:		sid = Info->u.DnsDomainInfo->Sid;
        				break;
        case Primary:	sid = Info->u.PrimaryDomainInfo->Sid;
        				break;
        }

		if(Dbg) {
			printf("Domain %ws Sid=",DCInfostr);
			PrintSID(sid);
			printf("\n");
		}


    }

	if(Info->DomInfoType==DNS)
		dbgprintf( (0,IDS_DOMAINNAMED,&(Info->u.DnsDomainInfo->DnsDomainName) ) );
		
    if ( !NT_SUCCESS( Status ) )
		//well...
    	goto cleanup;
		//...
cleanup:
	if(DCInfo!=NULL)
	    NetApiBufferFree( DCInfo );

	if(p101!=NULL)
		NetApiBufferFree( p101 );

    return( Status );
}


VOID
FreeDomainInfo(
    IN PTD_DOM_INFO Info
    )
/*++

Routine Description:

    Frees the info returned from GetDomainInfoForDomain

Arguments:

    Info -- Information structure to free

Return Value:

    STATUS_SUCCESS -- Success

--*/
{
	int i;
	
    if ( Info->Policy ) {
        LsaClose( Info->Policy );
        Info->Policy=NULL;
    }

    if ( Info->u.DnsDomainInfo != NULL )
        LsaFreeMemory( Info->u.DnsDomainInfo );
	// Info->u.DnsDomainInfo is inside an union with Info->u.PrimaryDomainInfo
	//on the same position

	if(Info->pTDIX!=NULL)
		LsaFreeMemory(Info->pTDIX);

	//if there's an array of pointers to TI shots returned from LsaEnumerateTrustedDomains...	
	if(Info->pTIs!=NULL) {
		for(i=0; i<Info->nTIs; i++)
			LsaFreeMemory(Info->pTIs[i].pTI);
	}
	
	if(Info->pUI1!=NULL)
		NetApiBufferFree(Info->pUI1);
}


NTSTATUS
GetTrustLinks(
    IN PTD_DOM_INFO pInfo
	)
/*++
Fills an array of trust links information.
	Usually that information will be printed in the form:
	domain_name, trust direction, type, attributes
	)
--*/
{
	NET_API_STATUS   netstatus=NERR_Success;
    NTSTATUS Status = STATUS_SUCCESS;
	
    LSA_ENUMERATION_HANDLE EnumerationContext = 0;
    //needed for NT4 enumeration...
	DWORD UIRead=0L;
	DWORD UITotal=0L;
	DWORD reshandle=0;	// Put 0 for enumeration handles !!!!
		//A value like INVALID_HANDLE_VALUE (that is -1) would make the NetUserEnum to return 0 users...

	if(pInfo->majver>=5) {
	    Status = LsaEnumerateTrustedDomainsEx( pInfo->Policy,
						   &EnumerationContext,
						   &pInfo->pTDIX,
						   0xffffffff,	//ULONG_MAX,
						   &pInfo->TDIXcEntries );

		dbgprintf( (0,IDS_LSAENUMERATETRUSTEDDOMAINSEX_D,GetName(pInfo),Status,pInfo->TDIXcEntries) );
		if(Status==STATUS_NO_MORE_ENTRIES && pInfo->pTDIX==NULL) {
			pInfo->TDIXcEntries=0L;
			Status=STATUS_SUCCESS;	//that means "0 entries"
		}

		return( Status );
	}

	//Enumerate NT4 Inbound trusts:
	netstatus = NetUserEnum( MakeSrvName(pInfo->DCName),
								1,
								FILTER_INTERDOMAIN_TRUST_ACCOUNT,
								(LPBYTE*)(&pInfo->pUI1),
								0xffffffff,	//ULONG_MAX
								&UIRead,
								&UITotal,
								&reshandle
								);
	dbgprintf( (0,IDS_NETUSERENUM_D,GetName(pInfo),netstatus,UIRead) );
	if(netstatus!=NERR_Success) {
		Status = STATUS_UNSUCCESSFUL;
		goto cleanup;
	}
	pInfo->UI1cEntries=UIRead;

	//Enumerate NT4 Outbound trusts:
	{	PLSA_TRUST_INFORMATION	pTIShot=NULL;
		ULONG nShotsize=0;
		struct LsaTIshot *pTIsav=NULL;
	
		do {
				Status=LsaEnumerateTrustedDomains( pInfo->Policy,
								&EnumerationContext,
								&pTIShot,
								0xffffffff,	//ULONG_MAX,
								&nShotsize);

				dbgprintf( (0,IDS_LSAENUMERATETRUSTEDDOMAINS_D,GetName(pInfo),Status,nShotsize) );
				if( (Status != STATUS_SUCCESS) &&
					(Status != STATUS_MORE_ENTRIES) &&
					(Status != STATUS_NO_MORE_ENTRIES)
					) {
						SetLastError( LsaNtStatusToWinError(Status) );
						goto cleanup;
				}
				if(pTIShot!=NULL) {
					if((pInfo->pTIs=realloc(pTIsav=pInfo->pTIs,pInfo->nTIs+1))==NULL) {
						free(pTIsav);
						Status = ERROR_NOT_ENOUGH_MEMORY;
						goto cleanup;
					}
					pInfo->TIcEntries+=nShotsize;
					pInfo->pTIs[pInfo->nTIs].count=nShotsize;
					pInfo->pTIs[pInfo->nTIs].pTI=pTIShot;
					pInfo->nTIs++;
				}
				
		} while (Status != STATUS_NO_MORE_ENTRIES);

		if(Dbg) printf("Total number of entries: %u\n",pInfo->TIcEntries);
		dbgprintf( (0,IDS_LSAENUMERATETRUSTEDDOMAINS_D,GetName(pInfo),Status,pInfo->TIcEntries) );
		if(Status==STATUS_NO_MORE_ENTRIES)
			Status=STATUS_SUCCESS;
		if(pInfo->pTIs==NULL) {
			pInfo->TIcEntries=0L;
		}
	}


cleanup:
	return( Status );	
}

struct bidir_st {
	ULONG index;	// index in the 'Inbound' vector
	char type;		// 'O' - Outbound, 'B' - Bidirectional
};
int __cdecl cmpbidir(const struct bidir_st *pb1, const struct bidir_st *pb2)
{
	if(pb1->index==pb2->index)
		return(0);
	if(pb1->index>pb2->index)
		return(1);
	return(-1);
}

NTSTATUS
PrintTrustLinks(
	IN PTD_DOM_INFO Info
	)
/*++
	Print Trust Links
--*/
{
	ULONG i,j;

	if(Info->majver>=5) {
		for(i=0; i<Info->TDIXcEntries; i++) {
			char c;
			switch(Info->pTDIX[i].TrustDirection)
			{
				case TRUST_DIRECTION_DISABLED:		c='D';	break;
				case TRUST_DIRECTION_INBOUND:		c='I';	break;
				case TRUST_DIRECTION_OUTBOUND:		c='O';	break;
				case TRUST_DIRECTION_BIDIRECTIONAL:	c='B';	break;
				default:							c='-';	break;
			}
			printf("%-32wZ,%c",&Info->pTDIX[i].Name,c);
			switch(Info->pTDIX[i].TrustType&0x000FFFFF)
			{
				case TRUST_TYPE_DOWNLEVEL:
					printf(",T_downlevel");	break;
				case TRUST_TYPE_UPLEVEL:
					printf(",T_uplevel");	break;
				case TRUST_TYPE_MIT:
					printf(",T_mit");		break;
				default:
					printf("-");			break;
			}
			if(Info->pTDIX[i].TrustAttributes & TRUST_ATTRIBUTE_NON_TRANSITIVE)
					printf(",A_NonTran");
			else	printf(",_");
			if(Info->pTDIX[i].TrustAttributes & TRUST_ATTRIBUTE_UPLEVEL_ONLY  )
					printf(",A_UpLevelOnly");
			else	printf(",_");
			if(Info->pTDIX[i].TrustAttributes & TRUST_ATTRIBUTE_QUARANTINED_DOMAIN   )
					printf(",A_QuarantinedDomain");
			else	printf(",_");
			if(Info->pTDIX[i].TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
					printf(",A_ForestTrust");
			else	printf(",_");
			if(Info->pTDIX[i].TrustAttributes & TRUST_ATTRIBUTE_CROSS_ORGANIZATION)
					printf(",A_CrossFederation");
			else	printf(",_");
			if(Info->pTDIX[i].TrustAttributes & TRUST_ATTRIBUTE_WITHIN_FOREST)
					printf(",A_WithinForest");
			else	printf(",_");
			if(Info->pTDIX[i].TrustAttributes & TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL)
					printf(",A_TreatAsExternal");
			else	printf(",_");
			if(SidList) {
				printf(",");
				PrintSID(Info->pTDIX[i].Sid);
			}
			printf("\n");
		}

	}
	else {
		//Info->majver<=4
		int shot;
		struct bidir_st *p=NULL, *q=NULL;
		if((p=calloc(Info->TIcEntries,sizeof(struct bidir_st)))==NULL)
			return(ERROR_NOT_ENOUGH_MEMORY);
		//for(q=p,i=0; i<Info->TIcEntries; q++,i++) {
		for(q=p,shot=0; shot<Info->nTIs; shot++) {
			for(i=0; i<Info->pTIs[shot].count; i++,q++) {
				WCHAR buf[1024];
				swprintf(buf,L"%wZ",&Info->pTIs[shot].pTI[i].Name);
				for(j=0; j<Info->UI1cEntries; j++)
					if(wcscmp(buf,CutDlrFromName(Info->pUI1[j].usri1_name))==0)
						break;
				if((q->index=j)<Info->UI1cEntries)	//found...
						q->type='B';	//actually it's a Bidir link...
				else	q->type='O';	//or this is a "true" Outbound...
			}
		}
		//print Outbound and Bidirectional links
		//for(q=p,i=0; i<Info->TIcEntries; q++,i++)
		for(q=p,shot=0; shot<Info->nTIs; shot++)
			for(i=0; i<Info->pTIs[shot].count; i++,q++)
				printf("%-32wZ,%c,T_downlevel,_,_,_,_\n",&Info->pTIs[shot].pTI[i].Name,q->type);
		qsort(p,Info->TIcEntries,sizeof(struct bidir_st),cmpbidir);
		//print Inbound links
		for(q=p,j=i=0; i<Info->UI1cEntries; i++) {
			if(j<Info->TIcEntries && q->index==i) {	//if it was a Bidirectional, it was already printed...
					j++; q++;
					continue;
			}
			printf("%-32ws,I,T_downlevel,_,_,_,_\n",CutDlrFromName(Info->pUI1[i].usri1_name));
		}
		if(p!=NULL)
			free(p);
	}

	return( STATUS_SUCCESS );

}



NTSTATUS
CreateNT5TrustDomObject(
    IN PTD_DOM_INFO Local,
    IN PTD_DOM_INFO Remote,
    IN PWSTR Password,
    IN BOOLEAN Downlevel,
    IN BOOLEAN Mit,
    IN ULONG Direction
    )
/*++
Routine Description:
    Creates the trusted domain object on an NT5 domain (DS based)

Arguments:
    Local -- Information about the domain doing the trust
    Remote -- Information about the domain being trusted
    Password -- Password to set on the trust
    Downlevel -- If TRUE, create this as a downlevel trust
    Mit -- If TRUE, creates this as an Mit style trust
    Direction -- Which direction to make the link in.
Return Value:
    STATUS_SUCCESS -- Success
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
	WCHAR Domain[1024]={L'\0'};
	WCHAR DnsDomain[1024]={L'\0'};

    TRUSTED_DOMAIN_INFORMATION_EX TDIEx;
    LSA_AUTH_INFORMATION AuthData;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx;
    PSID Sid = NULL;

	swprintf(Domain,L"%wZ",GetFlatName(Remote));
	swprintf(DnsDomain,L"%wZ",GetName(Remote));

    Status  = NtQuerySystemTime( &AuthData.LastUpdateTime );

    if ( !NT_SUCCESS( Status ) ) {

        return( Status );
    }

    AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
    AuthData.AuthInfoLength = wcslen( Password ) * sizeof( WCHAR );
    AuthData.AuthInfo = (PUCHAR)Password;


    RtlZeroMemory( &AuthInfoEx, sizeof( LSA_AUTH_INFORMATION ) );

    if ( Direction & TRUST_DIRECTION_INBOUND ) {
        AuthInfoEx.IncomingAuthInfos = 1;
        AuthInfoEx.IncomingAuthenticationInformation = &AuthData;
        AuthInfoEx.IncomingPreviousAuthenticationInformation = NULL;
    }

    if ( Direction & TRUST_DIRECTION_OUTBOUND ) {
        AuthInfoEx.OutgoingAuthInfos = 1;
        AuthInfoEx.OutgoingAuthenticationInformation = &AuthData;
        AuthInfoEx.OutgoingPreviousAuthenticationInformation = NULL;
    }

    if (!Mit)
    {
        RtlCopyMemory( &TDIEx.Name, GetName(Remote), sizeof( UNICODE_STRING ) );
        RtlCopyMemory( &TDIEx.FlatName, GetFlatName(Remote), sizeof( UNICODE_STRING ) );
        switch(Remote->DomInfoType) {
        case DNS:		TDIEx.Sid = Remote->u.DnsDomainInfo->Sid;
        				break;
        case Primary:	TDIEx.Sid = Remote->u.PrimaryDomainInfo->Sid;
        				break;
        default:		Status = GenerateRandomSID( &Sid);

				        if (!NT_SUCCESS(Status))
				        {
				            return(Status);
				        }
				        TDIEx.Sid = Sid;
				        break;
        }

        //TDIEx.Sid = (Remote->DomInfoType==DNS?Remote->u.DnsDomainInfo->Sid:Remote->u.PrimaryDomainInfo->Sid);
    }
    else
    {
//		printf("****Set %ws for the Name and FlatName in the trust object... GetFlatName(Local)=%wZ\n",
//						Domain,GetFlatName(Local));
        RtlInitUnicodeString(
            &TDIEx.Name,
            Domain
            );
        RtlInitUnicodeString(
            &TDIEx.FlatName,
            Domain
            );

		Status = GenerateRandomSID( &Sid);

        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }
        TDIEx.Sid = Sid;
    }
    TDIEx.TrustDirection = Direction;
    TDIEx.TrustType = Mit ? TRUST_TYPE_MIT : (Downlevel ? TRUST_TYPE_DOWNLEVEL : TRUST_TYPE_UPLEVEL);
    TDIEx.TrustAttributes = 0;

    Status = LsaCreateTrustedDomainEx( Local->Policy,
                                       &TDIEx,
                                       &AuthInfoEx,
                                       TRUSTED_ALL_ACCESS,
                                       &Local->TrustedDomain );

    if (!NT_SUCCESS(Status)) {
        dbgprintf( (0,IDS_LSACREATETRUSTEDDOMAINEX_F, GetName(Local), DnsDomain, Status) );
        if(Status==STATUS_OBJECT_NAME_COLLISION)
        	dbgprintf( (0,IDS_STATUS_OBJECT_NAME_COLLISION, GetName(Local), DnsDomain) );
    }
    else	LsaClose(Local->TrustedDomain);	//not interested in the actual handle...

    if (Sid != NULL)
    {
        RtlFreeSid(Sid);
    }
    return( Status );
}

NTSTATUS
CreateTrustLink(
	IN PTD_DOM_INFO pInfoA,
	IN PTD_DOM_INFO pInfoB,
    IN PWSTR Password,
    IN BOOLEAN Downlevel,
    IN BOOLEAN Mit,
    IN BOOLEAN ParentChild,
    IN ULONG Direction
	)
{
	NET_API_STATUS   netstatus=NERR_Success;
	NTSTATUS Status = STATUS_SUCCESS;
	PWSTR pDomain=NULL;

	if(	!Force	// if -force was NOT specified...
		&&
		!Mit	// for a non-MIT trust...
		&&
		(pInfoA->DomInfoType==Minimal || pInfoB->DomInfoType==Minimal)
				// creating links not supported in 'Minimal' mode...
		)
		return( STATUS_UNSUCCESSFUL );

	if(pInfoA->majver>=5) {
		Status = CreateNT5TrustDomObject(
					pInfoA,
					pInfoB,
					Password,
					Downlevel,Mit,Direction
					);

		return( Status );
	}

	////////////////////////////////////////////////////////////////////////
	//for a NT4 domain...
	if(Mit || ParentChild)
		return (STATUS_INVALID_PARAMETER);

	if(Direction & TRUST_DIRECTION_INBOUND) {
		USER_INFO_1 UI1;
		DWORD dwParmErr=0xffffffff;

		memset(&UI1,0,sizeof(UI1));

		pDomain=AddDlrToDomainName(pInfoB);

	    //  Create the necessary SAM account.
	    UI1.usri1_name = pDomain;
	    UI1.usri1_password = Password;
	    UI1.usri1_password_age = 0;
	    UI1.usri1_priv = USER_PRIV_USER;
	    UI1.usri1_home_dir = NULL;
	    UI1.usri1_comment = NULL;
	    UI1.usri1_flags = UF_INTERDOMAIN_TRUST_ACCOUNT | UF_SCRIPT;
	    UI1.usri1_script_path = NULL;

	    netstatus = NetUserAdd(
	                MakeSrvName(pInfoA->DCName),
	                1,
	                (LPBYTE)&UI1,
	                &dwParmErr
	                );
		
		if(netstatus != NERR_Success) {
				resprintf(0,IDS_NETUSERADD_F,pInfoA->DCName,pDomain,netstatus);
				if(netstatus==NERR_UserExists)
					resprintf(0,IDS_NERR_UserExists,pInfoA->DCName,pDomain);
				goto Done;
		}
	}
	if(Direction & TRUST_DIRECTION_OUTBOUND) {
		LSA_TRUST_INFORMATION TI;
		PUNICODE_STRING puSecret;
		UNICODE_STRING uPass;
		LSA_HANDLE hSecret;
		

		swprintf(Domain,L"%wZ",GetFlatName(pInfoB));
		
		RtlInitUnicodeString(&TI.Name,Domain);
		{	PSID Sid = NULL;
	        switch(pInfoB->DomInfoType) {
	        case DNS:		TI.Sid = pInfoB->u.DnsDomainInfo->Sid;
	        				break;
	        case Primary:	TI.Sid = pInfoB->u.PrimaryDomainInfo->Sid;
	        				break;
	        default:		Status = GenerateRandomSID( &Sid);

					        if (!NT_SUCCESS(Status))
					        {
					            return(Status);
					        }
					        TI.Sid = Sid;
					        break;
	        }
		}

		//TI.Sid=(pInfoB->DomInfoType==DNS?pInfoB->u.DnsDomainInfo->Sid:pInfoB->u.PrimaryDomainInfo->Sid);

		Status = LsaCreateTrustedDomain(
						pInfoA->Policy,
						&TI,
						TRUSTED_ALL_ACCESS,
						&pInfoA->TrustedDomain
						);
		if( !NT_SUCCESS(Status)) {
			resprintf(0,IDS_LSACREATETRUSTEDDOMAIN_F,Status);
			goto Done;
		}
		else	LsaClose(pInfoA->TrustedDomain);	//not interested in the actual handle...
			
		puSecret=MakeSecretName(pInfoB);

		Status = LsaCreateSecret(
						pInfoA->Policy,
						puSecret,
						SECRET_ALL_ACCESS,
						&hSecret
						);
		if(!NT_SUCCESS(Status)) {
			resprintf(0,IDS_LSACREATESECRET_F,Status);
			goto Done;
		}
		
		RtlInitUnicodeString(&uPass,Password);
		Status=LsaSetSecret(
						hSecret,
						&uPass,
						NULL
						);
		if(!NT_SUCCESS(Status)) {
			resprintf(0,IDS_LSASETSECRET_F,Status);
			LsaDelete(hSecret); hSecret=NULL;
			goto Done;
		}
		if(hSecret!=NULL)
			LsaClose(hSecret);
	}
			
Done:
//	if(pInfoA->TrustedDomain!=NULL)
//		LsaClose(pInfoA->TrustedDomain);
	return(Status);
}




NTSTATUS
DeleteTrustLink(
    IN PTD_DOM_INFO pInfoA,
    IN PTD_DOM_INFO pInfoB
    )
/*++

Routine Description:

    Deletes on A trusted domain things related to a trust to B

Return Value:

    STATUS_SUCCESS -- Success

--*/
{
	NET_API_STATUS netstatus=NERR_Success;
    NTSTATUS Status=STATUS_SUCCESS;
//#define NO_TRUST_OBJECTS 	1
//#define NO_SECRETS			2
//#define NO_TRUST_ACCOUNTS	4
//    DWORD dwFlag=0;
    ULONG i, ix=0;
	PSID sid=NULL;


	PTRUSTED_DOMAIN_INFORMATION_EX pTDIx = NULL;
	PLSA_UNICODE_STRING puDomBName=GetName(pInfoB);
	PLSA_UNICODE_STRING puDomBFlatName=GetFlatName(pInfoB);
	PLSA_UNICODE_STRING puSecret;

	dbgprintf( (0,IDS_DELTRUSTFROMTO,GetName(pInfoA),puDomBName) );


	Status = GetTrustLinks(pInfoA);
	if(!NT_SUCCESS(Status)) {
		resprintf(0,IDS_GETTRUSTLINKS_F,GetName(pInfoA),Status);
		return(Status);
	}
	//try to find a trust link to B...
	if(pInfoA->majver>=5) {

		// now try to get a LSA_HANDLE to a (possible) trust object with this domain...
		// if not found any, that Info->TrustedDomain will remain NULL
		
		Status = LsaQueryTrustedDomainInfoByName(
					    pInfoA->Policy,
					    puDomBName,					//IN PLSA_UNICODE_STRING TrustedDomainName
					    TrustedDomainInformationEx,	//IN TRUSTED_INFORMATION_CLASS InformationClass,
					    &pTDIx						//OUT PVOID *Buffer
					    );
		if ( !NT_SUCCESS( Status ) ) {
			
			if(Status==STATUS_OBJECT_NAME_NOT_FOUND) {
					pInfoA->TrustedDomain=NULL;
					dbgprintf( (0,IDS_NO_TRUST_OBJECT_D,GetName(pInfoA),puDomBName) );
					Status=STATUS_SUCCESS;
			}
			else	resprintf(0,IDS_LSAQUERYTRUSTEDDOMAININFOBYNAME_F,GetName(pInfoA),puDomBName,Status);
			goto cleanup;
		}

		if(pTDIx->Sid==NULL)
			dbgprintf( (0,IDS_LSAQUERYNULLSID) ); //"NULL sid returned by LsaQueryTrustedDomainInfoByName\n"
		sid=pTDIx->Sid;
		//check to see if the trusted domain object can be opened with that sid...
		if(sid!=NULL) {
			LSA_HANDLE td;
			Status=LsaOpenTrustedDomain(pInfoA->Policy,
						sid,TRUSTED_ALL_ACCESS,&td);
			if(NT_SUCCESS( Status ))	// if it was ok...
				LsaClose(td);			// ...just close the handle (leave the following code to open it again later)
			else {						// if failed...
				if(Status==STATUS_INVALID_PARAMETER && Force) {
					printf("LsaOpenTrustedDomain for the trust to %wZ failed with STATUS_INVALID_PARAMETER (i.e. the sid is bad)\n"
						   "Trying to set a valid sid...\n",puDomBName);
										// if was STATUS_INVALID_PARAMETER (i.e. the sid) and '-overwritesid' option used...
					RtlFreeSid(sid);	// free the old sid
					sid=NULL;			// make it NULL as a signal to the next 'if' (see below) to
				}						// pick it up and set a new random valid sid in its place
			}
		}

		if(sid==NULL) {
			// try to put a sid THERE ...
			Status = GenerateRandomSID ( &pTDIx->Sid );
			if (!NT_SUCCESS( Status ))
				goto cleanup;

			Status = LsaSetTrustedDomainInfoByName(
						    pInfoA->Policy,
						    puDomBName,					//IN PLSA_UNICODE_STRING TrustedDomainName
						    TrustedDomainInformationEx,	//IN TRUSTED_INFORMATION_CLASS InformationClass,
						    pTDIx						//IN PVOID Buffer
						    );
			if(!NT_SUCCESS( Status )) {
				resprintf(0,IDS_LSASETTRUSTEDDOMAININFOBYNAME_F,GetName(pInfoA),puDomBName,Status);
				goto cleanup;		
			}
			sid=pTDIx->Sid;
			if(sid==NULL)
				resprintf(0,IDS_LSASETNULLSID); //"LsaSetTrustedDomainInfoByName: NULL sid\n"
		}
	}
	else {	// pInfoA->majver<=4
		//check for Outbound....	
		int shot;
		//for(ix=0; ix<pInfoA->TIcEntries; ix++)
		for(shot=0; shot<pInfoA->nTIs; shot++)
			for(ix=0; ix<pInfoA->pTIs[shot].count; ix++)
				if(RtlEqualUnicodeString(&pInfoA->pTIs[shot].pTI[ix].Name,puDomBFlatName,TRUE))
													//it was FALSE, i.e. case sensitive
					goto out_of_loop;
		out_of_loop:
		if(ix<pInfoA->TIcEntries)
			sid=pInfoA->pTIs[shot].pTI[ix].Sid;
		else {
			printf("No OUTBOUND trust to %wZ found...\n",puDomBFlatName);
		}
	}

	if(sid==NULL)
		dbgprintf( (0,IDS_NULLSID) );	//"#### NULL sid\n"

	if(sid!=NULL) {
		Status=LsaOpenTrustedDomain(
					pInfoA->Policy,
					sid,
					TRUSTED_ALL_ACCESS,
					&pInfoA->TrustedDomain
					);
		//printf("Handle=0x%08lx (Status: 0x%08lx)\n",pInfoA->TrustedDomain,Status);
		if(!NT_SUCCESS(Status)) {
			resprintf(0,IDS_LSAOPENTRUSTEDDOMAIN_F,Status);
			//return(Status);
		}
		dbgprintf( (0,IDS_LSATRUSTHANDLE,pInfoA->TrustedDomain,Status) );
	}
	else {
		if(	//pInfoA->majver<=4 &&
			ix<pInfoA->TIcEntries) {
				resprintf(0,IDS_NONNULL_SID,puDomBName);
				Status=STATUS_INVALID_SID;
		}
		else	//simply no trust objects...
			Status=STATUS_SUCCESS;
	}

	if(pInfoA->TrustedDomain) {
		dbgprintf( (0,IDS_LSADELOBJ,pInfoA->TrustedDomain) );
	    Status = LsaDelete( pInfoA->TrustedDomain );
	}

    if (!NT_SUCCESS(Status))
        dbgprintf( (0,IDS_DELETION_F,GetName(pInfoA), Status) );

	//NT4 only section...
	if(pInfoA->majver<=4) {
		LSA_HANDLE hSecret;
		//delete secret thing...
		puSecret=MakeSecretName(pInfoB);

		Status = LsaOpenSecret(
						pInfoA->Policy,
						puSecret,
						SECRET_ALL_ACCESS,
						&hSecret
						);
		if(Status==STATUS_OBJECT_NAME_NOT_FOUND) {
			dbgprintf( (0,IDS_SECRET_NOT_FOUND_D,puSecret) );
			Status=STATUS_SUCCESS;
		}
		else {
			if(!NT_SUCCESS(Status)) {
					resprintf(0,IDS_LSAOPENSECRET_F,Status);
			}
			else {
				Status = LsaDelete(hSecret);	hSecret=NULL;
				if(!NT_SUCCESS(Status))
					resprintf(0,IDS_LSADELETE_F,puSecret,Status);
			}
		}
		//delete Interdomain Trust Account....
		netstatus = NetUserDel(
						MakeSrvName(pInfoA->DCName),
						AddDlrToDomainName(pInfoB)
						);
		if(netstatus!=NERR_Success && netstatus!=NERR_UserNotFound) {
				resprintf(0,IDS_NETUSERDEL_F,AddDlrToDomainName(pInfoB),netstatus);
				Status=STATUS_UNSUCCESSFUL;
		}
	}

cleanup:
	if(pTDIx!=NULL)
		LsaFreeMemory(pTDIx);
	if(sid!=NULL)
		RtlFreeSid(sid);

    return( Status );
}

NTSTATUS
CheckTrustLink(
    IN PTD_DOM_INFO pInfoA,
    IN PTD_DOM_INFO pInfoB
    )
/*++

Routine Description:

    Checks on A trusted domain sids related to a trust to B

Return Value:

    STATUS_SUCCESS -- Success

--*/
{
	NET_API_STATUS netstatus=NERR_Success;
    NTSTATUS Status=STATUS_SUCCESS;

	PSID sid=NULL, sidb=NULL;
	BOOL UnknownRemoteSid=FALSE;

	PTRUSTED_DOMAIN_INFORMATION_EX pTDIx = NULL;
	PLSA_UNICODE_STRING puDomBName=GetName(pInfoB);
	PLSA_UNICODE_STRING puDomBFlatName=GetFlatName(pInfoB);

	dbgprintf( (0,IDS_CHKTRUSTFROMTO,GetName(pInfoA),puDomBName) );

	//try to find a trust link to B...
	if(pInfoA->majver>=5) {

		// now try to get a LSA_HANDLE to a (possible) trust object with this domain...
		// if not found any, that Info->TrustedDomain will remain NULL
		Status = LsaQueryTrustedDomainInfoByName(
					    pInfoA->Policy,
					    puDomBName,					//IN PLSA_UNICODE_STRING TrustedDomainName
					    TrustedDomainInformationEx,	//IN TRUSTED_INFORMATION_CLASS InformationClass,
					    &pTDIx						//OUT PVOID *Buffer
					    );
		if ( !NT_SUCCESS( Status ) ) {
			if(Status==STATUS_OBJECT_NAME_NOT_FOUND) {
					pInfoA->TrustedDomain=NULL;
					dbgprintf( (0,IDS_NO_TRUST_OBJECT_D,GetName(pInfoA),puDomBName) );
					Status=STATUS_SUCCESS;
			}
			else	resprintf(0,IDS_LSAQUERYTRUSTEDDOMAININFOBYNAME_F,GetName(pInfoA),puDomBName,Status);
			goto cleanup;
		}
		sid=pTDIx->Sid;
	}
	else {	// pInfoA->majver<=4
		//check for Outbound....
		int shot;
        ULONG i;

		for(shot=0; shot<pInfoA->nTIs; shot++)
			for(i=0; i<pInfoA->pTIs[shot].count; i++)
				if(RtlEqualUnicodeString(&pInfoA->pTIs[shot].pTI[i].Name,puDomBFlatName,TRUE))
													//it was FALSE, i.e. case sensitive
					goto out_of_loop;
		out_of_loop:
		if(i<pInfoA->TIcEntries)
			sid=pInfoA->pTIs[shot].pTI[i].Sid;

	}

    switch(pInfoB->DomInfoType) {
    case DNS:		sidb = pInfoB->u.DnsDomainInfo->Sid;
    				break;
    case Primary:	sidb = pInfoB->u.PrimaryDomainInfo->Sid;
    				break;
    default:		sidb=NULL;
    				UnknownRemoteSid=TRUE;
			        break;
    }

	
	//now sid contains the Sid of the trust object, if any... (on NT4, only the OUTBOUND
	//end of the trust has a trust object...)
	//Print them and compare them...
	printf("TDO on %wZ: sid:\t",GetName(pInfoA));
	PrintSID(sid);
	printf("\n");
	if(UnknownRemoteSid) {
		if(pInfoB->majver<=4)
			printf("Domain %wZ does not have a trust object (possibly an NT4 only with an INBOUND trust)\n",puDomBName);
		else
			printf("Sid for domain %wZ is unknown (possible localonly used or error getting Dns/Primary DomainInfo)",puDomBName);
	}
	else {
		if(sid!=NULL && IsValidSid(sid) && sidb!=NULL && IsValidSid(sidb)) {
			if(EqualSid(sid,sidb))
					printf("Sid on %wZ is the same:\t",puDomBName);
			else	printf("Sid on %wZ is different:\t",puDomBName);
		}
		else {
			printf("Sid on %wZ: ",puDomBName);
		}
		PrintSID(sidb);
	}
	printf("\n");

cleanup:
	if(pTDIx!=NULL)
		LsaFreeMemory(pTDIx);

    return( Status );
}

	
void ParseForDCName(WCHAR DomBuf[], WCHAR DCBuf[])
{
	WCHAR *pw;
	DCBuf[0]=L'\0';
	wcstok(DomBuf,L":");
	if((pw=wcstok(NULL,L":"))!=NULL)
		wcscpy(DCBuf,pw);
	if(DomBuf[0]==L'*' || wcscmp(DomBuf,L"(local)")==0)
		DomBuf[0]=L'\0';
}


//the NameValidate stuff below taken from icanon.h
NET_API_STATUS
NET_API_FUNCTION
I_NetNameValidate(
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags    );

//NameType:
#define NAMETYPE_DOMAIN         6
//Flags:
//#define LM2X_COMPATIBLE                 0x80000000L


#ifdef COMMENT
#define CTRL_CHARS_0   L"\001\002\003\004\005\006\007"
#define CTRL_CHARS_1   L"\010\011\012\013\014\015\016\017"
#define CTRL_CHARS_2   L"\020\021\022\023\024\025\026\027"
#define CTRL_CHARS_3   L"\030\031\032\033\034\035\036\037"
#define CTRL_CHARS_STR CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3

#define ILLEGAL_DOMAIN_CHARS_STR
#define ILLEGAL_DOMAIN_NAME_CHARS_STR  L"\"/\\[]:|<>+;,?" CTRL_CHARS_STR L"*" L" "
#endif //COMMENT

BOOL ValidateDomain(WCHAR DomBuf[])
{	WCHAR Buf[MAX_PATH + 1]= { L'\0' };
	WCHAR *p;
	int DomBuf_len, oem_name_len;
	NET_API_STATUS netstatus=NERR_Success;
	
	if(DomBuf==NULL || DomBuf[0]==L'\0')
		return(TRUE);

	wcscpy(Buf,DomBuf);
	//for DNS name, test each component; for a flat name, there's already only one...
	for(p=wcstok(Buf,L"."); p!=NULL; p=wcstok(NULL,L"."))
		if((netstatus=I_NetNameValidate(NULL,p,NAMETYPE_DOMAIN,0))!=NERR_Success)
			return(FALSE);
	return(TRUE);

#ifdef COMMENT
	DomBuf_len=wcslen(DomBuf);
    // oem_name_len : length in bytes in oem character set
    // name_len     : ifdef UNICODE
    //                    character length in unicode
    //                else
    //                    length in bytes in oem character set
    //
	{
        BOOL fUsedDefault;
        oem_name_len = WideCharToMultiByte(
                         CP_OEMCP,       // UINT CodePage
                         0,              // DWORD dwFlags
                         DomBuf,         // LPWSTR lpWideChar
                         DomBuf_len,     // int cchWideChar
                         NULL,           // LPSTR lpMultiByteStr
                         0,              // int cchMultiByte
                         NULL,           // use system default char
                         &fUsedDefault); //
	}

	if(oem_name_len<1 || oem_name_len>=DNLEN)
		return(FALSE);

	if(wcscspn(DomBuf,ILLEGAL_DOMAIN_NAME_CHARS_STR) < DomBuf_len)
		return(FALSE);

	return(TRUE);
#endif //COMMENT
}

#define ARG_CASE_S	0x8000	// case sensitive argument

#define BOOL_ARG(argvec,a_index,var)	{if((argvec)[(a_index)].b) (var)=(BOOLEAN)((argvec)[(a_index)].b);}
enum e_arg_type { ARG_S, ARG_U, ARG_B, ARG_I, ARG_L, ARG_UD };
struct _arg_st {
	char *name;
	union {
		char *s;
		ULONG u;
		BOOL b;
		int i;
		long l;
		void (*fct)(char *);
	};
	enum e_arg_type t;
};
#define NELEMS(a)  (sizeof(a)/sizeof(a[0]))
	
int process_opt(int argc, char **argv, struct _arg_st arg[])
{ // command line parameters processing
  int i,j,k; char *p; struct _arg_st *pa;
  int r=1;
  // process options
  for (i=1; i<argc; i++) {
     if (argv[i][0]=='/' || argv[i][0]=='-') {
   		p=strtok(argv[i]+1,":");
     	for(j=0; arg[j].name!=NULL; j++) {
     		if(p!=NULL && (	((arg[j].t & ARG_CASE_S) && strcmp(p,arg[j].name)==0) ||
     					    _stricmp(p,arg[j].name)==0 ) )
     			break;
     	}
     	if(arg[j].name==NULL) {
     		resprintf(1,IDS_UNKNOWN_OPTION,p);
     		r=0;
     		continue;
     	}
		switch(arg[j].t)
		{
			case ARG_B:
				if(	(p=strtok(NULL,""))==NULL
					|| _stricmp(p,"on")==0
					|| _stricmp(p,"true")==0)
						arg[j].b=TRUE;
				else	arg[j].b=FALSE;
				break;
			case ARG_S:
				if((p=strtok(NULL,""))!=NULL)
						arg[j].s=_strdup(p);
				else	arg[j].s=NULL;
				break;
			case ARG_U:
				if((p=strtok(NULL,""))!=NULL)
						arg[j].u=(ULONG)atol(p);
				break;							
			case ARG_L:
				if((p=strtok(NULL,""))!=NULL)
						arg[j].l=atol(p);
				break;							
			case ARG_I:
				if((p=strtok(NULL,""))!=NULL)
						arg[j].i=atoi(p);
				break;
			case ARG_UD:
				p=strtok(NULL,"");
				(*arg[j].fct)(p);
				break;
		}
     }
  }
  return(r);
}


// options
enum e_arg_idx {	A_LIST, A_BOTH, A_IN, A_OUT,
					A_UNTRUST, A_CHECK,
                    A_VERIFY,
					A_LOCALONLY, A_DOWNLEVEL, A_MIT, A_PARENT,
					A_DEBUG,
					A_PW,
					A_FORCE,
					A_NT4,
					A_SIDLIST,
					A_LASTARG };
struct _arg_st opt_arg[]={
	{"list",		NULL,	ARG_B},	// A_LIST
	{"both",		NULL,	ARG_B},	// A_BOTH
	{"in",			NULL,	ARG_B},	// A_IN
	{"out",			NULL,	ARG_B},	// A_OUT
	{"untrust",		NULL,	ARG_B},	// A_UNTRUST
	{"sidcheck",	NULL,	ARG_B},	// A_CHECK
    {"verify",      NULL,   ARG_B}, // A_VERIFY
	{"localonly",	NULL,	ARG_B},	// A_LOCALONLY
	{"downlevel",	NULL,	ARG_B},	// A_DOWNLEVEL
	{"mit",			NULL,	ARG_B},	// A_MIT
	{"parent",		NULL,	ARG_B},	// A_PARENT
	{"debug",		NULL,	ARG_B},	// A_DEBUG
	{"pw",			NULL,	ARG_S},	// A_PW
	{"force",		NULL,	ARG_B},	// A_FORCE
	{"nt4",			NULL,	ARG_B},	// A_NT4
	{"sidlist",		NULL,	ARG_B},	// A_SIDLIST
	{NULL,			NULL}
};


INT
__cdecl main (		// it was _CRTAPI1
    int argc,
    char **argv)
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusL = STATUS_SUCCESS;
    NTSTATUS StatusR = STATUS_SUCCESS;

    WCHAR  ADomain[MAX_PATH + 1]= { L'\0' };
    WCHAR  BDomain[MAX_PATH + 1]= { L'\0' };

    WCHAR  ADC[MAX_PATH + 1]= { L'\0' };
    WCHAR  BDC[MAX_PATH + 1]= { L'\0' };	// BDC means just DC for machine B and NOT B(ackup) DC !!!...

    WCHAR  Xbuf[MAX_PATH + 1]= { L'\0' };	// general purpose buffer
    WCHAR  Ybuf[MAX_PATH + 1]= { L'\0' };	// general purpose buffer

    INT i,j;

    BOOLEAN List=FALSE;
	BOOLEAN Both = FALSE, DirIn=FALSE, DirOut=FALSE;
    BOOLEAN LocalOnly = FALSE, Untrust = FALSE, Downlevel = FALSE, Parent = FALSE;
    BOOLEAN Check=FALSE;
    BOOLEAN Mit = FALSE;
    BOOLEAN LocalCreated = FALSE;
    BOOL Verify = FALSE;
    // BOOLEAN Force = FALSE; moved global
    // BOOLEAN Nt4 = FALSE; this is global
	// BOOLEAN Dbg = FALSE; this is global

	DWORD DirectionLocal=0, DirectionRemote=0;

    WCHAR PasswordBuff[1024];
    PWSTR  Password = NULL;

    TD_DOM_INFO Local={0},
    			Remote={0};

	LSA_UNICODE_STRING uDomNameL,uDomNameR;

	// help requested? display it and exit ...
    if ( argc<2 ||
    	 _stricmp( argv[1], "-?") == 0 ||
         _stricmp( argv[1], "/?") == 0 ) {
		        Usage();
		        goto Done;
    }

	hInst=GetModuleHandle(NULL);


    RtlZeroMemory( &Local, sizeof( TD_DOM_INFO ) );
    RtlZeroMemory( &Remote, sizeof (TD_DOM_INFO ) );

	if(!process_opt(argc,argv, opt_arg)) {
        Status = STATUS_INVALID_PARAMETER;
        Usage();
        goto Done;
	}

	BOOL_ARG(opt_arg,A_LIST,	List		);
	BOOL_ARG(opt_arg,A_BOTH,	Both		);
	BOOL_ARG(opt_arg,A_IN,		DirIn		);
	BOOL_ARG(opt_arg,A_OUT,		DirOut		);
	BOOL_ARG(opt_arg,A_UNTRUST,	Untrust		);
	BOOL_ARG(opt_arg,A_CHECK,	Check		);
	BOOL_ARG(opt_arg,A_VERIFY,	Verify		);
	BOOL_ARG(opt_arg,A_LOCALONLY,LocalOnly	);
	BOOL_ARG(opt_arg,A_DOWNLEVEL,Downlevel	);
	BOOL_ARG(opt_arg,A_MIT,		Mit			);
	BOOL_ARG(opt_arg,A_PARENT,	Parent		);
	BOOL_ARG(opt_arg,A_DEBUG,	Dbg			);
	BOOL_ARG(opt_arg,A_FORCE,	Force		);
	BOOL_ARG(opt_arg,A_NT4,		Nt4			);
	BOOL_ARG(opt_arg,A_SIDLIST,	SidList		);

	//put this after Dbg variable is set
	if(Dbg)
		printf("TRUSTDOM - (ver %ws)\n",VER_FILEVERSION_LSTR);

	//get password (if any)
	if(opt_arg[A_PW].s)
			mbstowcs( PasswordBuff, opt_arg[A_PW].s, strlen( opt_arg[A_PW].s )+1 );
	else	PasswordBuff[0]='\0';

	// process normal command line arguments (positional)
	for (j=0,i=1; i<argc; i++) {
	 if (!(argv[i][0]=='/' || argv[i][0]=='-')) {
	    switch(j) {
	    case 0:
	    	{	WCHAR *pws;
	            mbstowcs(ADomain, argv[i], strlen(argv[i]) + 1 );

	            if((pws=wcschr(ADomain,L','))!=NULL) {
	            	*pws=L'\0';
	            	wcscpy(BDomain,pws+1);
	            }
	            else {
	            	wcscpy(BDomain,ADomain);
	            	ADomain[0]=L'\0';
	            }
	    	}
			break;
	    }
	 j++;
	 }
	}

	ParseForDCName(ADomain,ADC);
	ParseForDCName(BDomain,BDC);

	dbgprintf( (0,IDS_DOMARGUMENTS,ADomain,ADC[0]?L":":L"",ADC,BDomain,BDC[0]?L":":L"",BDC) );

	resprintf(2,IDS_WARNING);
	wcsncpy(Xbuf,outbuf,MAX_PATH);
	resprintf(2,IDS_ERROR);
	wcsncpy(Ybuf,outbuf,MAX_PATH);


	//Parameter adjust
	if(SidList)
		List=TRUE;

	//Domain names check:
	{	WCHAR *s=NULL;
		BOOL ba, bb;
		if(	!(ba=ValidateDomain(s=ADomain)) ||
			!(bb=ValidateDomain(s=BDomain))) {
				resprintf(0,IDS_INVALID_DOMAIN_NAME,s);
				Status = STATUS_INVALID_PARAMETER;
				goto Done;
		}
	}

	// Parameter constraints:

    // '-parent' REQUIRES '-both'
	if (Parent && !Both) {
		if(!Force)
			Status = STATUS_INVALID_PARAMETER;
		resprintf(0,IDS_PARENT_REQ_BOTH,(Force?Xbuf:Ybuf));
	}
    // MIT trusts are always local only
    if (Mit && (!LocalOnly || !Both)) {
    	resprintf(0,IDS_MIT_LOCAL_ONLY_BOTH);
        LocalOnly = TRUE;
        Both = TRUE;
    }
    //
    // Validate the parameters
    //
    //specifying both in and out means, yes, '-both'...
	if(DirIn && DirOut)
		Both=TRUE;

	if(List && Mit)
	    Status = STATUS_INVALID_PARAMETER;

	if((!List && BDomain[0]==L'\0') || (List && ADomain[0]!=L'\0'))
	    Status = STATUS_INVALID_PARAMETER;

    if ( Untrust == TRUE && (Downlevel)) // || Mit || Both ) )  // changed from Both || LocalOnly ||...
        Status = STATUS_INVALID_PARAMETER;

//    if(LocalOnly == TRUE  && Both == FALSE)
//        Status = STATUS_INVALID_PARAMETER;;

    if (Mit && (Downlevel || Parent ))
        Status = STATUS_INVALID_PARAMETER;
    // end validating parameters

    if( Status == STATUS_INVALID_PARAMETER ) {
        Usage();
        goto Done;
    }

	if(!Untrust && !List && !Verify) {	//check password... otherwise ignore
        if(wcscmp(PasswordBuff,L"*")==0)
        	GetPassword(PasswordBuff,1024);
        Password = PasswordBuff;
	}



	////////////////////////////////////////////////////////////////////////////////
	// list || verify operation: simplified GetDomainInfo scenario...
	////////////////////////////////////////////////////////////////////////////////
	if ( List ) {
		ULONG i;
		
	    Status = GetDomainInfoForDomain((BDomain[0]==L'\0'?NULL:BDomain),BDC,&Remote, Mit );
	    if (!NT_SUCCESS( Status ) )
	        goto Done;
		Status = GetTrustLinks( &Remote );
	    if (Status!=STATUS_NO_MORE_ENTRIES && !NT_SUCCESS( Status ) )
	        goto Done;

		Status = PrintTrustLinks( &Remote );

		goto Done;		
	} else
	////////////////////////////////////////////////////////////////////////////////
	// verify operation
	////////////////////////////////////////////////////////////////////////////////
	if ( Verify ) {
        Status = VerifyTrusts( BDomain[ 0 ]==L'\0' ? NULL : BDomain, BDC );
        goto Done;
    }

	// regular operation: create/delete trust...
	// get info about the domain(s) involved...
    Status = GetDomainInfoForDomain((ADomain[0]==L'\0'?NULL:ADomain), ADC, &Local, FALSE );
    if ( !NT_SUCCESS( Status ) )
	        goto Done;
    Status = GetDomainInfoForDomain( BDomain, BDC, &Remote, Mit );
    if ( !NT_SUCCESS( Status ) ) {
		if(Mit) {	//assuming a Unix machine...
			dbgprintf( (0,IDS_DSGETDCNAME_MIT, BDomain) );
		}
		else {
		    if(!(	Force
		    		//&& (Status==STATUS_NO_SUCH_DOMAIN)
		    		//&& LocalOnly && Untrust
		    		))						// if -force not specified...
							    			// continue anyway
		        goto Done;
		}
    }

    //
    // Ok, now check or or delete or create  the trust objects...
    //
    ////////////////////////////////////////////////////////////////////////////////
    // check trust link
    ////////////////////////////////////////////////////////////////////////////////
    if ( Check ) {
		dbgprintf( (0, IDS_PROCESSDOM, GetName(&Local)) );
        Status = CheckTrustLink( &Local, &Remote );
        if (Status!=NERR_Success)
            dbgprintf( (0,IDS_LOCAL_CHK_TRUST_F,Status) );
        if ( !LocalOnly ) {
			dbgprintf( (0, IDS_PROCESSDOM, GetName(&Remote)) );
            Status = CheckTrustLink( &Remote, &Local );
            if (Status!=NERR_Success)
                dbgprintf( (IDS_REMOTE_CHK_TRUST_F,Status) );
        }
    // end check block...
    } else
    ////////////////////////////////////////////////////////////////////////////////
    // delete trust object
    ////////////////////////////////////////////////////////////////////////////////
    if ( Untrust ) {
		dbgprintf( (0, IDS_PROCESSDOM, GetName(&Local)) );
        Status = DeleteTrustLink( &Local, &Remote );
        if (Status!=NERR_Success)
            dbgprintf( (0,IDS_LOCAL_DEL_TRUST_F,Status) );
        if ( !LocalOnly ) {
			dbgprintf( (0, IDS_PROCESSDOM, GetName(&Remote)) );
            Status = DeleteTrustLink( &Remote, &Local );
            if (Status!=NERR_Success)
                dbgprintf( (IDS_REMOTE_DEL_TRUST_F,Status) );
        }
    // end untrust block...
    } else {
		////////////////////////////////////////////////////////////////////////////
		// create trust links
		////////////////////////////////////////////////////////////////////////////
        if ( Password == NULL ) {

            Password = L""; // no password specified? then use void password: ""
        }
        if((Local.majver==4 || Remote.majver==4) && !Downlevel) {
			if(!Force)
				Status = STATUS_INVALID_PARAMETER;
			resprintf(0,IDS_NT4_REQ_DOWNLEVEL,(Force?Xbuf:Ybuf));
			if(!NT_SUCCESS(Status))
				goto Done;
        }
        	

		//compute direction of trust based on the values of Both, DirIn, DirOut
		//'Both' has higher priority
		if(Both) {
			DirectionLocal=DirectionRemote=TRUST_DIRECTION_BIDIRECTIONAL;
		} else {
			//default is 'OUTBOUND'... as being DirIn==FALSE and DirOut==TRUE
			DirectionLocal	=(DirIn?TRUST_DIRECTION_INBOUND:TRUST_DIRECTION_OUTBOUND);
			DirectionRemote	=(DirIn?TRUST_DIRECTION_OUTBOUND:TRUST_DIRECTION_INBOUND);
		}
		
		swprintf(Xbuf,L"%wZ",GetName(&Local));
		swprintf(Ybuf,L"%wZ",GetName(&Remote));

		//RtlCopyUnicodeString(&uDomNameL,GetName(&Local));
		//RtlCopyUnicodeString(&uDomNameR,GetName(&Remote));

		dbgprintf( (0, IDS_PROCESSDOM, GetName(&Local)) );
        StatusL = CreateTrustLink( &Local, &Remote,
                                       Password,
                                       Downlevel,
                                       Mit,
                                       Parent,
                                       DirectionLocal	//Both ? TRUST_DIRECTION_BIDIRECTIONAL :
					                                    //       TRUST_DIRECTION_OUTBOUND
                                     );

        if (!NT_SUCCESS(StatusL))
            dbgprintf( (0,IDS_CREATE_TRUST_F, Xbuf,Ybuf,StatusL) );
        //if ( NT_SUCCESS( StatusL ) ) {	not needed...
        //    LocalCreated = TRUE;
        //}

        if ( NT_SUCCESS( StatusL ) && !LocalOnly )  {
			dbgprintf( (0, IDS_PROCESSDOM, GetName(&Remote)) );
            StatusR = CreateTrustLink( &Remote, &Local,
                                           Password,
                                           Downlevel,
                                           Mit,
                                           FALSE,
				                           DirectionRemote	//Both ? TRUST_DIRECTION_BIDIRECTIONAL :
				                                            //		 TRUST_DIRECTION_INBOUND
                                         );
            if (!NT_SUCCESS(StatusR))
                dbgprintf( (0,IDS_CREATE_TRUST_F, Ybuf,Xbuf, StatusR) );
        }

        if ( !NT_SUCCESS( StatusR ) && NT_SUCCESS( StatusL ) ) { //LocalCreated not used anymore....

            DeleteTrustLink( &Local, &Remote );
        }

    }

	Status = StatusL;
	if( NT_SUCCESS(Status) )	//maybe the 'Remote' attempt failed ?...
		Status = StatusR;

Done:

    FreeDomainInfo( &Local );
    FreeDomainInfo( &Remote );

    if( NT_SUCCESS( Status ) ) {

		//No message; in this way will be easier also to get a count of the trust links for a list:
		// by example, 'trustdom <dom> -list | findstr ",B," | wc' will get a count of the
		// bidirectional trusts of domain <dom>

        //printf("The command completed successfully\n");


    } else {

        resprintf(0,IDS_COMMAND_FAILED, Status );

    }

	// return 0 for SUCCESS and 1 for some error
    return( !NT_SUCCESS( Status ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\webchange\filesandactions.h ===
// FilesAndActions.h : Declaration of the CFilesAndActions

#pragma once
#include "resource.h"       // main symbols
#include <list>


// IFilesAndActions
[
	object,
	uuid("14AD0A5D-16AD-4C3F-A56D-A2F4FE7458F9"),
	dual,	helpstring("IFilesAndActions Interface"),
	pointer_default(unique)
]
__interface IFilesAndActions : IDispatch
{
	[propget, id(DISPID_VALUE), helpstring("property Item")] HRESULT Item([in] long Index, [out, retval] VARIANT* pVal);
	[propget, id(DISPID_NEWENUM), helpstring("property _NewEnum"), restricted] HRESULT _NewEnum([out, retval] LPUNKNOWN* pVal);
	[propget, id(1), helpstring("property Count")] HRESULT Count([out, retval] long* pVal);
	[id(2), helpstring("method Add. The new item is added to the end of the collection.")] HRESULT Add([in] VARIANT NewItem);
	[id(3), helpstring("method Remove. Specify the index of the item to remove.")] HRESULT Remove([in] long Index);
};



// CFilesAndActions

// typdefs to make life easier.
typedef std::list<CComVariant> StdVariantList;
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT>, StdVariantList> STLVariantEnum;
typedef ICollectionOnSTLImpl<IFilesAndActions, StdVariantList, VARIANT, _Copy<VARIANT>, STLVariantEnum> VariantCollImpl;

[
	coclass,
	threading("apartment"),
	vi_progid("WebChange.FilesAndActions"),
	progid("WebChange.FilesAndActions"),
	version(1.3),
	uuid("9819D968-C9A8-4528-BB0D-4AF0A8EDDBD8"),
	helpstring("FilesAndActions Class")
]
class ATL_NO_VTABLE CFilesAndActions : 
	public IDispatchImpl<VariantCollImpl, &__uuidof(IFilesAndActions)>,
	public IObjectSafetyImpl<CFilesAndActions,
							 INTERFACESAFE_FOR_UNTRUSTED_CALLER |
							 INTERFACESAFE_FOR_UNTRUSTED_DATA>
{
public:
	CFilesAndActions()
	{		
	}

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	
	void FinalRelease() 
	{
	}

public:
	STDMETHOD(Add)(VARIANT Item);
	STDMETHOD(Remove)(long Index);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\webchange\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// WebChange.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\webchange\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by WebChange.rc
//

#define IDS_PROJNAME                    100
#define IDR_WEBCHANGE	101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\webchange\webchange.cpp ===
// WebChange.cpp : Implementation of DLL Exports.

#include "stdafx.h"
#include "resource.h"

// The module attribute causes DllMain, DllRegisterServer and DllUnregisterServer to be automatically implemented for you
[
	module(dll, uuid = "{F15FC472-AD30-4426-B8A5-085E5AC7C0FE}",
	name = "WebChange",
	helpstring = "WebChange 1.0 Type Library",
	resource_name = "IDR_WEBCHANGE")
];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\webchange\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#ifndef STRICT
#define STRICT
#endif

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
#define WINVER 0x0400		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0400	// Change this to the appropriate value to target Windows 2000 or later.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
#define _WIN32_IE 0x0400	// Change this to the appropriate value to target IE 5.0 or later.
#endif

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_AUTOMATIC_NAMESPACE

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

// turns off ATL's hiding of some common and often safely ignored warning messages
#define _ATL_ALL_WARNINGS

#include <atlbase.h>
#include <atlcom.h>
#include <atlwin.h>
#include <atltypes.h>
#include <atlctl.h>
#include <atlhost.h>


using namespace ATL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\webchange\webchangelisteditor.cpp ===
// WebChangelistEditor.cpp : Implementation of CWebChangelistEditor

#include "stdafx.h"
#include "WebChangelistEditor.h"
#include <fcntl.h>


// CWebChangelistEditor


STDMETHODIMP CWebChangelistEditor::Initialize(BSTR ChangelistKey, BOOL* Result)
{
    HKEY	 hKey = NULL;
	DWORD	 cbData = MAX_PATH * sizeof(WCHAR);
	DWORD	 dwDatatype;

	// Initialize the Result return value to FALSE:
	if (Result == NULL)
		return E_POINTER;

	*Result = FALSE;

	// Put our Key/Value name into a CComBSTR
	m_ChangelistKey = ChangelistKey;

	// Make sure we can't be initialized twice:
	if (m_fInitialized)
		return E_FAIL;

	// Sanity check the ChangelistKey argument.
	// It must be 40 characters, null-terminated, containing only hex digits.
	if (m_ChangelistKey.Length() != 40)
		goto Done;
	if (m_ChangelistKey[40] != L'\0')
		goto Done;
	if (wcsspn(m_ChangelistKey, L"ABCDEFabcdef1234567890") != 40)
		goto Done;

	// Open our Key:
	if (RegOpenKeyExW(HKEY_CURRENT_USER,
					 g_wszRegKey,
					 0,
					 KEY_QUERY_VALUE,
					 &hKey) != ERROR_SUCCESS)
	{
		hKey = NULL;
		goto Done;
	}

	// Read the specified subkey:
	if ((RegQueryValueExW(hKey,
						  m_ChangelistKey,
						  0,
						  &dwDatatype,
						  (LPBYTE)m_wszCLFilename,
						  &cbData) != ERROR_SUCCESS) ||
		(dwDatatype != REG_SZ))
	{
		goto Done;
	}

	// Now that we have the filename and key read successfully
	// we can parse the file and populate all the properties of this object.
    *Result = m_fInitialized = _ReadFile();

Done:
	if (hKey != NULL)
		RegCloseKey(hKey);

	if (!m_fInitialized)
	{
		// If we failed, clean up nicely.
		_WipeRegEntries();
	}

	return S_OK;
}

STDMETHODIMP CWebChangelistEditor::Save()
{
	FILE				*CLFile = NULL;
	IFilesAndActions	*pIFiles = NULL;
	IFileAndAction		*pIFile = NULL;
	long				count;
	VARIANT				varTemp;
	CComBSTR			bstrFilename;
	CComBSTR			bstrAction;
	BOOL				fEnabled;
	HKEY				hKey;

	// Save can't be called unless we've been properly initialized
	if (!m_fInitialized)
		return E_FAIL;

	// Open the file write-only.
	// This clears the file contents.
	CLFile = _wfopen(m_wszCLFilename, L"wt");
	if (CLFile == NULL)
		goto Done;

	// Print a much shortened comment block:
	fwprintf(CLFile, L"# Source Depot Changelist.\n");
	// Print the simple stuff
	fwprintf(CLFile, L"\nChange:\t%s\n", m_Change);
	if (_wcsicmp(m_Status, L"new") != 0)
	{
		// Only print the Date line if Status != "new"
		fwprintf(CLFile, L"\nDate:\t%s\n", m_Date);
	}
	fwprintf(CLFile, L"\nClient:\t%s\n", m_Client);
	fwprintf(CLFile, L"\nUser:\t%s\n", m_User);
	fwprintf(CLFile, L"\nStatus:\t%s\n", m_Status);
	fwprintf(CLFile, L"\nDescription:\n");
	fwprintf(CLFile, L"\t%s\n", m_Description);
	fwprintf(CLFile, L"\nFiles:\n");

	// Get the FilesAndActions interface
	if (FAILED(m_Files->QueryInterface<IFilesAndActions>(&pIFiles)))
		goto Done; // This shouldn't ever fail.

	varTemp.vt = VT_EMPTY;

	// Loop over the entries and remove each entry as we print it
	while (SUCCEEDED(pIFiles->get_Count(&count)) &&
			(count >= 1))
	{
		if (SUCCEEDED(pIFiles->get_Item(1, &varTemp)) && // Get item
			(varTemp.vt == VT_DISPATCH) && // Check Variant type
			(pIFile = (IFileAndAction*)varTemp.pdispVal) && // <-- Yes, this is an assignment
			SUCCEEDED(pIFile->get_Filename(&bstrFilename)) &&
			SUCCEEDED(pIFile->get_Action(&bstrAction)) &&
			SUCCEEDED(pIFile->get_Enabled(&fEnabled)))
		{
			// If it's enabled, print the complete line.
			if (fEnabled)
				fwprintf(CLFile, L"\t%s\t# %s\n", bstrFilename, bstrAction);
			// Clean up for the next pass
			//pIFile->Release();
			pIFile = NULL;
			VariantClear(&varTemp);
			pIFiles->Remove(1);
		}
		else
			break; // This should not happen.
	} // End of while loop


Done:
	// OK, we're closing. Un-Initialize the thing.
	m_fInitialized = FALSE;

	// Close the file
	if (CLFile)
		fclose(CLFile);

	// Release the FilesAndActions interface
	if (pIFiles)
		pIFiles->Release();

	// Delete the registry value we used.
	// This may trigger the waiting executable to continue, so do
	// this _after_ saving and closing the file.
	if (RegOpenKeyExW(HKEY_CURRENT_USER,
					  g_wszRegKey,
					  0,
					  KEY_QUERY_VALUE | KEY_SET_VALUE,
					  &hKey) == ERROR_SUCCESS)
	{
		RegDeleteValueW(hKey, m_ChangelistKey);
		RegCloseKey(hKey);
	}

	return S_OK;
}

BOOL CWebChangelistEditor::_ReadFile(void)
{
	BOOL						fRetVal = FALSE;
	FILE						*CLFile = NULL;
	IFilesAndActions			*pIFiles = NULL;
	WCHAR						wszBuffer[500];
	WCHAR						wszBuffer2[500];
	WCHAR						wszBuffer3[50];
	long						count;
	DWORD						dwState = 0; // State of parsing engine


	// Ensure that we don't have any old Files entries
	if (FAILED(m_Files->QueryInterface<IFilesAndActions>(&pIFiles)))
		return FALSE;

	if (FAILED(pIFiles->get_Count(&count)))
		goto Done;

	if (count != 0)
		goto Done;

	// Open the file read-only
	CLFile = _wfopen(m_wszCLFilename, L"rt");
	if (CLFile == NULL)
		goto Done;

	while (fwscanf(CLFile, L"%499[^\n]%*[\n]", &wszBuffer) == 1)
	{
		// Expect a comment block at the top of the file
		switch (dwState)
		{
		case 0: // Comment block at top of file
			if (wszBuffer[0] == L'#')
			{
				// Skip each comment line
				break;
			}
			else
			{
				// Stop expecting a comment block
				dwState++;
				// Fall through to status=1 below
			}
		case 1: // Change field
			if (wcsncmp(wszBuffer, L"Change:\t", 8) == 0)
			{
				// Store the Change string:
				m_Change = &wszBuffer[8];
				// move on:
				dwState++;
				break;
			}
			else
			{
				// Invalid file.
				goto Done;
			}
		case 2: // Date field
			if (wcsncmp(wszBuffer, L"Date:\t", 6) == 0)
			{
				// Store the Date string:
				m_Date = &wszBuffer[6];
				// move on:
				dwState++;
				break;
			}
			else
			{
				// Maybe the Date line is missing. Skip it.
				dwState++;
				// Fall through to status=3 below
			}
		case 3: // Client field
			if (wcsncmp(wszBuffer, L"Client:\t", 8) == 0)
			{
				// Store the Client string:
				m_Client = &wszBuffer[8];
				// move on:
				dwState++;
				break;
			}
			else
			{
				// Invalid file.
				goto Done;
			}
		case 4: // User field
			if (wcsncmp(wszBuffer, L"User:\t", 6) == 0)
			{
				// Store the User string:
				m_User = &wszBuffer[6];
				// move on:
				dwState++;
				break;
			}
			else
			{
				// Invalid file.
				goto Done;
			}
		case 5: // Status field
			if (wcsncmp(wszBuffer, L"Status:\t", 8) == 0)
			{
				// Store the Status string:
				m_Status = &wszBuffer[8];
				// move on:
				dwState++;
				break;
			}
			else
			{
				// Invalid file.
				goto Done;
			}
		case 6: // Description field name
			if (wcscmp(wszBuffer, L"Description:") == 0)
			{
				// Found it, but the actual Description is on the next line
				dwState++;
				break;
			}
			else
			{
				// Invalid file.
				goto Done;
			}
		case 7: // Description field value
			if (wszBuffer[0] == L'\t')
			{
				// Store the Description string:
				m_Description = &wszBuffer[1];
				// move on:
				dwState++;
				break;
			}
			else
			{
				// Invalid file.
				goto Done;
			}
		case 8: // Files field name
			if (wcscmp(wszBuffer, L"Files:") == 0)
			{
				// Found it, but the actual Files and Actions are on the following lines
				dwState++;
				break;
			}
			else
			{
				// Invalid file.
				goto Done;
			}
		case 9: // Files and Actions field values
			if (swscanf(wszBuffer, L"\t%499[^\t]\t# %49s",
							wszBuffer2, wszBuffer3) == 2)
			{
				// Add the new FileAndAction data
				if (_AddFileAndAction(pIFiles, wszBuffer2, wszBuffer3) == FALSE)
				{
					// Unable to add data. Nothing we can do about it.
					goto Done;
				}

				// move on:
				break; // This is the final state. No increment.
			}
			else
			{
				// Invalid file.
				goto Done;
			}
		} // end of case statement
	} // end of while loop

	if ((dwState == 7) || (dwState == 9))
	{
		// We got to the Description section, so we completed parsing successfully.
		fRetVal = TRUE;
	}
Done:
	if ((dwState == 9) && (fRetVal == FALSE))
	{
		// We might have to remove some failed files entries
		while (SUCCEEDED(pIFiles->get_Count(&count)) &&
			   (count >= 1))
		{
			if (FAILED(pIFiles->Remove(1)))
				break;
		}
	}
	if (pIFiles)
		pIFiles->Release();
	if (CLFile)
		fclose(CLFile);
	return fRetVal;
}

BOOL CWebChangelistEditor::_AddFileAndAction(IFilesAndActions *pIFiles, WCHAR* wszFilename, WCHAR* wszAction)
{
	CComBSTR					bstrFile = wszFilename;
	CComBSTR					bstrAction = wszAction;
	IFileAndAction				*pIFile = NULL;
	CComObject<CFileAndAction>	*pBase = NULL;
	CComVariant					varTemp;

	// Create a new FileAndAction object
	if (FAILED(CComObject<CFileAndAction>::CreateInstance(&pBase)))
	{
		// Unable to create instance. Nothing we can do about it.
		return FALSE;
	}
	if (FAILED(pBase->QueryInterface<IFileAndAction>(&pIFile)))
	{
		// Unable to query inferface. Nothing we can do about it.
		return FALSE;
	}
	
	// Add the data to the new object
	if (FAILED(pIFile->put_Action(bstrAction)) ||
		FAILED(pIFile->put_Filename(bstrFile)))
	{
		// Unable to add data. Nothing we can do about it.
		pIFile->Release();
		return FALSE;
	}

	// Put the Interface ptr into a Variant, and release the old Interface ptr
	varTemp = (IDispatch*)pIFile;
	pIFile->Release();

	// Add the new object to the collection
	if (FAILED(pIFiles->Add(varTemp)))
	{
		// Unable to add data. Nothing we can do about it.
		return FALSE;
	}

	// Success
	return TRUE;
}

void CWebChangelistEditor::_WipeRegEntries(void)
{
	HKEY	hKey = NULL;
	WCHAR	wszValueName[41];
	DWORD	cchValueName = 41;
	DWORD	dwDatatype;
	DWORD	dwIndex;
	HRESULT	hr;

	// Open our Key:
	if (RegOpenKeyExW(HKEY_CURRENT_USER,
					 g_wszRegKey,
					 0,
					 KEY_QUERY_VALUE | KEY_SET_VALUE,
					 &hKey) != ERROR_SUCCESS)
	{
		hKey = NULL;
		goto Done;
	}

	// For each value under that is named a 40-digit hex value,
	// Delete it.
	dwIndex = 0;
	while ((hr = RegEnumValueW(hKey,
							   dwIndex,
							   wszValueName,
							   &cchValueName,
							   0,
							   &dwDatatype,
							   NULL, NULL)) != ERROR_NO_MORE_ITEMS)
	{
		if (FAILED(hr))
		{
			// This is most likely because the buffers are the wrong size
			// but we don't care about the key unless we can read it into
			// the buffers we've got, so just move on.		
			dwIndex++;
			cchValueName = 41; // Set it back to the size of the buffer.
			continue;
		}
		// Check the datatype:
		if (dwDatatype != REG_SZ)
		{
			dwIndex++;
			cchValueName = 41; // Set it back to the size of the buffer.
			continue;
		}
		// Check the name:
		// It must be 40 characters, containing only hex digits.
		if ((cchValueName != 40) ||
			(wcsspn(wszValueName, L"ABCDEFabcdef1234567890") != 40))
		{
			dwIndex++;
			cchValueName = 41; // Set it back to the size of the buffer.
			continue;
		}
		// If all the above checks succeeded, delete the value.
		RegDeleteValueW(hKey, wszValueName);
		// Since we've changed the indexing, start over:
		cchValueName = 41; // Set it back to the size of the buffer.
		dwIndex = 0;
	}

Done:
	if (hKey != NULL)
		RegCloseKey(hKey);
}

STDMETHODIMP CWebChangelistEditor::get_Change(BSTR* pVal)
{
	if (pVal == NULL)
		return E_POINTER;
	if (!m_fInitialized)
		return E_FAIL;

	return m_Change.CopyTo(pVal);
}

STDMETHODIMP CWebChangelistEditor::put_Change(BSTR newVal)
{
	if (!m_fInitialized)
		return E_FAIL;

	m_Change = newVal;
	return S_OK;
}

STDMETHODIMP CWebChangelistEditor::get_Date(BSTR* pVal)
{
	if (pVal == NULL)
		return E_POINTER;
	if (!m_fInitialized)
		return E_FAIL;

	return m_Date.CopyTo(pVal);
}

STDMETHODIMP CWebChangelistEditor::put_Date(BSTR newVal)
{
	if (!m_fInitialized)
		return E_FAIL;

	m_Date = newVal;
	return S_OK;
}

STDMETHODIMP CWebChangelistEditor::get_Client(BSTR* pVal)
{
	if (pVal == NULL)
		return E_POINTER;
	if (!m_fInitialized)
		return E_FAIL;

	return m_Client.CopyTo(pVal);
}

STDMETHODIMP CWebChangelistEditor::put_Client(BSTR newVal)
{
	if (!m_fInitialized)
		return E_FAIL;

	m_Client = newVal;
	return S_OK;
}

STDMETHODIMP CWebChangelistEditor::get_User(BSTR* pVal)
{
	if (pVal == NULL)
		return E_POINTER;
	if (!m_fInitialized)
		return E_FAIL;

	return m_User.CopyTo(pVal);
}

STDMETHODIMP CWebChangelistEditor::put_User(BSTR newVal)
{
	if (!m_fInitialized)
		return E_FAIL;

	m_User = newVal;
	return S_OK;
}

STDMETHODIMP CWebChangelistEditor::get_Status(BSTR* pVal)
{
	if (pVal == NULL)
		return E_POINTER;
	if (!m_fInitialized)
		return E_FAIL;

	return m_Status.CopyTo(pVal);
}

STDMETHODIMP CWebChangelistEditor::put_Status(BSTR newVal)
{
	if (!m_fInitialized)
		return E_FAIL;

	m_Status = newVal;
	return S_OK;
}

STDMETHODIMP CWebChangelistEditor::get_Description(BSTR* pVal)
{
	if (pVal == NULL)
		return E_POINTER;
	if (!m_fInitialized)
		return E_FAIL;

	return m_Description.CopyTo(pVal);
}

STDMETHODIMP CWebChangelistEditor::put_Description(BSTR newVal)
{
	if (!m_fInitialized)
		return E_FAIL;

	m_Description = newVal;
	return S_OK;
}

STDMETHODIMP CWebChangelistEditor::get_Files(IFilesAndActions** pVal)
{
	if (pVal == NULL)
		return E_POINTER;
	if (!m_fInitialized)
		return E_FAIL;

	return m_Files->QueryInterface<IFilesAndActions>(pVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\webchange\webchangelisteditor.h ===
// WebChangelistEditor.h : Declaration of the CWebChangelistEditor

#pragma once
#include "resource.h"       // main symbols
#include "atlcomcli.h"
#include <io.h>
#include "FilesAndActions.h"
#include "FileAndAction.h"


// Globals
const WCHAR* g_wszRegKey = L"Software\\Microsoft\\WebChangelistEditor";


// IWebChangelistEditor
[
	object,
	uuid("C0DBCFAB-FA09-4FD9-825B-B37CEA10CB40"),
	dual,	helpstring("IWebChangelistEditor Interface"),
	pointer_default(unique)
]
__interface IWebChangelistEditor : IDispatch
{
	[id(1), helpstring("method Initialize")] HRESULT Initialize([in] BSTR ChangelistKey, [out, retval] BOOL* Result);
	[id(2), helpstring("method Finish")] HRESULT Save();
	[propget, id(3), helpstring("property Change. This is either the changelist number for an existing changelist or 'new' for a new changelist.")] HRESULT Change([out, retval] BSTR* pVal);
	[propput, id(3), helpstring("property Change. This is either the changelist number for an existing changelist or 'new' for a new changelist.")] HRESULT Change([in] BSTR newVal);
	[propget, id(4), helpstring("property Date")] HRESULT Date([out, retval] BSTR* pVal);
	[propput, id(4), helpstring("property Date")] HRESULT Date([in] BSTR newVal);
	[propget, id(5), helpstring("property Client. The Source Depot client name is usually a derivative of the computer name.")] HRESULT Client([out, retval] BSTR* pVal);
	[propput, id(5), helpstring("property Client. The Source Depot client name is usually a derivative of the computer name.")] HRESULT Client([in] BSTR newVal);
	[propget, id(6), helpstring("property User. Domain user name, usually in the format DOMAIN\\user")] HRESULT User([out, retval] BSTR* pVal);
	[propput, id(6), helpstring("property User. Domain user name, usually in the format DOMAIN\\user")] HRESULT User([in] BSTR newVal);
	[propget, id(7), helpstring("property Status. Examples of valid Status values are New, Pending, and Submitted.")] HRESULT Status([out, retval] BSTR* pVal);
	[propput, id(7), helpstring("property Status. Examples of valid Status values are New, Pending, and Submitted.")] HRESULT Status([in] BSTR newVal);
	[propget, id(8), helpstring("property Description")] HRESULT Description([out, retval] BSTR* pVal);
	[propput, id(8), helpstring("property Description")] HRESULT Description([in] BSTR newVal);
	[propget, id(9), helpstring("property Files is a collection of FileAndAction objects.")] HRESULT Files([out, retval] IFilesAndActions** pVal);
};



// CWebChangelistEditor

[
	coclass,
	threading("apartment"),
	vi_progid("WebChange.WebChangelistEditor"),
	progid("WebChange.WebChangelistEditor"),
	version(1.3),
	uuid("D1308BC0-D844-4EAC-AE31-D46E4EA87876"),
	helpstring("WebChangelistEditor Class")
]
class ATL_NO_VTABLE CWebChangelistEditor : 
	public IWebChangelistEditor,
	public IObjectSafetyImpl<CWebChangelistEditor,
							 INTERFACESAFE_FOR_UNTRUSTED_CALLER |
							 INTERFACESAFE_FOR_UNTRUSTED_DATA>

{
public:
	CWebChangelistEditor()
		: m_fInitialized(FALSE)
	{
	}


	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		HRESULT hr;
		m_wszCLFilename[0] = L'\0';
		hr = CComObject<CFilesAndActions>::CreateInstance(&m_Files);
		if (FAILED(hr))
		{
			m_Files = NULL;
			return hr;
		}
		m_Files->AddRef();
		return S_OK;
	}
	
	void FinalRelease() 
	{
		if (m_Files != NULL)
			m_Files->Release();
	}

public:

	STDMETHOD(Initialize)(BSTR ChangelistKey, BOOL* Result);
	STDMETHOD(Save)();
	STDMETHOD(get_Change)(BSTR* pVal);
	STDMETHOD(put_Change)(BSTR newVal);
	STDMETHOD(get_Date)(BSTR* pVal);
	STDMETHOD(put_Date)(BSTR newVal);
	STDMETHOD(get_Client)(BSTR* pVal);
	STDMETHOD(put_Client)(BSTR newVal);
	STDMETHOD(get_User)(BSTR* pVal);
	STDMETHOD(put_User)(BSTR newVal);
	STDMETHOD(get_Status)(BSTR* pVal);
	STDMETHOD(put_Status)(BSTR newVal);
	STDMETHOD(get_Description)(BSTR* pVal);
	STDMETHOD(put_Description)(BSTR newVal);
	STDMETHOD(get_Files)(IFilesAndActions** pVal);
private:
	CComBSTR						m_Change;
	CComBSTR						m_Date;
	CComBSTR						m_Client;
	CComBSTR						m_User;
	CComBSTR						m_Status;
	CComBSTR						m_Description;
	CComBSTR						m_ChangelistKey;
	CComObject<CFilesAndActions>	*m_Files;
	BOOL							m_fInitialized;
	WCHAR							m_wszCLFilename[MAX_PATH];

	BOOL		_ReadFile(void);
	void		_WipeRegEntries(void);
	BOOL		_AddFileAndAction(IFilesAndActions *pIFiles, WCHAR* wszFilename, WCHAR* wszAction);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\pch.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    This module contains function prototypes.

Author:

    Jeffrey Lawson (jlawson) 12-Apr-2000

Revision History:

--*/

#ifndef _WINSAFER_PCH_
#define _WINSAFER_PCH_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif
//
// Include Common Definitions.
//

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    );


#ifdef __cplusplus
} // extern "C"
#endif

#endif // _WINSAFER_PCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safecann.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafeCann.c        (WinSAFER Filename Canonicalization)

Abstract:

    This module implements the WinSAFER APIs that produce canonicalized
    filenames from a caller-supplied .

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzFullyQualifyFilename

Revision History:

    Created - Nov 2000

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"


//
// Defines the maximum recursion depth that will be used when attempting
// to resolve the final mapping of SUBST'ed drives.  For worst-case, value
// shouldn't be greater than 26 (the number of possible drive letters).
//
#define MAX_RECURSE_DRIVE_LETTER        10


//
// Some static name prefixes in the NT object namespace.
//
static const UNICODE_STRING UnicodeDeviceWinDfs =
        RTL_CONSTANT_STRING( L"\\Device\\WinDfs\\" );
static const UNICODE_STRING UnicodeDeviceLanman =
        RTL_CONSTANT_STRING( L"\\Device\\LanmanRedirector\\" );
static const UNICODE_STRING UnicodeDosDevicesUncPrefix =
        RTL_CONSTANT_STRING( L"\\??\\UNC\\" );
static const UNICODE_STRING UnicodeDosDevicesPrefix =
        RTL_CONSTANT_STRING( L"\\??\\" );
static const UNICODE_STRING UnicodeDevicePrefix =
        RTL_CONSTANT_STRING( L"\\Device\\" );




static BOOLEAN FORCEINLINE
SaferpIsAlphaLetter(
        IN WCHAR inwcletter
        )
{
#if 1
    if ((inwcletter >= L'A' && inwcletter <= L'Z') ||
        (inwcletter >= L'a' && inwcletter <= L'z'))
        return TRUE;
    else
        return FALSE;
#else
    inwcletter = RtlUpcaseUnicodeChar(inwcletter);
    return (inwcletter >= L'A' && inwcletter <= 'Z') ? TRUE : FALSE;
#endif
}



static BOOLEAN NTAPI
SaferpQueryActualDriveLetterFromDriveLetter(
        IN WCHAR        inDriveLetter,
        OUT WCHAR       *outDriveLetter,
        IN SHORT        MaxRecurseCount
        )
/*++

Routine Description:

    Attempts to determine if a specified drive letter is a SUBST'ed
    drive letter, a network mapped drive letter, or a physical drive
    letter.  Unknown cases result in a failure.

Arguments:

    inDriveLetter - Drive leter to obtain information about.  This must
            be an alphabetic character.

    outDriveLetter - Receives the result of the evaluation and indicates
            what drive letter the requested one actually points to:
               -->  If the drive letter is a SUBST'ed drive, then the result
                    will be the drive letter of the original drive.
               -->  If the drive letter is a network mapped drive, then the
                    result will be UNICODE_NULL, indicating a network volume.
               -->  If the drive letter is a local, physical drive, then
                    the result will be the same as the input letter.

    MaxRecurseCount - used for limiting maximum recursion depth.
            Recommend specifying a reasonable positive value.

Return Value:

    Returns TRUE on successful operation, FALSE if the determination
    could not be made.

--*/
{
    NTSTATUS Status;
    HANDLE LinkHandle;
    UNICODE_STRING UnicodeFileName;
    OBJECT_ATTRIBUTES Attributes;
    const WCHAR FileNameBuffer[7] = { L'\\', L'?', L'?', L'\\',
            inDriveLetter, L':', UNICODE_NULL };
    UNICODE_STRING LinkValue;
    WCHAR LinkValueBuffer[2*MAX_PATH];
    ULONG ReturnedLength;


    //
    // Require that the input drive letter be alphabetic.
    //
    if (!SaferpIsAlphaLetter(inDriveLetter)) {
        // Input drive letter was not uppercase alphabetic.
        return FALSE;
    }


    //
    // Open a reference to see if there are any links.
    //
    RtlInitUnicodeString(&UnicodeFileName, FileNameBuffer);
    InitializeObjectAttributes(&Attributes, &UnicodeFileName,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);
    Status = NtOpenSymbolicLinkObject (&LinkHandle,
                                       SYMBOLIC_LINK_QUERY,
                                       &Attributes);
    if (!NT_SUCCESS(Status)) {
        // Unable to open the drive letter so it must not exist.
        return FALSE;
    }


    //
    // Now query the link and see if there is a redirection
    //
    LinkValue.Buffer = LinkValueBuffer;
    LinkValue.Length = 0;
    LinkValue.MaximumLength = (USHORT)(sizeof(LinkValueBuffer));
    ReturnedLength = 0;
    Status = NtQuerySymbolicLinkObject( LinkHandle,
                                        &LinkValue,
                                        &ReturnedLength
                                      );
    NtClose( LinkHandle );
    if (!NT_SUCCESS(Status)) {
        // Could not retrieve final link destination.
        return FALSE;
    }


    //
    // Analyze the resulting link destination and extract the
    // actual destination drive letter or network path.
    //
    if (RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDeviceWinDfs,
                &LinkValue, TRUE) ||
        RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDeviceLanman,
                &LinkValue, TRUE) ||
        RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDosDevicesUncPrefix,
                &LinkValue, TRUE))
        // Note: Other network redirectors (Netware, NFS, etc) will not be known as such.
        // Maybe there is a way to query if a device is a "network redirector"?
    {
        // This is a network volume.
        *outDriveLetter = UNICODE_NULL;
        return TRUE;
    }
    else if (RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDosDevicesPrefix,
                &LinkValue, TRUE) &&
             LinkValue.Length >= 6 * sizeof(WCHAR) &&
             LinkValue.Buffer[5] == L':' &&
             SaferpIsAlphaLetter(LinkValue.Buffer[4]))
    {
        // This is a SUBST'ed drive letter.
        // We need to recurse, since you can SUBST multiple times,
        // or SUBST a network mapped drive to a second drive letter.
        if (MaxRecurseCount > 0) {
            // Tail recursion here would be nice.
            return SaferpQueryActualDriveLetterFromDriveLetter(
                LinkValue.Buffer[4], outDriveLetter, MaxRecurseCount - 1);
        }
        return FALSE;
    }
    else if (RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDevicePrefix,
                &LinkValue, TRUE))
    {
        // Otherwise this drive letter is an actual device and is
        // apparently its own identity.  However, network redirectors
        // that we did not know about will also fall into this bucket.
        *outDriveLetter = inDriveLetter;
        return TRUE;
    } else {
        // Otherwise we don't know what it is.
        return FALSE;
    }
}



static BOOLEAN NTAPI
SaferpQueryCanonicalizedDriveLetterFromDosPathname(
        IN LPCWSTR          szDosPathname,
        OUT WCHAR           *wcDriveLetter
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    RTL_PATH_TYPE PathType;


    //
    // Verify input arguments were supplied.
    //
    if (!ARGUMENT_PRESENT(szDosPathname) ||
        !ARGUMENT_PRESENT(wcDriveLetter)) {
        return FALSE;
    }


    //
    // Determine what syntax this DOS pathname was supplied to us as.
    //
    PathType = RtlDetermineDosPathNameType_U(szDosPathname);
    switch (PathType) {

        case RtlPathTypeUncAbsolute:
            // definitely a network volume.
            *wcDriveLetter = UNICODE_NULL;
            return TRUE;


        case RtlPathTypeDriveAbsolute:
        case RtlPathTypeDriveRelative:
            // explicitly specified drive letter, but need to handle subst or network mapped.
        {
            WCHAR CurDrive = RtlUpcaseUnicodeChar( szDosPathname[0] );
            if (SaferpQueryActualDriveLetterFromDriveLetter(
                        CurDrive, wcDriveLetter, MAX_RECURSE_DRIVE_LETTER)) {
                return TRUE;
            }
            break;
        }


        case RtlPathTypeRooted:
        case RtlPathTypeRelative:
            // relative to current drive, but still need to handle subst or network mapped.
        {
            PCURDIR CurDir;
            WCHAR CurDrive;

            CurDir = &(NtCurrentPeb()->ProcessParameters->CurrentDirectory);
            CurDrive = RtlUpcaseUnicodeChar( CurDir->DosPath.Buffer[0] );

            if (SaferpQueryActualDriveLetterFromDriveLetter(
                        CurDrive, wcDriveLetter, MAX_RECURSE_DRIVE_LETTER)) {
                return TRUE;
            }
            break;
        }


        // Everything else gets rejected:
        //      RtlPathTypeUnknown
        //      RtlPathTypeLocalDevice
        //      RtlPathTypeRootLocalDevice
    }

    return FALSE;
}



static BOOLEAN NTAPI
SaferpQueryCanonicalizedDriveLetterFromNtPathname(
        IN LPCWSTR          szNtPathname,
        OUT WCHAR           *wcDriveLetter
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    UNICODE_STRING LinkValue;


    RtlInitUnicodeString(&LinkValue, szNtPathname);


    //
    // Analyze the resulting link destination and extract the
    // actual destination drive letter or network path.
    //
    if (RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDeviceWinDfs,
                &LinkValue, TRUE) ||
        RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDeviceLanman,
                &LinkValue, TRUE) ||
        RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDosDevicesUncPrefix,
                &LinkValue, TRUE))
        // Note: Other network redirectors (Netware, NFS, etc) will not be known as such.
        // Maybe there is a way to query if a device is a "network redirector"?
    {
        // This is a network volume.
        *wcDriveLetter = UNICODE_NULL;
        return TRUE;
    }
    else if (RtlPrefixUnicodeString(
                (PUNICODE_STRING) &UnicodeDosDevicesPrefix,
                &LinkValue, TRUE) &&
             LinkValue.Length >= 6 * sizeof(WCHAR) &&
             LinkValue.Buffer[5] == L':' &&
             SaferpIsAlphaLetter(LinkValue.Buffer[4]))
    {
        // This is a SUBST'ed drive letter.
        // We need to recurse, since you can SUBST multiple times,
        // or SUBST a network mapped drive to a second drive letter.
        return SaferpQueryActualDriveLetterFromDriveLetter(
            LinkValue.Buffer[4], wcDriveLetter, MAX_RECURSE_DRIVE_LETTER);
    }
    else {
        // Otherwise we don't know what it is.
        return FALSE;
    }
}




static NTSTATUS NTAPI
SaferpQueryFilenameFromHandle(
        IN HANDLE               hFileHandle,
        IN WCHAR                wcDriveLetter,
        OUT PUNICODE_STRING     pUnicodeOutput
        )
/*++

Routine Description:

    Attempts to determine the fully qualified, canonicalized long
    filename version of the file associated with a given file handle.

    Note that the behavior provided by this function is a frequently
    requested API by Win32 developers because this information is
    normally not available by any other way through documented
    Win32 API calls.  However, even this implementation is not able to
    generally satisfy the general case very well due the limited access
    to the full path information from user-mode.

Arguments:

    hFileHandle -

    wcDriveLetter -

    pUnicodeOutput - Canonicalized DOS namespace filename, or
        potentially a UNC network path.

Return Value:

    Returns STATUS_SUCCESS on successful completion, otherwise an error code.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PWCHAR szLongFileNameBuffer = NULL;

    PBYTE FileNameInfoBuffer = NULL;
    PFILE_NAME_INFORMATION pFileNameInfo = NULL;
    DWORD Size = (sizeof(WCHAR) * MAX_PATH) + sizeof(FILE_NAME_INFORMATION);

    PUCHAR Buffer = NULL;

    UNICODE_STRING UnicodeFileName = {0};

    Buffer = (PUCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, Size); 

    if (Buffer == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    pFileNameInfo = (PFILE_NAME_INFORMATION) Buffer;

    //
    // Query the full path and filename (minus the drive letter).
    //
    Status = NtQueryInformationFile(
                hFileHandle,
                &IoStatusBlock,
                pFileNameInfo,
                Size,
                FileNameInformation);

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    //
    // Initialize the UNICODE_STRING reference to the output string.
    //
    UnicodeFileName.Buffer = pFileNameInfo->FileName;
    UnicodeFileName.Length = (USHORT) pFileNameInfo->FileNameLength;
    UnicodeFileName.MaximumLength = (USHORT) (sizeof(WCHAR) * MAX_PATH);
    ASSERT(UnicodeFileName.Length <= UnicodeFileName.MaximumLength);

    //
    // Perform some additional fixups depending upon whether we
    // were told that the file eventually comes from a local drive
    // letter or a network/dfs share.
    //
    if (wcDriveLetter == UNICODE_NULL)
    {
        // Ensure there is room for one more character.
        if (UnicodeFileName.Length + sizeof(WCHAR) >
            UnicodeFileName.MaximumLength) {
            Status =  STATUS_BUFFER_OVERFLOW;
            goto Cleanup;
        }

        // We've been told that this comes from a network volume,
        // so we need to prepend another backslash to the front.
        RtlMoveMemory(&UnicodeFileName.Buffer[1],
                      &UnicodeFileName.Buffer[0],
                      UnicodeFileName.Length);
        ASSERT(UnicodeFileName.Buffer[0] == L'\\' &&
               UnicodeFileName.Buffer[1] == L'\\');
        UnicodeFileName.Length += sizeof(WCHAR);
    }
    else if (SaferpIsAlphaLetter(wcDriveLetter))
    {
        // Ensure there is room for two more characters.
        if (UnicodeFileName.Length + 2 * sizeof(WCHAR) >
            UnicodeFileName.MaximumLength) {
            Status = STATUS_BUFFER_OVERFLOW;
            goto Cleanup;
        }

        // We've been told that this comes from a local drive.
        RtlMoveMemory(&UnicodeFileName.Buffer[2],
                      &UnicodeFileName.Buffer[0],
                      UnicodeFileName.Length);
        UnicodeFileName.Buffer[0] = RtlUpcaseUnicodeChar(wcDriveLetter);
        UnicodeFileName.Buffer[1] = L':';
        ASSERT(UnicodeFileName.Buffer[2] == L'\\');
        UnicodeFileName.Length += 2 * sizeof(WCHAR);
    }
    else {
        // Otherwise invalid input.
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Make sure the string is NULL terminated
    //

    UnicodeFileName.Buffer[(UnicodeFileName.Length)/sizeof(WCHAR)] = L'\0';

    szLongFileNameBuffer = (PWCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, (MAX_PATH * sizeof(WCHAR))); 

    if (szLongFileNameBuffer == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    szLongFileNameBuffer[0] =  L'\0';

    if (GetLongPathNameW(UnicodeFileName.Buffer,
                          szLongFileNameBuffer,
                          MAX_PATH)) {

        RtlInitUnicodeString(&UnicodeFileName, szLongFileNameBuffer);
    }


    //
    // Duplicate the local string into a new memory buffer so we
    // can pass it back to the caller.
    Status = RtlDuplicateUnicodeString(
                    RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE,
                    &UnicodeFileName,
                    pUnicodeOutput);

Cleanup:

    if (Buffer != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
    }

    if (szLongFileNameBuffer != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, szLongFileNameBuffer);
    }

    return Status;
}




NTSTATUS NTAPI
CodeAuthzFullyQualifyFilename(
        IN HANDLE               hFileHandle         OPTIONAL,
        IN BOOLEAN              bSourceIsNtPath,
        IN LPCWSTR              szSourceFilePath,
        OUT PUNICODE_STRING     pUnicodeResult
        )
/*++

Routine Description:

    Attempts to return fully qualified, canonicalized filename using a
    caller-supplied filename and optionally an opened file handle.
    The method used by this function is significantly more reliable
    and consistent if an opened file handle can additionally be provided.

Arguments:

    hFileHandle - optionally supplies the file handle to the file that
        is being canonicalized.  The handle is used to obtain a more
        definitive canonicalization result.

        Unfortunately, since NT does not currently allow full information
        to be queried from strictly the file handle, the original filename
        used to open the file needs to also be supplied.  No explicit
        verification is done to ensure that the supplied file handle
        actually corresponds with the filename that is also supplied.

    bSourceIsNtPath - boolean indicator of whether the filename being
        supplied is a DOS namespace or an NT-namespace filename.

    szSourceFilePath - string of the filename to canonicalize.  This
        filename may either be a DOS or an NT-namespace filename.

    pUnicodeResult - output UNICODE_STRING structure that receives an
        allocated string of the resulting canonicalized path.
        The resulting path will always be a DOS namespace filename.

Return Value:

    Returns STATUS_SUCCESS if successful, otherwise the error code.

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PWCHAR FileBuffer = NULL;
    PWCHAR FileBufferTwo = NULL;

    if (ARGUMENT_PRESENT(hFileHandle) && ARGUMENT_PRESENT(szSourceFilePath))
    {
        //
        // When we are given a file handle, or are able to open
        // the file ourselves, use the handle to derive the full name.
        // First, determine the drive letter by looking at the supplied
        // file path itself.  This step is necessary because the
        // NtQueryInformationFile API that we use later is unable to
        // supply the full prefix of the filename.
        //
        WCHAR wcDriveLetter;
        Status = STATUS_SUCCESS;
        if (bSourceIsNtPath) {
            if (!SaferpQueryCanonicalizedDriveLetterFromNtPathname(
                    szSourceFilePath, &wcDriveLetter))
                Status = STATUS_UNSUCCESSFUL;
        } else {
            if (!SaferpQueryCanonicalizedDriveLetterFromDosPathname(
                    szSourceFilePath, &wcDriveLetter))
                Status = STATUS_UNSUCCESSFUL;
        }

        if (NT_SUCCESS(Status)) {
            Status = SaferpQueryFilenameFromHandle(
                            hFileHandle,
                            wcDriveLetter,
                            pUnicodeResult);
            if (NT_SUCCESS(Status)) return Status;
        }
    }



    if (szSourceFilePath != NULL)
    {
        //
        // Allow the case where a pathname was supplied, but not a
        // handle and we were unable to open the file.  This case
        // will not be very common, so it can be less efficient.
        //
        UNICODE_STRING UnicodeInput;

        //
        // Transform the name into a fully qualified name.
        //
        RtlInitUnicodeString(&UnicodeInput, szSourceFilePath);
        if ( bSourceIsNtPath )
        {
            if (RtlPrefixUnicodeString(
                    (PUNICODE_STRING) &UnicodeDosDevicesPrefix,
                    &UnicodeInput, TRUE) &&
                UnicodeInput.Length >= 6 * sizeof(WCHAR) &&
                UnicodeInput.Buffer[5] == L':' &&
                SaferpIsAlphaLetter(UnicodeInput.Buffer[4]) &&
                UnicodeInput.Buffer[6] == L'\\')
            {
                // Absolute NT style filename, and assumed to already be
                // fully-qualified.  Since we want the DOS-namespace,
                // the leading NT prefix stuff needs to be chopped.
                UnicodeInput.Buffer = &UnicodeInput.Buffer[4];
                UnicodeInput.Length -= (4 * sizeof(WCHAR));
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_UNSUCCESSFUL;
            }
        } else {
            // Need to possibly fully qualify the path first.

            ULONG ulResult;

            FileBufferTwo = (PWCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, (MAX_PATH * sizeof(WCHAR))); 

            if (FileBufferTwo == NULL)
            {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            ulResult = RtlGetFullPathName_U(
                    UnicodeInput.Buffer,
                    (MAX_PATH * sizeof(WCHAR)),   // yes, BYTEs not WCHARs!
                    FileBufferTwo,
                    NULL);
            if (ulResult != 0 && ulResult < (MAX_PATH * sizeof(WCHAR))) {
                UnicodeInput.Buffer = FileBufferTwo;
                UnicodeInput.Length = (USHORT) ulResult;
                UnicodeInput.MaximumLength = MAX_PATH * sizeof(WCHAR);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_UNSUCCESSFUL;
            }
        }


        //
        // Convert any short 8.3 filenames to their full versions.
        //

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        FileBuffer = (PWCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, (MAX_PATH * sizeof(WCHAR))); 

        if (FileBuffer == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if (!GetLongPathNameW(UnicodeInput.Buffer,
                              FileBuffer,
                              MAX_PATH)) {
            // duplicate UnicodeInput into identStruct.UnicodeFullyQualfiedLongFileName
            Status = RtlDuplicateUnicodeString(
                            RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
                            RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                            &UnicodeInput,
                            pUnicodeResult);
        } else {
            // Conversion was possible, so just return an
            // allocated copy of what we were able to find.
            // This can happen when the file path doesn't exist.
            Status = RtlCreateUnicodeString(
                            pUnicodeResult,
                            FileBuffer);
        }

        if (NT_SUCCESS(Status)) 
        {
            goto Cleanup;
        }
    }


Cleanup:

    if (FileBuffer != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, FileBuffer);
    }

    if (FileBufferTwo != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, FileBufferTwo);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safecat.c ===
//depot/main/DS/security/winsafer/safecat.c#8 - integrate change 7547 (text)
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safecat.cpp         (SAFER SaferComputeTokenFromLevel)

Abstract:

    This module implements the WinSAFER APIs to compute a new restricted
    token from a more privileged one, utilizing an "Code Authorization
    Level Object", which specifies the actions to perform to apply
    the restrictions.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzpGetTokenInformation               (private)
    CodeAuthzpSidInSidAndAttributes             (private)
    CodeAuthzpModifyTokenPermissions            (private)
    CodeAuthzpInvertPrivs                       (private)
    SaferComputeTokenFromLevel
    CompareCodeAuthzObjectWithToken
    CodeAuthzpGetAuthzObjectRestrictions        (private)

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <seopaque.h>       // needed for sertlp.h
#include <sertlp.h>         // RtlpDaclAddrSecurityDescriptor
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"



//
// Internal prototypes of other functions defined locally within this file.
//

NTSTATUS NTAPI
CodeAuthzpModifyTokenPermissions(
    IN HANDLE   hToken,
    IN PSID     pExplicitSid,
    IN DWORD    dwExplicitPerms,
    IN PSID     pExplicitSid2       OPTIONAL,
    IN DWORD    dwExplicitPerms2    OPTIONAL
    );

NTSTATUS NTAPI
CodeAuthzpModifyTokenOwner(
    IN HANDLE   hToken,
    IN PSID     NewOwnerSid
    );

BOOL
IsSaferDisabled(
    void
    )
{
    static int g_nDisableSafer = -1;
            // -1 means we didn't check yet
            //  0 means safer is enabled
            //  1 means safer is disabled

    static const UNICODE_STRING KeyNameSafeBoot =
        RTL_CONSTANT_STRING(L"\\Registry\\MACHINE\\System\\CurrentControlSet\\Control\\SafeBoot\\Option");
    static const UNICODE_STRING ValueNameSafeBoot =
        RTL_CONSTANT_STRING(L"OptionValue");
    static const OBJECT_ATTRIBUTES objaSafeBoot =
        RTL_CONSTANT_OBJECT_ATTRIBUTES(&KeyNameSafeBoot, OBJ_CASE_INSENSITIVE);

    HANDLE                      hKey;
    BYTE ValueBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInformation =
            (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
    DWORD                       ValueLength;
    NTSTATUS                    Status;

    //
    // First see if we already checked the registry
    //
    if (g_nDisableSafer == 1) {
        return TRUE;
    }

    if (g_nDisableSafer == 0) {
        return FALSE;
    }

    //
    // This is the only time we check for safeboot by going to the registry
    // Opening the key for "write" tells us if we are an admin.
	// 
    Status = NtOpenKey(&hKey, KEY_QUERY_VALUE | KEY_SET_VALUE, (POBJECT_ATTRIBUTES) &objaSafeBoot);
    if (NT_SUCCESS(Status)) {
        Status = NtQueryValueKey(hKey,
                                 (PUNICODE_STRING) &ValueNameSafeBoot,
                                 KeyValuePartialInformation,
                                 pKeyValueInformation,
                                 sizeof(ValueBuffer),
                                 &ValueLength);

        NtClose(hKey);

        if (NT_SUCCESS(Status) &&
            pKeyValueInformation->Type == REG_DWORD &&
            pKeyValueInformation->DataLength == sizeof(DWORD)) {
            //
            // If the value exists and it's not 0 then we are in one of SafeBoot modes.
            // Return TRUE in this case to disable the shim infrastructure
            //
            if (*((PDWORD) pKeyValueInformation->Data) > 0) {
                g_nDisableSafer = 1;
                return TRUE;
            }
        }
    }

    g_nDisableSafer = 0;

    return FALSE;
}


LPVOID NTAPI
CodeAuthzpGetTokenInformation(
    IN HANDLE                       TokenHandle,
    IN TOKEN_INFORMATION_CLASS      TokenInformationClass
    )
/*++

Routine Description:

    Returns a pointer to allocated memory containing a specific
    type of information class about the specified token.  This
    wrapper function around GetTokenInformation() handles the
    allocation of memory of the appropriate size needed.

Arguments:

    TokenHandle - specifies the token that should be used
        to obtain the specified information from.

    TokenInformationClass - specifies the information class wanted.

Return Value:

    Returns NULL on error.  Otherwise caller must free the returned
    structure with RtlFreeHeap().

--*/
{
    DWORD dwSize = 128;
    LPVOID pTokenInfo = NULL;

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        pTokenInfo = (LPVOID)RtlAllocateHeap(RtlProcessHeap(), 0, dwSize);
        if (pTokenInfo != NULL)
        {
            DWORD dwNewSize;
            NTSTATUS Status;

            Status = NtQueryInformationToken(
                    TokenHandle, TokenInformationClass,
                    pTokenInfo, dwSize, &dwNewSize);
            if (Status == STATUS_BUFFER_TOO_SMALL)
            {
                RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenInfo);

                pTokenInfo = (LPVOID)RtlAllocateHeap(RtlProcessHeap(), 0, dwNewSize);
                if (pTokenInfo != NULL)
                {
                    Status = NtQueryInformationToken(
                        TokenHandle, TokenInformationClass,
                        pTokenInfo, dwNewSize, &dwNewSize);
                }
            }
            if (!NT_SUCCESS(Status))
            {
                RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenInfo);
                pTokenInfo = NULL;
            }
        }
    }

    return pTokenInfo;
}



BOOLEAN NTAPI
CodeAuthzpSidInSidAndAttributes (
    IN PSID_AND_ATTRIBUTES  SidAndAttributes,
    IN ULONG                SidCount,
    OPTIONAL IN PSID        SePrincipalSelfSid,
    OPTIONAL IN PSID        PrincipalSelfSid,
    IN PSID                 Sid,
    BOOLEAN                 HonorEnabledAttribute
    )
/*++

Routine Description:

    Checks to see if a given SID is in the given token.

    N.B. The code to compute the length of a SID and test for equality
         is duplicated from the security runtime since this is such a
         frequently used routine.

    This function is mostly copied from the SepSidInSidAndAttributes
    found in ntos\se\tokendup.c, except it handles PrincipalSelfSid
    within the list as well as the passed in Sid.  SePrincipalSelfSid
    is also a parameter here, instead of an ntoskrnl global.  also the
    HonorEnabledAttribute argument was added.

Arguments:

    SidAndAttributes - Pointer to the sid and attributes to be examined

    SidCount - Number of entries in the SidAndAttributes array.

    SePrincipalSelfSid - This parameter should optionally be the SID that
        will be replaced with the PrincipalSelfSid if this SID is encountered
        in any ACE.  This SID should be generated from SECURITY_PRINCIPAL_SELF_RID

        The parameter should be NULL if the object does not represent a principal.


    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        SECURITY_PRINCIPAL_SELF_RID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.


    Sid - Pointer to the SID of interest


    HonorEnabledAttribute - If this argument is TRUE, then only Sids in the
        SidsAndAttributes array that have the Attribute SE_GROUP_ENABLED set
        will be processed during the evaluation.

Return Value:

    A value of TRUE indicates that the SID is in the token, FALSE
    otherwise.

--*/
{
    ULONG i;
    PISID MatchSid;
    ULONG SidLength;
    PSID_AND_ATTRIBUTES TokenSid;
    ULONG UserAndGroupCount;



    if (!ARGUMENT_PRESENT( SidAndAttributes ) ) {
        return(FALSE);
    }
    ASSERT(Sid != NULL);

    //
    // If Sid is the constant PrincipalSelfSid,
    //  replace it with the passed in PrincipalSelfSid.
    //

    if ( ARGUMENT_PRESENT(PrincipalSelfSid) &&
         ARGUMENT_PRESENT(SePrincipalSelfSid) &&
         RtlEqualSid( SePrincipalSelfSid, Sid ) ) {

        ASSERT(!RtlEqualSid(SePrincipalSelfSid, PrincipalSelfSid));
        Sid = PrincipalSelfSid;
    }

    //
    // Get the length of the source SID since this only needs to be computed
    // once.
    //

    SidLength = 8 + (4 * ((PISID)Sid)->SubAuthorityCount);

    //
    // Get address of user/group array and number of user/groups.
    //

    ASSERT(SidAndAttributes != NULL);
    TokenSid = SidAndAttributes;
    UserAndGroupCount = SidCount;

    //
    // Scan through the user/groups and attempt to find a match with the
    // specified SID.
    //

    for (i = 0 ; i < UserAndGroupCount ; i++)
    {
        if (!HonorEnabledAttribute ||
            (TokenSid->Attributes & SE_GROUP_ENABLED) != 0)
        {
            MatchSid = (PISID)TokenSid->Sid;
            ASSERT(MatchSid != NULL);

            //
            // If the SID is the principal self SID, then replace it.
            //

            if ( ARGUMENT_PRESENT(SePrincipalSelfSid) &&
                 ARGUMENT_PRESENT(PrincipalSelfSid) &&
                 RtlEqualSid(SePrincipalSelfSid, MatchSid)) {

                MatchSid = (PISID) PrincipalSelfSid;
            }


            //
            // If the SID revision and length matches, then compare the SIDs
            // for equality.
            //

            if ((((PISID)Sid)->Revision == MatchSid->Revision) &&
                (SidLength == (8 + (4 * (ULONG)MatchSid->SubAuthorityCount)))) {

                if (RtlEqualMemory(Sid, MatchSid, SidLength)) {

                    return TRUE;

                }
            }
        }

        TokenSid++;
    }

    return FALSE;
}


NTSTATUS NTAPI
CodeAuthzpModifyTokenPermissions(
    IN HANDLE   hToken,
    IN PSID     pExplicitSid,
    IN DWORD    dwExplicitPerms,
    IN PSID     pExplicitSid2       OPTIONAL,
    IN DWORD    dwExplicitPerms2    OPTIONAL
    )

/*++

Routine Description:

    An internal function to make some additional permission modifications
    on a newly created restricted token.

Arguments:

    hToken - token to modify

    pExplicitSid - explicitly named SID to add to the token's DACL.

    dwExplicitPerms - permissions given to the explicitly named SID
            when it is added to the DACL.

    pExplicitSid2 - (optional) secondary named SID to add to the DACL.

    dwExplicitPerms2 - (optional) secondary permissions given to the
            secondary SID when it is added to the DACL.

Return Value:

    A value of TRUE indicates that the operation was successful,
    FALSE otherwise.

--*/

{
    NTSTATUS            Status       = STATUS_SUCCESS;
    PACL                pTokenDacl   = NULL;
    PUCHAR              Buffer       = NULL;
    TOKEN_DEFAULT_DACL  TokenDefDacl = {0};
    ULONG               BufferLength = 0;
    ULONG               AclLength    = 0;

    //
    // Verify that our arguments were supplied.  Since this is
    // an internal function, we just assert instead of doing
    // real argument checking.
    //

    ASSERT(ARGUMENT_PRESENT(hToken));
    ASSERT(ARGUMENT_PRESENT(pExplicitSid) && RtlValidSid(pExplicitSid));
    ASSERT(!ARGUMENT_PRESENT(pExplicitSid2) || RtlValidSid(pExplicitSid2));

    //
    // Retrieve the default acl in the token.
    //

    Status = NtQueryInformationToken(
                    hToken,
                    TokenDefaultDacl,
                    NULL,
                    0, 
                    (PULONG) &BufferLength
                    );

    if (Status == STATUS_BUFFER_TOO_SMALL)
    {
        //
        // Allocate memory for the buffer.
        //

        Buffer = (PUCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, BufferLength);

        if (!Buffer) 
        {
            Status = STATUS_NO_MEMORY;
            goto ExitHandler;
        }

        //
        // Perform the query again and actually get it.
        //

        Status = NtQueryInformationToken(
                        hToken,
                        TokenDefaultDacl,
                        Buffer, 
                        BufferLength, 
                        (PULONG) &BufferLength
                        );

        if (!NT_SUCCESS(Status)) 
        {
            goto ExitHandler;
        }

        AclLength = ((PTOKEN_DEFAULT_DACL) Buffer)->DefaultDacl->AclSize;

        //
        // Calculate how much size we might need in the worst case where
        // we have to enlarge the DACL.
        //

        AclLength += (sizeof(ACCESS_ALLOWED_ACE) +
                      RtlLengthSid(pExplicitSid) -
                      sizeof(DWORD));

        if (ARGUMENT_PRESENT(pExplicitSid2)) 
        {
            AclLength += (sizeof(ACCESS_ALLOWED_ACE) +
                          RtlLengthSid(pExplicitSid2) -
                          sizeof(DWORD));
        }

        //
        // Allocate memory to hold the new acl.
        //

        pTokenDacl = (PACL) RtlAllocateHeap(RtlProcessHeap(), 0, AclLength);

        if (!pTokenDacl) 
        {
            Status = STATUS_NO_MEMORY;
            goto ExitHandler;
        }

        //
        // Copy the old acl into allocated memory.
        //

        RtlCopyMemory(
            pTokenDacl, 
            ((PTOKEN_DEFAULT_DACL) Buffer)->DefaultDacl,
            ((PTOKEN_DEFAULT_DACL) Buffer)->DefaultDacl->AclSize
            );

        //
        // Set the acl size to the new size.
        //

        pTokenDacl->AclSize = (USHORT) AclLength;

    } 
    else if (!NT_SUCCESS(Status)) 
    {
        goto ExitHandler;
    } 
    else 
    {
        //
        // If we get here, there's a bug in Nt code.
        //

        ASSERT(FALSE);
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }

    ASSERT(RtlValidAcl(pTokenDacl));

    //
    // Create the new DACL that includes the extra ACEs that we want.
    //

    Status = RtlAddAccessAllowedAceEx(
                    pTokenDacl,
                    ACL_REVISION,
                    CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                    dwExplicitPerms,
                    pExplicitSid
                    );

    if (!NT_SUCCESS(Status)) 
    {
        ASSERT(Status != STATUS_ALLOTTED_SPACE_EXCEEDED);
        goto ExitHandler;
    }

    if (ARGUMENT_PRESENT(pExplicitSid2))
    {
        Status = RtlAddAccessAllowedAceEx(
                        pTokenDacl,
                        ACL_REVISION,
                        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
                        dwExplicitPerms2,
                        pExplicitSid2
                        );

        if (!NT_SUCCESS(Status)) 
        {
            ASSERT(Status != STATUS_ALLOTTED_SPACE_EXCEEDED);
            goto ExitHandler;
        }

    }

    ASSERT(RtlValidAcl(pTokenDacl));

    //
    // Set the Default DACL within the token to the DACL that we built.
    //

    RtlZeroMemory(&TokenDefDacl, sizeof(TOKEN_DEFAULT_DACL));
    TokenDefDacl.DefaultDacl = pTokenDacl;

    Status = NtSetInformationToken(
                    hToken,
                    TokenDefaultDacl,
                    &TokenDefDacl,
                    sizeof(TOKEN_DEFAULT_DACL)
                    );

    if (!NT_SUCCESS(Status)) 
    {
        goto ExitHandler;
    }

    Status = STATUS_SUCCESS;      // success


ExitHandler:
    if (pTokenDacl != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pTokenDacl);
    }

    if (Buffer != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
    }

    return Status;
}



NTSTATUS NTAPI
CodeAuthzpModifyTokenOwner(
    IN HANDLE       hToken,
    IN PSID         NewOwnerSid
    )
{
    NTSTATUS Status;
    TOKEN_OWNER tokenowner;

    //
    // Verify that we have our arguments.
    //
    if (!ARGUMENT_PRESENT(hToken) ||
        !ARGUMENT_PRESENT(NewOwnerSid)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Set the owner of the Token.
    //
    RtlZeroMemory(&tokenowner, sizeof(TOKEN_OWNER));
    tokenowner.Owner = NewOwnerSid;
    Status = NtSetInformationToken(hToken, TokenOwner,
                    &tokenowner, sizeof(TOKEN_OWNER));

ExitHandler:
    return Status;
}



BOOLEAN NTAPI
CodeAuthzpInvertPrivs(
    IN HANDLE                   InAccessToken,
    IN DWORD                    dwNumInvertedPrivs,
    IN PLUID_AND_ATTRIBUTES     pInvertedPrivs,
    OUT PDWORD                  dwOutNumPrivs,
    OUT PLUID_AND_ATTRIBUTES   *pResultingPrivs
    )
/*++

Routine Description:


Arguments:

    InAccessToken -

    dwNumInvertedPrivs -

    pInvertedPrivs -

    dwOutNumPrivs -

    pResultingPrivs -

Return Value:

    Returns FALSE on error, TRUE on success.

--*/
{
    PTOKEN_PRIVILEGES pTokenPrivileges;
    DWORD Index, InnerIndex;


    //
    // Obtain the list of currently held privileges.
    //
    ASSERT( ARGUMENT_PRESENT(InAccessToken) );
    pTokenPrivileges = (PTOKEN_PRIVILEGES)
        CodeAuthzpGetTokenInformation(InAccessToken, TokenPrivileges);
    if (!pTokenPrivileges) goto ExitHandler;


    //
    // Squeeze out any privileges that were specified to us,
    // leaving only those privileges that weren't specified.
    //
    ASSERT( ARGUMENT_PRESENT(pInvertedPrivs) );
    for (Index = 0; Index < pTokenPrivileges->PrivilegeCount; Index++)
    {
        for (InnerIndex = 0; InnerIndex < dwNumInvertedPrivs; InnerIndex++)
        {
            if (RtlEqualMemory(&pTokenPrivileges->Privileges[Index].Luid,
                    &pInvertedPrivs[InnerIndex].Luid, sizeof(LUID)) )
            {
                pTokenPrivileges->PrivilegeCount--;
                RtlMoveMemory(&pTokenPrivileges->Privileges[Index],
                    &pTokenPrivileges->Privileges[Index + 1],
                    pTokenPrivileges->PrivilegeCount - Index);
                Index--;
                break;
            }
        }
    }


    //
    // Return the number of final privileges.  Also, convert the
    // TOKEN_PRIVILEGES structure into just a LUID_AND_ATTRIBUTES array.
    // There will be some unused slack at the end of the used portion
    // of the array, but that is fine (some array entries have probably
    // already been squeezed out).
    //
    *dwOutNumPrivs = pTokenPrivileges->PrivilegeCount;
    RtlMoveMemory(pTokenPrivileges, &pTokenPrivileges->Privileges[0],
         pTokenPrivileges->PrivilegeCount * sizeof(LUID_AND_ATTRIBUTES) );
    *pResultingPrivs = (PLUID_AND_ATTRIBUTES) pTokenPrivileges;
    return TRUE;


ExitHandler:
    return FALSE;
}



NTSTATUS NTAPI
__CodeAuthzpComputeAccessTokenFromCodeAuthzObject (
    IN PAUTHZLEVELTABLERECORD     pLevelRecord,
    IN HANDLE                   InAccessToken OPTIONAL,
    OUT PHANDLE                 OutAccessToken,
    IN DWORD                    dwFlags,
    IN LPVOID                   lpReserved,
    IN DWORD                    dwSaferIdentFlags OPTIONAL
    )
/*++

Routine Description:

    Uses the specified WinSafer Level to apply various restrictions
    or modifications to the specified InAccessToken to produce a
    Restricted Token that can be used to execute processes with.
    Alternatively, the returned Restricted Token can be used for
    thread impersonation to selectively perform operations within a
    less-privileged environment.

Arguments:

    pLevelRecord - the record structure of the Level to evaluate.

    InAccessToken - Optionally specifies the input Token that will be
        modified with restrictions.  If this argument is NULL, then the
        Token for the currently executing process will be opened and used.

    OutAccessToken - Specifies the memory region to receive the resulting
        Restricted Token.

    dwFlags - Specifies additional flags that can be used to control the
        restricted token creation:

            SAFER_TOKEN_MAKE_INERT -
            SAFER_TOKEN_NULL_IF_EQUAL -
            SAFER_TOKEN_WANT_FLAGS -

    lpReserved - extra parameter used for some dwFlag combinations.

    dwSaferIdentFlags - extra SaferFlags bits derived from the matched
        Code Identifier record entry.  These extra bits are ORed to
        combine them with the SaferFlags associated with the Level.

Return Value:

    Returns -1 if the input Level record is the Disallowed level.

    Returns STATUS_SUCCESS on a successful operation, otherwise the
    errorcode of the failure that occurred.

--*/
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOL InAccessTokenWasSupplied = FALSE;
    HANDLE RestrictedToken = NULL;
    DWORD FinalFilterFlags;
    DWORD SaferFlags;
    BOOL InertStateChanged = FALSE;

    PSID restrictedSid = NULL;
    PTOKEN_USER pTokenUser = NULL;
    PSID principalSelfSid = NULL;

    DWORD FinalDisabledSidCount;
    PSID_AND_ATTRIBUTES FinalSidsToDisable = NULL;
    BOOL FreeFinalDisabledSids = FALSE;

    DWORD FinalRestrictedSidCount;
    PSID_AND_ATTRIBUTES FinalSidsToRestrict = NULL;
    BOOL FreeFinalRestrictedSids = FALSE;

    DWORD FinalPrivsToDeleteCount;
    PLUID_AND_ATTRIBUTES FinalPrivsToDelete = NULL;
    BOOL FreeFinalPrivsToDelete = FALSE;


    OBJECT_ATTRIBUTES ObjAttr = {0};
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService = {0};
    SECURITY_DESCRIPTOR sd = {0};

    //
    // Verify that our input arguments were supplied.
    //
    if (!ARGUMENT_PRESENT(pLevelRecord)) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(OutAccessToken)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }


    //
    // Ensure that we have the parent token that will be
    // used for the creation of the restricted token.
    //
    if (ARGUMENT_PRESENT(InAccessToken)) {
        InAccessTokenWasSupplied = TRUE;
    } else {
        Status = NtOpenThreadToken(NtCurrentThread(),
                TOKEN_DUPLICATE | READ_CONTROL | TOKEN_QUERY,
                TRUE, &InAccessToken);
        if (!NT_SUCCESS(Status)) {
            Status = NtOpenProcessToken(NtCurrentProcess(),
                    TOKEN_DUPLICATE | READ_CONTROL | TOKEN_QUERY,
                    &InAccessToken);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;       // could not obtain default token
            }
        }
    }



    //
    // Figure out the combined effect of the "SaferFlags".
    // Also figure out what flags we'll pass to NtFilterToken.
    // Note that all of the bits within the SaferFlags can be
    // combined by bitwise-OR, except for the JOBID portion.
    //
    FinalFilterFlags = (pLevelRecord->DisableMaxPrivileges ?
                        DISABLE_MAX_PRIVILEGE : 0);
    if ((dwSaferIdentFlags & SAFER_POLICY_JOBID_MASK) != 0) {
        SaferFlags = dwSaferIdentFlags |
            (pLevelRecord->SaferFlags & ~SAFER_POLICY_JOBID_MASK);
    } else {
        SaferFlags = pLevelRecord->SaferFlags | dwSaferIdentFlags;
    }
    if ((dwFlags & SAFER_TOKEN_MAKE_INERT) != 0 ||
        (SaferFlags & SAFER_POLICY_SANDBOX_INERT) != 0)
    {
        SaferFlags |= SAFER_POLICY_SANDBOX_INERT;
        FinalFilterFlags |= SANDBOX_INERT;
    }



    //
    // Retrieve the User's personal SID.
    // (user's SID is accessible afterwards with "pTokenUser->User.Sid")
    //

    pTokenUser = (PTOKEN_USER) CodeAuthzpGetTokenInformation(
                                   InAccessToken, 
                                   TokenUser
                                   );

    if (pTokenUser == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }

    //
    // Quick check to see if we can expect a change in the
    // token's "Sandbox Inert" state to occur.
    //
    {
        ULONG bIsInert = 0;
        ULONG ulReturnLength;

        Status = NtQueryInformationToken(
                    InAccessToken,
                    TokenSandBoxInert,
                    &bIsInert,
                    sizeof(bIsInert),
                    &ulReturnLength);
        if (NT_SUCCESS(Status) && bIsInert) {
            if ( (dwFlags & SAFER_TOKEN_NULL_IF_EQUAL) != 0) {
                // The output token was not made any more restrictive during
                // this operation, so pass back NULL and return success.
                *OutAccessToken = NULL;
                Status = STATUS_SUCCESS;
                goto ExitHandler;
            } else {
                
                SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE  );
                SecurityQualityOfService.ImpersonationLevel = SecurityAnonymous;
                SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
                SecurityQualityOfService.EffectiveOnly = FALSE;

                Status = RtlCreateSecurityDescriptor(
                            &sd, 
                            SECURITY_DESCRIPTOR_REVISION
                            );

                if (!NT_SUCCESS(Status)) {
                    goto ExitHandler;
                }
                Status = RtlSetOwnerSecurityDescriptor(
                             &sd, 
                             pTokenUser->User.Sid, 
                             FALSE
                             );

                if (!NT_SUCCESS(Status)) {
                    goto ExitHandler;
                }

                InitializeObjectAttributes(
                        &ObjAttr,
                        NULL,
                        OBJ_INHERIT,
                        NULL,
                        &sd
                        );

                ObjAttr.SecurityQualityOfService = &SecurityQualityOfService;

                Status = NtDuplicateToken(
                             InAccessToken,
                             TOKEN_ALL_ACCESS,
                             &ObjAttr,
                             FALSE,
                             TokenPrimary,
                             OutAccessToken
                             );
                
                goto ExitHandler;
            }
        } else {
            if ((FinalFilterFlags & SANDBOX_INERT) != 0) {
                // the input token was not "SandBox Inert" and
                // we're being requested to make it.
                InertStateChanged = TRUE;
            }
        }
    }

    //
    // If this is not allowed to execute, then break out now.
    //
    if (pLevelRecord->DisallowExecution) {
        Status = -1;            // special status code
        goto ExitHandler;
    }


    //
    // Process PrivsToDelete inversion.
    //
    if (pLevelRecord->InvertDeletePrivs != FALSE)
    {
        if (!CodeAuthzpInvertPrivs(
                InAccessToken,
                pLevelRecord->DeletePrivilegeUsedCount,
                pLevelRecord->PrivilegesToDelete,
                &FinalPrivsToDeleteCount,
                &FinalPrivsToDelete))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler;
        }
        FreeFinalPrivsToDelete = TRUE;
    }
    else
    {
        FinalPrivsToDeleteCount = pLevelRecord->DeletePrivilegeUsedCount;
        FinalPrivsToDelete = pLevelRecord->PrivilegesToDelete;
    }


    //
    // Process SidsToDisable inversion.
    //
    if (pLevelRecord->InvertDisableSids != FALSE)
    {
        if (!CodeAuthzpInvertAndAddSids(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->DisableSidUsedCount,
                pLevelRecord->SidsToDisable,
                0,
                NULL,
                &FinalDisabledSidCount,
                &FinalSidsToDisable))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler;
        }
        FreeFinalDisabledSids = TRUE;
    }
    else
    {
        if (pLevelRecord->DisableSidUsedCount == 0 ||
            pLevelRecord->SidsToDisable == NULL)
        {
            FinalSidsToDisable = NULL;
            FinalDisabledSidCount = 0;
            FreeFinalDisabledSids = FALSE;
        } else {
            if (!CodeAuthzpExpandWildcardList(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->DisableSidUsedCount,
                pLevelRecord->SidsToDisable,
                &FinalDisabledSidCount,
                &FinalSidsToDisable))
            {
                Status = STATUS_UNSUCCESSFUL;
                goto ExitHandler;
            }
            FreeFinalDisabledSids = TRUE;
        }
    }


    //
    // Process RestrictingSids inversion.
    //
    if (pLevelRecord->RestrictedSidsInvUsedCount != 0)
    {
        if (!CodeAuthzpInvertAndAddSids(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->RestrictedSidsInvUsedCount,
                pLevelRecord->RestrictedSidsInv,
                pLevelRecord->RestrictedSidsAddedUsedCount,
                pLevelRecord->RestrictedSidsAdded,
                &FinalRestrictedSidCount,
                &FinalSidsToRestrict))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler;
        }
        FreeFinalRestrictedSids = TRUE;
    }
    else
    {
        FinalRestrictedSidCount = pLevelRecord->RestrictedSidsAddedUsedCount;
        FinalSidsToRestrict = pLevelRecord->RestrictedSidsAdded;
    }


    //
    // In some cases, we can bail out early if we were called with
    // the compare-only flag, and we know that there should not be
    // any actual changes being made to the token.
    //
    if (!InertStateChanged &&
        FinalDisabledSidCount == 0 &&
        FinalPrivsToDeleteCount == 0 &&
        FinalRestrictedSidCount == 0 &&
        (FinalFilterFlags & DISABLE_MAX_PRIVILEGE) == 0)
    {
        if ( (dwFlags & SAFER_TOKEN_NULL_IF_EQUAL) != 0) {
            // The output token was not made any more restrictive during
            // this operation, so pass back NULL and return success.
            *OutAccessToken = NULL;
            Status = STATUS_SUCCESS;
            goto ExitHandler;
        } else {
            // OPTIMIZATION: for this case we can consider using DuplicateToken
        }
    }


    //
    // Create the actual restricted token.
    //
    if (!CreateRestrictedToken(
            InAccessToken,              // handle to existing token
            FinalFilterFlags,           // privilege options and inert
            FinalDisabledSidCount,      // number of deny-only SIDs
            FinalSidsToDisable,         // deny-only SIDs
            FinalPrivsToDeleteCount,    // number of privileges
            FinalPrivsToDelete,         // privileges
            FinalRestrictedSidCount,    // number of restricting SIDs
            FinalSidsToRestrict,        // list of restricting SIDs
            &RestrictedToken            // handle to new token
        ))
    {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }


    //
    // If the caller requested SAFER_TOKEN_NULL_IF_EQUAL
    // then do the evaluation now.
    // Notice that NtCompareTokens intentionally does not
    // consider possible differences in the SandboxInert
    // flag, so we have to handle that case ourself.
    //
    if ( (dwFlags & SAFER_TOKEN_NULL_IF_EQUAL) != 0 &&
         !InertStateChanged )
    {
        BOOLEAN bResult = FALSE;

        Status = NtCompareTokens(InAccessToken, RestrictedToken, &bResult);
        if (!NT_SUCCESS(Status)) {
            // An error occurred during the comparison.
            goto ExitHandler;
        }
        if (bResult) {
            // The output token was not made any more restrictive during
            // this operation, so pass back NULL and return success.
            *OutAccessToken = NULL;
            Status = STATUS_SUCCESS;
            goto ExitHandler;
        }
    }



    //
    // Build the "Restricted Code" SID.
    //
    Status = RtlAllocateAndInitializeSid( &SIDAuth, 1,
        SECURITY_RESTRICTED_CODE_RID, 0, 0, 0, 0, 0, 0, 0,
        &restrictedSid);
    if (! NT_SUCCESS(Status) ) goto ExitHandler;


    //
    // Build the "Principal Self" SID.
    //
    Status = RtlAllocateAndInitializeSid( &SIDAuth, 1,
        SECURITY_PRINCIPAL_SELF_RID, 0, 0, 0, 0, 0, 0, 0,
        &principalSelfSid);
    if (! NT_SUCCESS(Status) ) goto ExitHandler;


    //
    // Duplicate the token into a primary token and simultaneously
    // update the owner to the user's personal SID, instead of the
    // user of the current thread token.
    //
    {
        OBJECT_ATTRIBUTES ObjA;
        HANDLE NewTokenHandle;

        //
        // Initialize a SECURITY_ATTRIBUTES and SECURITY_DESCRIPTOR
        // to force the owner to the personal user SID.
        //
        Status = RtlCreateSecurityDescriptor(
                &sd, SECURITY_DESCRIPTOR_REVISION);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        }
        Status = RtlSetOwnerSecurityDescriptor(
                &sd, pTokenUser->User.Sid, FALSE);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        }

        //
        // Only a primary token can be assigned to a process, so
        // we must duplicate the restricted token so we can ensure
        // the we can assign it to the new process.
        //
        SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE  );
        SecurityQualityOfService.ImpersonationLevel = SecurityAnonymous;
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.EffectiveOnly = FALSE;
        InitializeObjectAttributes(
                &ObjA,
                NULL,
                OBJ_INHERIT,
                NULL,
                &sd
                );
        ObjA.SecurityQualityOfService = &SecurityQualityOfService;
        Status = NtDuplicateToken(
                RestrictedToken,   // handle to token to duplicate
                TOKEN_ALL_ACCESS,  // access rights of new token
                &ObjA,             // attributes
                FALSE,
                TokenPrimary,      // primary or impersonation token
                &NewTokenHandle    // handle to duplicated token
                );
        if (Status == STATUS_INVALID_OWNER) {
            // If we failed once, then it might be because the new owner
            // that was specified in the Security Descriptor could not
            // be set, so retry but without the SD specified.
            ObjA.SecurityDescriptor = NULL;
            Status = NtDuplicateToken(
                    RestrictedToken,   // handle to token to duplicate
                    TOKEN_ALL_ACCESS,  // access rights of new token
                    &ObjA,             // attributes
                    FALSE,
                    TokenPrimary,      // primary or impersonation token
                    &NewTokenHandle    // handle to duplicated token
                    );
        }
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        }
        ASSERT(NewTokenHandle != NULL);
        NtClose(RestrictedToken);
        RestrictedToken = NewTokenHandle;
    }


    //
    // Modify permissions on the token.  This involves:
    //    1) edit the DACL on the token to explicitly grant the special
    //       permissions to the User SID and to the Restricted SID.
    //    2) optionally change owner to specified SID.
    //
    {
        PSID defaultOwner = ( (pLevelRecord->DefaultOwner != NULL &&
                    RtlEqualSid(pLevelRecord->DefaultOwner, principalSelfSid)) ?
                        pTokenUser->User.Sid : pLevelRecord->DefaultOwner);

        Status = CodeAuthzpModifyTokenPermissions(
                RestrictedToken,           // token to modify.
                pTokenUser->User.Sid,      // explicitly named SID to add to the DACL.
                GENERIC_ALL,
                (pLevelRecord->dwLevelId < SAFER_LEVELID_NORMALUSER ?
                        restrictedSid : NULL),             // optional secondary named SID to add to the DACL
                GENERIC_ALL
                );

        if (NT_SUCCESS(Status) && defaultOwner != NULL) {
            Status = CodeAuthzpModifyTokenOwner(
                    RestrictedToken,
                    defaultOwner);
        }
        if (!NT_SUCCESS(Status)) {
            NtClose(RestrictedToken);
            goto ExitHandler;
        }
    }


    //
    // Return the result.
    //
    ASSERT(OutAccessToken != NULL);
    *OutAccessToken = RestrictedToken;
    RestrictedToken = NULL;
    Status = STATUS_SUCCESS;


    //
    // Cleanup and epilogue code.
    //
ExitHandler:
    if (RestrictedToken != NULL)
        NtClose(RestrictedToken);
    if (pTokenUser != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, pTokenUser);
    if (restrictedSid != NULL)
        RtlFreeSid(restrictedSid);
    if (principalSelfSid != NULL)
        RtlFreeSid(principalSelfSid);
    if (FreeFinalDisabledSids)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalSidsToDisable);
    if (FreeFinalRestrictedSids)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalSidsToRestrict);
    if (FreeFinalPrivsToDelete)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalPrivsToDelete);

    //
    // If the caller specified SAFER_TOKEN_WANT_SAFERFLAGS then we
    // need to copy the JobFlags value into the lpReserved parameter.
    //
    if ( Status == STATUS_SUCCESS &&
        (dwFlags & SAFER_TOKEN_WANT_FLAGS) != 0 )
    {
        if (ARGUMENT_PRESENT(lpReserved)) {
            *((LPDWORD)lpReserved) = SaferFlags;
        }
    }

    //
    // Close the process token if it wasn't supplied and we opened it.
    //
    if (!InAccessTokenWasSupplied && InAccessToken != NULL)
        NtClose(InAccessToken);

    return Status;
}


NTSTATUS NTAPI
__CodeAuthzpCompareCodeAuthzLevelWithToken(
    IN PAUTHZLEVELTABLERECORD   pLevelRecord,
    IN HANDLE                   InAccessToken     OPTIONAL,
    IN LPDWORD                  lpResultWord
    )
/*++

Routine Description:

    Performs a "light-weight" evaluation of the token manipulations that
    would be performed if the InAccessToken were restricted with the
    specified WinSafer Level.  The return code indicates if any
    modifications would actually be done to the token (ie: a distinctly
    less-privileged token would be created).

    This function is intended to be used to decide if a DLL (with the
    specified WinSafer Level) is authorized enough to be loaded into
    the specified process context handle, but without actually having
    to create a restricted token since a separate token won't actually
    be needed.

Arguments:

    pLevelRecord - the record structure of the Level to evaluate.

    InAccessToken - optionally the access token to use as a parent token.
            If this argument is not supplied, then the current process
            token will be opened and used.

    lpResultWord - receives the result of the evaluation when function
            is successful (value is left indeterminate if not successful).
            This result will be value 1 if the level is equal or more
            privileged than the InAccessToken, or value -1 if the level
            is less privileged (more restrictions necessary).


Return Value:

    Returns STATUS_SUCCESS on successful evaluation, otherwise returns
    the error status code.  When successful, lpResultWord receives
    the result of the evaluation.

--*/
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    BOOLEAN TokenWasSupplied = FALSE;
    DWORD Index;

    PTOKEN_USER pTokenUser = NULL;
    PSID principalSelfSid = NULL;
    PTOKEN_PRIVILEGES pTokenPrivs = NULL;
    PTOKEN_GROUPS pTokenGroups = NULL;
    PTOKEN_GROUPS pTokenRestrictedSids = NULL;

    DWORD FinalDisabledSidCount;
    PSID_AND_ATTRIBUTES FinalSidsToDisable;
    BOOLEAN FreeFinalDisabledSids = FALSE;
    DWORD FinalRestrictedSidCount;
    PSID_AND_ATTRIBUTES FinalSidsToRestrict;
    BOOLEAN FreeFinalRestrictedSids = FALSE;
    DWORD FinalPrivsToDeleteCount;
    PLUID_AND_ATTRIBUTES FinalPrivsToDelete;
    BOOLEAN FreeFinalPrivsToDelete = FALSE;
    

    //
    // Ensure that we have a place to write the result.
    //
    if (!ARGUMENT_PRESENT(pLevelRecord)) {
        Status = STATUS_INVALID_PARAMETER_1;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(lpResultWord)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }

    //
    // Ensure that we have the token that will be
    // used for the comparison test.
    //
    if (ARGUMENT_PRESENT(InAccessToken)) {
        TokenWasSupplied = TRUE;
    } else {
        Status = NtOpenThreadToken(NtCurrentThread(),
                TOKEN_DUPLICATE | READ_CONTROL | TOKEN_QUERY,
                TRUE, &InAccessToken);
        if (!NT_SUCCESS(Status)) {
            Status = NtOpenProcessToken(NtCurrentProcess(),
                    TOKEN_DUPLICATE | READ_CONTROL | TOKEN_QUERY,
                    &InAccessToken);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;       // could not obtain default token
            }
        }
    }


    //
    // If this is not allowed to execute, then break out now and return LESS.
    //
    if (pLevelRecord->DisallowExecution) {
        *lpResultWord = (DWORD) -1;        // Less priv'ed.
        Status = STATUS_SUCCESS;
        goto ExitHandler2;
    }


    //
    // Evaluate the privileges that should be deleted.
    //
    if (pLevelRecord->InvertDeletePrivs != FALSE)
    {
        if (!CodeAuthzpInvertPrivs(
                InAccessToken,
                pLevelRecord->DeletePrivilegeUsedCount,
                pLevelRecord->PrivilegesToDelete,
                &FinalPrivsToDeleteCount,
                &FinalPrivsToDelete))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler2;
        }
        FreeFinalPrivsToDelete = TRUE;

        //
        // If there are any Privileges that need to be deleted, then
        // this object definitely less restricted than the token.
        //
        if (FinalPrivsToDeleteCount != 0)
        {
            *lpResultWord = (DWORD) -1;        // Less priv'ed.
            Status = STATUS_SUCCESS;
            goto ExitHandler3;
        }
    }
    else
    {
        //
        // Get the list of privileges held by the token.
        //
        pTokenPrivs = (PTOKEN_PRIVILEGES) CodeAuthzpGetTokenInformation(
                InAccessToken, TokenPrivileges);
        if (!pTokenPrivs) {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler2;
        }


        //
        // if PrivsToRemove includes a Privilege not yet disabled,
        // then return LESS.
        //
        for (Index = 0; Index < pLevelRecord->DeletePrivilegeUsedCount; Index++)
        {
            DWORD InnerLoop;
            PLUID pLuid = &pLevelRecord->PrivilegesToDelete[Index].Luid;

            for (InnerLoop = 0; InnerLoop < pTokenPrivs->PrivilegeCount; InnerLoop++)
            {
                if ( RtlEqualMemory(&pTokenPrivs->Privileges[InnerLoop].Luid,
                        pLuid, sizeof(LUID)) )
                {
                    *lpResultWord = (DWORD) -1;        // Less priv'ed.
                    Status = STATUS_SUCCESS;
                    goto ExitHandler3;
                }
            }
        }
    }



    //
    // Retrieve the User's personal SID.
    // (user's SID is accessible afterwards with "pTokenUser->User.Sid")
    //
    pTokenUser = (PTOKEN_USER) CodeAuthzpGetTokenInformation(
            InAccessToken, TokenUser);
    if (pTokenUser == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler3;
    }


    //
    // Process SidsToDisable inversion.
    //
    if (pLevelRecord->InvertDisableSids != FALSE)
    {
        if (!CodeAuthzpInvertAndAddSids(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->DisableSidUsedCount,
                pLevelRecord->SidsToDisable,
                0,
                NULL,
                &FinalDisabledSidCount,
                &FinalSidsToDisable))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler3;
        }
        FreeFinalDisabledSids = TRUE;
    }
    else
    {
        if (pLevelRecord->DisableSidUsedCount == 0 ||
            pLevelRecord->SidsToDisable == NULL)
        {
            FinalSidsToDisable = NULL;
            FinalDisabledSidCount = 0;
            FreeFinalDisabledSids = FALSE;
        } else {
            if (!CodeAuthzpExpandWildcardList(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->DisableSidUsedCount,
                pLevelRecord->SidsToDisable,
                &FinalDisabledSidCount,
                &FinalSidsToDisable))
            {
                Status = STATUS_UNSUCCESSFUL;
                goto ExitHandler3;
            }
            FreeFinalDisabledSids = TRUE;
        }
    }



    //
    // Get the list of group membership from the token.
    //
    pTokenGroups = (PTOKEN_GROUPS) CodeAuthzpGetTokenInformation(
            InAccessToken, TokenGroups);
    if (!pTokenGroups) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler3;
    }



    //
    // Build the "Principal Self" SID.
    //
    Status = RtlAllocateAndInitializeSid( &SIDAuth, 1,
        SECURITY_PRINCIPAL_SELF_RID, 0, 0, 0, 0, 0, 0, 0,
        &principalSelfSid);
    if (! NT_SUCCESS(Status) ) {
        goto ExitHandler3;
    }


    //
    // if SidsToDisable includes a SID in Groups that is not
    // yet disabled, then return LESS.
    //
    for (Index = 0; Index < FinalDisabledSidCount; Index++)
    {
        if (CodeAuthzpSidInSidAndAttributes (
                pTokenGroups->Groups,
                pTokenGroups->GroupCount,
                principalSelfSid,
                pTokenUser->User.Sid,
                FinalSidsToDisable[Index].Sid,
                TRUE))                  // check only SIDs that are still enabled
        {
            Status = STATUS_SUCCESS;
            *lpResultWord = (DWORD) -1;        // Less priv'ed.
            goto ExitHandler3;
        }
    }


    //
    // Process RestrictingSids inversion.
    //
    if (pLevelRecord->RestrictedSidsInvUsedCount != 0)
    {
        if (!CodeAuthzpInvertAndAddSids(
                InAccessToken,
                pTokenUser->User.Sid,
                pLevelRecord->RestrictedSidsInvUsedCount,
                pLevelRecord->RestrictedSidsInv,
                pLevelRecord->RestrictedSidsAddedUsedCount,
                pLevelRecord->RestrictedSidsAdded,
                &FinalRestrictedSidCount,
                &FinalSidsToRestrict))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler3;
        }
        FreeFinalRestrictedSids = TRUE;
    }
    else
    {
        FinalRestrictedSidCount = pLevelRecord->RestrictedSidsAddedUsedCount;
        FinalSidsToRestrict = pLevelRecord->RestrictedSidsAdded;
    }


    //
    // Get the existing Restricted SIDs from the token.
    //
    pTokenRestrictedSids = (PTOKEN_GROUPS) CodeAuthzpGetTokenInformation(
            InAccessToken, TokenRestrictedSids);
    if (!pTokenRestrictedSids) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler3;
    }


    if (pTokenRestrictedSids->GroupCount != 0)
    {
        //
        // If there are currently no Restricting SIDs and we
        // have to add any, then return LESS.
        //
        if (pTokenRestrictedSids->GroupCount == 0 &&
            FinalRestrictedSidCount != 0)
        {
            *lpResultWord = (DWORD) -1;        // Less priv'ed.
            Status = STATUS_SUCCESS;
            goto ExitHandler3;
        }


        //
        // If the token already includes a Restricting SID that is
        // not in RestrictedSidsAdded then return LESS.
        //
        for (Index = 0; Index < pTokenRestrictedSids->GroupCount; Index++)
        {
            if (!CodeAuthzpSidInSidAndAttributes (
                FinalSidsToRestrict,
                FinalRestrictedSidCount,
                principalSelfSid,
                pTokenUser->User.Sid,
                pTokenRestrictedSids->Groups[Index].Sid,
                FALSE))                     // check all SIDs in the list
            {
                *lpResultWord = (DWORD) -1;        // Less priv'ed.
                Status = STATUS_SUCCESS;
                goto ExitHandler3;
            }
        }
    }
    else
    {
        //
        // if RestrictedSidsAdded then return LESS.
        //
        if (FinalRestrictedSidCount != 0)
        {
            *lpResultWord = (DWORD) -1;        // Less priv'ed.
            Status = STATUS_SUCCESS;
            goto ExitHandler3;
        }
    }


    //
    // If we got here, then the Level is equal or greater
    // privileged than the access token and is safe to run.
    // We could conceivably also want to return LESS if the
    // default owner needs to be changed from what it currently is.
    //
    *lpResultWord = +1;
    Status = STATUS_SUCCESS;



    //
    // Cleanup and epilogue code.
    //
ExitHandler3:
    if (principalSelfSid != NULL)
        RtlFreeSid(principalSelfSid);
    if (pTokenRestrictedSids != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenRestrictedSids);
    if (pTokenGroups != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenGroups);
    if (pTokenPrivs != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenPrivs);
    if (pTokenUser != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) pTokenUser);
    if (FreeFinalDisabledSids)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalSidsToDisable);
    if (FreeFinalRestrictedSids)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalSidsToRestrict);
    if (FreeFinalPrivsToDelete)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) FinalPrivsToDelete);


ExitHandler2:

ExitHandler:
    if (!TokenWasSupplied && InAccessToken != NULL)
        NtClose(InAccessToken);

    return Status;
}



BOOL WINAPI
SaferComputeTokenFromLevel(
        IN SAFER_LEVEL_HANDLE      hLevelObject,
        IN HANDLE           InAccessToken         OPTIONAL,
        OUT PHANDLE         OutAccessToken,
        IN DWORD            dwFlags,
        IN LPVOID           lpReserved
        )
/*++

Routine Description:

    Uses the specified WinSafer Level handle to apply various
    restrictions or modifications to the specified InAccessToken
    to produce a Restricted Token that can be used to execute
    processes with.

Arguments:

    hLevelObject - the WinSafer Level handle that specifies the
        restrictions that should be applied.

    InAccessToken - Optionally specifies the input Token that will be
        modified with restrictions.  If this argument is NULL, then the
        Token for the currently executing process will be opened and used.

    OutAccessToken - Specifies the memory region to receive the resulting
        Restricted Token.

    dwFlags - Specifies additional flags that can be used to control the
        restricted token creation.

    lpReserved - reserved for future use, must be zero.

Return Value:

    A value of TRUE indicates that the operation was successful,
    FALSE otherwise.

--*/
{
    NTSTATUS Status;
    PAUTHZLEVELHANDLESTRUCT pLevelStruct;
    PAUTHZLEVELTABLERECORD pLevelRecord;
    
    OBJECT_ATTRIBUTES ObjAttr = {0};
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService = {0};
    SECURITY_DESCRIPTOR sd;
    PTOKEN_USER pTokenUser = NULL;


    //
    // Verify our input arguments are minimally okay.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(hLevelObject)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }

    if (IsSaferDisabled()) {
		Status = STATUS_SUCCESS;
        if ( (dwFlags & SAFER_TOKEN_NULL_IF_EQUAL) != 0) {
            // The output token was not made any more restrictive during
            // this operation, so pass back NULL and return success.
            *OutAccessToken = NULL;
            Status = STATUS_SUCCESS;
        } else {
            
            //
            // Retrieve the User's personal SID.
            // (user's SID is accessible afterwards with "pTokenUser->User.Sid")
            //
            
            pTokenUser = (PTOKEN_USER) CodeAuthzpGetTokenInformation(
                                           InAccessToken, 
                                           TokenUser
                                           );
            
            if (pTokenUser == NULL) {
                Status = STATUS_UNSUCCESSFUL;
                goto ExitHandler;
            }

            SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE  );
            SecurityQualityOfService.ImpersonationLevel = SecurityAnonymous;
            SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
            SecurityQualityOfService.EffectiveOnly = FALSE;

            Status = RtlCreateSecurityDescriptor(
                        &sd, 
                        SECURITY_DESCRIPTOR_REVISION
                        );

            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            Status = RtlSetOwnerSecurityDescriptor(
                         &sd, 
                         pTokenUser->User.Sid, 
                         FALSE
                         );

            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }

            InitializeObjectAttributes(
                    &ObjAttr,
                    NULL,
                    OBJ_INHERIT,
                    NULL,
                    &sd
                    );

            ObjAttr.SecurityQualityOfService = &SecurityQualityOfService;

            Status = NtDuplicateToken(
                         InAccessToken,
                         TOKEN_ALL_ACCESS,
                         &ObjAttr,
                         FALSE,
                         TokenPrimary,
                         OutAccessToken
                         );

        }
        goto ExitHandler;
	} 

    //
    // Obtain the pointer to the level handle structure.
    //
    RtlEnterCriticalSection(&g_TableCritSec);

    Status = CodeAuthzHandleToLevelStruct(hLevelObject, &pLevelStruct);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    ASSERT(pLevelStruct != NULL);
    pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, pLevelStruct->dwLevelId);
    if (!pLevelRecord) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler2;
    }


	// 
	// Perform the actual computation or comparison operation.
    //
    if ((dwFlags & SAFER_TOKEN_COMPARE_ONLY) != 0) {
        ULONG bIsInert = 0;
        ULONG ulReturnLength=0;

        //
        // check if token is inert - if so, this object is definitely not more restrictive 
        //


        Status = NtQueryInformationToken(
                    InAccessToken,
                    TokenSandBoxInert,
                    &bIsInert,
                    sizeof(bIsInert),
                    &ulReturnLength);

        if (NT_SUCCESS(Status)) {
            if ( bIsInert ) {
                *(LPDWORD)lpReserved = +1;
                goto ExitHandler2;
            } else {
                Status = __CodeAuthzpCompareCodeAuthzLevelWithToken(
                                pLevelRecord,
                                InAccessToken,
                                (LPDWORD) lpReserved);
            }
        }
        else {
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler2;
        }

    }
    else {
        Status = __CodeAuthzpComputeAccessTokenFromCodeAuthzObject (
                        pLevelRecord,
                        InAccessToken,
                        OutAccessToken,
                        dwFlags,
                        lpReserved,
                        pLevelStruct->dwSaferFlags);
    }


    //
    // Cleanup and return code handling.
    //
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    if (pTokenUser) {
        LocalFree(pTokenUser);
    }
    if (Status == -1) {
        SetLastError(ERROR_ACCESS_DISABLED_BY_POLICY);
        return FALSE;
    }
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    return TRUE;
}


BOOL WINAPI
IsTokenUntrusted(
        IN HANDLE   hToken
        )
/*++

Routine Description:

    Indicate if the token does is not able to access a DACL against the
    Token User SID.  This is typically the case in these situations:
      - the User SID is disabled (for deny-use only)
      - there are Restricting SIDs and the User SID is not one of them.

    The passed token handle must have been opened for TOKEN_QUERY and
    TOKEN_DUPLICATE access or else the evaluation will fail.

Arguments:

    hToken - Specifies the input Token that will be analyzed.

Return Value:

    Returns TRUE if the token is "untrusted", or FALSE if the token
    represents a "trusted" token.

    If an error occurs during the evaluation of this check, the result
    returned will be TRUE (assumed untrusted).

--*/
{
    BOOL fTrusted = FALSE;
    DWORD dwStatus;
    DWORD dwACLSize;
    DWORD cbps = sizeof(PRIVILEGE_SET);
    PACL pACL = NULL;
    DWORD dwUserSidSize;
    PTOKEN_USER psidUser = NULL;
    PSECURITY_DESCRIPTOR psdUser = NULL;
    PRIVILEGE_SET ps;
    GENERIC_MAPPING gm;
    HANDLE hImpToken;

    const int TESTPERM_READ = 1;
    const int TESTPERM_WRITE = 2;


    // Prepare some memory
    ZeroMemory(&ps, sizeof(ps));
    ZeroMemory(&gm, sizeof(gm));

    // Get the User's SID.
    if (!GetTokenInformation(hToken, TokenUser, NULL, 0, &dwUserSidSize))
    {
        psidUser = (PTOKEN_USER) LocalAlloc(LPTR, dwUserSidSize);
        if (psidUser != NULL)
        {
            if (GetTokenInformation(hToken, TokenUser, psidUser, dwUserSidSize, &dwUserSidSize))
            {
                // Create the Security Descriptor (SD)
                psdUser = LocalAlloc(LPTR,SECURITY_DESCRIPTOR_MIN_LENGTH);
                if (psdUser != NULL)
                {
                    if(InitializeSecurityDescriptor(psdUser,SECURITY_DESCRIPTOR_REVISION))
                    {
                        // Compute size needed for the ACL then allocate the
                        // memory for it
                        dwACLSize = sizeof(ACCESS_ALLOWED_ACE) + 8 +
                                    GetLengthSid(psidUser->User.Sid) - sizeof(DWORD);
                        pACL = (PACL)LocalAlloc(LPTR, dwACLSize);
                        if (pACL != NULL)
                        {
                            // Initialize the new ACL
                            if(InitializeAcl(pACL, dwACLSize, ACL_REVISION2))
                            {
                                // Add the access-allowed ACE to the DACL
                                if(AddAccessAllowedAce(pACL,ACL_REVISION2,
                                                     (TESTPERM_READ | TESTPERM_WRITE),psidUser->User.Sid))
                                {
                                    // Set our DACL to the Administrator's SD
                                    if (SetSecurityDescriptorDacl(psdUser, TRUE, pACL, FALSE))
                                    {
                                        // AccessCheck is downright picky about what is in the SD,
                                        // so set the group and owner
                                        SetSecurityDescriptorGroup(psdUser,psidUser->User.Sid,FALSE);
                                        SetSecurityDescriptorOwner(psdUser,psidUser->User.Sid,FALSE);

                                        // Initialize GenericMapping structure even though we
                                        // won't be using generic rights
                                        gm.GenericRead = TESTPERM_READ;
                                        gm.GenericWrite = TESTPERM_WRITE;
                                        gm.GenericExecute = 0;
                                        gm.GenericAll = TESTPERM_READ | TESTPERM_WRITE;

                                        if (ImpersonateLoggedOnUser(hToken) &&
                                            OpenThreadToken(GetCurrentThread(),
                                                    TOKEN_QUERY, FALSE, &hImpToken))
                                        {

                                            if (!AccessCheck(psdUser, hImpToken, TESTPERM_READ, &gm,
                                                            &ps,&cbps,&dwStatus,&fTrusted))
                                                    fTrusted = FALSE;

                                            CloseHandle(hImpToken);
                                        }
                                    }
                                }
                            }
                            LocalFree(pACL);
                        }
                    }
                    LocalFree(psdUser);
                }
            }
            LocalFree(psidUser);
        }
    }
    RevertToSelf();
    return(!fTrusted);
}



BOOL WINAPI
SaferiCompareTokenLevels (
        IN HANDLE   ClientAccessToken,
        IN HANDLE   ServerAccessToken,
        OUT PDWORD  pdwResult
        )
/*++

Routine Description:

    Private function provided to try to empiracally determine if
    the two access token have been restricted with comparable
    WinSafer authorization Levels.

Arguments:

    ClientAccessToken - handle to the Access Token of the "client"

    ServerAccessToken - handle to the Access Token of the "server"

    pdwResult - When TRUE is returned, the pdwResult output parameter
        will receive any of the following values:
        -1 = Client's access token is more authorized than Server's.
         0 = Client's access token is comparable level to Server's.
         1 = Server's access token is more authorized than Clients's.

Return Value:

    A value of TRUE indicates that the operation was successful,
    FALSE otherwise.

--*/
{
    NTSTATUS Status;
    LPVOID RestartKey;
    PAUTHZLEVELTABLERECORD authzobj;
    DWORD dwCompareResult;


    //
    // Verify our input arguments are minimally okay.
    //
    if (!ARGUMENT_PRESENT(ClientAccessToken) ||
        !ARGUMENT_PRESENT(ServerAccessToken)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(pdwResult)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }


    //
    // Gain the critical section lock and load the tables as needed.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    if (RtlIsGenericTableEmpty(&g_CodeLevelObjTable)) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }


    //
    // Loop through the Authorization Levels and see where we
    // find the first difference in access rights.
    //
    dwCompareResult = 0;
    RestartKey = NULL;
    for (authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey);
        authzobj != NULL;
        authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey))
    {
        DWORD dwClientResult, dwServerResult;

        Status = __CodeAuthzpCompareCodeAuthzLevelWithToken(
                authzobj,
                ClientAccessToken,
                &dwClientResult);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }

        Status = __CodeAuthzpCompareCodeAuthzLevelWithToken(
                authzobj,
                ServerAccessToken,
                &dwServerResult);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }

        if (dwClientResult == (DWORD) -1 && dwServerResult != (DWORD) -1) {
            dwCompareResult = (DWORD) -1;
            break;
        } else if (dwClientResult != (DWORD) -1 && dwServerResult == (DWORD) -1) {
            dwCompareResult = 1;
            break;
        } else if (dwClientResult != (DWORD) -1 && dwServerResult != (DWORD) -1) {
            dwCompareResult = 0;
            break;
        }
    }
    Status = STATUS_SUCCESS;
    *pdwResult = dwCompareResult;


    //
    // Cleanup and return code handling.
    //
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safeget.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safeget.cpp         (SAFER SaferGetLevelInformation)

Abstract:

    This module implements the WinSAFER APIs to get information about a
    sepcific Authorization Level and the attributes and identities that
    are associated with it.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    SaferGetLevelInformation

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"



DWORD NTAPI
__CodeAuthzpCountIdentsForLevel(
        IN DWORD        dwScopeId,
        IN DWORD        dwLevelId
        )
/*++

Routine Description:

    Determines the number of Code Identities that have been associated
    with a given WinSafer LevelId.  This number represents the number
    of identity GUIDs that will be returned to the caller.

Arguments:

    dwScopeId - specifies the Scope value that will be considered.

    dwLevelId - specifies the LevelId value to be counted.

Return Value:

    Returns the actual number of unique Code Identities that were found
        to be associated with the given LevelId.  If no Identities were
        found, then 0 will be returned.

--*/
{
    PVOID RestartKey;
    PAUTHZIDENTSTABLERECORD pAuthzIdentsRec;
    DWORD dwMatchingCount = 0;


    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));


    RestartKey = NULL;
    for (pAuthzIdentsRec = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
         pAuthzIdentsRec != NULL;
         pAuthzIdentsRec = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey)
         )
    {
        if (pAuthzIdentsRec->dwLevelId == dwLevelId &&
            pAuthzIdentsRec->dwScopeId == dwScopeId)
            dwMatchingCount++;
    }

    return dwMatchingCount;
}



NTSTATUS NTAPI
__CodeAuthzpFetchIdentsForLevel(
        IN DWORD        dwScopeId,
        IN DWORD        dwLevelId,
        IN DWORD        dwInBufferSize,
        IN OUT LPVOID   lpQueryBuffer,
        OUT LPDWORD     pdwUsedSize
        )
/*++

Routine Description:

    Retrieves all of Code Identities that have been associated
    with a given WinSafer LevelId.  The number of identity GUIDs
    that will be returned to the caller can be determined by
    first calling __CodeAuthzpCountIdentsForLevel.  It is assumed
    that the caller has already determined and verified the appropriate
    size of the buffer that should be supplied using that function.

Arguments:

    dwScopeId - specifies the Scope value that will be considered.

    dwLevelId - specifies the LevelId value to be matched.

    dwInBufferSize - specifies the size of the output buffer.

    lpQueryBuffer - points to the output buffer that should be filled.

    pdwUsedSize - receives the actual number of bytes used.

Return Value:

    Returns the actual number of unique Code Identities that were found
        to be associated with the given LevelId.  If no Identities were
        found, then 0 will be returned.

--*/
{
    PVOID RestartKey;
    PAUTHZIDENTSTABLERECORD pIdentRecord;
    LPVOID lpNextPtr;


    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));
    ASSERT(ARGUMENT_PRESENT(lpQueryBuffer));
    ASSERT(ARGUMENT_PRESENT(pdwUsedSize));


    RestartKey = NULL;
    lpNextPtr = (LPVOID) lpQueryBuffer;
    for (pIdentRecord = (PAUTHZIDENTSTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
        pIdentRecord != NULL;
        pIdentRecord = (PAUTHZIDENTSTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey))
    {
        if (pIdentRecord->dwLevelId == dwLevelId &&
            pIdentRecord->dwScopeId == dwScopeId)
        {
            if ( ((PBYTE) lpNextPtr) - ((PBYTE) lpQueryBuffer) +
                 sizeof(GUID) > dwInBufferSize ) {
                return STATUS_BUFFER_TOO_SMALL;
            }
            RtlCopyMemory( lpNextPtr, &pIdentRecord->IdentGuid, sizeof(GUID) );
            lpNextPtr = (LPVOID) ( ((PBYTE) lpNextPtr) + sizeof(GUID));
        }
    }
    ASSERT((PBYTE) lpNextPtr <= ((PBYTE) lpQueryBuffer) + dwInBufferSize);
    *pdwUsedSize = (DWORD) (((PBYTE) lpNextPtr) - ((PBYTE) lpQueryBuffer));
    return STATUS_SUCCESS;
}



NTSTATUS NTAPI
__CodeAuthzpOpenIdentifierKey(
        IN DWORD        dwScopeId,
        IN DWORD        dwLevelId,
        IN LPCWSTR      szIdentityType,
        IN REFGUID      refIdentGuid,
        OUT HANDLE     *phOpenedKey
        )
/*++

Routine Description:

Arguments:

    dwScopeId -

    dwLevelId -

    szIdentityType -

    refIdentGuid -

    phOpenedKey -

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodePath;
    WCHAR szPathBuffer[MAX_PATH];


    if (!ARGUMENT_PRESENT(refIdentGuid) ||
        !ARGUMENT_PRESENT(phOpenedKey)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    }
    RtlInitEmptyUnicodeString(&UnicodePath,
                szPathBuffer, sizeof(szPathBuffer));
    Status = CodeAuthzpFormatIdentityKeyPath(
                dwLevelId, szIdentityType,
                refIdentGuid, &UnicodePath);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpOpenPolicyRootKey(
                dwScopeId, g_hKeyCustomRoot,
                UnicodePath.Buffer,
                KEY_READ, FALSE, phOpenedKey);

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
__CodeAuthzpQueryIdentityRegValue(
        IN HANDLE       hKeyIdentityBase,
        IN LPWSTR       szValueName,
        IN DWORD        dwRegType,
        OUT PVOID       lpOutBuffer,
        IN ULONG        ulOutBufferSize,
        OUT PULONG      pulActualOutSize OPTIONAL
        )
/*++

Routine Description:

    Generic helper function to query a registry value, provided that a
    pre-opened registry handle to the key is already known. 

Arguments:

    hKeyIdentityBase - registry key handle.

    szValueName - null-terminated Unicode string of the registry value name.

    dwRegType - type of the registry value expected (REG_SZ, REG_DWORD, etc)
        If a registry value of the given name exists, but is not of this
        type, then this function will return STATUS_NOT_FOUND.

    lpOutBuffer - pointer to a target buffer that will receive the
        retrieved value contents.

    ulOutBufferSize - input argument that specifies the maximum size
        of the buffer pointed to by the lpOutBuffer argument.

    pulActualOutSize - output argument that receives the actual size
        of the retrieved value contents if the call is successful.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    ULONG ulResultLength;
    UNICODE_STRING ValueName;
    ULONG ulValueBufferSize;
    PKEY_VALUE_PARTIAL_INFORMATION pValuePartialInfo;



    //
    // Allocate enough memory for the query buffer.
    //
    ASSERT(ARGUMENT_PRESENT(lpOutBuffer) && ulOutBufferSize > 0);
    ulValueBufferSize = sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
            ulOutBufferSize + sizeof(WCHAR) * 256;
    pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
            RtlAllocateHeap(RtlProcessHeap(), 0, ulValueBufferSize);
    if (!pValuePartialInfo) {
        Status = STATUS_NO_MEMORY;
        goto ExitHandler;
    }


    //
    // Actually query the value into the temporary query buffer.
    //
    ASSERT(ARGUMENT_PRESENT(szValueName));
    RtlInitUnicodeString(&ValueName, szValueName);
    Status = NtQueryValueKey(hKeyIdentityBase, &ValueName,
                             KeyValuePartialInformation,
                             pValuePartialInfo, ulValueBufferSize,
                             &ulResultLength);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    if (pValuePartialInfo->Type != dwRegType) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }


    //
    // Copy the resulting data from the query buffer into
    // the caller's buffer.
    //

    ulResultLength = pValuePartialInfo->DataLength;
    if (ulResultLength > ulOutBufferSize) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        RtlCopyMemory(lpOutBuffer,
                      pValuePartialInfo->Data,
                      ulResultLength);
        Status = STATUS_SUCCESS;
    }

    if (ARGUMENT_PRESENT(pulActualOutSize)) {
        *pulActualOutSize = ulResultLength;
    }

ExitHandler2:
    RtlFreeHeap(RtlProcessHeap(), 0, (PVOID) pValuePartialInfo);


ExitHandler:
    return Status;
}


NTSTATUS NTAPI
__CodeAuthzpQuerySingleIdentification(
        IN PAUTHZIDENTSTABLERECORD  pSingleIdentRecord,
        OUT LPVOID                  lpQueryBuffer,
        IN DWORD                    dwInBufferSize,
        OUT PDWORD                  dwNeededSize
        )
/*++

Routine Description:

    Allows the user to retrieve information about a single identity.

    Assumes that the caller has already obtained and locked the
    global critical section.

Arguments:

    pSingleIdentRecord - pointer to the identity record structure.

    lpQueryBuffer - pointer to a user-supplied memory buffer that
        will receive the requested information.

    dwInBufferSize - specifies the size of the user's memory block.

    lpdwOutBufferSize - receives the used size of the data within the
        memory block, or the minimum necessary size if the passed
        buffer was too small.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hKeyIdentity = NULL;
    ULONG ulResultLength = 0;
    ULONG ulTextLen = 0;
    PSAFER_IDENTIFICATION_HEADER pIdentCommon = NULL;

    //
    // All of these conditions should have been already verified
    // by our caller before calling us, so we only assert them.
    //
    ASSERT(ARGUMENT_PRESENT(pSingleIdentRecord));
    ASSERT(ARGUMENT_PRESENT(lpQueryBuffer) &&
           dwInBufferSize >= sizeof(SAFER_IDENTIFICATION_HEADER));
    ASSERT(pSingleIdentRecord->dwIdentityType == SaferIdentityTypeImageName ||
           pSingleIdentRecord->dwIdentityType == SaferIdentityTypeImageHash ||
           pSingleIdentRecord->dwIdentityType == SaferIdentityTypeUrlZone);


    //
    // Start filling the resulting structure with the data.
    //
    pIdentCommon = (PSAFER_IDENTIFICATION_HEADER) lpQueryBuffer;
    switch (pSingleIdentRecord->dwIdentityType)
    {
        // --------------------

        case SaferIdentityTypeImageName:
            Status = __CodeAuthzpOpenIdentifierKey(
                        pSingleIdentRecord->dwScopeId,
                        pSingleIdentRecord->dwLevelId,
                        SAFER_PATHS_REGSUBKEY,
                        &pSingleIdentRecord->IdentGuid,
                        &hKeyIdentity);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }

            pIdentCommon->dwIdentificationType = SaferIdentityTypeImageName;
            {
                PSAFER_PATHNAME_IDENTIFICATION pIdentOut = (PSAFER_PATHNAME_IDENTIFICATION) lpQueryBuffer;

                ASSERT(&pIdentOut->header == pIdentCommon);


                ulTextLen = pSingleIdentRecord->ImageNameInfo.ImagePath.Length;

                *dwNeededSize = ulTextLen + sizeof(UNICODE_NULL) +
                                sizeof(SAFER_PATHNAME_IDENTIFICATION);

                if (*dwNeededSize > dwInBufferSize) {
                    // the imagepath is vital, so we'll bail out.
                    Status = STATUS_BUFFER_TOO_SMALL;
                    goto ExitHandler2;
                } 

                pIdentOut->ImageName = (PWCHAR) (((PUCHAR) pIdentOut) + sizeof(SAFER_PATHNAME_IDENTIFICATION));

                Status = __CodeAuthzpQueryIdentityRegValue(
                            hKeyIdentity,
                            SAFER_IDS_DESCRIPTION_REGVALUE,
                            REG_SZ,
                            pIdentOut->Description,
                            SAFER_MAX_DESCRIPTION_SIZE * sizeof(WCHAR),
                            NULL);

                if (!NT_SUCCESS(Status)) {
                    pIdentOut->Description[0] = UNICODE_NULL;
                }
                
                RtlCopyMemory(pIdentOut->ImageName,
                    pSingleIdentRecord->ImageNameInfo.ImagePath.Buffer,
                    ulTextLen);
                pIdentOut->ImageName[ulTextLen / sizeof(WCHAR)] = UNICODE_NULL;

                pIdentOut->header.cbStructSize = *dwNeededSize;

                pIdentOut->dwSaferFlags =
                    pSingleIdentRecord->ImageNameInfo.dwSaferFlags;
            }
            break;

        // --------------------

        case SaferIdentityTypeImageHash:
            Status = __CodeAuthzpOpenIdentifierKey(
                        pSingleIdentRecord->dwScopeId,
                        pSingleIdentRecord->dwLevelId,
                        SAFER_HASHMD5_REGSUBKEY,
                        &pSingleIdentRecord->IdentGuid,
                        &hKeyIdentity);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }

            pIdentCommon->dwIdentificationType = SaferIdentityTypeImageHash;
            {
                PSAFER_HASH_IDENTIFICATION pIdentOut = (PSAFER_HASH_IDENTIFICATION) lpQueryBuffer;

                ASSERT(&pIdentOut->header == pIdentCommon);
                pIdentOut->header.cbStructSize =
                        sizeof(SAFER_HASH_IDENTIFICATION);

                Status = __CodeAuthzpQueryIdentityRegValue(
                            hKeyIdentity,
                            SAFER_IDS_DESCRIPTION_REGVALUE,
                            REG_SZ,
                            pIdentOut->Description,
                            SAFER_MAX_DESCRIPTION_SIZE * sizeof(WCHAR),
                            NULL
                            );
                if (!NT_SUCCESS(Status)) {
                    pIdentOut->Description[0] = UNICODE_NULL;
                }
                Status = __CodeAuthzpQueryIdentityRegValue(
                            hKeyIdentity,
                            SAFER_IDS_FRIENDLYNAME_REGVALUE,
                            REG_SZ,
                            pIdentOut->FriendlyName,
                            SAFER_MAX_FRIENDLYNAME_SIZE * sizeof(WCHAR),
                            NULL
                            );
                if (!NT_SUCCESS(Status)) {
                    pIdentOut->FriendlyName[0] = UNICODE_NULL;
                }
                ASSERT(pSingleIdentRecord->ImageHashInfo.HashSize <= SAFER_MAX_HASH_SIZE);
                RtlCopyMemory(pIdentOut->ImageHash,
                              pSingleIdentRecord->ImageHashInfo.ImageHash,
                              pSingleIdentRecord->ImageHashInfo.HashSize);
                pIdentOut->HashSize =
                        pSingleIdentRecord->ImageHashInfo.HashSize;
                pIdentOut->HashAlgorithm =
                        pSingleIdentRecord->ImageHashInfo.HashAlgorithm;
                pIdentOut->ImageSize =
                        pSingleIdentRecord->ImageHashInfo.ImageSize;
                pIdentOut->dwSaferFlags =
                        pSingleIdentRecord->ImageHashInfo.dwSaferFlags;
            }
            break;

        // --------------------

        case SaferIdentityTypeUrlZone:
        {
            PSAFER_URLZONE_IDENTIFICATION pIdentOut = (PSAFER_URLZONE_IDENTIFICATION) lpQueryBuffer;

            Status = __CodeAuthzpOpenIdentifierKey(
                        pSingleIdentRecord->dwScopeId,
                        pSingleIdentRecord->dwLevelId,
                        SAFER_SOURCEURL_REGSUBKEY,
                        &pSingleIdentRecord->IdentGuid,
                        &hKeyIdentity);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pIdentCommon->dwIdentificationType = SaferIdentityTypeUrlZone;

            ASSERT(&pIdentOut->header == pIdentCommon);
            pIdentOut->header.cbStructSize =
                    sizeof(SAFER_URLZONE_IDENTIFICATION);

            pIdentOut->UrlZoneId =
                    pSingleIdentRecord->ImageZone.UrlZoneId;
            pIdentOut->dwSaferFlags =
                    pSingleIdentRecord->ImageZone.dwSaferFlags;
            break;
        }

        // --------------------

        default:
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;
    }

    //
    // Fill in the other information that is applicable to all types.
    //
    RtlCopyMemory(&pIdentCommon->IdentificationGuid,
                  &pSingleIdentRecord->IdentGuid,
                  sizeof(GUID));
    ASSERT(sizeof(FILETIME) == sizeof(DWORD) * 2);
    Status = __CodeAuthzpQueryIdentityRegValue(
                hKeyIdentity,
                SAFER_IDS_LASTMODIFIED_REGVALUE,
                REG_QWORD,
                &pIdentCommon->lastModified,
                sizeof(FILETIME),
                &ulResultLength
                );
    if (!NT_SUCCESS(Status)) {
        pIdentCommon->lastModified.dwHighDateTime =
            pIdentCommon->lastModified.dwLowDateTime = 0;
    }
    Status = STATUS_SUCCESS;

ExitHandler2:
    NtClose(hKeyIdentity);

ExitHandler:
    return Status;
}



NTSTATUS NTAPI
__CodeAuthzpGetAuthzLevelInfo(
    IN SAFER_LEVEL_HANDLE                      hLevelHandle,
    IN SAFER_OBJECT_INFO_CLASS     dwInfoType,
    OUT LPVOID                          lpQueryBuffer  OPTIONAL,
    IN DWORD                            dwInBufferSize,
    OUT LPDWORD                         lpdwOutBufferSize
    )
/*++

Routine Description:

    Allows the user to query various pieces of information about a
    given Level handle.

    Assumes that the caller has already obtained and locked the
    global critical section.

Arguments:

    hLevelHandle - the handle to the authorization object to evaluate.

    dwInfoType - specifies the type of information being requested.

    lpQueryBuffer - pointer to a user-supplied memory buffer that
        will receive the requested information.

    dwInBufferSize - specifies the size of the user's memory block.

    lpdwOutBufferSize - receives the used size of the data within the
        memory block, or the minimum necessary size if the passed
        buffer was too small.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    const static SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    PAUTHZLEVELHANDLESTRUCT pAuthzLevelStruct;
    PAUTHZLEVELTABLERECORD pAuthzLevelRecord;
    PAUTHZIDENTSTABLERECORD pSingleIdentRecord = NULL;
    DWORD dwHandleScopeId;
    static HMODULE hAdvApiInst = NULL;
    BOOL bUnicodeInitialized = FALSE;
    UNICODE_STRING UnicodeName = {0};
    BOOL b = FALSE;

    //
    // Obtain a pointer to the authorization Level structure.
    //
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));
    Status = CodeAuthzHandleToLevelStruct(hLevelHandle, &pAuthzLevelStruct);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    ASSERT(pAuthzLevelStruct != NULL);
    pAuthzLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, pAuthzLevelStruct->dwLevelId);
    if (!pAuthzLevelRecord) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    dwHandleScopeId = pAuthzLevelStruct->dwScopeId;


    //
    // Some of the attributes are fixed size, or are known before performing
    // the full query against the registry.  Compute their size first.
    //
    *lpdwOutBufferSize = 0;
    switch (dwInfoType)
    {
        case SaferObjectLevelId:              // DWORD
        case SaferObjectScopeId:              // DWORD
        case SaferObjectBuiltin:              // DWORD boolean
            *lpdwOutBufferSize = sizeof(DWORD);
            break;

        case SaferObjectFriendlyName:         // LPCTSTR
            if (hAdvApiInst == NULL)
            {
                hAdvApiInst = (HANDLE) GetModuleHandleW(L"advapi32");
            }

            if (hAdvApiInst == NULL)
            {
                Status = STATUS_NOT_FOUND;
                goto ExitHandler;
            }

            // load the friendly name.
            b = SaferpLoadUnicodeResourceString(
                    hAdvApiInst,
                    (UINT) (pAuthzLevelRecord->uResourceID + 0),
                    &UnicodeName,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

            if (!b)
            {
                Status = STATUS_NOT_FOUND;
                goto ExitHandler;
            }

            bUnicodeInitialized = TRUE;

            *lpdwOutBufferSize = UnicodeName.Length + sizeof(UNICODE_NULL);
            break;

        case SaferObjectDescription:          // LPCTSTR
            if (hAdvApiInst == NULL)
            {
                hAdvApiInst = (HANDLE) GetModuleHandleW(L"advapi32");
            }

            if (hAdvApiInst == NULL)
            {
                Status = STATUS_NOT_FOUND;
                goto ExitHandler;
            }

            // load the friendly name.
            b = SaferpLoadUnicodeResourceString(
                    hAdvApiInst,
                    (UINT) (pAuthzLevelRecord->uResourceID + 1),
                    &UnicodeName,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

            if (!b)
            {
                Status = STATUS_NOT_FOUND;
                goto ExitHandler;
            }

            *lpdwOutBufferSize = UnicodeName.Length + sizeof(UNICODE_NULL);
            break;

#ifdef ALLOW_FULL_WINSAFER
        case SaferObjectDisallowed:               // DWORD boolean
        case SaferObjectDisableMaxPrivilege:      // DWORD boolean
        case SaferObjectInvertDeletedPrivileges:  // DWORD boolean
            *lpdwOutBufferSize = sizeof(DWORD);
            break;

        case SaferObjectDeletedPrivileges:        // TOKEN_PRIVILEGES
            *lpdwOutBufferSize = (sizeof(TOKEN_PRIVILEGES) - sizeof(LUID_AND_ATTRIBUTES)) +
                pAuthzLevelRecord->DeletePrivilegeUsedCount * sizeof(LUID_AND_ATTRIBUTES);
            break;

        case SaferObjectDefaultOwner:             // TOKEN_OWNER
            *lpdwOutBufferSize = sizeof(TOKEN_OWNER);
            if (pAuthzLevelRecord->DefaultOwner != NULL)
                *lpdwOutBufferSize += RtlLengthSid(pAuthzLevelRecord->DefaultOwner);
            break;

        case SaferObjectSidsToDisable:            // TOKEN_GROUPS
            *lpdwOutBufferSize = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                pAuthzLevelRecord->DisableSidUsedCount * sizeof(SID_AND_ATTRIBUTES);
            for (Index = 0; Index < pAuthzLevelRecord->DisableSidUsedCount; Index++)
                *lpdwOutBufferSize += RtlLengthSid(pAuthzLevelRecord->SidsToDisable[Index].Sid);
            break;

        case SaferObjectRestrictedSidsInverted:   // TOKEN_GROUPS
            *lpdwOutBufferSize = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                pAuthzLevelRecord->RestrictedSidsInvUsedCount * sizeof(SID_AND_ATTRIBUTES);
            for (Index = 0; Index < pAuthzLevelRecord->RestrictedSidsInvUsedCount; Index++)
                *lpdwOutBufferSize += RtlLengthSid(pAuthzLevelRecord->RestrictedSidsInv[Index].Sid);
            break;

        case SaferObjectRestrictedSidsAdded:      // TOKEN_GROUPS
            *lpdwOutBufferSize = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                pAuthzLevelRecord->RestrictedSidsAddedUsedCount * sizeof(SID_AND_ATTRIBUTES);
            for (Index = 0; Index < pAuthzLevelRecord->RestrictedSidsAddedUsedCount; Index++)
                *lpdwOutBufferSize += RtlLengthSid(pAuthzLevelRecord->RestrictedSidsAdded[Index].Sid);
            break;
#endif


        case SaferObjectAllIdentificationGuids:
            *lpdwOutBufferSize = sizeof(GUID) *
                __CodeAuthzpCountIdentsForLevel(
                        dwHandleScopeId,
                        pAuthzLevelRecord->dwLevelId);
            if (!*lpdwOutBufferSize) {
                Status = STATUS_NOT_FOUND;
                goto ExitHandler;
            }
            break;


        case SaferObjectSingleIdentification:
        {
            *lpdwOutBufferSize = sizeof(SAFER_IDENTIFICATION_HEADER);
            if (ARGUMENT_PRESENT(lpQueryBuffer) &&
                dwInBufferSize >= *lpdwOutBufferSize)
            {
                PSAFER_IDENTIFICATION_HEADER pIdentCommonHeader =
                    (PSAFER_IDENTIFICATION_HEADER) lpQueryBuffer;

                if (pIdentCommonHeader->cbStructSize < *lpdwOutBufferSize) {
                    // the caller claimed that the dwInBufferSize was
                    // large enough, but the common header size doesn't.
                    goto ExitBufferTooSmall;
                }


                if (IsZeroGUID(&pIdentCommonHeader->IdentificationGuid))
                {
                    //
                    // Caller supplied a zero GUID and wants to retrieve
                    // the rule that produced the SaferIdentifyLevel
                    // result match, if this Level handle was from it.
                    //
                    if (IsZeroGUID(&pAuthzLevelStruct->identGuid)) {
                        // This was a handle that was explicitly opened
                        // by the user with SaferCreateLevel().
                        Status = STATUS_NOT_FOUND;
                        goto ExitHandler;
                    }
                    pSingleIdentRecord = CodeAuthzIdentsLookupByGuid(
                            &g_CodeIdentitiesTable,
                            &pAuthzLevelStruct->identGuid);
                    if (!pSingleIdentRecord) {
                        // This handle was obtained via a match to one of
                        // the special GUIDs or an code identity GUID
                        // that no longer exists.  Just return a blank
                        // structure with just the GUID in the header.
                        *lpdwOutBufferSize = sizeof(SAFER_IDENTIFICATION_HEADER);
                        break;
                    }

                } else {
                    //
                    // Caller is explicitly supplying the GUID of the
                    // code identifier rule that details should be
                    // retrieved for.
                    //
                    pSingleIdentRecord = CodeAuthzIdentsLookupByGuid(
                            &g_CodeIdentitiesTable,
                            &pIdentCommonHeader->IdentificationGuid);
                }


                //
                // We now have a pointer to the identity record that
                // information should be retrieved for.  Perform the
                // necessary work to marshal back the details about it.
                //
                if (!pSingleIdentRecord ||
                    pSingleIdentRecord->dwLevelId !=
                            pAuthzLevelRecord->dwLevelId ||
                    pSingleIdentRecord->dwScopeId != dwHandleScopeId)
                {
                    Status = STATUS_NOT_FOUND;
                    goto ExitHandler;
                }
                switch (pSingleIdentRecord->dwIdentityType) {
                case SaferIdentityTypeImageName:
                        // Size is calculated later on.
                        *lpdwOutBufferSize = 0;
                        break;

                    case SaferIdentityTypeImageHash:
                        *lpdwOutBufferSize = sizeof(SAFER_HASH_IDENTIFICATION);
                        break;

                    case SaferIdentityTypeUrlZone:
                        *lpdwOutBufferSize = sizeof(SAFER_URLZONE_IDENTIFICATION);
                        break;

                    default:
                        Status = STATUS_NOT_FOUND;
                        goto ExitHandler;
                }
            }
            break;
        }

        case SaferObjectExtendedError:
            *lpdwOutBufferSize = sizeof(DWORD);
            break;


        default:
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;
    }
    //ASSERTMSG("required buffer size must be computed", *lpdwOutBufferSize != 0);


    //
    // If there is not enough space for the query, then return with error.
    //
    if (*lpdwOutBufferSize != -1 &&
        (!ARGUMENT_PRESENT(lpQueryBuffer) ||
        dwInBufferSize < *lpdwOutBufferSize) )
    {
ExitBufferTooSmall:
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitHandler;
    }


    //
    // Otherwise there is enough space for the request buffer,
    // so now actually perform the copy.
    //
    switch (dwInfoType)
    {
        case SaferObjectLevelId:              // DWORD
            *(PDWORD)lpQueryBuffer = pAuthzLevelRecord->dwLevelId;
            break;

        case SaferObjectScopeId:              // DWORD
            *(PDWORD)lpQueryBuffer = dwHandleScopeId;
            break;

        case SaferObjectBuiltin:              // DWORD boolean
            *((LPDWORD)lpQueryBuffer) =
                (pAuthzLevelRecord->Builtin ? TRUE : FALSE);
            break;

        case SaferObjectExtendedError:
            *((DWORD *)lpQueryBuffer) = pAuthzLevelStruct->dwExtendedError;
            break;

        case SaferObjectFriendlyName:         // LPCTSTR
            RtlCopyMemory(lpQueryBuffer,
                          UnicodeName.Buffer,
                          UnicodeName.Length);
            ((LPWSTR) lpQueryBuffer)[
                    UnicodeName.Length /
                    sizeof(WCHAR) ] = UNICODE_NULL;
            *lpdwOutBufferSize =
                    UnicodeName.Length +
                    sizeof(UNICODE_NULL);
            break;


        case SaferObjectDescription:          // LPCTSTR

            RtlCopyMemory(lpQueryBuffer,
                          UnicodeName.Buffer,
                          UnicodeName.Length);
            ((LPWSTR) lpQueryBuffer)[UnicodeName.Length / sizeof(WCHAR)] = UNICODE_NULL;
            *lpdwOutBufferSize = UnicodeName.Length + sizeof(UNICODE_NULL);
        break;

#ifdef ALLOW_FULL_WINSAFER
        case SaferObjectDisallowed:               // DWORD boolean
            *((LPDWORD)lpQueryBuffer) = (pAuthzLevelRecord->DisallowExecution != 0) ? TRUE : FALSE;
            break;
        case SaferObjectDisableMaxPrivilege:      // DWORD boolean
            *((LPDWORD)lpQueryBuffer) = (pAuthzLevelRecord->Flags & DISABLE_MAX_PRIVILEGE) != 0;
            break;
        case SaferObjectInvertDeletedPrivileges:  // DWORD boolean
            *((LPDWORD)lpQueryBuffer) = (pAuthzLevelRecord->InvertDeletePrivs != 0) ? TRUE : FALSE;
            break;
        case SaferObjectDeletedPrivileges:        // TOKEN_PRIVILEGES
        {
            PTOKEN_PRIVILEGES pTokenPrivs = (PTOKEN_PRIVILEGES) lpQueryBuffer;
            pTokenPrivs->PrivilegeCount = pAuthzLevelRecord->DeletePrivilegeUsedCount;
            RtlCopyMemory(&pTokenPrivs->Privileges[0],
                    &pAuthzLevelRecord->PrivilegesToDelete[0],
                    sizeof(LUID_AND_ATTRIBUTES) * pAuthzLevelRecord->DeletePrivilegeUsedCount);
            break;
        }
        case SaferObjectDefaultOwner:             // TOKEN_OWNER
        {
            PTOKEN_OWNER pTokenOwner = (PTOKEN_OWNER) lpQueryBuffer;
            if (pAuthzLevelRecord->DefaultOwner == NULL)
                pTokenOwner->Owner = NULL;
            else {
                pTokenOwner->Owner = (PSID) &pTokenOwner[1];
                Status = RtlCopySid(dwInBufferSize - sizeof(TOKEN_OWNER),
                        pTokenOwner->Owner, pAuthzLevelRecord->DefaultOwner);
                ASSERT(NT_SUCCESS(Status));
            }
            break;
        }
        case SaferObjectSidsToDisable:            // TOKEN_GROUPS (wildcard sids)
        {
            PTOKEN_GROUPS pTokenGroups = (PTOKEN_GROUPS) lpQueryBuffer;
            DWORD dwUsedOffset = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                    (sizeof(SID_AND_ATTRIBUTES) * pAuthzLevelRecord->DisableSidUsedCount);
            pTokenGroups->GroupCount = pAuthzLevelRecord->DisableSidUsedCount;
            for (Index = 0; Index < pAuthzLevelRecord->DisableSidUsedCount; Index++) {
                pTokenGroups->Groups[Index].Sid = (PSID) &((LPBYTE)lpQueryBuffer)[dwUsedOffset];
                DWORD dwSidLength = RtlLengthSid(pAuthzLevelRecord->SidsToDisable[Index].Sid);
                ASSERT(dwUsedOffset + dwSidLength <= dwInBufferSize);
                RtlCopyMemory(pTokenGroups->Groups[Index].Sid,
                        pAuthzLevelRecord->SidsToDisable[Index].Sid, dwSidLength);
                dwUsedOffset += dwSidLength;

    //BLACKCOMB TODO: handle wildcard sids differently?
                if (pAuthzLevelRecord->SidsToDisable[Index].WildcardPos == -1)
                    pTokenGroups->Groups[Index].Attributes = 0;
                else
                    pTokenGroups->Groups[Index].Attributes = (((DWORD) '*') << 24) |
                        (pAuthzLevelRecord->SidsToDisable[Index].WildcardPos & 0x0000FFFF);
            }
            break;
        }
        case SaferObjectRestrictedSidsInverted:   // TOKEN_GROUPS (wildcard sids)
        {
            PTOKEN_GROUPS pTokenGroups = (PTOKEN_GROUPS) lpQueryBuffer;
            DWORD dwUsedOffset = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                    (sizeof(SID_AND_ATTRIBUTES) * pAuthzLevelRecord->RestrictedSidsInvUsedCount);
            pTokenGroups->GroupCount = pAuthzLevelRecord->RestrictedSidsInvUsedCount;
            for (Index = 0; Index < pAuthzLevelRecord->RestrictedSidsInvUsedCount; Index++) {
                pTokenGroups->Groups[Index].Sid = (PSID) &((LPBYTE)lpQueryBuffer)[dwUsedOffset];
                DWORD dwSidLength = RtlLengthSid(pAuthzLevelRecord->RestrictedSidsInv[Index].Sid);
                ASSERT(dwUsedOffset + dwSidLength <= dwInBufferSize);
                RtlCopyMemory(pTokenGroups->Groups[Index].Sid,
                        pAuthzLevelRecord->RestrictedSidsInv[Index].Sid, dwSidLength);
                dwUsedOffset += dwSidLength;

    //BLACKCOMB TODO: handle wildcard sids differently?
                if (pAuthzLevelRecord->RestrictedSidsInv[Index].WildcardPos == -1)
                    pTokenGroups->Groups[Index].Attributes = 0;
                else
                    pTokenGroups->Groups[Index].Attributes = (((DWORD) '*') << 24) |
                        (pAuthzLevelRecord->RestrictedSidsInv[Index].WildcardPos & 0x0000FFFF);
            }
            break;
        }
        case SaferObjectRestrictedSidsAdded:      // TOKEN_GROUPS
        {
            PTOKEN_GROUPS pTokenGroups = (PTOKEN_GROUPS) lpQueryBuffer;
            DWORD dwUsedOffset = (sizeof(TOKEN_GROUPS) - sizeof(SID_AND_ATTRIBUTES)) +
                    (sizeof(SID_AND_ATTRIBUTES) * pAuthzLevelRecord->RestrictedSidsAddedUsedCount);
            pTokenGroups->GroupCount = pAuthzLevelRecord->RestrictedSidsAddedUsedCount;
            for (Index = 0; Index < pAuthzLevelRecord->RestrictedSidsAddedUsedCount; Index++) {
                pTokenGroups->Groups[Index].Attributes = 0;
                pTokenGroups->Groups[Index].Sid = (PSID) &((LPBYTE)lpQueryBuffer)[dwUsedOffset];
                DWORD dwSidLength = RtlLengthSid(pAuthzLevelRecord->RestrictedSidsAdded[Index].Sid);
                ASSERT(dwUsedOffset + dwSidLength <= dwInBufferSize);
                RtlCopyMemory(pTokenGroups->Groups[Index].Sid,
                        pAuthzLevelRecord->RestrictedSidsAdded[Index].Sid, dwSidLength);
                dwUsedOffset += dwSidLength;
            }
            break;
        }
#endif

        case SaferObjectAllIdentificationGuids:
            Status = __CodeAuthzpFetchIdentsForLevel(
                            dwHandleScopeId,
                            pAuthzLevelRecord->dwLevelId,
                            dwInBufferSize,
                            lpQueryBuffer,
                            lpdwOutBufferSize);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            break;

        case SaferObjectSingleIdentification:
            if (pSingleIdentRecord == NULL)
            {
                // One of the special identifier GUIDs is being returned,
                // or a no-longer existing identifier GUID.
                PSAFER_IDENTIFICATION_HEADER pCommon =
                    (PSAFER_IDENTIFICATION_HEADER) lpQueryBuffer;

                ASSERT(*lpdwOutBufferSize == sizeof(SAFER_IDENTIFICATION_HEADER));
                RtlZeroMemory(pCommon, sizeof(SAFER_IDENTIFICATION_HEADER));
                pCommon->cbStructSize = sizeof(SAFER_IDENTIFICATION_HEADER);
                RtlCopyMemory(&pCommon->IdentificationGuid,
                              &pAuthzLevelStruct->identGuid,
                              sizeof(GUID));
            }
            else
            {
                // Query information about a specific, existing GUID.
                Status = __CodeAuthzpQuerySingleIdentification(
                            pSingleIdentRecord,
                            lpQueryBuffer,
                            dwInBufferSize,
                            lpdwOutBufferSize
                            );
                if (!NT_SUCCESS(Status)) {
                    goto ExitHandler;
                }
            }
            break;

        default:
            ASSERTMSG("all info classes were not handled", 0);
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;
    }
    Status = STATUS_SUCCESS;



    //
    // Cleanup and epilogue code.
    //

ExitHandler:

    if (bUnicodeInitialized)
    {
        RtlFreeUnicodeString(&UnicodeName);
    }
    return Status;
}



BOOL WINAPI
SaferGetLevelInformation(
        IN SAFER_LEVEL_HANDLE          LevelHandle,
        IN SAFER_OBJECT_INFO_CLASS     dwInfoType,
        OUT LPVOID                     lpQueryBuffer    OPTIONAL ,
        IN DWORD                       dwInBufferSize,
        OUT LPDWORD                    lpdwOutBufferSize
        )
/*++

Routine Description:

    Allows the user to query various pieces of information about a
    given AuthzObject handle.

Arguments:

    LevelHandle - the handle to the authorization object to evaluate.

    dwInfoType - specifies the type of information being requested.

    lpQueryBuffer - pointer to a user-supplied memory buffer that
        will receive the requested information.

    dwInBufferSize - specifies the size of the user's memory block.

    lpdwOutBufferSize - receives the used size of the data within the
        memory block, or the minimum necessary size if the passed
        buffer was too small.

Return Value:

    Returns FALSE on error, otherwise success.

--*/
{
    NTSTATUS Status;


    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }

    if (!ARGUMENT_PRESENT(lpdwOutBufferSize)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }

    RtlEnterCriticalSection(&g_TableCritSec);

    Status = __CodeAuthzpGetAuthzLevelInfo(
                    LevelHandle, dwInfoType,
                    lpQueryBuffer, dwInBufferSize,
                    lpdwOutBufferSize);

    RtlLeaveCriticalSection(&g_TableCritSec);

    if (NT_SUCCESS(Status))
        return TRUE;

ExitHandler:
    BaseSetLastNTError(Status);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\tools\webchange\client\webchange.cpp ===
/*********************************************************************




*********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <unicode.h>
#include <mscat.h>

const WCHAR* g_wszRegKey = L"Software\\Microsoft\\WebChangelistEditor";

BOOL IsNewOrPendingChangelist(WCHAR *wszFilename);
BOOL CalculateHash(WCHAR *wszFilename, WCHAR *wszHash);
void OpenWebEditor(WCHAR *wszURL, WCHAR *wszFilename);
void OpenAlternateEditor(WCHAR *wszFilename);


void PrintUsage()
{
    wprintf(L"Usage: webchange <URL with query string> <temp filename>\n\n");
    wprintf(L"If the temp file is a \"pending\" or \"new\" Source Depot changelist:\n");
    wprintf(L"\tWebChange opens the specified web page and fills in the hash of the\n");
    wprintf(L"\tfile to complete the query string. The web page should host the\n");
    wprintf(L"\tWebChangelistEditor ActiveX control, which can be initialized with the\n");
    wprintf(L"\tgiven hash to edit the changelist.\n");
    wprintf(L"If the temp file is anything else:\n");
    wprintf(L"\tWebChange calls %%SDALTFORMEDITOR%% with the name of the temp file.\n");
    wprintf(L"\nExample: webchange http://ntserver/submit.asp?key= d:\\temp\\t3104t1.tmp\n");
}

int __cdecl wmain(DWORD argc, LPWSTR argv[])
{
    WCHAR   *wszURL;
    WCHAR   *wszFilename;


    // Parse arguments
    if (argc != 3)
    {
        PrintUsage();
        return 1; // Fail
    }
    if ((argv[1][0] == L'/') ||
        (argv[1][0] == L'-') ||
        (argv[2][0] == L'/') ||
        (argv[2][0] == L'-'))
    {
        PrintUsage();
        return 1; // Fail
    }
    if ((wcslen(argv[1]) >= MAX_PATH) ||
        (wcslen(argv[2]) >= MAX_PATH))
    {
        PrintUsage();
        return 1; // Fail
    }

    wszURL = argv[1];
    wszFilename = argv[2];


    if (IsNewOrPendingChangelist(wszFilename))
    {
        OpenWebEditor(wszURL, wszFilename);
    }
    else
    {
        OpenAlternateEditor(wszFilename);
    }
}


void OpenWebEditor(WCHAR *wszURL, WCHAR *wszFilename)
{
    WCHAR               *wszCommand = NULL;
    WCHAR               wszName[MAX_PATH];
    WCHAR               wszHash[41];
    DWORD               dwRet;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFOW        StartupInfo;
    HKEY                hKey = NULL;
    HANDLE              hWait[2];
    HANDLE              hEvent = NULL;

    ProcessInfo.hProcess = NULL;

    if (!CalculateHash(wszFilename, wszHash))
    {
        // Error message is printed by CalculateHash function
        return;
    }

    // Build the program name starting with the program files directory name
    if (!SHGetSpecialFolderPathW(NULL, // hWnd
                                 wszName, // Path Out
                                 CSIDL_PROGRAM_FILES, // Folder ID
                                 FALSE) ||
        (wcslen(wszName) > (MAX_PATH - 100)))
    {
        wprintf(L"WebChange Error: Unable to find Program Files directory\n");
        return;
    }

    // Finish building program name
    wcscat(wszName, L"\\Internet Explorer\\IEXPLORE.exe");

    // Allocate the command string
    wszCommand = (WCHAR*) malloc((1 + wcslen(wszName) + 2 + wcslen(wszURL) +
                                  wcslen(wszHash) + 1) * sizeof(WCHAR));
    if (wszCommand == NULL)
    {
        wprintf(L"WebChange Error: Out of Memory\n");
        goto Done;
    }

    // Build the command string
    wcscpy(wszCommand, L"\"");
    wcscat(wszCommand, wszName);
    wcscat(wszCommand, L"\" ");
    wcscat(wszCommand, wszURL);
    wcscat(wszCommand, wszHash);

    // Create our event for registry notification
    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hEvent == NULL)
    {
        wprintf(L"WebChange Error: Unable to create event\n");
        goto Done;
    }
    
    // Create the Registry Value that the ActiveX control needs
    // Open our Key:
    if (RegCreateKeyExW(HKEY_CURRENT_USER,
                        g_wszRegKey,
                        0,
                        NULL,
                        0,
                        KEY_QUERY_VALUE | KEY_SET_VALUE | KEY_NOTIFY,
                        NULL,
                        &hKey,
                        NULL) != ERROR_SUCCESS)
    {
        wprintf(L"WebChange Error: Failed to open the registry key\n");
        hKey = NULL; // Just to make sure it does not get closed in cleanup
        goto Done;
    }
    
    // Set the specified value:
    if (FAILED(RegSetValueExW(hKey,
                              wszHash,
                              0,
                              REG_SZ,
                              (LPBYTE)wszFilename,
                              (wcslen(wszFilename) + 1) * sizeof(WCHAR))))
    {
        wprintf(L"WebChange Error: Failed to create registry value\n");
        goto Done;
    }
    
    // Watch our key for changes
    if (RegNotifyChangeKeyValue(hKey, 
                                FALSE, 
                                REG_NOTIFY_CHANGE_LAST_SET, 
                                hEvent, 
                                TRUE) != ERROR_SUCCESS)
    {
        wprintf(L"WebChange Error: Failed to set registry notification\n");
        goto Done;
    }

    // Initialize StartupInfo structure
    memset(&StartupInfo, 0, sizeof(STARTUPINFOW));
    StartupInfo.cb = sizeof(STARTUPINFOW);

    // Call IE and open to the specified page
    if (CreateProcessW(wszName,
                       wszCommand,      // command line string
                       NULL,            // SD
                       NULL,            // SD
                       FALSE,           // handle inheritance option
                       CREATE_NEW_PROCESS_GROUP,               // creation flags
                       NULL,            // new environment block
                       NULL,            // current directory name
                       &StartupInfo,    // startup information
                       &ProcessInfo))   // process information
    {
        // Close the Thread handle. I don't use it.
        CloseHandle(ProcessInfo.hThread);

        hWait[0] = hEvent;
        hWait[1] = ProcessInfo.hProcess;

        // Wait until IE exits or our Key is changed.
        WaitAgain:
        dwRet = WaitForMultipleObjects(2, hWait, FALSE, INFINITE);
        if (dwRet == WAIT_OBJECT_0)
        {
            // Then the Registry was modified.

            // First reset the event.
            if (!ResetEvent(hEvent))
            {
                goto Done;
            }
            // Then restart the Notify on the registry key
            if (RegNotifyChangeKeyValue(hKey, 
                                        FALSE, 
                                        REG_NOTIFY_CHANGE_LAST_SET, 
                                        hEvent, 
                                        TRUE) != ERROR_SUCCESS)
            {
                goto Done;
            }
            // Then check to see if our value is still there
            // We do this last to avoid race issues
            if (RegQueryValueExW(hKey,
                                 wszHash,
                                 0,
                                 NULL,
                                 NULL,
                                 NULL) == ERROR_SUCCESS)
            {
                // The key is still there, so wait again
                goto WaitAgain;
            }
            else
            {
                // The key was deleted, so exit
                goto Done;
            }
        }
        if (dwRet == (WAIT_OBJECT_0 + 1))
        {
            // Then IE was closed.

            // Attempt to delete our value whether it's there or not
            RegDeleteValueW(hKey, wszHash);
        }
    }
    else
    {
        ProcessInfo.hProcess = NULL; // Just to be sure.
        wprintf(L"WebChange Error %08X while attempting to execute:\n%s\n",
                GetLastError(), wszCommand);
    }

Done:
    if (hEvent)
    {
        CloseHandle(hEvent);
    }
    if (ProcessInfo.hProcess)
    {
        CloseHandle(ProcessInfo.hProcess);
    }
    
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    if (wszCommand)
    {
        free(wszCommand);
    }

}


void OpenAlternateEditor(WCHAR *wszFilename)
{
    WCHAR *wszCommand;

    wszCommand = (WCHAR*) malloc((18 + wcslen(wszFilename) + 1) * sizeof(WCHAR));
    if (wszCommand == NULL)
    {
        wprintf(L"WebChange Error: Out of Memory\n");
    }

    // Build the command string
    wcscpy(wszCommand, L"%SDALTFORMEDITOR% ");
    wcscat(wszCommand, wszFilename);

    // Execute the alternate editor and wait for it to return.
    if (_wsystem(wszCommand) == -1)
    {
        wprintf(L"WebChange Error: Could not execute: %s\n", wszCommand);
    }

    free(wszCommand);
}


BOOL CalculateHash(WCHAR *wszFilename, WCHAR *wszHash)
{
    CRYPT_HASH_BLOB     SHA1;
    HANDLE              hFile;




    // Initialize the Hash structure
    SHA1.pbData = (BYTE*)malloc(20);
    if (SHA1.pbData)
    {
        SHA1.cbData = 20;
    }
    else
    {
        wprintf(L"WebChange Error: Out of Memory\n");
        return FALSE;
    }

    // Open the file
    hFile = CreateFileW(wszFilename,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (!hFile)
    {
        wprintf(L"WebChange Error: Unable to open %s\n", wszFilename);
        return FALSE;
    }

    // Create the hash of the file using the catalog function
    if (!CryptCATAdminCalcHashFromFileHandle(hFile,
                                             &SHA1.cbData,
                                             SHA1.pbData,
                                             NULL))
    {
        CloseHandle(hFile);
        wprintf(L"WebChange Error: Failed to create file hash\n");
        return FALSE;
    }
    CloseHandle(hFile);

    for (DWORD j = 0; j<SHA1.cbData; j++)
    { // Print the hash to a string:
        swprintf(&(wszHash[j*2]), L"%02X", SHA1.pbData[j]);
    }
    
    // Finished calculating the hash.
    return TRUE;
}


BOOL IsNewOrPendingChangelist(WCHAR *wszFilename)
{
    BOOL                        fRetVal = FALSE;
    FILE                        *pFile = NULL;
    WCHAR                       wszBuffer[500];
    DWORD                       dwState = 0; // State of parsing engine
    
    // Open the file read-only
    pFile = _wfopen(wszFilename, L"rt");
    if (pFile == NULL)
        goto Done;
    
    while (fwscanf(pFile, L"%499[^\n]%*[\n]", &wszBuffer) == 1)
    {
        // Expect a specific comment
        switch (dwState)
        {
            case 0: // Comment block at top of file
                if (wcscmp(wszBuffer, L"# A Source Depot Change Specification.") == 0)
                {
                    // move on:
                    dwState++;
                    break;
                }
                else
                {
                    // Invalid file.
                    goto Done;
                }
            case 1:
                if (wszBuffer[0] == L'#')
                {
                    // Ignore the comment line
                    break;
                }
                else
                {
                    // Stop expecting a comment block
                    dwState++;
                    // Fall through to status=2 below
                }
            case 2: // Change field
                if (wcsncmp(wszBuffer, L"Change:\t", 8) == 0)
                {
                    // move on:
                    dwState++;
                    break;
                }
                else
                {
                    // Invalid file.
                    goto Done;
                }
            case 3: // Status field
                if (wcsncmp(wszBuffer, L"Status:\t", 8) == 0)
                {
                    // Check the Status string:
                    if ((_wcsicmp(&wszBuffer[8], L"pending") != 0) &&
                        (_wcsicmp(&wszBuffer[8], L"new") != 0))
                    {
                        // Invalid file.
                        goto Done;
                    }
                    // move on:
                    dwState++;
                    break;
                }
                else
                {
                    // maybe we haven't gotten to the status field
                    break;
                }
        } // end of case statement
    } // end of while loop
    
    if (dwState == 4)
    {
        // We got past the Status section, so we completed parsing successfully.
        fRetVal = TRUE;
    }
Done:
    if (pFile)
        fclose(pFile);
    return fRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safehand.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    SafeHand.c        (WinSAFER Handle Operations)

Abstract:

    This module implements the WinSAFER APIs to open and close handles
    to SAFER Code Authorization Levels.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzHandleToLevelStruct
    CodeAuthzpOpenPolicyRootKey
    CodeAuthzCreateLevelHandle
    CodeAuthzCloseLevelHandle
    SaferCreateLevel                (public win32 api)
    SaferCloseLevel                 (public win32 api)

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"


//
// All handles have a bit pattern OR-ed onto them to serve both
// as a debugging aid in distinguishing obvious non-handles,
// and also to ensure that a zero handle is never given back.
//
#define LEVEL_HANDLE_BITS   0x74000000
#define LEVEL_HANDLE_MASK   0xFF000000



NTSTATUS NTAPI
CodeAuthzpCreateLevelHandleFromRecord(
        IN PAUTHZLEVELTABLERECORD   pLevelRecord,
        IN DWORD                    dwScopeId,
        IN DWORD                    dwSaferFlags OPTIONAL,
        IN DWORD                    dwExtendedError,
        IN SAFER_IDENTIFICATION_TYPES IdentificationType,
        IN REFGUID                  refIdentGuid OPTIONAL,
        OUT SAFER_LEVEL_HANDLE            *pLevelHandle
        )
/*++

Routine Description:

    Converts a level record to an opaque SAFER_LEVEL_HANDLE handle.

    Note that although this function assumes that the global
    critical section has already been obtained by the caller.

Arguments:

    pLevelRecord - specifies the level record for which the
        request is being made.  It is assumed that this record
        is valid and exists within the g_CodeLevelObjTable.

    dwScopeId - indicates the scope that will be stored within
        the opened handle.  This scope affects the behavior of
        Get/SetInfoCodeAuthzLevel for code identifiers.

    dwSaferFlags - indicates any optional Safer flags that were
        derived from the matching code identifier.  These bits
        will be bitwise ORed in SaferComputeTokenFromLevel.

    dwExtendedError - Error returned by WinVerifyTrust.

    IdentificationType - Rule that identified this level.
    
    refIdentGuid - indicates the Code Identifier record that was
        used to match the given level.  This may be NULL.

    pLevelHandle - receives the resulting opaque Level handle.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    ULONG ulHandleIndex;
    PAUTHZLEVELHANDLESTRUCT pLevelStruct;


    ASSERT(ARGUMENT_PRESENT(pLevelRecord) &&
           ARGUMENT_PRESENT(pLevelHandle));


    //
    // Validate the value passed within the dwScope argument.
    //
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    }


    //
    // Allocate a handle to represent this level.
    //
    pLevelStruct = (PAUTHZLEVELHANDLESTRUCT) RtlAllocateHandle(
                        &g_LevelHandleTable,
                        &ulHandleIndex);
    if (!pLevelStruct) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ExitHandler;
    }

    g_dwNumHandlesAllocated++;

    ASSERT((ulHandleIndex & LEVEL_HANDLE_MASK) == 0);
    *pLevelHandle = UlongToPtr(ulHandleIndex | LEVEL_HANDLE_BITS);


    //
    // Fill in the handle structure to represent this level.
    //
    RtlZeroMemory(pLevelStruct, sizeof(AUTHZLEVELHANDLESTRUCT));
    pLevelStruct->HandleHeader.Flags = RTL_HANDLE_ALLOCATED;
    pLevelStruct->dwLevelId = pLevelRecord->dwLevelId;
    pLevelStruct->dwScopeId = dwScopeId;
    pLevelStruct->dwSaferFlags = dwSaferFlags;
    pLevelStruct->dwHandleSequence = g_dwLevelHandleSequence;
    pLevelStruct->dwExtendedError = dwExtendedError;
    pLevelStruct->IdentificationType = IdentificationType;
    if (ARGUMENT_PRESENT(refIdentGuid)) {
        RtlCopyMemory(&pLevelStruct->identGuid, refIdentGuid, sizeof(GUID));
    } else {
        ASSERT(IsZeroGUID(&pLevelStruct->identGuid));
    }
    Status = STATUS_SUCCESS;


ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzHandleToLevelStruct(
            IN SAFER_LEVEL_HANDLE          hLevelObject,
            OUT PAUTHZLEVELHANDLESTRUCT  *pLevelStruct)
/*++

Routine Description:

    Converts an opaque SAFER_LEVEL_HANDLE handle into a pointer to the
    internal handle structure.

    Note that although this function gains and releases access to
    the critical section during the API execution, the caller is
    expected to have already entered the critical section and
    maintain the critical section for the entire duration under
    which the return pLevelStruct will be used.  Otherwise, the
    pLevelStruct can potentially become invalid if another thread
    reloads the cache tables and invalidates all handles.

Arguments:

    hLevelObject - specifies the handle to the AuthzObject for which the
        request is being made.

    lpLevelObjectStruct - receives a pointer to the internal handle
        structure that represents the specified AuthzLevelObject.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    ULONG ulHandleIndex;

    if (!g_bInitializedFirstTime) {
        return STATUS_UNSUCCESSFUL;
    }
    if (!ARGUMENT_PRESENT(hLevelObject)) {
        return STATUS_INVALID_HANDLE;
    }
    if (!ARGUMENT_PRESENT(pLevelStruct)) {
        return STATUS_ACCESS_VIOLATION;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    ASSERT(!g_bNeedCacheReload);


    //
    // Translate the handle index into a pointer to the handle structure.
    //
    ulHandleIndex = PtrToUlong(hLevelObject);
    if ( (ulHandleIndex & LEVEL_HANDLE_MASK) != LEVEL_HANDLE_BITS) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    ulHandleIndex &= ~LEVEL_HANDLE_MASK;
    if (!RtlIsValidIndexHandle(&g_LevelHandleTable, ulHandleIndex,
                          (PRTL_HANDLE_TABLE_ENTRY*) pLevelStruct)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }

    //
    // Verify some additional sanity checks on the handle structure
    // that was mapped.  Ensure that it was not a handle that was
    // opened, but invalidated because CodeAuthzReloadCacheTables was
    // called before closing then Level handle.
    //
    if (*pLevelStruct == NULL ||
        (*pLevelStruct)->dwHandleSequence != g_dwLevelHandleSequence ||
        !CodeAuthzLevelObjpLookupByLevelId(
                    &g_CodeLevelObjTable, (*pLevelStruct)->dwLevelId ) )
    {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    Status = STATUS_SUCCESS;


ExitHandler:
    RtlLeaveCriticalSection(&g_TableCritSec);
    return Status;
}




NTSTATUS NTAPI
CodeAuthzCreateLevelHandle(
        IN DWORD            dwLevelId,
        IN DWORD            OpenFlags,
        IN DWORD            dwScopeId,
        IN DWORD            dwSaferFlags OPTIONAL,
        OUT SAFER_LEVEL_HANDLE    *pLevelHandle)
/*++

Routine Description:

    Internal function to open a handle to a WinSafer Level.

Arguments:

    dwLevelId - input level of the WinSafer Level to open.
        Note that the dwScopeId argument does not affect the scope
        of the level that is opened itself.

    OpenFlags - flags that affect how the object is opened.

    dwScopeId - input scope identifier that is stored within the
        resulting handle.  This scope identifier is used to affect
        the behavior of SaferGet/SetLevelInformation for code identifier.

    dwSaferFlags - flags that are stored within the resulting handle.
        These flags are usually derived from the code identifier
        that matched, and will be used in the final call to
        SaferComputeTokenFromLevel.

    pLevelHandle - receives the new handle.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    PAUTHZLEVELTABLERECORD pLevelRecord;



    //
    // Verify our input arguments are okay.
    //
    if (!ARGUMENT_PRESENT(pLevelHandle)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    if ((OpenFlags & SAFER_LEVEL_CREATE) != 0 ||
        (OpenFlags & SAFER_LEVEL_DELETE) != 0) {
        // BLACKCOMB TODO: need to support creation or deletion.
        Status = STATUS_NOT_IMPLEMENTED;
        goto ExitHandler;
    }
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }


    //
    // Find the cached record for the requested level.
    //
    pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                            &g_CodeLevelObjTable,
                            dwLevelId);
    if (!pLevelRecord) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }
    ASSERT(pLevelRecord->dwLevelId == dwLevelId);


    //
    // Actually create a Level handle for this record.
    //
    Status = CodeAuthzpCreateLevelHandleFromRecord(
                    pLevelRecord, dwScopeId,
                    dwSaferFlags, ERROR_SUCCESS, SaferIdentityDefault, NULL, pLevelHandle);


    //
    // Handle cleanup and error handling.
    //
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzCloseLevelHandle(
            IN SAFER_LEVEL_HANDLE      hLevelObject)
/*++

Routine Description:

    Internal function to close an AuthzObject handle.

Arguments:

    hLevelObject - the AuthzObject handle to close.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    ULONG ulHandleIndex;
    PAUTHZLEVELHANDLESTRUCT pLevelStruct;

    if (!ARGUMENT_PRESENT(hLevelObject)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);

    ulHandleIndex = PtrToUlong(hLevelObject);
    if ( (ulHandleIndex & LEVEL_HANDLE_MASK) != LEVEL_HANDLE_BITS) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler2;
    }
    ulHandleIndex &= ~LEVEL_HANDLE_MASK;
    if (!RtlIsValidIndexHandle(&g_LevelHandleTable, ulHandleIndex,
                   (PRTL_HANDLE_TABLE_ENTRY *) &pLevelStruct)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler2;
    }
    if (!RtlFreeHandle(&g_LevelHandleTable,
                  (PRTL_HANDLE_TABLE_ENTRY) pLevelStruct)) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler2;
    }
    g_dwNumHandlesAllocated--;
    Status = STATUS_SUCCESS;

ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}



BOOL WINAPI
SaferCreateLevel(
            IN DWORD            dwScopeId,
            IN DWORD            dwLevelId,
            IN DWORD            OpenFlags,
            OUT SAFER_LEVEL_HANDLE    *pLevelObject,
            IN LPVOID           lpReserved)
/*++

Routine Description:

    Public function implementing the Unicode version of this API,
    allowing the user to create or open an Authorization Object
    and receive a handle representing the object.

Arguments:

    dwScopeId - not used (anymore), reserved for future use.

    dwLevelId - input object level of the AuthzObject to create/open.

    OpenFlags - flags to control opening, creation, or deletion.

    lpReserved - not used, reserved for future use.

    pLevelObject - receives the new handle.

Return Value:

    Returns FALSE on error, TRUE on success.  Sets GetLastError() on error.

--*/
{
    NTSTATUS Status;


    //
    // Verify the arguments were all supplied.
    //
    UNREFERENCED_PARAMETER(lpReserved);
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(pLevelObject)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }


    //
    // Actually call the worker functions to get it done.
    //
    Status = CodeAuthzCreateLevelHandle(
                    dwLevelId,
                    OpenFlags,
                    dwScopeId,
                    0,
                    pLevelObject);

    //
    // Set the error result.
    //
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    if ( NT_SUCCESS( Status ) ) {
        return TRUE;
    }
    BaseSetLastNTError(Status);
    return FALSE;
}



BOOL WINAPI
SaferCloseLevel(
            IN SAFER_LEVEL_HANDLE hLevelObject)
/*++

Routine Description:

    Public function to close a handle to an Authorization Level Object.

Arguments:

    hLevelObject - the AuthzObject handle to close.

Return Value:

    Returns FALSE on error, TRUE on success.

--*/
{
    NTSTATUS Status;

    Status = CodeAuthzCloseLevelHandle(hLevelObject);
    if (! NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safeidep.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafeIdep.c        (WinSAFER Identify Objects privates)

Abstract:

    This module implements the WinSAFER APIs that loads the names (and
    high-level information) of all Authorization Levels defined within
    a given registry context.  The list of available levels is loaded
    into a Rtl Generic Table that can be enumerated and accessed using
    conventional Rtl Generic Table techniques.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzLevelObjpInitializeTable
    CodeAuthzLevelObjpLoadTable
    CodeAuthzLevelObjpEntireTableFree

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"




PVOID NTAPI
SaferpGenericTableAllocate (
        IN PRTL_GENERIC_TABLE      Table,
        IN CLONG                   ByteSize
        )
/*++

Routine Description:

    Internal callback for the generic table implementation.
    This function allocates memory for a new entry in a GENERIC_TABLE

Arguments:

    Table         - pointer to the Generic Table structure

    ByteSize      - the size, in bytes, of the structure to allocate

Return Value:

    Pointer to the allocated space.

--*/
{
    UNREFERENCED_PARAMETER(Table);
    return (PVOID) RtlAllocateHeap(RtlProcessHeap(), 0, ByteSize);
}


VOID NTAPI
SaferpGenericTableFree (
        IN PRTL_GENERIC_TABLE          Table,
        IN PVOID                       Buffer
        )
/*++

Routine Description:

    Internal callback for the generic table implementation.
    This function frees the space used by a GENERIC_TABLE entry.

Arguments:

    Table         - pointer to the Generic Table structure

    Buffer        - pointer to the space to deallocate.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(Table);
    ASSERT(Buffer != NULL);

    RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) Buffer);
}





RTL_GENERIC_COMPARE_RESULTS NTAPI
SaferpGuidIdentsTableCompare (
        IN PRTL_GENERIC_TABLE   Table,
        IN PVOID                FirstStruct,
        IN PVOID                SecondStruct
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PAUTHZIDENTSTABLERECORD FirstObj = (PAUTHZIDENTSTABLERECORD) FirstStruct;
    PAUTHZIDENTSTABLERECORD SecondObj = (PAUTHZIDENTSTABLERECORD) SecondStruct;
    int result;

    UNREFERENCED_PARAMETER(Table);

    // Explicitly handle null parameters as wildcards, allowing them
    // to match anything.  We use this for quick deletion of the table.
    if (FirstStruct == NULL || SecondStruct == NULL)
        return GenericEqual;

    // Compare ascending by guid.
    result = memcmp(&FirstObj->IdentGuid,
                    &SecondObj->IdentGuid, sizeof(GUID));
    if ( result < 0 )
        return GenericLessThan;
    else if ( result > 0 )
        return GenericGreaterThan;
    else
        return GenericEqual;
}



VOID NTAPI
CodeAuthzGuidIdentsInitializeTable(
        IN OUT PRTL_GENERIC_TABLE  pAuthzObjTable
        )
/*++

Routine Description:

Arguments:

    pAuthzObjTable - pointer to the generic table structure to initialize.

Return Value:

    Does not return a value.

--*/
{
    RtlInitializeGenericTable(
            pAuthzObjTable,
            (PRTL_GENERIC_COMPARE_ROUTINE) SaferpGuidIdentsTableCompare,
            (PRTL_GENERIC_ALLOCATE_ROUTINE) SaferpGenericTableAllocate,
            (PRTL_GENERIC_FREE_ROUTINE) SaferpGenericTableFree,
            NULL);
}


NTSTATUS NTAPI
SaferpGuidIdentsLoadTable (
        IN OUT PRTL_GENERIC_TABLE  pAuthzIdentTable,
        IN DWORD               dwScopeId,
        IN HANDLE              hKeyCustomBase,
        IN DWORD               dwLevelId,
        IN SAFER_IDENTIFICATION_TYPES dwIdentityType
        )
/*++

Routine Description:

    Loads all Code Identities of a particular fragment type and which
    map to a specific LevelId value.

Arguments:

    pAuthzIdentTable - specifies the table into which the new Code Identity
        records should be inserted.

    dwScopeId - can be AUTHZSCOPEID_USER, AUTHZSCOPEID_MACHINE, or
        AUTHSCOPEID_REGISTRY.

    hKeyCustomBase - used only if dwScopeId is AUTHZSCOPEID_REGISTRY.

    dwLevelId - specifies the LevelId for which identities should
        be loaded.

    dwIdentityType - specifies the type of identity to load.
        This can be SaferIdentityTypeImageName, SaferIdentityTypeImageHash,
        or SaferIdentityTypeUrlZone.

Return Value:

    Returns STATUS_SUCCESS if no error occurs.

--*/
{
    DWORD dwIndex;
    NTSTATUS Status;
    HANDLE hKeyIdentityBase = NULL;
    HANDLE hKeyThisIdentity = NULL;

    PUCHAR LocalBuffer = NULL;
    DWORD Size = sizeof(KEY_BASIC_INFORMATION) + MAX_PATH * sizeof(WCHAR);

    LocalBuffer = (PUCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, Size);

    if (LocalBuffer == NULL) 
    {
        return STATUS_NO_MEMORY;
    }

    //
    // We were given the key to the root of the policy storage,
    // so we need to open the subkey that contains the Identities.
    //
    {
        WCHAR szPathSuffix[MAX_PATH];
        WCHAR szDigits[20];
        UNICODE_STRING UnicodePathSuffix;
        UNICODE_STRING UnicodeDigits;


        UnicodePathSuffix.Buffer = szPathSuffix;
        UnicodePathSuffix.Length = 0;
        UnicodePathSuffix.MaximumLength = sizeof(szPathSuffix);

        UnicodeDigits.Buffer = szDigits;
        UnicodeDigits.Length = 0;
        UnicodeDigits.MaximumLength = sizeof(szDigits);

        Status = RtlAppendUnicodeToString(
            &UnicodePathSuffix,
            SAFER_CODEIDS_REGSUBKEY L"\\");
        if (!NT_SUCCESS(Status)) 
        {
            goto Cleanup;
        }
        Status = RtlIntegerToUnicodeString(
            dwLevelId, 10, &UnicodeDigits);
        if (!NT_SUCCESS(Status)) 
        {
            goto Cleanup;
        }
        Status = RtlAppendUnicodeStringToString(
            &UnicodePathSuffix, &UnicodeDigits);
        if (!NT_SUCCESS(Status)) 
        {
            goto Cleanup;
        }

        switch (dwIdentityType)
        {
            case SaferIdentityTypeImageName:
                Status = RtlAppendUnicodeToString(
                    &UnicodePathSuffix, L"\\" SAFER_PATHS_REGSUBKEY);
                break;

            case SaferIdentityTypeImageHash:
                Status = RtlAppendUnicodeToString(
                    &UnicodePathSuffix, L"\\" SAFER_HASHMD5_REGSUBKEY);
                break;

            case SaferIdentityTypeUrlZone:
                Status = RtlAppendUnicodeToString(
                    &UnicodePathSuffix, L"\\" SAFER_SOURCEURL_REGSUBKEY);
                break;

            default:
                Status = STATUS_INVALID_PARAMETER;
                break;
        }
        if (!NT_SUCCESS(Status)) 
        {
            goto Cleanup;
        }
        ASSERT(UnicodePathSuffix.Buffer[ UnicodePathSuffix.Length /
                    sizeof(WCHAR) ] == UNICODE_NULL);


        Status = CodeAuthzpOpenPolicyRootKey(
                        dwScopeId,
                        hKeyCustomBase,
                        UnicodePathSuffix.Buffer,
                        KEY_READ,
                        FALSE,
                        &hKeyIdentityBase);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }


    //
    // Iterate through all subkeys under this branch.
    //
    for (dwIndex = 0; ; dwIndex++)
    {
        DWORD dwLength;
        OBJECT_ATTRIBUTES ObjectAttributes;
        AUTHZIDENTSTABLERECORD AuthzIdentsRec;

        PKEY_BASIC_INFORMATION pBasicInformation =
                (PKEY_BASIC_INFORMATION) LocalBuffer;
        PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64 pPartialInformation =
                (PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64) LocalBuffer;
        UNICODE_STRING ValueName;
        UNICODE_STRING UnicodeKeyname;


        //
        // Find the next Identity GUID that we will check.
        //
        Status = NtEnumerateKey(hKeyIdentityBase,
                                dwIndex,
                                KeyBasicInformation,
                                pBasicInformation,
                                Size,
                                &dwLength);
        if (!NT_SUCCESS(Status)) {
            //
            // If this one key was too large to fit in our query buffer
            // then simply skip over it and try enumerating the next one.
            //
            if (Status == STATUS_BUFFER_OVERFLOW) {


                //
                // Reallocate and retry.
                //

                RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) LocalBuffer);
                Size = dwLength;
                LocalBuffer = (PUCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, Size);

                if (LocalBuffer == NULL) 
                {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                pBasicInformation = (PKEY_BASIC_INFORMATION) LocalBuffer;
                pPartialInformation = (PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64) LocalBuffer;

                Status = NtEnumerateKey(hKeyIdentityBase,
                                        dwIndex,
                                        KeyBasicInformation,
                                        pBasicInformation,
                                        Size,
                                        &dwLength);
                if (!NT_SUCCESS(Status)) {
                    break;
                }
            } else {
                break;
            }
        }
        UnicodeKeyname.Buffer = pBasicInformation->Name;
        UnicodeKeyname.MaximumLength = UnicodeKeyname.Length =
                (USHORT) pBasicInformation->NameLength;

        //
        // Translate the keyname (which we expect to be a GUID).
        //
        RtlZeroMemory(&AuthzIdentsRec, sizeof(AUTHZIDENTSTABLERECORD));
        Status = RtlGUIDFromString(&UnicodeKeyname,
                                   &AuthzIdentsRec.IdentGuid);
        if (!NT_SUCCESS(Status) ||
            IsZeroGUID(&AuthzIdentsRec.IdentGuid)) {
            // the keyname was apparently not numeric.
            continue;
        }
        AuthzIdentsRec.dwScopeId = dwScopeId;
        AuthzIdentsRec.dwLevelId = dwLevelId;
        AuthzIdentsRec.dwIdentityType = dwIdentityType;
        if (RtlLookupElementGenericTable(
                pAuthzIdentTable, (PVOID) &AuthzIdentsRec) != NULL) {
            // this identity GUID happens to have already been found.
            continue;
        }


        //
        // Try to open a handle to that Identity GUID.
        //
        InitializeObjectAttributes(&ObjectAttributes,
              &UnicodeKeyname,
              OBJ_CASE_INSENSITIVE,
              hKeyIdentityBase,
              NULL
              );
        Status = NtOpenKey(&hKeyThisIdentity,
                           KEY_READ,
                           &ObjectAttributes);
        if (!NT_SUCCESS(Status)) {
            // If we failed to open it, skip to the next one.
            break;
        }


        //
        // Add the new record into our table.
        //
        switch (dwIdentityType) {
            // --------------------

            case SaferIdentityTypeImageName:
                //
                // Read the image path.
                //
                RtlInitUnicodeString(
                    &ValueName, SAFER_IDS_ITEMDATA_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformationAlign64,
                                         pPartialInformation,
                                         Size,
                                         &dwLength);
                if (!NT_SUCCESS(Status)) {
                    if (Status == STATUS_BUFFER_OVERFLOW) {

                        //
                        // Reallocate and retry.
                        //

                        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) LocalBuffer);
                        Size = dwLength;
                        LocalBuffer = (PUCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, Size);

                        if (LocalBuffer == NULL) 
                        {
                            Status = STATUS_NO_MEMORY;
                            goto Cleanup;
                        }

                        pBasicInformation = (PKEY_BASIC_INFORMATION) LocalBuffer;
                        pPartialInformation = (PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64) LocalBuffer;

                        Status = NtQueryValueKey(hKeyThisIdentity,
                                                 &ValueName,
                                                 KeyValuePartialInformationAlign64,
                                                 pPartialInformation,
                                                 Size,
                                                 &dwLength);
                        if (!NT_SUCCESS(Status)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                if (pPartialInformation->Type == REG_SZ ||
                    pPartialInformation->Type == REG_EXPAND_SZ) {

                    AuthzIdentsRec.ImageNameInfo.bExpandVars =
                        (pPartialInformation->Type == REG_EXPAND_SZ);
                    Status = RtlCreateUnicodeString(
                            &AuthzIdentsRec.ImageNameInfo.ImagePath,
                            (LPCWSTR) pPartialInformation->Data);
                    if (!NT_SUCCESS(Status)) {
                        break;
                    }
                } else {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                //
                // Read the extra WinSafer flags.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_SAFERFLAGS_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformationAlign64,
                                         pPartialInformation,
                                         Size,
                                         &dwLength);
                if (NT_SUCCESS(Status) &&
                    pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    AuthzIdentsRec.ImageNameInfo.dwSaferFlags =
                        (*(PDWORD) pPartialInformation->Data);

                } else {
                    // default the flags if they are missing.
                    AuthzIdentsRec.ImageNameInfo.dwSaferFlags = 0;
                    Status = STATUS_SUCCESS;
                }

                break;

            // --------------------

            case SaferIdentityTypeImageHash:
                //
                // Read the hash data and hash size.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_ITEMDATA_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformationAlign64,
                                         pPartialInformation,
                                         Size,
                                         &dwLength);
                if (!NT_SUCCESS(Status)) {
                    if (Status == STATUS_BUFFER_OVERFLOW) {

                        //
                        // Reallocate and retry.
                        //

                        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) LocalBuffer);
                        Size = dwLength;
                        LocalBuffer = (PUCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, Size);

                        if (LocalBuffer == NULL) 
                        {
                            Status = STATUS_NO_MEMORY;
                            goto Cleanup;
                        }

                        pBasicInformation = (PKEY_BASIC_INFORMATION) LocalBuffer;
                        pPartialInformation = (PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64) LocalBuffer;

                        Status = NtQueryValueKey(hKeyThisIdentity,
                                                 &ValueName,
                                                 KeyValuePartialInformationAlign64,
                                                 pPartialInformation,
                                                 Size,
                                                 &dwLength);

                        if (!NT_SUCCESS(Status)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                if (pPartialInformation->Type == REG_BINARY &&
                    pPartialInformation->DataLength > 0 &&
                    pPartialInformation->DataLength <= SAFER_MAX_HASH_SIZE) {

                    AuthzIdentsRec.ImageHashInfo.HashSize =
                        pPartialInformation->DataLength;
                    RtlCopyMemory(&AuthzIdentsRec.ImageHashInfo.ImageHash[0],
                                  pPartialInformation->Data,
                                  pPartialInformation->DataLength);

                } else {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                //
                // Read the algorithm used to compute the hash.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_HASHALG_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformationAlign64,
                                         pPartialInformation,
                                         Size,
                                         &dwLength);
                if (!NT_SUCCESS(Status)) {
                    break;
                }
                if (pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    AuthzIdentsRec.ImageHashInfo.HashAlgorithm =
                        *((PDWORD) pPartialInformation->Data);
                } else {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }
                if ((AuthzIdentsRec.ImageHashInfo.HashAlgorithm &
                        ALG_CLASS_ALL) != ALG_CLASS_HASH) {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }


                //
                // Read the original image size.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_ITEMSIZE_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformationAlign64,
                                         pPartialInformation,
                                         Size,
                                         &dwLength);
                if (!NT_SUCCESS(Status)) {
                    if (Status == STATUS_BUFFER_OVERFLOW) {

                        //
                        // Reallocate and retry.
                        //

                        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) LocalBuffer);
                        Size = dwLength;
                        LocalBuffer = (PUCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, Size);

                        if (LocalBuffer == NULL) 
                        {
                            Status = STATUS_NO_MEMORY;
                            goto Cleanup;
                        }

                        pBasicInformation = (PKEY_BASIC_INFORMATION) LocalBuffer;
                        pPartialInformation = (PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64) LocalBuffer;

                        Status = NtQueryValueKey(hKeyThisIdentity,
                                                 &ValueName,
                                                 KeyValuePartialInformationAlign64,
                                                 pPartialInformation,
                                                 Size,
                                                 &dwLength);
                        if (!NT_SUCCESS(Status)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                if (pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    AuthzIdentsRec.ImageHashInfo.ImageSize.LowPart =
                        *((PDWORD) pPartialInformation->Data);
                    AuthzIdentsRec.ImageHashInfo.ImageSize.HighPart = 0;
                } else if (pPartialInformation->Type == REG_QWORD &&
                           pPartialInformation->DataLength == 2 * sizeof(DWORD) ) {

                    AuthzIdentsRec.ImageHashInfo.ImageSize.QuadPart =
                        ((PLARGE_INTEGER) pPartialInformation->Data)->QuadPart;
                } else {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                //
                // Read the extra WinSafer flags.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_SAFERFLAGS_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformationAlign64,
                                         pPartialInformation,
                                         Size,
                                         &dwLength);
                if (NT_SUCCESS(Status) &&
                    pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    #ifdef SAFER_POLICY_ONLY_EXES
                    AuthzIdentsRec.ImageHashInfo.dwSaferFlags =
                        (*((PDWORD) pPartialInformation->Data)) &
                        ~SAFER_POLICY_ONLY_EXES;
                    #else
                    AuthzIdentsRec.ImageHashInfo.dwSaferFlags =
                        (*((PDWORD) pPartialInformation->Data));
                    #endif

                } else {
                    // default the flags if they are missing.
                    AuthzIdentsRec.ImageHashInfo.dwSaferFlags = 0;
                    Status = STATUS_SUCCESS;
                }


                break;

            // --------------------

            case SaferIdentityTypeUrlZone:
                //
                // Read the zone identifier.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_ITEMDATA_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformationAlign64,
                                         pPartialInformation,
                                         Size,
                                         &dwLength);
                if (!NT_SUCCESS(Status)) {
                    if (Status == STATUS_BUFFER_OVERFLOW) {

                        //
                        // Reallocate and retry.
                        //

                        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) LocalBuffer);
                        Size = dwLength;
                        LocalBuffer = (PUCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, Size);

                        if (LocalBuffer == NULL) 
                        {
                            Status = STATUS_NO_MEMORY;
                            goto Cleanup;
                        }

                        pBasicInformation = (PKEY_BASIC_INFORMATION) LocalBuffer;
                        pPartialInformation = (PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64) LocalBuffer;

                        Status = NtQueryValueKey(hKeyThisIdentity,
                                                 &ValueName,
                                                 KeyValuePartialInformationAlign64,
                                                 pPartialInformation,
                                                 Size,
                                                 &dwLength);

                        if (!NT_SUCCESS(Status)) {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                if (pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    AuthzIdentsRec.ImageZone.UrlZoneId =
                        * (PDWORD) pPartialInformation->Data;

                } else {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }

                //
                // Read the extra WinSafer flags.
                //
                RtlInitUnicodeString(&ValueName,
                                     SAFER_IDS_SAFERFLAGS_REGVALUE);
                Status = NtQueryValueKey(hKeyThisIdentity,
                                         &ValueName,
                                         KeyValuePartialInformationAlign64,
                                         pPartialInformation,
                                         Size,
                                         &dwLength);
                if (NT_SUCCESS(Status) &&
                    pPartialInformation->Type == REG_DWORD &&
                    pPartialInformation->DataLength == sizeof(DWORD)) {

                    #ifdef SAFER_POLICY_ONLY_EXES
                    AuthzIdentsRec.ImageZone.dwSaferFlags =
                        (*(PDWORD) pPartialInformation->Data) &
                        ~SAFER_POLICY_ONLY_EXES;
                    #else
                    AuthzIdentsRec.ImageZone.dwSaferFlags =
                        (*(PDWORD) pPartialInformation->Data);
                    #endif

                } else {
                    // default the flags if they are missing.
                    AuthzIdentsRec.ImageZone.dwSaferFlags = 0;
                    Status = STATUS_SUCCESS;
                }

                break;

            // --------------------

            default:
                ASSERT(0 && "unexpected identity type");
                Status = STATUS_INVALID_INFO_CLASS;
        }

        // Only insert the record if we don't have
        // any other entries with this same GUID.
        if (NT_SUCCESS(Status)) {
            RtlInsertElementGenericTable(
                    pAuthzIdentTable,
                    (PVOID) &AuthzIdentsRec,
                    sizeof(AUTHZIDENTSTABLERECORD),
                    NULL);
        }
        NtClose(hKeyThisIdentity);
        hKeyThisIdentity = NULL;
    }

Cleanup:

    if (hKeyThisIdentity != NULL) {
        NtClose(hKeyThisIdentity);
    }

    if (hKeyIdentityBase != NULL) {
        NtClose(hKeyIdentityBase);
    }

    RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) LocalBuffer);

    return Status;
}


NTSTATUS NTAPI
CodeAuthzGuidIdentsLoadTableAll (
        IN PRTL_GENERIC_TABLE       pAuthzLevelTable,
        IN OUT PRTL_GENERIC_TABLE   pAuthzIdentTable,
        IN DWORD                    dwScopeId,
        IN HANDLE                   hKeyCustomBase
        )
/*++

Routine Description:

Arguments:

    pAuthzLevelTable - specifies the table that has already been
        loaded with the WinSafer Levels that should be allowed.
        These Levels do not necessarily need to have been loaded
        from the same scope from which the Code Identities are
        being loaded from.

    pAuthzIdentTable - specifies the table into which the loaded
        Code Identities should be inserted.

    dwScopeId - scope from where the Code Identities should be loaded from.
        This may be AUTHZSCOPEID_MACHINE, AUTHZSCOPEID_USER, or
        AUTHZSCOPEID_REGISTRY.

    hKeyCustomBase - only used if dwScopeId was AUTHZSCOPEID_REGISTRY.

Return Value:

    Returns STATUS_SUCCESS if no errors occurred.

--*/
{
    NTSTATUS Status;
    NTSTATUS WorstStatus = STATUS_SUCCESS;
    PVOID RestartKey;
    PAUTHZLEVELTABLERECORD pAuthzLevelRecord;


    //
    // Enumerate through all records and close the registry handles.
    //
    RestartKey = NULL;
    for (pAuthzLevelRecord = (PAUTHZLEVELTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    pAuthzLevelTable, &RestartKey);
         pAuthzLevelRecord != NULL;
         pAuthzLevelRecord = (PAUTHZLEVELTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    pAuthzLevelTable, &RestartKey)
         )
    {
        Status = SaferpGuidIdentsLoadTable(
                    pAuthzIdentTable,
                    dwScopeId,
                    hKeyCustomBase,
                    pAuthzLevelRecord->dwLevelId,
                    SaferIdentityTypeImageName);
        if (!NT_SUCCESS(Status))
            WorstStatus = Status;

        Status = SaferpGuidIdentsLoadTable(
                    pAuthzIdentTable,
                    dwScopeId,
                    hKeyCustomBase,
                    pAuthzLevelRecord->dwLevelId,
                    SaferIdentityTypeImageHash);
        if (!NT_SUCCESS(Status))
            WorstStatus = Status;

        Status = SaferpGuidIdentsLoadTable(
                    pAuthzIdentTable,
                    dwScopeId,
                    hKeyCustomBase,
                    pAuthzLevelRecord->dwLevelId,
                    SaferIdentityTypeUrlZone);
        if (!NT_SUCCESS(Status))
            WorstStatus = Status;
    }


    return WorstStatus;
}



VOID NTAPI
CodeAuthzGuidIdentsEntireTableFree (
        IN OUT PRTL_GENERIC_TABLE pAuthzIdentTable
        )
/*++

Routine Description:

    Frees the allocated memory associated with all of the entries
    currently within a Code Identities table.  Once the table has
    been emptied, it may immediately be filled again without any
    other initialization necessary.

Arguments:

    pAuthzIdentTable - pointer to the table that should be cleared.

Return Value:

    Does not return any value.

--*/
{
    ULONG NumElements;

    //
    // Now iterate through the table again and free all of the
    // elements themselves.
    //
    NumElements = RtlNumberGenericTableElements(pAuthzIdentTable);

    while ( NumElements-- > 0 ) {
        // Delete all elements.  Note that we pass NULL as the element
        // to delete because our compare function is smart enough to
        // allow treatment of NULL as a wildcard element.
        BOOL retval = RtlDeleteElementGenericTable( pAuthzIdentTable, NULL);
        ASSERT(retval == TRUE);
    }
}


PAUTHZIDENTSTABLERECORD NTAPI
CodeAuthzIdentsLookupByGuid (
        IN PRTL_GENERIC_TABLE      pAuthzIdentTable,
        IN REFGUID                 pIdentGuid
        )
/*++

Routine Description:

    This function searches for an identity within a GENERIC_TABLE.

Arguments:

    pAuthzIdentTable   - pointer to the Generic Table structure

    pIdentGuid -

Return Value:

    Returns a pointer to the Code Identity record if the GUID
    specified was found.  Otherwise NULL is returned.

--*/
{
    AUTHZIDENTSTABLERECORD AuthzIdentsRec;

    RtlCopyMemory(&AuthzIdentsRec.IdentGuid, pIdentGuid, sizeof(GUID));
    return (PAUTHZIDENTSTABLERECORD)
        RtlLookupElementGenericTable(pAuthzIdentTable,
                   (PVOID) &AuthzIdentsRec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safeiden.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafeIden.c        (WinSAFER SaferIdentifyLevel)

Abstract:

    This module implements the WinSAFER APIs that evaluate the system
    policies to determine which Authorization Level has been configured
    to apply restrictions for a specified application or code library.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    SaferiSearchMatchingHashRules        (privately exported)
    SaferIdentifyLevel

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <md5.h>
#include <wchar.h>  //for swprintf

#pragma warning(push, 3)
#include <wintrust.h>           // WinVerifyTrust
#include <softpub.h>            // WINTRUST_ACTION_GENERIC_VERIFY_V2
#pragma warning(pop)

#include <winsafer.h>
#include <winsaferp.h>
#include <wintrust.h>
#include <crypto\wintrustp.h>
#include "saferp.h"

#define EXPAND_REGPATH

//#define VERBOSE_IDENTIFICATIONS
#ifdef VERBOSE_IDENTIFICATIONS
#define OUTPUTDEBUGSTRING(v)        OutputDebugStringW(v)
#else
#define OUTPUTDEBUGSTRING(v)
#endif

const static GUID guidTrustedCert = SAFER_GUID_RESULT_TRUSTED_CERT;
const static GUID guidDefaultRule = SAFER_GUID_RESULT_DEFAULT_LEVEL;



NTSTATUS NTAPI
__CodeAuthzpEnsureMapped(
        IN OUT PLOCALIDENTITYCONTEXT pIdentContext
        )
/*++

Routine Description:

    Evaluates the supplied identification context structure and
    attempts to gain access to a mapped memory region of the entity
    being identified.  It does the following steps:

        1) if the identification context already has a non-NULL memory
            pointer then returns successfully.
        2) if the identification context has a non-NULL file handle
            then that handle is memory mapped into memory and
            returns successfully.
        3) if the identification context has a non-NULL image filename
            then that filename is opened for read access and memory
            mapped into memory.

    Otherwise the function call is not successful.

    The caller must be sure to call CodeAuthzpEnsureUnmapped later.

Arguments:

    pIdentContext = pointer to the identification context structure.
            After this function call succeeds, the caller can assume
            that pIdentContext->pImageMemory and pIdentContext->ImageSize
            are valid and can be used.

Return Value:

    Returns STATUS_SUCCESS if a memory-mapped image pointer and size
    are now available, otherwise a failure occurred trying to map them.

--*/
{
    HANDLE hMapping;


    ASSERT(ARGUMENT_PRESENT(pIdentContext) &&
           pIdentContext->CodeProps != NULL);


    if (pIdentContext->pImageMemory == NULL ||
        pIdentContext->ImageSize.QuadPart == 0)
    {
        //
        // If a memory pointer and imagesize were supplied to us
        // in the CodeProperties, then just use them directly.
        //
        if (pIdentContext->CodeProps->ImageSize.QuadPart != 0 &&
            pIdentContext->CodeProps->pByteBlock != NULL)
        {
            pIdentContext->pImageMemory =
                    pIdentContext->CodeProps->pByteBlock;
            pIdentContext->ImageSize.QuadPart =
                    pIdentContext->CodeProps->ImageSize.QuadPart;
            pIdentContext->bImageMemoryNeedUnmap = FALSE;
            return STATUS_SUCCESS;
        }

        //
        // Ensure that we have an open file handle, by using the
        // handle supplied to us in the CodeProperties if possible,
        // otherwise by opening the supplied ImagePath.
        //
        if (pIdentContext->hFileHandle == NULL) {
            // no file handle supplied.
            return STATUS_INVALID_PARAMETER;       // failed.
        }


        //
        // Get the size of the file.  We assume that if we had to
        // open the file ourself that the ImageSize cannot be used.
        //
        if (!GetFileSizeEx(pIdentContext->hFileHandle,
                           &pIdentContext->ImageSize)) {
            return STATUS_ACCESS_DENIED;       // failure
        }
        if (pIdentContext->ImageSize.HighPart != 0) {
            //BLACKCOMB TODO: maybe later handle very large files.
            return STATUS_NO_MEMORY;        // failure--too large.
        }
        if (pIdentContext->ImageSize.QuadPart == 0) {
            return STATUS_INVALID_PARAMETER;       // failure--zero file size.
        }


        //
        // Now that we have an open file handle, open it up
        // as a memory-mapped file mapping.
        //
        hMapping = CreateFileMapping(
                        pIdentContext->hFileHandle,
                        NULL,
                        PAGE_READONLY,
                        (DWORD) 0,      // highword zero
                        (DWORD) pIdentContext->ImageSize.LowPart,
                        NULL);
        if (hMapping == NULL || hMapping == INVALID_HANDLE_VALUE) {
            return STATUS_ACCESS_DENIED;
        }


        //
        // View map the file into memory.
        //
        pIdentContext->pImageMemory =
            MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0,
                    pIdentContext->ImageSize.LowPart);
        CloseHandle(hMapping);
        if (pIdentContext->pImageMemory == NULL) {
            return STATUS_ACCESS_DENIED;
        }
        pIdentContext->bImageMemoryNeedUnmap = TRUE;
    }
    return STATUS_SUCCESS;
}


NTSTATUS NTAPI
__CodeAuthzpEnsureUnmapped(
        IN OUT PLOCALIDENTITYCONTEXT        pIdentContext
        )
/*++

Routine Description:

    Reverses the effects of __CodeAuthzEnsureMapped and closes and
    frees any handles that were opened to the specified file.

Arguments:

    pIdentContext - pointer to the context structure.

Return Value:

    Returns STATUS_SUCCESS if no errors occurred.

--*/
{
    ASSERT(pIdentContext != NULL);

    if (pIdentContext->bImageMemoryNeedUnmap &&
        pIdentContext->pImageMemory != NULL)
    {
        UnmapViewOfFile((LPCVOID) pIdentContext->pImageMemory);
        pIdentContext->pImageMemory = NULL;
        pIdentContext->bImageMemoryNeedUnmap = FALSE;
    }

    return STATUS_SUCCESS;
}



NTSTATUS NTAPI
CodeAuthzpComputeImageHash(
        IN PVOID        pImageMemory,
        IN DWORD        dwImageSize,
        OUT PBYTE       pComputedHash OPTIONAL,
        IN OUT PDWORD   pdwHashSize OPTIONAL,
        OUT ALG_ID     *pHashAlgorithm OPTIONAL
        )
/*++

Routine Description:

    Computes an MD5 image hash of a specified region of memory.
    Note, MD5 hashes are always 16 bytes in length.

Arguments:

    pImageMemory - Pointer to a memory buffer to compute the hash of.

    dwImageSize - Total size of the pImageMemory buffer in bytes.

    pComputedHash - Pointer that receives the computed hash.

    pdwHashSize - Pointer to a DWORD value.  On input, this DWORD should
            specify the maximum size of the pComputedHash buffer.
            On successful execution of this function, the length of the
            resulting hash is written to this pointer.

    pHashAlgorithm - pointer to a variable that will receive the hash
            algorithm that was used to compute the hash.  This will
            always be the constant CALG_MD5.

Return Value:

    Returns STATUS_SUCCESS on successful execution.

--*/
{
    MD5_CTX md5ctx;

    //
    // Check the validity of the arguments supplied to us.
    //
    if (!ARGUMENT_PRESENT(pImageMemory) ||
        dwImageSize == 0) {
        return STATUS_INVALID_PARAMETER;
    }
    if (!ARGUMENT_PRESENT(pComputedHash) ||
        !ARGUMENT_PRESENT(pdwHashSize) ||
        *pdwHashSize < 16) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Compute the MD5 hash of it.
    // (this could also be done with CryptCreateHash+CryptHashData)
    //
    MD5Init(&md5ctx);
    MD5Update(&md5ctx, (LPBYTE) pImageMemory, dwImageSize);
    MD5Final(&md5ctx);

    //
    // Copy the hash to the user's buffer.
    //
    RtlCopyMemory(pComputedHash, &md5ctx.digest[0], 16);
    *pdwHashSize = 16;
    if (ARGUMENT_PRESENT(pHashAlgorithm)) {
        *pHashAlgorithm = CALG_MD5;
    }

    return STATUS_SUCCESS;
}




NTSTATUS NTAPI
__CodeAuthzpCheckIdentityPathRules(
        IN OUT PLOCALIDENTITYCONTEXT    pIdentStruct,
        OUT PAUTHZLEVELTABLERECORD       *pFoundLevel,
        OUT PBOOL                       pbExactMatch,
        OUT PAUTHZIDENTSTABLERECORD    *pFoundIdentity
        )
/*++

Routine Description:

    Evaluates a wildcard pattern against a specified pathname and
    indicates if they match.

Arguments:

    pIdentStruct -

    pFoundLevel - receives a pointer to the authorization Level record
        indicated by the best matching rule.

    pbExactMatch - receives a boolean value indicating if the match
        was against an exact fully qualified path rule.

    pFoundIdentity - receives a pointer to the identifier entry rule
        that best matched.

Return Value:

    Returns STATUS_SUCCESS if a WinSafer Level has been found,
    or STATUS_NOT_FOUND if not.  Otherwise an error code.

--*/
{
    NTSTATUS Status;
    PVOID RestartKey;
    UNICODE_STRING UnicodePath;
    WCHAR ExpandedPath[MAX_PATH];
    WCHAR szLongPath[MAX_PATH];
    PAUTHZIDENTSTABLERECORD pAuthzIdentRecord, pBestIdentRecord;
    PAUTHZLEVELTABLERECORD pAuthzLevelRecord;
    LPWSTR lpKeyname = NULL;

    LONG lBestLevelDepth;
    DWORD dwBestLevelId;
    BOOLEAN bFirstPass;

    LONG bPathIdentIsBadType = -1;     // represents uninit'd state


    //
    // Verify that our input arguments all make sense.
    //
    if (!ARGUMENT_PRESENT(pIdentStruct) ||
        pIdentStruct->CodeProps == NULL ||
        !ARGUMENT_PRESENT(pFoundLevel) ||
        !ARGUMENT_PRESENT(pbExactMatch))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if ((pIdentStruct->dwCheckFlags & SAFER_CRITERIA_IMAGEPATH) == 0 ||
        pIdentStruct->UnicodeFullyQualfiedLongFileName.Buffer == NULL ||
        RtlIsGenericTableEmpty(&g_CodeIdentitiesTable))
    {
        // We're not supposed to evaluate image paths.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));


    //
    // Enumerate through all path subkey GUIDs.
    //
    bFirstPass = TRUE;
    RestartKey = NULL;
    for (pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
         pAuthzIdentRecord != NULL;
         pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey)
         )
    {
        if (pAuthzIdentRecord->dwIdentityType ==
                    SaferIdentityTypeImageName)
        {//begin reg key lookup block
            LONG lMatchDepth;


            //
            // Explicitly expand environmental variables.
            //
            if (pAuthzIdentRecord->ImageNameInfo.bExpandVars) {

#ifdef EXPAND_REGPATH
            //This code attempts to expand "path" entries that are really reg keys.
            //For example, some paths are install dependent.  These paths are commonly written into
            //the registry.  You can specify a regkey that is a path.
            //For example see the following regkeys:
            //HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
            //HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders
            //HKEY_CURRENT_USER\Software\Microsoft\Office\9.0\Outlook\Security\OutlookSecureTempFolder
            {
                LPWSTR lpzRegKey = pAuthzIdentRecord->ImageNameInfo.ImagePath.Buffer;
                HKEY hKey=NULL, hKeyHive=NULL;
                BOOL bIsCurrentUser = FALSE;

                //leading percent does two things:
                //1.  The rules created will be the Expandable String Type (REG_EXPAND_SZ)
                //2.  Reduces the chance of a real path name conflict.
                LPCWSTR LP_CU_HIVE = L"%HKEY_CURRENT_USER";
                LPCWSTR LP_LM_HIVE = L"%HKEY_LOCAL_MACHINE";

                BYTE buffer[MAX_PATH *2 + 80];
                LPWSTR lpValue=NULL;
                DWORD dwBufferSize = sizeof(buffer);
                LPWSTR lpHivename;
                LPWSTR lpLastPercentSign;
                LONG retval;
                BOOL bIsRegKey=TRUE;
                DWORD dwKeyLength;

                //We expect a string like the following:
                //%HKEY_CURRENT_USER\Software\Microsoft\Office\9.0\Outlook\Security\OutlookSecureTempFolder%
                //We need to break it into three parts for the registry query:
                //1.  The hive: HKEY_CURRENT_USER
                //2.  The key name: Software\Microsoft\Office\9.0\Outlook\Security
                //3.  The value name: OutlookSecureTempFolder
                lpKeyname=NULL;
                lpValue=NULL;
                lpHivename=NULL;
                lpLastPercentSign=NULL;
                memset(buffer, 0, dwBufferSize);
                lpHivename = wcsstr(lpzRegKey, LP_CU_HIVE);
                OUTPUTDEBUGSTRING(L"\n");
                OUTPUTDEBUGSTRING(L"$");
                OUTPUTDEBUGSTRING(lpzRegKey);
                OUTPUTDEBUGSTRING(L"\n");
                lpLastPercentSign = wcsrchr(lpzRegKey, '%');
                //if (lpLastPercentSign != &lpzRegKey[wcslen(lpzRegKey) - 1]) {  //needs to end in a '%' as well
                
                //
                // we allow %key+valuename%OLK* type paths now
                // but there still has to be a matching %
                //

                if (!lpLastPercentSign) {  
                    bIsRegKey = FALSE;
                }
                if (bIsRegKey) {
                    if (lpHivename != NULL) {
                        hKeyHive = HKEY_CURRENT_USER;
                        bIsCurrentUser = TRUE;
                        dwKeyLength = (wcslen(&lpzRegKey[wcslen(LP_CU_HIVE)+1]) +1) * sizeof (WCHAR);
                        lpKeyname = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY, dwKeyLength);
                        if ( lpKeyname == NULL ) {
                            Status = STATUS_NO_MEMORY;
                            goto ForLoopCleanup;
                        }
                        wcscpy(lpKeyname, &lpzRegKey[wcslen(LP_CU_HIVE)+1] );
                        OUTPUTDEBUGSTRING(L"HKEY_CURRENT_USER");
                        OUTPUTDEBUGSTRING(L"\n");
                    } else {
                        lpHivename = wcsstr(lpzRegKey, LP_LM_HIVE);
                        if (lpHivename != NULL) {
                            hKeyHive = HKEY_LOCAL_MACHINE;
                            dwKeyLength = (wcslen(&lpzRegKey[wcslen(LP_LM_HIVE)+1]) +1) * sizeof (WCHAR);
                            lpKeyname = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY, dwKeyLength);
                            if ( lpKeyname == NULL ) {
                                Status = STATUS_NO_MEMORY;
                                goto ForLoopCleanup;
                            }
                            wcscpy(lpKeyname, &lpzRegKey[wcslen(LP_LM_HIVE)+1] );
                            OUTPUTDEBUGSTRING(L"HKEY_LOCAL_MACHINE");
                            OUTPUTDEBUGSTRING(L"\n");
                        } else {
                            //The string is either a path or bogus data
                            bIsRegKey = FALSE;
                        }
                    }
                }

                if (bIsRegKey) {
                    lpValue = wcsrchr(lpKeyname, '\\');
                    if (lpValue==NULL) {
                        Status = STATUS_NOT_FOUND;
                        goto ForLoopCleanup;
                    }
                    //Take the regkey and value and stick a null terminator in between them.
                    *lpValue = '\0';
                    lpValue++;
                    //lpValue[wcslen(lpValue)-1] = '\0';
                    //lpLastPercentSign[0] = L'\0'; //replace the final '%' char with a null terminator
                    lpLastPercentSign = wcsrchr(lpValue, '%');
                    if (lpLastPercentSign == NULL) {
                        Status = STATUS_NOT_FOUND;
                        goto ForLoopCleanup;
                        }
                        *lpLastPercentSign = '\0';

                 //
                 // Bug# 416461 - causes handle leak so use a different API
                 // for the user hive
                 //

                 if ( bIsCurrentUser ) {
                       if (retval = RegOpenCurrentUser( KEY_READ, &hKeyHive ) ) {
                           if ( retval == ERROR_FILE_NOT_FOUND || 
                                retval == ERROR_NOT_FOUND ||
                                retval == ERROR_PATH_NOT_FOUND) {

                                if (lpKeyname) {
                                    HeapFree(GetProcessHeap(), 0,lpKeyname);
                                    lpKeyname = NULL;
                                }
                                continue;
                            }

                            Status = STATUS_NOT_FOUND;
                            goto ForLoopCleanup;
                        }
                  }

                  retval = RegOpenKeyEx(hKeyHive,
                                        lpKeyname,
                                        0,
                                        KEY_READ,
                                        &hKey);

                  if ( bIsCurrentUser ) {
                     RegCloseKey(hKeyHive);
                  }

                    if (retval)
                    {
                        if ( retval == ERROR_FILE_NOT_FOUND || 
                             retval == ERROR_NOT_FOUND ||
                             retval == ERROR_PATH_NOT_FOUND) {
                            
                            if (lpKeyname) {
                                HeapFree(GetProcessHeap(), 0,lpKeyname);
                                lpKeyname = NULL;
                            }
                            continue;
                        }
                        
                        Status = STATUS_NOT_FOUND;
                        goto ForLoopCleanup;
                    } else {
                        OUTPUTDEBUGSTRING(lpKeyname);
                        OUTPUTDEBUGSTRING(L"\n");
                        OUTPUTDEBUGSTRING(lpValue);
                        OUTPUTDEBUGSTRING(L"\n");

                        if (retval = RegQueryValueEx(hKey,
                                            lpValue,
                                            NULL,
                                            NULL,
                                            buffer,
                                            &dwBufferSize))
                        {
                            RegCloseKey(hKey);
                            Status = STATUS_NOT_FOUND;
                            goto ForLoopCleanup;
                        } else {
#ifdef VERBOSE_IDENTIFICATIONS
                            UNICODE_STRING UnicodeDebug;
                            WCHAR DebugBuffer[MAX_PATH*2 + 80];
#endif
                            UNICODE_STRING NewPath;
                            PUNICODE_STRING pPathFromRule;

                            //
                            // if it exists, concatenate the filename after 
                            // i.e. the OLK in %HKEY\somekey\somevalue%OLK
                            //

                            if (lpLastPercentSign[1] != L'\0') {

                                //
                                // there is some stuff after %HKEY\somekey\somevalue%
                                //
                            
                                if (sizeof(buffer) > 
                                    ((wcslen((WCHAR*)buffer) + wcslen(lpLastPercentSign+1))* sizeof(WCHAR))) {

                                    WCHAR   *pwcBuffer = (WCHAR *)buffer;
                                    if (pwcBuffer[0] != L'\0' && 
                                        pwcBuffer[wcslen(pwcBuffer)-1] != L'\\') {
                                        wcscat((WCHAR*)buffer, L"\\");
                                    }
                                    wcscat((WCHAR*)buffer, lpLastPercentSign+1);
                            
                                }
                            }
                            
                            pPathFromRule=&(pAuthzIdentRecord->ImageNameInfo.ImagePath);
                            NewPath.Length = (USHORT)wcslen((WCHAR*)buffer) * sizeof(WCHAR);
                            NewPath.MaximumLength = (USHORT)wcslen((WCHAR*)buffer) * sizeof(WCHAR);
                            NewPath.Buffer = (PWCHAR)buffer;
                            

#ifdef VERBOSE_IDENTIFICATIONS
                            RtlInitEmptyUnicodeString(&UnicodeDebug, DebugBuffer, sizeof(DebugBuffer));
                            swprintf(UnicodeDebug.Buffer, L"pPathFromRule(L,ML,Buffer)=(%d,%d,%s)\n",
                                        pPathFromRule->Length,
                                        pPathFromRule->MaximumLength,
                                        pPathFromRule->Buffer);
                            OUTPUTDEBUGSTRING(UnicodeDebug.Buffer);

                            memset(DebugBuffer, '0', sizeof(DebugBuffer));
                            swprintf(UnicodeDebug.Buffer, L"NewPath(L,ML,Buffer)=(%d,%d,%s)\n",
                                        NewPath.Length,
                                        NewPath.MaximumLength,
                                        NewPath.Buffer);
                            OUTPUTDEBUGSTRING(UnicodeDebug.Buffer);
#endif


                            //The new path may be bigger than the current UNICODE_STRING can store.  Reallocate if necessary.
                            if (pPathFromRule->MaximumLength >=
                                NewPath.Length + sizeof(UNICODE_NULL)) {
                                RtlCopyUnicodeString(
                                        pPathFromRule,
                                        &NewPath);
                            } else {
                                UNICODE_STRING UnicodeExpandedCopy;

                                Status = RtlDuplicateUnicodeString(
                                                RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
                                                RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                                                &NewPath,
                                                &UnicodeExpandedCopy);

                                if (NT_SUCCESS(Status)) {
                                    RtlFreeUnicodeString(&pAuthzIdentRecord->ImageNameInfo.ImagePath);
                                    pAuthzIdentRecord->ImageNameInfo.ImagePath = UnicodeExpandedCopy;
                                }
                            }

#ifdef VERBOSE_IDENTIFICATIONS
                            memset(DebugBuffer, '0', sizeof(DebugBuffer));
                            swprintf(UnicodeDebug.Buffer, L"pPathFromRule after copy(L,ML,Buffer)=(%d,%d,%s)\n",
                                        pPathFromRule->Length,
                                        pPathFromRule->MaximumLength,
                                        pPathFromRule->Buffer);
                            OUTPUTDEBUGSTRING(UnicodeDebug.Buffer);
#endif
                        }

                    }
                    RegCloseKey(hKey);
                }
                if (lpKeyname) {
                    HeapFree(GetProcessHeap(), 0,lpKeyname);
                    lpKeyname = NULL;
                }

            } //end reg key lookup block

#endif

            // Attempt to expand now.
                RtlInitEmptyUnicodeString(
                        &UnicodePath,
                        &ExpandedPath[0],
                        sizeof(ExpandedPath) );

                Status = RtlExpandEnvironmentStrings_U(
                            NULL,               // environment
                            &pAuthzIdentRecord->ImageNameInfo.ImagePath,       // unexpanded path
                            &UnicodePath,       // resulting path
                            NULL);              // needed buffer size.
                if (!NT_SUCCESS(Status)) {
                    // Failed to expand environment strings.
                    continue;
                }


                // Perf optimization:  If the expansion was successful,
                // update the table to keep the expanded version, eliminating
                // the need to expand the string for any future comparisons.
                if (pAuthzIdentRecord->ImageNameInfo.ImagePath.MaximumLength >=
                    UnicodePath.Length + sizeof(UNICODE_NULL)) {
                    RtlCopyUnicodeString(
                            &pAuthzIdentRecord->ImageNameInfo.ImagePath,
                            &UnicodePath);
                    pAuthzIdentRecord->ImageNameInfo.bExpandVars = FALSE;
                } else {
                    UNICODE_STRING UnicodeExpandedCopy;

                    Status = RtlDuplicateUnicodeString(
                                    RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
                                    RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                                    &UnicodePath,
                                    &UnicodeExpandedCopy);

                    if (NT_SUCCESS(Status)) {
                        RtlFreeUnicodeString(
                                &pAuthzIdentRecord->ImageNameInfo.ImagePath);
                        pAuthzIdentRecord->ImageNameInfo.ImagePath =
                                UnicodeExpandedCopy;
                        pAuthzIdentRecord->ImageNameInfo.bExpandVars = FALSE;
                    }
                }

            } else {
                UnicodePath.Buffer = pAuthzIdentRecord->ImageNameInfo.ImagePath.Buffer;
                UnicodePath.Length = pAuthzIdentRecord->ImageNameInfo.ImagePath.Length;
                UnicodePath.MaximumLength = pAuthzIdentRecord->ImageNameInfo.ImagePath.MaximumLength;
            }


            //
            // Attempt short -> long filename expansion (if there is a need)
            //

            szLongPath[0] = L'\0';

            //
            //  unicode buffer is guaranteed to be < MAX_PATH
            //

            wcsncpy(szLongPath,
                    pAuthzIdentRecord->ImageNameInfo.ImagePath.Buffer,
                    pAuthzIdentRecord->ImageNameInfo.ImagePath.Length/sizeof(WCHAR));

            szLongPath[pAuthzIdentRecord->ImageNameInfo.ImagePath.Length/sizeof(WCHAR)] = L'\0';

            if ( wcschr(szLongPath, L'~') ) {

                if (!GetLongPathNameW(szLongPath,
                                      szLongPath,
                                      sizeof(szLongPath) / sizeof(WCHAR))) {

                    Status = STATUS_VARIABLE_NOT_FOUND;
                    continue;
                }

                RtlInitUnicodeString(&UnicodePath, szLongPath);

                if (pAuthzIdentRecord->ImageNameInfo.ImagePath.MaximumLength >=
                    UnicodePath.Length + sizeof(UNICODE_NULL)) {
                    RtlCopyUnicodeString(
                                        &pAuthzIdentRecord->ImageNameInfo.ImagePath,
                                        &UnicodePath);
                } else {
                    UNICODE_STRING UnicodeExpandedCopy;

                    Status = RtlDuplicateUnicodeString(
                                                      RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
                                                      RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                                                      &UnicodePath,
                                                      &UnicodeExpandedCopy);

                    if (NT_SUCCESS(Status)) {
                        RtlFreeUnicodeString(
                                            &pAuthzIdentRecord->ImageNameInfo.ImagePath);
                        pAuthzIdentRecord->ImageNameInfo.ImagePath =
                        UnicodeExpandedCopy;
                    }
                }
            }


            //
            // Compute the quality of which the wildcard path identity
            // matches the ImagePath property we were asked to evaluate.
            //
            ASSERT(UnicodePath.Buffer[UnicodePath.Length / sizeof(WCHAR)] == UNICODE_NULL);
            ASSERT(pIdentStruct->UnicodeFullyQualfiedLongFileName.Buffer[
                    pIdentStruct->UnicodeFullyQualfiedLongFileName.Length / sizeof(WCHAR)] == UNICODE_NULL);
            lMatchDepth = CodeAuthzpCompareImagePath(UnicodePath.Buffer,
                    pIdentStruct->UnicodeFullyQualfiedLongFileName.Buffer);
            if (!lMatchDepth) continue;


            //
            // If this path identity is configured to only apply to
            // file extensions on the "bad list" then check to see if
            // the ImagePath specifies one of the bad extensions.
            //
            #ifdef AUTHZPOL_SAFERFLAGS_ONLY_EXES
            if (lMatchDepth > 0 &&
                (pAuthzIdentRecord->ImageNameInfo.dwSaferFlags &
                    AUTHZPOL_SAFERFLAGS_ONLY_EXES) != 0)
            {
                if (bPathIdentIsBadType == -1) {
                    BOOLEAN bResult;

                    Status = CodeAuthzIsExecutableFileType(
                            &pIdentStruct->UnicodeFullyQualfiedLongFileName, FALSE,
                            &bResult );
                    if (!NT_SUCCESS(Status) || !bResult) {
                        bPathIdentIsBadType = FALSE;
                    } else {
                        bPathIdentIsBadType = TRUE;
                    }
                }
                if (!bPathIdentIsBadType) {
                    // This identity matches against only the "bad"
                    // extensions, so pretend that this didn't match.
                    continue;
                }
            }
            #endif


            //
            // Emit some diagnostic debugging code to show the result
            // of all of the path evaluations and their match depths.
            //
            #ifdef VERBOSE_IDENTIFICATIONS
            {
                UNICODE_STRING UnicodeDebug;
                WCHAR DebugBuffer[MAX_PATH*2 + 80];

                // sprintf is for wimps.
                RtlInitEmptyUnicodeString(&UnicodeDebug, DebugBuffer, sizeof(DebugBuffer));
                RtlAppendUnicodeToString(&UnicodeDebug, L"Safer pattern ");
                RtlAppendUnicodeStringToString(&UnicodeDebug, &UnicodePath);
                RtlAppendUnicodeToString(&UnicodeDebug, L" matched ");
                RtlAppendUnicodeStringToString(&UnicodeDebug, &(pIdentStruct->UnicodeFullyQualfiedLongFileName));
                RtlAppendUnicodeToString(&UnicodeDebug, L" with value ");
                UnicodeDebug.Buffer += UnicodeDebug.Length / sizeof(WCHAR);
                UnicodeDebug.MaximumLength -= UnicodeDebug.Length;
                RtlIntegerToUnicodeString(lMatchDepth, 10, &UnicodeDebug);
                RtlAppendUnicodeToString(&UnicodeDebug, L"\n");
                OUTPUTDEBUGSTRING(DebugBuffer);
            }
            #endif


            //
            // Evaluate if this path identity matches better than whatever
            // best path identity that we previously had, and keep it if so.
            //
            if (lMatchDepth < 0)    // an exact fully-qualified path!
            {
                if (bFirstPass ||
                    lBestLevelDepth >= 0 ||
                    pAuthzIdentRecord->dwLevelId < dwBestLevelId)
                {
                    pBestIdentRecord = pAuthzIdentRecord;
                    dwBestLevelId = pAuthzIdentRecord->dwLevelId;
                    lBestLevelDepth = lMatchDepth;
                    bFirstPass = FALSE;
                }
            }
            else   // an inexact leading prefix path match.
            {
                ASSERT(lMatchDepth > 0);

                if (bFirstPass ||
                    (lBestLevelDepth >= 0 &&
                        (lMatchDepth > lBestLevelDepth ||
                            (lMatchDepth == lBestLevelDepth &&
                            pAuthzIdentRecord->dwLevelId < dwBestLevelId)
                         )
                     )
                    )
                {
                    pBestIdentRecord = pAuthzIdentRecord;
                    dwBestLevelId = pAuthzIdentRecord->dwLevelId;
                    lBestLevelDepth = lMatchDepth;
                    bFirstPass = FALSE;
                }
            }

ForLoopCleanup:
            if (lpKeyname)
            {
                HeapFree(GetProcessHeap(), 0,lpKeyname);
                lpKeyname = NULL;
            }
        }

    }


    //
    // If we have identified a matching WinSafer Level then
    // look up the Level record for it and return success.
    //
    if (bFirstPass) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    pAuthzLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, dwBestLevelId);
    if (!pAuthzLevelRecord) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    *pFoundLevel = pAuthzLevelRecord;
    *pbExactMatch = (lBestLevelDepth < 0 ? TRUE : FALSE);
    *pFoundIdentity = pBestIdentRecord;

    Status = STATUS_SUCCESS;


ExitHandler:
                
    if (lpKeyname)
        HeapFree(GetProcessHeap(), 0,lpKeyname);
    return Status;
}



NTSTATUS NTAPI
__CodeAuthzpCheckIdentityCertificateRules(
        IN OUT PLOCALIDENTITYCONTEXT    pIdentStruct,
        OUT DWORD                    *dwExtendedError,
        OUT PAUTHZLEVELTABLERECORD     *pFoundLevel,
        IN  DWORD                       dwUIChoice
        )
/*++

Routine Description:

    Calls WinVerifyTrust to determine the trust level of the code
    signer that has signed a piece of code.

Arguments:

    pIdentStruct - context state structure.

    dwExtendedError - To return extended error returned by WinVerifyTrust.
    
    pFoundLevel - receives a pointer to the authorization Level record
        indicated by the best matching rule.

    dwUIChoice - optionally specifies the amount of UI that WinVerifyTrust
        is allowed to display.  If this argument is 0, then it is treated
        as if WTD_UI_ALL had been supplied.

Return Value:

    Returns STATUS_SUCCESS if a WinSafer Level has been found,
    or STATUS_RETRY if the publisher was unknown and UIflags blocked prompting,
    or STATUS_NOT_FOUND if not.  Otherwise an error code.

--*/
{
    NTSTATUS Status;
    PAUTHZLEVELTABLERECORD pLevelRecord;
    GUID wvtFileActionID = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_FILE_INFO wvtFileInfo;
    WINTRUST_DATA wvtData;
    LONG lStatus;
    DWORD dwLastError;
    DWORD LocalHandleSequenceNumber;

    //
    // Verify that our input arguments all make sense.
    //
    if (!ARGUMENT_PRESENT(pIdentStruct) ||
        pIdentStruct->CodeProps == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if ((pIdentStruct->dwCheckFlags & SAFER_CRITERIA_AUTHENTICODE) == 0 ||
        !ARGUMENT_PRESENT(pIdentStruct->UnicodeFullyQualfiedLongFileName.Buffer)) {
        // We're not supposed to evaluate certificates, or the
        // filename was not supplied (WinVerifyTrust requires a
        // filename, even if an opened handle to is also supplied).
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    if ( !ARGUMENT_PRESENT(pFoundLevel) ) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));



    //
    // Prepare the input data structure that WinVerifyTrust expects.
    //
    RtlZeroMemory(&wvtData, sizeof(WINTRUST_DATA));
    wvtData.cbStruct = sizeof(WINTRUST_DATA);
    if ((wvtData.dwUIChoice = dwUIChoice) == 0) {
        // If the UI choice element was left zero, then assume all UI.
        wvtData.dwUIChoice = WTD_UI_ALL;
    }
    wvtData.dwProvFlags = WTD_SAFER_FLAG;        // our magic flag.
    wvtData.dwUnionChoice = WTD_CHOICE_FILE;
    wvtData.pFile = &wvtFileInfo;


    //
    // Prepare the input file data structure used by WinVerifyTrust.
    //
    RtlZeroMemory(&wvtFileInfo, sizeof(WINTRUST_FILE_INFO));
    wvtFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
    wvtFileInfo.hFile = pIdentStruct->hFileHandle;
    wvtFileInfo.pcwszFilePath = pIdentStruct->UnicodeFullyQualfiedLongFileName.Buffer;


    //
    // Save the global state number.
    //

    LocalHandleSequenceNumber = g_dwLevelHandleSequence;

    //
    // Leave the critical section to prevent deadlock with the LoaderLock.
    //

    RtlLeaveCriticalSection(&g_TableCritSec);

    //
    // Actually call WinVerifyTrust and save off the return code
    // and last error code.
    //
    lStatus = WinVerifyTrust(
                pIdentStruct->CodeProps->hWndParent,  // hwnd
                &wvtFileActionID,
                &wvtData
                );

    dwLastError = GetLastError();

    *dwExtendedError = dwLastError;

    //
    // Reacquire the lock and check global state.
    //

    RtlEnterCriticalSection(&g_TableCritSec);


    //
    // Check the global state and make sure that the tables were not reloaded 
    // when we were not looking.
    //

    if (LocalHandleSequenceNumber != g_dwLevelHandleSequence) {

        ASSERT(FALSE);

        Status = STATUS_INTERNAL_ERROR;
        goto ExitHandler;
    }

    //
    // Process the WinVerifyTrust errors per PhilH
    //
    
    pLevelRecord = NULL;


    if (S_OK == lStatus && TRUST_E_SUBJECT_NOT_TRUSTED != dwLastError) {
	
        //
        // The file is signed. The publisher or hash is explicitly trusted
        //

        pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, SAFER_LEVELID_FULLYTRUSTED);

    } else if (TRUST_E_EXPLICIT_DISTRUST == lStatus || TRUST_E_SUBJECT_NOT_TRUSTED == lStatus) {
	
        //
        // The publisher is revoked or explicitly untrusted. Alternatively, the hash is
        // explicitly untrusted.
        //
        
        pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, SAFER_LEVELID_DISALLOWED);

    } else {

        //
        // we won't be too conservative in any of the following cases. 
        // No explicit trust or untrust. Continue on to other SAFER checks.
        //

        // TRUST_E_NOSIGNATURE == lStatus	
        // The file isn't signed. Alternatively for TRUST_E_BAD_DIGEST == dwLastError,
        // a signed file has been modified.


        // CRYPT_E_SECURITY_SETTINGS == lStatus	
        // For authenticode downloads, the admin has disabled user UI and trust.	

	
        // any other combination of lStatus and dwLastError
        // The file is signed. WVT has already called safer to check the hash rules.

	
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;

    }
    
    if (!pLevelRecord) {
        Status = STATUS_ACCESS_DENIED;
    } else {
        *pFoundLevel = pLevelRecord;
        Status = STATUS_SUCCESS;
    }

ExitHandler:
    return Status;
}



BOOL WINAPI
SaferiSearchMatchingHashRules(
        IN ALG_ID       HashAlgorithm OPTIONAL,
        IN PBYTE        pHashBytes,
        IN DWORD        dwHashSize,
        IN DWORD        dwOriginalImageSize OPTIONAL,
        OUT PDWORD      pdwFoundLevel,
        OUT PDWORD      pdwSaferFlags
        )
/*++

Routine Description:

    This is a private function that is exported for WinVerifyTrust
    to call to determine if a given hash has a WinSafer policy
    associated with it.

    Because this is a private function that is directly called by
    outside code, there is extra work needed to enter the critical
    section, reload the policy if needed, and set the value returned
    by GetLastError.

Arguments:

    HashAlgorithm - specifies the algorithm in which the hash
        was computed (CALG_MD5, CALG_SHA, etc).

    pHashBytes - pointer to a buffer containing the pre-computed
        hash value of the file's contents.

    dwHashSize - length indicating the size of the hash value that
        is referenced by the pHashBytes argument.  For example,
        a 128-bit MD5 hash should have a dwHashSize length of 16.

    dwOriginalImageSize - Specifies the size of the original file's
        contents that are being hashed.  This value is used as a
        heuristic to minimize the number of comparisons that must
        be done to identify a match.  If this parameter is 0, then
        this heuristic will not be used.

    pdwFoundLevel - pointer that receives a DWORD indicating the
        WinSafer LevelId that is found.  This value is only written
        when TRUE is returned.

    pdwSaferFlags - pointer that receives a DWORD value containing flags
        that control the supression of User-Interface dialogs.
        This value is only written when TRUE is returned.

Return Value:

    Returns TRUE if a WinSafer Level has been found, or FALSE if not.
    If FALSE is returned, GetLastError() may be used to find out
    specifics about why no match was found (possibly argument errors).

--*/
{
    NTSTATUS Status;
    PVOID RestartKey;
    PAUTHZIDENTSTABLERECORD pAuthzIdentRecord;

    DWORD dwBestLevelId;
    DWORD dwBestSaferFlags;
    BOOLEAN bFirstPass;


    //
    // Verify that our input arguments all make sense.
    //
    if (!ARGUMENT_PRESENT(pHashBytes) ||
        dwHashSize < 1) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(pdwFoundLevel) ||
        !ARGUMENT_PRESENT(pdwSaferFlags)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }


    //
    // Enter the critical section and reload the tables if needed.
    // Notice that a potential reload is needed here because this
    // function is externally called directly.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }


    //
    // Enumerate through all hash subkey GUIDs.
    //
    bFirstPass = TRUE;
    RestartKey = NULL;
    for (pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
         pAuthzIdentRecord != NULL;
         pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey)
         )
    {
        if (pAuthzIdentRecord->dwIdentityType == SaferIdentityTypeImageHash)
        {
            //
            // Ensure that the hash algorithm is the same type between
            // what we were supplied and what we are matching against.
            //
            if (HashAlgorithm != 0 &&
                pAuthzIdentRecord->ImageHashInfo.HashAlgorithm !=
                        HashAlgorithm) {
                continue;
            }


            //
            // If the actual filesize does not match the filesize stored
            // with the hash identity then there is no need to perform
            // any comparisons involving the hash.
            //
            if ( dwOriginalImageSize != 0 && dwOriginalImageSize !=
                pAuthzIdentRecord->ImageHashInfo.ImageSize.QuadPart ) {
                continue;
            }

            //
            // If the hash doesn't match at all, then go onto the next one.
            //
            if ( dwHashSize != pAuthzIdentRecord->ImageHashInfo.HashSize ||
                !RtlEqualMemory(
                    &pAuthzIdentRecord->ImageHashInfo.ImageHash[0],
                    &pHashBytes[0], dwHashSize))
            {
                continue;
            }


            //
            // Evaluate if this identity matches better than whatever
            // best path identity that we previously had, and keep it if so.
            //
            if ( bFirstPass ||
                        // we didn't have anything before.
                pAuthzIdentRecord->dwLevelId < dwBestLevelId
                        // or specifies a less-privileged level.
                )
            {
                dwBestLevelId = pAuthzIdentRecord->dwLevelId;
                dwBestSaferFlags = pAuthzIdentRecord->ImageHashInfo.dwSaferFlags;
                bFirstPass = FALSE;
            }
        }
    }


    //
    // If we have identified a matching WinSafer Level then
    // pass it back and return success.
    //
    if (bFirstPass) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }
    *pdwFoundLevel = dwBestLevelId;
    *pdwSaferFlags = dwBestSaferFlags;

    Status = STATUS_SUCCESS;

ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    if (NT_SUCCESS(Status)) {
        return TRUE;
    } else {
        BaseSetLastNTError(Status);
        return FALSE;
    }
}



NTSTATUS NTAPI
__CodeAuthzpCheckIdentityHashRules(
        IN OUT PLOCALIDENTITYCONTEXT    pIdentStruct,
        OUT PAUTHZLEVELTABLERECORD     *pFoundLevel,
        OUT PAUTHZIDENTSTABLERECORD    *pFoundIdentity
        )
/*++

Routine Description:

    Assumes that the global table lock has already been acquired.

Arguments:

    pIdentStruct -

    pFoundLevel - receives a pointer to the authorization Level record
        indicated by the best matching rule.

    pFoundIdentity - receives a pointer to the identifier entry rule
        that best matched.

Return Value:

    Returns STATUS_SUCCESS if a WinSafer Level has been found,
    or STATUS_NOT_FOUND if not.  Otherwise an error code.

--*/
{
    NTSTATUS Status;
    PVOID RestartKey;
    PAUTHZIDENTSTABLERECORD pAuthzIdentRecord, pBestIdentRecord;
    PAUTHZLEVELTABLERECORD pAuthzLevelRecord;
    DWORD dwBestLevelId;
    BOOLEAN bFirstPass;


    //
    // Verify that our input arguments all make sense.
    //
    if (!ARGUMENT_PRESENT(pIdentStruct) ||
        pIdentStruct->CodeProps == NULL ) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if ((pIdentStruct->dwCheckFlags & SAFER_CRITERIA_IMAGEHASH) == 0 ||
        RtlIsGenericTableEmpty(&g_CodeIdentitiesTable)) {
        // We're not supposed to evaluate hashes.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    if ( !ARGUMENT_PRESENT(pFoundLevel) ||
         !ARGUMENT_PRESENT(pFoundIdentity) ) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));



    //
    // Enumerate through all hash subkey GUIDs.
    //
    bFirstPass = TRUE;
    RestartKey = NULL;
    for (pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
         pAuthzIdentRecord != NULL;
         pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey)
         )
    {
        if (pAuthzIdentRecord->dwIdentityType == SaferIdentityTypeImageHash)
        {
            HRESULT hr = S_OK;

            //
            // If the user already supplied the pre-computed hash to us,
            // but not the file size, then assume that we do not need
            // to consider the file size when making a comparison.
            //
            if (pIdentStruct->bHaveHash) {
                goto HashComputed;
            }

            //
            // Get the signed hash for the file. If this fails then compute the
            // MD5 hash.
            //

            if ((pIdentStruct->dwCheckFlags & SAFER_CRITERIA_NOSIGNEDHASH) == 0) {


                //
                // Leave the critical section to prevent deadlock with the LoaderLock.
                //

                RtlLeaveCriticalSection(&g_TableCritSec);


                hr = WTHelperGetFileHash(
                         pIdentStruct->UnicodeFullyQualfiedLongFileName.Buffer,
                         0,
                         NULL,
                         &pIdentStruct->FinalHash[0],
                         &pIdentStruct->FinalHashSize,
                         &pIdentStruct->FinalHashAlgorithm);


                //
                // Reacquire the lock and check global state.
                // Since this is the first thing that we do, it is ok to reacquire
                // the lock safely.
                //

                RtlEnterCriticalSection(&g_TableCritSec);

                if (SUCCEEDED(hr)) {
                    pIdentStruct->bHaveHash = TRUE;
                    goto HashComputed;
                }
            }

            //
            // If the actual filesize does not match the filesize stored
            // with the hash identity then there is no need to perform
            // any comparisons involving the hash.
            //
            if ( pIdentStruct->ImageSize.QuadPart == 0 )
            {
                // If we don't have the ImageSize yet, then try to
                // open the file and memory map it to find the size.
                Status = __CodeAuthzpEnsureMapped(pIdentStruct);
                if (!NT_SUCCESS(Status)) {
                    // If we failed to compute the MD5 sum of this, then that is
                    // actually rather bad, but we'll proceed to evaluate any
                    // non-MD5 identity rules, since ignoring them could be worse.
                    pIdentStruct->dwCheckFlags &= ~SAFER_CRITERIA_IMAGEHASH;
                    goto ExitHandler;
                }
                ASSERTMSG("EnsureMapped failed but did not return error",
                          pIdentStruct->pImageMemory != NULL &&
                            pIdentStruct->ImageSize.QuadPart != 0);
            }

            if ( pAuthzIdentRecord->ImageHashInfo.ImageSize.QuadPart !=
                    pIdentStruct->ImageSize.QuadPart) {
                continue;
            }


            //
            // Dynamically compute the MD5 hash of the item if needed.
            //
            if (!pIdentStruct->bHaveHash)
            {
                // Otherwise hash was not supplied, so we must compute it now.
                // Open the file and memory map it.
                Status = __CodeAuthzpEnsureMapped(pIdentStruct);
                if (!NT_SUCCESS(Status)) {
                    // If we failed to compute the MD5 sum of this, then
                    // that is actually rather bad, but we'll proceed to
                    // evaluate any non-MD5 identity rules, since ignoring
                    // them could be worse.
                    pIdentStruct->dwCheckFlags &= ~SAFER_CRITERIA_IMAGEHASH;
                    goto ExitHandler;
                }
                ASSERTMSG("EnsureMapped failed but did not return error",
                          pIdentStruct->pImageMemory != NULL &&
                        pIdentStruct->ImageSize.QuadPart != 0);



                // We now have a MD5 hash to use.
                pIdentStruct->FinalHashSize =
                    sizeof(pIdentStruct->FinalHash);
                Status = CodeAuthzpComputeImageHash(
                            pIdentStruct->pImageMemory,
                            pIdentStruct->ImageSize.LowPart,
                            &pIdentStruct->FinalHash[0],
                            &pIdentStruct->FinalHashSize,
                            &pIdentStruct->FinalHashAlgorithm);
                if (!NT_SUCCESS(Status)) {
                    goto ExitHandler;
                }
                pIdentStruct->bHaveHash = TRUE;
            }

    HashComputed:

            //
            // Ensure that the hash algorithm is the same type between
            // what we were supplied and what we are matching against.
            //
            if ( pIdentStruct->FinalHashAlgorithm != 0 &&
                pAuthzIdentRecord->ImageHashInfo.HashAlgorithm !=
                        pIdentStruct->FinalHashAlgorithm) {
                continue;
            }


            //
            // If the hash doesn't match at all, then go onto the next one.
            //
            if ( pIdentStruct->FinalHashSize !=
                        pAuthzIdentRecord->ImageHashInfo.HashSize ||
                !RtlEqualMemory(
                    &pIdentStruct->FinalHash[0],
                    &pAuthzIdentRecord->ImageHashInfo.ImageHash[0],
                    pIdentStruct->FinalHashSize))
            {
                continue;
            }


            //
            // Evaluate if this identity matches better than whatever
            // best path identity that we previously had, and keep it if so.
            //
            if ( bFirstPass ||
                        // we didn't have anything before.
                pAuthzIdentRecord->dwLevelId < dwBestLevelId
                        // same scope, but specifies a less-privileged level.
                )
            {
                pBestIdentRecord = pAuthzIdentRecord;
                dwBestLevelId = pAuthzIdentRecord->dwLevelId;
                bFirstPass = FALSE;
            }
        }
    }


    //
    // If we have identified a matching WinSafer Level then
    // look up the Level record for it and return success.
    //
    if (bFirstPass) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    pAuthzLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, dwBestLevelId);
    if (!pAuthzLevelRecord) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    *pFoundLevel = pAuthzLevelRecord;
    *pFoundIdentity = pBestIdentRecord;

    Status = STATUS_SUCCESS;

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
__CodeAuthzpCheckIdentityUrlZoneRules(
        IN OUT PLOCALIDENTITYCONTEXT    pIdentStruct,
        OUT PAUTHZLEVELTABLERECORD     *pFoundLevel,
        OUT PAUTHZIDENTSTABLERECORD    *pFoundIdentity
        )
/*++

Routine Description:

Arguments:

    pIdentStruct -

    pFoundLevel - receives a pointer to the authorization Level record
        indicated by the best matching rule.

    pFoundIdentity - receives a pointer to the identifier entry rule
        that best matched.

Return Value:

    Returns STATUS_SUCCESS if a WinSafer Level has been found,
    or STATUS_NOT_FOUND if not.  Otherwise an error code.

--*/
{
    NTSTATUS Status;
    PVOID RestartKey;
    PAUTHZIDENTSTABLERECORD pAuthzIdentRecord, pBestIdentRecord;
    PAUTHZLEVELTABLERECORD pAuthzLevelRecord;
    DWORD dwBestLevelId;
    BOOLEAN bFirstPass;


    //
    // Verify that our input arguments all make sense.
    //
    if (!ARGUMENT_PRESENT(pIdentStruct) ||
        pIdentStruct->CodeProps == NULL) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if ((pIdentStruct->dwCheckFlags & SAFER_CRITERIA_URLZONE) == 0 ||
        RtlIsGenericTableEmpty(&g_CodeIdentitiesTable)) {
        // We're not supposed to evaluate zones.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(pFoundLevel) ||
        !ARGUMENT_PRESENT(pFoundIdentity) ) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));


    //
    // Enumerate through all UrlZone subkey GUIDs.
    //
    RestartKey = NULL;
    bFirstPass = TRUE;
    for (pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey);
         pAuthzIdentRecord != NULL;
         pAuthzIdentRecord = (PAUTHZIDENTSTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeIdentitiesTable, &RestartKey)
         )
    {
        if (pAuthzIdentRecord->dwIdentityType ==
                SaferIdentityTypeUrlZone)
        {
            //
            // Compare the identity with what was supplied to us.
            //
            if (pAuthzIdentRecord->ImageZone.UrlZoneId !=
                    pIdentStruct->CodeProps->UrlZoneId) {
                // this zone does not match, so ignore it.
                continue;
            }


            //
            // Evaluate if this path identity matches better than whatever
            // best path identity that we previously had, and keep it if so.
            //
            if (bFirstPass ||
                        // we didn't have anything better before.
                pAuthzIdentRecord->dwLevelId < dwBestLevelId)
                        // this also matches, but specifies a less-privileged level.
            {
                pBestIdentRecord = pAuthzIdentRecord;
                dwBestLevelId = pAuthzIdentRecord->dwLevelId;
                bFirstPass = FALSE;
            }
        }
    }


    //
    // If we have identified a matching WinSafer Level then
    // look up the Level record for it and return success.
    //
    if (bFirstPass) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    pAuthzLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, dwBestLevelId);
    if (!pAuthzLevelRecord) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }
    *pFoundLevel = pAuthzLevelRecord;
    *pFoundIdentity = pBestIdentRecord;

    Status = STATUS_SUCCESS;

ExitHandler:
    return Status;
}



NTSTATUS NTAPI
__CodeAuthzpIdentifyOneCodeAuthzLevel(
        IN PSAFER_CODE_PROPERTIES       pCodeProperties OPTIONAL,
        OUT DWORD                      *dwExtendedError,
        OUT PAUTHZLEVELTABLERECORD     *pBestLevelRecord,
        OUT GUID                       *pBestIdentGuid
        )
/*++

Routine Description:

    Performs the code identification process.
    Assumes that the caller has already locked the global critsec.

Arguments:

    pCodeProperties - pointer the single CODE_PROPERTIESW structure
            that should be analyzed and evaluated.  This parameter
            may be specified as NULL to indicate that there are
            no specific properties that should be evaluated and that
            only the configured Default Level should be used.

    dwExtendedError - In case of certificate rule match, return the extended
            error from WinVerifyTrust.
            
    pBestLevelRecord - returns the matching WinSafer Level record.
            The value written to this parameter should only be
            considered valid when STATUS_SUCCESS is also returned.

    pBestIdentGuid - returns the matching Code Identity guid from
            which the resulting WinSafer Level was determined.
            The value written to this parameter should only be
            considered valid when STATUS_SUCCESS is also returned.

            This GUID may also be SAFER_GUID_RESULT_TRUSTED_CERT or
            SAFER_GUID_RESULT_DEFAULT_LEVEL to indicate that the result
            was from a publisher cert or a default rule match.
            Note that a cert hash match will also

Return Value:

    Returns STATUS_SUCCESS if a WinSafer Level has been found,
    or STATUS_NOT_FOUND or another error code if not.

--*/
{
    NTSTATUS Status;
    LOCALIDENTITYCONTEXT identStruct = {0};

    //
    // Verify our input state and perform any explicit
    // policy loading, if it hasn't been loaded yet.
    //
    if (!ARGUMENT_PRESENT(pBestLevelRecord) ||
        !ARGUMENT_PRESENT(pBestIdentGuid)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));


    //
    // Star the identification process.  If no code properties were
    // supplied to us, then we can immediately skip to only
    // considering the default WinSafer Level configurations.
    //
    if (ARGUMENT_PRESENT(pCodeProperties))
    {
        BOOLEAN bRetryCertRuleCheck = FALSE;
        BOOLEAN bPathIsNtNamespace;

        // Current best identity match.
        PAUTHZLEVELTABLERECORD pAuthzLevelRecord = NULL;
        PAUTHZIDENTSTABLERECORD pAuthzIdentRecord;

        // Temporary evaluation identity match.
        BOOL bExactPath;
        PAUTHZLEVELTABLERECORD pTempLevelRecord;
        PAUTHZIDENTSTABLERECORD pTempIdentRecord;


        //
        // Check that the CODE_PROPERTIES structure is the right size.
        //
        if (pCodeProperties->cbSize != sizeof(SAFER_CODE_PROPERTIES)) {
            Status = STATUS_INFO_LENGTH_MISMATCH;
            goto ExitHandler;
        }


        //
        // Initialize the structure that we use to store our
        // stateful information during policy evaluation.
        // We don't copy everything from the CODE_PROPERTIES
        // structure into the identStruct, since some of it
        // is dynamically loaded/copied within "EnsureMapped".
        //
        RtlZeroMemory(&identStruct, sizeof(LOCALIDENTITYCONTEXT));
        identStruct.CodeProps = pCodeProperties;
        identStruct.dwCheckFlags = pCodeProperties->dwCheckFlags;
        identStruct.ImageSize.QuadPart =
            pCodeProperties->ImageSize.QuadPart;
        if (identStruct.ImageSize.QuadPart != 0 &&
            pCodeProperties->dwImageHashSize > 0 &&
            pCodeProperties->dwImageHashSize <= SAFER_MAX_HASH_SIZE)
        {
            // The image hash and filesize were both supplied, therefore
            // we have a valid hash and don't need to compute it ourself.
            RtlCopyMemory(&identStruct.FinalHash[0],
                          &pCodeProperties->ImageHash[0],
                          pCodeProperties->dwImageHashSize);
            identStruct.FinalHashSize = pCodeProperties->dwImageHashSize;
            identStruct.bHaveHash = TRUE;
        }
        bPathIsNtNamespace = ((identStruct.dwCheckFlags &
                SAFER_CRITERIA_IMAGEPATH_NT) != 0 ? TRUE : FALSE);


        //
        // Copy over the file handle into the context structure, if a
        // handle was supplied, otherwise try to open the filepath.
        //
        if (pCodeProperties->hImageFileHandle != NULL &&
            pCodeProperties->hImageFileHandle != INVALID_HANDLE_VALUE)
        {
            identStruct.hFileHandle = pCodeProperties->hImageFileHandle;
            identStruct.bCloseFileHandle = FALSE;
        }
        else if (pCodeProperties->ImagePath != NULL)
        {
            HANDLE hFile;

            if (bPathIsNtNamespace) {
                UNICODE_STRING UnicodeFilename;
                IO_STATUS_BLOCK IoStatusBlock;
                OBJECT_ATTRIBUTES ObjectAttributes;

                RtlInitUnicodeString(&UnicodeFilename, pCodeProperties->ImagePath);
                InitializeObjectAttributes(
                        &ObjectAttributes, &UnicodeFilename,
                        OBJ_CASE_INSENSITIVE, NULL, NULL);
                Status = NtOpenFile(&hFile, FILE_GENERIC_READ, &ObjectAttributes,
                                    &IoStatusBlock, FILE_SHARE_READ, FILE_NON_DIRECTORY_FILE);

                if (!NT_SUCCESS(Status)) {
                    hFile = NULL;
                }
            } else {
                hFile = CreateFileW(
                                pCodeProperties->ImagePath,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
            }

            if (hFile != NULL && hFile != INVALID_HANDLE_VALUE) {
                identStruct.hFileHandle = hFile;
                identStruct.bCloseFileHandle = TRUE;
            }
        }


        //
        // Reconstruct the fully qualified pathname from the handle
        // or from the supplied filename.
        //
        Status = CodeAuthzFullyQualifyFilename(
                        identStruct.hFileHandle,
                        bPathIsNtNamespace,
                        pCodeProperties->ImagePath,
                        &identStruct.UnicodeFullyQualfiedLongFileName);
        if (!NT_SUCCESS(Status) &&
            pCodeProperties->ImagePath != NULL &&
            !bPathIsNtNamespace)
        {
            // Otherwise just live with what was passed in to us.
            // If allocation fails, then path criteria will just be ignored.
            Status = RtlCreateUnicodeString(
                    &identStruct.UnicodeFullyQualfiedLongFileName,
                    pCodeProperties->ImagePath);
        }


        //
        // Perform the WinVerifyTrust sequence to see if the signing
        // certificate matches any of the publishers that are in the
        // trusted or distrusted publisher stores.  This also has the
        // additional effect of checking the "signed hashes".
        //
        Status = __CodeAuthzpCheckIdentityCertificateRules(
                                        &identStruct,
                                        dwExtendedError,
                                        &pAuthzLevelRecord,
                                        WTD_UI_NONE);
        if (NT_SUCCESS(Status)) {
            // An exact publisher was found, so return immediately.
            ASSERT(pAuthzLevelRecord != NULL);
            *pBestLevelRecord = pAuthzLevelRecord;
            RtlCopyMemory(pBestIdentGuid,
                          &guidTrustedCert, sizeof(GUID));
            goto ExitHandler2;
        } else if (Status != STATUS_NOT_FOUND) {
              goto ExitHandler2;
        }


        //
        // Search hash rules defined for this level/scope.
        // Note that hashes match exactly or not at all,
        // so if we get a positive match, then that level
        // is absolutely returned.
        //
        Status = __CodeAuthzpCheckIdentityHashRules(
                        &identStruct,
                        &pAuthzLevelRecord,
                        &pAuthzIdentRecord);
        if (NT_SUCCESS(Status)) {
            // An exact hash identity was found, so return immediately.
            ASSERT(pAuthzLevelRecord != NULL);
            *pBestLevelRecord = pAuthzLevelRecord;
            RtlCopyMemory(pBestIdentGuid,
                          &pAuthzIdentRecord->IdentGuid, sizeof(GUID));
            goto ExitHandler2;
        } else if (Status != STATUS_NOT_FOUND) {
              goto ExitHandler2;
        }
        ASSERT(pAuthzLevelRecord == NULL);


        //
        // Search file path rules defined for this level/scope.
        // Note that file paths can either be an exact match
        // or a partial match.  If we find an exact match, then
        // it should be absolutely returned.  Otherwise the
        // path was a "grouping match" and we must compare the
        // Level with all of the remaining "grouping checks".
        //
        Status = __CodeAuthzpCheckIdentityPathRules(
                        &identStruct,
                        &pAuthzLevelRecord,
                        &bExactPath,
                        &pAuthzIdentRecord);
        if (NT_SUCCESS(Status)) {
            ASSERT(pAuthzLevelRecord != NULL);
            pTempLevelRecord = pAuthzLevelRecord;
            pTempIdentRecord = pAuthzIdentRecord;
            if (bExactPath) {
                *pBestLevelRecord = pTempLevelRecord;
                RtlCopyMemory(pBestIdentGuid,
                        &pTempIdentRecord->IdentGuid, sizeof(GUID));
                goto ExitHandler2;
            }
        } else if (Status != STATUS_NOT_FOUND) {
              goto ExitHandler2;
        }


        //
        // Search URL Zone identity rules.
        // Note that zones are always "grouping matches",
        // so they must be compared against all of the remaining
        // "grouping checks".
        //
        Status = __CodeAuthzpCheckIdentityUrlZoneRules(
                        &identStruct,
                        &pTempLevelRecord,
                        &pTempIdentRecord);
        if (NT_SUCCESS(Status)) {
            ASSERT(pTempLevelRecord != NULL);
            if (pAuthzLevelRecord == NULL ||
                pTempLevelRecord->dwLevelId <
                    pAuthzLevelRecord->dwLevelId)
            {
                pAuthzLevelRecord = pTempLevelRecord;
                pAuthzIdentRecord = pTempIdentRecord;
            }
        } else if (Status != STATUS_NOT_FOUND) {
              goto ExitHandler2;
        }

#ifdef SAFER_PROMPT_USER_FOR_DECISION_MAKING

#error "Prompting user in WinVerifyTrust"

        //
        // We were originally passed UI flag, but we supressed
        // the UI display the first time.  Call WinVerifyTrust
        // again and see if user choice would allow code to run.
        //
        if (bRetryCertRuleCheck)
        {
            if (pAuthzLevelRecord != NULL) {
                //If we have a rule match and the rule match is FULLYTRUSTED skip retry.
                if (pAuthzLevelRecord->dwLevelId == SAFER_LEVELID_FULLYTRUSTED) {
                    bRetryCertRuleCheck = FALSE;
                }
            } else if (g_DefaultCodeLevel != NULL) {
                //No rule match so far.  Check default level.
                //If default level is FULLY_TRUSTED skip retry
                if (g_DefaultCodeLevel->dwLevelId == SAFER_LEVELID_FULLYTRUSTED) {
                    bRetryCertRuleCheck = FALSE;
                }
            }

            //
            // Perform the WinVerifyTrust sequence again to see if the signing
            // certificate matches any of the publishers that are in the
            // trusted or distrusted publisher stores.
            //
            if (bRetryCertRuleCheck) {
                Status = __CodeAuthzpCheckIdentityCertificateRules(
                                    &identStruct,
                                    &pTempLevelRecord,
                                    identStruct.CodeProps->dwWVTUIChoice);
                if (NT_SUCCESS(Status)) {
                    // User clicked Yes or No.  Run it as such.
                    ASSERT(pTempLevelRecord != NULL);
                    *pBestLevelRecord = pTempLevelRecord;
                    RtlCopyMemory(pBestIdentGuid,
                                  &guidTrustedCert, sizeof(GUID));
                    goto ExitHandler2;
                }
            }
        }
#endif

        //
        // If we found any Level matches at this point, then we
        // should simply return that match.  The identified Level
        // will be the MIN() of all "grouping matches" found.
        //
        if (pAuthzLevelRecord != NULL) {
            Status = STATUS_SUCCESS;
            *pBestLevelRecord = pAuthzLevelRecord;
            ASSERT(pAuthzIdentRecord != NULL);
            RtlCopyMemory(pBestIdentGuid,
                          &pAuthzIdentRecord->IdentGuid, sizeof(GUID));
            goto ExitHandler2;
        }
    }


    //
    // Now we need to consider the default WinSafer Level and
    // return it if one was defined.  If there was no default
    // defined, then we should simply return STATUS_NOT_FOUND.
    //
    if (g_DefaultCodeLevel != NULL) {
        *pBestLevelRecord = g_DefaultCodeLevel;
        RtlCopyMemory(pBestIdentGuid, &guidDefaultRule, sizeof(GUID));
        Status = STATUS_SUCCESS;
        goto ExitHandler2;
    }
    Status = STATUS_NOT_FOUND;


ExitHandler2:
    __CodeAuthzpEnsureUnmapped(&identStruct);
    if (identStruct.UnicodeFullyQualfiedLongFileName.Buffer != NULL) {
        RtlFreeUnicodeString(&identStruct.UnicodeFullyQualfiedLongFileName);
    }
    if (identStruct.bCloseFileHandle && identStruct.hFileHandle != NULL) {
        NtClose(identStruct.hFileHandle);
    }

ExitHandler:
    return Status;
}


BOOL
SaferpSkipPolicyForAdmins(VOID)

/*++

Routine Description:

    Decides whether or not Safer policy should be skipped.
    Policy is skipped if
        1. The caller is an Admin AND
        2. The registry key specifies that the policy should be skipped
           for Admins.
           
Arguments:

Return Value:

    Returns TRUE if a policy should be skipped for admins.
    Returns FALSE otherwise or in case of any intermediate errors.

--*/

{
    static BOOL gSaferSkipPolicy = 2;
    BOOL bIsAdmin = FALSE;
    DWORD AdminSid[] = {0x201, 0x5000000, 0x20, 0x220};
    NTSTATUS Status = STATUS_SUCCESS;

    // If we have already evaluated policy once, return the cached value.
    if (2 != gSaferSkipPolicy)
    {
        return gSaferSkipPolicy;
    }

    // Set the default to "will not skip policy"
    gSaferSkipPolicy = 0;

    // Check if the caller is an admin.
    if (CheckTokenMembership(NULL, (PSID) AdminSid, &bIsAdmin))
    {
        // The caller is an Admin. Let's check whether the regkey says it's ok
        // to skip the policy for admins.
        if (bIsAdmin)
        {
            const static UNICODE_STRING SaferUnicodeKeyName = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers");
            const static OBJECT_ATTRIBUTES SaferObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&SaferUnicodeKeyName, OBJ_CASE_INSENSITIVE);
            const static UNICODE_STRING SaferPolicyScope = RTL_CONSTANT_STRING(SAFER_POLICY_SCOPE);

            HANDLE hKeyEnabled = NULL;
            BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
            DWORD dwActualSize = 0;

            // Open the CodeIdentifiers key.
            Status = NtOpenKey(
                         &hKeyEnabled, 
                         KEY_QUERY_VALUE,
                         (POBJECT_ATTRIBUTES) &SaferObjectAttributes
                         );

            if (NT_SUCCESS(Status)) {

                // Read the Policy Scope value.
                Status = NtQueryValueKey(
                             hKeyEnabled,
                             (PUNICODE_STRING) &SaferPolicyScope,
                             KeyValuePartialInformation,
                             pKeyValueInfo, 
                             sizeof(QueryBuffer), 
                             &dwActualSize
                             );

		        NtClose(hKeyEnabled);

                // Skip policy if the flag is set to 1.
                if (NT_SUCCESS(Status)) {
                    if ((pKeyValueInfo->Type == REG_DWORD) &&
                        (pKeyValueInfo->DataLength == sizeof(DWORD)) &&
                        (*((PDWORD) pKeyValueInfo->Data) & 0x1)) {
                        
                        gSaferSkipPolicy = 1;
                    }
                }		
            }
        }
    }

    return gSaferSkipPolicy;

}
   

VOID
SaferpLogResultsToFile(
    LPWSTR InputImageName,
    LPWSTR LevelName,
    LPWSTR RuleTypeName,
    GUID *Guid
    )

/*++

Routine Description:

    Logs a message to a file specified in 
    
    HKLM\Software\Policies\Microsoft\Windows\Safer\CodeIdentifiers LogFileName.
    
    The format of the message is:
        TLIST.EXE (PID = 1076) identified C:\SAFERTEST\TEST.VBS as FULLY TRUSTED
        using CERTIFICATE rul, Guid = {abcdef00-abcd-abcd-abcdefabcdef00}
           
Arguments:

Return Value:

--*/

{

#define SAFER_LOG_NAME1 L" (PID = "
#define SAFER_LOG_NAME2 L") identified "
#define SAFER_LOG_NAME3 L" as "
#define SAFER_LOG_NAME4 L" using "
#define SAFER_LOG_NAME5 L" rule, Guid = "

#define SAFER_INTEGER_LENGTH 20
#define SAFER_MAX_RULE_DESCRIPTION_LENGTH 12
#define SAFER_GUID_LENGTH 38

    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hFile = NULL;
    HANDLE hKey = NULL;
    ULONG ProcessNameLength = 0;
    PWCHAR Buffer = NULL;
    ULONG BasicInfoLength = 0;
    ULONG BytesWritten = 0;

    UCHAR TmpBuf[] = {0xFF, 0xFE};

    const static UNICODE_STRING SaferUnicodeKeyName = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers");
    const static OBJECT_ATTRIBUTES SaferObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&SaferUnicodeKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING SaferPolicyScope = RTL_CONSTANT_STRING(SAFER_LOGFILE_NAME);
    PROCESS_BASIC_INFORMATION ProcInfo = {0};
    ULONG TotalSize = sizeof(SAFER_LOG_NAME1) + 
                      sizeof(SAFER_LOG_NAME2) + 
                      sizeof(SAFER_LOG_NAME3) + 
                      sizeof(SAFER_LOG_NAME4) + 
                      sizeof(SAFER_LOG_NAME5) + 
                      ((SAFER_INTEGER_LENGTH + 
                        SAFER_MAX_RULE_DESCRIPTION_LENGTH + 
                        SAFER_GUID_LENGTH) * sizeof(WCHAR));

    UCHAR QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_PATH * sizeof(WCHAR)];
    PWCHAR ProcessImageName = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
    DWORD dwActualSize = 0;

    // Open the CodeIdentifiers key.
    Status = NtOpenKey(
                 &hKey, 
                 KEY_QUERY_VALUE,
                 (POBJECT_ATTRIBUTES) &SaferObjectAttributes
                 );

    if (!NT_SUCCESS(Status)) {
        return;
    }

    // Read the name of the file for logging.
    Status = NtQueryValueKey(
                 hKey,
                 (PUNICODE_STRING) &SaferPolicyScope,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );

    NtClose(hKey);

    // We do not care if the buffer size was too small to retrieve the logfile
    // name since this is for troubleshooting.
    if (!NT_SUCCESS(Status)) {
        return;
    }

    // This was not a string.
    if (pKeyValueInfo->Type != REG_SZ) {
        return;
    }       

    hFile = CreateFileW((LPCWSTR) pKeyValueInfo->Data, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return;
    }

    SetFilePointer (hFile, 0, NULL, FILE_BEGIN);

    WriteFile (hFile, (LPCVOID)TmpBuf, 2, &BytesWritten, NULL);

    SetFilePointer (hFile, 0, NULL, FILE_END);

    Status = NtQueryInformationProcess(NtCurrentProcess(), ProcessImageFileName, QueryBuffer, sizeof(QueryBuffer), &ProcessNameLength);

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    ProcessImageName = (PWCHAR) (QueryBuffer + ProcessNameLength - sizeof(WCHAR));
    ProcessNameLength = 1;
    while (((PUCHAR) ProcessImageName >= QueryBuffer) && (*(ProcessImageName - 1) != L'\\')) {
        ProcessImageName--;
        ProcessNameLength++;
    }

    TotalSize += (ProcessNameLength + (wcslen(InputImageName) + wcslen(LevelName)) * sizeof(WCHAR));

    Status = NtQueryInformationProcess(NtCurrentProcess(), ProcessBasicInformation, (PVOID) &ProcInfo, sizeof(PROCESS_BASIC_INFORMATION), &BasicInfoLength);

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Buffer = (PWCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, TotalSize);

    if (Buffer == NULL) {
        goto Cleanup;
    }

    swprintf(Buffer, L"%s%s%d%s%s%s%s%s%s%s{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n", 
             ProcessImageName,
             SAFER_LOG_NAME1,
             ProcInfo.UniqueProcessId,
             SAFER_LOG_NAME2,
             InputImageName,
             SAFER_LOG_NAME3,
             LevelName,
             SAFER_LOG_NAME4,
             RuleTypeName,
             SAFER_LOG_NAME5,
             Guid->Data1, Guid->Data2, Guid->Data3, Guid->Data4[0], Guid->Data4[1], Guid->Data4[2], Guid->Data4[3], Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]);

    ASSERT((wcslen(Buffer) + 1) * sizeof(WCHAR) < TotalSize);

    WriteFile (hFile, (LPCVOID)Buffer, (wcslen(Buffer) * sizeof(WCHAR)), &BytesWritten, NULL);

    RtlFreeHeap(RtlProcessHeap(), 0, Buffer);

Cleanup:
    CloseHandle(hFile);


}



#define USER_REGISTRY_EXT_MUTEX   TEXT("userenv: User Registry policy mutex")
#define MACH_REGISTRY_EXT_MUTEX   TEXT("Global\\userenv: Machine Registry policy mutex")


HANDLE 
SaferpEnterCriticalPolicySection(
    IN PWCHAR wszMutex, 
    IN DWORD dwTimeOut
    )

/*++

Routine Description:

    Acquires the machine/user mutex.

Arguments:

    wszMutex - Name of the mutex to acquire.

    dwTimeOut - Time for we will wait in case policy processing is going on.

Return Value:

    Returns the handle to the mutex. In case of errors, the return value in ZERO.

--*/
{
    HANDLE hSection;
    DWORD  dwRet;

    //
    // Open the mutex to wait on.
    //

    hSection = OpenMutex(SYNCHRONIZE, FALSE, wszMutex);

    if (!hSection) {
        return NULL;
    }

    //
    // Claim the mutex
    //

    dwRet = WaitForSingleObject(hSection, dwTimeOut);
    
    if ((dwRet == WAIT_FAILED) || (dwRet == WAIT_TIMEOUT)) {
        CloseHandle(hSection);
        return NULL;
    }

    return hSection;
}




BOOL
SaferpCheckKeyStamp(
    IN HKEY Key
    )
/*++

Routine Description:

    Compare the last write stamp on the CodeIdentifiers key vs the last time
    we loaded Safer policy.

Arguments:

    Key - Handle to HKLM or HKCU.

Return Value:

    Returns TRUE if policy needs to be reloaded.

--*/
{
#define SAFERP_KEY_NAME L"Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers"

    NTSTATUS Status;
    HKEY SubKey = NULL;
    DWORD SizeIgnore = 0;
    WCHAR Buffer[MAX_PATH];
    PKEY_BASIC_INFORMATION KeyInfo = (PKEY_BASIC_INFORMATION) Buffer;

    //
    // Open the CodeIdentifiers key.
    //

    DWORD dwErr = RegOpenKeyW(Key, SAFERP_KEY_NAME, &SubKey);

    if (dwErr != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // Query the key for basic information.
    //

    Status = NtQueryKey(SubKey, KeyBasicInformation, KeyInfo, sizeof(Buffer), &SizeIgnore);
    CloseHandle(SubKey);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // Compare the timestmaps.
    //

    if (-1 == CompareFileTime((FILETIME *) &g_SaferPolicyTimeStamp, (FILETIME *) &KeyInfo->LastWriteTime)) {
        return TRUE;
    }

    return FALSE;
}

NTSTATUS
SaferpGrabGroupPolicyLocks(
    OUT PHANDLE phMachine,
    OUT PHANDLE phUser
    )

/*++

Routine Description:

    Acquire both user and machine locks.

Arguments:
    phMachine - To return the handle to machine mutex.

    phUser - To return the handle to user mutex.

Return Value:

    Returns STATUS_SUCCESS if both mutexes have been acquired.

--*/

{
    //
    // Observe the locking order - machine first, then user.
    //

    *phMachine = SaferpEnterCriticalPolicySection(MACH_REGISTRY_EXT_MUTEX, 0); 

    if (*phMachine != NULL) {

        //
        // We got the machine lock. Now let's get the user lock.
        //

        *phUser = SaferpEnterCriticalPolicySection(USER_REGISTRY_EXT_MUTEX, 0); 

        if (*phUser != NULL) {
            return STATUS_SUCCESS;
        }

        // 
        // If we could not get the User lock, release the machine lock.
        //
            
        ReleaseMutex (*phMachine);
        CloseHandle (*phMachine);
        *phMachine = NULL;
    }

    return STATUS_ACCESS_DENIED;
}

VOID
SaferpReleaseGroupPolicyLocks(
    IN HANDLE hMachine,
    IN HANDLE hUser
    )
/*++

Routine Description:

    Release both user and machine locks.

Arguments:
    hMachine - Machine handle to release.

    hUser - User handle to release.

Return Value:
    None.

--*/

{
    if (hUser)
    {
        ReleaseMutex(hUser);
        CloseHandle(hUser);
    }

    if (hMachine)
    {
        ReleaseMutex(hMachine);
        CloseHandle(hMachine);
    }

}

NTSTATUS
SaferpReloadPolicyIfNeeded()

/*++

Routine Description:

    Reload Safer policy in case the time stamp on Safer keys is more recent than
    the last time we loaded policy.

Arguments:

    None.

Return Value:

    Returns STATUS_SUCCESS in case we fail to load the policy after we have decided
    to do so. No failure is returned if we encounter an error before that since 
    we already have a cached one.

--*/
{

    NTSTATUS Status;
    HANDLE hUser = NULL;
    HANDLE hMachine = NULL;

    //
    // Check if Machine policy has changed.
    //

    if (!SaferpCheckKeyStamp(HKEY_LOCAL_MACHINE))
    {
        //
        // Machine policy has not changed.
        // Check if User policy has changed.
        //

        if (!SaferpCheckKeyStamp(HKEY_CURRENT_USER))
        {
            //
            // Neither policy has changed. Just return.
            //

            return STATUS_SUCCESS;
        }
    }


    //
    // Check if it is ok to load policy.
    //

    Status = SaferpGrabGroupPolicyLocks(&hMachine, &hUser);

    if (!NT_SUCCESS(Status)) {

        //
        // Failure to grab the locks is ok here. We will just return.
        //

        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Release the current set of rules.
    //

    CodeAuthzGuidIdentsEntireTableFree(&g_CodeIdentitiesTable);
    CodeAuthzLevelObjpEntireTableFree(&g_CodeLevelObjTable);

    //
    // And reload the policy.
    //

    g_bNeedCacheReload = TRUE;

    Status = CodeAuthzpImmediateReloadCacheTables();

    if (!NT_SUCCESS(Status)) {
        ASSERT(FALSE);
    }

Cleanup:

    //
    // Leave the group policy locks.
    //

    SaferpReleaseGroupPolicyLocks(hMachine, hUser);


    return Status;

}

BOOL WINAPI
SaferIdentifyLevel(
        IN DWORD                dwNumProperties,
        IN PSAFER_CODE_PROPERTIES    pCodeProperties,
        OUT SAFER_LEVEL_HANDLE        *pLevelHandle,
        IN LPVOID               lpReserved
        )
/*++

Routine Description:

    Performs the code identification process.  Accepts an array of
    CODE_PROPERTIES structures that supply all of the identification
    criteria.  The final result is the least privileged match resulting
    from each element of the array.

Arguments:

    dwNumProperties - indicates the number of CODE_PROPERTIES structures
            pointed to by the CodeProperties argument.

    pCodeProperties - pointer to one or more structures that specify
            all of the input criteria that will be used to identify level.

    pLevelHandle - pointer that will receive the opened Level object
            handle when the identification operation is successful.

    lpReserved - unused, must be zero.

Return Value:

    Returns TRUE if a Level was identified and an opened handle
    to it stored in the 'LevelHandle' argument.  Otherwise this
    function returns FALSE on error and GetLastError() can be used
    to obtain additional information about the error.

--*/
{
    DWORD Index;
    NTSTATUS Status;
    BOOL ReturnValue = FALSE;
    PAUTHZLEVELTABLERECORD pBestLevelRecord;
    GUID BestIdentGuid;
    PWCHAR LocalLevelName = L"\"default\"";
    PWCHAR LocalRuleName = L"default";
    PWCHAR LocalImageName = L"Default";
    DWORD dwExtendedError = ERROR_SUCCESS;
    BOOL bCheckPolicyPropagation = TRUE;

    //
    // Validate the input parameters.
    //
    UNREFERENCED_PARAMETER(lpReserved);

    if (!ARGUMENT_PRESENT(pLevelHandle)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
        bCheckPolicyPropagation = FALSE;
    }
    if (RtlIsGenericTableEmpty(&g_CodeLevelObjTable)) {
        // There are no levels defined!  Should not happen.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }

    //
    // Do not allow filehandles unless filename is specified.
    //
    for (Index = 0; Index < dwNumProperties; Index++)
    {
        if (pCodeProperties[Index].hImageFileHandle != NULL &&
            pCodeProperties[Index].hImageFileHandle != INVALID_HANDLE_VALUE &&
            pCodeProperties[Index].ImagePath == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;               
            goto ExitHandler2;
        }
    }

    if (SaferpSkipPolicyForAdmins())
    {
        pBestLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, SAFER_LEVELID_FULLYTRUSTED);

        RtlCopyMemory(&BestIdentGuid, &guidDefaultRule, sizeof(GUID));
        goto GotMatchingRule;
    }


    if (!ARGUMENT_PRESENT(pCodeProperties) || dwNumProperties == 0) {
        // We were given no criteria to evaluate, so just return
        // the default level.  If there was no default defined,
        // then we should simply return STATUS_NOT_FOUND.
        if (g_DefaultCodeLevel != NULL) {
            pBestLevelRecord = g_DefaultCodeLevel;
            RtlCopyMemory(&BestIdentGuid, &guidDefaultRule, sizeof(GUID));
            goto GotMatchingRule;
        } else {
            Status = STATUS_NOT_FOUND;
            goto ExitHandler2;
        }
    }

    //
    // If we did not reload policy in this call, check if we need to.
    //

    if (bCheckPolicyPropagation) 
    {
        //
        // Make sure that we do not have any outstanding handles.
        //

        if (0 == g_dwNumHandlesAllocated)
        {
            //
            // Get the last time policy was propagated.
            //

            Status = SaferpReloadPolicyIfNeeded();

            if (!NT_SUCCESS(Status)) 
            {
                goto ExitHandler2;
            }
        }
    }

    //
    // Iterate through the list of CODE_PROPERTIES supplied
    // and determine the final code Level that should be used.
    //
    pBestLevelRecord = NULL;
    for (Index = 0; Index < dwNumProperties; Index++)
    {
        PAUTHZLEVELTABLERECORD pOneLevelRecord;
        GUID OneIdentGuid;

        Status = __CodeAuthzpIdentifyOneCodeAuthzLevel(
                        &pCodeProperties[Index],
                        &dwExtendedError,
                        &pOneLevelRecord,
                        &OneIdentGuid);
        if (NT_SUCCESS(Status)) {
            ASSERT(pOneLevelRecord != NULL);
            if (!pBestLevelRecord ||
                pOneLevelRecord->dwLevelId <
                    pBestLevelRecord->dwLevelId )
            {
                pBestLevelRecord = pOneLevelRecord;
                RtlCopyMemory(&BestIdentGuid, &OneIdentGuid, sizeof(GUID));
            }
        } else if (Status != STATUS_NOT_FOUND) {
            // An unexpected error occurred, so return that.
            goto ExitHandler2;
        }
    }
    if (pBestLevelRecord == NULL) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }



    //
    // Now we have the result so pass back a handle to the
    // identified WinSafer Level.
    // Allocate a handle to represent this level.
    //
GotMatchingRule:
    ASSERT(pBestLevelRecord != NULL);
    if (IsEqualGUID(&guidDefaultRule, &BestIdentGuid))
    {
        // The resulting level match came from the default rule.
        // Now we have to try to guess whether the default actually
        // came from the Machine or User scope.
        DWORD dwScopeId;

        if (g_hKeyCustomRoot != NULL) {
            dwScopeId = SAFER_SCOPEID_REGISTRY;
        } else if (g_DefaultCodeLevelUser != NULL &&
                g_DefaultCodeLevelUser->dwLevelId ==
                   pBestLevelRecord->dwLevelId) {
            dwScopeId = SAFER_SCOPEID_USER;
        } else {
            dwScopeId = SAFER_SCOPEID_MACHINE;
        }

        Status = CodeAuthzpCreateLevelHandleFromRecord(
                    pBestLevelRecord,   // pLevelRecord
                    dwScopeId,          // dwScopeId
                    0,                  // dwSaferFlags
                    dwExtendedError,
                    SaferIdentityDefault,
                    &BestIdentGuid,     // pIdentRecord
                    pLevelHandle        // pLevelHandle
                    );


    }
    else if (IsEqualGUID(&guidTrustedCert, &BestIdentGuid))
    {
        // Note that when the result is from a certificate, we have
        // no way of actually knowing whether the certificate was
        // defined within the Machine or User scope, so we'll just
        // arbitrarily pick the Machine scope for the handle to be
        // based out of.  Additionally, there are no SaferFlags
        // persisted for certificates so we just assume 0.
        Status = CodeAuthzpCreateLevelHandleFromRecord(
                    pBestLevelRecord,       // pLevelRecord
                    SAFER_SCOPEID_MACHINE,   // dwScopeId
                    0,                      // dwSaferFlags
                    dwExtendedError,
                    SaferIdentityTypeCertificate,
                    &BestIdentGuid,         // pIdentRecord
                    pLevelHandle            // pLevelHandle
                    );

        LocalRuleName = L"certificate";
    }
    else
    {
        // Otherwise the result must have come from a path, hash,
        // or zone rule, so we must look up the resulting GUID in our
        // identity table and retrieve the SaferFlags that were stored
        // along with that Identity record.  But we won't panic if we
        // can't actually find the GUID anymore (even though that should
        // not ever be the case while we have the critical section).
        PAUTHZIDENTSTABLERECORD pBestIdentRecord;
        DWORD dwSaferFlags = 0;
        SAFER_IDENTIFICATION_TYPES LocalIdentificationType = SaferIdentityDefault;

        pBestIdentRecord = CodeAuthzIdentsLookupByGuid(
                &g_CodeIdentitiesTable, &BestIdentGuid);
        if (pBestIdentRecord != NULL) {
            // we identified a level, and the match came from a Identity.
            switch (pBestIdentRecord->dwIdentityType) {
                case SaferIdentityTypeImageName:
                    dwSaferFlags = pBestIdentRecord->ImageNameInfo.dwSaferFlags;
                    LocalRuleName = L"path";
                    LocalIdentificationType = SaferIdentityTypeImageName;
                    break;
                case SaferIdentityTypeImageHash:
                    dwSaferFlags = pBestIdentRecord->ImageHashInfo.dwSaferFlags;
                    LocalRuleName = L"hash";
                    LocalIdentificationType = SaferIdentityTypeImageHash;
                    break;
                case SaferIdentityTypeUrlZone:
                    dwSaferFlags = pBestIdentRecord->ImageZone.dwSaferFlags;
                    LocalRuleName = L"zone";
                    LocalIdentificationType = SaferIdentityTypeUrlZone;
                    break;
                default: break;
            }
            Status = CodeAuthzpCreateLevelHandleFromRecord(
                        pBestLevelRecord,               // pLevelRecord
                        pBestIdentRecord->dwScopeId,
                        dwSaferFlags,                   // dwSaferFlags
                        dwExtendedError,
                        LocalIdentificationType,
                        &BestIdentGuid,                 // pIdentRecord
                        pLevelHandle                    // pLevelHandle
                        );
        }
        else
        {
            Status = STATUS_ACCESS_DENIED;

        }
    }
    if (NT_SUCCESS(Status)) {
        ReturnValue = TRUE;      // success.
    }

    switch(pBestLevelRecord->dwLevelId)
    {
    case SAFER_LEVELID_FULLYTRUSTED:
        LocalLevelName = L"Unrestricted";
        break;
    case SAFER_LEVELID_NORMALUSER:
        LocalLevelName = L"Basic User";
        break;
    case SAFER_LEVELID_CONSTRAINED:
        LocalLevelName = L"Restricted"; 
        break;
    case SAFER_LEVELID_UNTRUSTED:
        LocalLevelName = L"Untrusted";
        break;
    case SAFER_LEVELID_DISALLOWED:
        LocalLevelName = L"Disallowed";
        break;
    default:
        ASSERT(FALSE);
        break;
    }

    if (pCodeProperties->ImagePath != NULL) {
        LocalImageName = (PWSTR) pCodeProperties->ImagePath;
    }

    SaferpLogResultsToFile(
        LocalImageName,
        LocalLevelName,
        LocalRuleName, 
        &BestIdentGuid);

ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    if (!ReturnValue) {
        BaseSetLastNTError(Status);
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safeext.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafeExt.c        (WinSAFER File Extension)

Abstract:

    This module implements the WinSAFER APIs that evaluate the system
    policies to determine if a given file extension is an "executable"
    file that needs to have different enforcement policies considered.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:


Revision History:

    Created - Jul 2000

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"



NTSTATUS NTAPI
__CodeAuthzIsExecutableFileTypeHelper(
        IN PUNICODE_STRING  UnicodeFullPathname,
        IN DWORD			dwScopeId,
        IN BOOLEAN          bFromShellExecute,
        OUT PBOOLEAN        pbResult
        )
{
    NTSTATUS Status;
    LPCWSTR szExtension, szPtr, szEnd;
    ULONG ulExtensionLength;
    HANDLE hKeyBadTypes;
    DWORD dwAllocatedSize = 0, dwActualSize;
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = NULL;

    const static UNICODE_STRING UnicodeValueName =
        RTL_CONSTANT_STRING(SAFER_EXETYPES_REGVALUE);

    if (!ARGUMENT_PRESENT(UnicodeFullPathname) ||
        UnicodeFullPathname->Buffer == NULL ||
        UnicodeFullPathname->Length == 0)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(pbResult)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }


    //
    // Start from the end of the string and scan backwards to
    // look for the period separator and find the extension.
    //
    szExtension = UnicodeFullPathname->Buffer +
            (UnicodeFullPathname->Length / sizeof(WCHAR));
    ASSERT(szExtension >= UnicodeFullPathname->Buffer);

    for (;;) {
        if (szExtension < UnicodeFullPathname->Buffer ||
            *szExtension == L'\\' || *szExtension == L'/') {
            // We scanned back too far, but did not find the extension.
            Status = STATUS_NOT_FOUND;
            goto ExitHandler;
        }
        if (*szExtension == L'.') {
            // We found the period that marks the extension.
            szExtension++;
            break;
        }
        szExtension--;
    }
    ulExtensionLength = (UnicodeFullPathname->Length / sizeof(WCHAR)) -
            (ULONG) (szExtension - UnicodeFullPathname->Buffer);
    if (ulExtensionLength == 0) {
        // We found a period, but there was no extension.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }

    if (bFromShellExecute) {
        
        if ( _wcsicmp(szExtension, L"exe") == 0 ){
            
            *pbResult = FALSE;
            Status = STATUS_SUCCESS;
            goto ExitHandler;
        
        }
    }

    //
    // Open and query the registry value containing the list of extensions.
    //
	Status = CodeAuthzpOpenPolicyRootKey(
		dwScopeId,
        NULL,
        SAFER_CODEIDS_REGSUBKEY,
        KEY_READ,
        FALSE,
        &hKeyBadTypes
        );

    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    for (;;) {
        Status = NtQueryValueKey(
                        hKeyBadTypes,
                        (PUNICODE_STRING) &UnicodeValueName,
                        KeyValuePartialInformation,
                        pKeyValueInfo, dwAllocatedSize, &dwActualSize);
        if (NT_SUCCESS(Status)) {
            break;
        }
        else if ((Status == STATUS_BUFFER_OVERFLOW ||
                Status == STATUS_BUFFER_TOO_SMALL) &&
                dwActualSize > dwAllocatedSize)
        {
            if (pKeyValueInfo != NULL) {
                RtlFreeHeap(RtlProcessHeap(), 0, pKeyValueInfo);
            }
            dwAllocatedSize = dwActualSize;
            pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                RtlAllocateHeap(RtlProcessHeap(), 0, dwAllocatedSize);
            if (!pKeyValueInfo) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler2;
            }
        }
        else {
            goto ExitHandler3;
        }
    }


    //
    // See if the extension is in one of those specified in the list.
    //
    szEnd = (LPCWSTR) ( ((LPBYTE) pKeyValueInfo->Data) +
                        pKeyValueInfo->DataLength);
    for (szPtr = (LPCWSTR) pKeyValueInfo->Data; szPtr < szEnd; ) {
        ULONG ulOneExtension = wcslen(szPtr);
        if (szPtr + ulOneExtension > szEnd) {
            ulOneExtension = (ULONG) (szEnd - szPtr);
        }

        if (ulOneExtension == ulExtensionLength &&
            _wcsnicmp(szExtension, szPtr, ulExtensionLength) == 0) {
            *pbResult = TRUE;
            Status = STATUS_SUCCESS;
            goto ExitHandler3;
        }
        szPtr += ulOneExtension + 1;
    }
    *pbResult = FALSE;
    Status = STATUS_SUCCESS;


ExitHandler3:
    if (pKeyValueInfo != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, pKeyValueInfo);
    }

ExitHandler2:
    NtClose(hKeyBadTypes);

ExitHandler:
    return Status;
}

NTSTATUS NTAPI
CodeAuthzIsExecutableFileType(
        IN PUNICODE_STRING  UnicodeFullPathname,
        IN BOOLEAN  bFromShellExecute,
        OUT PBOOLEAN        pbResult
        )
/*++

Routine Description:

    This API determines if a specified filename has an extension that
    is considered an "executable" extension.  Applications can take
    special precautions to avoid invoking untrusted files that might
    be considered executable.

    Common examples of extensions that are considered executable include:
    EXE, COM, BAT, CMD, VBS, JS, URL, LNK, SHS, PIF, PL, and others.

Arguments:

    UnicodeFullPathname - pointer to a Unicode string of the
        full path and/or filename to evaluate.  Only the file's extension
        (the portion of the specified path following the last period)
        is used in this evaluation.  File extension comparisons are done
        case-insensitively, without regard to case.

        An error will be returned if this pointer is NULL, or if the length
        of the path is zero, or if the file does not have an extension.

        Although applications are encouraged to supply the entire,
        fully-qualified pathname to this API, the szFullPathname argument
        will also accept only the file extension, by ensuring that the
        file extension is preceeded by a period (for example:  L".exe")

    bFromShellExecute - for performance reasons, if this is being called 
        from ShellExecute, we'd like to skip exe checking since CreateProcess 
        will do the check
    
    pbResult - pointer to a variable that will receive a TRUE or FALSE
        result value if this API executes successfully.  An error will
        be returned if this pointer is NULL.

Return Value:

    Returns STATUS_SUCCESS if the API executes successfully, otherwise a
    valid NTSTATUS error code is returned.  If the return value indicates
    success, then the argument 'pbResult' will also receive a boolean
    value indicating whether or not the pathname represented an executable
    file type.

--*/
{
	NTSTATUS Status;

    Status = __CodeAuthzIsExecutableFileTypeHelper(
			UnicodeFullPathname,
        	SAFER_SCOPEID_MACHINE,
            bFromShellExecute,
        	pbResult
        );
	if (!NT_SUCCESS(Status)) {
	    Status = __CodeAuthzIsExecutableFileTypeHelper(
				UnicodeFullPathname,
	        	SAFER_SCOPEID_USER,
                bFromShellExecute,
	        	pbResult
	        );
	}
	return Status;
}

BOOL WINAPI
SaferiIsExecutableFileType(
        IN LPCWSTR      szFullPathname,
        IN BOOLEAN  bFromShellExecute
        )
/*++

Routine Description:

    This API determines if a specified filename has an extension that
    is considered an "executable" extension.  Applications can take
    special precautions to avoid invoking untrusted files that might
    be considered executable.

    Common examples of extensions that are considered executable include:
    EXE, COM, BAT, CMD, VBS, JS, URL, LNK, SHS, PIF, PL, and others.

Arguments:

    szFullPathname - pointer to a Null-terminated Unicode string of the
        full path and/or filename to evaluate.  Only the file's extension
        (the portion of the specified path following the last period)
        is used in this evaluation.  File extension comparisons are done
        case-insensitively, without regard to case.

        An error will be returned if this pointer is NULL, or if the length
        of the path is zero, or if the file does not have an extension.

        Although applications are encouraged to supply the entire,
        fully-qualified pathname to this API, the szFullPathname argument
        will also accept only the file extension, by ensuring that the
        file extension is preceeded by a period (for example:  L".exe")
        
    bFromShellExecute - for performance reasons, if this is being called 
        from ShellExecute, we'd like to skip exe checking since CreateProcess 
        will do the check

Return Value:

    Returns TRUE if the API executes successfully and the filepath's
    extension was recognized as one of the "executable extensions".
    Otherwise a return value of FALSE will either indicate unsuccessful
    API execution, or identification of a non-executable extension.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodePathname;
    BOOLEAN bResult;

    RtlInitUnicodeString(&UnicodePathname, szFullPathname);
    Status = CodeAuthzIsExecutableFileType(
                &UnicodePathname, bFromShellExecute, &bResult);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    if (!bResult) {
        BaseSetLastNTError(STATUS_NOT_FOUND);
        return FALSE;
    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safelevp.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafeLevp.c        (WinSAFER Level table privates)

Abstract:

    This module implements the WinSAFER APIs that loads the names (and
    high-level information) of all Authorization Levels defined within
    a given registry context.  The list of available levels is loaded
    into a Rtl Generic Table that can be enumerated and accessed using
    conventional Rtl Generic Table techniques.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzLevelObjpInitializeTable
    CodeAuthzLevelObjpLoadTable
    CodeAuthzLevelObjpEntireTableFree

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <sddl.h>
#include <winsafer.h>
#include <winsaferp.h>
#include <winsafer.rh>
#include "saferp.h"

//
// Private enumerators used as the EntryContext parameter in our
// callback function CodeAuthzpBuildRestrictedToken during the
// call to RtlQueryRegistryValues.
//
#define AUTHZREGQUERY_IGNORE                (0)
#define AUTHZREGQUERY_DISALLOWEXECUTION     (1)
#define AUTHZREGQUERY_PTR_DISABLEMAX        (2)
#define AUTHZREGQUERY_PTR_COUNT             (3)
#define AUTHZREGQUERY_PTR_PRIVS             (4)
#define AUTHZREGQUERY_PTR_INVERT            (5)
#define AUTHZREGQUERY_RSADD_COUNT           (6)
#define AUTHZREGQUERY_RSADD_SIDS            (7)
#define AUTHZREGQUERY_RSINV_COUNT           (8)
#define AUTHZREGQUERY_RSINV_SIDS            (9)
#define AUTHZREGQUERY_STD_COUNT             (10)
#define AUTHZREGQUERY_STD_SIDS              (11)
#define AUTHZREGQUERY_STD_INVERT            (12)
#define AUTHZREGQUERY_DEFAULTOWNER          (13)
#define AUTHZREGQUERY_SAFERFLAGS            (14)
#define AUTHZREGQUERY_DESCRIPTION           (15)
#define AUTHZREGQUERY_FRIENDLYNAME          (16)


//
// Prototype for the callback function used within the following table.
//
NTSTATUS NTAPI
SaferpBuildRestrictedToken(
        IN PWSTR ValueName,
        IN ULONG ValueType,
        IN PVOID ValueData,
        IN ULONG ValueLength,
        IN PVOID Context,
        IN PVOID EntryContext
        );

PVOID NTAPI
SaferpGenericTableAllocate (
        IN PRTL_GENERIC_TABLE      Table,
        IN CLONG                   ByteSize
        );

VOID NTAPI
SaferpGenericTableFree (
        IN PRTL_GENERIC_TABLE          Table,
        IN PVOID                       Buffer
        );



//
// Internal structure used as an argument to RtlQueryRegistryValues
// during the loading/parsing of an Authorization Object's restrictions.
//
RTL_QUERY_REGISTRY_TABLE CodeAuthzpBuildRestrictedTokenTable[] =
{
    // ----------- Object level flags ------------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        SAFER_OBJDISALLOW_REGVALUE,
        (PVOID) AUTHZREGQUERY_DISALLOWEXECUTION,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        SAFER_OBJDESCRIPTION_REGVALUEW,
        (PVOID) AUTHZREGQUERY_DESCRIPTION,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        SAFER_OBJFRIENDLYNAME_REGVALUEW,
        (PVOID) AUTHZREGQUERY_FRIENDLYNAME,
        REG_NONE, NULL, 0},

    // ----------- Restriction level flags -----------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        RTL_QUERY_REGISTRY_SUBKEY,
        L"Restrictions", (PVOID) AUTHZREGQUERY_IGNORE,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"DefaultOwner", (PVOID) AUTHZREGQUERY_DEFAULTOWNER,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"SaferFlags", (PVOID) AUTHZREGQUERY_SAFERFLAGS,
        REG_NONE, NULL, 0},

    // ----------- Privileges To Remove ------------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        RTL_QUERY_REGISTRY_SUBKEY,
        L"Restrictions\\PrivsToRemove", (PVOID) AUTHZREGQUERY_IGNORE,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"DisableMaxPrivilege", (PVOID) AUTHZREGQUERY_PTR_DISABLEMAX,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"Count", (PVOID) AUTHZREGQUERY_PTR_COUNT,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        NULL, (PVOID) AUTHZREGQUERY_PTR_PRIVS,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"InvertPrivs", (PVOID) AUTHZREGQUERY_PTR_INVERT,
        REG_NONE, NULL, 0},

    // ----------- Sids To Disable ------------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        RTL_QUERY_REGISTRY_SUBKEY,
        L"Restrictions\\SidsToDisable", (PVOID) AUTHZREGQUERY_IGNORE,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"Count", (PVOID) AUTHZREGQUERY_STD_COUNT,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        NULL, (PVOID) AUTHZREGQUERY_STD_SIDS,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"InvertGroups", (PVOID) AUTHZREGQUERY_STD_INVERT,
        REG_NONE, NULL, 0},

    // ----------- Restricting Sids Added ------------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        RTL_QUERY_REGISTRY_SUBKEY,
        L"Restrictions\\RestrictingSidsAdded", (PVOID) AUTHZREGQUERY_IGNORE,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"Count", (PVOID) AUTHZREGQUERY_RSADD_COUNT,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        NULL, (PVOID) AUTHZREGQUERY_RSADD_SIDS,
        REG_NONE, NULL, 0},

    // ----------- Restricting Sids Inverted ------------

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        RTL_QUERY_REGISTRY_SUBKEY,
        L"Restrictions\\RestrictingSidsInverted", (PVOID) AUTHZREGQUERY_IGNORE,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        L"Count", (PVOID) AUTHZREGQUERY_RSINV_COUNT,
        REG_NONE, NULL, 0},

    {(PRTL_QUERY_REGISTRY_ROUTINE)SaferpBuildRestrictedToken,
        0,
        NULL, (PVOID) AUTHZREGQUERY_RSINV_SIDS,
        REG_NONE, NULL, 0},

    // ----------- Terminating Entry ------------

    {NULL, 0, NULL, NULL, REG_NONE, NULL, 0}

};




RTL_GENERIC_COMPARE_RESULTS NTAPI
SaferpLevelObjpTableCompare (
    IN PRTL_GENERIC_TABLE   Table,
    IN PVOID                FirstStruct,
    IN PVOID                SecondStruct
    )
/*++

Routine Description:

    Internal callback for the generic table implementation.
    Comparison callback function used to sort or search entries in the
    level table.  Sorts the object records by the order in which they
    should be evaluated to find the first matching rule for a given
    piece of code.

Arguments:

    Table - pointer to the generic table.

    FirstStruct - first element to compare.

    SecondStruct - second element to compare.

Return Value:

    Returns GenericEqual, GenericLessThan, or GenericGreaterThan.

--*/
{
    PAUTHZLEVELTABLERECORD FirstObj = (PAUTHZLEVELTABLERECORD) FirstStruct;
    PAUTHZLEVELTABLERECORD SecondObj = (PAUTHZLEVELTABLERECORD) SecondStruct;

    UNREFERENCED_PARAMETER(Table);

    // Explicitly handle null parameters as wildcards, allowing them
    // to match anything.  We use this for quick deletion of the table.
    if (FirstStruct == NULL || SecondStruct == NULL)
        return GenericEqual;

    // Compare ascending by dwLevelId.
    if ( FirstObj->dwLevelId < SecondObj->dwLevelId )
        return GenericLessThan;
    else if ( FirstObj->dwLevelId > SecondObj->dwLevelId )
        return GenericGreaterThan;

    // otherwise they are equal.
    return GenericEqual;
}



NTSTATUS NTAPI
SaferpBuildRestrictedToken(
        IN PWSTR    ValueName,
        IN ULONG    ValueType,
        IN PVOID    ValueData,
        IN ULONG    ValueLength,
        IN PVOID    Context,
        IN PVOID    EntryContext
        )
/*++

Routine Description:

    This is a callback function used during the reading and parsing
    of the registry values associated with the restricted token
    that will be built.

Arguments:

    ValueName -

    ValueType -

    ValueData -

    ValueLength -

    Context - parameter from original RtlQueryRegistryValues function call.

    EntryContext - parameter from structure entry.

Return Value:

    Returns STATUS_SUCCESS if enumeration should continue.

--*/
{
    PAUTHZLEVELTABLERECORD RegQuery = (PAUTHZLEVELTABLERECORD) Context;

    switch ((ULONG_PTR) EntryContext)
    {
    case AUTHZREGQUERY_DISALLOWEXECUTION:
        if (!RegQuery->Builtin) {
            RegQuery->DisallowExecution =
                ((ValueType == REG_DWORD) &&
                (ValueLength == sizeof(DWORD)) &&
                (*(PDWORD) ValueData) != 0);
        }
        break;
#if 0
#error
    case AUTHZREGQUERY_DESCRIPTION:
        if (ValueType == REG_SZ &&
            RegQuery->UnicodeDescription.Buffer == NULL)
        {
            RtlCreateUnicodeString(
                &RegQuery->UnicodeDescription,
                (LPCWSTR) ValueData);
        }
        break;
    case AUTHZREGQUERY_FRIENDLYNAME:
        if (ValueType == REG_SZ &&
            RegQuery->UnicodeFriendlyName.Buffer == NULL)
        {
            RtlCreateUnicodeString(
                &RegQuery->UnicodeFriendlyName,
                (LPCWSTR) ValueData);
        }
        break;
#endif

    //---------
    case AUTHZREGQUERY_DEFAULTOWNER:
        if (!RegQuery->Builtin && ValueType == REG_SZ &&
            RegQuery->DefaultOwner == NULL)
        {
            if (!ConvertStringSidToSidW(
                (LPCWSTR) ValueData,
                &RegQuery->DefaultOwner))
            {
                RegQuery->DefaultOwner = NULL;
            }
        }
        break;
    case AUTHZREGQUERY_SAFERFLAGS:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            RegQuery->SaferFlags = *(LPDWORD) ValueData;
        }
        break;
    //---------
    case AUTHZREGQUERY_PTR_DISABLEMAX:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD) &&
            (*(PDWORD) ValueData) != 0)
            RegQuery->DisableMaxPrivileges = TRUE;
        break;
    case AUTHZREGQUERY_PTR_COUNT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            ASSERT(RegQuery->PrivilegesToDelete == NULL);
            RegQuery->DeletePrivilegeCount = (*(PDWORD) ValueData);
            RegQuery->DeletePrivilegeUsedCount = 0;
            if (RegQuery->DeletePrivilegeCount > 0) {
                RegQuery->PrivilegesToDelete =
                    (PLUID_AND_ATTRIBUTES) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            sizeof(LUID_AND_ATTRIBUTES) *
                                RegQuery->DeletePrivilegeCount);
                if (RegQuery->PrivilegesToDelete == NULL)
                    return STATUS_NO_MEMORY;
            }
        }
        break;
    case AUTHZREGQUERY_PTR_PRIVS:
        if (!RegQuery->Builtin && ValueType == REG_SZ &&
            _wcsnicmp(ValueName, L"Priv", 4) == 0 &&
            RegQuery->PrivilegesToDelete != NULL &&
            RegQuery->DeletePrivilegeUsedCount < RegQuery->DeletePrivilegeCount)
        {
            if (LookupPrivilegeValueW(NULL,
                (LPCWSTR) ValueData,
                &RegQuery->PrivilegesToDelete[
                    RegQuery->DeletePrivilegeUsedCount].Luid) != 0)
            {
                RegQuery->PrivilegesToDelete[
                    RegQuery->DeletePrivilegeUsedCount].Attributes = 0;
                (RegQuery->DeletePrivilegeUsedCount)++;
            }
        }
        break;
    case AUTHZREGQUERY_PTR_INVERT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            RegQuery->InvertDeletePrivs =
                ( (*(PDWORD) ValueData) != 0 ? TRUE : FALSE);
        }
        break;

    //---------
    case AUTHZREGQUERY_STD_COUNT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            ASSERT(RegQuery->SidsToDisable == NULL);
            RegQuery->DisableSidCount = (*(PDWORD) ValueData);
            RegQuery->DisableSidUsedCount = 0;
            if (RegQuery->DisableSidCount > 0) {
                RegQuery->SidsToDisable =
                    (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            sizeof(AUTHZ_WILDCARDSID) *
                                RegQuery->DisableSidCount);
                if (RegQuery->SidsToDisable == NULL)
                    return STATUS_NO_MEMORY;
            }
        }
        break;
    case AUTHZREGQUERY_STD_SIDS:
        if (!RegQuery->Builtin && ValueType == REG_SZ &&
            _wcsnicmp(ValueName, L"Group", 5) == 0 &&
            RegQuery->SidsToDisable != NULL &&
            RegQuery->DisableSidUsedCount < RegQuery->DisableSidCount)
        {
            NTSTATUS Status;
            Status = CodeAuthzpConvertWildcardStringSidToSidW(
                (LPCWSTR) ValueData,
                &RegQuery->SidsToDisable[
                    RegQuery->DisableSidUsedCount]);
            if (NT_SUCCESS(Status)) {
                (RegQuery->DisableSidUsedCount)++;
            }
        }
        break;
    case AUTHZREGQUERY_STD_INVERT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            RegQuery->InvertDisableSids =
                ( (*(PDWORD) ValueData) != 0 ? TRUE : FALSE);
        }
        break;

    //---------
    case AUTHZREGQUERY_RSADD_COUNT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            ASSERT(RegQuery->RestrictedSidsAdded == NULL);
            RegQuery->RestrictedSidsAddedCount = (*(PDWORD) ValueData);
            RegQuery->RestrictedSidsAddedUsedCount = 0;
            if (RegQuery->RestrictedSidsAddedCount > 0) {
                RegQuery->RestrictedSidsAdded =
                    (PSID_AND_ATTRIBUTES) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            sizeof(SID_AND_ATTRIBUTES) *
                                RegQuery->RestrictedSidsAddedCount);
                if (RegQuery->RestrictedSidsAdded == NULL)
                    return STATUS_NO_MEMORY;
            }
        }
        break;
    case AUTHZREGQUERY_RSADD_SIDS:
        if (!RegQuery->Builtin && ValueType == REG_SZ &&
            _wcsnicmp(ValueName, L"Group", 5) == 0 &&
            RegQuery->RestrictedSidsAdded != NULL &&
            RegQuery->RestrictedSidsAddedUsedCount <
                RegQuery->RestrictedSidsAddedCount)
        {
            if (ConvertStringSidToSidW(
                (LPCWSTR) ValueData,
                &RegQuery->RestrictedSidsAdded[
                    RegQuery->RestrictedSidsAddedUsedCount].Sid) != 0)
            {
                RegQuery->RestrictedSidsAdded[
                    RegQuery->RestrictedSidsAddedUsedCount].Attributes = 0;
                (RegQuery->RestrictedSidsAddedUsedCount)++;
            }
        }
        break;

    //---------
    case AUTHZREGQUERY_RSINV_COUNT:
        if (!RegQuery->Builtin && ValueType == REG_DWORD &&
            ValueLength == sizeof(DWORD))
        {
            ASSERT(RegQuery->RestrictedSidsInv == NULL);
            RegQuery->RestrictedSidsInvCount = (*(PDWORD) ValueData);
            RegQuery->RestrictedSidsInvUsedCount = 0;
            if (RegQuery->RestrictedSidsInvCount > 0) {
                RegQuery->RestrictedSidsInv =
                    (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                            RtlProcessHeap(),
                            0,
                            sizeof(AUTHZ_WILDCARDSID) *
                                RegQuery->RestrictedSidsInvCount);
                if (RegQuery->RestrictedSidsInv == NULL)
                    return STATUS_NO_MEMORY;
            }
        }
        break;
    case AUTHZREGQUERY_RSINV_SIDS:
        if (!RegQuery->Builtin && ValueType == REG_SZ &&
            _wcsnicmp(ValueName, L"Group", 5) == 0 &&
            RegQuery->RestrictedSidsInv != NULL &&
            RegQuery->RestrictedSidsInvUsedCount <
                RegQuery->RestrictedSidsInvCount)
        {
            NTSTATUS Status;
            Status = CodeAuthzpConvertWildcardStringSidToSidW(
                (LPCWSTR) ValueData,
                &RegQuery->RestrictedSidsInv[
                    RegQuery->RestrictedSidsInvUsedCount]);
            if (NT_SUCCESS(Status)) {
                (RegQuery->RestrictedSidsInvUsedCount)++;
            }
        }
        break;
    //---------
    default:
    case AUTHZREGQUERY_IGNORE:
        // ignore anything else.
        break;
    }
    return STATUS_SUCCESS;
}


VOID NTAPI
CodeAuthzLevelObjpInitializeTable(
        IN PRTL_GENERIC_TABLE  AuthzObjTable
        )
/*++

Routine Description:

    Initializes a generic table structure to prepare it for use.
    This function must be called before CodeAuthzObjpLoadTable
    is used to load data into it.

Arguments:

    AuthzObjTable = pointer to the level table being updated.

Return Value:

    Does not return a value.

--*/
{
    RtlInitializeGenericTable(
            AuthzObjTable,
            (PRTL_GENERIC_COMPARE_ROUTINE) SaferpLevelObjpTableCompare,
            (PRTL_GENERIC_ALLOCATE_ROUTINE) SaferpGenericTableAllocate,
            (PRTL_GENERIC_FREE_ROUTINE) SaferpGenericTableFree,
            NULL);
}


VOID NTAPI
SaferpLevelObjpCleanupEntry(
        IN OUT PAUTHZLEVELTABLERECORD     pAuthzObjRecord
        )
/*++

Routine Description:

    Releases allocated memory represented within a level record.
    Does not free the record itself or remove it from the
    generic table that it belongs to.

Arguments:

    pAuthzObjRecord = pointer to the level table record itself.

Return Value:

    Does not return a value.

--*/
{
    PVOID processheap = RtlProcessHeap();

    ASSERT(pAuthzObjRecord != NULL);

#if 0
#error
    if (pAuthzObjRecord->UnicodeDescription.Buffer != NULL) {
        RtlFreeUnicodeString(&pAuthzObjRecord->UnicodeDescription);
    }
    if (pAuthzObjRecord->UnicodeFriendlyName.Buffer != NULL) {
        RtlFreeUnicodeString(&pAuthzObjRecord->UnicodeFriendlyName);
    }
#endif
    
    if (pAuthzObjRecord->DefaultOwner != NULL) {
        LocalFree((HLOCAL) pAuthzObjRecord->DefaultOwner);
    }
    if (pAuthzObjRecord->SidsToDisable != NULL) {
        DWORD Index;
        for (Index = 0; Index < pAuthzObjRecord->DisableSidUsedCount; Index++) {
            LocalFree((HLOCAL) pAuthzObjRecord->SidsToDisable[Index].Sid);
        }
        RtlFreeHeap(processheap, 0, (LPVOID) pAuthzObjRecord->SidsToDisable);
    }
    if (pAuthzObjRecord->PrivilegesToDelete != NULL) {
        RtlFreeHeap(processheap, 0, (LPVOID) pAuthzObjRecord->PrivilegesToDelete);
    }
    if (pAuthzObjRecord->RestrictedSidsAdded != NULL) {
        DWORD Index;
        for (Index = 0; Index < pAuthzObjRecord->RestrictedSidsAddedUsedCount; Index++) {
            LocalFree((HLOCAL) pAuthzObjRecord->RestrictedSidsAdded[Index].Sid);
        }
        RtlFreeHeap(processheap, 0, (LPVOID) pAuthzObjRecord->RestrictedSidsAdded);
    }
    if (pAuthzObjRecord->RestrictedSidsInv != NULL) {
        DWORD Index;
        for (Index = 0; Index < pAuthzObjRecord->RestrictedSidsInvUsedCount; Index++) {
            LocalFree((HLOCAL) pAuthzObjRecord->RestrictedSidsInv[Index].Sid);
        }
        RtlFreeHeap(processheap, 0, (LPVOID) pAuthzObjRecord->RestrictedSidsInv);
    }
    RtlZeroMemory(pAuthzObjRecord, sizeof(AUTHZLEVELTABLERECORD));
}



BOOL NTAPI
SaferpLoadUnicodeResourceString(
        IN HANDLE               hModule,
        IN UINT                 wID,
        OUT PUNICODE_STRING     pUnicodeString,
        IN WORD                 wLangId
    )
/*++

Routine Description:

    We roll our own instead of using LoadStringW() directly, because it
    depends on user32.dll and would introduce a new dll dependency,
    whereas this implementation only requires kernel32.dll imports.

Arguments:

    hModule - handle the module to load the resource from.

    wID - Resource ID to load.

    pUnicodeString - output buffer to receive the loaded string.  This
        string must be freed with RtlFreeUnicodeString().

    wLangId - language identifier to load.  To simply use the current
        thread locale, you may specify the value:
                MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)

Return Value:

    Returns FALSE on error, otherwise success.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeOrig;
    HANDLE hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    hResInfo = FindResourceEx(
                    hModule,
                    MAKEINTRESOURCEW(6), /* RT_STRING */
                    (LPWSTR)((LONG_PTR)(((USHORT)wID >> 4) + 1)),
                    wLangId );
    if (hResInfo) {

        /*
         * Load that segment.
         */
        hStringSeg = LoadResource(hModule, hResInfo);
        if (hStringSeg == NULL) {
            return 0;
        }

        lpsz = (LPWSTR) (hStringSeg);

        /*
         * Move past the other strings in this segment.
         * (16 strings in a segment -> & 0x0F)
         */
        wID &= 0x0F;
        for (;;) {
            cch = *((WCHAR *)lpsz++);       // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
            if (wID-- == 0) break;
            lpsz += cch;                    // Step to start if next string
        }

        /*
         * Create the UNICODE_STRING version of the string based
         * off of the pointer to the read-only resource buffer.
         */
        UnicodeOrig.Buffer = (WCHAR *)lpsz;
        UnicodeOrig.Length = UnicodeOrig.MaximumLength =
                (USHORT) (cch * sizeof(WCHAR));


        /*
         * Allocate memory for the new copy, and pass that back.
         */
        Status = RtlDuplicateUnicodeString(
                        RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE,
                        &UnicodeOrig, pUnicodeString);
        if (NT_SUCCESS(Status)) {
            return 1;
        }
    }
    return 0;
}




NTSTATUS NTAPI
SaferpEnforceDefaultLevelDefinitions(
        IN OUT PAUTHZLEVELTABLERECORD pAuthzObjTableRec
        )
/*++

Routine Description:

    Fills a level record structure with the built-in definitions of
    the 5 WinSafer level definitions.

Arguments:

    pAuthzObjTableRec - pointer to the level record to initialize.
        The dwLevelId member of the record must be initialized.  The
        rest of the structure is expected to be NULL.

Return Value:

    Returns STATUS_SUCCESS on success, otherwise error.

--*/
{
    NTSTATUS Status;
    const static SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    const static SID_IDENTIFIER_AUTHORITY WorldAuth = SECURITY_WORLD_SID_AUTHORITY;

    if (!ARGUMENT_PRESENT(pAuthzObjTableRec)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if (pAuthzObjTableRec->dwLevelId != SAFER_LEVELID_FULLYTRUSTED &&
         pAuthzObjTableRec->dwLevelId != SAFER_LEVELID_NORMALUSER &&
         pAuthzObjTableRec->dwLevelId != SAFER_LEVELID_CONSTRAINED &&
         pAuthzObjTableRec->dwLevelId != SAFER_LEVELID_UNTRUSTED &&
         pAuthzObjTableRec->dwLevelId != SAFER_LEVELID_DISALLOWED) {
        Status = STATUS_NOT_IMPLEMENTED;
        goto ExitHandler;
    }

    switch (pAuthzObjTableRec->dwLevelId)
    {
        case SAFER_LEVELID_DISALLOWED:
            pAuthzObjTableRec->uResourceID = CODEAUTHZ_RC_LEVELNAME_DISALLOWED;
            pAuthzObjTableRec->DisallowExecution = TRUE;
            break;

        // -----------------------

        case SAFER_LEVELID_UNTRUSTED:
            pAuthzObjTableRec->uResourceID = CODEAUTHZ_RC_LEVELNAME_UNTRUSTED;
            pAuthzObjTableRec->DisallowExecution = FALSE;
            ASSERT(pAuthzObjTableRec->DefaultOwner == NULL);
            Status = RtlAllocateAndInitializeSid(
                        (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                        SECURITY_PRINCIPAL_SELF_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pAuthzObjTableRec->DefaultOwner);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SaferFlags = SAFER_POLICY_JOBID_UNTRUSTED;

            // Privileges.
            pAuthzObjTableRec->DisableMaxPrivileges = TRUE;
            pAuthzObjTableRec->DeletePrivilegeUsedCount = 0;
            pAuthzObjTableRec->InvertDeletePrivs = FALSE;

            // Sids to restrict.
            ASSERT(pAuthzObjTableRec->RestrictedSidsAdded == NULL);
            pAuthzObjTableRec->RestrictedSidsAddedCount =
                pAuthzObjTableRec->RestrictedSidsAddedUsedCount = 5;
            pAuthzObjTableRec->RestrictedSidsAdded =
                (PSID_AND_ATTRIBUTES) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 5 * sizeof(SID_AND_ATTRIBUTES));
            if (!pAuthzObjTableRec->RestrictedSidsAdded) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->RestrictedSidsAdded,
                          5 * sizeof(SID_AND_ATTRIBUTES));
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_RESTRICTED_CODE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[0].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &WorldAuth, 1,
                    SECURITY_WORLD_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[1].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_INTERACTIVE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[2].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_AUTHENTICATED_USER_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[3].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_USERS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[4].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInvUsedCount = 0;

            // Sids to disable.
            pAuthzObjTableRec->DisableSidCount =
                pAuthzObjTableRec->DisableSidUsedCount = 5;
            ASSERT(pAuthzObjTableRec->SidsToDisable == NULL);
            pAuthzObjTableRec->SidsToDisable =
                (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 5 * sizeof(AUTHZ_WILDCARDSID));
            if (!pAuthzObjTableRec->SidsToDisable) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->SidsToDisable,
                          5 * sizeof(AUTHZ_WILDCARDSID));
            pAuthzObjTableRec->SidsToDisable[0].WildcardPos = -1;
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &WorldAuth, 1,
                    SECURITY_WORLD_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[0].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[1].WildcardPos = -1;
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_INTERACTIVE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[1].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[2].WildcardPos = -1;
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_PRINCIPAL_SELF_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[2].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[3].WildcardPos = -1;
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_AUTHENTICATED_USER_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[3].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[4].WildcardPos = -1;
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_USERS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[4].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->InvertDisableSids = TRUE;
            break;

        // -----------------------

        case SAFER_LEVELID_CONSTRAINED:
            pAuthzObjTableRec->uResourceID = CODEAUTHZ_RC_LEVELNAME_CONSTRAINED;
            pAuthzObjTableRec->DisallowExecution = FALSE;
            ASSERT(pAuthzObjTableRec->DefaultOwner == NULL);
            Status = RtlAllocateAndInitializeSid(
                        (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                        SECURITY_PRINCIPAL_SELF_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pAuthzObjTableRec->DefaultOwner);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SaferFlags = SAFER_POLICY_JOBID_CONSTRAINED;

            // Privileges.
            pAuthzObjTableRec->DisableMaxPrivileges = TRUE;
            pAuthzObjTableRec->DeletePrivilegeUsedCount = 0;
            pAuthzObjTableRec->InvertDeletePrivs = FALSE;

            // Sids to restrict (added).
            ASSERT(pAuthzObjTableRec->RestrictedSidsAdded == NULL);
            pAuthzObjTableRec->RestrictedSidsAddedCount =
                pAuthzObjTableRec->RestrictedSidsAddedUsedCount = 1;
            pAuthzObjTableRec->RestrictedSidsAdded =
                (PSID_AND_ATTRIBUTES) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 1 * sizeof(SID_AND_ATTRIBUTES));
            if (!pAuthzObjTableRec->RestrictedSidsAdded) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->RestrictedSidsAdded,
                          1 * sizeof(SID_AND_ATTRIBUTES));
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                    SECURITY_RESTRICTED_CODE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsAdded[0].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }

            // Sids to restrict (inverted).
            ASSERT(pAuthzObjTableRec->RestrictedSidsInv == NULL);
            pAuthzObjTableRec->RestrictedSidsInvCount =
                pAuthzObjTableRec->RestrictedSidsInvUsedCount = 8;
            pAuthzObjTableRec->RestrictedSidsInv =
                (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 8 * sizeof(AUTHZ_WILDCARDSID));
            if (!pAuthzObjTableRec->RestrictedSidsInv) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->RestrictedSidsInv,
                          8 * sizeof(AUTHZ_WILDCARDSID));
            pAuthzObjTableRec->RestrictedSidsInv[0].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                        (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                        SECURITY_PRINCIPAL_SELF_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pAuthzObjTableRec->RestrictedSidsInv[0].Sid);
            pAuthzObjTableRec->RestrictedSidsInv[1].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[1].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[2].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[2].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[3].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[3].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[4].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_CERT_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[4].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[5].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_SCHEMA_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[5].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[6].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[6].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->RestrictedSidsInv[7].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_POLICY_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->RestrictedSidsInv[7].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }

            // Sids to disable.
            pAuthzObjTableRec->DisableSidCount =
                pAuthzObjTableRec->DisableSidUsedCount = 7;
            ASSERT(pAuthzObjTableRec->SidsToDisable == NULL);
            pAuthzObjTableRec->SidsToDisable =
                (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 7 * sizeof(AUTHZ_WILDCARDSID));
            if (!pAuthzObjTableRec->SidsToDisable) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->SidsToDisable,
                          7 * sizeof(AUTHZ_WILDCARDSID));
            pAuthzObjTableRec->SidsToDisable[0].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[0].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[1].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[1].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[2].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[2].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[3].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_CERT_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[3].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[4].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_SCHEMA_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[4].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[5].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[5].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[6].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_POLICY_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[6].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->InvertDisableSids = FALSE;
            break;

        // -----------------------

        case SAFER_LEVELID_NORMALUSER:
            pAuthzObjTableRec->uResourceID = CODEAUTHZ_RC_LEVELNAME_NORMALUSER;
            pAuthzObjTableRec->DisallowExecution = FALSE;
            ASSERT(pAuthzObjTableRec->DefaultOwner == NULL);
            Status = RtlAllocateAndInitializeSid(
                        (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 1,
                        SECURITY_PRINCIPAL_SELF_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pAuthzObjTableRec->DefaultOwner);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SaferFlags = 0;

            // Privileges
            pAuthzObjTableRec->DisableMaxPrivileges = TRUE;
            pAuthzObjTableRec->DeletePrivilegeUsedCount = 0;
            pAuthzObjTableRec->InvertDeletePrivs = FALSE;

            // Sids to restrict.
            pAuthzObjTableRec->RestrictedSidsAddedUsedCount =
                pAuthzObjTableRec->RestrictedSidsInvUsedCount = 0;

            // Sids to disable.
            pAuthzObjTableRec->DisableSidCount =
                pAuthzObjTableRec->DisableSidUsedCount = 7;
            ASSERT(pAuthzObjTableRec->SidsToDisable == NULL);
            pAuthzObjTableRec->SidsToDisable =
                (PAUTHZ_WILDCARDSID) RtlAllocateHeap(
                    RtlProcessHeap(), 0, 7 * sizeof(AUTHZ_WILDCARDSID));
            if (!pAuthzObjTableRec->SidsToDisable) {
                Status = STATUS_NO_MEMORY;
                goto ExitHandler;
            }
            RtlZeroMemory(pAuthzObjTableRec->SidsToDisable,
                          7 * sizeof(AUTHZ_WILDCARDSID));
            pAuthzObjTableRec->SidsToDisable[0].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[0].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[1].WildcardPos = -1;   // exact!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_POWER_USERS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[1].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[2].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[2].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[3].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_CERT_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[3].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[4].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_SCHEMA_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[4].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[5].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[5].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->SidsToDisable[6].WildcardPos = 1;    // wildcard!
            Status = RtlAllocateAndInitializeSid(
                    (PSID_IDENTIFIER_AUTHORITY) &SIDAuth, 2,
                    SECURITY_NT_NON_UNIQUE, DOMAIN_GROUP_RID_POLICY_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAuthzObjTableRec->SidsToDisable[6].Sid);
            if (!NT_SUCCESS(Status)) {
                goto ExitHandler;
            }
            pAuthzObjTableRec->InvertDisableSids = FALSE;
            break;

        // -----------------------

        case SAFER_LEVELID_FULLYTRUSTED:
            pAuthzObjTableRec->uResourceID = CODEAUTHZ_RC_LEVELNAME_FULLYTRUSTED;
            pAuthzObjTableRec->DisallowExecution = FALSE;
            ASSERT(pAuthzObjTableRec->DefaultOwner == NULL);
            pAuthzObjTableRec->DisableMaxPrivileges = FALSE;
            pAuthzObjTableRec->SaferFlags = 0;
            pAuthzObjTableRec->DeletePrivilegeUsedCount =
                pAuthzObjTableRec->DisableSidUsedCount =
                pAuthzObjTableRec->RestrictedSidsAddedUsedCount =
                pAuthzObjTableRec->RestrictedSidsInvUsedCount = 0;
            pAuthzObjTableRec->InvertDeletePrivs =
                pAuthzObjTableRec->InvertDisableSids = FALSE;
            break;

        // -----------------------

        default:
            // should not happen.
            Status = STATUS_UNSUCCESSFUL;
            goto ExitHandler;
    }


#if 0
    //
    // Load the resource descriptions and friendly names.
    //
    hAdvApiInst = (HANDLE) GetModuleHandleW(L"advapi32");
    if (hAdvApiInst != NULL)
    {
        // load the friendly name.
        SaferpLoadUnicodeResourceString(
                    hAdvApiInst,
                    (UINT) (uResourceID + 0),
                    &pAuthzObjTableRec->UnicodeFriendlyName,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));

        // load the description.
        SaferpLoadUnicodeResourceString(
                    hAdvApiInst,
                    (UINT) (uResourceID + 1),
                    &pAuthzObjTableRec->UnicodeDescription,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL));
    }
#endif
    

    Status = STATUS_SUCCESS;


ExitHandler:
    return Status;
}

DWORD
SaferpEnumerateHiddenLevels(VOID)

/*++

Routine Description:
    Reads which hidden levels should be enumerated.

Arguments:

Return Value:

    Returns DWORD.

--*/
{
    NTSTATUS Status;
    UCHAR QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_PATH * sizeof(WCHAR)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
    DWORD dwActualSize = 0;
    HKEY hKey = NULL;

    const static UNICODE_STRING SaferUnicodeKeyName = RTL_CONSTANT_STRING(L"\\Registry\\Machine\\Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers");
    const static OBJECT_ATTRIBUTES SaferObjectAttributes = RTL_CONSTANT_OBJECT_ATTRIBUTES(&SaferUnicodeKeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING SaferHiddenLevels = RTL_CONSTANT_STRING(SAFER_HIDDEN_LEVELS);


    // Open the CodeIdentifiers key.
    Status = NtOpenKey(
                 &hKey, 
                 KEY_QUERY_VALUE,
                 (POBJECT_ATTRIBUTES) &SaferObjectAttributes
                 );
    
    if (!NT_SUCCESS(Status)) {
        return 0;
    }
    
    Status = NtQueryValueKey(
                 hKey,
                 (PUNICODE_STRING) &SaferHiddenLevels,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );
    
    NtClose(hKey);

    if (!NT_SUCCESS(Status)) {
        return 0;
    }
    
    if (pKeyValueInfo->Type == REG_DWORD &&
        pKeyValueInfo->DataLength == sizeof(DWORD)) {
        return *((PDWORD) pKeyValueInfo->Data);
    }

    return 0;
}


NTSTATUS NTAPI
CodeAuthzLevelObjpLoadTable (
        IN OUT PRTL_GENERIC_TABLE   pAuthzObjTable,
        IN DWORD                    dwScopeId,
        IN HANDLE                   hKeyCustomRoot
        )
/*++

Routine Description:

    Pre-loads our table with a record for each Authorization Level
    encountered in the registry.  Each record in the table contains
    the LevelId, registry handle, and all restricted token attributes
    that will be needed to later compute the restricted token.

Arguments:

    AuthzObjTable = pointer to the level table being updated.  Must have
        already been initialized with CodeAuthzLevelObjpInitializeTable.


Return Value:

    Returns FALSE on error, otherwise success.

--*/
{
    DWORD dwIndex;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hKeyLevelObjects;
    DWORD LocalValue = 0;
    OBJECT_ATTRIBUTES ObjectAttributes;


    //
    // Open a handle to the appropriate section of the registry where
    // the Level definitions are stored.  Generally they will come only
    // from the AUTHZSCOPEID_MACHINE scope, but we allow it to be
    // specified as an argument for the group policy editing case.
    //
    Status = CodeAuthzpOpenPolicyRootKey(
                    dwScopeId,
                    hKeyCustomRoot,
                    SAFER_OBJECTS_REGSUBKEY,
                    KEY_READ,
                    FALSE,
                    &hKeyLevelObjects);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }


    //
    // Iterate through all subkeys under this branch.
    //
    for (dwIndex = 0; ; dwIndex++)
    {
        DWORD dwLength, dwLevelId;
        HANDLE hKeyThisLevelObject;
        AUTHZLEVELTABLERECORD AuthzObjTableRec;
        UNICODE_STRING UnicodeKeyname;
        BYTE RawQueryBuffer[sizeof(KEY_BASIC_INFORMATION) + 256];
        PKEY_BASIC_INFORMATION pBasicInformation =
                (PKEY_BASIC_INFORMATION) &RawQueryBuffer[0];


        //
        // Find the next Level that we will check.
        //
        Status = NtEnumerateKey(hKeyLevelObjects,
                                dwIndex,
                                KeyBasicInformation,
                                pBasicInformation,
                                sizeof(RawQueryBuffer),
                                &dwLength);
        if (!NT_SUCCESS(Status)) {
            break;
        }
        UnicodeKeyname.Buffer = pBasicInformation->Name;
        UnicodeKeyname.MaximumLength = UnicodeKeyname.Length =
                (USHORT) pBasicInformation->NameLength;
        // Note that UnicodeKeyname.Buffer is not necessarily null terminated.
        ASSERT(UnicodeKeyname.Length <= wcslen(UnicodeKeyname.Buffer) * sizeof(WCHAR));


        //
        // Translate the keyname (which we expect to be
        // purely numeric) into the integer LevelId value.
        //
        Status = RtlUnicodeStringToInteger(
                    &UnicodeKeyname, 10, &dwLevelId);
        if (!NT_SUCCESS(Status)) {
            // the keyname was apparently not numeric.
            continue;
        }


        //
        // Try to open a handle to that Level for read-only access.
        //
        InitializeObjectAttributes(&ObjectAttributes,
              &UnicodeKeyname,
              OBJ_CASE_INSENSITIVE,
              hKeyLevelObjects,
              NULL
              );
        Status = NtOpenKey(&hKeyThisLevelObject,
                           KEY_READ,
                           &ObjectAttributes);
        if (!NT_SUCCESS(Status)) {
            // If we failed to open it, skip to the next one.
            continue;
        }


        //
        // Fill in the well-known portions of the record structure.
        //
        RtlZeroMemory(&AuthzObjTableRec, sizeof(AuthzObjTableRec));
        AuthzObjTableRec.dwLevelId = dwLevelId;
        AuthzObjTableRec.Builtin =
            (dwLevelId == SAFER_LEVELID_FULLYTRUSTED ||
             dwLevelId == SAFER_LEVELID_NORMALUSER ||
             dwLevelId == SAFER_LEVELID_CONSTRAINED ||
             dwLevelId == SAFER_LEVELID_UNTRUSTED ||
             dwLevelId == SAFER_LEVELID_DISALLOWED) ? TRUE : FALSE;

		AuthzObjTableRec.isEnumerable = TRUE;  //always allow enumeration of entries defined in the registry.

        //
        // Read all of the restricted token attributes from the registry.
        // Note that for Builtin Levels, we use a different query table
        // that only attempts to read a reduced set of attributes from
        // the registry, since we'd ignore most of them anyways.
        //
        if (!AuthzObjTableRec.Builtin) {
            Status = RtlQueryRegistryValues(
                    RTL_REGISTRY_HANDLE,
                    (PCWSTR) hKeyThisLevelObject,
                    CodeAuthzpBuildRestrictedTokenTable,
                    &AuthzObjTableRec,
                    NULL
                    );
            // (We don't actually look at the Status code, since it
            // is acceptable for some values or subkeys to have not
            // been specified.)
        }


        //
        // If this is a built-in Level, then enforce the other expected attributes.
        //
        if (AuthzObjTableRec.Builtin) {
            Status = SaferpEnforceDefaultLevelDefinitions(
                            &AuthzObjTableRec);
            if (!NT_SUCCESS(Status)) {
                SaferpLevelObjpCleanupEntry(&AuthzObjTableRec);
                NtClose(hKeyThisLevelObject);
                continue;
            }
        }


        //
        // Add the new record into our table.
        //
        if (RtlLookupElementGenericTable(pAuthzObjTable,
                       (PVOID) &AuthzObjTableRec) == NULL)
        {
            // Only insert the record if we don't have any other
            // entries with this same LevelId combination.
            RtlInsertElementGenericTable(
                    pAuthzObjTable,
                    (PVOID) &AuthzObjTableRec,
                    sizeof(AUTHZLEVELTABLERECORD),
                    NULL);
        } else {
            // Otherwise something with this same LevelId already existed.
            // (like level names "01" and "1" being numerically the same).
            SaferpLevelObjpCleanupEntry(&AuthzObjTableRec);
        }
        NtClose(hKeyThisLevelObject);
    }
    NtClose(hKeyLevelObjects);


    //
    // Look through and verify that all of the default Levels were
    // actually loaded.  If they were not, then try to add them.
    //
ExitHandler:

    LocalValue = SaferpEnumerateHiddenLevels();

    for (dwIndex = 0; dwIndex < 5; dwIndex++)
    {
        const DWORD dwBuiltinLevels[5][2] = {
            {SAFER_LEVELID_DISALLOWED, TRUE},        // true = always create
            {SAFER_LEVELID_UNTRUSTED, FALSE},
            {SAFER_LEVELID_CONSTRAINED, FALSE},
            {SAFER_LEVELID_NORMALUSER, FALSE},
            {SAFER_LEVELID_FULLYTRUSTED, TRUE}       // true = always create
        };
        DWORD dwLevelId = dwBuiltinLevels[dwIndex][0];


        if ( !CodeAuthzLevelObjpLookupByLevelId (
                    pAuthzObjTable, dwLevelId))
        {
            AUTHZLEVELTABLERECORD AuthzObjTableRec;

            RtlZeroMemory(&AuthzObjTableRec, sizeof(AuthzObjTableRec));
            AuthzObjTableRec.dwLevelId = dwLevelId;
            AuthzObjTableRec.Builtin = TRUE;
            AuthzObjTableRec.isEnumerable =(BOOLEAN)(dwBuiltinLevels[dwIndex][1]) ;  //conditionally show this level

            // If the registry key specifies that the level should be shown
            // mark it as enumerable.
            if ((LocalValue & dwLevelId) == dwLevelId) {
                AuthzObjTableRec.isEnumerable = TRUE;
            }

            if (NT_SUCCESS(
                    SaferpEnforceDefaultLevelDefinitions(
                            &AuthzObjTableRec)))
            {
                RtlInsertElementGenericTable(
                        pAuthzObjTable,
                        (PVOID) &AuthzObjTableRec,
                        sizeof(AUTHZLEVELTABLERECORD),
                        NULL);
            } else {
                SaferpLevelObjpCleanupEntry(&AuthzObjTableRec);
            }
        }
    }

    return Status;
}





VOID NTAPI
CodeAuthzLevelObjpEntireTableFree (
        IN PRTL_GENERIC_TABLE   pAuthzObjTable
        )
/*++

Routine Description:

    This function frees all entries contained within a GENERIC_TABLE.

Arguments:

    AuthzObjTable   - pointer to the Generic Table structure

Return Value:

    None.

--*/
{
    ULONG NumElements;
    PVOID RestartKey;
    PAUTHZLEVELTABLERECORD pAuthzObjRecord;


    //
    // Enumerate through all records and close the registry handles.
    //
    RestartKey = NULL;
    for (pAuthzObjRecord = (PAUTHZLEVELTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    pAuthzObjTable, &RestartKey);
         pAuthzObjRecord != NULL;
         pAuthzObjRecord = (PAUTHZLEVELTABLERECORD)
            RtlEnumerateGenericTableWithoutSplaying(
                    pAuthzObjTable, &RestartKey)
         )
    {
        SaferpLevelObjpCleanupEntry(pAuthzObjRecord);
    }



    //
    // Now iterate through the table again and free all of the
    // elements themselves.
    //
    NumElements = RtlNumberGenericTableElements(pAuthzObjTable);

    while ( NumElements-- > 0 ) {
        // Delete all elements.  Note that we pass NULL as the element
        // to delete because our compare function is smart enough to
        // allow treatment of NULL as a wildcard element.
        BOOL retval = RtlDeleteElementGenericTable( pAuthzObjTable, NULL);
        ASSERT(retval == TRUE);
    }
}


PAUTHZLEVELTABLERECORD NTAPI
CodeAuthzLevelObjpLookupByLevelId (
        IN PRTL_GENERIC_TABLE      AuthzObjTable,
        IN DWORD                   dwLevelId
        )
/*++

Routine Description:

    This function searches for a given Level within a GENERIC_TABLE.

Arguments:

    AuthzObjTable   - pointer to the Generic Table structure

    dwLevelId       - the DWORD Level identifier to search for.

Return Value:

    On success, returns a pointer to the matching level record
    if it was found within the table, otherwise returns NULL.

--*/
{
    AUTHZLEVELTABLERECORD AuthzObjTableRec;

    RtlZeroMemory(&AuthzObjTableRec, sizeof(AUTHZLEVELTABLERECORD));
    AuthzObjTableRec.dwLevelId = dwLevelId;

    return (PAUTHZLEVELTABLERECORD)
        RtlLookupElementGenericTable(AuthzObjTable,
                     (PVOID) &AuthzObjTableRec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safeinit.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    SafeInit.c        (WinSAFER Initialization)

Abstract:

    This module implements the WinSAFER APIs to initialize and
    deinitialize all housekeeping and handle tracking structures.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzInitialize                     (privately exported)
    SaferiChangeRegistryScope            (privately exported)

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include <winsafer.rh>
#include "saferp.h" 
 

//#define SAFER_REGISTRY_NOTIFICATIONS


//
// Controls the maximum number of level handles that we will
// permit to be opened at any time.
//
#define MAXIMUM_LEVEL_HANDLES 64



//
// Various globals that are used for the cache of levels and
// identities so that we do not need to go to the registry each time.
//
BOOLEAN g_bInitializedFirstTime = FALSE;

CRITICAL_SECTION g_TableCritSec;
HANDLE g_hKeyCustomRoot;
DWORD g_dwKeyOptions;

DWORD g_dwLevelHandleSequence = 1;         // monotonically increasing
DWORD g_dwNumHandlesAllocated = 0;         // Number of outstanding handles


//
// All of the following global variables are cached settings that are
// read and parsed from the policy the first time it is needed.
// All of the variables within this block should be considered "stale"
// when the g_bNeedCacheReload flag is TRUE.
//
BOOLEAN g_bNeedCacheReload;         // indicates the following vars are stale.

RTL_GENERIC_TABLE g_CodeLevelObjTable;
RTL_GENERIC_TABLE g_CodeIdentitiesTable;
RTL_HANDLE_TABLE g_LevelHandleTable;

BOOLEAN g_bHonorScopeUser;

PAUTHZLEVELTABLERECORD g_DefaultCodeLevel;        // effective
PAUTHZLEVELTABLERECORD g_DefaultCodeLevelUser;
PAUTHZLEVELTABLERECORD g_DefaultCodeLevelMachine;
LARGE_INTEGER g_SaferPolicyTimeStamp;


//
// Handles used to receive registry change notifications against the
// currently loaded policy and invalidate the internal cache.
//
#ifdef SAFER_REGISTRY_NOTIFICATIONS
HANDLE g_hRegNotifyEvent;           // from CreateEvent
HANDLE g_hWaitNotifyObject;         // from RegisterWaitForSingleObject
HANDLE g_hKeyNotifyBase1, g_hKeyNotifyBase2;
#endif



NTSTATUS NTAPI
SaferpSetSingleIdentificationPath(
        IN BOOLEAN bAllowCreation,
        IN OUT PAUTHZIDENTSTABLERECORD pIdentRecord,
        IN PSAFER_PATHNAME_IDENTIFICATION pIdentChanges,
        IN BOOL UpdateCache
        );


FORCEINLINE BOOLEAN
CodeAuthzpIsPowerOfTwo(
        ULONG ulValue
        )
/*++

Routine Description:

    Determines if the specified value is a whole power of 2.
    (ie, exactly one of the following: 1, 2, 4, 8, 16, 32, 64, ...)

Arguments:

    ulValue - Integer value to test.

Return Value:

    Returns TRUE on success, FALSE on failure.

--*/
{
    while (ulValue != 0) {
        if (ulValue & 1) {
            ulValue >>= 1;
            break;
        }
        ulValue >>= 1;
    }
    return (ulValue == 0);
}


FORCEINLINE ULONG
CodeAuthzpMakePowerOfTwo(
        ULONG ulValue
        )
/*++

Routine Description:

    Rounds the specified number up to the next whole power of 2.
    (ie, exactly one of the following: 1, 2, 4, 8, 16, 32, 64, ...)

Arguments:

    ulValue - Integer value to operate on.

Return Value:

    Returns the rounded result.

--*/
{
    if (ulValue) {
        ULONG ulOriginal = ulValue;
        ULONG bitmask;
        for (bitmask = 1; ulValue != 0 && bitmask != 0 &&
             (ulValue & ~bitmask) != 0; bitmask <<= 1) {
            ulValue = ulValue & ~bitmask;
        }
        ASSERTMSG("failed to make a power of two",
                  CodeAuthzpIsPowerOfTwo(ulValue));
        if (ulOriginal > ulValue) {
            // if we ended up rounding down, then round it up!
            ulValue <<= 1;
        }
        ASSERT(ulValue >= ulOriginal);
    }
    return ulValue;
}




BOOLEAN
CodeAuthzInitialize (
    IN HANDLE Handle,
    IN DWORD Reason,
    IN PVOID Reserved
    )
/*++

Routine Description:

    This is the callback procedure used by the Advapi initialization
    and deinitialization.

Arguments:

    Handle -

    Reason -

    Reserved -

Return Value:

    Returns TRUE on success, FALSE on failure.

--*/
{
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(Handle);
    if (Reason == DLL_PROCESS_ATTACH) {
        Status = CodeAuthzInitializeGlobals();
        if (!NT_SUCCESS(Status)) return FALSE;
    } else if (Reason == DLL_PROCESS_DETACH) {
        CodeAuthzDeinitializeGlobals();
    }
    return TRUE;
}


#ifdef SAFER_REGISTRY_NOTIFICATIONS
static VOID NTAPI
SaferpRegistryNotificationRegister(VOID)
{
    if (g_hRegNotifyEvent != NULL)
    {
        // Note that it is okay to call RNCKV again on the same
        // registry handle even if there is still an outstanding
        // change notification registered.
        if (g_hKeyNotifyBase1 != NULL) {
            RegNotifyChangeKeyValue(
                g_hKeyNotifyBase1, TRUE,
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                g_hRegNotifyEvent,
                TRUE);
        }
        if (g_hKeyNotifyBase2 != NULL) {
            RegNotifyChangeKeyValue(
                g_hKeyNotifyBase2, TRUE,
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                g_hRegNotifyEvent,
                TRUE);
        }
    }
}

static VOID NTAPI
SaferpRegistryNotificationCallback (PVOID pvArg1, BOOLEAN bArg2)
{
    UNREFERENCED_PARAMETER(pvArg1);
    UNREFERENCED_PARAMETER(bArg2);
    g_bNeedCacheReload = TRUE;
}
#endif


NTSTATUS NTAPI
CodeAuthzInitializeGlobals(VOID)
/*++

Routine Description:

    Performs one-time startup operations that should be done before
    any other handle or cache table operations are attempted.

Arguments:

    nothing

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    ULONG ulHandleEntrySize;


    if (g_bInitializedFirstTime) {
        // Already initialized.
        return STATUS_SUCCESS;
    }


    //
    // Initialize a bunch of tables for their first usage.
    //
    Status = RtlInitializeCriticalSection(&g_TableCritSec);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    g_bInitializedFirstTime = g_bNeedCacheReload = TRUE;
    CodeAuthzLevelObjpInitializeTable(&g_CodeLevelObjTable);
    CodeAuthzGuidIdentsInitializeTable(&g_CodeIdentitiesTable);
    g_hKeyCustomRoot = NULL;
    g_dwKeyOptions = 0;


    //
    // Initialize the table that will be used to track opened
    // WinSafer Level handles.  Note that RtlInitializeHandleTable
    // requires a structure size that is a whole power of 2.
    //
    ulHandleEntrySize = CodeAuthzpMakePowerOfTwo(sizeof(AUTHZLEVELHANDLESTRUCT));

    RtlInitializeHandleTable(
            MAXIMUM_LEVEL_HANDLES,
            ulHandleEntrySize,          // was sizeof(AUTHZLEVELHANDLESTRUCT)
            &g_LevelHandleTable);
    g_dwNumHandlesAllocated = 0;


#ifdef SAFER_REGISTRY_NOTIFICATIONS
    //
    // Create the event to catch modifications to the registry changes.
    // This allows us to notice policy changes and reload as necessary.
    //
    g_hRegNotifyEvent = CreateEvent(
              NULL,     // Security Descriptor
              TRUE,     // reset type
              FALSE,    // initial state
              NULL      // object name
            );
    if (g_hRegNotifyEvent != INVALID_HANDLE_VALUE) {
         if (!RegisterWaitForSingleObject(
                &g_hWaitNotifyObject,
                g_hRegNotifyEvent,
                SaferpRegistryNotificationCallback,
                NULL,
                INFINITE,
                WT_EXECUTEINWAITTHREAD))
         {
             CloseHandle(g_hRegNotifyEvent);
             g_hRegNotifyEvent = g_hWaitNotifyObject = NULL;
         }
    } else {
        g_hRegNotifyEvent = g_hWaitNotifyObject = NULL;
    }
    g_hKeyNotifyBase1 = g_hKeyNotifyBase2 = NULL;
#endif


    return STATUS_SUCCESS;
}


VOID NTAPI
CodeAuthzDeinitializeGlobals(VOID)
/*++

Routine Description:

    Performs one-time deinitialization operations.

Arguments:

    nothing

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    if (g_bInitializedFirstTime) {
#ifdef SAFER_REGISTRY_NOTIFICATIONS
        if (g_hWaitNotifyObject != NULL) {
            UnregisterWait(g_hWaitNotifyObject);
            CloseHandle(g_hWaitNotifyObject);
        }
        if (g_hRegNotifyEvent != NULL) {
            CloseHandle(g_hRegNotifyEvent);
        }
        if (g_hKeyNotifyBase1 != NULL) {
            NtClose(g_hKeyNotifyBase1);
        }
        if (g_hKeyNotifyBase2 != NULL) {
            NtClose(g_hKeyNotifyBase2);
        }
#endif
        CodeAuthzLevelObjpEntireTableFree(&g_CodeLevelObjTable);
        CodeAuthzGuidIdentsEntireTableFree(&g_CodeIdentitiesTable);
        RtlDestroyHandleTable(&g_LevelHandleTable);
        g_dwNumHandlesAllocated = 0;
        if (g_hKeyCustomRoot != NULL) {
            NtClose(g_hKeyCustomRoot);
            g_hKeyCustomRoot = NULL;
            g_dwKeyOptions = 0;
        }
        g_bInitializedFirstTime = FALSE;
        RtlDeleteCriticalSection(&g_TableCritSec);
    }
}


BOOL WINAPI
SaferiChangeRegistryScope(
        IN HKEY     hKeyCustomRoot OPTIONAL,
        IN DWORD    dwKeyOptions
        )
/*++

Routine Description:

    Closes and invalidates all currently open level handles and
    reloads all cached levels and identities.  The outstanding
    handles are closed and freed during this operation.

    If a hKeyCustomRoot is specified, all future level and identity
    operations will be performed on the levels and identies defined
    within that registry scope.  Otherwise, such operations will be
    done on the normal HKLM/HKCU policy store locations.

Arguments:

    hKeyCustomRoot - If specified, this should be an opened
            registry key handle to the base of the policy
            storage that should be used for all future operations.

    dwKeyOptions - Additional flags that should be passed in with
            the dwOptions parameter to any RegCreateKey operations,
            such as REG_OPTION_VOLATILE.

Return Value:

    Returns TRUE on success, FALSE on failure.  On error, GetLastError()
    will return a more specific indicator of the nature of the failure.

--*/

{
    NTSTATUS Status;

    Status = CodeAuthzReloadCacheTables(
                    (HANDLE) hKeyCustomRoot,
                    dwKeyOptions,
                    FALSE
                    );
    if (NT_SUCCESS(Status)) {
        return TRUE;
    } else {
        BaseSetLastNTError(Status);
        return FALSE;
    }
}


NTSTATUS NTAPI
CodeAuthzReloadCacheTables(
        IN HANDLE   hKeyCustomRoot OPTIONAL,
        IN DWORD    dwKeyOptions,
        IN BOOLEAN  bImmediateLoad
        )
/*++

Routine Description:

    Closes and invalidates all currently open level handles and
    reloads all cached levels and identities.  The outstanding
    handles are closed and freed during this operation.

    If a hKeyCustomRoot is specified, all future level and identity
    operations will be performed on the levels and identies defined
    within that registry scope.  Otherwise, such operations will be
    done on the normal HKLM/HKCU policy store locations.

Arguments:

    hKeyCustomRoot - If specified, this should be an opened
            registry key handle to the base of the policy
            storage that should be used for all future operations.

    bPopulateDefaults - If TRUE, then the default set of Level definitions
            will be inserted into the Registry if no existing Levels
            were found at the specified scope.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;


    //
    // Ensure that the general globals have been initialized.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);


    //
    // Initialize and blank out the tables we will be using.
    //
    CodeAuthzLevelObjpEntireTableFree(&g_CodeLevelObjTable);
    CodeAuthzGuidIdentsEntireTableFree(&g_CodeIdentitiesTable);


    //
    // Increment the sequence number.  This has the effect of
    // immediately invalidating all currently open handles, but
    // allows the caller to still close them properly.  Any
    // attempt by the caller to actually use one of the old
    // handles will result in a STATUS_INVALID_HANDLE error.
    //
    g_dwLevelHandleSequence++;


    //
    // Reset the rest of our variables.
    //
    if (g_hKeyCustomRoot != NULL) {
        NtClose(g_hKeyCustomRoot);
        g_hKeyCustomRoot = NULL;
    }
#ifdef SAFER_REGISTRY_NOTIFICATIONS
    if (g_hKeyNotifyBase1 != NULL) {
        NtClose(g_hKeyNotifyBase1);
        g_hKeyNotifyBase1 = NULL;
    }
    if (g_hKeyNotifyBase2 != NULL) {
        NtClose(g_hKeyNotifyBase2);
        g_hKeyNotifyBase2 = NULL;
    }
#endif
    g_DefaultCodeLevel = g_DefaultCodeLevelMachine =
            g_DefaultCodeLevelUser = NULL;
    g_bHonorScopeUser = FALSE;
    g_bNeedCacheReload = FALSE;
    g_dwKeyOptions = 0;



    //
    // Save a duplicated copy of the custom registry handle.
    //
    if (ARGUMENT_PRESENT(hKeyCustomRoot))
    {
        const static UNICODE_STRING SubKeyName = { 0, 0, NULL };
        OBJECT_ATTRIBUTES ObjectAttributes;

        InitializeObjectAttributes(&ObjectAttributes,
                                   (PUNICODE_STRING) &SubKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   hKeyCustomRoot,
                                   NULL
                                   );
        Status = NtOpenKey(&g_hKeyCustomRoot,
                           KEY_READ,
                           &ObjectAttributes);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
        g_dwKeyOptions = dwKeyOptions;
#ifdef SAFER_REGISTRY_NOTIFICATIONS
#error "open for KEY_NOTIFY"
#endif
    }
    else
    {
#ifdef SAFER_REGISTRY_NOTIFICATIONS
#endif
    }

    //
    // Perform the actual load now, if needed.
    //
    g_bNeedCacheReload = TRUE;
    if (bImmediateLoad) {
        Status = CodeAuthzpImmediateReloadCacheTables();
    } else {
        Status = STATUS_SUCCESS;
    }



ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    return Status;
}



NTSTATUS NTAPI
CodeAuthzpImmediateReloadCacheTables(
        VOID
        )
/*++

Routine Description:

    Assumes that CodeAuthzReloadCacheTables() has already been called
    with the specified scope already, and that this function has not
    yet been called since the last reload.

Arguments:

    none

Return Value:

    returns STATUS_SUCCESS on successful completion.

--*/
{
    NTSTATUS Status;
    DWORD dwFlagValue;


    ASSERT(g_TableCritSec.OwningThread == UlongToHandle(GetCurrentThreadId()));
    ASSERT(RtlIsGenericTableEmpty(&g_CodeIdentitiesTable) &&
            RtlIsGenericTableEmpty(&g_CodeLevelObjTable));
    ASSERT(g_bNeedCacheReload != FALSE);


    //
    // Need to clear the cache reload flag, otherwise we
    // might cause undesired infinite recursion later with
    // some of the CodeAuthzPol_xxx functions.
    //
    g_bNeedCacheReload = FALSE;


    //
    // Begin loading the new policy settings from the specified location.
    //
    if (g_hKeyCustomRoot != NULL)
    {
        //
        // Read in the definitions of all WinSafer Levels from
        // the custom registry root specified.
        //
        CodeAuthzLevelObjpLoadTable(
                &g_CodeLevelObjTable,
                SAFER_SCOPEID_REGISTRY,
                g_hKeyCustomRoot);

        //
        // The HonorScopeUser flag is not relevant when a custom
        // registry scope is used, but we set it to false anyways.
        //
        g_bHonorScopeUser = FALSE;


        //
        // Load the Code Identities from the custom registry root.
        //
        CodeAuthzGuidIdentsLoadTableAll(
                &g_CodeLevelObjTable,
                &g_CodeIdentitiesTable,
                SAFER_SCOPEID_REGISTRY,
                g_hKeyCustomRoot);

        //
        // Load the Default Level specified by the custom registry root.
        //
        Status = CodeAuthzPol_GetInfoRegistry_DefaultLevel(
                SAFER_SCOPEID_REGISTRY,
                sizeof(DWORD), &dwFlagValue, NULL);
        if (NT_SUCCESS(Status)) {
            g_DefaultCodeLevelMachine =
                CodeAuthzLevelObjpLookupByLevelId(
                        &g_CodeLevelObjTable, dwFlagValue);
        } else {
            g_DefaultCodeLevelMachine = NULL;
        }
        g_DefaultCodeLevelUser = NULL;
    }
    else   // !ARGUMENT_PRESENT(hKeyCustomRoot)
    {
        g_hKeyCustomRoot = NULL;

        //
        // Read in the definitions of all WinSafer Levels from
        // the HKEY_LOCAL_MACHINE registry scope.
        //
        CodeAuthzLevelObjpLoadTable(
                &g_CodeLevelObjTable,
                SAFER_SCOPEID_MACHINE,
                NULL);

        g_bHonorScopeUser = TRUE;

        //
        // Load in all Code Identities from the HKEY_LOCAL_MACHINE
        // and possibly the HKEY_CURRENT_USER scope too.
        //
        CodeAuthzGuidIdentsLoadTableAll(
                &g_CodeLevelObjTable,
                &g_CodeIdentitiesTable,
                SAFER_SCOPEID_MACHINE,
                NULL);

        if (g_bHonorScopeUser) {
            CodeAuthzGuidIdentsLoadTableAll(
                &g_CodeLevelObjTable,
                &g_CodeIdentitiesTable,
                SAFER_SCOPEID_USER,
                NULL);
        }

        //
        // Load the Default Level specified by the machine scope.
        //
        Status = CodeAuthzPol_GetInfoRegistry_DefaultLevel(
                SAFER_SCOPEID_MACHINE,
                sizeof(DWORD), &dwFlagValue, NULL);
        if (NT_SUCCESS(Status)) {
            g_DefaultCodeLevelMachine =
                CodeAuthzLevelObjpLookupByLevelId(
                        &g_CodeLevelObjTable, dwFlagValue);
        } else {
            g_DefaultCodeLevelMachine = NULL;
        }


        //
        // Load the Default Level specified by the user scope.
        //
        Status = CodeAuthzPol_GetInfoRegistry_DefaultLevel(
                SAFER_SCOPEID_USER,
                sizeof(DWORD), &dwFlagValue, NULL);
        if (NT_SUCCESS(Status)) {
            g_DefaultCodeLevelUser =
                CodeAuthzLevelObjpLookupByLevelId(
                        &g_CodeLevelObjTable, dwFlagValue);
        } else {
            g_DefaultCodeLevelUser = NULL;
        }
    }


    //
    // Compute the effective Default Level (take the least privileged).
    //
    CodeAuthzpRecomputeEffectiveDefaultLevel();

    GetSystemTimeAsFileTime((LPFILETIME) &g_SaferPolicyTimeStamp);


    //
    // Now that we have fully loaded the policy, set a change
    // notification hook so that we can be alerted to updates.
    //
#ifdef SAFER_REGISTRY_NOTIFICATIONS
    g_bNeedCacheReload = FALSE;
    SaferpRegistryNotificationRegister();
#endif


    return STATUS_SUCCESS;
}



VOID NTAPI
CodeAuthzpRecomputeEffectiveDefaultLevel(
            VOID
            )
/*++

Routine Description:

Arguments:

    nothing

Return Value:

    nothing.

--*/
{
    if (g_DefaultCodeLevelMachine != NULL &&
        g_DefaultCodeLevelUser != NULL &&
        g_bHonorScopeUser)
    {
        g_DefaultCodeLevel =
            (g_DefaultCodeLevelMachine->dwLevelId <
                g_DefaultCodeLevelUser->dwLevelId ?
             g_DefaultCodeLevelMachine : g_DefaultCodeLevelUser);
    } else if (g_DefaultCodeLevelMachine != NULL) {
        g_DefaultCodeLevel = g_DefaultCodeLevelMachine;
    } else if (g_bHonorScopeUser) {
        g_DefaultCodeLevel = g_DefaultCodeLevelUser;
    } else {
        g_DefaultCodeLevel = NULL;
    }

    //
    // If we still don't have a default Level, then try to pick
    // the Fully Trusted level as default.  It still might fail
    // in the case where the Fully Trusted level doesn't exist,
    // but that shouldn't ever happen.
    //
    if (!g_DefaultCodeLevel) {
        g_DefaultCodeLevel = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, SAFER_LEVELID_FULLYTRUSTED);
        // ASSERT(g_DefaultCodeLevel != NULL);
    }
}



NTSTATUS NTAPI
CodeAuthzpDeleteKeyRecursively(
        IN HANDLE               hBaseKey,
        IN PUNICODE_STRING      pSubKey OPTIONAL
        )
/*++

Routine Description:

    Recursively delete the key, including all child values and keys.

Arguments:

    hkey - the base registry key handle to start from.

    pszSubKey - subkey to delete from.

Return Value:

    Returns ERROR_SUCCESS on success, otherwise error.

--*/
{
    NTSTATUS Status;
    BOOLEAN bCloseSubKey;
    HANDLE hSubKey;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    PKEY_BASIC_INFORMATION pKeyBasicInfo;
    DWORD dwQueryBufferSize = 0, dwActualSize = 0;


    //
    // Open the subkey so we can enumerate any children
    //
    if (ARGUMENT_PRESENT(pSubKey) &&
        pSubKey->Buffer != NULL)
    {
        InitializeObjectAttributes(&ObjectAttributes,
                                      pSubKey,
                                      OBJ_CASE_INSENSITIVE,
                                      hBaseKey,
                                      NULL
                                     );
        Status = NtOpenKey(&hSubKey, KEY_READ | DELETE, &ObjectAttributes);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
        bCloseSubKey = TRUE;
    } else {
        hSubKey = hBaseKey;
        bCloseSubKey = FALSE;
    }



    //
    // To delete a registry key, we must first ensure that all
    // children subkeys are deleted (registry values do not need
    // to be deleted in order to delete the key itself).  To do
    // this we loop enumerate
    //

    dwQueryBufferSize = 256;
    pKeyBasicInfo = RtlAllocateHeap(RtlProcessHeap(), 0,
                                   dwQueryBufferSize);
    for (;;)
    {
        Status = NtEnumerateKey(
                hSubKey, 0, KeyBasicInformation,
                pKeyBasicInfo, dwQueryBufferSize, &dwActualSize);

        if (Status == STATUS_BUFFER_TOO_SMALL ||
            Status == STATUS_BUFFER_OVERFLOW)
        {
            if (dwActualSize <= dwQueryBufferSize) {
                ASSERT(FALSE);
                break;  // should not happen, so stop now.
            }
            if (pKeyBasicInfo != NULL) {
                RtlFreeHeap(RtlProcessHeap(), 0, pKeyBasicInfo);
            }
            dwQueryBufferSize = dwActualSize;       // request a little more.
            pKeyBasicInfo = RtlAllocateHeap(RtlProcessHeap(), 0,
                                           dwQueryBufferSize);
            if (!pKeyBasicInfo) {
                break;  // stop now, but we don't care about the error.
            }

            Status = NtEnumerateKey(
                    hSubKey, 0, KeyBasicInformation,
                    pKeyBasicInfo, dwQueryBufferSize, &dwActualSize);

        }

        if (Status == STATUS_NO_MORE_ENTRIES) {
            // we've finished deleting all subkeys, stop now.
            Status = STATUS_SUCCESS;
            break;
        }
        if (!NT_SUCCESS(Status) || !pKeyBasicInfo) {
            break;
        }


        UnicodeString.Buffer = pKeyBasicInfo->Name;
        UnicodeString.MaximumLength = (USHORT) pKeyBasicInfo->NameLength;
        UnicodeString.Length = (USHORT) (pKeyBasicInfo->NameLength - sizeof(WCHAR));
        Status = CodeAuthzpDeleteKeyRecursively(hSubKey, &UnicodeString);
        if (!NT_SUCCESS(Status)) {
            break;
        }
    }
    if (pKeyBasicInfo != NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, pKeyBasicInfo);
    }
    Status = NtDeleteKey(hSubKey);

    if (bCloseSubKey) {
        NtClose(hSubKey);
    }
    return Status;
}



NTSTATUS NTAPI
CodeAuthzpFormatLevelKeyPath(
        IN DWORD                    dwLevelId,
        IN OUT PUNICODE_STRING      UnicodeSuffix
        )
/*++

Routine Description:

    Internal function to generate the path to a given subkey within the
    WinSafer policy store for the storage of a given Level.  The
    resulting path can then be supplied to CodeAuthzpOpenPolicyRootKey

Arguments:

    dwLevelId - the LevelId to process.

    UnicodeSuffix - Specifies the output buffer.  The Buffer and
            MaximumLength fields must be supplied, but the Length
            field is ignored.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeTemp;


    if (!ARGUMENT_PRESENT(UnicodeSuffix)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }
    UnicodeSuffix->Length = 0;
    Status = RtlAppendUnicodeToString(
                    UnicodeSuffix,
                    SAFER_OBJECTS_REGSUBKEY L"\\");
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    UnicodeTemp.Buffer = &UnicodeSuffix->Buffer[
                UnicodeSuffix->Length / sizeof(WCHAR) ];
    UnicodeTemp.MaximumLength = (UnicodeSuffix->MaximumLength -
                                 UnicodeSuffix->Length);
    Status = RtlIntegerToUnicodeString(dwLevelId,
                                       10,
                                       &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    UnicodeSuffix->Length += UnicodeTemp.Length;


ExitHandler:
    return Status;
}



NTSTATUS NTAPI
CodeAuthzpFormatIdentityKeyPath(
        IN DWORD                    dwLevelId,
        IN LPCWSTR                  szIdentityType,
        IN REFGUID                  refIdentGuid,
        IN OUT PUNICODE_STRING      UnicodeSuffix
        )
/*++

Routine Description:

    Internal function to generate the path to a given subkey within the
    WinSafer policy store for the storage of a given Code Identity.  The
    resulting path can then be supplied to CodeAuthzpOpenPolicyRootKey

Arguments:

    dwLevelId - the LevelId to process.

    szIdentityType - should be one of the following string constants:
        SAFER_PATHS_REGSUBKEY,
        SAFER_HASHMD5_REGSUBKEY,
        SAFER_SOURCEURL_REGSUBKEY

    refIdentGuid - the GUID of the code identity.

    UnicodeSuffix - Specifies the output buffer.  The Buffer and
            MaximumLength fields must be supplied, but the Length
            field is ignored.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeTemp;


    if (!ARGUMENT_PRESENT(refIdentGuid)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if (!ARGUMENT_PRESENT(UnicodeSuffix)) {
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }

    UnicodeSuffix->Length = 0;
    Status = RtlAppendUnicodeToString(
                    UnicodeSuffix,
                    SAFER_CODEIDS_REGSUBKEY L"\\");
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    UnicodeTemp.Buffer = &UnicodeSuffix->Buffer[
                UnicodeSuffix->Length / sizeof(WCHAR) ];
    UnicodeTemp.MaximumLength = (UnicodeSuffix->MaximumLength -
                                 UnicodeSuffix->Length);
    Status = RtlIntegerToUnicodeString(dwLevelId,
                                       10,
                                       &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    UnicodeSuffix->Length += UnicodeTemp.Length;
    Status = RtlAppendUnicodeToString(
                    UnicodeSuffix,
                    L"\\");
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }

    Status = RtlAppendUnicodeToString(
                    UnicodeSuffix,
                    szIdentityType);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }

    Status = RtlAppendUnicodeToString(
                    UnicodeSuffix,
                    L"\\");
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }

    Status = RtlStringFromGUID(refIdentGuid, &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = RtlAppendUnicodeStringToString(
                    UnicodeSuffix, &UnicodeTemp);
    RtlFreeUnicodeString(&UnicodeTemp);

ExitHandler:
    return Status;
}



NTSTATUS NTAPI
CodeAuthzpOpenPolicyRootKey(
        IN DWORD        dwScopeId,
        IN HANDLE       hKeyCustomBase OPTIONAL,
        IN LPCWSTR      szRegistrySuffix OPTIONAL,
        IN ACCESS_MASK  DesiredAccess,
        IN BOOLEAN      bCreateKey,
        OUT HANDLE     *OpenedHandle
        )
/*++

Routine Description:

    Internal function to generate the path to a given subkey within the
    WinSAFER policy store within the registry and then open that key.
    The specified subkeys can optionally be automatically created if
    they do not already exist.

Arguments:

    dwScopeId - input scope identifier.  This must be one of
        SAFER_SCOPEID_MACHINE or SAFER_SCOPEID_USER or SAFER_SCOPEID_REGISTRY.

    hKeyCustomBase - only used if dwScopeId is SAFER_SCOPEID_REGISTRY.

    szRegistrySuffix - optionally specifies a subkey name to open under
        the scope being referenced.

    DesiredAccess - specifies the access that should be used to open
        the registry key.  For example, use KEY_READ for read access.

    bCreateKey - if true, the key will be created if it does not exist.

    OpenedHandle - pointer that recieves the opened handle.  This handle
        must be closed by the caller with NtClose()

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    WCHAR KeyPathBuffer[MAX_PATH];
    HANDLE hKeyPolicyBase;
    UNICODE_STRING SubKeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;

    USHORT KeyLength = 0;
        
    //
    // Verify that we were given a pointer to write the final handle to.
    //
    if (!ARGUMENT_PRESENT(OpenedHandle)) {
        return STATUS_INVALID_PARAMETER_4;
    }

    if (ARGUMENT_PRESENT(szRegistrySuffix)) 
    {
        KeyLength = (wcslen(szRegistrySuffix) + 1 ) * sizeof(WCHAR);
    }

    //
    // Evaluate the Scope and build the full registry path that we will
    // use to open a handle to this key.
    //
    SubKeyName.Buffer = KeyPathBuffer;
    SubKeyName.Length = 0;
    SubKeyName.MaximumLength = sizeof(KeyPathBuffer);

    if (dwScopeId == SAFER_SCOPEID_MACHINE)
    {
        KeyLength += sizeof(WCHAR) + sizeof(SAFER_HKCU_REGBASE) + sizeof(L"\\Registry\\Machine\\");

        if (SubKeyName.MaximumLength < KeyLength)
        {
            SubKeyName.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0,
                                           KeyLength);
            if (SubKeyName.Buffer == NULL)
            {
                return STATUS_NO_MEMORY;
            }
            SubKeyName.MaximumLength = KeyLength;
        }
        Status = RtlAppendUnicodeToString(&SubKeyName,
                L"\\Registry\\Machine\\" SAFER_HKLM_REGBASE );
        hKeyPolicyBase = NULL;
    }
    else if (dwScopeId == SAFER_SCOPEID_USER)
    {
        UNICODE_STRING CurrentUserKeyPath;

        Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );
        if (NT_SUCCESS( Status ) )
        {
            KeyLength += CurrentUserKeyPath.Length + sizeof(WCHAR) + 
                          sizeof(SAFER_HKCU_REGBASE);

            if (SubKeyName.MaximumLength < KeyLength)
            {
                SubKeyName.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0,
                                               KeyLength);

                if (SubKeyName.Buffer == NULL)
                {
                    return STATUS_NO_MEMORY;
                }

                SubKeyName.MaximumLength = KeyLength;
            }

            Status = RtlAppendUnicodeStringToString(
                        &SubKeyName, &CurrentUserKeyPath );
            RtlFreeUnicodeString( &CurrentUserKeyPath );
        }
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        Status = RtlAppendUnicodeToString( &SubKeyName,
                L"\\" SAFER_HKCU_REGBASE );
        if (!NT_SUCCESS( Status )) {
            goto Cleanup;
        }
        hKeyPolicyBase = NULL;
    }
    else if (dwScopeId == SAFER_SCOPEID_REGISTRY)
    {
        ASSERT(hKeyCustomBase != NULL);

        hKeyPolicyBase = hKeyCustomBase;

        if (SubKeyName.MaximumLength < KeyLength)
        {
            SubKeyName.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0,
                                           KeyLength);
            if (SubKeyName.Buffer == NULL)
            {
                return STATUS_NO_MEMORY;
            }
            SubKeyName.MaximumLength = KeyLength;
        }
    }
    else {
        return STATUS_INVALID_PARAMETER_1;
    }


    //
    // Append whatever suffix we're supposed to append if one was given.
    //
    if (ARGUMENT_PRESENT(szRegistrySuffix)) {
        if (SubKeyName.Length > 0)
        {
            // We are appending a suffix to a partial path, so
            // make sure there is at least a single backslash
            // dividing the two strings (extra are fine).
            if (*szRegistrySuffix != L'\\') {
                Status = RtlAppendUnicodeToString(&SubKeyName, L"\\");
                if (!NT_SUCCESS(Status)) {
                    goto Cleanup;
                }
            }
        } else if (hKeyPolicyBase != NULL) {
            // Otherwise we are opening a key relative to a custom
            // specified key, and the supplied suffix happens to be
            // the first part of the path, so ensure there are no
            // leading backslashes.
            while (*szRegistrySuffix != UNICODE_NULL &&
                   *szRegistrySuffix == L'\\') szRegistrySuffix++;
        }

        Status = RtlAppendUnicodeToString(&SubKeyName, szRegistrySuffix);
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
    }

    //
    // Open a handle to the registry path that we are supposed to open.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                                  &SubKeyName,
                                  OBJ_CASE_INSENSITIVE,
                                  hKeyPolicyBase,
                                  NULL
                                 );
    if (bCreateKey) {
        Status = NtCreateKey(OpenedHandle, DesiredAccess,
                             &ObjectAttributes, 0, NULL,
                             g_dwKeyOptions, NULL);
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            BOOLEAN bAtLeastOnce;
            USHORT uIndex, uFinalLength;

            //
            // If we fail on the first try to open the full path, then
            // it is possible that one or more of the parent keys did
            // not already exist, so we have to retry for each.
            //
            uFinalLength = (SubKeyName.Length / sizeof(WCHAR));
            bAtLeastOnce = FALSE;
            for (uIndex = 0; uIndex < uFinalLength; uIndex++) {
                if (SubKeyName.Buffer[uIndex] == L'\\' ) {
                    HANDLE hTempKey;
                    SubKeyName.Length = uIndex * sizeof(WCHAR);
                    Status = NtCreateKey(&hTempKey, DesiredAccess,
                                         &ObjectAttributes, 0, NULL,
                                         g_dwKeyOptions, NULL);
                    if (NT_SUCCESS(Status)) {
                        NtClose(hTempKey);
                    } else if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
                        // one of the keys leading up here still failed.
                        break;
                    }
                    bAtLeastOnce = TRUE;
                }
            }

            if (bAtLeastOnce) {
                SubKeyName.Length = uFinalLength * sizeof(WCHAR);
                Status = NtCreateKey(OpenedHandle, DesiredAccess,
                                     &ObjectAttributes, 0, NULL,
                                     g_dwKeyOptions, NULL);
            }
        }

    } else {
        Status = NtOpenKey(OpenedHandle, DesiredAccess,
                           &ObjectAttributes);
    }

Cleanup:

    if ((SubKeyName.Buffer != NULL) && (SubKeyName.Buffer != KeyPathBuffer))
    {
        RtlFreeHeap(RtlProcessHeap(), 0, SubKeyName.Buffer);
    }

    return Status;
}

BOOL WINAPI
SaferiPopulateDefaultsInRegistry(
        IN HKEY     hKeyBase,
        OUT BOOL    *pbSetDefaults
        )
/*++

Routine Description:

    Winsafer UI will use this API to populate default winsafer values 
    in the registry as follows:
                                                                             
    DefaultLevel: SAFER_LEVELID_FULLYTRUSTED
    ExecutableTypes: initialized to the latest list of attachment types
    TransparentEnabled: 1
    Policy Scope: 0 (enable policy for admins)
    Level descriptions
    
    
Arguments:

    hKeyBase - This should be an opened registry key handle to the 
               base of the policy storage that should be used for 
               to populate the defaults into. This handle should be
               opened with a miniumum of KEY_SET_VALUE access.
        
   pbSetDefaults - Pointer to a boolean that gets set when 
                   default values are actually set (UI uses this).

Return Value:

    returns STATUS_SUCCESS on successful completion.

--*/

{
    
#define SAFERP_WINDOWS L"%HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRoot%" 
    GUID WindowsGuid = SAFERP_WINDOWS_GUID;

#define SAFERP_WINDOWS_EXE L"%HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRoot%\\*.exe" 
    GUID WindowsExeGuid = SAFERP_WINDOWS_EXE_GUID;

#define SAFERP_SYSTEM_EXE L"%HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SystemRoot%\\System32\\*.exe" 
    GUID SystemExeGuid = SAFERP_SYSTEM_EXE_GUID;

#define SAFERP_PROGRAMFILES L"%HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ProgramFilesDir%"
    GUID ProgramFilesGuid = SAFERP_PROGRAMFILES_GUID;

    NTSTATUS    Status;
    DWORD   dwValueValue;
    PWSTR   pmszFileTypes = NULL;
    UNICODE_STRING ValueName;
    ULONG   uResultLength = 0;
    KEY_NAME_INFORMATION   pKeyInformation;
    UNICODE_STRING ucSubKeyName;
    WCHAR   szSubKeyPath[] = L"Software\\Policies\\Microsoft\\Windows\\Safer\\CodeIdentifiers\0";
    OBJECT_ATTRIBUTES ObjectAttributes;
    HKEY    hKeyFinal = NULL;
    HANDLE hAdvApiInst;
    AUTHZIDENTSTABLERECORD LocalRecord = {0};
    SAFER_PATHNAME_IDENTIFICATION PathIdent = {0};

    DWORD dwLevelIndex;
    BYTE QueryBuffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 64];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION) QueryBuffer;
    DWORD dwActualSize = 0;

    if (!ARGUMENT_PRESENT(hKeyBase) || !ARGUMENT_PRESENT(pbSetDefaults)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }

    *pbSetDefaults = TRUE;
    
    RtlInitUnicodeString(&ucSubKeyName, szSubKeyPath);

    InitializeObjectAttributes(&ObjectAttributes,
                               (PUNICODE_STRING) &ucSubKeyName,
                               OBJ_CASE_INSENSITIVE,
                               hKeyBase,
                               NULL
                               );

    Status = NtOpenKey(&hKeyFinal,
                       KEY_WRITE | KEY_READ,
                       &ObjectAttributes);

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        
        Status = NtCreateKey(&hKeyFinal, 
                             KEY_WRITE | KEY_READ,
                             &ObjectAttributes, 
                             0, 
                             NULL,
                             REG_OPTION_NON_VOLATILE, 
                             NULL);
    }


    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }

    //
    // check if any default value is absent
    // if so, populate all the defaults again
    // if not, do not populate any values and return
    //
    
    RtlInitUnicodeString(&ValueName, SAFER_DEFAULTOBJ_REGVALUE);
    
    Status = NtQueryValueKey(
                 hKeyFinal,
                 (PUNICODE_STRING) &ValueName,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        goto PopulateAllDefaults;
    }

    RtlInitUnicodeString(&ValueName, SAFER_TRANSPARENTENABLED_REGVALUE);
    
    Status = NtQueryValueKey(
                 hKeyFinal,
                 (PUNICODE_STRING) &ValueName,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        goto PopulateAllDefaults;
    }

    RtlInitUnicodeString(&ValueName, SAFER_POLICY_SCOPE);

    Status = NtQueryValueKey(
                 hKeyFinal,
                 (PUNICODE_STRING) &ValueName,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        goto PopulateAllDefaults;
    }
    
    RtlInitUnicodeString(&ValueName, SAFER_EXETYPES_REGVALUE);

    Status = NtQueryValueKey(
                 hKeyFinal,
                 (PUNICODE_STRING) &ValueName,
                 KeyValuePartialInformation,
                 pKeyValueInfo, 
                 sizeof(QueryBuffer), 
                 &dwActualSize
                 );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        goto PopulateAllDefaults;
    }

    //
    // all default values are present or there was an error
    // querying one of the values no need to populate any
    //

    *pbSetDefaults = FALSE;

    goto ExitHandler;

PopulateAllDefaults:

    RtlInitUnicodeString(&ValueName, SAFER_DEFAULTOBJ_REGVALUE);

    dwValueValue = SAFER_LEVELID_FULLYTRUSTED;
    
    Status = NtSetValueKey(hKeyFinal,
                           &ValueName,
                           0,
                           REG_DWORD,
                           &dwValueValue,
                           sizeof(DWORD));

    if (!NT_SUCCESS(Status))
        goto ExitHandler;

    dwValueValue = 1;

    RtlInitUnicodeString(&ValueName, SAFER_TRANSPARENTENABLED_REGVALUE);
    
    Status = NtSetValueKey(hKeyFinal,
                           &ValueName,
                           0,
                           REG_DWORD,
                           &dwValueValue,
                           sizeof(DWORD));

    if (!NT_SUCCESS(Status))
        goto ExitHandler;

    dwValueValue = 0;

    RtlInitUnicodeString(&ValueName, SAFER_POLICY_SCOPE);
    
    Status = NtSetValueKey(hKeyFinal,
                           &ValueName,
                           0,
                           REG_DWORD,
                           &dwValueValue,
                           sizeof(DWORD));

    if (!NT_SUCCESS(Status))
        goto ExitHandler;


    //
    // prepare the MULTI_SZ value to write to the registry
    //

    RtlInitUnicodeString(&ValueName, SAFER_EXETYPES_REGVALUE);

    pmszFileTypes = RtlAllocateHeap(RtlProcessHeap(), 
                                    0,
                                    sizeof(SAFER_DEFAULT_EXECUTABLE_FILE_TYPES)
                                    );

    if (pmszFileTypes) {
            
        RtlCopyMemory(pmszFileTypes, 
                      SAFER_DEFAULT_EXECUTABLE_FILE_TYPES, 
                      sizeof(SAFER_DEFAULT_EXECUTABLE_FILE_TYPES));

        Status = NtSetValueKey(hKeyFinal,
                               &ValueName,
                               0,
                               REG_MULTI_SZ,
                               pmszFileTypes,
                               sizeof(SAFER_DEFAULT_EXECUTABLE_FILE_TYPES)
                               );

        RtlFreeHeap(RtlProcessHeap(), 
                    0, 
                    pmszFileTypes
                   );
    }

    else {

        Status = STATUS_NO_MEMORY;
        
        goto ExitHandler;

    }

    //
    // We now generate 4 rules so that the OS binaries are exempt.
    //   FULLY TRUSTED
    //     %windir%
    //     %windir%\*.exe
    //     %windir%\system32\*.exe
    //     %ProgramFiles%
    //


    LocalRecord.dwIdentityType = SaferIdentityTypeImageName;
    LocalRecord.dwLevelId = SAFER_LEVELID_FULLYTRUSTED;
    LocalRecord.dwScopeId = SAFER_SCOPEID_REGISTRY;
    LocalRecord.ImageNameInfo.bExpandVars = TRUE;
    LocalRecord.ImageNameInfo.dwSaferFlags = 0;
    RtlInitUnicodeString(&LocalRecord.ImageNameInfo.ImagePath, SAFERP_WINDOWS);
    LocalRecord.IdentGuid = WindowsGuid;

    PathIdent.header.cbStructSize = sizeof(SAFER_IDENTIFICATION_HEADER);
    PathIdent.header.dwIdentificationType = SaferIdentityTypeImageName;
    PathIdent.header.IdentificationGuid = LocalRecord.IdentGuid;
    PathIdent.dwSaferFlags = 0;
    PathIdent.ImageName = SAFERP_WINDOWS;
    PathIdent.Description[0] = L'\0';

    Status = SaferpSetSingleIdentificationPath(TRUE,
                                               &LocalRecord,
                                               &PathIdent,
                                               FALSE
                                               );
    if (!NT_SUCCESS(Status))
        goto ExitHandler;

    RtlInitUnicodeString(&LocalRecord.ImageNameInfo.ImagePath, SAFERP_WINDOWS_EXE);
    LocalRecord.IdentGuid = WindowsExeGuid;
    PathIdent.header.IdentificationGuid = LocalRecord.IdentGuid;
    PathIdent.ImageName = SAFERP_WINDOWS_EXE;

    Status = SaferpSetSingleIdentificationPath(TRUE,
                                               &LocalRecord,
                                               &PathIdent,
                                               FALSE
                                               );
    if (!NT_SUCCESS(Status))
        goto ExitHandler;

    RtlInitUnicodeString(&LocalRecord.ImageNameInfo.ImagePath, SAFERP_SYSTEM_EXE);
    LocalRecord.IdentGuid = SystemExeGuid;
    PathIdent.header.IdentificationGuid = LocalRecord.IdentGuid;
    PathIdent.ImageName = SAFERP_SYSTEM_EXE;

    Status = SaferpSetSingleIdentificationPath(TRUE,
                                               &LocalRecord,
                                               &PathIdent,
                                               FALSE
                                               );
    if (!NT_SUCCESS(Status))
        goto ExitHandler;

    RtlInitUnicodeString(&LocalRecord.ImageNameInfo.ImagePath, SAFERP_PROGRAMFILES);
    LocalRecord.IdentGuid = ProgramFilesGuid;
    PathIdent.header.IdentificationGuid = LocalRecord.IdentGuid;
    PathIdent.ImageName = SAFERP_PROGRAMFILES;

    Status = SaferpSetSingleIdentificationPath(TRUE,
                                               &LocalRecord,
                                               &PathIdent,
                                               FALSE
                                               );
    if (!NT_SUCCESS(Status))
        goto ExitHandler;

ExitHandler:

    if (hKeyFinal) {
        NtClose(hKeyFinal);
    }

    if (NT_SUCCESS(Status)) {
        return TRUE;
    } else {
        BaseSetLastNTError(Status);
        return FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safepath.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    SafePath.c        (WinSAFER Path Comparison)

Abstract:

    This module implements the WinSAFER APIs that evaluate the system
    policies to determine which Authorization Level has been configured
    to apply restrictions for a specified application or code library.

Author:

    Jeffrey Lawson (JLawson) - Nov 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzpCompareImagePath

Revision History:

    Created - Nov 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"



//
// Define the following value to use the "new" comparison logic,
// that includes asterick and question mark matching.
//
#define USE_NEW_WILDCARD_EVALUATION



//
// Convenient macros for doing filename pattern matching.
//
#define IS_UCASE_CHARS_EQUAL_U(ch1, ch2) (((ch1) == (ch2)) || (RtlUpcaseUnicodeChar(ch1) == RtlUpcaseUnicodeChar(ch2)))
#define IS_PATH_SEPARATOR_U(ch) (((ch) == L'\\') || ((ch) == L'/'))
#define IS_WILDCARD_CHAR_U(ch) ((ch) == L'*')
#define IS_QUESTION_CHAR_U(ch) ((ch) == L'?')
#define IS_DOT_CHAR_U(ch) ((ch) == L'.')



FORCEINLINE LPCWSTR CodeAuthzpFindSlash (
        IN LPCWSTR      string,
        IN USHORT       length
        )
/*++

Routine Description:

    Returns a pointer to the first instance of a forward or
    backward slash within the specified string buffer.

Arguments:

    string -

    length -

Return Value:

    Returns NULL if no backslashes or forward-slashes were found within
    the string.  Otherwise returns a pointer to the matching char.

--*/
{
    while (length-- > 0) {
         if (IS_PATH_SEPARATOR_U(*string)) return string;
         string++;
    }
    return NULL;
}




#ifdef USE_NEW_WILDCARD_EVALUATION
LONG NTAPI
__CodeAuthzpCompareImagePathHelper(
        IN LPCWSTR      wild,
        IN USHORT       wildlen,
        IN LPCWSTR      actual,
        IN USHORT       actuallen
        )
/*++

Routine Description:

    Evaluates a wildcard pattern against a specified pathname and
    indicates if they match.

Arguments:

    wild -

    wildlen -

    actual -

    actuallen -

Return Value:

    0 = no match
   -1 = match exactly
    1 = match with wildcard

--*/
{
    LONG lMatchResult = -1;

    ASSERT(ARGUMENT_PRESENT(wild) &&
           !CodeAuthzpFindSlash(wild, wildlen));
    ASSERT(ARGUMENT_PRESENT(actual) &&
           !CodeAuthzpFindSlash(actual, actuallen));

    for (;;) {
        // Check for terminating conditions.
        if (wildlen == 0) {
            if (actuallen == 0) {
                return lMatchResult;
            } else {
                ASSERT(actuallen > 0);
                return 0;
            }
        }

        // Evaluate the wildcard pattern.
        if (IS_WILDCARD_CHAR_U(*wild)) {
            USHORT matchcount;

            // Skip past the asterick (possibly multiple).
            do {
                wild++; wildlen--;
            } while ( wildlen > 0 && IS_WILDCARD_CHAR_U(*wild) );

            // Try expanding the asterick to be zero or more chars.
            for (matchcount = 0; ; matchcount++) {
                if (matchcount > actuallen) {
                    return 0;       // match failed.
                }
                if (0 != __CodeAuthzpCompareImagePathHelper(
                        wild, wildlen,
                        &actual[matchcount], actuallen - matchcount))
                {
                    actual += matchcount;
                    actuallen -= matchcount;
                    break;
                }
            }

            // We've encountered a wildcard char, so remember
            // that this is no longer an "exact" match.
            lMatchResult = 1;

        } else if (IS_QUESTION_CHAR_U(*wild)) {
            // Question marks will match any single character, except
            // periods.  Question marks will also match nothing when
            // we are already at the end of the filename or segment.

            if (actuallen > 0 && !IS_DOT_CHAR_U(*actual)) {
                actual++; actuallen--;
            }
            wild++; wildlen--;

            // We've encountered a wildcard char, so remember
            // that this is no longer an "exact" match.
            lMatchResult = 1;

        } else {
            if (actuallen < 1 ||
                !IS_UCASE_CHARS_EQUAL_U(*wild, *actual)) {
                return 0;
            }
            wild++; wildlen--;
            actual++; actuallen--;
        }
    }
}


LONG NTAPI
CodeAuthzpCompareUnicodeImagePath(
        IN PCUNICODE_STRING  wildcard,
        IN PCUNICODE_STRING  actual
        )
/*++

Routine Description:

    Evaluates a wildcard pattern against a specified pathname and
    indicates if they match.

Arguments:

    wildcard -

    actual -

Return Value:

    Returns 0 if the path fragment does not match the specified imagepath.
    Returns -1 if the fragment matches the imagepath _exactly_!
    Otherwise returns a postive integer representing the "depth" of the
    the match (number of matching subdirectories).  Greater values
    indicate a "deeper" directory match.

--*/

{
    USHORT wildindex = 0, actualindex = 0;
    LONG matchquality = 0;
    BOOLEAN bNoWildcardsFound = TRUE;

    ASSERT(ARGUMENT_PRESENT(wildcard) && wildcard->Buffer != NULL);
    ASSERT(ARGUMENT_PRESENT(actual) && actual->Buffer != NULL);
    for (;;)
    {
        ASSERT(wildindex <= wildcard->Length / sizeof(WCHAR));
        ASSERT(actualindex <= actual->Length / sizeof(WCHAR));

        if (wildindex == wildcard->Length / sizeof(WCHAR))
        {
            // We've reached the end of the wildcard but the actual string has 
            // not ended.
            if (actualindex < actual->Length / sizeof(WCHAR)) {
                return matchquality;
            }

            // The wildcard matched the filename but with inexact matches.
            // Return one more than the actual depth so that we can handle
            // non-qualified path matches as worse then these.
            if (!bNoWildcardsFound) {
                return (matchquality + 1);
            } 

            ASSERT(wildindex == wildcard->Length / sizeof(WCHAR));
            return -1;                  // exact match.
        }
        else if (IS_PATH_SEPARATOR_U(wildcard->Buffer[wildindex]))
        {
            if (!IS_PATH_SEPARATOR_U(actual->Buffer[actualindex])) {
                return 0;       // no match
            }

            // Skip forward to the start of the next component.
            do {
                wildindex++;
            } while ( wildindex < wildcard->Length / sizeof(WCHAR) &&
                      IS_PATH_SEPARATOR_U(wildcard->Buffer[wildindex]) );

            // Skip forward to the start of the next component.
            do {
                actualindex++;
            } while ( actualindex < actual->Length / sizeof(WCHAR) &&
                      IS_PATH_SEPARATOR_U(actual->Buffer[actualindex]) );
        }
        else
        {
            USHORT wildlen = 0, actuallen = 0;

            // Count the length of this component of the wildcard.
            while (wildindex + wildlen < (USHORT) (wildcard->Length / sizeof(WCHAR)) &&
                   !IS_PATH_SEPARATOR_U(wildcard->Buffer[wildindex + wildlen])) {
                wildlen++;
            }
            ASSERT(wildlen > 0);

            // Count the length of this component of the actual path.
            while (actualindex + actuallen < (USHORT) (actual->Length / sizeof(WCHAR)) &&
                   !IS_PATH_SEPARATOR_U(actual->Buffer[actualindex + actuallen])) {
                actuallen++;
            }

            // Otherwise require that this component matches.
            switch (__CodeAuthzpCompareImagePathHelper(
                        &wildcard->Buffer[wildindex], wildlen,
                        &actual->Buffer[actualindex], actuallen)) {
                case 0:     // fails to match
                    return 0;
                case -1:    // matches exactly without wildcards
                    break;
                default:    // matches with wildcard expansion.
                    bNoWildcardsFound = FALSE; break;
            }

            // Increment pointers for next component.
            wildindex += wildlen;
            actualindex += actuallen;
            matchquality++;
        }

    }
}



LONG NTAPI
CodeAuthzpCompareImagePath(
        IN LPCWSTR  szPathFragment,
        IN LPCWSTR  szFullImagePath
        )
/*++

Routine Description:

    Evaluates a wildcard pattern against a specified pathname and
    indicates if they match.

Arguments:

    szPathFragment -

    szFullImagePath -

Return Value:

    Returns 0 if the path fragment does not match the specified imagepath.
    Returns -1 if the fragment matches the imagepath _exactly_!
    Otherwise returns a postive integer representing the "depth" of the
    the match (number of matching subdirectories).  Greater values
    indicate a "deeper" directory match.

--*/
{
    UNICODE_STRING UnicodePathFragment;
    UNICODE_STRING UnicodeFullImagePath;
    ULONG i = 0;
    USHORT Len = 0;
    LONG lMatchDepth = 0;

    RtlInitUnicodeString(&UnicodePathFragment, szPathFragment);
    RtlInitUnicodeString(&UnicodeFullImagePath, szFullImagePath);
    lMatchDepth = CodeAuthzpCompareUnicodeImagePath(
                      &UnicodePathFragment, &UnicodeFullImagePath);

    // We did not get a match for fully qualified name. Let's try for just a 
    // basename match.
    if (!lMatchDepth) {
        // if the rule has a '\' in it, it's not a basename match rule.
        // We only check for filename.ext rules allowing wildcards.
        if (wcschr(szPathFragment, L'\\')) {
            return 0;
        }

        Len = (UnicodeFullImagePath.Length/sizeof(WCHAR)) -1;

        // Skip from rightmost character to the the character just after the
        // last '\', if any or to the beginning of the string in absence of '\'.
        while (Len > 0 && szFullImagePath[Len] != L'\\') {
            Len--;
        }

        // A '\' exists. Move one character to the right.
        if (szFullImagePath[Len] == L'\\') {
            Len++;
        }

        // Check if there is a match of the file basename with the rule. We have
        // already checked that the rule does not have '\'.
        switch (__CodeAuthzpCompareImagePathHelper(
                    szPathFragment, UnicodePathFragment.Length/sizeof(WCHAR),
                    szFullImagePath+Len, (UnicodeFullImagePath.Length/sizeof(WCHAR))-Len)) {
            case 0:     // fails to match
                return 0;
            case -1:    // matches exactly without wildcards
            default:    // matches with wildcard expansion.

                // We treat exact matches the same as inexact matches here.
                // Thus, abc.exe is == a*.exe = *.exe.

                // Skip to the first non-'\' character.
                while ((szFullImagePath[i] == L'\\') && (szFullImagePath[i] != L'\0')) {
                    i++;
                }

                // This string is bogus. It only has 0 or more '\'s in it.
                if (szFullImagePath[i] == L'\0') {
                    return 0;
                }

                // Return the depth of the tree.
                lMatchDepth = 1;
                while (TRUE) {

                    // Skip to the first '\' while not end of string.
                    while ((szFullImagePath[i] != L'\\') && (szFullImagePath[i] != L'\0')) {
                        i++;
                    }

                    // We are at the end of the string. Return the depth.
                    if (szFullImagePath[i] == L'\0') {
                        return lMatchDepth;
                    }

                    // Skip to the first non-'\' while not end of string.
                    while ((szFullImagePath[i] == L'\\') && (szFullImagePath[i] != L'\0')) {
                        i++;
                    }

                    // We are at a non-'\' character. Increment the depth.
                    lMatchDepth++;
                }

                // Should never get here.
                ASSERT(FALSE);
        }
    }        

    return lMatchDepth;
}



#else   // #ifdef USE_NEW_WILDCARD_EVALUATION


LONG NTAPI
CodeAuthzpCompareImagePath(
        IN LPCWSTR  szPathFragment,
        IN LPCWSTR  szFullImagePath
        )
/*++

Routine Description:

    Evaluates a wildcard pattern against a specified pathname and
    indicates if they match.

Arguments:

    szPathFragment -

    szFullImagePath -

Return Value:

    Returns 0 if the path fragment does not match the specified imagepath.
    Returns -1 if the fragment matches the imagepath _exactly_!
    Otherwise returns a postive integer representing the "depth" of the
    the match (number of matching subdirectories).  Greater values
    indicate a "deeper" directory match.

--*/
{
    LONG MatchDepth = 0;
    BOOLEAN bLastWasSlash = TRUE;
    LPCWSTR pFragment = szPathFragment;
    LPCWSTR pImage = szFullImagePath;


    //
    // Verify that our arguments were all supplied.
    //
    ASSERT(ARGUMENT_PRESENT(pFragment) && ARGUMENT_PRESENT(pImage));
    if (!*pFragment || !*pImage) return 0;      // empty strings.



    //
    // Perform the actual comparison loop.
    //
    for (;;) {
        if (!*pFragment)
        {
            // We have reached the string terminator at the end of the
            // wildcard fragment.  If this was also the end of the
            // actual filename, then this is a precise match.  Otherwise
            // we'll only consider this a positive partial match if this
            // occurred on a path-separator boundary.
            if (!*pImage) return -1;        // matched exactly.
            else if (bLastWasSlash) break;
            else if (IS_PATH_SEPARATOR_U(*pImage)) break;
            else return 0;       // did not match.
        }
        else if (!*pImage)
        {
            // We have reached the end of the actual filename, but have
            // not yet found the end of the wildcard fragment.
            return 0;       // did not match.
        }
        else if (!IS_UCASE_CHARS_EQUAL_U(*pFragment, *pImage))
        {
            // The two characters were unequal.  However, this condition
            // might occur if multiple path separators occur in one and
            // not the other, so explicitly absorb multiple slashes.
            if (bLastWasSlash) {
                if (IS_PATH_SEPARATOR_U(*pFragment)) { pFragment++; continue; }
                else if (IS_PATH_SEPARATOR_U(*pImage)) { pImage++; continue; }
            }
            return 0;           // did not match.
        }
        else
        {
            // Both characters matched.  Remember if they were slashes.
            // If this is a transition to a non-separator portion of the
            // filename, then increment our depth counter.
            if (IS_PATH_SEPARATOR_U(*pFragment)) {
                bLastWasSlash = TRUE;
            } else {
                if (bLastWasSlash) {
                    MatchDepth++;
                    bLastWasSlash = FALSE;
                }
            }
        }
        pFragment++;
        pImage++;
    }
    return MatchDepth;
}

#endif      //#ifdef USE_NEW_WILDCARD_EVALUATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safelog.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safelog.c         (SAFER Event Logging)

Abstract:

    This module implements the internal WinSAFER APIs to write eventlog
    messages.  All of our message strings are defined in ntstatus.mc
    and are physically located within ntdll.dll file.

    Currently we are just reusing the previously existing event source
    called "Application Popup", which already happens to use ntdll.dll
    as its message resource library.  Events of this source always go
    into the "System Log".

Author:

    Jeffrey Lawson (JLawson) - Apr 1999

Environment:

    User mode only.

Exported Functions:

    SaferRecordEventLogEntry

Revision History:

    Created - Nov 2000

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"




const static GUID guidTrustedCert = SAFER_GUID_RESULT_TRUSTED_CERT;
const static GUID guidDefaultRule = SAFER_GUID_RESULT_DEFAULT_LEVEL;



BOOL WINAPI
SaferpRecordEventLogEntryHelper(
        IN NTSTATUS     LogStatusCode,
        IN LPCWSTR      szTargetPath,
        IN REFGUID      refRuleGuid,
        IN LPCWSTR      szRulePath
        )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    WORD wNumStrings = 0;
    LPWSTR lpszStrings[5];
    HANDLE hEventSource;
    UNICODE_STRING UnicodeGuid;
    BYTE LocalBuffer[SECURITY_MAX_SID_SIZE + sizeof(TOKEN_USER)];
    PSID pSid = NULL;
    HANDLE hToken = NULL;
    DWORD Ignore = 0;
    
    //
    // Open the effective token on the thead and get the token user. On any
    // intermediate failure in this operation, we still dump the event to the 
    // event log, without the user sid information.
    //

    //
    // Get the effective token on the thread.
    // 

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,
                 &hToken);

    //
    // If the thread is not impersonating, get the process token.
    //

    if (Status == STATUS_NO_TOKEN) {
        Status = NtOpenProcessToken(
                     NtCurrentProcess(),
                     TOKEN_QUERY,
                     &hToken);
    }
    
    if (NT_SUCCESS(Status)) {

        // 
        // Get the User Sid.
        //

        Status = NtQueryInformationToken (
                     hToken,
                     TokenUser,
                     LocalBuffer,
                     sizeof(LocalBuffer),
                     &Ignore);

        NtClose(hToken);

        if (NT_SUCCESS(Status)) {

            //
            // We have successfully computed who the user is. This is good.
            //

            pSid = (PSID) (((PTOKEN_USER) LocalBuffer)->User.Sid);
        }
    }

    hEventSource = RegisterEventSourceW(NULL, L"Software Restriction Policy");

    if (hEventSource != NULL) {

        Status = STATUS_SUCCESS;
        RtlInitEmptyUnicodeString(&UnicodeGuid, NULL, 0);

        switch (LogStatusCode)
        {
            case STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT:
                if (!ARGUMENT_PRESENT(szTargetPath)) {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }
                lpszStrings[0] = (LPWSTR) szTargetPath;
                wNumStrings = 1;
                break;

            case STATUS_ACCESS_DISABLED_BY_POLICY_OTHER:
                if (!ARGUMENT_PRESENT(szTargetPath) ||
                    !ARGUMENT_PRESENT(refRuleGuid)) {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                Status = RtlStringFromGUID(refRuleGuid, &UnicodeGuid);
                if (NT_SUCCESS(Status)) {
                    ASSERT(UnicodeGuid.Buffer != NULL);
                    lpszStrings[0] = (LPWSTR) szTargetPath;
                    lpszStrings[1] = UnicodeGuid.Buffer;
                    wNumStrings = 2;
                }
                break;

            case STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER:
                if (!ARGUMENT_PRESENT(szTargetPath)) {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }
                lpszStrings[0] = (LPWSTR) szTargetPath;
                wNumStrings = 1;
                break;

            case STATUS_ACCESS_DISABLED_BY_POLICY_PATH:
                if (!ARGUMENT_PRESENT(szTargetPath) ||
                    !ARGUMENT_PRESENT(refRuleGuid) ||
                    !ARGUMENT_PRESENT(szRulePath)) {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }
                Status = RtlStringFromGUID(refRuleGuid, &UnicodeGuid);
                if (NT_SUCCESS(Status)) {
                    ASSERT(UnicodeGuid.Buffer != NULL);
                    lpszStrings[0] = (LPWSTR) szTargetPath;
                    lpszStrings[1] = UnicodeGuid.Buffer;
                    lpszStrings[2] = (LPWSTR) szRulePath;
                    wNumStrings = 3;
                }
                break;

            default:
                Status = STATUS_INVALID_PARAMETER;
        }

        if (NT_SUCCESS(Status)) {
            ReportEventW(
                    hEventSource,           // handle to event log
                    EVENTLOG_WARNING_TYPE,  // event type
                    0,                      // event category
                    LogStatusCode,          // event ID
                    pSid,                   // current user's SID
                    wNumStrings,            // strings in lpszStrings
                    0,                      // no bytes of raw data
                    lpszStrings,            // array of error strings
                    NULL);                  // no raw data
        }

        DeregisterEventSource(hEventSource);

        if (UnicodeGuid.Buffer != NULL) {
            RtlFreeUnicodeString(&UnicodeGuid);
        }
    }

    if (NT_SUCCESS(Status)) {
        return TRUE;
    } else {
        return FALSE;
    }
}



BOOL WINAPI
SaferRecordEventLogEntry(
        IN SAFER_LEVEL_HANDLE      hAuthzLevel,
        IN LPCWSTR          szTargetPath,
        IN LPVOID           lpReserved
        )
{
    PSAFER_IDENTIFICATION_HEADER pIdentCommon;
    DWORD dwIdentBufferSize;
    BOOL bResult;


    //
    // Allocate enough memory for the largest structure we can expect
    // and then query the information about the identifier that matched.
    //
    dwIdentBufferSize = max(sizeof(SAFER_HASH_IDENTIFICATION),
                            sizeof(SAFER_PATHNAME_IDENTIFICATION));
    pIdentCommon = (PSAFER_IDENTIFICATION_HEADER)
            HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwIdentBufferSize);
    if (!pIdentCommon) {
        return FALSE;
    }
    pIdentCommon->cbStructSize = sizeof(SAFER_IDENTIFICATION_HEADER);
    if (!SaferGetLevelInformation(
            hAuthzLevel,
            SaferObjectSingleIdentification,
            pIdentCommon,
            dwIdentBufferSize,
            &dwIdentBufferSize)) {

        if (GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {

            HeapFree(GetProcessHeap(), 0, pIdentCommon);
            pIdentCommon = (PSAFER_IDENTIFICATION_HEADER)
                    HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwIdentBufferSize);
            if (!pIdentCommon) {
                return FALSE;
            }
            pIdentCommon->cbStructSize = sizeof(SAFER_IDENTIFICATION_HEADER);
            if (!SaferGetLevelInformation(
                    hAuthzLevel,
                    SaferObjectSingleIdentification,
                    pIdentCommon,
                    dwIdentBufferSize,
                    &dwIdentBufferSize)) {
                bResult =  FALSE;
                goto Cleanup;
            }

        }
        else
        {
            bResult =  FALSE;
            goto Cleanup;
        }
    }


    //
    // Look at the resulting information about the identifier.
    //
    if (IsEqualGUID(&pIdentCommon->IdentificationGuid, &guidTrustedCert))
    {
        bResult = SaferpRecordEventLogEntryHelper(
                    STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER,
                    szTargetPath, NULL, NULL);
    }
    else if (IsEqualGUID(&pIdentCommon->IdentificationGuid, &guidDefaultRule))
    {
        bResult = SaferpRecordEventLogEntryHelper(
                    STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT,
                    szTargetPath, NULL, NULL);
    }
    else if (pIdentCommon->dwIdentificationType == SaferIdentityTypeImageName)
    {
        PSAFER_PATHNAME_IDENTIFICATION pIdentPath =
                (PSAFER_PATHNAME_IDENTIFICATION) pIdentCommon;
        bResult = SaferpRecordEventLogEntryHelper(
                    STATUS_ACCESS_DISABLED_BY_POLICY_PATH,
                    szTargetPath, &pIdentCommon->IdentificationGuid,
                    pIdentPath->ImageName);
    }
    else
    {
        bResult = SaferpRecordEventLogEntryHelper(
                    STATUS_ACCESS_DISABLED_BY_POLICY_OTHER,
                    szTargetPath, &pIdentCommon->IdentificationGuid,
                    NULL);
    }

Cleanup:
    HeapFree(GetProcessHeap(), 0, pIdentCommon);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\saferp.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    saferp.h

Abstract:

    This file implements the private (internal) functions, data types,
    data structures, and definitions used by the other WinSAFER
    code implementations.  All of the APIs listed in this header are
    not exported by ADVAPI32.DLL at all and are only callable by
    other code actually located within advapi.

Author:

    Jeffrey Lawson (JLawson)

Revision History:

--*/

#ifndef _AUTHZSAFERP_H_
#define _AUTHZSAFERP_H_

#include "safewild.h"


#ifdef __cplusplus
extern "C" {
#endif

// ---------------------------------------------------------


//
// Convenient macro for determining the number of elements in an array.
//
#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif


//
// Simple inlined function to return true if a GUID is all zeros.
//
FORCEINLINE BOOLEAN IsZeroGUID(REFGUID rguid1)
{
   return (
      ((unsigned long *) rguid1)[0] == 0 &&
      ((unsigned long *) rguid1)[1] == 0 &&
      ((unsigned long *) rguid1)[2] == 0 &&
      ((unsigned long *) rguid1)[3] == 0);
}



//
// Private structure used to store a table of all of the defined
// WinSafer Levels as we enumerate them to evaluate the matching one.
//
typedef struct _AUTHZLEVELTABLERECORD
{
    // The user-defined integer value that controls the relative ranking
    // of authorization level between Code Authorization Level.
    DWORD dwLevelId;

    // Boolean indicating whether this level is a "built-in" one.
    BOOLEAN Builtin;

	// Boolean indicating whether this level is enumerable
	BOOLEAN isEnumerable;

    // To load friendly name and description so that server apps can change
    // threadlocale.

    UINT uResourceID;

    // The short friendly name and the description.
    // UNICODE_STRING UnicodeFriendlyName;
    // UNICODE_STRING UnicodeDescription;

    // All of the following attributes are needed for
    // actual creation of the restricted token.
    BOOL DisallowExecution;                 // block execution entirely
    BOOL DisableMaxPrivileges;              // privilege options
    PSID DefaultOwner;                      // default owner SID
    DWORD SaferFlags;                       // special job execution flags

    BOOL InvertDisableSids;                 // SIDs specified are negative
    DWORD DisableSidCount;                  // number of deny-only SIDs
    DWORD DisableSidUsedCount;              // number actually used
    PAUTHZ_WILDCARDSID SidsToDisable;       // deny-only SIDs

    BOOL InvertDeletePrivs;                 // privileges specified are negative
    DWORD DeletePrivilegeCount;             // number of privileges
    DWORD DeletePrivilegeUsedCount;         // number actually used
    PLUID_AND_ATTRIBUTES PrivilegesToDelete;    // privileges

    DWORD RestrictedSidsInvCount;           // number of inverted restricting SIDs
    DWORD RestrictedSidsInvUsedCount;       // number actually used
    PAUTHZ_WILDCARDSID RestrictedSidsInv;   // list of inverted restricting SIDs

    DWORD RestrictedSidsAddedCount;         // number of restricting SIDs
    DWORD RestrictedSidsAddedUsedCount;     // number actually used
    PSID_AND_ATTRIBUTES RestrictedSidsAdded; // list of restricting SIDs

}
AUTHZLEVELTABLERECORD, *PAUTHZLEVELTABLERECORD;


//
// Private structure to store all code identifications.
//
#pragma warning(push)
#pragma warning(disable:4201)       // nonstandard extension used : nameless struct/union

typedef struct _AUTHZIDENTSTABLERECORD
{
    // unique identifier that distinguishes this code identity.
    GUID IdentGuid;

    // the following enumeration specifies what type of
    // code identity this record represents.
    SAFER_IDENTIFICATION_TYPES dwIdentityType;

    // Specifies what Level this Code Identification maps to.
    DWORD dwLevelId;

    // Specifies what scope this Code Identity was loaded from.
    DWORD dwScopeId;

    // Actual details about this identity.
    union {
        struct {
            BOOL bExpandVars;
            UNICODE_STRING ImagePath;
            DWORD dwSaferFlags;
        } ImageNameInfo;
        struct {
            LARGE_INTEGER ImageSize;
            DWORD HashSize;
            BYTE ImageHash[SAFER_MAX_HASH_SIZE];
            ALG_ID HashAlgorithm;
            DWORD dwSaferFlags;
        } ImageHashInfo;
        struct {
            DWORD UrlZoneId;
            DWORD dwSaferFlags;
        } ImageZone;
    };
}
AUTHZIDENTSTABLERECORD, *PAUTHZIDENTSTABLERECORD;
#pragma warning(pop)


//
// Private structure representation of a Level handle.  The
// typedef SAFER_LEVEL_HANDLE is an opaque reference to a structure of
// this type, accessed via the RtlHandleTable functions.
//
typedef struct _AUTHZLEVELHANDLESTRUCT_
{
    // This first header is required by the RTL_HANDLE_TABLE system.
    // All allocated handles will implicitly have bit 0 set.  All other
    // remaining bits can be used for our own purposes if we want.
    RTL_HANDLE_TABLE_ENTRY HandleHeader;

    // The following information is redundant.  It can be found by
    // also accessing the pLevelRecord directly.
    DWORD dwLevelId;

    // This scope identifier specifies the value that was passed to
    // the Win32 API SaferCreateLevel and is really only looked at
    // by SaferGetLevelInformation for the Identity GUID enums.
    DWORD dwScopeId;                 // (same as from pIdentRecord)

    // Stores the matching identity record that gave this result.
    // May be NULL, as in case of direct SaferCreateLevel or a
    // default Level match.
    GUID identGuid;

    // This value stores the Safer Flags that were derived from the
    // Identity Entry record when SaferIdentifyLevel finds a match.
    DWORD dwSaferFlags;

    // The sequence value indicates the "generation" at which a handle
    // was originally opened.  If this value does not match the current
    // value in the global g_dwLevelHandleSequence, then this handle
    // should be considered a no-longer valid handle.
    DWORD dwHandleSequence;

    // Extended error information - applicable for certificate rules.
    DWORD dwExtendedError;

    // the following enumeration specifies what type of
    // code identity this handle represents.
    SAFER_IDENTIFICATION_TYPES IdentificationType;

    // For future use and padding purposes.
    DWORD dwReserved;
}
AUTHZLEVELHANDLESTRUCT, *PAUTHZLEVELHANDLESTRUCT;


//
// Private structure definition used to pass around all state
// information needed during the SaferIdentifyLevel execution.
//
typedef struct _LOCALIDENTITYCONTEXT
{
    // Original query request data.
    DWORD dwCheckFlags;                 // copy of original function input
    PSAFER_CODE_PROPERTIES CodeProps;        // RO: original function input

    // Information about the hash that may have been computed.
    BOOLEAN bHaveHash;
    BYTE FinalHash[SAFER_MAX_HASH_SIZE];
    DWORD FinalHashSize;
    ALG_ID FinalHashAlgorithm;

    // File handle that may have been opened or supplied by the caller.
    HANDLE hFileHandle;

    // File handle status.  If this is TRUE then hFileHandle needs to
    // be closed before returning.
    BOOLEAN bCloseFileHandle;

    // Fully qualified NT filename of the input file.
    UNICODE_STRING UnicodeFullyQualfiedLongFileName;

    // Information about the image that may have been mapped.
    LARGE_INTEGER ImageSize;
    PVOID pImageMemory;

    // Memory mapped file status.  If this is TRUE then
    // pImageMemory needs to be unmapped before returning.
    BOOLEAN bImageMemoryNeedUnmap;
}
LOCALIDENTITYCONTEXT, *PLOCALIDENTITYCONTEXT;




//
// Various globals that are used for the cache of levels and
// identities so that we do not need to go to the registry each time.
//
extern BOOLEAN g_bInitializedFirstTime;

extern CRITICAL_SECTION g_TableCritSec;
extern HANDLE g_hKeyCustomRoot;
extern DWORD g_dwKeyOptions;

extern BOOLEAN g_bNeedCacheReload;

extern RTL_GENERIC_TABLE g_CodeLevelObjTable;
extern RTL_GENERIC_TABLE g_CodeIdentitiesTable;
extern RTL_HANDLE_TABLE g_LevelHandleTable;
extern DWORD g_dwLevelHandleSequence;

extern BOOLEAN g_bHonorScopeUser;

extern PAUTHZLEVELTABLERECORD g_DefaultCodeLevel;
extern PAUTHZLEVELTABLERECORD g_DefaultCodeLevelUser;
extern PAUTHZLEVELTABLERECORD g_DefaultCodeLevelMachine;


extern LARGE_INTEGER g_SaferPolicyTimeStamp;
extern DWORD g_dwNumHandlesAllocated;

//
// Private function prototypes defined within SAFEINIT.C
//

NTSTATUS NTAPI
CodeAuthzInitializeGlobals(VOID);


VOID NTAPI
CodeAuthzDeinitializeGlobals(VOID);


NTSTATUS NTAPI
CodeAuthzReloadCacheTables(
        IN HANDLE   hKeyCustomRoot OPTIONAL,
        IN DWORD    dwKeyOptions,
        IN BOOLEAN  bImmediateLoad
        );


NTSTATUS NTAPI
CodeAuthzpImmediateReloadCacheTables(
        VOID
        );


NTSTATUS NTAPI
CodeAuthzpDeleteKeyRecursively(
        IN HANDLE               hBaseKey,
        IN PUNICODE_STRING      pSubKey OPTIONAL
        );


NTSTATUS NTAPI
CodeAuthzpFormatLevelKeyPath(
        IN DWORD                    dwLevelId,
        IN OUT PUNICODE_STRING      UnicodeSuffix
        );

NTSTATUS NTAPI
CodeAuthzpFormatIdentityKeyPath(
        IN DWORD                    dwLevelId,
        IN LPCWSTR                  szIdentityType,
        IN REFGUID                  refIdentGuid,
        IN OUT PUNICODE_STRING      UnicodeSuffix
        );

NTSTATUS NTAPI
CodeAuthzpOpenPolicyRootKey(
        IN DWORD            dwScopeId,
        IN HANDLE           hKeyCustomBase OPTIONAL,
        IN LPCWSTR          szRegistrySuffix OPTIONAL,
        IN ACCESS_MASK      DesiredAccess,
        IN BOOLEAN          bCreateKey,
        OUT HANDLE         *OpenedHandle
        );

VOID NTAPI
CodeAuthzpRecomputeEffectiveDefaultLevel(VOID);



//
// Private function prototypes defined within SAFEHAND.C
//


NTSTATUS NTAPI
CodeAuthzpCreateLevelHandleFromRecord(
        IN PAUTHZLEVELTABLERECORD   pLevelRecord,
        IN DWORD                    dwScopeId,
        IN DWORD                    dwSaferFlags OPTIONAL,
        IN DWORD                    dwExtendedError,
        IN SAFER_IDENTIFICATION_TYPES IdentificationType,
        IN REFGUID                  refIdentGuid OPTIONAL,
        OUT SAFER_LEVEL_HANDLE            *pLevelHandle
        );

NTSTATUS NTAPI
CodeAuthzHandleToLevelStruct(
        IN SAFER_LEVEL_HANDLE          hLevelObject,
        OUT PAUTHZLEVELHANDLESTRUCT  *pLevelStruct
        );

NTSTATUS NTAPI
CodeAuthzCreateLevelHandle(
        IN DWORD            dwLevelId,
        IN DWORD            OpenFlags,
        IN DWORD            dwScopeId,
        IN DWORD            dwSaferFlags OPTIONAL,
        OUT SAFER_LEVEL_HANDLE    *pLevelHandle);

NTSTATUS NTAPI
CodeAuthzCloseLevelHandle(
        IN SAFER_LEVEL_HANDLE      hLevelObject
        );




//
// Functions related to WinSafer Level enumeration (SAFEIDEP.C)
//

VOID NTAPI
CodeAuthzLevelObjpInitializeTable(
        IN OUT PRTL_GENERIC_TABLE   pAuthzObjTable
        );


NTSTATUS NTAPI
CodeAuthzLevelObjpLoadTable (
        IN OUT PRTL_GENERIC_TABLE   pAuthzObjTable,
        IN DWORD                    dwScopeId,
        IN HANDLE                   hKeyCustomRoot
        );

VOID NTAPI
CodeAuthzLevelObjpEntireTableFree (
        IN OUT PRTL_GENERIC_TABLE   pAuthzObjTable
        );

PAUTHZLEVELTABLERECORD NTAPI
CodeAuthzLevelObjpLookupByLevelId (
        IN PRTL_GENERIC_TABLE      pAuthzObjTable,
        IN DWORD                   dwLevelId
        );



//
// Functions related to WinSafer Code Identity enumeration. (SAFEIDEP.C)
//

VOID NTAPI
CodeAuthzGuidIdentsInitializeTable(
        IN OUT PRTL_GENERIC_TABLE  pAuthzObjTable
        );

NTSTATUS NTAPI
CodeAuthzGuidIdentsLoadTableAll (
        IN PRTL_GENERIC_TABLE       pAuthzLevelTable,
        IN OUT PRTL_GENERIC_TABLE   pAuthzIdentTable,
        IN DWORD                    dwScopeId,
        IN HANDLE                   hKeyCustomBase
        );

VOID NTAPI
CodeAuthzGuidIdentsEntireTableFree (
        IN OUT PRTL_GENERIC_TABLE pAuthzIdentTable
        );

PAUTHZIDENTSTABLERECORD NTAPI
CodeAuthzIdentsLookupByGuid (
        IN PRTL_GENERIC_TABLE      pAuthzIdentTable,
        IN REFGUID                 pIdentGuid
        );


//
// Helper functions that are used during actual identification (SAFEIDEP.C)
//

LONG NTAPI
CodeAuthzpCompareImagePath(
        IN LPCWSTR      szPathFragment,
        IN LPCWSTR      szFullImagePath);

NTSTATUS NTAPI
CodeAuthzpComputeImageHash(
        IN PVOID        pImageMemory,
        IN DWORD        dwImageSize,
        OUT PBYTE       pComputedHash OPTIONAL,
        IN OUT PDWORD   pdwHashSize OPTIONAL,
        OUT ALG_ID     *pHashAlgorithm OPTIONAL
        );



//
// Private function prototypes for low-level policy reading/writing. (SAFEPOLR.C)
//

NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_LevelListRaw(
        IN DWORD    dwScopeId,
        IN DWORD    InfoBufferSize OPTIONAL,
        OUT PVOID   InfoBuffer OPTIONAL,
        OUT PDWORD  InfoBufferRetSize OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize OPTIONAL,
        OUT PVOID       InfoBuffer OPTIONAL,
        OUT PDWORD      InfoBufferRetSize OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize OPTIONAL,
        OUT PVOID       InfoBuffer OPTIONAL,
        OUT PDWORD      InfoBufferRetSize OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_SetInfoDual_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        OUT PVOID       InfoBuffer
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_HonorUserIdentities(
        IN   DWORD       dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_HonorUserIdentities(
        IN   DWORD       dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_SetInfoDual_HonorUserIdentities(
        IN      DWORD       dwScopeId,
        IN      DWORD       InfoBufferSize,
        IN      PVOID       InfoBuffer
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_TransparentEnabled(
        IN DWORD        dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_SetInfoRegistry_TransparentEnabled(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        IN PVOID        InfoBuffer
        );

NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_ScopeFlags(
        IN DWORD        dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        );

NTSTATUS NTAPI
CodeAuthzPol_SetInfoRegistry_ScopeFlags(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        IN PVOID        InfoBuffer
        );


//
// Private function prototypes defined elsewhere.
//

LPVOID NTAPI
CodeAuthzpGetTokenInformation(
        IN HANDLE                       TokenHandle,
        IN TOKEN_INFORMATION_CLASS      TokenInformationClass
        );

NTSTATUS NTAPI
CodeAuthzIsExecutableFileType(
        IN PUNICODE_STRING  szFullPathname,
        IN BOOLEAN  bFromShellExecute,
        OUT PBOOLEAN        pbResult
        );

NTSTATUS NTAPI
CodeAuthzFullyQualifyFilename(
        IN HANDLE               hFileHandle         OPTIONAL,
        IN BOOLEAN              bSourceIsNtPath,
        IN LPCWSTR              szSourceFilePath,
        OUT PUNICODE_STRING     pUnicodeResult
        );

BOOL NTAPI
SaferpLoadUnicodeResourceString(
        IN HANDLE               hModule,
        IN UINT                 wID,
        OUT PUNICODE_STRING     pUnicodeString,
        IN WORD                 wLangId
    );


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safepol.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safepol.c         (SAFER Code Authorization Policy)

Abstract:

    This module implements the WinSAFER APIs

Author:

    Jeffrey Lawson (JLawson) - Apr 1999

Environment:

    User mode only.

Exported Functions:

    CodeAuthzpGetInformationCodeAuthzPolicy
    CodeAuthzpSetInformationCodeAuthzPolicy
    SaferGetPolicyInformation                 (public win32)
    SaferSetPolicyInformation                 (public win32)

Revision History:

    Created - Apr 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"




NTSTATUS NTAPI
CodeAuthzpGetInformationCodeAuthzPolicy (
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS     CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        IN OUT PVOID                        InfoBuffer,
        OUT PDWORD                          InfoBufferRetSize
        )
/*++

Routine Description:


Arguments:

    dwScopeId -

    CodeAuthzPolicyInfoClass -

    InfoBufferSize -

    InfoBuffer -

    InfoBufferRetSize -

Return Value:

    Returns STATUS_SUCCESS if no error occurs, otherwise returns the
    status code indicating the nature of the failure.

--*/
{
    NTSTATUS Status;


    //
    // Handle the specific information type as appropriate.
    //
    switch (CodeAuthzPolicyInfoClass)
    {
        case SaferPolicyLevelList:
            // scope is only primary.
            Status = CodeAuthzPol_GetInfoCached_LevelListRaw(
                    dwScopeId,
                    InfoBufferSize, InfoBuffer, InfoBufferRetSize);
            break;


        case SaferPolicyDefaultLevel:
            // scope is primary or secondary for non-registry case.
            Status = CodeAuthzPol_GetInfoCached_DefaultLevel(
                    dwScopeId,
                    InfoBufferSize, InfoBuffer, InfoBufferRetSize);
            break;


        case SaferPolicyEnableTransparentEnforcement:
            // scope is only primary.
            Status = CodeAuthzPol_GetInfoRegistry_TransparentEnabled(
                    dwScopeId,
                    InfoBufferSize, InfoBuffer, InfoBufferRetSize);
            break;

        case SaferPolicyEvaluateUserScope:
            // scope is only primary.
            Status = CodeAuthzPol_GetInfoCached_HonorUserIdentities(
                    dwScopeId,
                    InfoBufferSize, InfoBuffer, InfoBufferRetSize);
            break;

        case SaferPolicyScopeFlags:
        // scope is only primary.
        Status = CodeAuthzPol_GetInfoRegistry_ScopeFlags(
                dwScopeId,
                InfoBufferSize, InfoBuffer, InfoBufferRetSize);
        break;


        default:
            Status = STATUS_INVALID_INFO_CLASS;
            break;
    }

    return Status;
}



NTSTATUS NTAPI
CodeAuthzpSetInformationCodeAuthzPolicy (
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS     CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        OUT PVOID                           InfoBuffer
        )
/*++

Routine Description:


Arguments:

    dwScopeId -

    CodeAuthzPolicyInfoClass -

    InfoBufferSize -

    InfoBuffer -

Return Value:

    Returns STATUS_SUCCESS if no error occurs, otherwise returns the
    status code indicating the nature of the failure.

--*/
{
    NTSTATUS Status;


    //
    // Handle the specific information type as appropriate.
    //
    switch (CodeAuthzPolicyInfoClass)
    {
        case SaferPolicyLevelList:
            // not valid for setting.
            Status = STATUS_INVALID_INFO_CLASS;
            break;


        case SaferPolicyDefaultLevel:
            // scope is primary or secondary for non-registry case.
            Status = CodeAuthzPol_SetInfoDual_DefaultLevel(
                    dwScopeId, InfoBufferSize, InfoBuffer);
            break;


        case SaferPolicyEnableTransparentEnforcement:
            // scope is only primary.
            Status = CodeAuthzPol_SetInfoRegistry_TransparentEnabled(
                    dwScopeId, InfoBufferSize, InfoBuffer);
            break;

        case SaferPolicyScopeFlags:
            // scope is only primary.
            Status = CodeAuthzPol_SetInfoRegistry_ScopeFlags(
                    dwScopeId, InfoBufferSize, InfoBuffer);
            break;

        case SaferPolicyEvaluateUserScope:
            // scope is only primary.
            Status = CodeAuthzPol_SetInfoDual_HonorUserIdentities(
                    dwScopeId, InfoBufferSize, InfoBuffer);
            break;


        default:
            Status = STATUS_INVALID_INFO_CLASS;
            break;
    }

    return Status;
}



BOOL WINAPI
SaferGetPolicyInformation(
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS     CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        IN OUT PVOID                        InfoBuffer,
        IN OUT PDWORD                       InfoBufferRetSize,
        IN LPVOID                           lpReserved
        )
/*++

Routine Description:


Arguments:

    dwScopeId -

    CodeAuthzPolicyInfoClass -

    InfoBufferSize -

    InfoBuffer -

    InfoBufferRetSize -

    lpReserved - unused, must be zero.

Return Value:

    Returns TRUE if successful, otherwise returns FALSE and sets
    the value returned by GetLastError() to be the specific cause.

--*/
{
    NTSTATUS Status;

    Status = CodeAuthzpGetInformationCodeAuthzPolicy(
            dwScopeId, CodeAuthzPolicyInfoClass,
            InfoBufferSize, InfoBuffer, InfoBufferRetSize);
    if (NT_SUCCESS(Status))
        return TRUE;

    BaseSetLastNTError(Status);
    UNREFERENCED_PARAMETER(lpReserved);
    return FALSE;
}



BOOL WINAPI
SaferSetPolicyInformation(
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS     CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        IN PVOID                            InfoBuffer,
        IN LPVOID                           lpReserved
        )
/*++

Routine Description:


Arguments:

    dwScopeId -

    CodeAuthzPolicyInfoClass -

    InfoBufferSize -

    InfoBuffer -

    lpReserved - unused, must be zero.

Return Value:

    Returns TRUE if successful, otherwise returns FALSE and sets
    the value returned by GetLastError() to be the specific cause.

--*/
{
    NTSTATUS Status;

    Status = CodeAuthzpSetInformationCodeAuthzPolicy (
                dwScopeId, CodeAuthzPolicyInfoClass,
                InfoBufferSize, InfoBuffer);

    if (NT_SUCCESS(Status))
        return TRUE;

    BaseSetLastNTError(Status);
    UNREFERENCED_PARAMETER(lpReserved);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safeset.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safeset.c         (WinSAFER SetInformation)

Abstract:

    This module implements the WinSAFER APIs to set attributes and
    information relating to the Code Authorization Levels.

Author:

    Jeffrey Lawson (JLawson) - May 2000

Environment:

    User mode only.

Exported Functions:

    SaferSetLevelInformation

Revision History:

    Created - Nov 1999


--*/

#include "pch.h"
#pragma hdrstop
#include <sddl.h>
#include <accctrl.h>
#include <aclapi.h>
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"
#include "safewild.h"





NTSTATUS NTAPI
SaferpCreateSecondLevelKey(
        IN HANDLE       hObjectKeyBase,
        IN LPCWSTR      szFirstLevel,
        IN LPCWSTR      szSecondLevel OPTIONAL,
        OUT PHANDLE     phOutKey
        )
/*++

Routine Description:

    Opens a subkey under a specified registry key handle, creating that
    subkey if necessary.  Up to two subkeys (ie: two levels deep) can
    be specified by specifying both the szFirstLevel and szSecondLevel
    arguments.

Arguments:

    hObjectKeyBase - specifies a pre-opened registry handle to the
        base registry key under which the specified szFirstLevel subkey
        will be opened/created.  This registry handle must be opened
        for write access, or else subkey creation will fail.

    szFirstLevel - specifies the first level subkey to open/create.

    szSecondLevel - optionally specifies the second subkey to open/create.

    phOutKey - pointer that will receive the opened registry key handle
        on successful execution of this function.  This handle must be
        closed by the caller when its use is no longer required.

Return Value:

    Returns STATUS_SUCCESS on successful opening of the requested key.
    Otherwise returns a status code indicating the nature of the failure.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING SubkeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hKeyFirstLevel, hKeySecondLevel;


    ASSERT(phOutKey != NULL && szFirstLevel != NULL);

    //
    // Open a handle to the "szFirstLevel" subkey,
    // creating it if needed.
    //
    RtlInitUnicodeString(&SubkeyName, szFirstLevel);
    InitializeObjectAttributes(&ObjectAttributes,
          &SubkeyName,
          OBJ_CASE_INSENSITIVE,
          hObjectKeyBase,
          NULL
          );
    Status = NtCreateKey(&hKeyFirstLevel, KEY_WRITE,
                         &ObjectAttributes, 0, NULL,
                         g_dwKeyOptions, NULL);
    if (!NT_SUCCESS(Status)) return Status;


    //
    // Open a handle to the "szFirstLevel\szSecondLevel"
    // subkey, creating it if needed.
    //
    if (ARGUMENT_PRESENT(szSecondLevel)) {
        RtlInitUnicodeString(&SubkeyName, szSecondLevel);
        InitializeObjectAttributes(&ObjectAttributes,
              &SubkeyName,
              OBJ_CASE_INSENSITIVE,
              hKeyFirstLevel,
              NULL
              );
        Status = NtCreateKey(&hKeySecondLevel,
                (KEY_WRITE & ~KEY_CREATE_SUB_KEY),
                &ObjectAttributes, 0,
                NULL, g_dwKeyOptions, NULL);
        NtClose(hKeyFirstLevel);
        if (!NT_SUCCESS(Status)) return Status;
    }
    else {
        hKeySecondLevel = hKeyFirstLevel;
    }

    *phOutKey = hKeySecondLevel;
    return STATUS_SUCCESS;
}


NTSTATUS NTAPI
SaferpSetRegistryHelper(
        IN HANDLE       hObjectKeyBase,
        IN LPCWSTR      szFirstLevel,
        IN LPCWSTR      szSecondLevel OPTIONAL,
        IN LPCWSTR      szValueName,
        IN DWORD        dwRegType,
        IN LPVOID       lpDataBuffer,
        IN DWORD        dwDataBufferSize
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS Status;
    HKEY hKeySecondLevel;
    UNICODE_STRING ValueName;


    //
    // Open a handle to the correct subkey.
    //
    Status = SaferpCreateSecondLevelKey(
                    hObjectKeyBase,
                    szFirstLevel,
                    szSecondLevel,
                    &hKeySecondLevel
                    );
    if (!NT_SUCCESS(Status)) return Status;


    //
    // Write the new value to "szValueName"
    //
    RtlInitUnicodeString(&ValueName, szValueName);
    Status = NtSetValueKey(hKeySecondLevel,
            &ValueName, 0, dwRegType,
            (LPBYTE) lpDataBuffer, dwDataBufferSize);
    NtClose(hKeySecondLevel);
    return Status;
}




#ifdef ALLOW_FULL_WINSAFER
NTSTATUS NTAPI
SaferpClearRegistryListHelper(
        IN HANDLE       hObjectKeyBase,
        IN LPCWSTR      szValueCountName,
        IN LPCWSTR      szPrefixName
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS Status;
    BOOLEAN bCompletePass;
    BYTE LocalBuffer[256];
    ULONG ulKeyInfoSize = sizeof(LocalBuffer);
    PKEY_VALUE_BASIC_INFORMATION pKeyInfo =
            (PKEY_VALUE_BASIC_INFORMATION) LocalBuffer;
    ULONG ulKeyIndex, ulSizeUsed;


    //
    // Start iterating through all of the values under this subkey and
    // see if there are any values that match the prefix that we are
    // supposed to delete.  If we find something we should delete, then
    // we do that, but we continue iterating with the expectation that
    // the enumeration values might possibly change when we deleted.
    // So we will keep looping until we are able to enumerate completely
    // through without finding something to delete.
    //
    ulKeyIndex = 0;
    bCompletePass = TRUE;
    for (;;)
    {
        //
        // Determine the next value name under this key.
        //
        Status = NtEnumerateValueKey(hObjectKeyBase,
                                    ulKeyIndex,
                                    KeyValueBasicInformation,
                                    pKeyInfo,
                                    ulKeyInfoSize,
                                    &ulSizeUsed);
        if (!NT_SUCCESS(Status))
        {
            if (Status == STATUS_BUFFER_TOO_SMALL) {
                // Buffer is too small, so we need to enlarge.
                ASSERT(ulSizeUsed > ulKeyInfoSize);
                if (pKeyInfo != (PKEY_VALUE_BASIC_INFORMATION) LocalBuffer) {
                    RtlFreeHeap(RtlProcessHeap(), 0, pKeyInfo);
                }

                ulKeyInfoSize = ulSizeUsed;
                pKeyInfo = (PKEY_VALUE_BASIC_INFORMATION )
                        RtlAllocateHeap(RtlProcessHeap(), 0, ulKeyInfoSize);
                if (!pKeyInfo) {
                    Status = STATUS_NO_MEMORY;
                    goto ExitHandler;
                }
                continue;
            }
            else if (Status == STATUS_NO_MORE_ENTRIES) {
                // All done enumerating.
                if (bCompletePass) {
                    // We just finished a complete pass through without any
                    // deletions so we really know that we're done now.
                    break;
                } else {
                    // We haven't yet completed a full pass without hitting
                    // any deletions so we must try again, since the value
                    // enumerations might have changed at least once.
                    bCompletePass = TRUE;
                    ulKeyIndex = 0;
                    continue;
                }
            }
            else {
                // All other errors get literally returned.
                // This is especially yucky if this error occurred partially
                // through our attempt to delete everything.
                goto ExitHandler;
            }
        }


        //
        // If this value is something that we need to delete,
        // then delete it now and then restart the enumeration.
        //
        if (_wcsnicmp(pKeyInfo->Name, szPrefixName,
                            wcslen(szPrefixName)) == 0 ||
            _wcsicmp(pKeyInfo->Name, szValueCountName) == 0)
        {
            UNICODE_STRING ValueName;

            bCompletePass = FALSE;
            ValueName.Buffer = pKeyInfo->Name;
            ValueName.MaximumLength = ValueName.Length =
                pKeyInfo->NameLength;
            ASSERT(ValueName.Length == sizeof(WCHAR) * wcslen(ValueName.Buffer));
            Status = NtDeleteValueKey(hObjectKeyBase, &ValueName);
            if (!NT_SUCCESS(Status)) {
                // Oh yuck, we got an error deleting.  This is especially
                // yucky if this error occurred partially through our
                // attempt to delete everything.
                goto ExitHandler;
            }
            continue;
        }
        ulKeyIndex++;
    }
    Status = STATUS_SUCCESS;


ExitHandler:
    if (pKeyInfo != (PKEY_VALUE_BASIC_INFORMATION) LocalBuffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, pKeyInfo);
    }
    return Status;
}
#endif // ALLOW_FULL_WINSAFER




#ifdef ALLOW_FULL_WINSAFER
NTSTATUS NTAPI
SaferpSetListOfSids(
            IN HKEY             hKeyBase,
            IN LPCWSTR          szFirstLevel,
            IN LPCWSTR          szSecondLevel OPTIONAL,
            IN LPCWSTR          szValueCountName,
            IN LPCWSTR          szPrefixName,
            IN PTOKEN_GROUPS    pTokenGroups,
            IN BOOLEAN          bAllowWildcardSids
            )
/*++

Routine Description:

Arguments:

Return Value:

--*/
//BLACKCOMB TODO: This really needs to take a dwInBufferSize argument so that
//      the size of the pTokenGroups structure can be verified.
{
    NTSTATUS Status;
    HKEY hSidsToDisable;
    UNICODE_STRING ValueName;
    DWORD Index;


    //
    // First verify the SIDs and that the Attributes field
    // of all of the SIDs are zero.
    //
    for (Index = 0; Index < pTokenGroups->GroupCount; Index++)
    {
        if (!RtlValidSid(pTokenGroups->Groups[Index].Sid))
            return STATUS_INVALID_SID;

        if (pTokenGroups->Groups[Index].Attributes != 0)
        {
            if (bAllowWildcardSids) {
//BLACKCOMB TODO: handle wildcard sids differently?
                if ((pTokenGroups->Groups[Index].Attributes >> 24) != '*' &&
                    (pTokenGroups->Groups[Index].Attributes & 0x0000FFFF) >
                        ((PISID)pTokenGroups->Groups[Index].Sid)->SubAuthorityCount)
                    return STATUS_INVALID_SID;
            }
            else
                return STATUS_INVALID_SID;
        }
    }


    //
    // Open a handle to the correct subkey.
    //
    Status = SaferpCreateSecondLevelKey(
                    hKeyBase,
                    szFirstLevel,
                    szSecondLevel,
                    &hSidsToDisable);
    if (!NT_SUCCESS(Status)) goto ExitHandler2;


    //
    // Clear out all old values under the subkey.
    //
    Status = SaferpClearRegistryListHelper(
                    hSidsToDisable,
                    szValueCountName,
                    szPrefixName);
    if (!NT_SUCCESS(Status)) {
        // Bad luck!  Possibly left in incomplete state!
        NtClose(hSidsToDisable);
        goto ExitHandler2;
    }


    //
    // Now add all of the new ones we're supposed to add.
    //
    RtlInitUnicodeString(&ValueName, szValueCountName);
    Status = NtSetValueKey(hSidsToDisable,
            &ValueName, 0, REG_DWORD,
            (LPBYTE) pTokenGroups->GroupCount, sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        // Bad luck!  Possibly left in incomplete state!
        NtClose(hSidsToDisable);
        goto ExitHandler2;
    }
    for (Index = 0; Index < pTokenGroups->GroupCount; Index++)
    {
        WCHAR ValueNameBuffer[20];
        UNICODE_STRING UnicodeStringSid;

        wsprintfW(ValueNameBuffer, L"%S%d", szPrefixName, Index);
        RtlInitUnicodeString(&ValueName, ValueNameBuffer);

//BLACKCOMB TODO: wildcard sids not yet supported
        if (bAllowWildcardSids)
            Status = xxxxx;
        else
            Status = RtlConvertSidToUnicodeString( &UnicodeStringSid,
                    pTokenGroups->Groups[Index].Sid, TRUE );
        if (!NT_SUCCESS(Status))
        {
            // Bad luck!  Possibly left in incomplete state!
            NtClose(hSidsToDisable);
            goto ExitHandler2;
        }

        Status = NtSetValueKey(hSidsToDisable,
            &ValueName, 0, REG_SZ,
            (LPBYTE) UnicodeStringSid.Buffer,
            UnicodeStringSid.Length + sizeof(UNICODE_NULL));

        RtlFreeUnicodeString( &UnicodeStringSid );

        if (!NT_SUCCESS(Status)) {
            // Bad luck!  Possibly left in incomplete state!
            NtClose(hSidsToDisable);
            goto ExitHandler2;
        }
    }
    NtClose(hSidsToDisable);
    return STATUS_SUCCESS;

ExitHandler2:
    return Status;
}
#endif // ALLOW_FULL_WINSAFER


NTSTATUS NTAPI
SaferpDeleteSingleIdentificationGuid(
        IN PAUTHZLEVELTABLERECORD     pLevelRecord,
        IN PAUTHZIDENTSTABLERECORD  pIdentRecord)
/*++

Routine Description:

    This API allows the caller to delete an existing Code Identifier.
    If the GUID exists it will be deleted from both the persisted
    registry store and the in-process identity cache.

Arguments:

    pLevelRecord - the level to which the identity belongs.

    pIdentRecord - points to the identifier record to delete.

Return Value:

    Returns STATUS_SUCCESS on successful operation.

--*/
{
    NTSTATUS Status;
    WCHAR szPathBuffer[MAX_PATH];
    UNICODE_STRING UnicodePath;
    HANDLE hKeyIdentity;
    LPCWSTR szIdentityType;


    //
    // Verify our input arguments.
    //
    if (!ARGUMENT_PRESENT(pIdentRecord) ||
        !ARGUMENT_PRESENT(pLevelRecord)) {
        // Specified a NULL buffer pointer.
        Status = STATUS_ACCESS_VIOLATION;
        goto ExitHandler;
    }


    //
    // Ensure that all of the GUIDs supplied by the user represent
    // Code Identities that exist within this Safer Level.
    //
    if (pIdentRecord->dwLevelId != pLevelRecord->dwLevelId) {
        // One of the Identifier GUIDs specified does
        // not actually exist.
        Status = STATUS_NOT_FOUND;
        goto ExitHandler;
    }


    //
    // Delete the Code Identity from the registry first.
    //
    switch (pIdentRecord->dwIdentityType) {
        case SaferIdentityTypeImageName:
            szIdentityType = SAFER_PATHS_REGSUBKEY;
            break;
        case SaferIdentityTypeImageHash:
            szIdentityType = SAFER_HASHMD5_REGSUBKEY;
            break;
        case SaferIdentityTypeUrlZone:
            szIdentityType = SAFER_SOURCEURL_REGSUBKEY;
            break;
        default:
            Status = STATUS_NOT_FOUND;
            goto ExitHandler;
    }
    RtlInitEmptyUnicodeString(
            &UnicodePath, szPathBuffer, sizeof(szPathBuffer));
    Status = CodeAuthzpFormatIdentityKeyPath(
            pIdentRecord->dwLevelId,
            szIdentityType,
            &pIdentRecord->IdentGuid,
            &UnicodePath);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpOpenPolicyRootKey(
            pIdentRecord->dwScopeId,
            g_hKeyCustomRoot,
            szPathBuffer,
            KEY_READ | DELETE,
            FALSE, &hKeyIdentity);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpDeleteKeyRecursively(hKeyIdentity, NULL);
    NtClose(hKeyIdentity);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }


    //
    // Delete the record from the cached table.
    //
    RtlDeleteElementGenericTable(
            &g_CodeIdentitiesTable,
            pIdentRecord);

    Status = STATUS_SUCCESS;


ExitHandler:
    return Status;
}


NTSTATUS NTAPI
SaferpSetSingleIdentificationPath(
        IN BOOLEAN bAllowCreation,
        IN OUT PAUTHZIDENTSTABLERECORD pIdentRecord,
        IN PSAFER_PATHNAME_IDENTIFICATION pIdentChanges,
        IN BOOL UpdateCache
        )
/*++

Routine Description:

    Updates the registry and the local Identification table cache
    with new properties about a ImagePath Code Identifier.

Arguments:

    bAllowCreation - indicates if the modification of this record has
        the potential of being the initial creation of this record.
        If this is false and the corresponding key location within the
        registry does not already exist, then this function call
        will fail.

    pIdentRecord - the cached code identity record that should be
        updated with new values.  This argument must always be supplied,
        even if the Code Identity is being created for the first time
        (in which case, this argument should be the new record that
        the caller has just inserted into the cached idents table).

    pIdentChanges - the input structure containing the new modifications
        that should be made to the specified Code Identity.

    UpdateCache - When FALSE, this is a default rule being created and does
        not need cache updation.

Return Value:

    Return STATUS_SUCCESS on success completion, or another error
    status code indicating the nature of the failure.

--*/
{
    const static UNICODE_STRING UnicodeLastModified =
            RTL_CONSTANT_STRING(SAFER_IDS_LASTMODIFIED_REGVALUE);
    const static UNICODE_STRING UnicodeDescription =
            RTL_CONSTANT_STRING(SAFER_IDS_DESCRIPTION_REGVALUE);
    const static UNICODE_STRING UnicodeSaferFlags =
            RTL_CONSTANT_STRING(SAFER_IDS_SAFERFLAGS_REGVALUE);
    const static UNICODE_STRING UnicodeItemData =
            RTL_CONSTANT_STRING(SAFER_IDS_ITEMDATA_REGVALUE);
    NTSTATUS Status;
    HANDLE hKeyIdentity = NULL;
    UNICODE_STRING UnicodeTemp;
    UNICODE_STRING UnicodeNewDescription;
    UNICODE_STRING UnicodeNewImagePath;
    WCHAR szPathBuffer[MAX_PATH];
    DWORD dwSaferFlags;
    FILETIME CurrentTime;
    BOOLEAN bExpandVars;


    //
    // Verify our arguments.  These things should have been ensured
    // by our caller already, so we only assert them here.
    //
    ASSERT(ARGUMENT_PRESENT(pIdentRecord) &&
           ARGUMENT_PRESENT(pIdentChanges) &&
           pIdentChanges->header.dwIdentificationType == SaferIdentityTypeImageName &&
           IsEqualGUID(&pIdentChanges->header.IdentificationGuid, &pIdentRecord->IdentGuid));


    //
    // Verify that the existing type matches the new type.
    // Cannot change identity type once it has been created.
    //
    if (pIdentRecord->dwIdentityType != SaferIdentityTypeImageName) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Verify that the string arguments are properly terminated.
    // We require that they fit entirely within the input buffer
    // and also have an explicit null terminator.
    //
    RtlInitUnicodeString(&UnicodeNewImagePath, pIdentChanges->ImageName);
    RtlInitUnicodeString(&UnicodeNewDescription, pIdentChanges->Description);
    if (UnicodeNewDescription.Length >=
                SAFER_MAX_DESCRIPTION_SIZE * sizeof(WCHAR) ||
        UnicodeNewImagePath.Length == 0) {
        // One of these buffers was not NULL terminated.
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }



    //
    // Open a registry handle to the Code Identity.
    //
    RtlInitEmptyUnicodeString(
            &UnicodeTemp, szPathBuffer, sizeof(szPathBuffer));
    Status = CodeAuthzpFormatIdentityKeyPath(
            pIdentRecord->dwLevelId,
            SAFER_PATHS_REGSUBKEY,
            &pIdentRecord->IdentGuid,
            &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpOpenPolicyRootKey(
            pIdentRecord->dwScopeId,
            g_hKeyCustomRoot,
            szPathBuffer,
            KEY_READ | KEY_WRITE,
            bAllowCreation,
            &hKeyIdentity);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }



    //
    // Set the "Last Modified" attribute in the registry.
    //
    GetSystemTimeAsFileTime(&CurrentTime);
    ASSERT(sizeof(DWORD) * 2 == sizeof(FILETIME));
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeLastModified,
                0, REG_QWORD, (LPBYTE) &CurrentTime,
                sizeof(DWORD) * 2);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "Description" attribute in the registry.
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeDescription,
                0, REG_SZ, (LPBYTE) UnicodeNewDescription.Buffer,
                UnicodeNewDescription.MaximumLength);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "SaferFlags" attribute in the registry (and in our cache).
    //
    dwSaferFlags = pIdentChanges->dwSaferFlags;
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeSaferFlags,
                0, REG_DWORD, (LPBYTE) &dwSaferFlags, sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "image pathname" attribute in the registry (and our cache).
    //
    bExpandVars = (wcschr(pIdentChanges->ImageName, L'%') != NULL ? TRUE : FALSE);
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeItemData,
                0, (bExpandVars ? REG_EXPAND_SZ : REG_SZ),
                (LPBYTE) UnicodeNewImagePath.Buffer,
                UnicodeNewImagePath.MaximumLength );
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    if (UpdateCache) {
        RtlFreeUnicodeString(&pIdentRecord->ImageNameInfo.ImagePath);
        Status = RtlDuplicateUnicodeString(
                        RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE,
                        &UnicodeNewImagePath,
                        &pIdentRecord->ImageNameInfo.ImagePath);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
        pIdentRecord->ImageNameInfo.bExpandVars = bExpandVars;
        pIdentRecord->ImageNameInfo.dwSaferFlags = dwSaferFlags;
    }

    Status = STATUS_SUCCESS;


ExitHandler2:
    NtClose(hKeyIdentity);

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
SaferpSetSingleIdentificationHash(
        IN BOOLEAN bAllowCreation,
        IN OUT PAUTHZIDENTSTABLERECORD pIdentRecord,
        IN PSAFER_HASH_IDENTIFICATION pIdentChanges
        )
/*++

Routine Description:

    Updates the registry and the local Identification table cache
    with new properties about a hash Code Identifier.

Arguments:

    bAllowCreation - indicates if the modification of this record has
        the potential of being the initial creation of this record.
        If this is false and the corresponding key location within the
        registry does not already exist, then this function call
        will fail.

    pIdentRecord - the cached code identity record that should be
        updated with new values.  This argument must always be supplied,
        even if the Code Identity is being created for the first time
        (in which case, this argument should be the new record that
        the caller has just inserted into the cached idents table).

    pIdentChanges - the input structure containing the new modifications
        that should be made to the specified Code Identity.

Return Value:

    Return STATUS_SUCCESS on success completion, or another error
    status code indicating the nature of the failure.

--*/
{
    const static UNICODE_STRING UnicodeLastModified =
            RTL_CONSTANT_STRING(SAFER_IDS_LASTMODIFIED_REGVALUE);
    const static UNICODE_STRING UnicodeDescription =
            RTL_CONSTANT_STRING(SAFER_IDS_DESCRIPTION_REGVALUE);
    const static UNICODE_STRING UnicodeSaferFlags =
            RTL_CONSTANT_STRING(SAFER_IDS_SAFERFLAGS_REGVALUE);
    const static UNICODE_STRING UnicodeItemData =
            RTL_CONSTANT_STRING(SAFER_IDS_ITEMDATA_REGVALUE);
    const static UNICODE_STRING UnicodeFriendlyName =
            RTL_CONSTANT_STRING(SAFER_IDS_FRIENDLYNAME_REGVALUE);
    const static UNICODE_STRING UnicodeItemSize =
            RTL_CONSTANT_STRING(SAFER_IDS_ITEMSIZE_REGVALUE);
    const static UNICODE_STRING UnicodeHashAlgorithm =
            RTL_CONSTANT_STRING(SAFER_IDS_HASHALG_REGVALUE);

    NTSTATUS Status;
    HANDLE hKeyIdentity = NULL;
    UNICODE_STRING UnicodeTemp;
    UNICODE_STRING UnicodeNewFriendlyName;
    UNICODE_STRING UnicodeNewDescription;
    WCHAR szPathBuffer[MAX_PATH];
    DWORD dwSaferFlags;
    FILETIME CurrentTime;


    //
    // Verify our arguments.  These things should have been ensured
    // by our caller already, so we only assert them here.
    //
    ASSERT(ARGUMENT_PRESENT(pIdentRecord) &&
           ARGUMENT_PRESENT(pIdentChanges) &&
           pIdentChanges->header.dwIdentificationType == SaferIdentityTypeImageHash &&
           pIdentChanges->header.cbStructSize == sizeof(SAFER_HASH_IDENTIFICATION) &&
           IsEqualGUID(&pIdentChanges->header.IdentificationGuid, &pIdentRecord->IdentGuid));


    //
    // Verify that the existing type matches the new type.
    // Cannot change identity type once it has been created.
    //
    if (pIdentRecord->dwIdentityType != SaferIdentityTypeImageHash) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Verify that the string arguments are properly terminated.
    // We require that they fit entirely within the input buffer
    // and also have an explicit null terminator.
    //
    RtlInitUnicodeString(&UnicodeNewDescription, pIdentChanges->Description);
    RtlInitUnicodeString(&UnicodeNewFriendlyName, pIdentChanges->FriendlyName);
    if (UnicodeNewDescription.Length >=
                SAFER_MAX_DESCRIPTION_SIZE * sizeof(WCHAR) ||
        UnicodeNewFriendlyName.Length >=
                SAFER_MAX_FRIENDLYNAME_SIZE * sizeof(WCHAR) ||
        pIdentChanges->HashSize > SAFER_MAX_HASH_SIZE)
    {
        // One of these buffers was not NULL terminated or
        // the hash size specified was invalid.
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }
    if ((pIdentChanges->HashAlgorithm & ALG_CLASS_ALL) != ALG_CLASS_HASH ||
        pIdentChanges->HashSize < 1) {
        // The hash algorithm method was an invalid type, or
        // a zero-length hash was supplied.
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Open a registry handle to the Code Identity.
    //
    RtlInitEmptyUnicodeString(
            &UnicodeTemp, szPathBuffer, sizeof(szPathBuffer));
    Status = CodeAuthzpFormatIdentityKeyPath(
            pIdentRecord->dwLevelId,
            SAFER_HASHMD5_REGSUBKEY,
            &pIdentRecord->IdentGuid,
            &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpOpenPolicyRootKey(
            pIdentRecord->dwScopeId,
            g_hKeyCustomRoot,
            szPathBuffer,
            KEY_READ | KEY_WRITE,
            bAllowCreation,
            &hKeyIdentity);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }


    //
    // Set the "Last Modified" attribute in the registry.
    //
    GetSystemTimeAsFileTime(&CurrentTime);
    ASSERT(sizeof(DWORD) * 2 == sizeof(FILETIME));
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeLastModified, 0,
                REG_QWORD, (LPBYTE) &CurrentTime,
                sizeof(DWORD) * 2);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "Description" attribute in the registry.
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeDescription,
                0, REG_SZ, (LPBYTE) UnicodeNewDescription.Buffer,
                UnicodeNewDescription.MaximumLength);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "FriendlyName" attribute in the registry.
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeFriendlyName,
                0, REG_SZ, (LPBYTE) UnicodeNewFriendlyName.Buffer,
                UnicodeNewFriendlyName.MaximumLength);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "SaferFlags" attribute in the registry (and in our cache).
    //
    #ifdef SAFER_SAFERFLAGS_ONLY_EXES
    dwSaferFlags = (pIdentChanges->dwSaferFlags &
            ~SAFER_SAFERFLAGS_ONLY_EXES);
    #else
    dwSaferFlags = pIdentChanges->dwSaferFlags;
    #endif
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeSaferFlags,
                0, REG_DWORD, (LPBYTE) &dwSaferFlags, sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageNameInfo.dwSaferFlags = dwSaferFlags;


    //
    // Set the "image size" attribute in the registry (and our cache).
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeItemSize,
                0, REG_QWORD, (LPBYTE) &pIdentChanges->ImageSize.QuadPart,
                sizeof(DWORD) * 2);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageHashInfo.ImageSize.QuadPart =
        pIdentChanges->ImageSize.QuadPart;


    //
    // Set the "image hash" attribute in the registry (and our cache).
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeItemData,
                0, REG_BINARY, (LPBYTE) pIdentChanges->ImageHash,
                pIdentChanges->HashSize);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageHashInfo.HashSize =
        pIdentChanges->HashSize;
    RtlCopyMemory(&pIdentRecord->ImageHashInfo.ImageHash[0],
                  &pIdentChanges->ImageHash[0],
                  pIdentChanges->HashSize);

    //
    // Set the "hash algorithm" attribute in the registry (and our cache).
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeHashAlgorithm,
                0, REG_DWORD, (LPBYTE) &pIdentChanges->HashAlgorithm,
                sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageHashInfo.HashAlgorithm =
        pIdentChanges->HashAlgorithm;


    Status = STATUS_SUCCESS;


ExitHandler2:
    NtClose(hKeyIdentity);

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
SaferpSetSingleIdentificationZone(
        IN BOOLEAN bAllowCreation,
        IN OUT PAUTHZIDENTSTABLERECORD pIdentRecord,
        IN PSAFER_URLZONE_IDENTIFICATION pIdentChanges
        )
/*++

Routine Description:

    Updates the registry and the local Identification table cache
    with new properties about a URL Zone Code Identifier.

Arguments:

    bAllowCreation - indicates if the modification of this record has
        the potential of being the initial creation of this record.
        If this is false and the corresponding key location within the
        registry does not already exist, then this function call
        will fail.

    pIdentRecord - the cached code identity record that should be
        updated with new values.  This argument must always be supplied,
        even if the Code Identity is being created for the first time
        (in which case, this argument should be the new record that
        the caller has just inserted into the cached idents table).

    pIdentChanges - the input structure containing the new modifications
        that should be made to the specified Code Identity.

Return Value:

    Return STATUS_SUCCESS on success completion, or another error
    status code indicating the nature of the failure.

--*/
{
    const static UNICODE_STRING UnicodeLastModified =
            RTL_CONSTANT_STRING(SAFER_IDS_LASTMODIFIED_REGVALUE);
    const static UNICODE_STRING UnicodeSaferFlags =
            RTL_CONSTANT_STRING(SAFER_IDS_SAFERFLAGS_REGVALUE);
    const static UNICODE_STRING UnicodeItemData =
            RTL_CONSTANT_STRING(SAFER_IDS_ITEMDATA_REGVALUE);

    NTSTATUS Status;
    HANDLE hKeyIdentity = NULL;
    UNICODE_STRING UnicodeTemp;
    WCHAR szPathBuffer[MAX_PATH];
    DWORD dwSaferFlags;
    FILETIME CurrentTime;


    //
    // Verify our arguments.  These things should have been ensured
    // by our caller already, so we only assert them here.
    //
    ASSERT(ARGUMENT_PRESENT(pIdentRecord) &&
           ARGUMENT_PRESENT(pIdentChanges) &&
           pIdentChanges->header.dwIdentificationType == SaferIdentityTypeUrlZone &&
           pIdentChanges->header.cbStructSize == sizeof(SAFER_URLZONE_IDENTIFICATION) &&
           IsEqualGUID(&pIdentChanges->header.IdentificationGuid, &pIdentRecord->IdentGuid));


    //
    // Verify that the existing type matches the new type.
    // Cannot change identity type once it has been created.
    //
    if (pIdentRecord->dwIdentityType != SaferIdentityTypeUrlZone) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Open a registry handle to the Code Identity.
    //
    RtlInitEmptyUnicodeString(
            &UnicodeTemp, szPathBuffer, sizeof(szPathBuffer));
    Status = CodeAuthzpFormatIdentityKeyPath(
            pIdentRecord->dwLevelId,
            SAFER_SOURCEURL_REGSUBKEY,
            &pIdentRecord->IdentGuid,
            &UnicodeTemp);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    Status = CodeAuthzpOpenPolicyRootKey(
            pIdentRecord->dwScopeId,
            g_hKeyCustomRoot,
            szPathBuffer,
            KEY_READ | KEY_WRITE,
            bAllowCreation,
            &hKeyIdentity);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }



    //
    // Set the "Last Modified" attribute in the registry.
    //
    GetSystemTimeAsFileTime(&CurrentTime);
    ASSERT(sizeof(DWORD) * 2 == sizeof(FILETIME));
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeLastModified,
                0, REG_QWORD, (LPBYTE) &CurrentTime,
                sizeof(DWORD) * 2);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Set the "SaferFlags" attribute in the registry (and in our cache).
    //
    #ifdef SAFER_SAFERFLAGS_ONLY_EXES
    dwSaferFlags = (pIdentChanges->dwSaferFlags &
                    ~SAFER_SAFERFLAGS_ONLY_EXES);
    #else
    dwSaferFlags = pIdentChanges->dwSaferFlags;
    #endif
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeSaferFlags,
                0, REG_DWORD, (LPBYTE) &dwSaferFlags, sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageNameInfo.dwSaferFlags = dwSaferFlags;


    //
    // Set the "ZoneId" attribute in the registry (and our cache).
    //
    Status = NtSetValueKey(
                hKeyIdentity,
                (PUNICODE_STRING) &UnicodeItemData,
                0, REG_DWORD, (LPBYTE) &pIdentChanges->UrlZoneId,
                sizeof(DWORD));
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }
    pIdentRecord->ImageZone.UrlZoneId = pIdentChanges->UrlZoneId;


    Status = STATUS_SUCCESS;


ExitHandler2:
    NtClose(hKeyIdentity);

ExitHandler:
    return Status;
}




NTSTATUS NTAPI
SaferpSetExistingSingleIdentification(
        IN OUT PAUTHZIDENTSTABLERECORD pIdentRecord,
        IN PSAFER_IDENTIFICATION_HEADER pCommon
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS Status;


    //
    // Verify our arguments.  These things should have been ensured
    // by our caller already, so we only assert them here.
    //
    ASSERT(ARGUMENT_PRESENT(pIdentRecord) &&
           ARGUMENT_PRESENT(pCommon) &&
           pCommon->cbStructSize >= sizeof(SAFER_IDENTIFICATION_HEADER) &&
           IsEqualGUID(&pCommon->IdentificationGuid, &pIdentRecord->IdentGuid) );



    //
    // Perform the appropriate action depending on the identification
    // data type, including verifying that the structure size matches
    // the size that we are expecting.
    //
    switch (pCommon->dwIdentificationType)
    {
        case SaferIdentityTypeImageName:

            Status = SaferpSetSingleIdentificationPath(
                        FALSE, pIdentRecord,
                        (PSAFER_PATHNAME_IDENTIFICATION) pCommon, TRUE);
            break;

        // --------------------

        case SaferIdentityTypeImageHash:
            if (pCommon->cbStructSize ==
                    sizeof(SAFER_HASH_IDENTIFICATION)) {
                // Request to change and a Unicode structure was given.
                Status = SaferpSetSingleIdentificationHash(
                        FALSE, pIdentRecord,
                        (PSAFER_HASH_IDENTIFICATION) pCommon);

            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

        // --------------------

        case SaferIdentityTypeUrlZone:
            if (pCommon->cbStructSize ==
                    sizeof(SAFER_URLZONE_IDENTIFICATION)) {
                Status = SaferpSetSingleIdentificationZone(
                        FALSE, pIdentRecord,
                        (PSAFER_URLZONE_IDENTIFICATION) pCommon);
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

        // --------------------

        default:
            Status = STATUS_INVALID_INFO_CLASS;
    }

    return Status;
}





NTSTATUS NTAPI
SaferpCreateNewSingleIdentification(
        IN DWORD dwScopeId,
        IN PAUTHZLEVELTABLERECORD pLevelRecord,
        IN PSAFER_IDENTIFICATION_HEADER pCommon
        )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS Status;
    AUTHZIDENTSTABLERECORD NewIdentRecord;
    PAUTHZIDENTSTABLERECORD pIdentRecord;


    //
    // Verify our arguments.  These things should have been ensured
    // by our caller already, so we only assert them here.
    //
    ASSERT(ARGUMENT_PRESENT(pLevelRecord) &&
           ARGUMENT_PRESENT(pCommon) &&
           pCommon->cbStructSize >= sizeof(SAFER_IDENTIFICATION_HEADER) &&
           !CodeAuthzIdentsLookupByGuid(&g_CodeIdentitiesTable,
                                        &pCommon->IdentificationGuid) );
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
        if (dwScopeId == SAFER_SCOPEID_USER && !g_bHonorScopeUser) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler;
        }
    }


    //
    // Prepare a new Code Identity structure since we will likely
    // need to insert a new record for the entry that will be created.
    //
    RtlZeroMemory(&NewIdentRecord, sizeof(AUTHZIDENTSTABLERECORD));
    NewIdentRecord.dwIdentityType = pCommon->dwIdentificationType;
    NewIdentRecord.dwLevelId = pLevelRecord->dwLevelId;
    NewIdentRecord.dwScopeId = dwScopeId;
    RtlCopyMemory(&NewIdentRecord.IdentGuid,
                  &pCommon->IdentificationGuid,
                  sizeof(GUID));
    if (IsZeroGUID(&NewIdentRecord.IdentGuid)) {
        Status = STATUS_INVALID_PARAMETER;
        goto ExitHandler;
    }


    //
    // Perform the appropriate action depending on the identification
    // data type, including verifying that the structure size matches
    // the size that we are expecting.
    //
    switch (pCommon->dwIdentificationType)
    {
        // --------------------

        case SaferIdentityTypeImageName:
            RtlInsertElementGenericTable(
                &g_CodeIdentitiesTable,
                (PVOID) &NewIdentRecord,
                sizeof(AUTHZIDENTSTABLERECORD),
                NULL);
            pIdentRecord = CodeAuthzIdentsLookupByGuid(
                &g_CodeIdentitiesTable,
                &pCommon->IdentificationGuid);
            if (!pIdentRecord) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
            Status = SaferpSetSingleIdentificationPath(
                TRUE, pIdentRecord,
                (PSAFER_PATHNAME_IDENTIFICATION) pCommon, TRUE);
            if (!NT_SUCCESS(Status)) {
                RtlDeleteElementGenericTable(
                        &g_CodeIdentitiesTable,
                        (PVOID) &NewIdentRecord);
            }
            break;

        // --------------------

        case SaferIdentityTypeImageHash:
            if (pCommon->cbStructSize ==
                    sizeof(SAFER_HASH_IDENTIFICATION)) {

                RtlInsertElementGenericTable(
                    &g_CodeIdentitiesTable,
                    (PVOID) &NewIdentRecord,
                    sizeof(AUTHZIDENTSTABLERECORD),
                    NULL);
                pIdentRecord = CodeAuthzIdentsLookupByGuid(
                    &g_CodeIdentitiesTable,
                    &pCommon->IdentificationGuid);
                if (!pIdentRecord) {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }
                Status = SaferpSetSingleIdentificationHash(
                    TRUE, pIdentRecord,
                    (PSAFER_HASH_IDENTIFICATION) pCommon);
                if (!NT_SUCCESS(Status)) {
                    RtlDeleteElementGenericTable(
                            &g_CodeIdentitiesTable,
                            (PVOID) &NewIdentRecord);
                }

            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

        // --------------------

        case SaferIdentityTypeUrlZone:
            if (pCommon->cbStructSize ==
                    sizeof(SAFER_URLZONE_IDENTIFICATION)) {

                RtlInsertElementGenericTable(
                    &g_CodeIdentitiesTable,
                    (PVOID) &NewIdentRecord,
                    sizeof(AUTHZIDENTSTABLERECORD),
                    NULL);
                pIdentRecord = CodeAuthzIdentsLookupByGuid(
                    &g_CodeIdentitiesTable,
                    &pCommon->IdentificationGuid);
                if (!pIdentRecord) {
                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }
                Status = SaferpSetSingleIdentificationZone(
                    TRUE, pIdentRecord,
                    (PSAFER_URLZONE_IDENTIFICATION) pCommon);
                if (!NT_SUCCESS(Status)) {
                    RtlDeleteElementGenericTable(
                            &g_CodeIdentitiesTable,
                            (PVOID) &NewIdentRecord);
                }

            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

        // --------------------

        default:
            Status = STATUS_INVALID_INFO_CLASS;
            break;
    }

ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzpSetAuthzLevelInfo(
        IN SAFER_LEVEL_HANDLE                      LevelHandle,
        IN SAFER_OBJECT_INFO_CLASS     dwInfoType,
        IN LPVOID                           lpQueryBuffer,
        IN DWORD                            dwInBufferSize
        )
/*++

Routine Description:

    Allows the user to modify various pieces of information about a
    given WinSafer Level.

Arguments:

    LevelHandle - the handle to the authorization object to evaluate.

    dwInfoType - specifies the type of information being modified.

    lpQueryBuffer - pointer to a user-supplied memory buffer that
        contains the new data for the item being modified.

    dwInBufferSize - specifies the size of the user's memory block.
        For string arguments, this size includes the terminating null.

Return Value:

    Returns STATUS_SUCCESS on success.

--*/
{
    NTSTATUS Status;
    PAUTHZLEVELHANDLESTRUCT pLevelStruct;
    PAUTHZLEVELTABLERECORD pLevelRecord;
    DWORD dwHandleScopeId;
    BOOLEAN bNeedLevelRegKey;
    UNICODE_STRING ValueName, UnicodeRegistrySuffix;
    HANDLE hRegLevelBase;


    //
    // Obtain a pointer to the authorization object structure
    //
    Status = CodeAuthzHandleToLevelStruct(LevelHandle, &pLevelStruct);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler;
    }
    ASSERT(pLevelStruct != NULL);
    pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, pLevelStruct->dwLevelId);
    if (!pLevelRecord) {
        Status = STATUS_INVALID_HANDLE;
        goto ExitHandler;
    }
    dwHandleScopeId = pLevelStruct->dwScopeId;


    //
    // Determine if we need to open a registry handle to the Level key.
    //
    bNeedLevelRegKey = FALSE;
    switch (dwInfoType)
    {
        case SaferObjectLevelId:              // DWORD
        case SaferObjectScopeId:              // DWORD
        case SaferObjectBuiltin:              // DWORD boolean
            // These information classes cannot be altered with this API.
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;

        case SaferObjectFriendlyName:         // LPCTSTR
        case SaferObjectDescription:          // LPCTSTR
            if (pLevelRecord->Builtin) {
                // Don't allow built-in Levels to be modified at all.
                Status = STATUS_ACCESS_DENIED;
                goto ExitHandler;
            }
            // All of these classes need to access the Level key.
            bNeedLevelRegKey = TRUE;
            break;

#ifdef ALLOW_FULL_WINSAFER
        case SaferObjectDisallowed:               // DWORD boolean
        case SaferObjectDisableMaxPrivilege:      // DWORD boolean
        case SaferObjectInvertDeletedPrivileges:  // DWORD boolean
        case SaferObjectDefaultOwner:             // TOKEN_OWNER
        case SaferObjectDeletedPrivileges:        // TOKEN_PRIVILEGES
        case SaferObjectSidsToDisable:            // TOKEN_GROUPS
        case SaferObjectRestrictedSidsInverted:   // TOKEN_GROUPS
        case SaferObjectRestrictedSidsAdded:      // TOKEN_GROUPS
            if (pLevelRecord->Builtin) {
                // Don't allow built-in Levels to be modified at all.
                Status = STATUS_ACCESS_DENIED;
                goto ExitHandler;
            }
            // All of these classes need to access the Level key.
            bNeedLevelRegKey = TRUE;
            break;
#endif

        case SaferObjectAllIdentificationGuids:
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;

        case SaferObjectSingleIdentification:
            // These only modify Code Identity keys.
            break;

        default:
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler;
    }



    //
    // Open the registry handle to where this Level is stored.
    //
    if (bNeedLevelRegKey) {
        WCHAR szRegistrySuffix[MAX_PATH];

        RtlInitEmptyUnicodeString(
                    &UnicodeRegistrySuffix,
                    szRegistrySuffix,
                    sizeof(szRegistrySuffix));
        Status = CodeAuthzpFormatLevelKeyPath(
                    pLevelRecord->dwLevelId,
                    &UnicodeRegistrySuffix);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        }
        Status = CodeAuthzpOpenPolicyRootKey(
                    g_hKeyCustomRoot != NULL ?
                            SAFER_SCOPEID_REGISTRY : SAFER_SCOPEID_MACHINE,
                    g_hKeyCustomRoot, szRegistrySuffix,
                    KEY_WRITE, TRUE, &hRegLevelBase);
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler;
        }
    } else {
        hRegLevelBase = NULL;
    }



    //
    // Otherwise perform the actual "Set" operation.
    //
    switch (dwInfoType)
    {
        case SaferObjectFriendlyName:         // LPCTSTR
            ASSERT(hRegLevelBase != NULL);
            RtlInitUnicodeString(&ValueName,
                                 SAFER_OBJFRIENDLYNAME_REGVALUEW);
            Status = NtSetValueKey(hRegLevelBase,
                    &ValueName, 0, REG_SZ,
                    (LPBYTE) lpQueryBuffer, dwInBufferSize);
            goto ExitHandler2;


        case SaferObjectDescription:          // LPCTSTR
            ASSERT(hRegLevelBase != NULL);
            RtlInitUnicodeString(&ValueName,
                                 SAFER_OBJDESCRIPTION_REGVALUEW);
            Status = NtSetValueKey(hRegLevelBase,
                    &ValueName, 0, REG_SZ,
                    (LPBYTE) lpQueryBuffer, dwInBufferSize);
            goto ExitHandler2;


#ifdef ALLOW_FULL_WINSAFER
        case SaferObjectDisallowed:               // DWORD boolean
            ASSERT(hRegLevelBase != NULL);
            if (!ARGUMENT_PRESENT(lpQueryBuffer) ||
                    dwInBufferSize != sizeof(DWORD)) {
                Status = STATUS_INVALID_PARAMETER;
                goto ExitHandler2;
            }
            RtlInitUnicodeString(&ValueName, SAFER_OBJDISALLOW_REGVALUE);
            Status = NtSetValueKey(hRegLevelBase,
                    &ValueName, 0, REG_DWORD,
                    (LPBYTE) lpQueryBuffer, dwInBufferSize);
            if (NT_SUCCESS(Status)) {
                goto ExitHandler2;
            } else {
                pLevelRecord->DisallowExecution =
                    ( *((LPDWORD) lpQueryBuffer) != 0 ? TRUE : FALSE );
            }
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;

        case SaferObjectDisableMaxPrivilege:      // DWORD boolean
            ASSERT(hRegLevelBase != NULL);

            // Make sure the argument is the correct size.
            if (!ARGUMENT_PRESENT(lpQueryBuffer) ||
                    dwInBufferSize != sizeof(DWORD)) {
                Status = STATUS_INVALID_PARAMETER;
                goto ExitHandler2;
            }

            // Actually write the value to the correct place.
            Status = SaferpSetRegistryHelper(
                    hRegLevelBase,
                    L"Restrictions",
                    L"PrivsToRemove",
                    L"DisableMaxPrivilege",
                    REG_DWORD,
                    lpQueryBuffer,
                    dwInBufferSize);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;

        case SaferObjectInvertDeletedPrivileges:  // DWORD boolean
            ASSERT(hRegLevelBase != NULL);

            // Make sure the argument is the correct size.
            if (!ARGUMENT_PRESENT(lpQueryBuffer) ||
                    dwInBufferSize != sizeof(DWORD)) {
                Status = STATUS_INVALID_PARAMETER;
                goto ExitHandler2;
            }

            // Actually write the value to the correct place.
            Status = SaferpSetRegistryHelper(
                    hRegLevelBase,
                    L"Restrictions",
                    L"PrivsToRemove",
                    L"InvertPrivs",
                    REG_DWORD,
                    lpQueryBuffer,
                    dwInBufferSize);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;

        case SaferObjectDefaultOwner:             // TOKEN_OWNER
        {
            BOOLEAN AllocatedStringSid = FALSE;
            UNICODE_STRING UnicodeStringSid;
            PTOKEN_OWNER pTokenOwner = (PTOKEN_OWNER) lpQueryBuffer;

            ASSERT(hRegLevelBase != NULL);
            if (pTokenOwner->Owner == NULL) {
                RtlInitUnicodeString(&UnicodeStringSid, L"");
            }
            else {
                Status = RtlConvertSidToUnicodeString( &UnicodeStringSid,
                        pTokenOwner->Owner, TRUE );
                if (!NT_SUCCESS(Status)) goto ExitHandler2;
                AllocatedStringSid = TRUE;
            }

            Status = SaferpSetRegistryHelper(
                    hRegLevelBase,
                    L"Restrictions",
                    NULL,
                    L"DefaultOwner",
                    REG_SZ,
                    lpQueryBuffer,
                    dwInBufferSize);

            if (AllocatedStringSid)
                RtlFreeUnicodeString(&UnicodeStringSid);

            if (!NT_SUCCESS(Status)) goto ExitHandler2;

            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;
        }

        case SaferObjectDeletedPrivileges:        // TOKEN_PRIVILEGES
        {
            HKEY hKeyPrivsToRemove;
            UNICODE_STRING ValueName;
            PTOKEN_PRIVILEGES pTokenPrivs =
                    (PTOKEN_PRIVILEGES) lpQueryBuffer;

            // Open a handle to the correct subkey.
            ASSERT(hRegLevelBase != NULL);
            Status = SaferpCreateSecondLevelKey(
                            hRegLevelBase,
                            L"Restrictions",
                            L"PrivsToRemove",
                            &hKeyPrivsToRemove);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;

            // Clear out all old values under the subkey.
            Status = SaferpClearRegistryListHelper(
                            hKeyPrivsToRemove,
                            L"Count",
                            L"Priv");
            if (!NT_SUCCESS(Status)) {
                // Bad luck!  Possibly left in incomplete state!
                NtClose(hKeyPrivsToRemove);
                goto ExitHandler2;
            }

            // Now add all of the new ones we're supposed to add.
            RtlInitUnicodeString(&ValueName, L"Count");
            Status = NtSetValueKey(hKeyPrivsToRemove,
                    &ValueName, 0, REG_DWORD,
                    (LPBYTE) pTokenPrivs->PrivilegeCount, sizeof(DWORD));
            if (!NT_SUCCESS(Status)) {
                // Bad luck!  Possibly left in incomplete state!
                NtClose(hKeyPrivsToRemove);
                goto ExitHandler2;
            }
            for (Index = 0; Index < pTokenPrivs->PrivilegeCount; Index++)
            {
                WCHAR ValueNameBuffer[20];
                WCHAR PrivilegeNameBuffer[64];
                DWORD dwPrivilegeNameLen;

                wsprintfW(ValueNameBuffer, L"Priv%d", Index);
                RtlInitUnicodeString(&ValueName, ValueNameBuffer);

                dwPrivilegeNameLen = sizeof(PrivilegeNameBuffer) / sizeof(WCHAR);
                if (!LookupPrivilegeNameW(NULL,
                        &pTokenPrivs->Privileges[Index].Luid,
                        PrivilegeNameBuffer,
                        &dwPrivilegeNameLen))
                {
                    // Bad luck!  Possibly left in incomplete state!
                    Status = STATUS_NO_SUCH_PRIVILEGE;
                    NtClose(hKeyPrivsToRemove);
                    goto ExitHandler2;
                }

                Status = NtSetValueKey(hKeyPrivsToRemove,
                    &ValueName, 0, REG_SZ,
                    (LPBYTE) PrivilegeNameBuffer,
                    (wcslen(PrivilegeNameBuffer) + 1) * sizeof(WCHAR));
                if (!NT_SUCCESS(Status)) {
                    // Bad luck!  Possibly left in incomplete state!
                    NtClose(hKeyPrivsToRemove);
                    goto ExitHandler2;
                }
            }
            NtClose(hKeyPrivsToRemove);
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;
        }

        case SaferObjectSidsToDisable:            // TOKEN_GROUPS
            //BLACKCOMB TODO: allow wildcard sids to be specified.
            ASSERT(hRegLevelBase != NULL);
            Status = SaferpSetListOfSids(
                    hRegLevelBase,
                    L"Restrictions",
                    L"SidsToDisable",
                    L"Count",
                    L"Group",
                    (PTOKEN_GROUPS) lpQueryBuffer);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;

        case SaferObjectRestrictedSidsInverted:   // TOKEN_GROUPS
            //BLACKCOMB TODO: allow wildcard sids to be specified.
            ASSERT(hRegLevelBase != NULL);
            Status = SaferpSetListOfSids(
                    hRegLevelBase,
                    L"Restrictions",
                    L"RestrictingSidsInverted",
                    L"Count",
                    L"Group",
                    (PTOKEN_GROUPS) lpQueryBuffer);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;

        case SaferObjectRestrictedSidsAdded:      // TOKEN_GROUPS
            ASSERT(hRegLevelBase != NULL);
            Status = SaferpSetListOfSids(
                    hRegLevelBase,
                    L"Restrictions",
                    L"RestrictingSidsAdded",
                    L"Count",
                    L"Group",
                    (PTOKEN_GROUPS) lpQueryBuffer);
            if (!NT_SUCCESS(Status)) goto ExitHandler2;
            //BLACKCOMB TODO: update cached pLevelRecord on success
            break;
#endif

        case SaferObjectSingleIdentification:
        {
            PAUTHZIDENTSTABLERECORD pIdentRecord;
            PSAFER_IDENTIFICATION_HEADER pCommon =
                (PSAFER_IDENTIFICATION_HEADER) lpQueryBuffer;

            if (!ARGUMENT_PRESENT(pCommon)) {
                Status = STATUS_ACCESS_VIOLATION;
                goto ExitHandler2;
            }
            if (dwInBufferSize < sizeof(SAFER_IDENTIFICATION_HEADER) ||
                dwInBufferSize < pCommon->cbStructSize) {
                Status = STATUS_INFO_LENGTH_MISMATCH;
                goto ExitHandler2;
            }
            pIdentRecord = CodeAuthzIdentsLookupByGuid(
                    &g_CodeIdentitiesTable,
                    &pCommon->IdentificationGuid);
            if (!pIdentRecord)
            {
                // Request to create a new Code Identifier.
                Status = SaferpCreateNewSingleIdentification(
                        dwHandleScopeId, pLevelRecord, pCommon);
            }
            else if (pCommon->dwIdentificationType == 0)
            {
                // Request to delete an existing Code Identifier.
                if (pIdentRecord->dwLevelId != pLevelRecord->dwLevelId ||
                    pIdentRecord->dwScopeId != dwHandleScopeId) {
                    Status = STATUS_NOT_FOUND;
                } else {
                    Status = SaferpDeleteSingleIdentificationGuid(
                            pLevelRecord, pIdentRecord);
                }
            }
            else
            {
                // Request to modify an existing Code Identifier.
                if (pIdentRecord->dwLevelId != pLevelRecord->dwLevelId ||
                    pIdentRecord->dwScopeId != dwHandleScopeId)
                {
                    // This was likely a request to create a new Code
                    // Identifier, but with a GUID that already exists.
                    Status = STATUS_OBJECT_NAME_COLLISION;
                } else {
                    Status = SaferpSetExistingSingleIdentification(
                                pIdentRecord, pCommon);
                }
            }
            goto ExitHandler2;
        }


        default:
            ASSERTMSG("invalid info class unhandled earlier", 0);
            Status = STATUS_INVALID_INFO_CLASS;
            goto ExitHandler2;
    }

    Status = STATUS_SUCCESS;



    //
    // Cleanup and epilogue code.
    //
ExitHandler2:
    if (hRegLevelBase != NULL) {
        NtClose(hRegLevelBase);
    }

ExitHandler:
    return Status;
}



BOOL WINAPI
SaferSetLevelInformation(
    IN SAFER_LEVEL_HANDLE                      LevelHandle,
    IN SAFER_OBJECT_INFO_CLASS     dwInfoType,
    IN LPVOID                           lpQueryBuffer,
    IN DWORD                            dwInBufferSize
    )
/*++

Routine Description:

    Allows the user to modify various pieces of information about a
    given WinSafer Level.

Arguments:

    LevelHandle - the handle to the WinSafer Level to evaluate.

    dwInfoType - specifies the type of information being modified.

    lpQueryBuffer - pointer to a user-supplied memory buffer that
        contains the new data for the item being modified.

    dwInBufferSize - specifies the size of the user's memory block.
        For string arguments, this size includes the terminating null.

Return Value:

    Returns FALSE on error, otherwise success.

--*/
{
    NTSTATUS Status;

    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);

    Status = CodeAuthzpSetAuthzLevelInfo(
            LevelHandle, dwInfoType,
            lpQueryBuffer, dwInBufferSize);

    RtlLeaveCriticalSection(&g_TableCritSec);

    if (NT_SUCCESS(Status))
        return TRUE;

ExitHandler:
    if (Status == STATUS_OBJECT_NAME_COLLISION) {
        SetLastError(ERROR_OBJECT_ALREADY_EXISTS);
    } else {
        BaseSetLastNTError(Status);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safepolr.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    safepolr.c         (SAFER Code Authorization Policy)

Abstract:

    This module implements the WinSAFER APIs that query and set the
    persisted and cached policy definitions.

Author:

    Jeffrey Lawson (JLawson) - Apr 1999

Environment:

    User mode only.

Exported Functions:


Revision History:

    Created - Apr 1999

--*/

#include "pch.h"
#pragma hdrstop
#include <winsafer.h>
#include <winsaferp.h>
#include "saferp.h"




NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_LevelListRaw(
        IN DWORD    dwScopeId,
        IN DWORD    InfoBufferSize OPTIONAL,
        OUT PVOID   InfoBuffer OPTIONAL,
        OUT PDWORD  InfoBufferRetSize OPTIONAL
        )
/*++

Routine Description:

    Asks the system to query for the list of available
    WinSafer Levels for the currently loaded policy scope.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - optionally specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - optionally specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

    InfoBufferRetSize - optionally specifies a pointer that will receive
        the size of the results actually written to the InfoBuffer.

Return Value:

    Returns STATUS_SUCCESS on successful return.  Otherwise a status
    code such as STATUS_BUFFER_TOO_SMALL or STATUS_NOT_FOUND.

--*/
{
    NTSTATUS Status;
    PVOID RestartKey;
    PAUTHZLEVELTABLERECORD authzobj;
    DWORD dwSizeNeeded;
    LPVOID lpNextPtr, lpEndBuffer;


    //
    // Load the list of all of the available objects.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    if (RtlIsGenericTableEmpty(&g_CodeLevelObjTable)) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }

    //
    // Determine the necessary size needed to store a DWORD array
    // of all of the Levels that were found in this scope.
    //
	dwSizeNeeded = 0;
    RestartKey = NULL;
    for (authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey);
        authzobj != NULL;
        authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey))
    {
		if (authzobj->isEnumerable) {  //only allow enumeration if the level is enumerable
			dwSizeNeeded += sizeof(DWORD);
		}
	}

    if (!ARGUMENT_PRESENT(InfoBuffer) ||
            !InfoBufferSize ||
            InfoBufferSize < dwSizeNeeded)
    {
        if (ARGUMENT_PRESENT(InfoBufferRetSize))
            *InfoBufferRetSize = dwSizeNeeded;

        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitHandler2;
    }



    //
    // Fill the buffer with the resulting data.
    //
    lpNextPtr = (LPVOID) InfoBuffer;
    lpEndBuffer = (LPVOID) ( ((LPBYTE) InfoBuffer) + InfoBufferSize);
    RestartKey = NULL;
    for (authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey);
        authzobj != NULL;
        authzobj = (PAUTHZLEVELTABLERECORD)
                RtlEnumerateGenericTableWithoutSplaying(
                    &g_CodeLevelObjTable, &RestartKey))
    {
		if (authzobj->isEnumerable) {  //only allow enumeration if the level is enumerable
	        *((PDWORD)lpNextPtr) = authzobj->dwLevelId;
   		     lpNextPtr = (LPVOID) ( ((PBYTE) lpNextPtr) + sizeof(DWORD));
		}
    }
    ASSERT(lpNextPtr <= lpEndBuffer);


    //
    // Return the final buffer size and result code.
    //
    if (ARGUMENT_PRESENT(InfoBufferRetSize))
        *InfoBufferRetSize = (DWORD) ((PBYTE) lpNextPtr - (PBYTE) InfoBuffer);

    Status = STATUS_SUCCESS;

ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);

ExitHandler:
    return Status;
}



NTSTATUS NTAPI
SaferpPol_GetInfoCommon_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize OPTIONAL,
        OUT PVOID       InfoBuffer OPTIONAL,
        OUT PDWORD      InfoBufferRetSize OPTIONAL,
        IN BOOLEAN      bUseCached
        )
/*++

Routine Description:

    Queries the current WinSafer Level that has been configured to be
    the default policy level.

    Note that this query always accepts a constant-sized buffer that
    is only a single DWORD in length.

    Although this API directly queries the registry scope indicated,
    the pre-cached list of available Levels is used to validate the
    specified Level.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this can be SAFER_SCOPEID_MACHINE or SAFER_SCOPEID_USER.

    InfoBufferSize - optionally specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - optionally specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

    InfoBufferRetSize - optionally specifies a pointer that will receive
        the size of the results actually written to the InfoBuffer.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.  InfoBuffer will
        be filled with a single DWORD of the level that has been configured
        to be the default level for this scope.  InfoBufferRetSize will
        contain the length of the result (a single DWORD).
    Returns STATUS_NOT_FOUND if no default level has been configured
        for the given scope (or the level defined does not exist).
    Returns STATUS_BUFFER_TOO_SMALL if there was a defined default level
        but a buffer was not supplied, or the buffer supplied was too
        small to accomodate the results.

--*/
{
    NTSTATUS Status;
    DWORD dwNewLevelId = (DWORD) -1;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    if (RtlIsGenericTableEmpty(&g_CodeLevelObjTable)) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }


    //
    // Query the current value setting.
    //
    if (!bUseCached)
    {
        HANDLE hKeyBase;
        ULONG ActualSize;
        UNICODE_STRING ValueName;
        WCHAR KeyPathBuffer[ MAXIMUM_FILENAME_LENGTH+6 ];
        PKEY_VALUE_FULL_INFORMATION ValueBuffer =
            (PKEY_VALUE_FULL_INFORMATION) KeyPathBuffer;

        Status = CodeAuthzpOpenPolicyRootKey(
                    dwScopeId,
                    g_hKeyCustomRoot,
                    L"\\" SAFER_CODEIDS_REGSUBKEY,
                    KEY_READ, FALSE, &hKeyBase);
        if (NT_SUCCESS(Status))
        {
            RtlInitUnicodeString(&ValueName, SAFER_DEFAULTOBJ_REGVALUE);
            Status = NtQueryValueKey(hKeyBase,
                                     &ValueName,
                                     KeyValueFullInformation,
                                     ValueBuffer,     // ptr to KeyPathBuffer
                                     sizeof(KeyPathBuffer),
                                     &ActualSize);
            if (NT_SUCCESS(Status)) {
                if (ValueBuffer->Type != REG_DWORD ||
                    ValueBuffer->DataLength != sizeof(DWORD)) {
                    Status = STATUS_NOT_FOUND;
                } else {
                    dwNewLevelId = * (PDWORD) ((PBYTE) ValueBuffer +
                            ValueBuffer->DataOffset);
                }
            }
            NtClose(hKeyBase);
        }
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    else
    {
        if (dwScopeId == SAFER_SCOPEID_USER) {
            if (!g_DefaultCodeLevelUser) {
                dwNewLevelId = SAFER_LEVELID_FULLYTRUSTED;
            } else {
                dwNewLevelId = g_DefaultCodeLevelUser->dwLevelId;
            }
        } else {
            if (!g_DefaultCodeLevelMachine) {
                dwNewLevelId = SAFER_LEVELID_FULLYTRUSTED;
            } else {
                dwNewLevelId = g_DefaultCodeLevelMachine->dwLevelId;
            }
        }
    }


    //
    // Make sure the level we found is actually
    // valid (still in our level table).
    //
    if (!CodeAuthzLevelObjpLookupByLevelId(
            &g_CodeLevelObjTable, dwNewLevelId)) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler2;
    }


    //
    // Make sure the target buffer is large
    // enough and copy the levelid into it.
    //
    if (!ARGUMENT_PRESENT(InfoBuffer) ||
            InfoBufferSize < sizeof(DWORD)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        RtlCopyMemory(InfoBuffer, &dwNewLevelId, sizeof(DWORD));
        Status = STATUS_SUCCESS;
    }
    if (ARGUMENT_PRESENT(InfoBufferRetSize))
        *InfoBufferRetSize = sizeof(DWORD);


ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize OPTIONAL,
        OUT PVOID       InfoBuffer OPTIONAL,
        OUT PDWORD      InfoBufferRetSize OPTIONAL
        )
{
    return SaferpPol_GetInfoCommon_DefaultLevel(
        dwScopeId,
        InfoBufferSize,
        InfoBuffer,
        InfoBufferRetSize,
        TRUE);
}


NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize OPTIONAL,
        OUT PVOID       InfoBuffer OPTIONAL,
        OUT PDWORD      InfoBufferRetSize OPTIONAL
        )
{
    return SaferpPol_GetInfoCommon_DefaultLevel(
        dwScopeId,
        InfoBufferSize,
        InfoBuffer,
        InfoBufferRetSize,
        FALSE);
}




NTSTATUS NTAPI
CodeAuthzPol_SetInfoDual_DefaultLevel(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        OUT PVOID       InfoBuffer
        )
/*++

Routine Description:

    Modifies the current WinSafer Level that has been configured to be
    the default policy level.

    Note that this query always accepts a constant-sized buffer that
    is only a single DWORD in length.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this can be SAFER_SCOPEID_MACHINE or SAFER_SCOPEID_USER.

    InfoBufferSize - specifies the size of input buffer
        supplied by the caller to receive the results.

    InfoBuffer - specifies the input buffer that was
        supplied by the caller to receive the results.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.  InfoBuffer will
        be filled with a single DWORD of the level that has been configured
        to be the default level for this scope.  InfoBufferRetSize will
        contain the length of the result (a single DWORD).
    Returns STATUS_NOT_FOUND if no default level has been configured
        for the given scope (or the level defined does not exist).
    Returns STATUS_BUFFER_TOO_SMALL if there was a defined default level
        but a buffer was not supplied, or the buffer supplied was too
        small to accomodate the results.

--*/
{
    NTSTATUS Status;
    HANDLE hKeyBase;
    DWORD dwNewLevelId;
    UNICODE_STRING ValueName;
    PAUTHZLEVELTABLERECORD pLevelRecord;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE &&
            dwScopeId != SAFER_SCOPEID_USER) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    Status = CodeAuthzpOpenPolicyRootKey(
                dwScopeId,
                g_hKeyCustomRoot,
                L"\\" SAFER_CODEIDS_REGSUBKEY,
                KEY_READ | KEY_SET_VALUE,
                TRUE, &hKeyBase);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }


    //
    // Load the list of all of the available objects.
    //
    if (RtlIsGenericTableEmpty(&g_CodeLevelObjTable)) {
        Status = STATUS_NOT_FOUND;
        goto ExitHandler3;
    }


    //
    // If we are going to set a new default object,
    // make sure it is a valid one.
    //
    if (InfoBufferSize < sizeof(DWORD) ||
        !ARGUMENT_PRESENT(InfoBuffer))
    {
        // Caller wants to clear the default object.
        InfoBuffer = NULL;
        pLevelRecord = NULL;
    }
    else
    {
        dwNewLevelId = *(PDWORD) InfoBuffer;
        pLevelRecord = CodeAuthzLevelObjpLookupByLevelId(
                &g_CodeLevelObjTable, dwNewLevelId);
        if (!pLevelRecord)
        {
            // Caller was trying to set the default to an
            // authorization object that does not exist.
            Status = STATUS_NOT_FOUND;
            goto ExitHandler3;
        }
    }


    //
    // Write the name of the default object that is specified.
    //
    RtlInitUnicodeString(&ValueName, SAFER_DEFAULTOBJ_REGVALUE);

    Status = NtSetValueKey(hKeyBase,
                           &ValueName,
                           0,
                           REG_DWORD,
                           &dwNewLevelId,
                           sizeof(DWORD));
    if (NT_SUCCESS(Status)) {
        if (dwScopeId == SAFER_SCOPEID_USER) {
            g_DefaultCodeLevelUser = pLevelRecord;
        } else {
            g_DefaultCodeLevelMachine = pLevelRecord;
        }

        //
        // Compute the effective Default Level (take the least privileged).
        //
        CodeAuthzpRecomputeEffectiveDefaultLevel();
    }


ExitHandler3:
    NtClose(hKeyBase);
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}


NTSTATUS NTAPI
SaferpPol_GetInfoCommon_HonorUserIdentities(
        IN   DWORD       dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL,
        IN   BOOLEAN    bUseCached
        )
/*++

Routine Description:

    Queries the current WinSafer policy to determine if Code Identities
    defined within the User's registry scope should be considered.

    Note that this query always accepts a constant-sized buffer that is
    only a single DWORD in length.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - optionally specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - optionally specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

    InfoBufferRetSize - optionally specifies a pointer that will receive
        the size of the results actually written to the InfoBuffer.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.
        InfoBuffer will be filled with a single DWORD containing
        either a TRUE or FALSE value that indicates whether the option
        is enabled. InfoBufferRetSize will contain the length of the
        result (a single DWORD).
    Returns STATUS_BUFFER_TOO_SMALL if the buffer was not supplied, or
        the buffer supplied was too small to accomodate the result.

--*/
{
    NTSTATUS Status;
    DWORD dwValueState = (DWORD) -1;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }


    //
    // Read or write the name of the policy value that is specified.
    //
    if (!bUseCached)
    {
        HANDLE hKeyBase;
        ULONG ActualSize;
        UNICODE_STRING ValueName;
        WCHAR KeyPathBuffer[ MAXIMUM_FILENAME_LENGTH+6 ];
        PKEY_VALUE_FULL_INFORMATION ValueBuffer =
            (PKEY_VALUE_FULL_INFORMATION) KeyPathBuffer;

        Status = CodeAuthzpOpenPolicyRootKey(
                    dwScopeId,
                    g_hKeyCustomRoot,
                    L"\\" SAFER_CODEIDS_REGSUBKEY,
                    KEY_READ, FALSE, &hKeyBase);
        if (NT_SUCCESS(Status))
        {
            RtlInitUnicodeString(&ValueName,
                                 SAFER_HONORUSER_REGVALUE);
            Status = NtQueryValueKey(hKeyBase,
                                     &ValueName,
                                     KeyValueFullInformation,
                                     ValueBuffer,     // ptr to KeyPathBuffer
                                     sizeof(KeyPathBuffer),
                                     &ActualSize);
            if (NT_SUCCESS(Status)) {
                if (ValueBuffer->Type != REG_DWORD ||
                    ValueBuffer->DataLength != sizeof(DWORD)) {
                    Status = STATUS_NOT_FOUND;
                } else {
                    dwValueState = * (PDWORD) ((PBYTE) ValueBuffer +
                            ValueBuffer->DataOffset);
                }
            }
            NtClose(hKeyBase);
        }
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    else
    {
        dwValueState = (g_bHonorScopeUser ? TRUE : FALSE);
    }


    //
    // Make sure the target buffer is large
    // enough and copy the object name into it.
    //
    if (!ARGUMENT_PRESENT(InfoBuffer) ||
            InfoBufferSize < sizeof(DWORD)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        RtlCopyMemory(InfoBuffer, &dwValueState, sizeof(DWORD));
        Status = STATUS_SUCCESS;
    }
    if (ARGUMENT_PRESENT(InfoBufferRetSize))
        *InfoBufferRetSize = sizeof(DWORD);


ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzPol_GetInfoCached_HonorUserIdentities(
        IN   DWORD       dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        )
{
    return SaferpPol_GetInfoCommon_HonorUserIdentities(
        dwScopeId, InfoBufferSize,
        InfoBuffer, InfoBufferRetSize, TRUE);
}


NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_HonorUserIdentities(
        IN   DWORD       dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        )
{
    return SaferpPol_GetInfoCommon_HonorUserIdentities(
        dwScopeId, InfoBufferSize,
        InfoBuffer, InfoBufferRetSize, FALSE);
}




NTSTATUS NTAPI
CodeAuthzPol_SetInfoDual_HonorUserIdentities(
        IN      DWORD       dwScopeId,
        IN      DWORD       InfoBufferSize,
        IN      PVOID       InfoBuffer
        )
/*++

Routine Description:

    Queries the current WinSafer policy to determine if Code Identities
    defined within the User's registry scope should be considered.

    Note that this API always accepts a constant-sized buffer that is
    only a single DWORD in length.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.  InfoBuffer will
        be filled with a single DWORD of the level that has been configured
        to be the default level for this scope.  InfoBufferRetSize will
        contain the length of the result (a single DWORD).
    Returns STATUS_NOT_FOUND if no default level has been configured
        for the given scope (or the level defined does not exist).
    Returns STATUS_BUFFER_TOO_SMALL if there was a defined default level
        but a buffer was not supplied, or the buffer supplied was too
        small to accomodate the results.

--*/
{
    HANDLE hKeyBase;
    NTSTATUS Status;
    UNICODE_STRING ValueName;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    if (g_bNeedCacheReload) {
        Status = CodeAuthzpImmediateReloadCacheTables();
        if (!NT_SUCCESS(Status)) {
            goto ExitHandler2;
        }
    }
    Status = CodeAuthzpOpenPolicyRootKey(
                dwScopeId,
                g_hKeyCustomRoot,
                L"\\" SAFER_CODEIDS_REGSUBKEY,
                (KEY_READ | KEY_SET_VALUE),
                TRUE, &hKeyBase);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }

    //
    // Make sure the input buffer is large enough.
    //
    if (InfoBufferSize < sizeof(DWORD) ||
        !ARGUMENT_PRESENT(InfoBuffer)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitHandler3;
    }


    //
    // Write the policy value that is specified.
    //
    RtlInitUnicodeString(&ValueName, SAFER_HONORUSER_REGVALUE);

    Status = NtSetValueKey(hKeyBase,
                           &ValueName,
                           0,
                           REG_DWORD,
                           InfoBuffer,
                           sizeof(DWORD));
    if (NT_SUCCESS(Status)) {
        BOOLEAN bNewHonorScopeUser = (*((PDWORD)InfoBuffer) != 0 ? TRUE : FALSE);

        if (g_bHonorScopeUser != bNewHonorScopeUser)
        {
            g_bHonorScopeUser = bNewHonorScopeUser;

            //
            // If the actual value is different from what we had then we
            // need to purge the identities table and reload the only the
            // parts that we should consider.
            //
            if (g_hKeyCustomRoot == NULL)
            {
                CodeAuthzGuidIdentsEntireTableFree(&g_CodeIdentitiesTable);

                CodeAuthzGuidIdentsLoadTableAll(
                        &g_CodeLevelObjTable,
                        &g_CodeIdentitiesTable,
                        SAFER_SCOPEID_MACHINE,
                        NULL);

                if (g_bHonorScopeUser) {
                    CodeAuthzGuidIdentsLoadTableAll(
                        &g_CodeLevelObjTable,
                        &g_CodeIdentitiesTable,
                        SAFER_SCOPEID_USER,
                        NULL);
                }
            }
        }
    }


ExitHandler3:
    NtClose(hKeyBase);
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}



NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_TransparentEnabled(
        IN DWORD        dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        )
/*++

Routine Description:

    Queries the current "transparent enforcement" setting.  This is a
    global setting that can be used to enable or disable automatic
    WinSafer token reductions.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - optionally specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - optionally specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

    InfoBufferRetSize - optionally specifies a pointer that will receive
        the size of the results actually written to the InfoBuffer.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.  If the
    operation is not successful, then the contents of 'pdwEnabled'
    are left untouched.

--*/
{
    NTSTATUS Status;
    DWORD dwValueState = (DWORD) -1;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }

    //
    // Query the current value setting.
    //
    {
        HANDLE hKeyBase;
        DWORD ActualSize;
        UNICODE_STRING ValueName;
        WCHAR KeyPathBuffer[ MAXIMUM_FILENAME_LENGTH+6 ];
        PKEY_VALUE_FULL_INFORMATION ValueBuffer =
            (PKEY_VALUE_FULL_INFORMATION) KeyPathBuffer;

        Status = CodeAuthzpOpenPolicyRootKey(
                    dwScopeId,
                    g_hKeyCustomRoot,
                    L"\\" SAFER_CODEIDS_REGSUBKEY,
                    KEY_READ, FALSE, &hKeyBase);
        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&ValueName,
                                 SAFER_TRANSPARENTENABLED_REGVALUE);
            Status = NtQueryValueKey(hKeyBase,
                                     &ValueName,
                                     KeyValueFullInformation,
                                     ValueBuffer,     // ptr to KeyPathBuffer
                                     sizeof(KeyPathBuffer),
                                     &ActualSize);
            if (NT_SUCCESS(Status)) {
                if (ValueBuffer->Type != REG_DWORD ||
                    ValueBuffer->DataLength != sizeof(DWORD)) {
                    Status = STATUS_NOT_FOUND;
                } else {
                    dwValueState = * (PDWORD) ((PBYTE) ValueBuffer +
                            ValueBuffer->DataOffset);
                }
            }
            NtClose(hKeyBase);
        }
        if (!NT_SUCCESS(Status)) {
            // On failure, just ignore it and pretend it was FALSE.
            dwValueState = FALSE;
        }
    }


    //
    // Make sure the target buffer is large
    // enough and copy the object name into it.
    //
    if (!ARGUMENT_PRESENT(InfoBuffer) ||
            InfoBufferSize < sizeof(DWORD)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        RtlCopyMemory(InfoBuffer, &dwValueState, sizeof(DWORD));
        Status = STATUS_SUCCESS;
    }
    if (ARGUMENT_PRESENT(InfoBufferRetSize))
        *InfoBufferRetSize = sizeof(DWORD);


ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzPol_SetInfoRegistry_TransparentEnabled(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        IN PVOID        InfoBuffer
        )
/*++

Routine Description:

    Modifies the current "transparent enforcement" setting.  This is a
    global setting that can be used to enable or disable automatic
    WinSafer token reductions.

    Note that this API always accepts a constant-sized buffer that is
    only a single DWORD in length.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

Return Value:

    Returns STATUS_SUCCESS on a successful result.

--*/
{
    HANDLE hKeyBase;
    NTSTATUS Status;
    UNICODE_STRING ValueName;

    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    Status = CodeAuthzpOpenPolicyRootKey(
                dwScopeId, g_hKeyCustomRoot,
                L"\\" SAFER_CODEIDS_REGSUBKEY,
                KEY_READ | KEY_SET_VALUE,
                TRUE, &hKeyBase);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }


    //
    // Make sure the input buffer is large enough.
    //
    if (InfoBufferSize < sizeof(DWORD) ||
        !ARGUMENT_PRESENT(InfoBuffer)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitHandler3;
    }


    //
    // Write the policy value that is specified.
    //
    RtlInitUnicodeString(&ValueName,
                         SAFER_TRANSPARENTENABLED_REGVALUE);
    Status = NtSetValueKey(hKeyBase,
                           &ValueName,
                           0,
                           REG_DWORD,
                           InfoBuffer,
                           sizeof(DWORD));


ExitHandler3:
    NtClose(hKeyBase);
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}



NTSTATUS NTAPI
CodeAuthzPol_GetInfoRegistry_ScopeFlags(
        IN DWORD        dwScopeId,
        IN   DWORD       InfoBufferSize      OPTIONAL,
        OUT  PVOID       InfoBuffer          OPTIONAL,
        OUT PDWORD       InfoBufferRetSize   OPTIONAL
        )
/*++

Routine Description:

    Queries the current "scope flags" setting.  

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - optionally specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - optionally specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

    InfoBufferRetSize - optionally specifies a pointer that will receive
        the size of the results actually written to the InfoBuffer.

Return Value:

    Returns STATUS_SUCCESS on a successful query result.  If the
    operation is not successful, then the contents of 'pdwEnabled'
    are left untouched.

--*/
{
    NTSTATUS Status;
    DWORD dwValueState = (DWORD) 0;


    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }

    //
    // Query the current value setting.
    //
    {
        HANDLE hKeyBase;
        DWORD ActualSize;
        UNICODE_STRING ValueName;
        WCHAR KeyPathBuffer[ MAXIMUM_FILENAME_LENGTH+6 ];
        PKEY_VALUE_FULL_INFORMATION ValueBuffer =
            (PKEY_VALUE_FULL_INFORMATION) KeyPathBuffer;

        Status = CodeAuthzpOpenPolicyRootKey(
                    dwScopeId,
                    g_hKeyCustomRoot,
                    L"\\" SAFER_CODEIDS_REGSUBKEY,
                    KEY_READ, FALSE, &hKeyBase);
        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&ValueName,
                                 SAFER_POLICY_SCOPE);
            Status = NtQueryValueKey(hKeyBase,
                                     &ValueName,
                                     KeyValueFullInformation,
                                     ValueBuffer,     // ptr to KeyPathBuffer
                                     sizeof(KeyPathBuffer),
                                     &ActualSize);
            if (NT_SUCCESS(Status)) {
                if (ValueBuffer->Type != REG_DWORD ||
                    ValueBuffer->DataLength != sizeof(DWORD)) {
                    Status = STATUS_NOT_FOUND;
                } else {
                    dwValueState = * (PDWORD) ((PBYTE) ValueBuffer +
                            ValueBuffer->DataOffset);
                }
            }
            NtClose(hKeyBase);
        }
        if (!NT_SUCCESS(Status)) {
            // On failure, just ignore it and pretend it was FALSE.
            dwValueState = 0;
        }
    }


    //
    // Make sure the target buffer is large
    // enough and copy the object name into it.
    //
    if (!ARGUMENT_PRESENT(InfoBuffer) ||
            InfoBufferSize < sizeof(DWORD)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        RtlCopyMemory(InfoBuffer, &dwValueState, sizeof(DWORD));
        Status = STATUS_SUCCESS;
    }
    if (ARGUMENT_PRESENT(InfoBufferRetSize))
        *InfoBufferRetSize = sizeof(DWORD);


ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}


NTSTATUS NTAPI
CodeAuthzPol_SetInfoRegistry_ScopeFlags(
        IN DWORD        dwScopeId,
        IN DWORD        InfoBufferSize,
        IN PVOID        InfoBuffer
        )
/*++

Routine Description:

    Modifies the current "scope flags" setting.

    Note that this API always accepts a constant-sized buffer that is
    only a single DWORD in length.

Arguments:

    dwScopeId - specifies the registry scope that will be examined.
        If the currently cached scope included a registry handle
        then AUTHZSCOPE_REGISTRY must be specified.  Otherwise,
        this must be SAFER_SCOPEID_MACHINE.

    InfoBufferSize - specifies the size of input buffer
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBuffer must also be supplied.

    InfoBuffer - specifies the input buffer that was
        supplied by the caller to receive the results.  If this argument
        is supplied, then InfoBufferSize must also be supplied.

Return Value:

    Returns STATUS_SUCCESS on a successful result.

--*/
{
    HANDLE hKeyBase;
    NTSTATUS Status;
    UNICODE_STRING ValueName;

    //
    // Open up the regkey to the base of the policies.
    //
    if (!g_bInitializedFirstTime) {
        Status = STATUS_UNSUCCESSFUL;
        goto ExitHandler;
    }
    RtlEnterCriticalSection(&g_TableCritSec);
    if (g_hKeyCustomRoot != NULL) {
        if (dwScopeId != SAFER_SCOPEID_REGISTRY) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    } else {
        if (dwScopeId != SAFER_SCOPEID_MACHINE) {
            Status = STATUS_INVALID_PARAMETER_MIX;
            goto ExitHandler2;
        }
    }
    Status = CodeAuthzpOpenPolicyRootKey(
                dwScopeId, g_hKeyCustomRoot,
                L"\\" SAFER_CODEIDS_REGSUBKEY,
                KEY_READ | KEY_SET_VALUE,
                TRUE, &hKeyBase);
    if (!NT_SUCCESS(Status)) {
        goto ExitHandler2;
    }


    //
    // Make sure the input buffer is large enough.
    //
    if (InfoBufferSize < sizeof(DWORD) ||
        !ARGUMENT_PRESENT(InfoBuffer)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto ExitHandler3;
    }


    //
    // Write the policy value that is specified.
    //
    RtlInitUnicodeString(&ValueName,
                         SAFER_POLICY_SCOPE);
    Status = NtSetValueKey(hKeyBase,
                           &ValueName,
                           0,
                           REG_DWORD,
                           InfoBuffer,
                           sizeof(DWORD));


ExitHandler3:
    NtClose(hKeyBase);
ExitHandler2:
    RtlLeaveCriticalSection(&g_TableCritSec);
ExitHandler:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safewild.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    SaifWild.cpp

Abstract:

    This module implements various "Wildcard SID" operations that are
    used internally by the WinSAIFER APIs to compute SID list
    intersections and inversions.

Author:

    Jeffrey Lawson (JLawson) - Apr 2000

Environment:

    User mode only.

Revision History:

    Created - Apr 2000

--*/


#ifndef _SAIFER_WILDCARD_SIDS_H_
#define _SAIFER_WILDCARD_SIDS_H_


//
// Internal structure used to represent our private "Wildcard SIDs".
//
typedef struct _AUTHZ_WILDCARDSID
{
    PSID Sid;
    DWORD WildcardPos;          // -1, or else the wildcard position of
                                // the within the subauthorities.
} AUTHZ_WILDCARDSID, *PAUTHZ_WILDCARDSID;


#ifdef __cplusplus
extern "C" {
#endif


NTSTATUS NTAPI
CodeAuthzpConvertWildcardStringSidToSidW(
    IN LPCWSTR szStringSid,
    OUT PAUTHZ_WILDCARDSID pWildcardSid
    );

NTSTATUS NTAPI
CodeAuthzpConvertWildcardSidToStringSidW(
    IN PAUTHZ_WILDCARDSID   pWildcardSid,
    OUT PUNICODE_STRING     pUnicodeOutput
    );

BOOLEAN NTAPI
CodeAuthzpCompareWildcardSidWithSid(
    IN PAUTHZ_WILDCARDSID pWildcardSid,
    IN PSID pMatchSid
    );

BOOLEAN NTAPI
CodeAuthzpSidInWildcardList (
    IN PAUTHZ_WILDCARDSID   WildcardList,
    IN ULONG                WildcardCount,
    IN PSID                 SePrincipalSelfSid   OPTIONAL,
    IN PSID                 PrincipalSelfSid   OPTIONAL,
    IN PSID                 Sid
    );

BOOLEAN NTAPI
CodeAuthzpInvertAndAddSids(
    IN HANDLE                   InAccessToken,
    IN PSID                     InTokenOwner    OPTIONAL,
    IN DWORD                    InvertSidCount,
    IN PAUTHZ_WILDCARDSID       SidsToInvert,
    IN DWORD                    SidsAddedCount  OPTIONAL,
    IN PSID_AND_ATTRIBUTES      SidsToAdd       OPTIONAL,
    OUT DWORD                  *NewDisabledSidCount,
    OUT PSID_AND_ATTRIBUTES    *NewSidsToDisable
    );

BOOLEAN NTAPI
CodeAuthzpExpandWildcardList(
    IN HANDLE                   InAccessToken,
    IN PSID                     InTokenOwner   OPTIONAL,
    IN DWORD                    WildcardCount,
    IN PAUTHZ_WILDCARDSID       WildcardList,
    OUT DWORD                  *OutSidCount,
    OUT PSID_AND_ATTRIBUTES    *OutSidList
    );


#ifdef __cplusplus
} // extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\accctrl2\src\accacc.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1993, Microsoft Corporation.
//
// File:        accacc.cxx
//
// Classes:     CAccountAccess
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::CAccountAccess, public
//
//  Synopsis:   initializes data members, constructor will not throw
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CAccountAccess::CAccountAccess()
    : _principal(NULL),
      _domain(NULL),
      _psid(NULL),
      _accessmask(0),
      _accessmode(NOT_USED_ACCESS),
      _aceflags(0xff),
      _esidtype(SidTypeUnknown),
      _freedomain(FALSE),
      _freename(FALSE),
      _freesid(FALSE),
      _pimpersonatesid(NULL),
      _pimpersonatename(NULL),
      _multipletrusteeoperation(NO_MULTIPLE_TRUSTEE)
{
}
//+---------------------------------------------------------------------------
//
//  Member:     dtor
//
//  Synopsis:   initializes data members
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CAccountAccess::~CAccountAccess()
{

}
//+---------------------------------------------------------------------------
//
//  Member:    new, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void * CAccountAccess::operator new(size_t size)
{
    return(RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (ULONG)size));
}
//+---------------------------------------------------------------------------
//
//  Member:    delete, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void CAccountAccess::operator delete(void *p, size_t size)
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::Init, public
//
//  Synopsis:   initializes by name, and lookup the SID
//
//  Arguments:  IN [Name] - principal or trustee
//              IN [System] - the server where the name is found
//              IN [AccessMode] - set/deny/grant, etc.
//              IN [AccessMask] - the access mask
//              IN [AceFlags] - inheritance flags
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::Init(LPWSTR Name,
                           LPWSTR System,
                           ACCESS_MODE AccessMode,
                           ACCESS_MASK AccessMask,
                           DWORD AceFlags,
                           BOOL fSaveName)
{

    DWORD status = NO_ERROR;
    DWORD cusid = 0, crd = 0;

    _principal = Name;
    _system = System;
    _accessmode = AccessMode;
    _accessmask = AccessMask;

    //
    // should allow INHERIT_ONLY_ACE to be added bug #234020
    //
    /*
    if (AceFlags & INHERIT_ONLY_ACE)
    {
        return(ERROR_BAD_INHERITANCE_ACL);
    }
    */
    _aceflags = AceFlags;

    //
    // check for CURRENT_USER (in which case we get the name from the token
    //
    if (0 == _wcsicmp(Name, L"CURRENT_USER"))
    {

        HANDLE token_handle;
        //
        // see if a thread token exists
        //
        if (!OpenThreadToken(GetCurrentThread(),
                             TOKEN_ALL_ACCESS,
                             FALSE,
                             &token_handle))
        {
            //
            // if not, use the process token
            //
            if (ERROR_NO_TOKEN == (status = GetLastError()))
            {
                status = NO_ERROR;
                if (!OpenProcessToken(GetCurrentProcess(),
                                      TOKEN_ALL_ACCESS,
                                      &token_handle))
                {
                    status = GetLastError();
                }
            }
        }
        //
        // if we have a token, get the user SID from it
        //
        if (status == NO_ERROR)
        {
            ULONG cinfosize;

            //
            // Note: Since the buffer is long enough to accomodate any sid
            // last error value is not checked for buffer overflow.
            //

            BYTE buf[8 + 4 * SID_MAX_SUB_AUTHORITIES];

            TOKEN_USER *ptu = (TOKEN_USER *)buf;

            if (GetTokenInformation(token_handle,
                                     TokenUser,
                                     ptu,
                                     (8 + 4 * SID_MAX_SUB_AUTHORITIES),
                                     &cinfosize))
            {
                //
                // allocate room for the returned sid
                //
                ULONG sidsize = RtlLengthSid(ptu->User.Sid);
                if (NULL != (_psid = (PSID)
                               AccAlloc(sidsize)))
                {
                    //
                    // and copy the new sid
                    //
                    NTSTATUS ntstatus;
                    if (NT_SUCCESS(ntstatus = RtlCopySid(sidsize,
                                                         _psid,
                                                         ptu->User.Sid)))
                    {
                        _freesid = TRUE;
                    }else
                    {
                        status = RtlNtStatusToDosError(ntstatus);
                        AccFree(_psid);
                    }
                } else
                {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                }
            } else
            {
                status = GetLastError();
            }
        }
    } else
    {
        if (!LookupAccountName( _system,
                                _principal,
                                NULL,
                                &cusid,
                                NULL,
                                &crd,
                                &_esidtype))
        {
            if (ERROR_INSUFFICIENT_BUFFER == (status = GetLastError()))
            {
                if (NULL == (_psid = (PSID)AccAlloc(cusid)))
                {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                } else if (crd > 0)
                {
                    if (NULL == (_domain = (LPWSTR )AccAlloc(crd * sizeof(WCHAR))))
                    {
                        AccFree(_psid);
                        status = ERROR_NOT_ENOUGH_MEMORY;
                    }  else
                    {
                        _freesid = TRUE;
                        _freedomain = TRUE;

                        if ( LookupAccountName( _system,
                                                _principal,
                                                _psid,
                                                &cusid,
                                                _domain,
                                                &crd,
                                                &_esidtype) )
                        {
                           status = NO_ERROR;
                        } else
                        {
                            status = GetLastError();
                        }
                    }
                }
            }
        }
    }
    if (status == NO_ERROR && fSaveName)
    {
        LPWSTR tmp;
        if (NULL != (tmp = (LPWSTR )AccAlloc(
                (wcslen(_principal) + 1) * sizeof(WCHAR))))
        {
            wcscpy(tmp,_principal);
            _principal = tmp;
            _freename = TRUE;
        }  else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::Init, public
//
//  Synopsis:   initializes by sid, but do not lookup the name
//
//  Arguments:  IN [pSid] - the sid
//              IN [System] - the server where the name is found
//              IN [AccessMode] - set/deny/grant, etc.
//              IN [AccessMask] - the access mask
//              IN [AceFlags] - inheritance flags
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::Init(PSID  pSid,
                           LPWSTR System,
                           ACCESS_MODE AccessMode,
                           ACCESS_MASK AccessMask,
                           DWORD AceFlags,
                           BOOL fSaveSid)
{
    DWORD status = NO_ERROR;

    //
    // should allow INHERIT_ONLY_ACE to be added bug #234020
    //
    /*
    if (AceFlags & INHERIT_ONLY_ACE)
    {
        return(ERROR_BAD_INHERITANCE_ACL);
    }
    */

    _system = System;
    _accessmode = AccessMode;
    _accessmask = AccessMask;
    _aceflags = AceFlags;
    if (fSaveSid)
    {
        ULONG sidsize = RtlLengthSid(pSid);

        if (NULL != (_psid = (LPWSTR)AccAlloc(sidsize)))
        {
            NTSTATUS ntstatus;
            _freesid = TRUE;

            if (!NT_SUCCESS(ntstatus = RtlCopySid(sidsize,
                                               _psid, pSid)))
            {
                status = RtlNtStatusToDosError(ntstatus);
            }
        } else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else
    {
        _psid       = pSid;
    }

    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::Clone, public
//
//  Synopsis:   makes a copy of the class
//
//  Arguments:  OUT [clone] - address of new CAccountAccess object
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::Clone(CAccountAccess **clone)
{
    DWORD status = NO_ERROR;

    if (NULL != (*clone = new CAccountAccess()))
    {
        if (_freename)
        {
            if (NULL != ((*clone)->_principal = (LPWSTR)AccAlloc(
                           (wcslen(_principal) + 1) * sizeof(WCHAR))))
            {
                (*clone)->_freename     = _freename;
                wcscpy( (*clone)->_principal, _principal);
            } else
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else
        {
            (*clone)->_principal    = _principal;
        }
        if (_freedomain)
        {
            if (NULL != ((*clone)->_domain = (LPWSTR)AccAlloc(
                           (wcslen(_domain) + 1) * sizeof(WCHAR))))
            {
                (*clone)->_freedomain   = _freedomain;
                wcscpy( (*clone)->_domain, _domain);
            } else
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else
        {
            (*clone)->_domain       = _domain;
        }
        if (_freesid)
        {
            ULONG sidsize = RtlLengthSid(_psid);
            if (NULL != ((*clone)->_psid = (LPWSTR)AccAlloc(
                           sidsize)))
            {
                NTSTATUS ntstatus;
                (*clone)->_freesid      = _freesid;
                if (!NT_SUCCESS(ntstatus = RtlCopySid(sidsize,
                                                   (*clone)->_psid, _psid)))
                {
                    status = RtlNtStatusToDosError(ntstatus);
                }
            } else
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else
        {
            (*clone)->_psid       = _psid;
        }
        (*clone)->_accessmask   = _accessmask;
        (*clone)->_accessmode   = _accessmode;
        (*clone)->_aceflags     = _aceflags;
        (*clone)->_esidtype     = _esidtype;

        if (status != NO_ERROR)
        {
            delete (*clone);
        }
    }
    else
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::LookupName, public
//
//  Synopsis:   returns the principal for the class
//
//  Arguments:  OUT [Name] - address of the principal name
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::LookupName(LPWSTR *Name)
{
    DWORD status = NO_ERROR;
    DWORD can = 0, crd = 0;


    if (_principal == NULL)
    {
        if (!LookupAccountSid( _system,
                               _psid,
                               NULL,
                               &can,
                               NULL,
                               &crd,
                               &_esidtype))
        {
            if (ERROR_INSUFFICIENT_BUFFER == (status = GetLastError()))
            {
                if (NULL == (_principal = (LPWSTR )AccAlloc(can * sizeof(WCHAR))))
                {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                } else if (NULL == (_domain = (LPWSTR )AccAlloc(crd * sizeof(WCHAR))))
                {
                    AccFree(_principal);
                    status = ERROR_NOT_ENOUGH_MEMORY;
                } else
                {
                    _freename = TRUE;
                    _freedomain = TRUE;

                    if ( !LookupAccountSid( _system,
                                           _psid,
                                           _principal,
                                           &can,
                                           _domain,
                                           &crd,
                                           &_esidtype) )
                    {
                       status = GetLastError();
                    } else
                    {
                        *Name = _principal;
                        status = NO_ERROR;
                    }
                }
            }
        }
    } else
    {
        *Name = _principal;
    }

    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::SetImpersonateSid, public
//
//  Synopsis:   sets the impersonating server sid
//
//  Arguments:  IN [PSID] - address of the sid
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::SetImpersonateSid(PSID pSid)
{
    DWORD status= NO_ERROR;

    if (NULL == _pimpersonatesid)
    {
        ULONG sidsize  = RtlLengthSid(pSid);
        if (NULL != (_pimpersonatesid = (PSID) AccAlloc(sidsize)))
        {
            NTSTATUS ntstatus;

            if (!NT_SUCCESS(ntstatus = RtlCopySid(sidsize,
                                                 _pimpersonatesid,
                                                 pSid)))
            {
                AccFree(_pimpersonatesid);
                _pimpersonatesid = NULL;
                status = RtlNtStatusToDosError(ntstatus);
            } else
            {
                _multipletrusteeoperation = TRUSTEE_IS_IMPERSONATE;
            }
        } else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else
    {
        status = ERROR_INVALID_PARAMETER;
    }
    return(status);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAccountAccess::SetImpersonateName, public
//
//  Synopsis:   sets the impersonating server name (and looks up the SID)
//
//  Arguments:  IN [PSID] - address of the name
//
//----------------------------------------------------------------------------
DWORD CAccountAccess::SetImpersonateName(LPWSTR name)
{
    DWORD status= NO_ERROR;

    if (NULL == _pimpersonatesid)
    {
        TRUSTEE trustee;
        PSID psid;

        BuildTrusteeWithName(&trustee, name);
        SID_NAME_USE    SNE;
        status = (*gNtMartaInfo.pfSid)(NULL,
                                       &trustee,
                                       &psid,
                                       &SNE);

        if (status == NO_ERROR)
        {
            if (NULL != (_pimpersonatename = (LPWSTR)AccAlloc((wcslen(name) + 1)
                                                              * sizeof(WCHAR))))
            {
                wcscpy(_pimpersonatename, name);
                _pimpersonatesid = psid;
                _multipletrusteeoperation = TRUSTEE_IS_IMPERSONATE;
            }
            else
            {
                AccFree(psid);
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    else
    {
        status = ERROR_INVALID_PARAMETER;
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\accctrl2\drt\aclapi.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       ACLAPI.C
//
//  Contents:   Implements the drt for MARTA and Win32Ex APIs
//
//  History:    14-Sep-96       MacM        Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <aclapi.h>
#include <marta.h>
#include <seopaque.h>
#include <ntrtl.h>


#define EVERYONE L"EVERYONE"
#define EVERYONE_A "EVERYONE"
#define GUEST L"GUEST"
#define GUEST_A "GUEST"
#define GUEST_COMPARE L"GUEST"
#define SYSTEM L"SYSTEM"
#define SYSTEM_A "SYSTEM"
#define MAX_LINE 256

//
// Globals
//
BOOL    fVerbose = FALSE;

//
// Function prototypes
//
DWORD   Nt4BuildW(PACL *ppAcl);
DWORD   Nt4BuildA(PACL *ppAcl);
DWORD   Nt5BuildW(PACTRL_ACCESSW   *ppAccess);
DWORD   Nt5BuildA(PACTRL_ACCESSA   *ppAccess);
DWORD   Nt4DrtW(PACL            pAcl,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType);

DWORD   Nt4DrtA(PACL            pAcl,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType);

DWORD   Nt5DrtW(PACTRL_ACCESSW  pAccess,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType);

DWORD   Nt5DrtA(PACTRL_ACCESSA  pAccess,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType);

VOID
ConvertAccessMaskToAccessRight(IN  ACCESS_MASK      AccessMask,
                               OUT PACCESS_RIGHTS   pAccessRight);
//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   The main
//
//  Arguments:  [IN  argc]          --  Count of arguments
//              [IN  argv]          --  List of arguments
//
//  Returns:    0                   --  Success
//              non-0               --  Failure
//
//----------------------------------------------------------------------------
__cdecl main(INT argc, CHAR *argv[])
{

    DWORD           dwErr = ERROR_SUCCESS;
    PACL            pNt4AclW = NULL, pNt4AclA = NULL;
    PACTRL_ACCESSW  pNt5AccessW = NULL;
    PACTRL_ACCESSA  pNt5AccessA = NULL;
    FILE           *fp = NULL;
    SE_OBJECT_TYPE  ObjType;
    CHAR            szBuff[MAX_LINE];

    if (argc < 2 || argc > 3)
    {
        fprintf(stderr,"USAGE: aclexdrt input_file [verbose]\n");
        exit(1);
    }

    if(argc == 3)
    {
        fVerbose = TRUE;
    }

    AccProvInit(dwErr);

    //
    // Do the Nt4 style build routines
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = Nt4BuildW(&pNt4AclW);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = Nt4BuildA(&pNt4AclA);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = Nt5BuildW(&pNt5AccessW);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = Nt5BuildA(&pNt5AccessA);
    }

    //
    // Now, open the file and process it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        fp = fopen(argv[1], "r");
        if(fp == NULL)
        {
            fprintf(stderr, "File %s not found\n", argv[1]);
            dwErr = ERROR_FILE_NOT_FOUND;
        }

        while(dwErr == ERROR_SUCCESS && fgets(szBuff, MAX_LINE, fp) != NULL)
        {
            BOOL    fIsDSObj = FALSE;
            PSTR    pszType;
            PSTR    pszObject = strtok(szBuff, " ");
            if(pszObject != NULL)
            {
                pszType = strtok(NULL," \n\r\0");
            }

            if(pszObject == NULL && pszType == NULL)
            {
                continue;
            }
            else if(pszObject == NULL || pszType == NULL)
            {
                fprintf(stderr,
                        "Invalid entry %s in input file %s\n",
                        szBuff,
                        argv[1]);
                dwErr = ERROR_INVALID_DATA;
            }
            else
            {
                if(_stricmp(pszType, "FILE") == 0)
                {
                    ObjType = SE_FILE_OBJECT;
                }
                else if(_stricmp(pszType, "SERVICE") == 0)
                {
                    ObjType = SE_SERVICE;
                }
                else if(_stricmp(pszType, "PRINTER") == 0)
                {
                    ObjType = SE_PRINTER;
                }
                else if (_stricmp(pszType, "REGISTRY_KEY") == 0)
                {
                    ObjType = SE_REGISTRY_KEY;
                }
                else if(_stricmp(pszType, "SHARE") == 0)
                {
                    ObjType = SE_LMSHARE;
                }
                else if(_stricmp(pszType, "DSOBJ") == 0)
                {
                    ObjType = SE_DS_OBJECT;
                    fIsDSObj = TRUE;
                }
                else if(_stricmp(pszType, "DSOBJALL") == 0)
                {
                    ObjType = SE_DS_OBJECT_ALL;
                    fIsDSObj = TRUE;
                }
                else
                {
                    fprintf(stderr, "Invalid object type %s\n", pszType);
                    dwErr = ERROR_INVALID_DATA;
                }
            }

            //
            // If it worked, do the tests...
            //
            if(dwErr == ERROR_SUCCESS && fIsDSObj == FALSE)
            {
                dwErr = Nt4DrtW(pNt4AclW,
                                pszObject,
                                ObjType);
            }

            if(dwErr == ERROR_SUCCESS && fIsDSObj == FALSE)
            {
                dwErr = Nt4DrtA(pNt4AclA,
                                pszObject,
                                ObjType);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = Nt5DrtW(pNt5AccessW,
                                pszObject,
                                ObjType);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = Nt5DrtA(pNt5AccessA,
                                pszObject,
                                ObjType);
            }
        }

        if(fp != NULL)
        {
            fclose(fp);
        }

    }
    LocalFree(pNt4AclW);
    LocalFree(pNt4AclA);
    LocalFree(pNt5AccessW);
    LocalFree(pNt5AccessA);

    if(dwErr == ERROR_SUCCESS)
    {
        printf("Success\n");
    }
    else
    {
        printf("Failure: %lu\n", dwErr);
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CompareAcls
//
//  Synopsis:   Compares 2 acls for equality
//
//  Arguments:  [pAcl1]             --  First ACL
//              [pAcl2]             --  Second ACL
//
//  Returns:    ERROR_SUCCESS       --  They match
//              ERROR_INVALID_DATA  --  They don't match
//
//----------------------------------------------------------------------------
DWORD   CompAcls(PACL pAcl1,
                 PACL pAcl2)
{
    DWORD   dwErr = ERROR_SUCCESS;

    ACL_SIZE_INFORMATION        AclSize1, AclSize2;
    ACL_REVISION_INFORMATION    AclRev1, AclRev2;
    PKNOWN_ACE                  pAce1, pAce2;
    PSID                        pSid1, pSid2;
    DWORD                       iIndex;

    if(pAcl1 == NULL || pAcl2 == NULL)
    {
        if(pAcl1 != pAcl2)
        {
            if(fVerbose)
            {
                fprintf(stderr,"Acl %lu is NULL\n", pAcl1 == NULL ? 1 : 2);
            }
            dwErr = ERROR_INVALID_DATA;
        }
    }
    else
    {
        if(GetAclInformation(pAcl1,
                             &AclRev1,
                             sizeof(ACL_REVISION_INFORMATION),
                             AclRevisionInformation) == FALSE ||
           GetAclInformation(pAcl2,
                             &AclRev2,
                             sizeof(ACL_REVISION_INFORMATION),
                             AclRevisionInformation) == FALSE)
        {
            return(ERROR_INVALID_DATA);
        }

        if(GetAclInformation(pAcl1,
                             &AclSize1,
                             sizeof(ACL_SIZE_INFORMATION),
                             AclSizeInformation) == FALSE ||
           GetAclInformation(pAcl2,
                             &AclSize2,
                             sizeof(ACL_SIZE_INFORMATION),
                             AclSizeInformation) == FALSE)
        {
            return(ERROR_INVALID_DATA);
        }

        if(AclRev1.AclRevision !=  AclRev2.AclRevision)
        {
            if(fVerbose)
            {
                fprintf(stderr,
                        "Revision mismatch: %lu %lu\n",
                        AclRev1.AclRevision,
                        AclRev2.AclRevision);
            }
            dwErr = ERROR_INVALID_DATA;
        }

        if(AclSize1.AceCount !=  AclSize2.AceCount)
        {
            if(fVerbose)
            {
                fprintf(stderr,
                        "AceCount mismatch: %lu %lu\n",
                        AclSize1.AceCount,
                        AclSize2.AceCount);
            }
            dwErr = ERROR_INVALID_DATA;
        }

        if(AclSize1.AclBytesInUse !=  AclSize2.AclBytesInUse)
        {
            if(fVerbose)
            {
                fprintf(stderr,
                        "BytesInUse mismatch: %lu %lu\n",
                        AclSize1.AclBytesInUse,
                        AclSize2.AclBytesInUse);
            }
            dwErr = ERROR_INVALID_DATA;
        }

        if(pAcl1->Sbz1 !=  pAcl2->Sbz1)
        {
            if(fVerbose)
            {
                fprintf(stderr,
                        "Acl flags mismatch: %lu %lu\n",
                        pAcl1->Sbz1,
                        pAcl2->Sbz1);
            }
            dwErr = ERROR_INVALID_DATA;
        }


        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }

        //
        // Now, compare all of the aces
        //
        pAce1 = FirstAce(pAcl1);
        pAce2 = FirstAce(pAcl2);
        for(iIndex = 0;
            iIndex < pAcl1->AceCount && dwErr == ERROR_SUCCESS;
            iIndex++)
        {
            ACCESS_RIGHTS   Rights1, Rights2;

            if(fVerbose)
            {
                printf("Ace %lu\n", iIndex);
            }

            if(pAce1->Header.AceType !=  pAce2->Header.AceType)
            {
                if(fVerbose)
                {
                    fprintf(stderr,
                            "\tAceType mismatch: %lu %lu\n",
                            pAce1->Header.AceType,
                            pAce2->Header.AceType);
                }
                dwErr = ERROR_INVALID_DATA;
            }

            if(pAce1->Header.AceFlags !=  pAce2->Header.AceFlags)
            {
                if(fVerbose)
                {
                    fprintf(stderr,
                            "\tAceType mismatch: %lu %lu\n",
                            pAce1->Header.AceFlags,
                            pAce2->Header.AceFlags);
                }
                dwErr = ERROR_INVALID_DATA;
            }

            if(pAce1->Header.AceSize !=  pAce2->Header.AceSize)
            {
                if(fVerbose)
                {
                    fprintf(stderr,
                            "\tAceType mismatch: %lu %lu\n",
                            pAce1->Header.AceSize,
                            pAce2->Header.AceSize);
                }
                dwErr = ERROR_INVALID_DATA;
            }

            ConvertAccessMaskToAccessRight(pAce1->Mask, &Rights1);
            ConvertAccessMaskToAccessRight(pAce2->Mask, &Rights2);
            if(Rights1 != Rights1)
            {
                if(fVerbose)
                {
                    fprintf(stderr,
                            "\tAccessMask mismatch: %lu %lu\n",
                            Rights1,
                            Rights2);
                }
                dwErr = ERROR_INVALID_DATA;
            }

            if(!RtlEqualSid((PSID)&(pAce1->SidStart), (PSID)&(pAce2->SidStart)))
            {
                if(fVerbose)
                {
                    fprintf(stderr,
                            "\tSids don't match\n");
                }
                dwErr = ERROR_INVALID_DATA;
            }

            pAce1 = NextAce(pAce1);
            pAce2 = NextAce(pAce2);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompStringsW
//
//  Synopsis:   Compares 2 string pointers for equality
//
//  Arguments:  [pwszStr1]          --  First string
//              [pwszStr2]          --  Second string
//
//  Returns:    ERROR_SUCCESS       --  They match
//              ERROR_INVALID_DATA  --  They don't match
//
//----------------------------------------------------------------------------
DWORD
CompStringsW(PWSTR  pwszStr1, PWSTR  pwszStr2)
{
    if(pwszStr1 != NULL && pwszStr2 != NULL)
    {
        if(_wcsicmp(pwszStr1, pwszStr2) == 0)
        {
            return(ERROR_SUCCESS);
        }
    }
    else
    {
        if(pwszStr1 == NULL)
        {
            return(ERROR_SUCCESS);
        }
    }

    return(ERROR_INVALID_DATA);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompStringsA
//
//  Synopsis:   Compares 2 string pointers for equality
//
//  Arguments:  [pszStr1]           --  First string
//              [pszStr2]           --  Second string
//
//  Returns:    ERROR_SUCCESS       --  They match
//              ERROR_INVALID_DATA  --  They don't match
//
//----------------------------------------------------------------------------
DWORD
CompStringsA(PSTR  pszStr1, PSTR  pszStr2)
{
    if(pszStr1 != NULL && pszStr2 != NULL)
    {
        if(_stricmp(pszStr1, pszStr2) == 0)
        {
            return(ERROR_SUCCESS);
        }
    }
    else
    {
        if(pszStr1 == NULL)
        {
            return(ERROR_SUCCESS);
        }
    }


    return(ERROR_INVALID_DATA);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompAccessW
//
//  Synopsis:   Compares 2 WIDE access lists for equality
//
//  Arguments:  [pAccess1]          --  First list
//              [pAccess2]          --  Second list
//
//  Returns:    ERROR_SUCCESS       --  They match
//              ERROR_INVALID_DATA  --  They don't match
//
//----------------------------------------------------------------------------
DWORD CompAccessW(PACTRL_ACCESSW pAccess1,
                  PACTRL_ACCESSW pAccess2)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG iIndex = 0;

    if(pAccess1 == NULL || pAccess2 == NULL)
    {
        if(pAccess1 != pAccess2)
        {
            if(fVerbose)
            {
                fprintf(stderr,"Access %lu is NULL\n",
                        pAccess1 == NULL ? 1 : 2);
            }
            dwErr = ERROR_INVALID_DATA;
        }
    }
    else
    {
        PACTRL_ACCESS_ENTRY_LISTW pAAEL1;
        PACTRL_ACCESS_ENTRY_LISTW pAAEL2;

        dwErr = CompStringsW((PWSTR)pAccess1->pPropertyAccessList[0].lpProperty,
                             (PWSTR)pAccess2->pPropertyAccessList[0].lpProperty);
        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }

        pAAEL1 = pAccess1->pPropertyAccessList[0].pAccessEntryList;
        pAAEL2 = pAccess2->pPropertyAccessList[0].pAccessEntryList;
        if(pAAEL1->cEntries != pAAEL2->cEntries)
        {
            dwErr = ERROR_INVALID_DATA;
            if(fVerbose)
            {
                fprintf(stderr, "cEntries: %lu %lu\n",
                        pAAEL1->cEntries,
                        pAAEL2->cEntries);
            }
        }
        else
        {
            //
            // Compare all of the entries
            //
            for(iIndex = 0; iIndex < pAAEL1->cEntries; iIndex++)
            {
                if(_wcsicmp(pAAEL1->pAccessList[iIndex].Trustee.ptstrName,
                            pAAEL1->pAccessList[iIndex].Trustee.ptstrName) != 0)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "Trustees: %ws %ws\n",
                                pAAEL1->pAccessList[iIndex].Trustee.ptstrName,
                                pAAEL2->pAccessList[iIndex].Trustee.ptstrName);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].fAccessFlags !=
                                    pAAEL1->pAccessList[iIndex].fAccessFlags)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "AccessFlags: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].fAccessFlags,
                                pAAEL2->pAccessList[iIndex].fAccessFlags);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].Access !=
                                    pAAEL1->pAccessList[iIndex].Access)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "Access: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].Access,
                                pAAEL2->pAccessList[iIndex].Access);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].ProvSpecificAccess !=
                              pAAEL1->pAccessList[iIndex].ProvSpecificAccess)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "ProvSpecificAccess: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].ProvSpecificAccess,
                                pAAEL2->pAccessList[iIndex].ProvSpecificAccess);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].Inheritance !=
                                    pAAEL1->pAccessList[iIndex].Inheritance)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "AccessFlags: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].Inheritance,
                                pAAEL2->pAccessList[iIndex].Inheritance);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                //
                // The inheritance property
                //
                dwErr = CompStringsW(
                        (PWSTR)pAAEL1->pAccessList[iIndex].lpInheritProperty,
                        (PWSTR)pAAEL1->pAccessList[iIndex].lpInheritProperty);

                if(dwErr == ERROR_SUCCESS && fVerbose)
                {
                    printf("AccessEntry %lu\n", iIndex);
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompAccessA
//
//  Synopsis:   Compares 2 ANSI access lists for equality
//
//  Arguments:  [pAccess1]          --  First list
//              [pAccess2]          --  Second list
//
//  Returns:    ERROR_SUCCESS       --  They match
//              ERROR_INVALID_DATA  --  They don't match
//
//----------------------------------------------------------------------------
DWORD CompAccessA(PACTRL_ACCESSA pAccess1,
                  PACTRL_ACCESSA pAccess2)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG iIndex = 0;

    if(pAccess1 == NULL || pAccess2 == NULL)
    {
        if(pAccess1 != pAccess2)
        {
            if(fVerbose)
            {
                fprintf(stderr,"Access %lu is NULL\n",
                        pAccess1 == NULL ? 1 : 2);
            }
            dwErr = ERROR_INVALID_DATA;
        }
    }
    else
    {
        PACTRL_ACCESS_ENTRY_LISTA pAAEL1;
        PACTRL_ACCESS_ENTRY_LISTA pAAEL2;

        dwErr = CompStringsA((PSTR)pAccess1->pPropertyAccessList[0].lpProperty,
                             (PSTR)pAccess2->pPropertyAccessList[0].lpProperty);
        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }

        pAAEL1 = pAccess1->pPropertyAccessList[0].pAccessEntryList;
        pAAEL2 = pAccess2->pPropertyAccessList[0].pAccessEntryList;
        if(pAAEL1->cEntries != pAAEL2->cEntries)
        {
            dwErr = ERROR_INVALID_DATA;
            if(fVerbose)
            {
                fprintf(stderr, "cEntries: %lu %lu\n",
                        pAAEL1->cEntries,
                        pAAEL2->cEntries);
            }
        }
        else
        {
            //
            // Compare all of the entries
            //
            for(iIndex = 0; iIndex < pAAEL1->cEntries; iIndex++)
            {
                if(_stricmp(pAAEL1->pAccessList[iIndex].Trustee.ptstrName,
                            pAAEL1->pAccessList[iIndex].Trustee.ptstrName) != 0)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "Trustees: %ws %ws\n",
                                pAAEL1->pAccessList[iIndex].Trustee.ptstrName,
                                pAAEL2->pAccessList[iIndex].Trustee.ptstrName);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].fAccessFlags !=
                                    pAAEL1->pAccessList[iIndex].fAccessFlags)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "AccessFlags: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].fAccessFlags,
                                pAAEL2->pAccessList[iIndex].fAccessFlags);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].Access !=
                                    pAAEL1->pAccessList[iIndex].Access)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "Access: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].Access,
                                pAAEL2->pAccessList[iIndex].Access);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].ProvSpecificAccess !=
                              pAAEL1->pAccessList[iIndex].ProvSpecificAccess)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "ProvSpecificAccess: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].ProvSpecificAccess,
                                pAAEL2->pAccessList[iIndex].ProvSpecificAccess);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                if(pAAEL1->pAccessList[iIndex].Inheritance !=
                                    pAAEL1->pAccessList[iIndex].Inheritance)
                {
                    if(fVerbose)
                    {
                        fprintf(stderr, "AccessFlags: %lu %lu\n",
                                pAAEL1->pAccessList[iIndex].Inheritance,
                                pAAEL2->pAccessList[iIndex].Inheritance);
                    }
                    dwErr = ERROR_INVALID_DATA;
                    continue;
                }

                //
                // The inheritance property
                //
                dwErr = CompStringsA(
                          (PSTR)pAAEL1->pAccessList[iIndex].lpInheritProperty,
                          (PSTR)pAAEL1->pAccessList[iIndex].lpInheritProperty);

                if(dwErr == ERROR_SUCCESS && fVerbose)
                {
                    printf("AccessEntry %lu\n", iIndex);
                }
            }
        }
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   DumpAccessW
//
//  Synopsis:   Dumps an ACTRL_ACCESSW structure to the screen
//
//  Arguments:  [pAccess]           --  Structure to dump
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
DumpAccessW(PACTRL_ACCESSW  pAccess)
{
    if(fVerbose)
    {
        ULONG iProp, iEnt;
        printf("\tEntries: %lu\n", pAccess->cEntries);
        for(iProp = 0; iProp < pAccess->cEntries; iProp++)
        {
            printf("\t\tProperty: %ws\n",
                   pAccess->pPropertyAccessList[iProp].lpProperty == NULL ?
                              L"NULL" :
                              pAccess->pPropertyAccessList[iProp].lpProperty);
            printf("\t\tFlags: %lu\n",
                   pAccess->pPropertyAccessList[iProp].fListFlags);
            if(pAccess->pPropertyAccessList[iProp].pAccessEntryList == NULL)
            {
                printf("\t\tpAccessEntryList: NULL\n");
            }
            else
            {
                PACTRL_ACCESS_ENTRYW pAE= pAccess->pPropertyAccessList[iProp].
                                                pAccessEntryList->pAccessList;
                printf("\t\t\tcEntries: %lu\n",
                       pAccess->pPropertyAccessList[iProp].pAccessEntryList->
                                                                    cEntries);

                for(iEnt = 0;
                    iEnt < pAccess->pPropertyAccessList[iProp].
                                                   pAccessEntryList->cEntries;
                    iEnt++)
                {
                    printf("\t\t\tEntry %lu:\n", iEnt);
                    printf("\t\t\t\tTrustee.Name: %ws\n",
                           pAE[iEnt].Trustee.ptstrName);
                    printf("\t\t\t\tfAccessFlags: %lu\n",
                           pAE[iEnt].fAccessFlags);
                    printf("\t\t\t\tAccess: 0x%lx\n", pAE[iEnt].Access);
                    printf("\t\t\t\tProvSpecificAccess: %lu\n",
                           pAE[iEnt].ProvSpecificAccess);
                    printf("\t\t\t\tInheritance: %lu\n", pAE[iEnt].Inheritance);
                    printf("\t\t\t\tlpInheritProperty: %ws\n",
                           pAE[iEnt].lpInheritProperty == NULL ?
                                                L""  :
                                                pAE[iEnt].lpInheritProperty);
                }
            }
        }
    }
}

#define BUILD_COUNT 5
//+---------------------------------------------------------------------------
//
//  Function:   Nt4BuildW
//
//  Synopsis:   Builds an ACL using the NT4 API WIDE apis
//
//  Arguments:  [ppAcl]             --  Acl to build
//
//  Returns:    ERROR_SUCCESS       --  Everything worked
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt4BuildW(PACL *ppAcl)
{
    DWORD               dwErr = ERROR_SUCCESS;
    ULONG               cCount;
    EXPLICIT_ACCESS_W   EAW;
    PEXPLICIT_ACCESS_W  pEAW;
    PACL                pAcl = NULL, pNewAcl;
    ULONG               iIndex, iVer;

    PWSTR rgTrustees[BUILD_COUNT] = {EVERYONE,
                                     SYSTEM,
                                     GUEST,
                                     EVERYONE,
                                     SYSTEM};

    DWORD rgAccess[BUILD_COUNT] =   {GENERIC_ALL | 0x8,
                                     GENERIC_ALL,
                                     GENERIC_ALL | 0x8,
                                     GENERIC_ALL | 0x8,
                                     0};

    ACCESS_MODE rgMode[BUILD_COUNT] = {SET_ACCESS,
                                       DENY_ACCESS,
                                       SET_ACCESS,
                                       SET_ACCESS,
                                       REVOKE_ACCESS};

    DWORD rgInherit[BUILD_COUNT] = {NO_INHERITANCE,
                                    NO_INHERITANCE,
                                    SUB_CONTAINERS_AND_OBJECTS_INHERIT,
                                    NO_INHERITANCE,
                                    SUB_CONTAINERS_AND_OBJECTS_INHERIT};

    DWORD rgSrch[BUILD_COUNT][BUILD_COUNT + 1] = {{1, 0},
                                                  {2, 1, 0},
                                                  {3, 1, 2, 0},
                                                  {3, 1, 3, 2},
                                                  {2, 3, 2}};
    if(fVerbose)
    {
        printf("Nt4BuildW\n");
    }

    //
    // We'll do this in a loop, since we have BUILD_COUNT different builds to do
    //
    for(iIndex = 0; iIndex < BUILD_COUNT && dwErr == ERROR_SUCCESS; iIndex++)
    {
        //
        // Build the new entry
        //
        BuildExplicitAccessWithNameW(&EAW,
                                     rgTrustees[iIndex],
                                     rgAccess[iIndex],
                                     rgMode[iIndex],
                                     rgInherit[iIndex]);

        dwErr = SetEntriesInAclW(1,
                                 &EAW,
                                 pAcl,
                                 &pNewAcl);

        if(dwErr == ERROR_SUCCESS)
        {
            LocalFree(pAcl);
            pAcl = pNewAcl;

            //
            // Get the explicit entries, and we'll verify them...
            //
            dwErr = GetExplicitEntriesFromAclW(pAcl,
                                               &cCount,
                                               &pEAW);
            if(dwErr == ERROR_SUCCESS)
            {
                PDWORD  pSrch = rgSrch[iIndex];
                ULONG   cExpected = pSrch[0];

                if(cCount != cExpected)
                {
                    dwErr = ERROR_INVALID_DATA;
                    if(fVerbose)
                    {
                        printf("\tCount mismatched: %lu, expected %lu\n",
                               cCount,
                               cExpected);
                    }
                }
                else
                {
                    //
                    // verify the rest of the data
                    //
                    for(iVer = 0; iVer < cExpected; iVer++)
                    {
                        ULONG iSrch = pSrch[iVer + 1];
                        if(_wcsicmp(pEAW[iVer].Trustee.ptstrName,
                                    rgTrustees[iSrch]) != 0)
                        {
                            dwErr = ERROR_INVALID_DATA;
                            if(fVerbose)
                            {
                                printf("\tTrustee mismatch[%lu]: %ws, expected "
                                       "%ws\n",
                                       iVer,
                                       pEAW[iVer].Trustee.ptstrName,
                                       rgTrustees[iSrch]);
                            }
                        }
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    if(fVerbose)
                    {
                        printf("\tCount: %lu\n", cCount);
                    }
                }
                LocalFree(pEAW);
            }
            else
            {
                fprintf(stderr,
                        "\tNt4BuildW: SetEntriesInAclW failed with %lu\n",
                        dwErr);
            }
        }
        else
        {
            fprintf(stderr,"\tNt4BuildW: SetEntriesInAclW failed with %lu\n",
                    dwErr);
        }

    }

    if(dwErr == ERROR_SUCCESS)
    {
        *ppAcl = pAcl;
    }
    else
    {
        LocalFree(pAcl);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   Nt4BuildA
//
//  Synopsis:   Builds an ACL using the NT4 API ANSI apis
//
//  Arguments:  [ppAcl]             --  Acl to build
//
//  Returns:    ERROR_SUCCESS       --  Everything worked
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt4BuildA(PACL *ppAcl)
{
    DWORD               dwErr = ERROR_SUCCESS;
    ULONG               cCount;
    EXPLICIT_ACCESS_A   EAA;
    PEXPLICIT_ACCESS_A  pEAA;
    PACL                pAcl = NULL, pNewAcl;
    ULONG               iIndex, iVer;

    PSTR rgTrustees[BUILD_COUNT] = {EVERYONE_A,
                                    SYSTEM_A,
                                    GUEST_A,
                                    EVERYONE_A,
                                    SYSTEM_A};

    DWORD rgAccess[BUILD_COUNT] =   {GENERIC_ALL | 0x8,
                                     GENERIC_ALL,
                                     GENERIC_ALL | 0x8,
                                     GENERIC_ALL | 0x8,
                                     0};

    ACCESS_MODE rgMode[BUILD_COUNT] = {SET_ACCESS,
                                       DENY_ACCESS,
                                       SET_ACCESS,
                                       SET_ACCESS,
                                       REVOKE_ACCESS};

    DWORD rgInherit[BUILD_COUNT] = {NO_INHERITANCE,
                                    NO_INHERITANCE,
                                    SUB_CONTAINERS_AND_OBJECTS_INHERIT,
                                    NO_INHERITANCE,
                                    SUB_CONTAINERS_AND_OBJECTS_INHERIT};

    DWORD rgSrch[BUILD_COUNT][BUILD_COUNT + 1] = {{1, 0},
                                                  {2, 1, 0},
                                                  {3, 1, 2, 0},
                                                  {3, 1, 3, 2},
                                                  {2, 3, 2}};
    if(fVerbose)
    {
        printf("Nt4BuildA\n");
    }

    //
    // We'll do this in a loop, since we have BUILD_COUNT different builds to do
    //
    for(iIndex = 0; iIndex < BUILD_COUNT && dwErr == ERROR_SUCCESS; iIndex++)
    {
        //
        // Build the new entry
        //
        BuildExplicitAccessWithNameA(&EAA,
                                     rgTrustees[iIndex],
                                     rgAccess[iIndex],
                                     rgMode[iIndex],
                                     rgInherit[iIndex]);

        dwErr = SetEntriesInAclA(1,
                                 &EAA,
                                 pAcl,
                                 &pNewAcl);

        if(dwErr == ERROR_SUCCESS)
        {
            LocalFree(pAcl);
            pAcl = pNewAcl;

            //
            // Get the explicit entries, and we'll verify them...
            //
            dwErr = GetExplicitEntriesFromAclA(pAcl,
                                               &cCount,
                                               &pEAA);
            if(dwErr == ERROR_SUCCESS)
            {
                PDWORD  pSrch = rgSrch[iIndex];
                ULONG   cExpected = pSrch[0];

                if(cCount != cExpected)
                {
                    dwErr = ERROR_INVALID_DATA;
                    if(fVerbose)
                    {
                        printf("\tCount mismatched: %lu, expected %lu\n",
                               cCount,
                               cExpected);
                    }
                }
                else
                {
                    //
                    // verify the rest of the data
                    //
                    for(iVer = 0; iVer < cExpected; iVer++)
                    {
                        ULONG iSrch = pSrch[iVer + 1];
                        if(_stricmp(pEAA[iVer].Trustee.ptstrName,
                                    rgTrustees[iSrch]) != 0)
                        {
                            dwErr = ERROR_INVALID_DATA;
                            if(fVerbose)
                            {
                                printf("\tTrustee mismatch[%lu]: %s, expected "
                                       "%s\n",
                                       iVer,
                                       pEAA[iVer].Trustee.ptstrName,
                                       rgTrustees[iSrch]);
                            }
                        }
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    if(fVerbose)
                    {
                        printf("\tCount: %lu\n", cCount);
                    }
                }

                LocalFree(pEAA);
            }
            else
            {
                fprintf(stderr,
                        "\tNt4BuildA: SetEntriesInAclA failed with %lu\n",
                        dwErr);
            }
        }
        else
        {
            fprintf(stderr,"\tNt4BuildA: SetEntriesInAclA failed with %lu\n",
                    dwErr);
        }

    }

    if(dwErr == ERROR_SUCCESS)
    {
        *ppAcl = pAcl;
    }
    else
    {
        LocalFree(pAcl);
    }

    return(dwErr);
}



#undef BUILD_COUNT
#define BUILD_COUNT 6
//+---------------------------------------------------------------------------
//
//  Function:   Nt5BuildW
//
//  Synopsis:   Builds an ACL using the NT5 API WIDE apis
//
//  Arguments:  [ppAccess]          --  Access list to build
//
//  Returns:    ERROR_SUCCESS       --  Everything worked
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt5BuildW(PACTRL_ACCESSW   *ppAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PACTRL_ACCESSW      pAccess = NULL, pNewAccess;
    ULONG               iIndex, iVer;

    PWSTR rgTrustees[BUILD_COUNT] = {SYSTEM, EVERYONE, SYSTEM, GUEST,
                                     EVERYONE, SYSTEM};

    DWORD rgTypes[BUILD_COUNT] = {ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_DENIED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_DENIED};

    DWORD rgAccess[BUILD_COUNT] =   {ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_5,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_1,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_2,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_3,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_4,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_2};

    ACCESS_MODE rgMode[BUILD_COUNT] = {SET_ACCESS, SET_ACCESS, GRANT_ACCESS,
                                       GRANT_ACCESS, GRANT_ACCESS,
                                       REVOKE_ACCESS};

    DWORD rgInherit[BUILD_COUNT] = {NO_INHERITANCE, NO_INHERITANCE,
                                    NO_INHERITANCE, NO_INHERITANCE,
                                    NO_INHERITANCE, NO_INHERITANCE};

    DWORD rgSrch[BUILD_COUNT][BUILD_COUNT + 1] = {{1, 0},
                                                  {1, 1},
                                                  {2, 2, 1},
                                                  {3, 2, 3, 1},
                                                  {4, 2, 4, 3, 1},
                                                  {3, 4, 3, 1}};
    if(fVerbose)
    {
        printf("Nt5BuildW\n");
    }

    //
    // We'll do this in a loop, since we have BUILD_COUNT different builds to do
    //
    for(iIndex = 0; iIndex < BUILD_COUNT && dwErr == ERROR_SUCCESS; iIndex++)
    {

        ACTRL_ACCESS_ENTRYW  AAE;

        BuildTrusteeWithNameW(&(AAE.Trustee),
                              rgTrustees[iIndex]);
        AAE.fAccessFlags = rgTypes[iIndex];
        AAE.Access = rgAccess[iIndex];
        AAE.ProvSpecificAccess = 0;
        AAE.Inheritance = rgInherit[iIndex];
        AAE.lpInheritProperty = NULL;

        dwErr = SetEntriesInAccessListW(1,
                                        &AAE,
                                        rgMode[iIndex],
                                        NULL,
                                        pAccess,
                                        &pNewAccess);
        if(dwErr == ERROR_SUCCESS)
        {
            LocalFree(pAccess);
            pAccess = pNewAccess;
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, verify the new entries...
            //
            PACTRL_ACCESS_ENTRY_LISTW pAAELW =
                           pAccess->pPropertyAccessList[0].pAccessEntryList;
            PDWORD  pSrch = rgSrch[iIndex];
            ULONG   cExpected = pSrch[0];

            if(pAAELW->cEntries != cExpected)
            {
                dwErr = ERROR_INVALID_DATA;
                if(fVerbose)
                {
                    printf("\tCount mismatched: %lu, expected %lu\n",
                           pAAELW->cEntries,
                           cExpected);
                }
            }
            else
            {
                //
                // verify the rest of the data
                //
                for(iVer = 0; iVer < pAAELW->cEntries; iVer++)
                {
                    ULONG iSrch = pSrch[iVer + 1];
                    if(_wcsicmp(pAAELW->pAccessList[iVer].Trustee.ptstrName,
                                rgTrustees[iSrch]) != 0)
                    {
                        dwErr = ERROR_INVALID_DATA;
                        if(fVerbose)
                        {
                            printf("\tTrustee mismatch[%lu]: %ws, expected "
                                   "%ws\n",
                                   iVer,
                                   pAAELW->pAccessList[iVer].Trustee.ptstrName,
                                   rgTrustees[iSrch]);
                        }
                    }
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                if(fVerbose)
                {
                    printf("\tCount: %lu\n", cExpected);
                }
            }
        }
        else
        {
            fprintf(stderr,"\tNt5BuildW: SetEntriesInAccessListW failed "
                    "with %lu\n",
                    dwErr);
        }

    }

    if(dwErr == ERROR_SUCCESS)
    {
        *ppAccess = pAccess;
    }
    else
    {
        LocalFree(pAccess);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   Nt5BuildA
//
//  Synopsis:   Builds an ACL using the NT5 API ANSI apis
//
//  Arguments:  [ppAccess]          --  Access list to build
//
//  Returns:    ERROR_SUCCESS       --  Everything worked
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt5BuildA(PACTRL_ACCESSA   *ppAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PACTRL_ACCESSA      pAccess = NULL, pNewAccess;
    ULONG               iIndex, iVer;

    PSTR rgTrustees[BUILD_COUNT] = {SYSTEM_A, EVERYONE_A, SYSTEM_A, GUEST_A,
                                     EVERYONE_A, SYSTEM_A};

    DWORD rgTypes[BUILD_COUNT] = {ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_DENIED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_ALLOWED,
                                  ACTRL_ACCESS_DENIED};

    DWORD rgAccess[BUILD_COUNT] =   {ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_5,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_1,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_2,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_3,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_4,
                                     ACTRL_STD_RIGHTS_ALL | ACTRL_PERM_2};

    ACCESS_MODE rgMode[BUILD_COUNT] = {SET_ACCESS, SET_ACCESS, GRANT_ACCESS,
                                       GRANT_ACCESS, GRANT_ACCESS,
                                       REVOKE_ACCESS};

    DWORD rgInherit[BUILD_COUNT] = {NO_INHERITANCE, NO_INHERITANCE,
                                    NO_INHERITANCE, NO_INHERITANCE,
                                    NO_INHERITANCE, NO_INHERITANCE};

    DWORD rgSrch[BUILD_COUNT][BUILD_COUNT + 1] = {{1, 0},
                                                  {1, 1},
                                                  {2, 2, 1},
                                                  {3, 2, 3, 1},
                                                  {4, 2, 4, 3, 1},
                                                  {3, 4, 3, 1}};
    if(fVerbose)
    {
        printf("Nt5BuildA\n");
    }

    //
    // We'll do this in a loop, since we have BUILD_COUNT different builds to do
    //
    for(iIndex = 0; iIndex < BUILD_COUNT && dwErr == ERROR_SUCCESS; iIndex++)
    {

        ACTRL_ACCESS_ENTRYA  AAE;

        BuildTrusteeWithNameA(&(AAE.Trustee),
                             rgTrustees[iIndex]);
        AAE.fAccessFlags = rgTypes[iIndex];
        AAE.Access = rgAccess[iIndex];
        AAE.ProvSpecificAccess = 0;
        AAE.Inheritance = rgInherit[iIndex];
        AAE.lpInheritProperty = NULL;

        dwErr = SetEntriesInAccessListA(1,
                                        &AAE,
                                        rgMode[iIndex],
                                        NULL,
                                        pAccess,
                                        &pNewAccess);
        if(dwErr == ERROR_SUCCESS)
        {
            LocalFree(pAccess);
            pAccess = pNewAccess;
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, verify the new entries...
            //
            PACTRL_ACCESS_ENTRY_LISTA pAAELA =
                           pAccess->pPropertyAccessList[0].pAccessEntryList;
            PDWORD  pSrch = rgSrch[iIndex];
            ULONG   cExpected = pSrch[0];

            if(pAAELA->cEntries != cExpected)
            {
                dwErr = ERROR_INVALID_DATA;
                if(fVerbose)
                {
                    printf("\tCount mismatched: %lu, expected %lu\n",
                           pAAELA->cEntries,
                           cExpected);
                }
            }
            else
            {
                //
                // verify the rest of the data
                //
                for(iVer = 0; iVer < pAAELA->cEntries; iVer++)
                {
                    ULONG iSrch = pSrch[iVer + 1];
                    if(_stricmp(pAAELA->pAccessList[iVer].Trustee.ptstrName,
                                rgTrustees[iSrch]) != 0)
                    {
                        dwErr = ERROR_INVALID_DATA;
                        if(fVerbose)
                        {
                            printf("\tTrustee mismatch[%lu]: %s, expected "
                                   "%s\n",
                                   iVer,
                                   pAAELA->pAccessList[iVer].Trustee.ptstrName,
                                   rgTrustees[iSrch]);
                        }
                    }
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                if(fVerbose)
                {
                    printf("\tCount: %lu\n", cExpected);
                }
            }
        }
        else
        {
            fprintf(stderr,"\tNt5BuildA: SetEntriesInAccessListA failed "
                    "with %lu\n",
                    dwErr);
        }

    }

    if(dwErr == ERROR_SUCCESS)
    {
        *ppAccess = pAccess;
    }
    else
    {
        LocalFree(pAccess);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   Nt4DrtW
//
//  Synopsis:   Does the actual API drt.  This involves reading the existing
//              access, writing the new one, rereading the new one and
//              verifing the results, and then restores the old one.  This
//              uses the WIDE version of the NT4 APIs
//
//  Arguments:  [pAcl]              --  Acl to write on the object
//              [pszObject]         --  The object in question
//              [ObjType]           --  Type of the object
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt4DrtW(PACL            pAcl,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType)
{
    DWORD                   dwErr = ERROR_SUCCESS;
    WCHAR                   wszPath[MAX_PATH + 1];
    PACL                    pOldAcl = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    mbstowcs(wszPath, pszObject, strlen(pszObject) + 1);

    if(fVerbose)
    {
        printf("Nt4DrtW: Processing %ws [%lu]\n", wszPath, ObjType);
    }

    //
    // First, get the old acl
    //
    dwErr = GetNamedSecurityInfoW(wszPath,
                                  ObjType,
                                  DACL_SECURITY_INFORMATION,
                                  NULL,
                                  NULL,
                                  &pOldAcl,
                                  NULL,
                                  &pSD);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set, get, and compare the new acl...
        //
        dwErr = SetNamedSecurityInfoW(wszPath,
                                      ObjType,
                                      DACL_SECURITY_INFORMATION,
                                      NULL,
                                      NULL,
                                      pAcl,
                                      NULL);
        if(dwErr == ERROR_SUCCESS)
        {
            PACL    pNewAcl = NULL;
            PSECURITY_DESCRIPTOR    pNewSD = NULL;
            dwErr = GetNamedSecurityInfoW(wszPath,
                                          ObjType,
                                          DACL_SECURITY_INFORMATION,
                                          NULL,
                                          NULL,
                                          &pNewAcl,
                                          NULL,
                                          &pNewSD);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Compare them...
                //
                dwErr = CompAcls(pAcl, pNewAcl);
                if(dwErr != ERROR_SUCCESS)
                {
                    fprintf(stderr, "\tSet and old ACLs don't compare\n");
                }
                LocalFree(pNewSD);
            }
            else
            {
                if(fVerbose)
                {
                    printf("\tSecond GetNamedSecurityW on %ws failed with %lu\n",
                           wszPath,
                           dwErr);
                }
            }
        }
        else
        {
            if(fVerbose)
            {
                printf("\tSetNamedSecurityInfoW on %ws failed with %lu\n",
                       wszPath,
                       dwErr);
            }
        }
    }
    else
    {
        fprintf(stderr,
                "\tGetNamedSecurityInfoW failed on %ws: %lu\n",
                wszPath,
                dwErr);
    }

    //
    // Restore the objects security
    //
    if(pSD != NULL)
    {
        DWORD   dwErr2 = SetNamedSecurityInfoW(wszPath,
                                               ObjType,
                                               DACL_SECURITY_INFORMATION,
                                               NULL,
                                               NULL,
                                               pOldAcl,
                                               NULL);
        if(dwErr2 != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "Restoring access to %ws failed with %lu\n",
                    wszPath,
                    dwErr2);

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }

    }
    LocalFree(pSD);
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   Nt4DrtA
//
//  Synopsis:   Does the actual API drt.  This involves reading the existing
//              access, writing the new one, rereading the new one and
//              verifing the results, and then restores the old one.  This
//              uses the ANSI version of the NT4 APIs
//
//  Arguments:  [pAcl]              --  Acl to write on the object
//              [pszObject]         --  The object in question
//              [ObjType]           --  Type of the object
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt4DrtA(PACL            pAcl,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType)
{
    DWORD                   dwErr = ERROR_SUCCESS;
    PACL                    pOldAcl = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    if(fVerbose)
    {
        printf("Nt4DrtA: Processing %s [%lu]\n", pszObject, ObjType);
    }

    //
    // First, get the old acl
    //
    dwErr = GetNamedSecurityInfoA(pszObject,
                                  ObjType,
                                  DACL_SECURITY_INFORMATION,
                                  NULL,
                                  NULL,
                                  &pOldAcl,
                                  NULL,
                                  &pSD);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set, get, and compare the new acl...
        //
        dwErr = SetNamedSecurityInfoA(pszObject,
                                      ObjType,
                                      DACL_SECURITY_INFORMATION,
                                      NULL,
                                      NULL,
                                      pAcl,
                                      NULL);
        if(dwErr == ERROR_SUCCESS)
        {
            PACL    pNewAcl = NULL;
            PSECURITY_DESCRIPTOR    pNewSD = NULL;
            dwErr = GetNamedSecurityInfoA(pszObject,
                                          ObjType,
                                          DACL_SECURITY_INFORMATION,
                                          NULL,
                                          NULL,
                                          &pNewAcl,
                                          NULL,
                                          &pNewSD);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Compare them...
                //
                dwErr = CompAcls(pAcl, pNewAcl);
                if(dwErr != ERROR_SUCCESS)
                {
                    fprintf(stderr, "\tSet and old ACLs don't compare\n");
                }
                LocalFree(pNewSD);
            }
            else
            {
                if(fVerbose)
                {
                    printf("\tSecond GetNamedSecurityA on %s failed with %lu\n",
                           pszObject,
                           dwErr);
                }
            }
        }
        else
        {
            if(fVerbose)
            {
                printf("\tSetNamedSecurityInfoA on %s failed with %lu\n",
                       pszObject,
                       dwErr);
            }
        }
    }
    else
    {
        fprintf(stderr,
                "\tGetNamedSecurityInfoA failed on %s: %lu\n",
                pszObject,
                dwErr);
    }

    //
    // Restore the objects security
    //
    if(pSD != NULL)
    {
        DWORD   dwErr2 = SetNamedSecurityInfoA(pszObject,
                                               ObjType,
                                               DACL_SECURITY_INFORMATION,
                                               NULL,
                                               NULL,
                                               pOldAcl,
                                               NULL);
        if(dwErr2 != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "Restoring access to %s failed with %lu\n",
                    pszObject,
                    dwErr2);

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }

    }
    LocalFree(pSD);
    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   Nt5DrtW
//
//  Synopsis:   Does the actual API drt.  This involves reading the existing
//              access, writing the new one, rereading the new one and
//              verifing the results, and then restores the old one.  This
//              uses the WIDE version of the NT5 APIs
//
//  Arguments:  [pAccess]           --  Access list to write on the object
//              [pszObject]         --  The object in question
//              [ObjType]           --  Type of the object
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt5DrtW(PACTRL_ACCESSW  pAccess,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType)
{
    DWORD                   dwErr = ERROR_SUCCESS;
    WCHAR                   wszPath[MAX_PATH + 1];
    PACTRL_ACCESSW          pOldAccess = NULL;

    mbstowcs(wszPath, pszObject, strlen(pszObject) + 1);

    if(fVerbose)
    {
        printf("Nt5DrtW: Processing %ws [%lu]\n", wszPath, ObjType);
    }

    //
    // First, get the old acl
    //
    dwErr = GetNamedSecurityInfoExW(wszPath,
                                    ObjType,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    &pOldAccess,
                                    NULL,
                                    NULL,
                                    NULL);
    if(dwErr == ERROR_SUCCESS)
    {

        //
        // Set, get, and compare the new value...
        //
        dwErr = SetNamedSecurityInfoExW(wszPath,
                                        ObjType,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        pAccess,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);
        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_ACCESS    pNewAccess = NULL;
            dwErr = GetNamedSecurityInfoExW(wszPath,
                                            ObjType,
                                            DACL_SECURITY_INFORMATION,
                                            NULL,
                                            NULL,
                                            &pNewAccess,
                                            NULL,
                                            NULL,
                                            NULL);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Compare them...
                //
                dwErr = CompAccessW(pAccess, pNewAccess);
                if(dwErr != ERROR_SUCCESS)
                {
                    fprintf(stderr, "\tSet and old Accesses don't compare\n");
                }
            }
            else
            {
                if(fVerbose)
                {
                    printf("\tSecond GetNamedSecurityExW on %ws failed "
                           "with %lu\n",
                           wszPath,
                           dwErr);
                }
            }
        }
        else
        {
            if(fVerbose)
            {
                printf("\tSetNamedSecurityInfoExW on %ws failed with %lu\n",
                       wszPath,
                       dwErr);
            }
        }
    }
    else
    {
        fprintf(stderr,
                "\tGetNamedSecurityInfoExW failed on %ws: %lu\n",
                wszPath,
                dwErr);
    }

    //
    // Restore the objects security
    //
    if(pOldAccess != NULL)
    {
        DWORD   dwErr2 = SetNamedSecurityInfoExW(wszPath,
                                                 ObjType,
                                                 DACL_SECURITY_INFORMATION,
                                                 NULL,
                                                 pOldAccess,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL);
        if(dwErr2 != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "Restoring access to %ws failed with %lu\n",
                    wszPath,
                    dwErr2);

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }

    }

    LocalFree(pOldAccess);

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   Nt5DrtA
//
//  Synopsis:   Does the actual API drt.  This involves reading the existing
//              access, writing the new one, rereading the new one and
//              verifing the results, and then restores the old one.  This
//              uses the ANSI version of the NT5 APIs
//
//  Arguments:  [pAccess]           --  Access list to write on the object
//              [pszObject]         --  The object in question
//              [ObjType]           --  Type of the object
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_DATA  --  One of the compares failed
//
//----------------------------------------------------------------------------
DWORD   Nt5DrtA(PACTRL_ACCESSA  pAccess,
                PSTR            pszObject,
                SE_OBJECT_TYPE  ObjType)
{
    DWORD                   dwErr = ERROR_SUCCESS;
    PACTRL_ACCESSA          pOldAccess = NULL;

    if(fVerbose)
    {
        printf("Nt5DrtA: Processing %s [%lu]\n", pszObject, ObjType);
    }

    //
    // First, get the old acl
    //
    dwErr = GetNamedSecurityInfoExA(pszObject,
                                    ObjType,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    &pOldAccess,
                                    NULL,
                                    NULL,
                                    NULL);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set, get, and compare the new value...
        //
        dwErr = SetNamedSecurityInfoExA(pszObject,
                                        ObjType,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        pAccess,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);
        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_ACCESSA    pNewAccess = NULL;
            dwErr = GetNamedSecurityInfoExA(pszObject,
                                            ObjType,
                                            DACL_SECURITY_INFORMATION,
                                            NULL,
                                            NULL,
                                            &pNewAccess,
                                            NULL,
                                            NULL,
                                            NULL);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Compare them...
                //
                dwErr = CompAccessA(pAccess, pNewAccess);
                if(dwErr != ERROR_SUCCESS)
                {
                    fprintf(stderr, "\tSet and old Accesses don't compare\n");
                }
            }
            else
            {
                if(fVerbose)
                {
                    printf("\tSecond GetNamedSecurityExA on %s failed "
                           "with %lu\n",
                           pszObject,
                           dwErr);
                }
            }
        }
        else
        {
            if(fVerbose)
            {
                printf("\tSetNamedSecurityInfoExA on %s failed with %lu\n",
                       pszObject,
                       dwErr);
            }
        }
    }
    else
    {
        fprintf(stderr,
                "\tGetNamedSecurityInfoExA failed on %s: %lu\n",
                pszObject,
                dwErr);
    }

    //
    // Restore the objects security
    //
    if(pOldAccess != NULL)
    {
        DWORD   dwErr2 = SetNamedSecurityInfoExA(pszObject,
                                                 ObjType,
                                                 DACL_SECURITY_INFORMATION,
                                                 NULL,
                                                 pOldAccess,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL);
        if(dwErr2 != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "Restoring access to %s failed with %lu\n",
                    pszObject,
                    dwErr2);

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }

    }

    LocalFree(pOldAccess);

    //
    // Finally, try to convert to and from a security descriptor
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PSECURITY_DESCRIPTOR    pSD;
        dwErr = ConvertAccessToSecurityDescriptorA(pAccess,
                                                   NULL,
                                                   "ntds\\macm",
                                                   NULL,
                                                   &pSD);
        if(dwErr != ERROR_SUCCESS)
        {
            fprintf(stderr,
                    "ConvertAccessToSecurityDescriptor failed with %lu\n",
                    dwErr);
        }
        else
        {
            PACTRL_ACCESSA  pNewAccess;
            PSTR            pszName;

            dwErr = ConvertSecurityDescriptorToAccessA(pszObject,
                                                       ObjType,
                                                       pSD,
                                                       &pNewAccess,
                                                       NULL,
                                                       &pszName,
                                                       NULL);
            if(dwErr == ERROR_SUCCESS)
            {
                AccFree(pszName);
                AccFree(pNewAccess);
            }
            else
            {
                fprintf(stderr,
                        "ConvertSecurityDescriptorToAccessA failed with %lu\n",
                        dwErr);
            }

            LocalFree(pSD);
        }

    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\accctrl2\inc\marta.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       MARTA.H
//
//  Contents:   Private definitions and function prototypes used by the
//              access control APIs to handle the provider independence
//
//  History:    19-Jun-96       MacM        Created
//
//--------------------------------------------------------------------
#ifndef __MARTA_H__
#define __MARTA_H__

#include <accprov.h>

//
// List of entry points for the provider DLL functions
//
#define ACC_PROV_GET_CAPS       "AccProvGetCapabilities"
#define ACC_PROV_OBJ_ACCESS     "AccProvIsObjectAccessible"
#define ACC_PROV_GRANT_ACCESS   "AccProvGrantAccessRights"
#define ACC_PROV_SET_ACCESS     "AccProvSetAccessRights"
#define ACC_PROV_REVOKE_ACCESS  "AccProvRevokeAccessRights"
#define ACC_PROV_REVOKE_AUDIT   "AccProvRevokeAuditRights"
#define ACC_PROV_GET_ALL        "AccProvGetAllRights"
#define ACC_PROV_ACCESS         "AccProvGetTrusteesAccess"
#define ACC_PROV_AUDIT          "AccProvIsAccessAudited"
#define ACC_PROV_OBJ_INFO       "AccProvGetAccessInfoPerObjectType"
#define ACC_PROV_CANCEL         "AccProvCancelOperation"
#define ACC_PROV_GET_RESULTS    "AccProvGetOperationResults"

#define ACC_PROV_HOBJ_ACCESS    "AccProvHandleIsObjectAccessible"
#define ACC_PROV_HGRANT_ACCESS  "AccProvHandleGrantAccessRights"
#define ACC_PROV_HSET_ACCESS    "AccProvHandleSetAccessRights"
#define ACC_PROV_HREVOKE_ACCESS "AccProvHandleRevokeAccessRights"
#define ACC_PROV_HREVOKE_AUDIT  "AccProvHandleRevokeAuditRights"
#define ACC_PROV_HGET_ALL       "AccProvHandleGetAllRights"
#define ACC_PROV_HACCESS        "AccProvHandleGetTrusteesAccess"
#define ACC_PROV_HAUDIT         "AccProvHandleIsAccessAudited"
#define ACC_PROV_HOBJ_INFO      "AccProvHandleGetAccessInfoPerObjectType"


//
// Registry keys that hold the provider information
//
#define ACC_PROV_REG_ROOT                                                   \
                L"System\\CurrentControlSet\\Control\\LSA\\AccessProviders"
#define ACC_PROV_REG_ORDER  L"ProviderOrder"
#define ACC_PROV_REG_UNIQUE L"RequireUniqueAccessibility"
#define ACC_PROV_REG_PATH   L"ProviderPath"


//
// Flags used to control the provider state
//
#define ACC_PROV_PROV_OK        0x00000001
#define ACC_PROV_PROV_FAILED    0x00000000

//
// Indicates that the RequireUniqueAccessibility flag was present
//
#define ACC_PROV_REQ_UNIQUE         0x00000001

//
// Indicates that the providers have been loaded
//
#define ACC_PROV_PROVIDERS_LOADED   0x00000002

//
// This structure is what contains all of the required information about
// each of the providers
//
typedef struct _ACCPROV_PROV_INFO
{
    PWSTR               pwszProviderName;   // "Friendly" name of the provider
    PWSTR               pwszProviderPath;   // DLL path name.  Null after
                                            // module loaded
    HMODULE             hDll;               // Module handle of the DLL
                                            // after being loaded
    ULONG               fProviderCaps;      // Provider capabilities
    ULONG               fProviderState;     // Current state of the provider

    //
    // The following is the function table used to call the provider
    // functions
    //

    //
    // General functions
    //
    pfAccProvObjAccess          pfObjAccess;    // AccProvIsObjectAccessible
    pfAccProvHandleObjAccess    pfhObjAccess;   // AccProvHandleIsObjectAccessible
    pfAccProvCancelOp           pfCancel;       // AccProvCancelOperation
    pfAccProvGetResults         pfResults;      // AccProvGetOperationResults

    //
    // Required path based functions
    //
    pfAccProvAddRights      pfGrantAccess;  // AccProvGrantAccessRights
    pfAccProvSetRights      pfSetAccess;    // AccProvSetAccessRights
    pfAccProvRevoke         pfRevokeAccess; // AccProvRevokeAccessRights
    pfAccProvRevoke         pfRevokeAudit;  // AccProvRevokeAuditRights
    pfAccProvGetRights      pfGetRights;    // AccProvGetAllRights
    pfAccProvTrusteeAccess  pfTrusteeAccess;// AccProvGetTrusteesAccess
    pfAccProvAccessAudit    pfAudit;        // AccProvIsAccessAudited
    pfAccProvGetObjTypeInfo pfObjInfo;      // AccProvGetAccessInfoPerObjectType

    //
    // Optional, handle based functions
    //
    pfAccProvHandleAddRights      pfhGrantAccess;  // AccProvHandleGrantAccessRights
    pfAccProvHandleSetRights      pfhSetAccess;    // AccProvHandleSetAccessRights
    pfAccProvHandleRevoke         pfhRevokeAccess; // AccProvHandleRevokeAccessRights
    pfAccProvHandleRevoke         pfhRevokeAudit;  // AccProvHandleRevokeAuditRights
    pfAccProvHandleGetRights      pfhGetRights;    // AccProvHandleGetAllRights
    pfAccProvHandleTrusteeAccess  pfhTrusteeAccess;// AccProvHandleGetTrusteesAccess
    pfAccProvHandleAccessAudit    pfhAudit;        // AccProvHandleIsAccessAudited
    pfAccProvHandleGetObjTypeInfo pfhObjInfo;      // AccProvHandleGetAccessInfoPerObjectType
} ACCPROV_PROV_INFO, *PACCPROV_PROV_INFO;


//
// This structure contains all of the information about the availible security
// providers
//
typedef struct _ACCPROV_PROVIDERS
{
    CRITICAL_SECTION    ProviderLoadLock;   // Lock the provider list during load time
    ULONG               fOptions;           // Various provider options
    ULONG               cProviders;         // Number of providers;
    PACCPROV_PROV_INFO  pProvList;          // Actual list of providers
} ACCPROV_PROVIDERS, *PACCPROV_PROVIDERS;


extern ACCPROV_PROVIDERS gAccProviders;

//
// Allocates the provider list
//
DWORD
AccProvpAllocateProviderList(IN OUT PACCPROV_PROVIDERS  pProviders);

//
// Frees a provider list
//
VOID
AccProvpFreeProviderList(IN  PACCPROV_PROVIDERS  pProviders);

//
// Gets the capabilities of the given provider
//
DWORD
AccProvpGetProviderCapabilities(IN  PACCPROV_PROV_INFO  pProvInfo);

//
// Loads a provider definition from the registry
//
DWORD
AccProvpLoadProviderDef(IN  HKEY                hkReg,
                        IN  PWSTR               pwszNextProv,
                        OUT PACCPROV_PROV_INFO  pProvInfo);

//
// Initializes the list of providers
//
DWORD
AccProvpInitProviders(IN OUT PACCPROV_PROVIDERS  pProviders);

//
// Loads the NTMARTA.DLL functions
//
DWORD
AccProvpLoadMartaFunctions();

BOOL
MartaInitialize();

BOOL
MartaDllInitialize(IN   HINSTANCE   hMod,
                   IN   DWORD       dwReason,
                   IN   PVOID       pvReserved);

//
// Unloads any loaded DLLs
//
VOID
AccProvUnload();

//
// Determines the provider for an object
//
DWORD
AccProvpProbeProviderForObject(IN   PWSTR               pwszObject,
                               IN   HANDLE              hObject,
                               IN   SE_OBJECT_TYPE      ObjectType,
                               IN   PACCPROV_PROVIDERS  pProviders,
                               OUT  PACCPROV_PROV_INFO *ppProvider);

//
// Determines which provider should handle a request...
//
DWORD
AccProvpGetProviderForPath(IN  PCWSTR              pcwszObject,
                           IN  SE_OBJECT_TYPE      ObjectType,
                           IN  PCWSTR              pcwszProvider,
                           IN  PACCPROV_PROVIDERS  pProviders,
                           OUT PACCPROV_PROV_INFO *ppProvider);

DWORD
AccProvpGetProviderForHandle(IN  HANDLE              hObject,
                             IN  SE_OBJECT_TYPE      ObjectType,
                             IN  PCWSTR              pcwszProvider,
                             IN  PACCPROV_PROVIDERS  pProviders,
                             OUT PACCPROV_PROV_INFO *ppProvider);


//
// Macro to load a function pointer from a DLL
//
#define LOAD_ENTRYPT(ptr, typ, dll, str)            \
ptr = (typ)GetProcAddress(dll, str);                \
if(ptr == NULL)                                     \
{                                                   \
    goto Error;                                     \
}



#endif // ifndef __MARTA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\accctrl2\src\aclapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       ACLAPI.CXX
//
//  Contents:   Regular versions of the Access Control APIs
//
//  History:    14-Sep-96       MacM        Created
//
//  Notes:      This replaces the DaveMont's aclapi.cxx, although it steals
//              large sections of code from it.
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#include <seopaque.h>
#include <sertlp.h>

#define CONDITIONAL_EXIT(a, b) if (ERROR_SUCCESS != (a)) { goto b; }
//
// This macro will load the MARTA functions if they haven't already been
// loaded, and exit on failure
//
#define LOAD_MARTA(err)                                 \
err = AccProvpLoadMartaFunctions();                     \
if(err != ERROR_SUCCESS)                                \
{                                                       \
    return(err);                                        \
}


DWORD
GetErrorChecks(
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
    {
        if (NULL == ppSidOwner)
        {
            if (NULL == ppSecurityDescriptor)
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            *ppSidOwner = NULL;
        }
    }

    if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
    {
        if (NULL == ppSidGroup)
        {
            if (NULL == ppSecurityDescriptor)
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            *ppSidGroup = NULL;
        }
    }

    if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if (NULL == ppDacl)
        {
            if (NULL == ppSecurityDescriptor)
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            *ppDacl = NULL;
        }
    }

    if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if (NULL == ppSacl)
        {
            if (NULL == ppSecurityDescriptor)
            {
                return ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            *ppSacl = NULL;
        }
    }

    if (NULL != ppSecurityDescriptor)
    {
        *ppSecurityDescriptor = NULL;
    }

    return ERROR_SUCCESS;
}

DWORD
SetErrorChecks(
    IN  SE_OBJECT_TYPE       ObjectType,
    IN  SECURITY_INFORMATION SecurityInfo,
    IN  PSID                 pSidOwner,
    IN  PSID                 pSidGroup,
    IN  PACL                 pDacl,
    IN  PACL                 pSacl,
    OUT PSECURITY_DESCRIPTOR pSD
    )
{
    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

    if (FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
    {
        if (FALSE == RtlValidSid(pSidOwner))
        {
            return ERROR_INVALID_PARAMETER;
        }

        if (FALSE == SetSecurityDescriptorOwner(pSD, pSidOwner, FALSE))
        {
            return GetLastError();
        }
    }

    if (FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
    {
        if (FALSE == RtlValidSid(pSidGroup))
        {
            return ERROR_INVALID_PARAMETER;
        }

        if (FALSE == SetSecurityDescriptorGroup(pSD, pSidGroup, FALSE))
        {
            return GetLastError();
        }
    }

    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if (NULL == pDacl)
        {
            //
            // Protect the DACL.
            //

            if (FALSE == SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED, SE_DACL_PROTECTED))
            {
                return GetLastError();
            }
        }
        else
        {
            if (FALSE == SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE))
            {
                return GetLastError();
            }

            if (FLAG_ON(SecurityInfo, PROTECTED_DACL_SECURITY_INFORMATION))
            {
                if (FALSE == SetSecurityDescriptorControl(pSD, SE_DACL_PROTECTED, SE_DACL_PROTECTED))
                {
                    return GetLastError();
                }
            }
        }
    }

    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if (NULL == pSacl)
        {
            //
            // Protect the SACL.
            //

            if (FALSE == SetSecurityDescriptorControl(pSD, SE_SACL_PROTECTED, SE_SACL_PROTECTED))
            {
                return GetLastError();
            }
        }
        else
        {
            if(FALSE == SetSecurityDescriptorSacl(pSD, TRUE, pSacl, FALSE))
            {
                return GetLastError();
            }

            if (FLAG_ON(SecurityInfo, PROTECTED_SACL_SECURITY_INFORMATION))
            {
                if (FALSE == SetSecurityDescriptorControl(pSD, SE_SACL_PROTECTED, SE_SACL_PROTECTED))
                {
                    return GetLastError();
                }
            }
        }
    }

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNamedSecurityInfoW
//
//  Synopsis:   Gets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  pObjectName]   --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT ppsidOwner]    --  Where the owners, if requested, is
//                                      returned.
//              [OUT ppsidGroup]    --  Where the groups, if requested, is
//                                      returned.
//              [OUT ppDacl]        --  Where the DACL, if requested, is
//                                      returned.
//              [OUT ppSacl]        --  Where the SACL, if requested, is
//                                      returned.
//              [OUT ppSecurityDescriptor]  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#define NEW_MARTA_API
#ifdef NEW_MARTA_API
DWORD
WINAPI
GetNamedSecurityInfoW(IN  LPWSTR                 pObjectName,
                      IN  SE_OBJECT_TYPE         ObjectType,
                      IN  SECURITY_INFORMATION   SecurityInfo,
                      OUT PSID                  *ppsidOwner,
                      OUT PSID                  *ppsidGroup,
                      OUT PACL                  *ppDacl,
                      OUT PACL                  *ppSacl,
                      OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if (NULL == pObjectName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = GetErrorChecks(
                ObjectType,
                SecurityInfo,
                ppsidOwner,
                ppsidGroup,
                ppDacl,
                ppSacl,
                ppSecurityDescriptor
                );

    CONDITIONAL_EXIT(dwErr, End)

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End)

    dwErr = (*(gNtMartaInfo.pfrGetNamedRights))(
                   pObjectName,
                   ObjectType,
                   SecurityInfo,
                   ppsidOwner,
                   ppsidGroup,
                   ppDacl,
                   ppSacl,
                   ppSecurityDescriptor
                   );

End:
    return(dwErr);
}

#else

DWORD
WINAPI
GetNamedSecurityInfoW(IN  LPWSTR                 pObjectName,
                      IN  SE_OBJECT_TYPE         ObjectType,
                      IN  SECURITY_INFORMATION   SecurityInfo,
                      OUT PSID                  *ppsidOwner,
                      OUT PSID                  *ppsidGroup,
                      OUT PACL                  *ppDacl,
                      OUT PACL                  *ppSacl,
                      OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_MARTA(dwErr);

    //
    // We'll do this the easy way...
    //
    PACTRL_ACCESSW  pAccess = NULL, pAudit = NULL;
    PWSTR           pwszOwner = NULL, pwszGroup = NULL;

    dwErr = GetNamedSecurityInfoExW(pObjectName,
                                    ObjectType,
                                    SecurityInfo,
                                    NULL,
                                    NULL,
                                    FLAG_ON(SecurityInfo,
                                            DACL_SECURITY_INFORMATION) ?
                                                                  &pAccess :
                                                                  NULL,
                                    FLAG_ON(SecurityInfo,
                                            SACL_SECURITY_INFORMATION) ?
                                                                  &pAudit :
                                                                  NULL,

                                    FLAG_ON(SecurityInfo,
                                            OWNER_SECURITY_INFORMATION) ?
                                                                  &pwszOwner :
                                                                  NULL,

                                    FLAG_ON(SecurityInfo,
                                            GROUP_SECURITY_INFORMATION) ?
                                                                  &pwszGroup  :
                                                                  NULL);
    //
    // Now, we'll need to convert our access entries back into a
    // security descriptor, so we can rip it apart again...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = (*gNtMartaInfo.pfAToSD)(pAccess,
                                        pAudit,
                                        pwszOwner,
                                        pwszGroup,
                                        ppSecurityDescriptor);
        if(dwErr == ERROR_SUCCESS)
        {
            SECURITY_DESCRIPTOR *pSD =
                            (SECURITY_DESCRIPTOR *)*ppSecurityDescriptor;

            if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
               ppsidOwner != NULL)
            {
                *ppsidOwner = RtlpOwnerAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
               ppsidGroup != NULL)
            {
                *ppsidGroup = RtlpGroupAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
               ppDacl != NULL)
            {
                *ppDacl = RtlpDaclAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
               ppSacl != NULL)
            {
                *ppSacl = RtlpSaclAddrSecurityDescriptor(pSD);
            }
        }

        LocalFree(pAccess);
        LocalFree(pAudit);
        LocalFree(pwszOwner);
        LocalFree(pwszGroup);
    }

    return(dwErr);
}


#endif

//+---------------------------------------------------------------------------
//
//  Function:   GetNamedSecurityInfoA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  pObjectName]   --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT ppsidOwner]    --  Where the owners, if requested, is
//                                      returned.
//              [OUT ppsidGroup]    --  Where the groups, if requested, is
//                                      returned.
//              [OUT ppDacl]        --  Where the DACL, if requested, is
//                                      returned.
//              [OUT ppSacl]        --  Where the SACL, if requested, is
//                                      returned.
//              [OUT ppSecurityDescriptor]  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetNamedSecurityInfoA(IN  LPSTR                  pObjectName,
                      IN  SE_OBJECT_TYPE         ObjectType,
                      IN  SECURITY_INFORMATION   SecurityInfo,
                      OUT PSID                  *ppsidOwner,
                      OUT PSID                  *ppsidGroup,
                      OUT PACL                  *ppDacl,
                      OUT PACL                  *ppSacl,
                      OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor)
{
    //
    // Do the conversion, and pass it on...
    //
    PWSTR   pwszObject;

    DWORD  dwErr = ConvertStringAToStringW(pObjectName,
                                           &pwszObject);

    if(dwErr == ERROR_SUCCESS)
    {

        dwErr = GetNamedSecurityInfoW(pwszObject,
                                      ObjectType,
                                      SecurityInfo,
                                      ppsidOwner,
                                      ppsidGroup,
                                      ppDacl,
                                      ppSacl,
                                      ppSecurityDescriptor);
        LocalFree(pwszObject);
    }
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetSecurityInfoW
//
//  Synopsis:   Gets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  handle]        --  Handle to the open object on which
//                                      to get the security info
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT ppsidOwner]    --  Where the owners, if requested, is
//                                      returned.
//              [OUT ppsidGroup]    --  Where the groups, if requested, is
//                                      returned.
//              [OUT ppDacl]        --  Where the DACL, if requested, is
//                                      returned.
//              [OUT ppSacl]        --  Where the SACL, if requested, is
//                                      returned.
//              [OUT ppSecurityDescriptor]  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API
DWORD
WINAPI
GetSecurityInfo(IN  HANDLE                 handle,
                IN  SE_OBJECT_TYPE         ObjectType,
                IN  SECURITY_INFORMATION   SecurityInfo,
                OUT PSID                  *ppsidOwner,
                OUT PSID                  *ppsidGroup,
                OUT PACL                  *ppDacl,
                OUT PACL                  *ppSacl,
                OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor)
{

    DWORD   dwErr = ERROR_SUCCESS;

    if (NULL == handle)
    {
        return ERROR_INVALID_HANDLE;
    }

    dwErr = GetErrorChecks(
                ObjectType,
                SecurityInfo,
                ppsidOwner,
                ppsidGroup,
                ppDacl,
                ppSacl,
                ppSecurityDescriptor
                );

    CONDITIONAL_EXIT(dwErr, End)

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End)

    dwErr = (*(gNtMartaInfo.pfrGetHandleRights))(
                   handle,
                   ObjectType,
                   SecurityInfo,
                   ppsidOwner,
                   ppsidGroup,
                   ppDacl,
                   ppSacl,
                   ppSecurityDescriptor
                   );

End:
    return(dwErr);
}

#else

DWORD
WINAPI
GetSecurityInfo(IN  HANDLE                 handle,
                IN  SE_OBJECT_TYPE         ObjectType,
                IN  SECURITY_INFORMATION   SecurityInfo,
                OUT PSID                  *ppsidOwner,
                OUT PSID                  *ppsidGroup,
                OUT PACL                  *ppDacl,
                OUT PACL                  *ppSacl,
                OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_MARTA(dwErr);

    //
    // We'll do this the easy way...
    //
    PACTRL_ACCESSW  pAccess = NULL, pAudit = NULL;
    PWSTR           pwszOwner = NULL, pwszGroup = NULL;

    dwErr = GetSecurityInfoExW(handle,
                               ObjectType,
                               SecurityInfo,
                               NULL,
                               NULL,
                               FLAG_ON(SecurityInfo,
                                       DACL_SECURITY_INFORMATION) ?
                                                             &pAccess :
                                                             NULL,
                               FLAG_ON(SecurityInfo,
                                       SACL_SECURITY_INFORMATION) ?
                                                             &pAudit :
                                                             NULL,
                               FLAG_ON(SecurityInfo,
                                       OWNER_SECURITY_INFORMATION) ?
                                                             &pwszOwner :
                                                             NULL,
                               FLAG_ON(SecurityInfo,
                                       GROUP_SECURITY_INFORMATION) ?
                                                             &pwszGroup :
                                                             NULL);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Now, convert it back into a SecurityDescriptor, so we
        // can rip it apart and return the right information
        //
        dwErr = (*gNtMartaInfo.pfAToSD)(pAccess,
                                        pAudit,
                                        pwszOwner,
                                        pwszGroup,
                                        ppSecurityDescriptor);
        if(dwErr == ERROR_SUCCESS)
        {
            SECURITY_DESCRIPTOR *pSD =
                                (SECURITY_DESCRIPTOR *)*ppSecurityDescriptor;

            if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
               ppsidOwner != NULL)
            {
                *ppsidOwner = RtlpOwnerAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
               ppsidGroup != NULL)
            {
                *ppsidGroup = RtlpGroupAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
               ppDacl != NULL)
            {
                *ppDacl = RtlpDaclAddrSecurityDescriptor(pSD);
            }

            if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
               ppSacl != NULL)
            {
                *ppSacl = RtlpSaclAddrSecurityDescriptor(pSD);
            }
        }

        LocalFree(pAccess);
        LocalFree(pAudit);
        LocalFree(pwszOwner);
        LocalFree(pwszGroup);

    }
    return(dwErr);
}
#endif




//+---------------------------------------------------------------------------
//
//  Function:   SetNamedSecurityInfoW
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  pObjectName]   --  Object on which to set the security
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT psidOwner]     --  Owner to set
//              [OUT psidGroup]     --  Group to set
//              [OUT pDacl]         --  Dacl to set
//              [OUT pSacl]         --  Sacl to set
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API
DWORD
WINAPI
SetNamedSecurityInfoW(IN LPWSTR                pObjectName,
                      IN SE_OBJECT_TYPE        ObjectType,
                      IN SECURITY_INFORMATION  SecurityInfo,
                      IN PSID                  psidOwner,
                      IN PSID                  psidGroup,
                      IN PACL                  pDacl,
                      IN PACL                  pSacl)
{
    DWORD dwErr;
    SECURITY_DESCRIPTOR SD;

    if (NULL == pObjectName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = SetErrorChecks(
                ObjectType,
                SecurityInfo,
                psidOwner,
                psidGroup,
                pDacl,
                pSacl,
                &SD
                );

    CONDITIONAL_EXIT(dwErr, End);

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End);

    dwErr = (*(gNtMartaInfo.pfrSetNamedRights))(
                pObjectName,
                ObjectType,
                SecurityInfo,
                &SD,
                FALSE // Do not skip inherited ace computation
                );

End:
    return dwErr;

}

#else

DWORD
WINAPI
SetNamedSecurityInfoW(IN LPWSTR                pObjectName,
                      IN SE_OBJECT_TYPE        ObjectType,
                      IN SECURITY_INFORMATION  SecurityInfo,
                      IN PSID                  psidOwner,
                      IN PSID                  psidGroup,
                      IN PACL                  pDacl,
                      IN PACL                  pSacl)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOLEAN Dacl = FALSE, Sacl = FALSE, Owner = FALSE, Group = FALSE;

    LOAD_MARTA(dwErr);

    //
    // Here, we'll first create a security descriptor, convert that into
    // access lists, and pass it on.
    //
    SECURITY_DESCRIPTOR SD;
    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);

    //
    // Set the owner, group, DAcl and SAcl in the SD
    //
    if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorOwner(&SD, psidOwner, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(psidOwner != NULL)
            {
                Owner = TRUE;
            }
        }


    }

    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorGroup(&SD, psidGroup, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(psidGroup != NULL)
            {
                Group = TRUE;
            }
        }
    }


    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pDacl != NULL)
            {
                Dacl = TRUE;
            }

            if(FLAG_ON(SecurityInfo, PROTECTED_DACL_SECURITY_INFORMATION))
            {
                SetSecurityDescriptorControl( &SD, SE_DACL_PROTECTED, SE_DACL_PROTECTED );
            }
        }
    }

    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorSacl(&SD, TRUE, pSacl, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pSacl != NULL)
            {
                Sacl = TRUE;
            }

            if(FLAG_ON(SecurityInfo, PROTECTED_SACL_SECURITY_INFORMATION))
            {
                SetSecurityDescriptorControl( &SD, SE_SACL_PROTECTED, SE_SACL_PROTECTED );
            }
        }
    }

    //
    // Now, if that worked, we'll convert it to our access format, and pass
    // it on.
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PACTRL_ACCESSW  pAccess = NULL, pAudit = NULL;
        PWSTR           pwszOwner = NULL, pwszGroup = NULL;

        dwErr = (*gNtMartaInfo.pfSDToA)(ObjectType,
                                        &SD,
                                        Dacl == FALSE ?
                                                  NULL  :
                                                  &pAccess,
                                        Sacl == FALSE ?
                                                  NULL  :
                                                  &pAudit,
                                        Owner == FALSE ?
                                                  NULL  :
                                                  &pwszOwner,
                                        Group == FALSE ?
                                                  NULL  :
                                                  &pwszGroup);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now that we have our access lists, pass them on to
            // the other APIs
            //
            dwErr = SetNamedSecurityInfoExW(pObjectName,
                                            ObjectType,
                                            SecurityInfo,
                                            NULL,
                                            pAccess,
                                            pAudit,
                                            pwszOwner,
                                            pwszGroup,
                                            NULL);
            LocalFree(pAccess);
            LocalFree(pAudit);
            LocalFree(pwszOwner);
            LocalFree(pwszGroup);
        }
    }

    return(dwErr);
}

#endif


//+---------------------------------------------------------------------------
//
//  Function:   SetNamedSecurityInfoA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  pObjectName]   --  Object on which to set the security
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT psidOwner]     --  Owner to set
//              [OUT psidGroup]     --  Group to set
//              [OUT pDacl]         --  Dacl to set
//              [OUT pSacl]         --  Sacl to set
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetNamedSecurityInfoA(IN LPSTR                 pObjectName,
                      IN SE_OBJECT_TYPE        ObjectType,
                      IN SECURITY_INFORMATION  SecurityInfo,
                      IN PSID                  psidOwner,
                      IN PSID                  psidGroup,
                      IN PACL                  pDacl,
                      IN PACL                  pSacl)
{
    //
    // Do the conversion, and pass it on...
    //
    PWSTR   pwszObject;

    DWORD   dwErr = ConvertStringAToStringW(pObjectName,
                                            &pwszObject);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = SetNamedSecurityInfoW(pwszObject,
                                      ObjectType,
                                      SecurityInfo,
                                      psidOwner,
                                      psidGroup,
                                      pDacl,
                                      pSacl);
        LocalFree(pwszObject);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetSecurityInfo
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  handle]        --  Handle to the open object on which
//                                      to set the security
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [OUT psidOwner]     --  Owner to set
//              [OUT psidGroup]     --  Group to set
//              [OUT pDacl]         --  Dacl to set
//              [OUT pSacl]         --  Sacl to set
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API
DWORD
WINAPI
SetSecurityInfo(IN HANDLE                handle,
                IN SE_OBJECT_TYPE        ObjectType,
                IN SECURITY_INFORMATION  SecurityInfo,
                IN PSID                  psidOwner,
                IN PSID                  psidGroup,
                IN PACL                  pDacl,
                IN PACL                  pSacl)
{
    DWORD dwErr;
    SECURITY_DESCRIPTOR SD;

    if (NULL == handle)
    {
        return ERROR_INVALID_HANDLE;
    }

    dwErr = SetErrorChecks(
                ObjectType,
                SecurityInfo,
                psidOwner,
                psidGroup,
                pDacl,
                pSacl,
                &SD
                );

    CONDITIONAL_EXIT(dwErr, End);

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End);

    dwErr = (*(gNtMartaInfo.pfrSetHandleRights))(
                handle,
                ObjectType,
                SecurityInfo,
                &SD
                );

End:
    return dwErr;

}

#else

DWORD
WINAPI
SetSecurityInfo(IN HANDLE                handle,
                IN SE_OBJECT_TYPE        ObjectType,
                IN SECURITY_INFORMATION  SecurityInfo,
                IN PSID                  psidOwner,
                IN PSID                  psidGroup,
                IN PACL                  pDacl,
                IN PACL                  pSacl)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOLEAN Dacl = FALSE, Sacl = FALSE, Owner = FALSE, Group = FALSE;

    LOAD_MARTA(dwErr);

    //
    // Same as before: Create the SecurityDescriptor, convert it to an
    // access list, and pass it on to the Ex APIs
    //
    SECURITY_DESCRIPTOR SD;
    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);

    //
    // Set the owner, group, DAcl and SAcl in the SD
    //
    if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorOwner(&SD, psidOwner, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(psidOwner != NULL)
            {
                Owner = TRUE;
            }
        }
    }

    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorGroup(&SD, psidGroup, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(psidGroup != NULL)
            {
                Group = TRUE;
            }
        }
    }


    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pDacl != NULL)
            {
                Dacl = TRUE;
            }
        }
    }

    if(dwErr == ERROR_SUCCESS &&
                        FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if(SetSecurityDescriptorSacl(&SD, TRUE, pSacl, FALSE) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(pSacl != NULL)
            {
                Sacl = TRUE;
            }
        }
    }

    //
    // Now, if that worked, we'll convert it our access format, and pass
    // it on.
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PACTRL_ACCESSW  pAccess = NULL, pAudit = NULL;
        PWSTR           pwszOwner = NULL, pwszGroup = NULL;

        dwErr = (*gNtMartaInfo.pfSDToA)(ObjectType,
                                        &SD,
                                        Dacl == FALSE ?
                                                  NULL  :
                                                  &pAccess,
                                        Sacl == FALSE ?
                                                  NULL  :
                                                  &pAudit,
                                        Owner == FALSE ?
                                                  NULL  :
                                                  &pwszOwner,
                                        Group == FALSE ?
                                                  NULL  :
                                                  &pwszGroup);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = SetSecurityInfoExW(handle,
                                       ObjectType,
                                       SecurityInfo,
                                       NULL,
                                       pAccess,
                                       pAudit,
                                       pwszOwner,
                                       pwszGroup,
                                       NULL);
            LocalFree(pAccess);
            LocalFree(pAudit);
            LocalFree(pwszOwner);
            LocalFree(pwszGroup);
        }
    }

    return(dwErr);
}
#endif




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAclW
//
//  Synopsis:   Adds the specified entries into the existing (if present)
//              ACL, returning the results
//
//  Arguments:  [IN  cCountOfExplicitEntries]   Number of items in list
//              [IN  pListOfExplicitEntries]    List of entries to be added
//              [IN  OldAcl]        --  OPTIONAL.  If present, the above
//                                      entries are merged with the this ACL
//              [OUT pNewAcl]       --  Where the new acl is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API

DWORD
WINAPI
SetEntriesInAclW(IN  ULONG               cCountOfExplicitEntries,
                 IN  PEXPLICIT_ACCESS_W  pListOfExplicitEntries,
                 IN  PACL                OldAcl,
                 OUT PACL               *pNewAcl)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_MARTA(dwErr);

    return (*(gNtMartaInfo.pfrSetEntriesInAcl))(
                   cCountOfExplicitEntries,
                   pListOfExplicitEntries,
                   OldAcl,
                   pNewAcl
                   );
}

#else
DWORD
WINAPI
SetEntriesInAclW(IN  ULONG               cCountOfExplicitEntries,
                 IN  PEXPLICIT_ACCESS_W  pListOfExplicitEntries,
                 IN  PACL                OldAcl,
                 OUT PACL               *pNewAcl)
{
    DWORD           dwErr = ERROR_SUCCESS;
    PACCESS_ENTRY   pAEntries = NULL;

    LOAD_MARTA(dwErr);

    CAcl CA(NULL,
            ACCESS_TO_UNKNOWN,
            FALSE,
            FALSE);

    //
    // Set the old ACL
    //
    dwErr = CA.SetAcl(OldAcl);


    if(dwErr == ERROR_SUCCESS && cCountOfExplicitEntries > 0)
    {
        dwErr = Win32ExplicitAccessToAccessEntry(cCountOfExplicitEntries,
                                                 pListOfExplicitEntries,
                                                 &pAEntries);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Add the requested access entries
            //
            dwErr = CA.AddAccessEntries(cCountOfExplicitEntries,
                                        pAEntries);
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Build the new ACL and merge in the access entries if necessary
        //
        dwErr = CA.BuildAcl(pNewAcl);
    }

    if(pAEntries)
    {
        LocalFree(pAEntries);
    }

    return(dwErr);
}
#endif




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAclA
//
//  Synopsis:   Same as above, execpt ANSI
//
//  Arguments:  [IN  cCountOfExplicitEntries]   Number of items in list
//              [IN  pListOfExplicitEntries]    List of entries to be added
//              [IN  OldAcl]        --  OPTIONAL.  If present, the above
//                                      entries are merged with the this ACL
//              [OUT pNewAcl]       --  Where the new acl is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------

#ifdef NEW_MARTA_API

typedef struct _MARTA_TMP_STRINGS
{
    LPSTR Name;
    LPSTR ObjectTypeName;
    LPSTR InheritedObjectTypeName;
} MARTA_TMP_STRINGS, *PMARTA_TMP_STRINGS;

DWORD
WINAPI
SetEntriesInAclA(IN  ULONG               cCountOfExplicitEntries,
                 IN  PEXPLICIT_ACCESS_A  pListOfExplicitEntries,
                 IN  PACL                OldAcl,
                 OUT PACL              *pNewAcl)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PMARTA_TMP_STRINGS Tmp = NULL;
    LPWSTR UnicodeString;
    POBJECTS_AND_NAME_A pObjName = NULL;
    ULONG i;

    if (0 != cCountOfExplicitEntries)
    {
        Tmp = (PMARTA_TMP_STRINGS) AccAlloc(sizeof(MARTA_TMP_STRINGS) * cCountOfExplicitEntries);

        if (NULL == Tmp)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        for (i = 0; i < cCountOfExplicitEntries; i++)
        {
            Tmp[i].Name = NULL;
            Tmp[i].ObjectTypeName = NULL;
            Tmp[i].InheritedObjectTypeName = NULL;

            switch (pListOfExplicitEntries[i].Trustee.TrusteeForm)
            {
            case TRUSTEE_IS_NAME:

                dwErr = ConvertStringAToStringW(
                            pListOfExplicitEntries[i].Trustee.ptstrName,
                            &UnicodeString
                            );

                if (ERROR_SUCCESS != dwErr)
                {
                    goto End;
                }

                Tmp[i].Name = pListOfExplicitEntries[i].Trustee.ptstrName;
                pListOfExplicitEntries[i].Trustee.ptstrName = (LPSTR) UnicodeString;

                break;

            case TRUSTEE_IS_OBJECTS_AND_NAME:

                pObjName = (POBJECTS_AND_NAME_A) pListOfExplicitEntries[i].Trustee.ptstrName;

                dwErr = ConvertStringAToStringW(
                            pObjName->ptstrName,
                            &UnicodeString
                            );

                if (ERROR_SUCCESS != dwErr)
                {
                    goto End;
                }

                Tmp[i].Name = pObjName->ptstrName;
                pObjName->ptstrName = (LPSTR) UnicodeString;

                dwErr = ConvertStringAToStringW(
                            pObjName->ObjectTypeName,
                            &UnicodeString
                            );

                if (ERROR_SUCCESS != dwErr)
                {
                    goto End;
                }

                Tmp[i].ObjectTypeName = pObjName->ObjectTypeName;
                pObjName->ObjectTypeName = (LPSTR) UnicodeString;

                dwErr = ConvertStringAToStringW(
                            pObjName->InheritedObjectTypeName,
                            &UnicodeString
                            );

                if (ERROR_SUCCESS != dwErr)
                {
                    goto End;
                }

                Tmp[i].InheritedObjectTypeName = pObjName->InheritedObjectTypeName;
                pObjName->InheritedObjectTypeName = (LPSTR) UnicodeString;

                break;

            default:
                break;
            }
        }
    }

    dwErr = SetEntriesInAclW(cCountOfExplicitEntries,
                             (PEXPLICIT_ACCESS_W)pListOfExplicitEntries,
                             OldAcl,
                             pNewAcl);

End:

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        switch (pListOfExplicitEntries[i].Trustee.TrusteeForm)
        {
        case TRUSTEE_IS_NAME:

            if (NULL != Tmp[i].Name)
            {
                AccFree(pListOfExplicitEntries[i].Trustee.ptstrName);
                pListOfExplicitEntries[i].Trustee.ptstrName = Tmp[i].Name;
            }

            break;

        case TRUSTEE_IS_OBJECTS_AND_NAME:

            pObjName = (POBJECTS_AND_NAME_A) pListOfExplicitEntries[i].Trustee.ptstrName;

            Tmp[i].ObjectTypeName = pObjName->ObjectTypeName;
            Tmp[i].InheritedObjectTypeName = pObjName->InheritedObjectTypeName;
            if (NULL != Tmp[i].Name)
            {
                AccFree(pObjName->ptstrName);
                pObjName->ptstrName = Tmp[i].Name;
            }

            if (NULL != Tmp[i].ObjectTypeName)
            {
                AccFree(pObjName->ObjectTypeName);
                pObjName->ObjectTypeName = Tmp[i].ObjectTypeName;
            }

            if (NULL != Tmp[i].InheritedObjectTypeName)
            {
                AccFree(pObjName->InheritedObjectTypeName);
                pObjName->InheritedObjectTypeName = Tmp[i].ObjectTypeName;
            }

            break;

        default:
            break;
        }
    }

    if (NULL != Tmp)
    {
        AccFree(Tmp);
    }

    return dwErr;
}
#else

DWORD
WINAPI
SetEntriesInAclA(IN  ULONG               cCountOfExplicitEntries,
                 IN  PEXPLICIT_ACCESS_A  pListOfExplicitEntries,
                 IN  PACL                OldAcl,
                 OUT PACL              *pNewAcl)
{
    DWORD   dwErr = ERROR_SUCCESS;
    CSList  ChangedList(CleanupConvertNode);

    dwErr = ConvertExplicitAccessAToW(cCountOfExplicitEntries,
                                      pListOfExplicitEntries,
                                      ChangedList);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = SetEntriesInAclW(cCountOfExplicitEntries,
                                 (PEXPLICIT_ACCESS_W)pListOfExplicitEntries,
                                 OldAcl,
                                 pNewAcl);
    }

    return(dwErr);
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   GetEffectiveRightsFromAclW
//
//  Synopsis:   Determines the effective rights of the given trustee from
//              the given acl
//
//  Arguments:  [IN  pacl]          --  The ACL to search
//              [IN  pTrustee]      --  Trustee for whom to get the effective
//                                      rights.
//              [OUT pAccessRights] --  Where the access mask is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetEffectiveRightsFromAclW(IN  PACL          pacl,
                           IN  PTRUSTEE_W    pTrustee,
                           OUT PACCESS_MASK  pAccessRights)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_MARTA(dwErr);

    //
    // Ok, here we simply make the right call to get the rights for
    // the trustee
    //
    ACCESS_RIGHTS   Allowed, Denied;
    dwErr = (*gNtMartaInfo.pfGetAccess)(pTrustee,
                                        pacl,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        &Allowed,
                                        &Denied);
    if(dwErr == ERROR_SUCCESS)
    {
        ACCESS_MASK CnvtAllowed, CnvtDenied;
        ConvertAccessRightToAccessMask(Allowed, &CnvtAllowed);
        ConvertAccessRightToAccessMask(Denied,  &CnvtDenied);

        *pAccessRights = CnvtAllowed & ~CnvtDenied;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetEffectiveRightsFromAclA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  pacl]          --  The ACL to search
//              [IN  pTrustee]      --  Trustee for whom to get the effective
//                                      rights.
//              [OUT pAccessRights] --  Where the access mask is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetEffectiveRightsFromAclA(IN  PACL          pacl,
                           IN  PTRUSTEE_A    pTrustee,
                           OUT PACCESS_MASK  pAccessRights)
{
    //
    // Convert the trustee to WIDE, and pass it on up
    //
    DWORD dwErr = ERROR_SUCCESS;
    TRUSTEE_W   TrusteeW;
    LOAD_MARTA(dwErr);

    dwErr = ConvertTrusteeAToTrusteeW(pTrustee,
                                      &TrusteeW,
                                      TRUE);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetEffectiveRightsFromAclW(pacl,
                                           &TrusteeW,
                                           pAccessRights);
        LocalFree(TrusteeW.ptstrName);
    }

    return(dwErr);
}


#if 0
#include "geefa_rewrite.cxx"
#endif


//+---------------------------------------------------------------------------
//
//  Function:   GetExplicitEntriesFromAclW
//
//  Synopsis:   "Converts" the given ACL into a list of EXPLICIT_ACCESS
//              entries
//
//  Arguments:  [IN  pacl]          --  The ACL to "convert"
//              [IN  pcCountOfExplicitEntries]  Where to return the number of
//                                      items in the list
//              [OUT pListOfExplicitEntries]    Where to return the list
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API
DWORD
WINAPI
GetExplicitEntriesFromAclW(IN  PACL                 pacl,
                           OUT PULONG               pcCountOfExplicitEntries,
                           OUT PEXPLICIT_ACCESS_W  *pListOfExplicitEntries)
{
    DWORD   dwErr = ERROR_SUCCESS;


#if 0
    return AccRewriteGetExplicitEntriesFromAcl(
              pacl,
              pcCountOfExplicitEntries,
              pListOfExplicitEntries
              );
#else

    LOAD_MARTA(dwErr);
    return (*gNtMartaInfo.pfrGetExplicitEntriesFromAcl)(
                 pacl,
                 pcCountOfExplicitEntries,
                 pListOfExplicitEntries
                 );
#endif
}
#else
DWORD
WINAPI
GetExplicitEntriesFromAclW(IN  PACL                 pacl,
                           OUT PULONG               pcCountOfExplicitEntries,
                           OUT PEXPLICIT_ACCESS_W  *pListOfExplicitEntries)
{
    DWORD   dwErr = ERROR_SUCCESS;
    LOAD_MARTA(dwErr);

    //
    // Convert the acl into an access list, and then do the conversion
    // on that...
    //
    PACTRL_ACCESSW  pAccess;
    dwErr = (*gNtMartaInfo.pfAclToA)(SE_UNKNOWN_OBJECT_TYPE,
                                     pacl,
                                     &pAccess);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertAccessWToExplicitW(pAccess,
                                          pcCountOfExplicitEntries,
                                          pListOfExplicitEntries);
        LocalFree(pAccess);
    }

    return(dwErr);
}
#endif




//+---------------------------------------------------------------------------
//
//  Function:   GetExplicitEntriesFromAclA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  pacl]          --  The ACL to "convert"
//              [IN  pcCountOfExplicitEntries]  Where to return the number of
//                                      items in the list
//              [OUT pListOfExplicitEntries]    Where to return the list
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
#ifdef NEW_MARTA_API
DWORD
WINAPI
GetExplicitEntriesFromAclA(IN  PACL                  pacl,
                           OUT PULONG                pcCountOfExplicitEntries,
                           OUT PEXPLICIT_ACCESS_A  * pListOfExplicitEntries)
{

    return GetExplicitEntriesFromAclW(
               pacl,
               pcCountOfExplicitEntries,
               (PEXPLICIT_ACCESS_W *) pListOfExplicitEntries
               );
}
#else
DWORD
WINAPI
GetExplicitEntriesFromAclA(IN  PACL                  pacl,
                           OUT PULONG                pcCountOfExplicitEntries,
                           OUT PEXPLICIT_ACCESS_A  * pListOfExplicitEntries)
{
    DWORD   dwErr = ERROR_SUCCESS;
    LOAD_MARTA(dwErr);

    //
    // Do the same conversion as above
    //
    PACTRL_ACCESSW  pAccess;
    dwErr = (*gNtMartaInfo.pfAclToA)(SE_UNKNOWN_OBJECT_TYPE,
                                     pacl,
                                     &pAccess);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertAccessWToExplicitA(pAccess,
                                          pcCountOfExplicitEntries,
                                          pListOfExplicitEntries);
        LocalFree(pAccess);
    }


    return(dwErr);
}
#endif



//+---------------------------------------------------------------------------
//
//  Function:   GetAuditedPermissionsFromAclW
//
//  Synopsis:   Determines the auditing rights for the given trustee
//
//  Arguments:  [IN  pacl]          --  The ACL to examine
//              [IN  pTrustee]      --  The trustee to check for
//              [OUT pSuccessfulAuditedRights]  Where the successful audit
//                                      mask is returned
//              [OUT pFailedAuditedRights]      Where the failed audit
//                                      mask is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetAuditedPermissionsFromAclW(IN  PACL          pacl,
                              IN  PTRUSTEE_W    pTrustee,
                              OUT PACCESS_MASK  pSuccessfulAuditedRights,
                              OUT PACCESS_MASK  pFailedAuditRights)
{
    DWORD   dwErr = ERROR_SUCCESS;
    LOAD_MARTA(dwErr);

    //
    // Ok, here we simply make the right call into the NTMARTA dll
    //
    ACCESS_RIGHTS   Allowed, Denied;
    dwErr = (*gNtMartaInfo.pfGetAccess)(pTrustee,
                                        pacl,
                                        SACL_SECURITY_INFORMATION,
                                        NULL,
                                        &Allowed,
                                        &Denied);
    if(dwErr == ERROR_SUCCESS)
    {
        ConvertAccessRightToAccessMask(Allowed, pSuccessfulAuditedRights);
        ConvertAccessRightToAccessMask(Denied,  pFailedAuditRights);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetAuditedPermissionsFromAclA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  pacl]          --  The ACL to examine
//              [IN  pTrustee]      --  The trustee to check for
//              [OUT pSuccessfulAuditedRights]  Where the successful audit
//                                      mask is returned
//              [OUT pFailedAuditedRights]      Where the failed audit
//                                      mask is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetAuditedPermissionsFromAclA(IN  PACL          pAcl,
                              IN  PTRUSTEE_A    pTrustee,
                              OUT PACCESS_MASK  pSuccessfulAuditedRights,
                              OUT PACCESS_MASK  pFailedAuditRights)
{
    //
    // Convert the trustee to WIDE, and pass it on up
    //
    TRUSTEE_W   TrusteeW;

    DWORD  dwErr = ConvertTrusteeAToTrusteeW(pTrustee,
                                             &TrusteeW,
                                             TRUE);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetAuditedPermissionsFromAclW(pAcl,
                                              &TrusteeW,
                                              pSuccessfulAuditedRights,
                                              pFailedAuditRights);
        LocalFree(TrusteeW.ptstrName);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildSecurityDescriptorW
//
//  Synopsis:   Builds a security descriptor from the various explicit access
//              and trustee information.  The returned security descriptor
//              is self relative.
//
//  Arguments:  [IN  pOwner]        --  Items new owner
//              [IN  pGroup]        --  Items new group
//              [IN  cCountOfAccessEntries] Number of items in access list
//              [IN  pListOfAccessEntries]  Actual access list
//              [IN  cCountOfAuditEntries]  Number of items in audit list
//              [IN  pListOfAuditEntries]   Actual audit list
//              [IN  pOldSD]        --  OPTIONAL.  Existing security
//                                      descriptor to merge with.  MUST BE
//                                      SELF RELATIVE
//              [OUT pSizeNewSD]    --  New SecDesc. size is returned here
//              [OUT pNewSD]        --  New SecDesc is returned here
//
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
BuildSecurityDescriptorW(IN  PTRUSTEE_W              pOwner,
                         IN  PTRUSTEE_W              pGroup,
                         IN  ULONG                   cCountOfAccessEntries,
                         IN  PEXPLICIT_ACCESS_W      pListOfAccessEntries,
                         IN  ULONG                   cCountOfAuditEntries,
                         IN  PEXPLICIT_ACCESS_W      pListOfAuditEntries,
                         IN  PSECURITY_DESCRIPTOR    pOldSD,
                         OUT PULONG                  pSizeNewSD,
                         OUT PSECURITY_DESCRIPTOR   *pNewSD)
{
    DWORD               dwErr;
    SECURITY_DESCRIPTOR SD;
    PACL                pDAcl = NULL, pSAcl = NULL;
    PACL                pNewDAcl = NULL, pNewSAcl = NULL;
    BOOL                fFreeDAcl = FALSE, fFreeSAcl = FALSE;
    PSID                pOwnerSid = NULL, pGroupSid = NULL;
    BOOL                fFreeOwner = FALSE, fFreeGroup = FALSE;

    LOAD_PROVIDERS(dwErr);

    if ( dwErr != ERROR_SUCCESS )
    {
        return( dwErr );
    }

    InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);

    //
    // input SD must be self relative
    //
    if(pOldSD != NULL)
    {
        SECURITY_DESCRIPTOR  *pIOldSd = (PISECURITY_DESCRIPTOR)pOldSD;

        if(!FLAG_ON(pIOldSd->Control,SE_SELF_RELATIVE))
        {
            dwErr = ERROR_INVALID_SECURITY_DESCR;
            goto errorexit;
        }

        //
        // get the owner, group, dacl and sacl from the input sd
        //
        if(pIOldSd->Owner)
        {
            pOwnerSid = RtlpOwnerAddrSecurityDescriptor( pIOldSd );
        }

        if(pIOldSd->Group)
        {
            pGroupSid = RtlpGroupAddrSecurityDescriptor( pIOldSd );
        }

        if(pIOldSd->Dacl)
        {
            pDAcl = RtlpDaclAddrSecurityDescriptor( pIOldSd );
        }

        if(pIOldSd->Sacl)
        {
            pSAcl = RtlpSaclAddrSecurityDescriptor( pIOldSd );
        }
    }

    //
    // if there is an input owner, override the one from the old SD
    //
    if(pOwner != NULL)
    {
        SID_NAME_USE    SNE;
        dwErr = (*gNtMartaInfo.pfSid)(NULL,
                                      pOwner,
                                      &pOwnerSid,
                                      &SNE);
        if (dwErr != ERROR_SUCCESS)
        {
            goto errorexit;
        }

        fFreeOwner = TRUE;
    }

    //
    // then the group
    //
    if (pGroup != NULL)
    {
        SID_NAME_USE    SNE;
        dwErr = (*gNtMartaInfo.pfSid)(NULL,
                                      pGroup,
                                      &pGroupSid,
                                      &SNE);
        if (dwErr != ERROR_SUCCESS)
        {
            goto errorexit;
        }

        fFreeGroup = TRUE;
    }

    //
    // then the dacl
    //
    if(cCountOfAccessEntries != 0)
    {
        dwErr = SetEntriesInAcl(cCountOfAccessEntries,
                                pListOfAccessEntries,
                                pDAcl,
                                &pNewDAcl);

        if(dwErr != ERROR_SUCCESS)
        {
            goto errorexit;
        }
        fFreeDAcl = TRUE;
    }
    else
    {
        pNewDAcl = pDAcl;
    }

    //
    // then the sacl
    //
    if(cCountOfAuditEntries != 0)
    {
        dwErr = SetEntriesInAcl(cCountOfAuditEntries,
                                pListOfAuditEntries,
                                pSAcl,
                                &pNewSAcl);
        if(dwErr != ERROR_SUCCESS)
        {
            goto errorexit;
        }
        fFreeSAcl = TRUE;
    }
    else
    {
        pNewSAcl = pSAcl;
    }


    //
    // Set the owner, group, dacl and sacl in the SD
    //
    if(SetSecurityDescriptorOwner(&SD, pOwnerSid, FALSE) == FALSE)
    {
        dwErr = GetLastError();
        goto errorexit;
    }

    if(SetSecurityDescriptorGroup(&SD, pGroupSid, FALSE) == FALSE)
    {
        dwErr = GetLastError();
        goto errorexit;
    }

    if(SetSecurityDescriptorDacl(&SD, TRUE, pNewDAcl, FALSE) == FALSE)
    {
        dwErr = GetLastError();
        goto errorexit;
    }

    if(SetSecurityDescriptorSacl(&SD, TRUE, pNewSAcl, FALSE) == FALSE)
    {
        dwErr = GetLastError();
        goto errorexit;
    }

    //
    // now make the final, self relative SD
    //
    *pSizeNewSD = 0;

    if (!MakeSelfRelativeSD(&SD, NULL, pSizeNewSD))
    {
        dwErr = GetLastError();

        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            *pNewSD = (PISECURITY_DESCRIPTOR)AccAlloc(*pSizeNewSD);

            if(*pNewSD == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                if(MakeSelfRelativeSD(&SD, *pNewSD, pSizeNewSD) == FALSE)
                {
                    LocalFree(*pNewSD);
                    dwErr = GetLastError();
                }
                else
                {

                    dwErr = ERROR_SUCCESS;
                }
            }
        }
    }
    else
    {
          dwErr = ERROR_INVALID_PARAMETER;
    }

errorexit:
    if(fFreeOwner)
    {
        AccFree(pOwnerSid);
    }

    if(fFreeGroup)
    {
        AccFree(pGroupSid);
    }

    if(fFreeDAcl)
    {
        AccFree(pNewDAcl);
    }

    if(fFreeSAcl)
    {
        AccFree(pNewSAcl);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildSecurityDescriptorA
//
//  Synopsis:   ANSI version of the above
//
//  Arguments:  [IN  pOwner]        --  Items new owner
//              [IN  pGroup]        --  Items new group
//              [IN  cCountOfAccessEntries] Number of items in access list
//              [IN  pListOfAccessEntries]  Actual access list
//              [IN  cCountOfAuditEntries]  Number of items in audit list
//              [IN  pListOfAuditEntries]   Actual audit list
//              [IN  pOldSD]        --  OPTIONAL.  Existing security
//                                      descriptor to merge with
//              [OUT pSizeNewSD]    --  New SecDesc. size is returned here
//              [OUT pNewSD]        --  New SecDesc is returned here
//
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
BuildSecurityDescriptorA(IN  PTRUSTEE_A             pOwner,
                         IN  PTRUSTEE_A             pGroup,
                         IN  ULONG                  cCountOfAccessEntries,
                         IN  PEXPLICIT_ACCESS_A     pListOfAccessEntries,
                         IN  ULONG                  cCountOfAuditEntries,
                         IN  PEXPLICIT_ACCESS_A     pListOfAuditEntries,
                         IN  PSECURITY_DESCRIPTOR   pOldSD,
                         OUT PULONG                 pSizeNewSD,
                         OUT PSECURITY_DESCRIPTOR  *ppNewSD)
{
    TRUSTEE_W           OwnerW, *pOwnerW = NULL;
    TRUSTEE_W           GroupW, *pGroupW = NULL;
    PEXPLICIT_ACCESS_W  pAccessW = NULL;
    PEXPLICIT_ACCESS_W  pAuditW = NULL;
    ULONG               cbBytes;
    PBYTE               pbStuffPtr;
    DWORD               dwErr = ERROR_SUCCESS;

    LOAD_MARTA(dwErr);

    OwnerW.ptstrName = NULL;
    GroupW.ptstrName = NULL;

    //
    // Convert owner.
    //
    if(pOwner != NULL)
    {
        dwErr = ConvertTrusteeAToTrusteeW(pOwner,
                                          &OwnerW,
                                          FALSE);
        pOwnerW = &OwnerW;

    }

    //
    // Convert the group now...
    //
    if(dwErr == ERROR_SUCCESS && pGroup != NULL)
    {
        dwErr = ConvertTrusteeAToTrusteeW(pGroup,
                                          &GroupW,
                                          FALSE);
        pGroupW = &GroupW;
    }

    //
    // Convert the access lists
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertExplicitAccessAToExplicitAccessW(cCountOfAccessEntries,
                                                        pListOfAccessEntries,
                                                        &pAccessW);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertExplicitAccessAToExplicitAccessW(cCountOfAuditEntries,
                                                        pListOfAuditEntries,
                                                        &pAuditW );
    }

    //
    // Then, make the call
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = BuildSecurityDescriptorW(pOwnerW,
                                         pGroupW,
                                         cCountOfAccessEntries,
                                         pAccessW,
                                         cCountOfAuditEntries,
                                         pAuditW,
                                         pOldSD,
                                         pSizeNewSD,
                                         ppNewSD);
    }

    //
    // Cleanup any allocated memory
    //
    if(pOwnerW != NULL)
    {
        AccFree(OwnerW.ptstrName);
    }

    if(pGroupW != NULL)
    {
        AccFree(GroupW.ptstrName);
    }

    if(pAccessW != NULL)
    {
        AccFree(pAccessW);
    }

    if(pAuditW != NULL)
    {
        AccFree(pAuditW);
    }

    return (dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   LookupSecurityDescriptorPartsW
//
//  Synopsis:   Converts a security descriptor into it's component parts
//
//  Arguments:  [OUT ppOwner]       --  Where to return the owner
//              [OUT ppGroup]       --  Where to return the group
//              [OUT pcCountOfAccessEntries]    Where to return the count of
//                                              access items
//              [OUT ppListOfAccessEntries]     Where to return the list of
//                                              access items
//              [OUT pcCountOfAuditEntries]     Where to return the count of
//                                              audit items
//              [OUT ppListOfAuditEntries]      Where to return the list of
//                                              audit items
//              [IN  pSD]           --  Security descriptor to seperate
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
LookupSecurityDescriptorPartsW(OUT PTRUSTEE_W          *ppOwner,
                               OUT PTRUSTEE_W          *ppGroup,
                               OUT PULONG               pcCountOfAccessEntries,
                               OUT PEXPLICIT_ACCESS_W  *ppListOfAccessEntries,
                               OUT PULONG               pcCountOfAuditEntries,
                               OUT PEXPLICIT_ACCESS_W  *ppListOfAuditEntries,
                               IN  PSECURITY_DESCRIPTOR pSD)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PACL                pAcl;
    PSID                pSid;
    BOOL                fDefaulted, fPresent;
    PTRUSTEE_W          pOwner = NULL, pGroup = NULL;
    ULONG               cAccess = 0, cAudit = 0;
    PEXPLICIT_ACCESS_W  pAccess = NULL, pAudit = NULL;

    LOAD_MARTA(dwErr);

    //
    // First, the owner
    //
    if(ppOwner != NULL)
    {
        if(GetSecurityDescriptorOwner(pSD, &pSid, &fDefaulted) == TRUE)
        {
            dwErr = (*gNtMartaInfo.pfTrustee)(NULL,
                                              pSid,
                                              &pOwner);
        }
        else
        {
            dwErr = GetLastError();
        }
    }

    //
    // Then the group
    //
    if(dwErr == ERROR_SUCCESS && ppGroup != NULL)
    {
        if(GetSecurityDescriptorGroup(pSD, &pSid, &fDefaulted))
        {
            dwErr = (*gNtMartaInfo.pfTrustee)(NULL,
                                              pSid,
                                              &pGroup);
        }
        else
        {
            dwErr = GetLastError();
        }
    }

    //
    // Now the DACL
    //
    if(dwErr == ERROR_SUCCESS && pcCountOfAccessEntries != NULL &&
                                              ppListOfAccessEntries != NULL)
    {
        if(GetSecurityDescriptorDacl(pSD,
                                     &fPresent,
                                     &pAcl,
                                     &fDefaulted) == TRUE)
        {
            dwErr = GetExplicitEntriesFromAclW(pAcl,
                                               &cAccess,
                                               &pAccess);
        }
        else
        {
            dwErr = GetLastError();
        }
    }
    else if(dwErr == ERROR_SUCCESS && (pcCountOfAccessEntries != NULL ||
                                               ppListOfAccessEntries != NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }


    //
    // Finally, the SACL
    //
    if(dwErr == ERROR_SUCCESS && pcCountOfAuditEntries != NULL &&
                                                ppListOfAuditEntries != NULL)
    {
        if(GetSecurityDescriptorSacl(pSD,
                                     &fPresent,
                                     &pAcl,
                                     &fDefaulted) == TRUE)
        {
            dwErr = GetExplicitEntriesFromAclW(pAcl,
                                               &cAudit,
                                               &pAudit);
        }
        else
        {
            dwErr = GetLastError();
        }
    }
    else if(dwErr == ERROR_SUCCESS &&  (pcCountOfAuditEntries != NULL ||
                                                ppListOfAuditEntries != NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // if succeeded, fill in the return arguments
    //
    if (dwErr == ERROR_SUCCESS)
    {
        if(ppOwner != NULL)
        {
            *ppOwner = pOwner;
        }

        if(ppGroup != NULL)
        {
            *ppGroup = pGroup;
        }

        if(ppListOfAccessEntries != NULL)
        {
            *ppListOfAccessEntries = pAccess;
            *pcCountOfAccessEntries = cAccess;
        }

        if(ppListOfAuditEntries != NULL)
        {
            *ppListOfAuditEntries = pAudit;
            *pcCountOfAuditEntries = cAudit;
        }
    }
    else
    {
        //
        // otherwise free any allocated memory
        //
        if(pOwner != NULL)
        {
            LocalFree(pOwner);
        }

        if(pGroup != NULL)
        {
            LocalFree(pGroup);
        }

        if(pAccess != NULL)
        {
            LocalFree(pAccess);
        }

        if(pAudit != NULL)
        {
            LocalFree(pAudit);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   LookupSecurityDescriptorPartsA
//
//  Synopsis:   ANSI version of the above
//
//  Arguments:  [OUT ppOwner]       --  Where to return the owner
//              [OUT ppGroup]       --  Where to return the group
//              [OUT pcCountOfAccessEntries]    Where to return the count of
//                                              access items
//              [OUT ppListOfAccessEntries]     Where to return the list of
//                                              access items
//              [OUT pcCountOfAuditEntries]     Where to return the count of
//                                              audit items
//              [OUT ppListOfAuditEntries]      Where to return the list of
//                                              audit items
//              [IN  pSD]           --  Security descriptor to seperate
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
LookupSecurityDescriptorPartsA(OUT PTRUSTEE_A           *ppOwner,
                               OUT PTRUSTEE_A           *ppGroup,
                               OUT PULONG                pcCountOfAccessEntries,
                               OUT PEXPLICIT_ACCESS_A   *ppListOfAccessEntries,
                               OUT PULONG                pcCountOfAuditEntries,
                               OUT PEXPLICIT_ACCESS_A   *ppListOfAuditEntries,
                               IN  PSECURITY_DESCRIPTOR  pSD)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PACL                pAcl;
    PSID                pSid;
    BOOL                fDefaulted, fPresent;
    PTRUSTEE_A          pOwner = NULL, pGroup = NULL;
    ULONG               cAccess = 0, cAudit = 0;
    PEXPLICIT_ACCESS_A  pAccess = NULL, pAudit = NULL;

    LOAD_MARTA(dwErr);

    //
    // First, the owner
    //
    if(ppOwner != NULL)
    {
        if(GetSecurityDescriptorOwner(pSD, &pSid, &fDefaulted) == TRUE)
        {
            PTRUSTEE_W  pTrusteeW;
            dwErr = (*gNtMartaInfo.pfTrustee)(NULL,
                                              pSid,
                                              &pTrusteeW);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertTrusteeWToTrusteeA(pTrusteeW,
                                                  &pOwner);
                LocalFree(pTrusteeW);
            }
        }
        else
        {
            dwErr = GetLastError();
        }
    }

    //
    // Then the group
    //
    if(dwErr == ERROR_SUCCESS && ppGroup != NULL)
    {
        if(GetSecurityDescriptorGroup(pSD, &pSid, &fDefaulted))
        {
            PTRUSTEE_W  pTrusteeW;
            dwErr = (*gNtMartaInfo.pfTrustee)(NULL,
                                              pSid,
                                              &pTrusteeW);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertTrusteeWToTrusteeA(pTrusteeW,
                                                  &pGroup);
                LocalFree(pTrusteeW);
            }
        }
        else
        {
            dwErr = GetLastError();
        }
    }

    //
    // Now the DACL
    //
    if(dwErr == ERROR_SUCCESS && pcCountOfAccessEntries != NULL &&
                                              ppListOfAccessEntries != NULL)
    {
        if(GetSecurityDescriptorDacl(pSD,
                                     &fPresent,
                                     &pAcl,
                                     &fDefaulted) == TRUE)
        {
            dwErr = GetExplicitEntriesFromAclA(pAcl,
                                               &cAccess,
                                               &pAccess);
        }
        else
        {
            dwErr = GetLastError();
        }
    }
    else if(dwErr == ERROR_SUCCESS && (pcCountOfAccessEntries != NULL ||
                                               ppListOfAccessEntries != NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }


    //
    // Finally, the SACL
    //
    if(dwErr == ERROR_SUCCESS && pcCountOfAuditEntries != NULL &&
                                                ppListOfAuditEntries != NULL)
    {
        if(GetSecurityDescriptorSacl(pSD,
                                     &fPresent,
                                     &pAcl,
                                     &fDefaulted) == TRUE)
        {
            dwErr = GetExplicitEntriesFromAclA(pAcl,
                                               &cAudit,
                                               &pAudit);
        }
        else
        {
            dwErr = GetLastError();
        }
    }
    else if(dwErr == ERROR_SUCCESS &&  (pcCountOfAuditEntries != NULL ||
                                                ppListOfAuditEntries != NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // if succeeded, fill in the return arguments
    //
    if (dwErr == ERROR_SUCCESS)
    {
        if(ppOwner != NULL)
        {
            *ppOwner = pOwner;
        }

        if(ppGroup != NULL)
        {
            *ppGroup = pGroup;
        }

        if(ppListOfAccessEntries != NULL)
        {
            *ppListOfAccessEntries = pAccess;
            *pcCountOfAccessEntries = cAccess;
        }

        if(ppListOfAuditEntries != NULL)
        {
            *ppListOfAuditEntries = pAudit;
            *pcCountOfAuditEntries = cAudit;
        }
    }
    else
    {
        //
        // otherwise free any allocated memory
        //
        if(pOwner != NULL)
        {
            LocalFree(pOwner);
        }

        if(pGroup != NULL)
        {
            LocalFree(pGroup);
        }

        if(pAccess != NULL)
        {
            LocalFree(pAccess);
        }

        if(pAudit != NULL)
        {
            LocalFree(pAudit);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildExplicitAccessWithNameW
//
//  Synopsis:   Initializes the given EXPLICIT_ACCESS entry
//
//  Arguments:  [OUT pExplicitAccess]   Structure to fill in
//              [IN  pTrusteeName]  --  Trustee name to set in strucutre
//              [IN  AccessPermissions] Access mask to set
//              [IN  AccessMode]    --  How to set the access permissions
//              [IN  Ihheritance]   --  Inheritance flags
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildExplicitAccessWithNameW(IN OUT PEXPLICIT_ACCESS_W  pExplicitAccess,
                             IN     LPWSTR              pTrusteeName,
                             IN     DWORD               AccessPermissions,
                             IN     ACCESS_MODE         AccessMode,
                             IN     DWORD               Inheritance)
{
    BuildTrusteeWithNameW(&(pExplicitAccess->Trustee), pTrusteeName);
    pExplicitAccess->grfAccessPermissions = AccessPermissions;
    pExplicitAccess->grfAccessMode = AccessMode;
    pExplicitAccess->grfInheritance = Inheritance;
}


//+---------------------------------------------------------------------------
//
//  Function:   BuildExplicitAccessWithNameA
//
//  Synopsis:   ANSI version of the above
//
//  Arguments:  [OUT pExplicitAccess]   Structure to fill in
//              [IN  pTrusteeName]  --  Trustee name to set in strucutre
//              [IN  AccessPermissions] Access mask to set
//              [IN  AccessMode]    --  How to set the access permissions
//              [IN  Ihheritance]   --  Inheritance flags
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildExplicitAccessWithNameA(IN OUT PEXPLICIT_ACCESS_A  pExplicitAccess,
                             IN     LPSTR               pTrusteeName,
                             IN     DWORD               AccessPermissions,
                             IN     ACCESS_MODE         AccessMode,
                             IN     DWORD               Inheritance)
{
    BuildTrusteeWithNameA(&(pExplicitAccess->Trustee), pTrusteeName);
    pExplicitAccess->grfAccessPermissions = AccessPermissions;
    pExplicitAccess->grfAccessMode = AccessMode;
    pExplicitAccess->grfInheritance = Inheritance;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildImpersonateExplicitAccessWithNameW
//
//  Synopsis:   Builds an impersonation explicit access entry
//
//  Arguments:  [OUT pExplicitAccess]   Structure to fill in
//              [IN  pTrusteeName]  --  Trustee name to set in strucutre
//              [IN  pTrustee]      --  Impersonate trustee
//              [IN  AccessPermissions] Access mask to set
//              [IN  AccessMode]    --  How to set the access permissions
//              [IN  Ihheritance]   --  Inheritance flags
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildImpersonateExplicitAccessWithNameW(
    IN OUT PEXPLICIT_ACCESS_W  pExplicitAccess,
    IN     LPWSTR              pTrusteeName,
    IN     PTRUSTEE_W          pTrustee,
    IN     DWORD               AccessPermissions,
    IN     ACCESS_MODE         AccessMode,
    IN     DWORD               Inheritance)
{
    BuildTrusteeWithNameW( &(pExplicitAccess->Trustee), pTrusteeName );
    BuildImpersonateTrusteeW( &(pExplicitAccess->Trustee), pTrustee );
    pExplicitAccess->grfAccessPermissions = AccessPermissions;
    pExplicitAccess->grfAccessMode = AccessMode;
    pExplicitAccess->grfInheritance = Inheritance;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildImpersonateExplicitAccessWithNameW
//
//  Synopsis:   ANSI version of the above
//
//  Arguments:  [OUT pExplicitAccess]   Structure to fill in
//              [IN  pTrusteeName]  --  Trustee name to set in strucutre
//              [IN  pTrustee]      --  Impersonate trustee
//              [IN  AccessPermissions] Access mask to set
//              [IN  AccessMode]    --  How to set the access permissions
//              [IN  Ihheritance]   --  Inheritance flags
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildImpersonateExplicitAccessWithNameA(
    IN OUT PEXPLICIT_ACCESS_A  pExplicitAccess,
    IN     LPSTR               pTrusteeName,
    IN     PTRUSTEE_A          pTrustee,
    IN     DWORD               AccessPermissions,
    IN     ACCESS_MODE         AccessMode,
    IN     DWORD               Inheritance)
{
    BuildTrusteeWithNameA( &(pExplicitAccess->Trustee), pTrusteeName );
    BuildImpersonateTrusteeA( &(pExplicitAccess->Trustee), pTrustee );
    pExplicitAccess->grfAccessPermissions = AccessPermissions;
    pExplicitAccess->grfAccessMode = AccessMode;
    pExplicitAccess->grfInheritance = Inheritance;
}

//+---------------------------------------------------------------------------
//
//  Function: TreeResetNamedSecurityInfoW
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  pObjectName]   --  Object on which to set the security
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN psidOwner]      --  Owner to set
//              [IN psidGroup]      --  Group to set
//              [IN pDacl]          --  Dacl to set
//              [IN pSacl]          --  Sacl to set
//              [IN KeepExplicit]   --  Whether children should retain explicit aces
//              [IN fnProgress]     --  Callback function
//              [IN ProgressInvokeSetting] --  Sacl to set
//              [IN Args]           --  Caller supplied arguments for callback
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
TreeResetNamedSecurityInfoW(
    IN LPWSTR               pObjectName,
    IN SE_OBJECT_TYPE       ObjectType,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSID                 pOwner,
    IN PSID                 pGroup,
    IN PACL                 pDacl,
    IN PACL                 pSacl,
    IN BOOL                 KeepExplicit,
    IN FN_PROGRESS          fnProgress,
    IN PROG_INVOKE_SETTING  ProgressInvokeSetting,
    IN PVOID                Args
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    if (NULL == pObjectName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch(ObjectType)
    {
    case SE_FILE_OBJECT:
    case SE_REGISTRY_KEY:
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        if ((SecurityInfo & PROTECTED_DACL_SECURITY_INFORMATION) &&
            (SecurityInfo & UNPROTECTED_DACL_SECURITY_INFORMATION))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        if ((SecurityInfo & PROTECTED_SACL_SECURITY_INFORMATION) &&
            (SecurityInfo & UNPROTECTED_SACL_SECURITY_INFORMATION))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    LOAD_MARTA(dwErr);

    if (dwErr != ERROR_SUCCESS)
    {
        return dwErr;
    }

    return (*(gNtMartaInfo.pfrTreeResetNamedSecurityInfo)) (
                  pObjectName,
                  ObjectType,
                  SecurityInfo,
                  pOwner,
                  pGroup,
                  pDacl,
                  pSacl,
                  KeepExplicit,
                  fnProgress,
                  ProgressInvokeSetting,
                  Args
                  );

}

//+---------------------------------------------------------------------------
//
//  Function: TreeResetNamedSecurityInfoA
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  pObjectName]   --  Object on which to set the security
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN psidOwner]      --  Owner to set
//              [IN psidGroup]      --  Group to set
//              [IN pDacl]          --  Dacl to set
//              [IN pSacl]          --  Sacl to set
//              [IN KeepExplicit]   --  Whether children should retain explicit aces
//              [IN fnProgress]     --  Callback function
//              [IN ProgressInvokeSetting] --  Sacl to set
//              [IN Args]           --  Caller supplied arguments for callback
//
//  Returns:    ERROR_CALL_NOT_IMPLEMENTED.
//              ANSI version is not supported.
//
//----------------------------------------------------------------------------
DWORD
WINAPI
TreeResetNamedSecurityInfoA(
    IN LPSTR                pObjectName,
    IN SE_OBJECT_TYPE       ObjectType,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSID                 pOwner,
    IN PSID                 pGroup,
    IN PACL                 pDacl,
    IN PACL                 pSacl,
    IN BOOL                 KeepExplicit,
    IN FN_PROGRESS          fnProgress,
    IN PROG_INVOKE_SETTING  ProgressInvokeSetting,
    IN PVOID                Args
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

//+---------------------------------------------------------------------------
//
//  Function: GetInheritanceSourceW
//
//  Synopsis:   For every inherited ace in a given acl, find the ancestor
//              from which it was inherited.
//
//  Arguments:  [IN pObjectName]      --  Name of the object
//              [IN ObjectType]       --  Type of object specified
//              [IN SecurityInfo]     --  Dacl or Sacl
//              [IN Container]        --  Whether object or container
//              [IN pObjectClassGuids]  --  Guids of the object
//              [IN GuidCount]        --  Number of guids 
//              [IN pAcl]             --  Dacl to set
//              [IN pfnArray]         --  For future, for any resource manager
//              [IN pGenericMapping]  --  Generic mapping for the object
//              [OUT pInheritArray]   --  To return output values as (Level, Name)
//
//  Returns:    ERROR_SUCCESS         --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetInheritanceSourceW(
    IN  LPWSTR                   pObjectName,
    IN  SE_OBJECT_TYPE           ObjectType,
    IN  SECURITY_INFORMATION     SecurityInfo,
    IN  BOOL                     Container,
    IN  GUID                  ** pObjectClassGuids OPTIONAL,
    IN  DWORD                    GuidCount,
    IN  PACL                     pAcl,
    IN  PFN_OBJECT_MGR_FUNCTS    pfnArray OPTIONAL,
    IN  PGENERIC_MAPPING         pGenericMapping,
    OUT PINHERITED_FROMW         pInheritArray

    )
{
    DWORD dwErr;

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End);

    dwErr = (*(gNtMartaInfo.pfrGetInheritanceSource)) (
                   pObjectName,
                   ObjectType,
                   SecurityInfo,
                   Container,
                   pObjectClassGuids,
                   GuidCount,
                   pAcl,
                   pGenericMapping,
                   pfnArray,
                   pInheritArray
                   );
End:
    return dwErr;
}

//+---------------------------------------------------------------------------
//
//  Function: GetInheritanceSourceA
//
//  Synopsis:   For every inherited ace in a given acl, find the ancestor
//              from which it was inherited.
//
//  Arguments:  [IN pObjectName]     --  Name of the object
//              [IN ObjectType]      --  Type of object specified
//              [IN SecurityInfo]    --  Dacl or Sacl
//              [IN Container]       --  Whether object or container
//              [IN pObjectTypeGuid] --  Guids of the object
//              [IN GuidCount]       --  Number of guids 
//              [IN pAcl]            --  Dacl to set
//              [IN pfnArray]        --  For future, for any resource manager
//              [IN pGenericMapping] --  Generic mapping for the object
//              [OUT pInheritArray]  --  To return output values as (Level, Name)
//
//  Returns:    ERROR_CALL_NOT_IMPLEMENTED
//              ANSI version is not supported.
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetInheritanceSourceA(
    IN  LPSTR                    pObjectName,
    IN  SE_OBJECT_TYPE           ObjectType,
    IN  SECURITY_INFORMATION     SecurityInfo,
    IN  BOOL                     Container,
    IN  GUID                  ** pObjectTypeGuid,
    IN  DWORD                    GuidCount,
    IN  PACL                     pAcl,
    IN  PFN_OBJECT_MGR_FUNCTS    pfnArray OPTIONAL,
    IN  PGENERIC_MAPPING         pGenericMapping,
    OUT PINHERITED_FROMA         pInheritArray

    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

//+---------------------------------------------------------------------------
//
//  Function: FreeInheritedFromArray
//
//  Synopsis:   Free the strings that were allocated and assigned to the array 
//              elements.
//
//  Arguments:  [IN pInheritArray]  --  Array from which strings will be freed.
//              [IN AceCnt]         --  Number of aces in the array
//              [IN pfnArray]       --  For future, for any resource manager
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
WINAPI
FreeInheritedFromArray(
    IN PINHERITED_FROMW pInheritArray,
    IN USHORT AceCnt,
    IN PFN_OBJECT_MGR_FUNCTS   pfnArray OPTIONAL
    )
{

    DWORD dwErr;

    LOAD_MARTA(dwErr);

    CONDITIONAL_EXIT(dwErr, End);

    dwErr = (*(gNtMartaInfo.pfrFreeIndexArray)) (
                   pInheritArray,
                   AceCnt,
                   NULL // Use LocalFree
                   );
End:
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\accctrl2\src\aclapiex.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       ACLAPIEX.CXX
//
//  Contents:   Ex versions of the Access Control APIs
//
//  History:    14-Sep-96       MacM        Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   GetNamedSecurityInfoExW
//
//  Synopsis:   Gets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  lpProperty]    --  OPTIONAL.  If present, the name of
//                                      property on the object to read from
//              [OUT ppAccessList]  --  Where the access list, if requested,
//                                      is returned.
//              [OUT ppAuditList]   --  Where the audit list, if requested,
//                                      is returned.
//              [OUT lppOwner]      --  Where the owners name, if requested,
//                                      is returned.
//              [OUT lppGroup]      --  Where the groups name, if requested,
//                                      is returned.
//              [OUT pOverlapped    --  OPTIONAL.  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetNamedSecurityInfoExW(IN   LPCWSTR                lpObject,
                        IN   SE_OBJECT_TYPE         ObjectType,
                        IN   SECURITY_INFORMATION   SecurityInfo,
                        IN   LPCWSTR                lpProvider,
                        IN   LPCWSTR                lpProperty,
                        OUT  PACTRL_ACCESSW        *ppAccessList,
                        OUT  PACTRL_AUDITW         *ppAuditList,
                        OUT  LPWSTR                *lppOwner,
                        OUT  LPWSTR                *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
                                                        ppAccessList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
                                                        ppAuditList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lppGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lppOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        dwErr = AccProvpGetProviderForPath(lpObject,
                                           ObjectType,
                                           lpProvider,
                                           &gAccProviders,
                                           &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Make the call
            //
            PTRUSTEE            pOwner, pGroup;
            __try
            {
                dwErr = (*(pProvider->pfGetRights))(
                                    lpObject,
                                    ObjectType,
                                    lpProperty,
                                    FLAG_ON(SecurityInfo,
                                            DACL_SECURITY_INFORMATION) ?
                                                    ppAccessList :
                                                    NULL,
                                    FLAG_ON(SecurityInfo,
                                            SACL_SECURITY_INFORMATION) ?
                                                    ppAuditList :
                                                    NULL,
                                    FLAG_ON(SecurityInfo,
                                            OWNER_SECURITY_INFORMATION) ?
                                                    &pOwner :
                                                    NULL,
                                    FLAG_ON(SecurityInfo,
                                            GROUP_SECURITY_INFORMATION) ?
                                                    &pGroup :
                                                    NULL);

            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                if(pProvider->pfGetRights == NULL)
                {
                    dwErr = ERROR_BAD_PROVIDER;
                }
                else
                {
                    dwErr = RtlNtStatusToDosError(GetExceptionCode());
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Save off our owner/group names, and free the memory
                //
                if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
                {
                    ACC_ALLOC_AND_COPY_STRINGW(pOwner->ptstrName,
                                               *lppOwner,
                                               dwErr);
                    AccFree(pOwner);
                }

                if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
                {
                    if(dwErr == ERROR_SUCCESS)
                    {
                        ACC_ALLOC_AND_COPY_STRINGW(pGroup->ptstrName,
                                                   *lppGroup,
                                                   dwErr);
                    }
                    AccFree(pGroup);
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetNamedSecurityInfoExA
//
//  Synopsis:   Same as above, except ANSI version
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  lpProperty]    --  OPTIONAL.  If present, the name of
//                                      property on the object to read from
//              [OUT ppAccessList]  --  Where the access list, if requested,
//                                      is returned.
//              [OUT ppAuditList]   --  Where the audit list, if requested,
//                                      is returned.
//              [OUT lppOwner]      --  Where the owners name, if requested,
//                                      is returned.
//              [OUT lppGroup]      --  Where the groups name, if requested,
//                                      is returned.
//              [OUT pOverlapped    --  OPTIONAL.  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetNamedSecurityInfoExA(IN   LPCSTR                lpObject,
                        IN   SE_OBJECT_TYPE        ObjectType,
                        IN   SECURITY_INFORMATION  SecurityInfo,
                        IN   LPCSTR                lpProvider,
                        IN   LPCSTR                lpProperty,
                        OUT  PACTRL_ACCESSA       *ppAccessList,
                        OUT  PACTRL_AUDITA        *ppAuditList,
                        OUT  LPSTR                *lppOwner,
                        OUT  LPSTR                *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    PWSTR   pwszObject;
    PWSTR   pwszProvider = NULL;
    PWSTR   pwszProperty = NULL;


    dwErr = ConvertStringAToStringW((PSTR)lpObject,
                                    &pwszObject);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                        &pwszProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpProperty,
                                            &pwszProperty);
        }
    }


    //
    // Do the call...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszOwner = NULL, pwszGroup = NULL;
        PACTRL_ACCESSW  pAccessListW = NULL;
        PACTRL_AUDITW   pAuditListW = NULL;
        dwErr = GetNamedSecurityInfoExW((PCWSTR)pwszObject,
                                        ObjectType,
                                        SecurityInfo,
                                        (PCWSTR)pwszProvider,
                                        (PCWSTR)pwszProperty,
                                        ppAccessList == NULL ?
                                                            NULL  :
                                                            &pAccessListW,
                                        ppAuditList == NULL  ?
                                                            NULL  :
                                                            &pAuditListW,
                                        lppOwner == NULL ?
                                                        NULL  :
                                                        &pwszOwner,
                                        lppGroup == NULL ?
                                                        NULL  :
                                                        &pwszGroup);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // See if we have to convert any of the returned owners or groups
            //
            if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
            {
                dwErr = ConvertStringWToStringA(pwszOwner,
                                                lppOwner);
            }

            if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                      dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertStringWToStringA(pwszGroup,
                                                lppGroup);
            }

            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
                                                     dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertAListWToAlistAInplace(pAccessListW);
                if(dwErr == ERROR_SUCCESS)
                {
                    *ppAccessList = (PACTRL_AUDITA)pAccessListW;
                }
            }

            if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
                                                     dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertAListWToAlistAInplace(pAuditListW);
                if(dwErr == ERROR_SUCCESS)
                {
                    *ppAuditList = (PACTRL_AUDITA)pAuditListW;
                }
            }

            //
            // If something failed, make sure we deallocate any information
            //
            if(dwErr != ERROR_SUCCESS)
            {
                if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
                {
                    LocalFree(*ppAccessList);
                    LocalFree(pAccessListW);
                }

                if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
                {
                    LocalFree(*ppAuditList);
                    LocalFree(pAuditListW);
                }

                if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
                {
                    LocalFree(*lppGroup);
                    LocalFree(pwszGroup);
                }

                if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
                {
                    LocalFree(*lppOwner);
                    LocalFree(pwszOwner);
                }
            }
        }
    }
    //
    // Free our allocated strings...
    //
    LocalFree(pwszObject);
    LocalFree(pwszProvider);
    LocalFree(pwszProperty);

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetNamedSecurityInfoExW
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be set
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pAccessList]   --  OPTIONAL  The access list to set
//              [OUT pAuditList]    --  OPTIONAL  The audit list to set
//              [OUT lppOwner]      --  OPTIONAL  The owner to set
//              [OUT lppGroup]      --  OPTIONAL  The group name to set
//              [OUT pOverlapped    --  OPTIONAL  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetNamedSecurityInfoExW(IN    LPCWSTR                lpObject,
                        IN    SE_OBJECT_TYPE         ObjectType,
                        IN    SECURITY_INFORMATION   SecurityInfo,
                        IN    LPCWSTR                lpProvider,
                        IN    PACTRL_ACCESSW         pAccessList,
                        IN    PACTRL_AUDITW          pAuditList,
                        IN    LPWSTR                 lpOwner,
                        IN    LPWSTR                 lpGroup,
                        IN    PACTRL_OVERLAPPED      pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lpGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lpOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        CSList  ChangedList(CleanupConvertNode);

        //
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        dwErr = AccProvpGetProviderForPath(lpObject,
                                           ObjectType,
                                           lpProvider,
                                           &gAccProviders,
                                           &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Change our access lists if necessary.  This means that
            // we'll go through and change any SIDS to names.  The way the
            // conversion works is that if a node needs to have it's
            // trustee name changed, the address of the trustee's name,
            // and its old value are saved off in ChangedList.  Then, when
            // the list is destructed, it goes through and deletes the
            // current trustee name (gotten through the saved address)
            // and restores the old sid
            //
            if(!FLAG_ON(pProvider->fProviderCaps,ACTRL_CAP_KNOWS_SIDS) &&
               FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListToNamedBasedW(pAccessList,
                                                  ChangedList);
            }

            if(dwErr == ERROR_SUCCESS &&
               !FLAG_ON(pProvider->fProviderCaps,ACTRL_CAP_KNOWS_SIDS) &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListToNamedBasedW(pAuditList,
                                                  ChangedList);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Check for the caller wanting a synchronous call...
                //
                ACTRL_OVERLAPPED    LocalOverlapped;
                PACTRL_OVERLAPPED   pActiveOverlapped = pOverlapped;

                if(pActiveOverlapped == NULL)
                {
                    pActiveOverlapped = &LocalOverlapped;
                }

                TRUSTEE_W   Group = {0};
                TRUSTEE_W   Owner = {0};
                PTRUSTEE    pGroup = NULL;
                PTRUSTEE    pOwner = NULL;

                if(FLAG_ON(SecurityInfo,GROUP_SECURITY_INFORMATION))
                {
                    pGroup = &Group;
                    BuildTrusteeWithName(pGroup,
                                         lpGroup);
                }

                if(FLAG_ON(SecurityInfo,OWNER_SECURITY_INFORMATION))
                {
                    pOwner = &Owner;
                    BuildTrusteeWithName(pOwner,
                                         lpOwner);
                }

                //
                // Set up the overlapped structure
                //
                memset(pActiveOverlapped, 0, sizeof(ACTRL_OVERLAPPED));
                pActiveOverlapped->hEvent = CreateEvent(NULL,
                                                        TRUE,
                                                        FALSE,
                                                        NULL);
                pActiveOverlapped->Provider = pProvider;
                if(pActiveOverlapped->hEvent == NULL)
                {
                    dwErr = GetLastError();
                }
                else
                {
                    //
                    // Make the call
                    //
                    __try
                    {
                        dwErr = (*(pProvider->pfSetAccess))(
                                                       lpObject,
                                                       ObjectType,
                                                       SecurityInfo,
                                                       pAccessList,
                                                       pAuditList,
                                                       pOwner,
                                                       pGroup,
                                                       pActiveOverlapped);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        if(pProvider->pfSetAccess == NULL)
                        {
                            dwErr = ERROR_BAD_PROVIDER;
                        }
                        else
                        {
                            dwErr = RtlNtStatusToDosError(GetExceptionCode());
                        }
                    }

                    if(dwErr != ERROR_SUCCESS)
                    {
                        CloseHandle(pActiveOverlapped->hEvent);
                    }

                }

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // See if we're supposed to do this synchronously
                    //
                    if(pActiveOverlapped != pOverlapped)
                    {
                        DWORD   dwRet;
                        dwErr  = GetOverlappedAccessResults(
                                                        pActiveOverlapped,
                                                        TRUE,
                                                        &dwRet,
                                                        NULL);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            dwErr = dwRet;
                        }
                    }
                }
            }
        }
    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   SetNamedSecurityInfoExA
//
//  Synopsis:   Same as above, but an ANSI version
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be set
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pAccessList]   --  OPTIONAL  The access list to set
//              [OUT pAuditList]    --  OPTIONAL  The audit list to set
//              [OUT lppOwner]      --  OPTIONAL  The owner to set
//              [OUT lppGroup]      --  OPTIONAL  The group name to set
//              [OUT pOverlapped    --  OPTIONAL  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      This is not a simple matter of converting a few strings/etc
//              and calling the Unicode version, since that would involve
//              processing the list twice.  Yuk.  So, we go ahead and do the
//              the conversion and update of our input structures, and make
//              the call ourselves...
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetNamedSecurityInfoExA(IN    LPCSTR                 lpObject,
                        IN    SE_OBJECT_TYPE         ObjectType,
                        IN    SECURITY_INFORMATION   SecurityInfo,
                        IN    LPCSTR                 lpProvider,
                        IN    PACTRL_ACCESSA         pAccessList,
                        IN    PACTRL_AUDITA          pAuditList,
                        IN    LPSTR                  lpOwner,
                        IN    LPSTR                  lpGroup,
                        IN    PACTRL_OVERLAPPED      pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(((SecurityInfo) & (GROUP_SECURITY_INFORMATION)) &&
                                                        lpGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lpOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        CSList  ChangedList(CleanupConvertNode);

        PWSTR   pwszObject;
        PWSTR   pwszProvider = NULL;

        dwErr = ConvertStringAToStringW((PSTR)lpObject,
                                        &pwszObject);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                            &pwszProvider);
        }

        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccProvpGetProviderForPath(pwszObject,
                                               ObjectType,
                                               pwszProvider,
                                               &gAccProviders,
                                               &pProvider);
        }

        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_ACCESSW  pAccessW = NULL;
            PACTRL_ACCESSW  pAuditW  = NULL;

            //
            // Change our access lists if necessary.  This means that
            // we'll go through and change any SIDS to names, and all
            // ansi strings to unicode strings.  This works exactly
            // as described in SetNamedSecurityInfoExW, with the
            // exception that we don't deal exclusively with trustee
            // names, but also property names and inherit object names
            //
            BOOL    fConvertSids = (BOOL)!FLAG_ON(pProvider->fProviderCaps,
                                                  ACTRL_CAP_KNOWS_SIDS) ;
            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListAToNamedBasedW(pAccessList,
                                                   ChangedList,
                                                   fConvertSids,
                                                   &pAccessW);
            }

            if(dwErr == ERROR_SUCCESS &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListAToNamedBasedW(pAuditList,
                                                   ChangedList,
                                                   fConvertSids,
                                                   &pAuditW);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Check for the caller wanting a synchronous call...
                //
                ACTRL_OVERLAPPED    LocalOverlapped;
                PACTRL_OVERLAPPED   pActiveOverlapped = pOverlapped;

                if(pActiveOverlapped == NULL)
                {
                    pActiveOverlapped = &LocalOverlapped;
                }

                TRUSTEE_W   Group = {0};
                TRUSTEE_W   Owner = {0};
                PTRUSTEE    pGroup = NULL;
                PTRUSTEE    pOwner = NULL;

                if(FLAG_ON(SecurityInfo,GROUP_SECURITY_INFORMATION))
                {
                    pGroup = &Group;
                    PWSTR   pwszGroup = NULL;
                    dwErr = ConvertStringAToStringW(lpGroup,
                                                    &pwszGroup);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        BuildTrusteeWithName(pGroup,
                                             pwszGroup);
                    }
                }

                if(dwErr == ERROR_SUCCESS &&
                   FLAG_ON(SecurityInfo,OWNER_SECURITY_INFORMATION))
                {
                    pOwner = &Owner;
                    PWSTR   pwszOwner = NULL;
                    dwErr = ConvertStringAToStringW(lpOwner,
                                                    &pwszOwner);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        BuildTrusteeWithName(pOwner,
                                             pwszOwner);
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Set up the overlapped structure
                    //
                    memset(pActiveOverlapped, 0, sizeof(ACTRL_OVERLAPPED));
                    pActiveOverlapped->Provider = pProvider;
                    pActiveOverlapped->hEvent = CreateEvent(NULL,
                                                            TRUE,
                                                            FALSE,
                                                            NULL);
                    if(pActiveOverlapped->hEvent == NULL)
                    {
                        dwErr = GetLastError();
                    }
                    else
                    {
                        //
                        // Make the call
                        //
                        __try
                        {
                            dwErr = (*(pProvider->pfSetAccess))(
                                                       pwszObject,
                                                       ObjectType,
                                                       SecurityInfo,
                                                       pAccessW,
                                                       pAuditW,
                                                       pOwner,
                                                       pGroup,
                                                       pActiveOverlapped);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            if(pProvider->pfSetAccess == NULL)
                            {
                                dwErr = ERROR_BAD_PROVIDER;
                            }
                            else
                            {
                                dwErr = RtlNtStatusToDosError(GetExceptionCode());
                            }
                        }

                        if(dwErr != ERROR_SUCCESS)
                        {
                            CloseHandle(pActiveOverlapped->hEvent);
                        }

                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // See if we're supposed to do this synchronously
                        //
                        if(pActiveOverlapped != pOverlapped)
                        {
                            DWORD   dwRet;
                            dwErr  = GetOverlappedAccessResults(
                                                        pActiveOverlapped,
                                                        TRUE,
                                                        &dwRet,
                                                        NULL);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = dwRet;
                            }
                        }
                    }
                }

                //
                // Free our allocated memory
                //
                if(pOwner != NULL)
                {
                    LocalFree(pOwner->ptstrName);
                }

                if(pGroup != NULL)
                {
                    LocalFree(pGroup->ptstrName);
                }
            }
        }

        //
        // Free our allocated strings...
        //
        LocalFree(pwszObject);
        LocalFree(pwszProvider);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetSecurityInfoExW
//
//  Synopsis:   Gets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  hObject]       --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  lpProperty]    --  OPTIONAL.  If present, the name of
//                                      property on the object to read from
//              [OUT ppAccessList]  --  Where the access list, if requested,
//                                      is returned.
//              [OUT ppAuditList]   --  Where the audit list, if requested,
//                                      is returned.
//              [OUT lppOwner]      --  Where the owners name, if requested,
//                                      is returned.
//              [OUT lppGroup]      --  Where the groups name, if requested,
//                                      is returned.
//              [OUT pOverlapped    --  OPTIONAL.  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_HANDLE    A bad handle was encountered
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetSecurityInfoExW(IN    HANDLE                  hObject,
                   IN    SE_OBJECT_TYPE          ObjectType,
                   IN    SECURITY_INFORMATION    SecurityInfo,
                   IN    LPCWSTR                lpProvider,
                   IN    LPCWSTR                lpProperty,
                   OUT   PACTRL_ACCESSW         *ppAccessList,
                   OUT   PACTRL_AUDITW          *ppAuditList,
                   OUT   LPWSTR                 *lppOwner,
                   OUT   LPWSTR                 *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(hObject == NULL)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
                                                        ppAccessList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
                                                        ppAuditList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lppGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lppOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        dwErr = AccProvpGetProviderForHandle(hObject,
                                             ObjectType,
                                             lpProvider,
                                             &gAccProviders,
                                             &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Make the call
            //
            PTRUSTEE            pOwner, pGroup;
            __try
            {
                dwErr = (*(pProvider->pfhGetRights))(
                                    hObject,
                                    ObjectType,
                                    lpProperty,
                                    FLAG_ON(SecurityInfo,
                                            DACL_SECURITY_INFORMATION) ?
                                                     ppAccessList :
                                                     NULL,
                                    FLAG_ON(SecurityInfo,
                                            SACL_SECURITY_INFORMATION) ?
                                                     ppAuditList :
                                                     NULL,
                                    FLAG_ON(SecurityInfo,
                                            OWNER_SECURITY_INFORMATION) ?
                                                     &pOwner :
                                                     NULL,
                                    FLAG_ON(SecurityInfo,
                                            GROUP_SECURITY_INFORMATION) ?
                                                     &pGroup :
                                                     NULL);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                if(pProvider->pfhGetRights == NULL)
                {
                    dwErr = ERROR_BAD_PROVIDER;
                }
                else
                {
                    dwErr = RtlNtStatusToDosError(GetExceptionCode());
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Save off our owner/group names, and deallocate the memory
                //
                if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
                {
                    ACC_ALLOC_AND_COPY_STRINGW(pOwner->ptstrName,
                                               *lppOwner,
                                               dwErr);
                    AccFree(pOwner);
                }

                if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
                {
                    if(dwErr == ERROR_SUCCESS)
                    {
                        ACC_ALLOC_AND_COPY_STRINGW(pGroup->ptstrName,
                                                   *lppGroup,
                                                   dwErr);
                    }
                    AccFree(pGroup);
                }

            }
        }
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetSecurityInfoExA
//
//  Synopsis:   Same as above, except ANSI version
//
//  Arguments:  [IN  hObject]       --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be returned
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  lpProperty]    --  OPTIONAL.  If present, the name of
//                                      property on the object to read from
//              [OUT ppAccessList]  --  Where the access list, if requested,
//                                      is returned.
//              [OUT ppAuditList]   --  Where the audit list, if requested,
//                                      is returned.
//              [OUT lppOwner]      --  Where the owners name, if requested,
//                                      is returned.
//              [OUT lppGroup]      --  Where the groups name, if requested,
//                                      is returned.
//              [OUT pOverlapped    --  OPTIONAL.  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetSecurityInfoExA(IN    HANDLE                  hObject,
                   IN    SE_OBJECT_TYPE          ObjectType,
                   IN    SECURITY_INFORMATION    SecurityInfo,
                   IN    LPCSTR                  lpProvider,
                   IN    LPCSTR                  lpProperty,
                   OUT   PACTRL_ACCESSA         *ppAccessList,
                   OUT   PACTRL_AUDITA          *ppAuditList,
                   OUT   LPSTR                  *lppOwner,
                   OUT   LPSTR                  *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    PWSTR   pwszProvider = NULL;
    PWSTR   pwszProperty = NULL;

    dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                    &pwszProvider);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertStringAToStringW((PSTR)lpProperty,
                                        &pwszProperty);
    }

    //
    // Do the call...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszOwner = NULL, pwszGroup = NULL;
        PACTRL_ACCESSW  pAccessListW = NULL;
        PACTRL_AUDITW   pAuditListW = NULL;
        dwErr = GetSecurityInfoExW(hObject,
                                   ObjectType,
                                   SecurityInfo,
                                   (PCWSTR)pwszProvider,
                                   (PCWSTR)pwszProperty,
                                   ppAccessList == NULL ?
                                                       NULL  :
                                                       &pAccessListW,
                                   ppAuditList == NULL  ?
                                                       NULL  :
                                                       &pAuditListW,
                                   lppOwner == NULL ?
                                                   NULL  :
                                                   &pwszOwner,
                                   lppGroup == NULL ?
                                                   NULL  :
                                                   &pwszGroup);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // See if we have to convert any of the returned owners or groups
            //
            if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
            {
                dwErr = ConvertStringWToStringA(pwszOwner,
                                                lppOwner);
            }

            if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                      dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertStringWToStringA(pwszGroup,
                                                lppGroup);
            }

            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) &&
                                                     dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertAListWToAlistAInplace(pAccessListW);
                if(dwErr == ERROR_SUCCESS)
                {
                    *ppAccessList = (PACTRL_AUDITA)pAccessListW;
                }
            }

            if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) &&
                                                     dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertAListWToAlistAInplace(pAuditListW);
                if(dwErr == ERROR_SUCCESS)
                {
                    *ppAuditList = (PACTRL_AUDITA)pAuditListW;
                }
            }

            //
            // If something failed, make sure we deallocate any information
            //
            if(dwErr != ERROR_SUCCESS)
            {
                if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
                {
                    LocalFree(*ppAccessList);
                    LocalFree(pAccessListW);
                }

                if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
                {
                    LocalFree(*ppAuditList);
                    LocalFree(pAuditListW);
                }

                if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
                {
                    LocalFree(*lppGroup);
                    LocalFree(pwszGroup);
                }

                if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
                {
                    LocalFree(*lppOwner);
                    LocalFree(pwszOwner);
                }
            }
        }
    }
    //
    // Free our allocated strings...
    //
    LocalFree(pwszProvider);
    LocalFree(pwszProperty);

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetSecurityInfoExW
//
//  Synopsis:   Sets the specified security information from the indicated
//              object
//
//  Arguments:  [IN  hObject]       --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be set
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pAccessList]   --  OPTIONAL  The access list to set
//              [OUT pAuditList]    --  OPTIONAL  The audit list to set
//              [OUT lppOwner]      --  OPTIONAL  The owner to set
//              [OUT lppGroup]      --  OPTIONAL  The group name to set
//              [OUT pOverlapped    --  OPTIONAL  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_HANDLE    A bad handle was encountered
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetSecurityInfoExW(IN    HANDLE                 hObject,
                   IN    SE_OBJECT_TYPE         ObjectType,
                   IN    SECURITY_INFORMATION   SecurityInfo,
                   IN    LPCWSTR               lpProvider,
                   IN    PACTRL_ACCESSW         pAccessList,
                   IN    PACTRL_AUDITW          pAuditList,
                   IN    LPWSTR                lpOwner,
                   IN    LPWSTR                lpGroup,
                   OUT   PACTRL_OVERLAPPED      pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(hObject == NULL || hObject == INVALID_HANDLE_VALUE)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lpGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lpOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        CSList  ChangedList(CleanupConvertNode);

        //
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        dwErr = AccProvpGetProviderForHandle(hObject,
                                             ObjectType,
                                             lpProvider,
                                             &gAccProviders,
                                             &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Change our access lists if necessary.  This means that
            // we'll go through and change any SIDS to names.  The way the
            // conversion works is that if a node needs to have it's
            // trustee name changed, the address of the trustee's name,
            // and its old value are saved off in ChangedList.  Then,
            // when the list is destructed, it goes through and deletes
            // the current trustee name (gotten through the saved address)
            // and restores the old name
            //
            if(!FLAG_ON(pProvider->fProviderCaps,ACTRL_CAP_KNOWS_SIDS) &&
               FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListToNamedBasedW(pAccessList,
                                                  ChangedList);
            }

            if(dwErr == ERROR_SUCCESS &&
               !FLAG_ON(pProvider->fProviderCaps,ACTRL_CAP_KNOWS_SIDS) &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListToNamedBasedW(pAuditList,
                                                  ChangedList);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Check for the caller wanting a synchronous call...
                //
                ACTRL_OVERLAPPED    LocalOverlapped;
                PACTRL_OVERLAPPED   pActiveOverlapped = pOverlapped;

                if(pActiveOverlapped == NULL)
                {
                    pActiveOverlapped = &LocalOverlapped;
                }

                TRUSTEE_W   Group = {0};
                TRUSTEE_W   Owner = {0};
                PTRUSTEE    pGroup = NULL;
                PTRUSTEE    pOwner = NULL;

                if(FLAG_ON(SecurityInfo,GROUP_SECURITY_INFORMATION))
                {
                    pGroup = &Group;
                    BuildTrusteeWithName(pGroup,
                                         lpGroup);
                }

                if(FLAG_ON(SecurityInfo,OWNER_SECURITY_INFORMATION))
                {
                    pOwner = &Owner;
                    BuildTrusteeWithName(pOwner,
                                         lpOwner);
                }

                //
                // Set up the overlapped structure
                //
                memset(pActiveOverlapped, 0, sizeof(ACTRL_OVERLAPPED));
                pActiveOverlapped->Provider = pProvider;
                pActiveOverlapped->hEvent = CreateEvent(NULL,
                                                        TRUE,
                                                        FALSE,
                                                        NULL);
                if(pActiveOverlapped->hEvent == NULL)
                {
                    dwErr = GetLastError();
                }
                else
                {
                    //
                    // Make the call
                    //
                    __try
                    {
                        dwErr = (*(pProvider->pfhSetAccess))(
                                                        hObject,
                                                        ObjectType,
                                                        SecurityInfo,
                                                        pAccessList,
                                                        pAuditList,
                                                        pOwner,
                                                        pGroup,
                                                        pActiveOverlapped);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        if(pProvider->pfhSetAccess == NULL)
                        {
                            dwErr = ERROR_BAD_PROVIDER;
                        }
                        else
                        {
                            dwErr = RtlNtStatusToDosError(GetExceptionCode());
                        }
                    }

                    if(dwErr != ERROR_SUCCESS)
                    {
                        CloseHandle(pActiveOverlapped->hEvent);
                    }

                }

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // See if we're supposed to do this synchronously
                    //
                    if(pActiveOverlapped != pOverlapped)
                    {
                        DWORD   dwRet;
                        dwErr  = GetOverlappedAccessResults(
                                                        pActiveOverlapped,
                                                        TRUE,
                                                        &dwRet,
                                                        NULL);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            dwErr = dwRet;
                        }
                    }
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetNamedSecurityInfoExA
//
//  Synopsis:   Same as above, but an ANSI version
//
//  Arguments:  [IN  hObject]       --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  SecurityInfo]  --  What is to be set
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pAccessList]   --  OPTIONAL  The access list to set
//              [OUT pAuditList]    --  OPTIONAL  The audit list to set
//              [OUT lppOwner]      --  OPTIONAL  The owner to set
//              [OUT lppGroup]      --  OPTIONAL  The group name to set
//              [OUT pOverlapped    --  OPTIONAL  If present, it must point
//                                      to a valid ACTRL_OVERLAPPED structure
//                                      on input that will be filled in by
//                                      the API.  This is an indication that
//                                      the API is to be asynchronous.  If the
//                                      parameter is NULL, than the API will
//                                      be performed synchronously.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_HANDLE    A bad handle was encountered
//
//  Notes:      This is not a simple matter of converting a few strings/etc
//              and calling the Unicode version, since that would involve
//              processing the list twice.  Yuk.  So, we go ahead and do the
//              the conversion and update of our input structures, and make
//              the call ourselves...
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetSecurityInfoExA(IN    HANDLE                 hObject,
                   IN    SE_OBJECT_TYPE         ObjectType,
                   IN    SECURITY_INFORMATION   SecurityInfo,
                   IN    LPCSTR                 lpProvider,
                   IN    PACTRL_ACCESSA         pAccessList,
                   IN    PACTRL_AUDITA          pAuditList,
                   IN    LPSTR                  lpOwner,
                   IN    LPSTR                  lpGroup,
                   OUT   PACTRL_OVERLAPPED      pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(hObject == NULL || hObject == INVALID_HANDLE_VALUE)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else
    {
        //
        // Verify that we have the proper parameters for our SecurityInfo
        //
        if(FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) &&
                                                        lpGroup == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) &&
                                                        lpOwner == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    //
    // If we have valid parameters, go do it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        CSList  ChangedList(CleanupConvertNode);

        PWSTR   pwszProvider = NULL;

        dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                        &pwszProvider);

        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccProvpGetProviderForHandle(hObject,
                                                 ObjectType,
                                                 pwszProvider,
                                                 &gAccProviders,
                                                 &pProvider);
        }

        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_ACCESSW  pAccessW = NULL;
            PACTRL_ACCESSW  pAuditW  = NULL;

            //
            // Change our access lists if necessary.  This means that
            // we'll go through and change any SIDS to names, and all
            // ansi strings to unicode strings.  This works exactly as
            // described in SetNamedSecurityInfoExW, with the exception
            // that we don't deal exclusively with trustee names, but
            // also property names and inherit object names
            //
            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListAToNamedBasedW(pAccessList,
                                                   ChangedList,
                                                   (BOOL)FLAG_ON(
                                                     pProvider->fProviderCaps,
                                                     ACTRL_CAP_KNOWS_SIDS),
                                                   &pAccessW);
            }

            if(dwErr == ERROR_SUCCESS &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = ConvertAListAToNamedBasedW(pAuditList,
                                                   ChangedList,
                                                   (BOOL)FLAG_ON(
                                                     pProvider->fProviderCaps,
                                                     ACTRL_CAP_KNOWS_SIDS),
                                                   &pAuditW);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Check for the caller wanting a synchronous call...
                //
                ACTRL_OVERLAPPED    LocalOverlapped;
                PACTRL_OVERLAPPED   pActiveOverlapped = pOverlapped;

                if(pActiveOverlapped == NULL)
                {
                    pActiveOverlapped = &LocalOverlapped;
                }

                TRUSTEE_W   Group = {0};
                TRUSTEE_W   Owner = {0};
                PTRUSTEE    pGroup = NULL;
                PTRUSTEE    pOwner = NULL;

                if(FLAG_ON(SecurityInfo,GROUP_SECURITY_INFORMATION))
                {
                    pGroup = &Group;
                    PWSTR   pwszGroup = NULL;
                    dwErr = ConvertStringAToStringW(lpGroup,
                                                    &pwszGroup);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        BuildTrusteeWithName(pGroup,
                                             pwszGroup);
                    }
                }

                if(dwErr == ERROR_SUCCESS &&
                   FLAG_ON(SecurityInfo,OWNER_SECURITY_INFORMATION))
                {
                    pOwner = &Owner;
                    PWSTR   pwszOwner = NULL;
                    dwErr = ConvertStringAToStringW(lpOwner,
                                                    &pwszOwner);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        BuildTrusteeWithName(pOwner,
                                             pwszOwner);
                    }
                }

                //
                // Make the call
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Set up the overlapped structure
                    //
                    memset(pActiveOverlapped, 0, sizeof(ACTRL_OVERLAPPED));
                    pActiveOverlapped->Provider = pProvider;
                    pActiveOverlapped->hEvent = CreateEvent(NULL,
                                                            TRUE,
                                                            FALSE,
                                                            NULL);
                    if(pActiveOverlapped->hEvent == NULL)
                    {
                        dwErr = GetLastError();
                    }
                    else
                    {
                        //
                        // Make the call
                        //
                        __try
                        {
                            dwErr = (*(pProvider->pfhSetAccess))(
                                                           hObject,
                                                           ObjectType,
                                                           SecurityInfo,
                                                           pAccessW,
                                                           pAuditW,
                                                           pOwner,
                                                           pGroup,
                                                           pActiveOverlapped);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            if(pProvider->pfhSetAccess == NULL)
                            {
                                dwErr = ERROR_BAD_PROVIDER;
                            }
                            else
                            {
                                dwErr = RtlNtStatusToDosError(GetExceptionCode());
                            }
                        }

                        if(dwErr != ERROR_SUCCESS)
                        {
                            CloseHandle(pActiveOverlapped->hEvent);
                        }

                    }


                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // See if we're supposed to do this synchronously
                        //
                        if(pActiveOverlapped != pOverlapped)
                        {
                            DWORD   dwRet;
                            dwErr  = GetOverlappedAccessResults(
                                                        pActiveOverlapped,
                                                        TRUE,
                                                        &dwRet,
                                                        NULL);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = dwRet;
                            }
                        }
                    }
                }

                //
                // Free our allocated memory
                //
                if(pOwner != NULL)
                {
                    LocalFree(pOwner->ptstrName);
                }

                if(pGroup != NULL)
                {
                    LocalFree(pGroup->ptstrName);
                }
            }
        }

        //
        // Free our allocated strings...
        //
        LocalFree(pwszProvider);
    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessToSecurityDescriptorW
//
//  Synopsis:   Creates a security descriptor out of the various access
//              entries
//
//  Arguments:  [IN  pAccessList]   --  OPTIONAL.  Access list
//              [IN  pAuditList]    --  OPTIONAL.  Audit list
//              [IN  lpOwner]       --  OPTIONAL.  Owner
//              [IN  lpGroup]       --  OPTIONAL.  Group
//              [OUT ppSecDescriptor]   Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertAccessToSecurityDescriptorW(IN  PACTRL_ACCESSW        pAccessList,
                                   IN  PACTRL_AUDITW         pAuditList,
                                   IN  LPCWSTR               lpOwner,
                                   IN  LPCWSTR               lpGroup,
                                   OUT PSECURITY_DESCRIPTOR *ppSecDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  At least one has to be present
    //
    if(pAccessList == NULL && pAuditList == NULL && lpOwner == NULL &&
                                                              lpGroup == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        dwErr = (*gNtMartaInfo.pfAToSD)(pAccessList,
                                        pAuditList,
                                        lpOwner,
                                        lpGroup,
                                        ppSecDescriptor);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessToSecurityDescriptorA
//
//  Synopsis:   Same as above, except ANSI version
//
//  Arguments:  [IN  pAccessList]   --  OPTIONAL.  Access list
//              [IN  pAuditList]    --  OPTIONAL.  Audit list
//              [IN  lpOwner]       --  OPTIONAL.  Owner
//              [IN  lpGroup]       --  OPTIONAL.  Group
//              [OUT ppSecDescriptor]   Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertAccessToSecurityDescriptorA(IN  PACTRL_ACCESSA        pAccessList,
                                   IN  PACTRL_AUDITA         pAuditList,
                                   IN  LPCSTR                lpOwner,
                                   IN  LPCSTR                lpGroup,
                                   OUT PSECURITY_DESCRIPTOR *ppSecDescriptor)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  At least one has to be present
    //
    if(pAccessList == NULL && pAuditList == NULL && lpOwner == NULL &&
                                                              lpGroup == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        CSList          ChangedList(CleanupConvertNode);

        PWSTR           pwszGroup = NULL;
        PWSTR           pwszOwner = NULL;
        PACTRL_ACCESSW  pNewAccess = NULL;
        PACTRL_ACCESSW  pNewAudit = NULL;

        dwErr = ConvertStringAToStringW((PSTR)lpGroup,
                                        &pwszGroup);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpOwner,
                                            &pwszOwner);
        }

        if(dwErr == ERROR_SUCCESS && pAccessList != NULL)
        {
            //
            // First, convert it to UNICODE
            //
            dwErr = ConvertAListAToNamedBasedW(pAccessList,
                                               ChangedList,
                                               FALSE,
                                               &pNewAccess);
        }

        if(dwErr == ERROR_SUCCESS && pAuditList != NULL)
        {
            PACTRL_ACCESSW  pNewList;
            dwErr = ConvertAListAToNamedBasedW(pAuditList,
                                               ChangedList,
                                               FALSE,
                                               &pNewAudit);
        }

        //
        // Now, build the Security Descriptor
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = (*gNtMartaInfo.pfAToSD)(pNewAccess,
                                            pNewAudit,
                                            pwszOwner,
                                            pwszGroup,
                                            ppSecDescriptor);
        }

        //
        // Free our allocations
        //
        LocalFree(pwszGroup);
        LocalFree(pwszOwner);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSDToAccessW
//
//  Synopsis:   Converts a security descriptor to the access entries
//
//  Arguments:  [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSDToAccessW(IN  SE_OBJECT_TYPE       ObjectType,
                   IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                   OUT PACTRL_ACCESSW      *ppAccessList,
                   OUT PACTRL_AUDITW       *ppAuditList,
                   OUT LPWSTR              *lppOwner,
                   OUT LPWSTR              *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // Make sure we have valid parameters
    //
    if(pSecDescriptor == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Make sure we have something to do
        //
        SECURITY_INFORMATION    SeInfo = 0;

        if(ppAccessList != NULL)
        {
            SeInfo |= DACL_SECURITY_INFORMATION;
        }

        if(ppAuditList != NULL)
        {
            SeInfo |= SACL_SECURITY_INFORMATION;
        }

        if(lppOwner != NULL)
        {
            SeInfo |= OWNER_SECURITY_INFORMATION;
        }

        if(lppGroup != NULL)
        {
            SeInfo |= GROUP_SECURITY_INFORMATION;
        }

        if(SeInfo != 0)
        {
            dwErr = (*gNtMartaInfo.pfSDToA)(ObjectType,
                                            pSecDescriptor,
                                            ppAccessList,
                                            ppAuditList,
                                            lppOwner,
                                            lppGroup);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSDToAccessA
//
//  Synopsis:   Same as above, but ANSI
//
//  Arguments:  [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSDToAccessA(IN  SE_OBJECT_TYPE       ObjectType,
                   IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                   OUT PACTRL_ACCESSA      *ppAccessList,
                   OUT PACTRL_AUDITA       *ppAuditList,
                   OUT LPSTR               *lppOwner,
                   OUT LPSTR               *lppGroup)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // Make sure we have valid parameters
    //
    if(pSecDescriptor == NULL || ObjectType == SE_UNKNOWN_OBJECT_TYPE)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Make sure we have something to do
        //
        SECURITY_INFORMATION    SeInfo = 0;

        if(ppAccessList != NULL)
        {
            SeInfo |= DACL_SECURITY_INFORMATION;
        }

        if(ppAuditList != NULL)
        {
            SeInfo |= SACL_SECURITY_INFORMATION;
        }

        if(lppOwner != NULL)
        {
            SeInfo |= OWNER_SECURITY_INFORMATION;
            *lppOwner = NULL;
        }

        if(lppGroup != NULL)
        {
            *lppGroup = NULL;
            SeInfo |= GROUP_SECURITY_INFORMATION;
        }

        if(SeInfo != 0)
        {
            PACTRL_ACCESSW  pAccessW = NULL, pAuditW = NULL;
            PWSTR           pwszOwner = NULL, pwszGroup = NULL;

            dwErr = ConvertSDToAccessW(ObjectType,
                                       pSecDescriptor,
                                       ppAccessList == NULL ?
                                                        NULL    :
                                                        &pAccessW,
                                       ppAuditList == NULL ?
                                                        NULL    :
                                                        &pAuditW,
                                       lppOwner == NULL ?
                                                        NULL    :
                                                        &pwszOwner,
                                       lppGroup == NULL ?
                                                        NULL    :
                                                        &pwszGroup);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Convert them to ANSI
                //
                if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                {
                    dwErr = ConvertAListWToAlistAInplace(pAccessW);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        *ppAccessList = (PACTRL_ACCESSA)pAccessW;
                    }
                }

                if(dwErr == ERROR_SUCCESS &&
                   FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                {
                    dwErr = ConvertAListWToAlistAInplace(pAuditW);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        *ppAuditList = (PACTRL_ACCESSA)pAuditW;
                    }
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Save off the strings
                    //
                    if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
                    {
                        dwErr = ConvertStringWToStringA(pwszOwner,
                                                        lppOwner);
                    }

                    if(dwErr == ERROR_SUCCESS &&
                       FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                    {
                        dwErr = ConvertStringWToStringA(pwszGroup,
                                                        lppGroup);
                    }
                }

                if(dwErr != ERROR_SUCCESS)
                {
                    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                    {
                        LocalFree(ppAccessList);
                    }

                    if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                    {
                        LocalFree(ppAuditList);
                    }

                    if(FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
                    {
                        LocalFree(lppOwner);
                    }

                    if(dwErr == ERROR_SUCCESS &&
                       FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                    {
                        LocalFree(lppGroup);
                    }
                }

                //
                // Free our earlier allocated memory
                //
                LocalFree(pwszOwner);
                LocalFree(pwszGroup);
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSecurityDescriptorToAccessW
//
//  Synopsis:   Converts a security descriptor to the access entries
//
//  Arguments:  [IN  hObject]       --  Handle to the open object
//              [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSecurityDescriptorToAccessW(IN  HANDLE               hObject,
                                   IN  SE_OBJECT_TYPE       ObjectType,
                                   IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                                   OUT PACTRL_ACCESSW      *ppAccessList,
                                   OUT PACTRL_AUDITW       *ppAuditList,
                                   OUT LPWSTR             *lppOwner,
                                   OUT LPWSTR             *lppGroup)
{
    return(ConvertSDToAccessW(ObjectType,
                              pSecDescriptor,
                              ppAccessList,
                              ppAuditList,
                              lppOwner,
                              lppGroup));
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSecurityDescriptorToAccessA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  hObject]       --  Handle to the open object
//              [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSecurityDescriptorToAccessA(IN  HANDLE               hObject,
                                   IN  SE_OBJECT_TYPE       ObjectType,
                                   IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                                   OUT PACTRL_ACCESSA      *ppAccessList,
                                   OUT PACTRL_AUDITA       *ppAuditList,
                                   OUT LPSTR               *lppOwner,
                                   OUT LPSTR               *lppGroup)
{
    return(ConvertSDToAccessA(ObjectType,
                              pSecDescriptor,
                              ppAccessList,
                              ppAuditList,
                              lppOwner,
                              lppGroup));
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSecurityDescriptorToAccessNamedW
//
//  Synopsis:   Converts a security descriptor to the access entries
//
//  Arguments:  [IN  lpObject]      --  Path to the object
//              [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSecurityDescriptorToAccessNamedW(IN  LPCWSTR             lpObject,
                                        IN  SE_OBJECT_TYPE       ObjectType,
                                        IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                                        OUT PACTRL_ACCESSW      *ppAccessList,
                                        OUT PACTRL_AUDITW       *ppAuditList,
                                        OUT LPWSTR             *lppOwner,
                                        OUT LPWSTR             *lppGroup)
{
    return(ConvertSDToAccessW(ObjectType,
                              pSecDescriptor,
                              ppAccessList,
                              ppAuditList,
                              lppOwner,
                              lppGroup));
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertSecurityDescriptorToAccessNamedW
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  lpObject]      --  Path to the object
//              [IN  ObjectType]    --  Type of the object
//              [IN  ppSecDescriptor]   Security descriptor to return
//              [OUT pAccessList]   --  OPTIONAL.  Access list returned here
//              [OUT pAuditList]    --  OPTIONAL.  Audit list returned here
//              [OUT lpOwner]       --  OPTIONAL.  Owner returned here
//              [OUT lpGroup]       --  OPTIONAL.  Group returned here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
ConvertSecurityDescriptorToAccessNamedA(IN  LPCSTR               lpObject,
                                        IN  SE_OBJECT_TYPE       ObjectType,
                                        IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                                        OUT PACTRL_ACCESSA      *ppAccessList,
                                        OUT PACTRL_AUDITA       *ppAuditList,
                                        OUT LPSTR               *lppOwner,
                                        OUT LPSTR               *lppGroup)
{
    return(ConvertSDToAccessA(ObjectType,
                              pSecDescriptor,
                              ppAccessList,
                              ppAuditList,
                              lppOwner,
                              lppGroup));
}




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAListW
//
//  Synopsis:   Sets/Merges the given entries with the existing ones, and
//              then remarshals the results
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  SeInfo]        --  Type of list we're dealing with
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAListW(IN  ULONG                 cEntries,
                   IN  PACTRL_ACCESS_ENTRYW  pAccessEntryList,
                   IN  ACCESS_MODE           AccessMode,
                   IN  SECURITY_INFORMATION  SeInfo,
                   IN  LPCWSTR               lpProperty,
                   IN  PACTRL_AUDITW         pOldList,
                   OUT PACTRL_AUDITW        *ppNewList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, a little parameter validation...
    //
    if((cEntries != 0 && pAccessEntryList == NULL) || ppNewList == NULL ||
       (AccessMode == DENY_ACCESS) ||
       (SeInfo != SACL_SECURITY_INFORMATION &&
                                         SeInfo != DACL_SECURITY_INFORMATION))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        dwErr = (*gNtMartaInfo.pfSetAList)(cEntries,
                                           pAccessEntryList,
                                           AccessMode,
                                           SeInfo,
                                           lpProperty,
                                           FALSE,
                                           pOldList,
                                           ppNewList);
    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAListA
//
//  Synopsis:   Same as above, but ANSI
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  SeInfo]        --  Type of list we're dealing with
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAListA(IN  ULONG                 cEntries,
                   IN  PACTRL_ACCESS_ENTRYA  pAccessEntryList,
                   IN  ACCESS_MODE           AccessMode,
                   IN  SECURITY_INFORMATION  SeInfo,
                   IN  LPCSTR                lpProperty,
                   IN  PACTRL_AUDITA         pOldList,
                   OUT PACTRL_AUDITA        *ppNewList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, a little parameter validation...
    //
    if((cEntries != 0 && pAccessEntryList == NULL) || ppNewList == NULL ||
       (AccessMode == DENY_ACCESS) ||
       (SeInfo != SACL_SECURITY_INFORMATION &&
                                         SeInfo != DACL_SECURITY_INFORMATION))

    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // We need to build a ACTRL_ALIST
        //
        ACTRL_ACCESSA               AList;
        ACTRL_PROPERTY_ENTRYA       APE;
        ACTRL_ACCESS_ENTRY_LISTA    AAEL;

        AAEL.cEntries    = cEntries;
        AAEL.pAccessList = pAccessEntryList;

        APE.lpProperty       = (PSTR)lpProperty;
        APE.pAccessEntryList = &(AAEL);

        AList.cEntries            = 1;
        AList.pPropertyAccessList = &APE;

        //
        // Now, convert them to UNICODE
        //
        PWSTR           pwszProperty;
        PACTRL_ACCESSW  pOldW = NULL, pNewW = NULL, pTemp = NULL;
        CSList          ChangedList(CleanupConvertNode);

        //
        // Convert them all the unicode
        //
        if(pOldList != NULL)
        {
            dwErr = ConvertAListAToNamedBasedW(pOldList,
                                               ChangedList,
                                               FALSE,
                                               &pOldW);

        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertAListAToNamedBasedW(&AList,
                                               ChangedList,
                                               FALSE,
                                               &pTemp);
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpProperty,
                                            &pwszProperty);
        }

        //
        // Now, we'll start adding them
        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_AUDITW   pAuditW;
            dwErr = (*gNtMartaInfo.pfSetAList)(cEntries,
                                               (PACTRL_ACCESS_ENTRYW)
                                                             pAccessEntryList,
                                               AccessMode,
                                               SeInfo,
                                               pwszProperty,
                                               FALSE,
                                               pOldW,
                                               &pAuditW);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = ConvertAListWToAlistAInplace(pAuditW);
                if(dwErr == ERROR_SUCCESS)
                {
                    *ppNewList = (PACTRL_AUDITA)pAuditW;
                }
                else
                {
                    LocalFree(pAuditW);
                }
            }

            LocalFree(pwszProperty);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAccessListW
//
//  Synopsis:   Sets/Merges the given entries with the existing ones, and
//              then remarshals the results
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAccessListW(IN  ULONG                cEntries,
                        IN  PACTRL_ACCESS_ENTRYW pAccessEntryList,
                        IN  ACCESS_MODE          AccessMode,
                        IN  LPCWSTR              lpProperty,
                        IN  PACTRL_ACCESSW       pOldList,
                        OUT PACTRL_ACCESSW      *ppNewList)
{
    SECURITY_INFORMATION SeInfo;

    switch(AccessMode)
    {
    case SET_AUDIT_SUCCESS:
    case SET_AUDIT_FAILURE:
        SeInfo = SACL_SECURITY_INFORMATION;
        break;

    default:
        SeInfo = DACL_SECURITY_INFORMATION;
        break;
    }

    return(SetEntriesInAListW(cEntries,
                              pAccessEntryList,
                              AccessMode,
                              SeInfo,
                              lpProperty,
                              pOldList,
                              ppNewList));
}




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAccessListA
//
//  Synopsis:   Same as above, except ANSI
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAccessListA(IN  ULONG                cEntries,
                        IN  PACTRL_ACCESS_ENTRYA pAccessEntryList,
                        IN  ACCESS_MODE          AccessMode,
                        IN  LPCSTR               lpProperty,
                        IN  PACTRL_ACCESSA       pOldList,
                        OUT PACTRL_ACCESSA      *ppNewList)
{
    SECURITY_INFORMATION SeInfo;

    switch(AccessMode)
    {
    case SET_AUDIT_SUCCESS:
    case SET_AUDIT_FAILURE:
        SeInfo = SACL_SECURITY_INFORMATION;
        break;

    default:
        SeInfo = DACL_SECURITY_INFORMATION;
        break;
    }

    return(SetEntriesInAListA(cEntries,
                              pAccessEntryList,
                              AccessMode,
                              SeInfo,
                              lpProperty,
                              pOldList,
                              ppNewList));
}




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAuditListW
//
//  Synopsis:   Sets/Merges the given entries with the existing ones, and
//              then remarshals the results
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAuditListW(IN  ULONG                 cEntries,
                       IN  PACTRL_ACCESS_ENTRYW  pAccessEntryList,
                       IN  ACCESS_MODE           AccessMode,
                       IN  LPCWSTR               lpProperty,
                       IN  PACTRL_AUDITW         pOldList,
                       OUT PACTRL_AUDITW        *ppNewList)
{
    return(SetEntriesInAListW(cEntries,
                              pAccessEntryList,
                              AccessMode,
                              SACL_SECURITY_INFORMATION,
                              lpProperty,
                              pOldList,
                              ppNewList));
}




//+---------------------------------------------------------------------------
//
//  Function:   SetEntriesInAuditListA
//
//  Synopsis:   Same as above, but ANSI
//
//  Arguments:  [IN  cEntries]      --  Number of items in the list
//              [IN  pAccessEntryList]  Entries to set/merge
//              [IN  AccessMode]    --  Whether to do a set or a merge
//              [IN  lpProperty]    --  OPTIONAL Property on which to operate
//              [IN  pOldList]      --  The existing audit list
//              [OUT ppNewList]     --  Where the new list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SetEntriesInAuditListA(IN  ULONG                 cEntries,
                       IN  PACTRL_ACCESS_ENTRYA  pAccessEntryList,
                       IN  ACCESS_MODE           AccessMode,
                       IN  LPCSTR                lpProperty,
                       IN  PACTRL_AUDITA         pOldList,
                       OUT PACTRL_AUDITA        *ppNewList)
{
    return(SetEntriesInAListA(cEntries,
                              pAccessEntryList,
                              AccessMode,
                              SACL_SECURITY_INFORMATION,
                              lpProperty,
                              pOldList,
                              ppNewList));
}




//+---------------------------------------------------------------------------
//
//  Function:   TrusteeAccessToObjectW
//
//  Synopsis:   Determines the access the trustee has to the specified
//              object
//
//  Arguments:  [IN  lpObject]      --  The object to get the access for
//              [IN  ObjectType]    --  The type of the object
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  pTrustee]      --  The trustee for which to do the
//                                      inquiry
//              [IN  cEntries]      --  Number of TRUSTEE_ACCESS entries in
//                                      the list
//              [IN  pTrusteeAccess]--  The list of trustee access structures
//                                      to process and update
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given or the
//                                      fields in the overlapped structure
//                                      were wrong
//
//----------------------------------------------------------------------------
DWORD
WINAPI
TrusteeAccessToObjectW(IN        LPCWSTR            lpObject,
                       IN        SE_OBJECT_TYPE     ObjectType,
                       IN        LPCWSTR            lpProvider,
                       IN        PTRUSTEE_W         pTrustee,
                       IN        ULONG              cEntries,
                       IN OUT    PTRUSTEE_ACCESSW   pTrusteeAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL || pTrustee == NULL || pTrusteeAccess == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;
        dwErr = AccProvpGetProviderForPath(lpObject,
                                           ObjectType,
                                           lpProvider,
                                           &gAccProviders,
                                           &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            __try
            {
                //
                // Make the calls
                //
                for(ULONG iIndex = 0;
                    iIndex < cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    dwErr = (*(pProvider->pfTrusteeAccess))(
                                                  lpObject,
                                                  ObjectType,
                                                  pTrustee,
                                                  &(pTrusteeAccess[iIndex]));
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                if(pProvider->pfTrusteeAccess == NULL)
                {
                    dwErr = ERROR_BAD_PROVIDER;
                }
                else
                {
                    dwErr = RtlNtStatusToDosError(GetExceptionCode());
                }
            }

        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   TrusteeAccessToObjectA
//
//  Synopsis:   Same as above, but the ANSI version
//
//  Arguments:  [IN  lpObject]      --  The object to get the access for
//              [IN  ObjectType]    --  The type of the object
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [IN  pTrustee]      --  The trustee for which to do the
//                                      inquiry
//              [IN  cEntries]      --  Number of TRUSTEE_ACCESS entries in
//                                      the list
//              [IN  pTrusteeAccess]--  The list of trustee access structures
//                                      to process and update
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given or the
//                                      fields in the overlapped structure
//                                      were wrong
//
//----------------------------------------------------------------------------
DWORD
WINAPI
TrusteeAccessToObjectA(IN        LPCSTR             lpObject,
                       IN        SE_OBJECT_TYPE     ObjectType,
                       IN        LPCSTR             lpProvider,
                       IN        PTRUSTEE_A         pTrustee,
                       IN        ULONG              cEntries,
                       IN OUT    PTRUSTEE_ACCESSA   pTrusteeAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL || pTrustee == NULL || pTrusteeAccess == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PWSTR   pwszObject;
        PWSTR   pwszProvider = NULL;

        dwErr = ConvertStringAToStringW((PSTR)lpObject,
                                        &pwszObject);
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                            &pwszProvider);
        }

        //
        // Find the provider
        //
        BOOL    fSidToName = TRUE;
        PACCPROV_PROV_INFO pProvider;
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccProvpGetProviderForPath(pwszObject,
                                               ObjectType,
                                               pwszProvider,
                                               &gAccProviders,
                                               &pProvider);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // See if this provider can understand sids
                //
                if(FLAG_ON(pProvider->fProviderCaps,ACTRL_CAP_KNOWS_SIDS))
                {
                    fSidToName = FALSE;
                }
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Do the conversions...
            //
            TRUSTEE_W   TrusteeW;
            dwErr = ConvertTrusteeAToTrusteeW(pTrustee,
                                              &TrusteeW,
                                              fSidToName);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Make the calls
                //
                for(ULONG iIndex = 0;
                    iIndex < cEntries && dwErr == ERROR_SUCCESS;
                    iIndex++)
                {
                    PWSTR   pwszProp;

                    dwErr = ConvertStringAToStringW(
                                            pTrusteeAccess[iIndex].lpProperty,
                                            &pwszProp);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        TRUSTEE_ACCESSW TrusteeAccessW;

                        memcpy(&TrusteeAccessW,
                               &(pTrusteeAccess[iIndex]),
                               sizeof(TRUSTEE_ACCESSA));
                        TrusteeAccessW.lpProperty = pwszProp;

                        __try
                        {
                            dwErr = (*(pProvider->pfTrusteeAccess))(
                                                      pwszObject,
                                                      ObjectType,
                                                      &TrusteeW,
                                                      &(TrusteeAccessW));
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            if(pProvider->pfTrusteeAccess == NULL)
                            {
                                dwErr = ERROR_BAD_PROVIDER;
                            }
                            else
                            {
                                dwErr = RtlNtStatusToDosError(GetExceptionCode());
                            }
                        }

                        //
                        // Copy our bits back
                        //
                        if(dwErr == ERROR_SUCCESS)
                        {
                            pTrusteeAccess[iIndex].fReturnedAccess =
                                               TrusteeAccessW.fReturnedAccess;
                        }

                        LocalFree(pwszProp);
                    }
                }

                if((PSID)TrusteeW.ptstrName != (PSID)pTrustee->ptstrName)
                {
                    LocalFree(TrusteeW.ptstrName);
                }
            }
        }

        LocalFree(pwszProvider);
        LocalFree(pwszObject);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CancelOverlappedAccess
//
//  Synopsis:   Cancels an overlapped access operation that is already
//              in progress
//
//  Arguments:  [IN  pOverlapped]   --  Information about the operation to
//                                      be canceled
//              [IN  fWaitForCompletion]    If TRUE, the API will wait for
//                                      the operation to complete
//              [OUT pResult]       --  Where the operation results are
//                                      returned
//              [OUT pcItemsProcessed]  OPTIONAL.  If present, the current
//                                      count of processed items is returned
//                                      here
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given or the
//                                      fields in the overlapped structure
//                                      were wrong
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetOverlappedAccessResults(IN  PACTRL_OVERLAPPED   pOverlapped,
                           IN  BOOL                fWaitForCompletion,
                           OUT PDWORD              pResult,
                           OUT PDWORD              pcItemsProcessed OPTIONAL)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);


    if(pOverlapped == NULL || pResult == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // See if we've already called the provider for this operation
        //
        if(pOverlapped->hEvent == NULL)
        {
            *pResult = pOverlapped->Reserved2;
            if(pcItemsProcessed != NULL)
            {
                *pcItemsProcessed = pOverlapped->Reserved1;
            }
        }
        else
        {
            if(fWaitForCompletion == TRUE)
            {
                if(WaitForSingleObject(pOverlapped->hEvent, INFINITE) ==
                                                                WAIT_FAILED)
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Call the underlying provider...  Note that the Provider
                // parameter must be initialized to reference our provider
                //
                PACCPROV_PROV_INFO pProvider =
                                   (PACCPROV_PROV_INFO)pOverlapped->Provider;
                if(pProvider == NULL)
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                }
                else
                {
                    //
                    // Make the call
                    //

                    //
                    // Note that it could be a bogus provider ptr
                    //
                    __try
                    {
                        do
                        {
                            dwErr = (*(pProvider->pfResults))
                                                       (pOverlapped,
                                                        pResult,
                                                        pcItemsProcessed);

                        } while(dwErr == ERROR_IO_PENDING);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        if(pProvider->pfResults == NULL)
                        {
                            dwErr = ERROR_BAD_PROVIDER;
                        }
                        else
                        {
                            dwErr = RtlNtStatusToDosError(GetExceptionCode());
                        }
                    }


                    //
                    // Handle it, if it worked...
                    //
                    CloseHandle(pOverlapped->hEvent);
                    pOverlapped->hEvent = NULL;
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CancelOverlappedAccess
//
//  Synopsis:   Cancels an overlapped access operation that is already
//              in progress
//
//  Arguments:  [IN  pOverlapped]   --  Information about the operation to
//                                      be canceled
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given or the
//                                      fields in the overlapped structure
//                                      were wrong
//
//----------------------------------------------------------------------------
DWORD
WINAPI
CancelOverlappedAccess(IN       PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, check the parameters
    //
    if(pOverlapped == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Call the underlying provider...  Note that the Provider
        // parameter must be initialized to reference our provider
        //
        PACCPROV_PROV_INFO pProvider =
                               (PACCPROV_PROV_INFO)pOverlapped->Provider;
        if(pProvider == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            //
            // Make the call
            //

            //
            // Note that it could be a bogus ptr
            //
            __try
            {
                dwErr = (*(pProvider->pfCancel))(pOverlapped);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                dwErr = ERROR_INVALID_PARAMETER;
            }

            //
            // If we get back an ERROR_INVALID_PARAMETER from the interface,
            // then we know that it didn't find this pending operation, so
            // it either has completed successfully or already been canceled.
            // Either way, not an error
            //
            if(dwErr == ERROR_INVALID_PARAMETER)
            {
                dwErr = ERROR_SUCCESS;
            }
        }
    }

    return(dwErr);
}






//+---------------------------------------------------------------------------
//
//  Function:   GetAccessPermissionsForObjectW
//
//  Synopsis:   Determines what the available and appropriate access
//              permissions that can be set for each object based upon its
//              type.  This is a provider call.
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  lpObjectType]  --  Gets the access rights for the specified
//                                      object type
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pcEntries]     --  Where the count of returned entries
//                                      is returned
//              [OUT ppAccessInfoList]  Where the access info list is
//                                      returned.  This consists of a list of
//                                      AccessBit / AccessName pairs
//              [OUT pcRights]      --  Where the count of access rights are returned
//              [OUT ppRightsList]  --  Where the list of access rights are returned
//              [OUT pfAccessFlags] --  Where the access flags are returned.
//                                      This is information about what type
//                                      of access entries this provider
//                                      supports for this object type
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetAccessPermissionsForObjectW(IN   LPCWSTR              lpObject,
                               IN   SE_OBJECT_TYPE       ObjectType,
                               IN   LPCWSTR              lpObjectType,
                               IN   LPCWSTR              lpProvider,
                               OUT  PULONG               pcEntries,
                               OUT  PACTRL_ACCESS_INFOW *ppAccessInfoList,
                               OUT  PULONG                pcRights,
                               OUT  PACTRL_CONTROL_INFOW *ppRightsList,
                               OUT  PULONG               pfAccessFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;

    LOAD_PROVIDERS(dwErr);

    //
    // First, verify the parameters.  The providers expect valid parameters
    //
    if(lpObject == NULL || pcEntries == NULL || ppAccessInfoList == NULL ||
             pfAccessFlags == NULL || ppRightsList == NULL || pcRights == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Find the provider
        //
        PACCPROV_PROV_INFO pProvider;
        dwErr = AccProvpGetProviderForPath(lpObject,
                                           ObjectType,
                                           lpProvider,
                                           &gAccProviders,
                                           &pProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            __try
            {
                //
                // Make the call
                //
                dwErr = (*(pProvider->pfObjInfo))(lpObject,
                                                  ObjectType,
                                                  lpObjectType,
                                                  pcEntries,
                                                  ppAccessInfoList,
                                                  pcRights,
                                                  ppRightsList,
                                                  pfAccessFlags);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                if(pProvider->pfObjInfo == NULL)
                {
                    dwErr = ERROR_BAD_PROVIDER;
                }
                else
                {
                    dwErr = RtlNtStatusToDosError(GetExceptionCode());
                }
            }
        }
    }

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   GetAccessPermissionsForObjectA
//
//  Synopsis:   Ansi version of the above
//
//  Arguments:  [IN  lpObject]      --  Object for which the permissions are
//                                      needed
//              [IN  ObjectType]    --  Type of object specified by lpObject
//              [IN  lpObjectType]  --  Gets the access rights for the specified
//                                      object type
//              [IN  lpProvider]    --  OPTIONAL If known, the provider to
//                                      handle the request.  If NULL, it will
//                                      be discovered
//              [OUT pcEntries]     --  Where the count of returned entries
//                                      is returned
//              [OUT ppAccessInfoList]  Where the access info list is
//                                      returned.  This consists of a list of
//                                      AccessBit / AccessName pairs
//              [OUT pcRights]      --  Where the count of access rights are returned
//              [OUT ppRightsList]  --  Where the list of access rights are returned
//              [OUT pfAccessFlags] --  Where the access flags are returned.
//                                      This is information about what type
//                                      of access entries this provider
//                                      supports for this object type
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A bad parameter was given
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
WINAPI
GetAccessPermissionsForObjectA(IN   LPCSTR                lpObject,
                               IN   SE_OBJECT_TYPE        ObjectType,
                               IN   LPCSTR                lpObjectType,
                               IN   LPCSTR                lpProvider,
                               OUT  PULONG                pcEntries,
                               OUT  PACTRL_ACCESS_INFOA  *ppAccessInfoList,
                               OUT  PULONG                pcRights,
                               OUT  PACTRL_CONTROL_INFOA *ppRightsList,
                               OUT  PULONG                pfAccessFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Validate that we have valid parameters to return
    //
    if(ppAccessInfoList == NULL || ppRightsList == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // First, convert the input parameters
    //
    PWSTR   pwszObject;
    PWSTR   pwszProvider = NULL;
    PWSTR   pwszObjType = NULL;

    dwErr = ConvertStringAToStringW((PSTR)lpObject,
                                    &pwszObject);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ConvertStringAToStringW((PSTR)lpProvider,
                                        &pwszProvider);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ConvertStringAToStringW((PSTR)lpObjectType,
                                            &pwszObjType);
        }
    }


    //
    // If that worked, make the call
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PACTRL_ACCESS_INFOW pAccessInfoListW;
        PACTRL_CONTROL_INFOW pRightsListW;
        dwErr = GetAccessPermissionsForObjectW((PCWSTR)pwszObject,
                                               ObjectType,
                                               (PCWSTR)pwszObjType,
                                               (PCWSTR)pwszProvider,
                                               pcEntries,
                                               &pAccessInfoListW,
                                               pcRights,
                                               &pRightsListW,
                                               pfAccessFlags);
        //
        // If it worked, convert it back into a ansi blob.  We can cheat here
        // and actually do it in place, since an ansi string will never be any
        // longer than a wide string
        //
        if(dwErr == ERROR_SUCCESS)
        {
            for(ULONG iIndex = 0; iIndex < *pcEntries; iIndex++)
            {
                wcstombs((PSTR)pAccessInfoListW[iIndex].lpAccessPermissionName,
                         pAccessInfoListW[iIndex].lpAccessPermissionName,
                         wcslen(pAccessInfoListW[iIndex].
                                                 lpAccessPermissionName) + 1);
            }

            *ppAccessInfoList = (PACTRL_ACCESS_INFOA)pAccessInfoListW;

            //
            // Do the same thing with the rights lists
            //
            for(iIndex = 0; iIndex < *pcRights; iIndex++)
            {
                wcstombs((PSTR)pRightsListW[iIndex].lpControlId,
                         pRightsListW[iIndex].lpControlId,
                         wcslen(pRightsListW[iIndex].lpControlId) + 1);

                wcstombs((PSTR)pRightsListW[iIndex].lpControlName,
                         pRightsListW[iIndex].lpControlName,
                         wcslen(pRightsListW[iIndex].lpControlName) + 1);
            }

            *ppRightsList = (PACTRL_CONTROL_INFOA)pRightsListW;
        }
    }

    //
    // Free our memory
    //
    LocalFree(pwszObject);
    LocalFree(pwszProvider);
    LocalFree(pwszObjType);

    return(dwErr);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\accctrl2\src\cacl.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:        cacl.cxx
//
//  Contents:    class providing merging of an access list and an ACL
//
//  Classes:     CAclBuilder
//
//  History:     Feb-94        Created         DaveMont
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#define NAME_NOT_FOUND L"Name Not Found"    
//----------------------------------------------------------------------------
//
//  This is rather an odd object.  It's output is either an ACL or a list
//  (array)  of AccessEntries.  As input it takes an (optional) ACL, and
//  (optionally) multiple lists of AccessEntries.  The object maintains the
//  SID, user name, mask, etc. in AccountAccess object.
//
//  The following 3 methods are used to input access information:
//
//      SetAcl           -- can only be called once
//      ClearAll         -- used when a call to replace all access rights is made
//      AddAccessEntries -- adds a list of access entries to the object
//
//  The following method generates an ACL from the information within the object:
//
//      GetAcl           -- allocates and generates a new ACL
//
//  The following method generates a list of access entries from the information
//  within the object.  This list will match an ACL generated by GetAcl
//
//      GetAccessEntries -- allocates and generates a list of AccessEntries
//
//  The following method calculates the effective rights for a trustee based
//  on the access control information within the object (but not on privileges
//  the trustee may have):
//
//      GetEffectiveRights-- returns the effective access rights for trustee
//
//----------------------------------------------------------------------------
//+---------------------------------------------------------------------------
//
//  Member:    ctor, public
//
//  Synopsis:   initializes class member variables
//
//  Arguments: IN - [system] - the machine where the object is
//             IN - [fSaveNamesAndSids] - TRUE if this object is to be transacted
//             IN - [fUsedByProviderIndependentApi] - if TRUE, SYNCHRONIZE and
//                  READ_CONTROL are appended to any allowed masks, thus allowing
//                  PROV_OBJECT_READ, ...WRITE and ...EXECUTE to be non-overlapping.
//
//----------------------------------------------------------------------------
CAcl::CAcl(LPWSTR system,
           IS_CONTAINER fdir,
           BOOL fSaveNamesAndSids,
           BOOL fUsedByProviderIndependentApi)
   :_fused_by_provider_independent_api(fUsedByProviderIndependentApi),
    _aclrevision(ACL_REVISION2),
    _capabilities(0),
    _pcaaacl(NULL),
    _pcaaaes(NULL),
    _pcaaaclindex(0),
    _pcaaaesindex(0),
    _pcacli(NULL),
    _pcaeli(NULL),
    _system(system),
    _fdir(fdir),
    _fsave_names_and_sids(fSaveNamesAndSids)
{
}

//+---------------------------------------------------------------------------
//
//  Member:    dtor, public
//
//  Synopsis:   frees class member variables
//
//----------------------------------------------------------------------------
CAcl::~CAcl()
{
    //
    // have to delete the individual account accesses
    //
    if (_pcaaacl)
    {
        for (ULONG idx = 0; idx < _pcaaaclindex; idx++ )
        {
            delete _pcaaacl[idx];
        }
        AccFree(_pcaaacl);
    }
    if (_pcaaaes)
    {
        for (ULONG idx = 0; idx < _pcaaaesindex; idx++ )
        {
            delete _pcaaaes[idx];
        }
        AccFree(_pcaaaes);
    }
    if (_pcacli)
    {
        delete _pcacli;
    }
    if (_pcaeli)
    {
        delete _pcaeli;
    }
}
//+---------------------------------------------------------------------------
//
//  Member:    new, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void * CAcl::operator new(size_t size)
{
    return(RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (ULONG)size));
}
//+---------------------------------------------------------------------------
//
//  Member:    delete, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void CAcl::operator delete(void *p, size_t size)
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}
//+---------------------------------------------------------------------------
//
//  Member:   SetAcl, public
//
//  Synopsis: Takes an input ACL and converts it into AccountAccess objects.
//
//  Arguments: IN - [pacl] - the acl from the object
//
//----------------------------------------------------------------------------
DWORD CAcl::SetAcl(PACL pacl)
{
    DWORD status;

    //
    // new the iterators if required
    //
    status = _InitIterators();
    if (status != NO_ERROR)
    {
        return(status);
    }
    //
    // initialize the ACL, if it exists
    //
    _pcacli->Init(pacl);

    //
    // allocate space for the ACL's array of account accesses
    // (if there are any ACEs)
    //

    if (_pcacli->NumberEntries() > 0)
    {
        //
        // allocate for the account accesses for the acl
        //
        if ( NULL != (_pcaaacl = (CAccountAccess **)AccAlloc(
                              (_pcacli->NumberEntries() )* sizeof(void *))))
        {
            //
            // initialize the ACLs AccountAccesses (old AAs)
            //

            for (_pcacli->FirstAce(); _pcacli->MoreAces(); _pcacli->NextAce() )
            {
                status = _AddEntry( _pcacli,
                                    &(_pcaaacl[_pcaaaclindex]),
                                    &_pcaaaclindex );
                if (status != NO_ERROR)
                {
                    break;
                }
            }
        } else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
        //
        // all done with the acl iterator now, clear it.
        //
        _pcacli->Init(NULL);
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:   ClearAll, public
//
//  Synopsis: clears the account accesses for the ACL and the access entries
//            (preparatory to doing a replace all API call)
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
DWORD CAcl::ClearAll()
{
    DWORD status;

    //
    // new the iterators if required
    //
    status = _InitIterators();
    if (status != NO_ERROR)
    {
        return(status);
    }
    //
    // clear out the acl, if it exists
    //
    _pcacli->Init(NULL);

    if (_pcaaacl)
    {
        for (ULONG idx = 0; idx < _pcaaaclindex; idx++ )
        {
            delete _pcaaacl[idx];
        }
        AccFree(_pcaaacl);
        _pcaaacl = NULL;
        _pcaaaclindex = 0;
    }
    status = ClearAccessEntries();

    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:   ClearAccessEntries, public
//
//  Synopsis: clears the access entries AccountAccess objects. (revert)
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
DWORD CAcl::ClearAccessEntries()
{
    if (_pcaaaes)
    {
        for (ULONG idx = 0; idx < _pcaaaesindex; idx++ )
        {
            delete _pcaaaes[idx];
        }
        AccFree(_pcaaaes);
        _pcaaaes = NULL;
        _pcaaaesindex = 0;
    }
    return(NO_ERROR);
}
//+---------------------------------------------------------------------------
//
//  Member:   AddAccessEntries, public
//
//  Synopsis: converts the access entries and ACL into AccountAccess objects,
//
//  Arguments: IN - [ccount] - the number of access entries
//             IN - [pae] - the array of access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::AddAccessEntries( ULONG ccount,
                              PACCESS_ENTRY pae)
{

    DWORD status = NO_ERROR;

    //
    // new the iterators if required
    //
    status = _InitIterators();
    if (status != NO_ERROR)
    {
        return(status);
    }
    //
    // initialize the iterator thru the access entries
    //
    _pcaeli->Init(ccount, pae);

    //
    // do something if there are any access entries
    //
    if (_pcaeli->NumberEntries() > 0)
    {
        //
        // if we have already processed some access entries into
        // AccountAccesses, then we need to make room for more
        // ie. do a re-alloc
        //
        if (_pcaaaes != NULL)
        {
            CAccountAccess **pcaaaestmp;

            if (NULL != (pcaaaestmp = (CAccountAccess **)AccAlloc(
                              (_pcaaaesindex +
                               _pcaeli->NumberEntries() )* sizeof(void *)) ))
            {
                //
                // after allocating enough space for the old and new access
                // entries, move the old AccountAccesses into the new space,
                //
                for (ULONG aeindex = 0; aeindex < _pcaaaesindex; aeindex++)
                {
                    status = _pcaaaes[aeindex]->Clone(&(pcaaaestmp[aeindex]));
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }
                //
                // free the old list and its contents (AccountAccesses)
                //
                if (status == NO_ERROR)
                {
                    for (ULONG idx = 0; idx < _pcaaaesindex; idx++ )
                    {
                       delete _pcaaaes[idx];
                    }
                    AccFree(_pcaaaes);
                    _pcaaaes = pcaaaestmp;
                } else
                //
                // if something failed, free the new list and what ever contents
                // got initialized
                //
                {
                    for (ULONG idx = 0; idx < aeindex; idx++ )
                    {
                       delete pcaaaestmp[idx];
                    }
                    AccFree(pcaaaestmp);
                }
            }else
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        } else
        {
            //
            // allocate memory for the account accesses for the access entries
            //
            if (NULL == (_pcaaaes = (CAccountAccess **)AccAlloc(
                              (_pcaeli->NumberEntries() )* sizeof(void *)) ))
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }

        }
        if (status == NO_ERROR)
        {
            //
            // save the number of old AccountAccesses so any that are for the
            // same trustee as a new access entry can be overridden (marked
            // unused).
            //
            ULONG countold = _pcaaaesindex;
            //
            // create AccountAccesses for the new access entries
            //
            for (_pcaeli->FirstAe(); _pcaeli->MoreAes(); _pcaeli->NextAe() )
            {
                status = _AddEntry( _pcaeli,
                                    &(_pcaaaes[_pcaaaesindex]),
                                    &_pcaaaesindex );
                if (status != NO_ERROR)
                {
                    break;
                }
            }
        }
    } else
    {
        status = ERROR_INVALID_PARAMETER;
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     BuildAcl, public
//
//  Synopsis:   converts AccountAccess objects into ACEs and builds an ACL
//              this is a two pass operation, the first pass calculates
//              the size required for the ACL, and resolves any conficts
//              between the ACL and access entries.  The second pass
//              builds the ACL.
//
//  Arguments:  OUT - [pacl]  - the returned, built acl
//
//----------------------------------------------------------------------------
DWORD CAcl::BuildAcl(PACL *pacl)
{
    DWORD status = NO_ERROR;
    NTSTATUS ntstatus;
    ULONG cacl_size, cace_count;
    ULONG aceindex = 0;
    ULONG newidx, oldidx;

    //
    // pass1 calculates the size and number of entries for an ACL or list of
    // access entries based on the current contents of this class
    //
    status = _Pass1(&cacl_size, &cace_count, TRUE); // TRUE = build ACL

    //
    // now for pass2, building the ACL.  The first thing to do is to
    // allocate space for the ACL, then add any access entries denies
    // then add any ACL denies, then add any access entries allows,
    // then add any ACL allows.  If any ACL denies are found after the
    // first ACL allow, an error is returned.  In this case the caller must
    // use a replace all option to clear out the old ACL.
    //
    if (status == NO_ERROR)
    {
        *pacl = (PACL)AccAlloc( cacl_size);
        if (*pacl == NULL)
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (status == NO_ERROR)
    {
        ntstatus = RtlCreateAcl( *pacl,
                                 cacl_size,
                                 ACL_REVISION2 );
        if (!NT_SUCCESS(ntstatus))
        {
            status = RtlNtStatusToDosError(ntstatus);
        }
    }

    if (status == NO_ERROR)
    {
        //
        // Add any access entries denies
        //
        for (ULONG newidx = 0; newidx < _pcaaaesindex ; newidx++ )
        {
            if (_pcaaaes[newidx]->AccessMode() == DENY_ACCESS)
            {
                if (_pcaaaes[newidx]->MultipleTrusteeOperation() ==
                              TRUSTEE_IS_IMPERSONATE)
                {
                    status = ERROR_INVALID_PARAMETER;
                    break;
                }
                if (!NT_SUCCESS(ntstatus = RtlAddAccessDeniedAce(*pacl,
                                           ACL_REVISION2,
                                          _pcaaaes[newidx]->AccessMask(),
                                          _pcaaaes[newidx]->Sid())))
                {
                    status = RtlNtStatusToDosError(ntstatus);
                    break;
                }
                else
                {
                    //
                    // set the inheritance
                    //
                    status = _SetAceFlags( aceindex,
                                           *pacl,
                                           _pcaaaes[newidx] );
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }
                //
                // increment the count of added aces (so can set any
                // inheritance)
                //
                aceindex++;
            }
        }
    }

    if (status == NO_ERROR)
    {
        //
        // loop thru the ACL AccountAccesses until the first allow
        //
        for (oldidx = 0; oldidx < _pcaaaclindex ; oldidx++ )
        {
            //
            //    add any denys found
            //
            if (_pcaaacl[oldidx]->AccessMode() == DENY_ACCESS)
            {
                if (!NT_SUCCESS(ntstatus = RtlAddAccessDeniedAce(
                                            *pacl,
                                            ACL_REVISION2,
                                            _pcaaacl[oldidx]->AccessMask(),
                                            _pcaaacl[oldidx]->Sid())))
                {
                    status = RtlNtStatusToDosError(ntstatus);
                    break;
                }
                else
                {
                    //
                    // set the inheritance
                    //
                    status = _SetAceFlags( aceindex,
                                           *pacl,
                                           _pcaaacl[oldidx] );
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }
                //
                // increment the count of added aces (so can set any
                // inheritance)
                //
                aceindex++;

            //
            // accessmode will be set to SE_AUDIT_BOTH in the case
            // where some other utility has put an an ACE to
            // audit both success and failure; this dll will
            // insert two aces when a request is made to set
            // both success and failure auditing
            //
            }
            else if ( (_pcaaacl[oldidx]->AccessMode() ==
                         SET_ACCESS) ||
                        (_pcaaacl[oldidx]->AccessMode() ==
                         SET_AUDIT_SUCCESS) ||
                        (_pcaaacl[oldidx]->AccessMode() ==
                         SET_AUDIT_FAILURE) ||
                        (_pcaaacl[oldidx]->AccessMode() ==
                         SE_AUDIT_BOTH))
            {
                //
                // break at the first allowed ACE
                //
                break;
            }
        } // for
    }

    if (status == NO_ERROR)
    {
        //
        // loop thru the access entries AccountAccesses
        //
        for (newidx = 0; newidx < _pcaaaesindex ; newidx++ )
        {
            //
            //    add any grants or sets found
            //
            if ( (_pcaaaes[newidx]->AccessMode() ==
                  SET_ACCESS) ||
                 (_pcaaaes[newidx]->AccessMode() ==
                  GRANT_ACCESS) )
            {
                if (_pcaaaes[newidx]->MultipleTrusteeOperation() ==
                    TRUSTEE_IS_IMPERSONATE)
                {
                    //
                    // note that no mask translations additions are
                    // done on compound ace masks
                    //
                    if (!NT_SUCCESS(ntstatus = RtlAddCompoundAce(
                                               *pacl,
                                               ACL_REVISION3,
                             COMPOUND_ACE_IMPERSONATION,
                            _pcaaaes[newidx]->AccessMask(),
                            _pcaaaes[newidx]->ImpersonateSid(),
                            _pcaaaes[newidx]->Sid())))
                    {
                        status = RtlNtStatusToDosError(ntstatus);
                        break;
                    }
                }
                else
                {
                    if (!NT_SUCCESS(ntstatus = RtlAddAccessAllowedAce(
                                                *pacl,
                                                ACL_REVISION2,
                                                _pcaaaes[newidx]->AccessMask(),
                                                _pcaaaes[newidx]->Sid())))
                    {
                        status = RtlNtStatusToDosError(ntstatus);
                        break;
                    }
                }

                //
                // set the inheritance
                //
                status = _SetAceFlags( aceindex,
                                       *pacl,
                                       _pcaaaes[newidx] );

                if (status != NO_ERROR)
                {
                    break;
                }
                //
                // increment the count of added aces (so can set
                // any inheritance)
                //
                aceindex++;
            }

            //
            // else add any audit entries
            //
            else if ( (_pcaaaes[newidx]->AccessMode() ==
                         SET_AUDIT_SUCCESS) ||
                        (_pcaaaes[newidx]->AccessMode() ==
                         SET_AUDIT_FAILURE) )
            {
                //
                // allow synchronize and read control if
                // used by provider independent API
                //
                ACCESS_MASK tmpmask;

                if (_fused_by_provider_independent_api)
                {
                    tmpmask = _pcaaaes[newidx]->AccessMask() |
                              SYNCHRONIZE | READ_CONTROL;
                } else
                {
                    tmpmask = _pcaaaes[newidx]->AccessMask();
                }

                if (!NT_SUCCESS(ntstatus = RtlAddAuditAccessAce(
                                           *pacl,
                                           ACL_REVISION2,
                                           tmpmask,
                                          _pcaaaes[newidx]->Sid(),
                                          (_pcaaaes[newidx]->AccessMode() ==
                                              SET_AUDIT_SUCCESS),
                                          (_pcaaaes[newidx]->AccessMode() ==
                                              SET_AUDIT_FAILURE))))
                {
                    status = RtlNtStatusToDosError(ntstatus);
                }
                else
                {
                    //
                    // set the inheritance
                    //
                    status = _SetAceFlags( aceindex,
                                           *pacl,
                                           _pcaaaes[newidx] );
                }

                if (status != NO_ERROR)
                {
                    break;
                }

                //
                // increment the count of added aces (so can set
                // any inheritance)
                //
                aceindex++;
            }

        } // for
    }

    if (status == NO_ERROR)
    {
        //
        // loop thru the rest of the ACLs AccountAccesses
        //
        for (; oldidx < _pcaaaclindex ; oldidx++ )
        {
            //
            //    add any sets found, error if any denys found
            //
            if (_pcaaacl[oldidx]->AccessMode() == SET_ACCESS)
            {
                if (_pcaaacl[oldidx]->MultipleTrusteeOperation() ==
                    TRUSTEE_IS_IMPERSONATE)
                {
                    //
                    // add any impersonate aces
                    //
                    if (!NT_SUCCESS(ntstatus = RtlAddCompoundAce( *pacl,
                                                ACL_REVISION3,
                                                COMPOUND_ACE_IMPERSONATION,
                                             _pcaaacl[oldidx]->AccessMask(),
                                          _pcaaacl[oldidx]->ImpersonateSid(),
                                                    _pcaaacl[oldidx]->Sid())))
                    {
                        status = RtlNtStatusToDosError(ntstatus);
                        break;
                    }
                }
                else
                {
                    //
                    // add an access allowed ACE
                    //
                    if (!NT_SUCCESS(ntstatus = RtlAddAccessAllowedAce(
                                                 *pacl,
                                                 ACL_REVISION2,
                                                 _pcaaacl[oldidx]->AccessMask(),
                                                 _pcaaacl[oldidx]->Sid())))
                    {
                        status = RtlNtStatusToDosError(ntstatus);
                        break;
                    }
                }

                //
                // set the inheritance
                //
                status = _SetAceFlags( aceindex,
                                       *pacl,
                                       _pcaaacl[oldidx] );
                if (status != NO_ERROR)
                {
                    break;
                }

                //
                // increment the count of added aces (so can
                // set any inheritance)
                //
                aceindex++;

            }
            //
            // add any audit aces
            //
            else if ( (_pcaaacl[oldidx]->AccessMode() == SET_AUDIT_SUCCESS) ||
                      (_pcaaacl[oldidx]->AccessMode() == SET_AUDIT_FAILURE) ||
                      (_pcaaacl[oldidx]->AccessMode() == SE_AUDIT_BOTH))
            {
                //
                // allow synchronize and read control if
                // used by provider independent API
                // also note that if an audit both ace
                // existed before, and is not being modified,
                // no changes are made to the ace
                //

                ACCESS_MASK tmpmask;

                if (_fused_by_provider_independent_api)
                {
                    tmpmask = _pcaaacl[oldidx]->AccessMask() |
                              SYNCHRONIZE | READ_CONTROL;
                } else
                {
                    tmpmask = _pcaaacl[oldidx]->AccessMask();
                }

                //
                // add an audit ace
                //
                if (!NT_SUCCESS(ntstatus = RtlAddAuditAccessAce(
                                             *pacl,
                                             ACL_REVISION2,
                                             tmpmask,
                                             _pcaaacl[oldidx]->Sid(),
                                             (_pcaaacl[oldidx]->AccessMode() ==
                                                 SET_AUDIT_SUCCESS),
                                             (_pcaaacl[oldidx]->AccessMode() ==
                                                 SET_AUDIT_FAILURE))))
                {
                    status = RtlNtStatusToDosError(ntstatus);
                    break;
                }
                else
                {
                    //
                    // set the inheritance
                    //
                    status = _SetAceFlags( aceindex,
                                           *pacl,
                                           _pcaaacl[oldidx] );
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }

                //
                // increment the count of added aces (so can
                // set any inheritance)
                //
                aceindex++;
            }

            //
            // unless the entry was marked as not used, it is
            // out of order
            //
            else if (_pcaaacl[oldidx]->AccessMode() !=
                       NOT_USED_ACCESS)

            {
               status = ERROR_INVALID_ACL;
               break;
            }
        } // for

    }

    if (status != NO_ERROR)
    {
        if (*pacl != NULL)
        {
            AccFree(*pacl);
        }
    }

    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     BuildAccessEntries, public
//
//  Synopsis:  converts the ACL and access entries AccountAccesses into
//             access entries.  This is also a 2 pass operation, the first
//             pass calculates the size and the second pass resolves conflicts,
//             allocates memory and builds the access entries to return
//
//  Arguments:  OUT - [csize]  - the returned size of the access entries
//              OUT - [ccount]  - the returned count of access entries
//              OUT - [pae]  - the returned list of access entries, this buffer
//                             and each trustee name in it must be freed using
//                             AccFree (or see below)
//              IN - [fAbsolute]  - If TRUE the returned access entries are in a
//                                  single buffer and must be freed with a single
//                                  call to AccFree
//
//----------------------------------------------------------------------------
DWORD CAcl::BuildAccessEntries(PULONG csize,
                                 PULONG ccount,
                                 PACCESS_ENTRY *pae,
                                 BOOL fAbsolute)
{
    DWORD status = NO_ERROR;

    //
    // pass1 resolve conflicts and get the size of the access entries based on
    // the current contents of this class
    //
    status = _Pass1(csize, ccount, FALSE); // FALSE:build access entries
    if (status == NO_ERROR)
    {
        //
        // allocate space for the new entries
        //
        if ( NULL != (*pae = (PACCESS_ENTRY)AccAlloc(*csize) ) )
        {
            //
            // get a pointer to where the names will be put
            //
            LPWSTR nameptr = (LPWSTR)((PBYTE)(*pae) + sizeof(ACCESS_ENTRY) *
                                                *ccount);

            ULONG cintcount = 0;
            //
            // loop thru the access entries AccountAccesses
            //
            for (ULONG newidx = 0; newidx < _pcaaaesindex ; newidx++ )
            {
                //
                //    add any denys found
                //
                if (_pcaaaes[newidx]->AccessMode() == DENY_ACCESS)
                {
                    _BuildAccessEntry(_pcaaaes[newidx],
                                      &nameptr,
                                      &((*pae)[cintcount++]),
                                      fAbsolute);
                }
            }

            //
            // loop thru the ACL AccountAccesses until the first allow
            //
            for (ULONG oldidx = 0; oldidx < _pcaaaclindex ; oldidx++ )
            {
                //
                //    add any denys found
                //
                if (_pcaaacl[oldidx]->AccessMode() == DENY_ACCESS)
                {
                    _BuildAccessEntry(_pcaaacl[oldidx],
                                      &nameptr,
                                      &((*pae)[cintcount++]),
                                      fAbsolute);

                } else if ( (_pcaaacl[oldidx]->AccessMode() ==
                             SET_ACCESS)  ||
                            (_pcaaacl[oldidx]->AccessMode() ==
                             SET_AUDIT_SUCCESS) ||
                            (_pcaaacl[oldidx]->AccessMode() ==
                             SET_AUDIT_FAILURE) ||
                            (_pcaaacl[oldidx]->AccessMode() ==
                             SE_AUDIT_BOTH))
                {
                    //
                    // break at the first allowed ACE
                    //
                    break;
                }
            }
            //
            // loop thru the access entries AccountAccesses
            //
            for (newidx = 0; newidx < _pcaaaesindex ; newidx++)
            {
                //
                //    add any grants or sets found
                //
                if (  (_pcaaaes[newidx]->AccessMode() ==
                       SET_ACCESS) ||
                      (_pcaaaes[newidx]->AccessMode() ==
                       GRANT_ACCESS) ||
                      (_pcaaaes[newidx]->AccessMode() ==
                       SET_AUDIT_SUCCESS) ||
                      (_pcaaaes[newidx]->AccessMode() ==
                       SET_AUDIT_FAILURE) )
                {
                    _BuildAccessEntry(_pcaaaes[newidx],
                                      &nameptr,
                                      &((*pae)[cintcount++]),
                                      fAbsolute);
                }
            }
            //
            // loop thru the rest of the ACLs AccountAccesses
            //
            for (; oldidx < _pcaaaclindex ; oldidx++)
            {
                //
                //    add any sets found, error if any denys found
                //
                if ( (_pcaaacl[oldidx]->AccessMode() ==
                      SET_ACCESS)  ||
                     (_pcaaacl[oldidx]->AccessMode() ==
                      SET_AUDIT_SUCCESS) ||
                     (_pcaaacl[oldidx]->AccessMode() ==
                      SET_AUDIT_FAILURE))
                {
                    _BuildAccessEntry(_pcaaacl[oldidx],
                                      &nameptr,
                                      &((*pae)[cintcount++]),
                                      fAbsolute);
                //
                // unless the entry was marked as not used, it is
                // out of order
                //
                } else if (_pcaaacl[oldidx]->AccessMode() ==
                           SE_AUDIT_BOTH)
                {
                    _BuildDualAuditEntries(_pcaaacl[oldidx],
                                           &nameptr,
                                           *pae,
                                           &cintcount,
                                           fAbsolute);

                } else if (_pcaaacl[oldidx]->AccessMode() !=
                           NOT_USED_ACCESS)

                {
                   status = ERROR_INVALID_ACL;
                   AccFree(*pae);
                   break;
                }
            }
            ASSERT(*ccount == cintcount);
        } else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return(status);
}
#if 0
//+---------------------------------------------------------------------------
//
//  Member:     GetEffectiveRights, public
//
//  Synopsis:   grovels the CACLs AccountAccess objects to determine the trustees
//              effective access rights
//
//  Arguments:  IN - [ptrustee]  - the name of the trustee to get effective right
//              OUT - [accessmask] - effective rights for the trustee
//
//----------------------------------------------------------------------------
DWORD CAcl::GetEffectiveRights( PTRUSTEE ptrustee,
                                PACCESS_MASK accessmask)
{
    DWORD status = NO_ERROR;
    CAccountAccess caa;

    //
    // initialize the account access for the trustee depending on type
    // of trustee
    //
    if (ptrustee->TrusteeForm == TRUSTEE_IS_SID)
    {
        status = caa.Init( (PSID)ptrustee->ptstrName,
                           _system,
                           SET_ACCESS,
                           0,
                           0,
                           FALSE);
    }
    else if (ptrustee->TrusteeForm == TRUSTEE_IS_NAME)
    {
        status = caa.Init( ptrustee->ptstrName,
                           _system,
                           SET_ACCESS,
                           0,
                           0,
                           FALSE);
    }
    else
    {
        status = ERROR_NOT_SUPPORTED;
    }

    if (status == NO_ERROR)
    {
        //
        // a class to do the member check
        //
        CMemberCheck cmc(&caa);

        //
        // initialized the class
        //
        status = cmc.Init();
        if (status == NO_ERROR)
        {
            ACCESS_MASK allowmask = 0, denymask = 0;

            for (ULONG newidx = 0; newidx < _pcaaaesindex ; newidx++ )
            {
                //
                //    add any denys found
                //
                if (_pcaaaes[newidx]->AccessMode() == DENY_ACCESS)
                {
                    status = _ComputeEffective( _pcaaaes[newidx],
                                                &cmc,
                                                &allowmask,
                                                &denymask);
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }
            }
            if (status == NO_ERROR)
            {
                //
                // loop thru the ACL AccountAccesses until the first allow
                //
                for (ULONG oldidx = 0; oldidx < _pcaaaclindex ; oldidx++ )
                {
                    //
                    //    add any denys found
                    //
                    if (_pcaaacl[oldidx]->AccessMode() == DENY_ACCESS)
                    {
                        status = _ComputeEffective( _pcaaacl[oldidx],
                                                    &cmc,
                                                    &allowmask,
                                                    &denymask );
                        if (status != NO_ERROR)
                        {
                            break;
                        }
                    }
                    else if (_pcaaacl[oldidx]->AccessMode() == SET_ACCESS)
                    {
                        //
                        // break at the first allowed ACE
                        //
                        break;
                    }
                    else if ( (_pcaaacl[oldidx]->AccessMode() ==
                                  SET_AUDIT_SUCCESS) ||
                              (_pcaaacl[oldidx]->AccessMode() ==
                                  SET_AUDIT_FAILURE) ||
                              (_pcaaacl[oldidx]->AccessMode() ==
                                  SE_AUDIT_BOTH) )
                    {
                        //
                        // we should not encounter any audit aces when
                        // we are checking for effective access rights
                        //
                        status = ERROR_INVALID_ACL;
                        break;
                    }
                }
                if (status == NO_ERROR)
                {
                    //
                    // loop thru the access entries AccountAccesses
                    //
                    for (newidx = 0; newidx < _pcaaaesindex ; newidx++ )
                    {
                        //
                        //    add any grants, or sets found
                        //
                        if ( (_pcaaaes[newidx]->AccessMode() ==
                              SET_ACCESS) ||
                             (_pcaaaes[newidx]->AccessMode() ==
                              GRANT_ACCESS) )
                        {
                            status = _ComputeEffective( _pcaaaes[newidx],
                                                        &cmc,
                                                        &allowmask,
                                                        &denymask );
                            if (status != NO_ERROR)
                            {
                                break;
                            }
                        }
                        else if ( (_pcaaaes[newidx]->AccessMode() ==
                                      SET_AUDIT_SUCCESS) ||
                                  (_pcaaaes[newidx]->AccessMode() ==
                                      SET_AUDIT_FAILURE) ||
                                  (_pcaaaes[newidx]->AccessMode() ==
                                      SE_AUDIT_BOTH) )
                        {
                            //
                            // we should not encounter any audit aces when
                            // we are checking for effective access rights
                            //
                            status = ERROR_INVALID_ACL;
                            break;
                        }
                    }
                    if (status == NO_ERROR)
                    {
                        //
                        // loop thru the rest of the ACLs AccountAccesses
                        //
                        for (; oldidx < _pcaaaclindex ; oldidx++ )
                        {
                            //
                            //    add any sets or audits found, error if any
                            //    denys found
                            //
                            if ( (_pcaaacl[oldidx]->AccessMode() ==
                                  SET_ACCESS) )
                            {
                                status = _ComputeEffective( _pcaaacl[oldidx],
                                                            &cmc,
                                                            &allowmask,
                                                            &denymask );
                                if (status != NO_ERROR)
                                {
                                    break;
                                }
                            }
                            else if (_pcaaacl[oldidx]->AccessMode() !=
                                        NOT_USED_ACCESS)

                            {
                                //
                                // unless the entry was marked as not used, it is
                                // out of order
                                //
                                status = ERROR_INVALID_ACL;
                                break;
                            }
                        }
                    }
                }
            }
            if (status == NO_ERROR)
            {
                //
                // set the effective rights to be the alloweds minus the denieds
                // (because of required ordering)
                //
                *accessmask = allowmask & ~denymask;
            }
        }
    }


    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     GetAuditedRights, public
//
//  Synopsis:   grovels the CACLs AccountAccess objects to determine the trustees
//              audited rights
//
//  Arguments:  IN - [ptrustee]  - the name of the trustee to get effective right
//              OUT - [successmask] - success audited rights for the trustee
//              OUT - [failuremask] - failure audited rights for the trustee
//
//----------------------------------------------------------------------------
DWORD CAcl::GetAuditedRights(PTRUSTEE ptrustee,
                               PACCESS_MASK successmask,
                               PACCESS_MASK failuremask)
{
    DWORD status;
    CAccountAccess caa;


    *successmask = 0;
    *failuremask = 0;

    //
    // initialize the account access for the trustee depending on form of
    // trustee
    //
    if (ptrustee->TrusteeForm == TRUSTEE_IS_SID)
    {
        status = caa.Init( (PSID)ptrustee->ptstrName,
                           _system,
                           SET_ACCESS,
                           0,
                           0,
                           FALSE );
    }
    else if (ptrustee->TrusteeForm == TRUSTEE_IS_NAME)
    {
        status = caa.Init( ptrustee->ptstrName,
                           _system,
                           SET_ACCESS,
                           0,
                           0,
                           FALSE );
    }
    else
    {
        status = ERROR_NOT_SUPPORTED;
    }

    if (status == NO_ERROR)
    {
        //
        // a class to do the member check
        //
        CMemberCheck cmc(&caa);

        //
        // initialized the class
        //
        status = cmc.Init();
        if (status == NO_ERROR)
        {
            //
            // loop thru the access entry accesses
            //
            for (ULONG newidx = 0; newidx < _pcaaaesindex ; newidx++ )
            {
                //
                // no access convered by ace with inherit only flag on
                //
                if (0 == (_pcaaaes[newidx]->AceFlags() & INHERIT_ONLY_ACE ) )
                {
                    BOOL fresult;

                    //
                    // check if the trustee is a member of the account access id
                    //
                    status = cmc.IsMemberOf( _pcaaaes[newidx],
                                             &fresult );
                    if (status == NO_ERROR)
                    {
                        if (fresult == TRUE)
                        {
                            //
                            // then decide which type to add it to
                            //
                            if ( (_pcaaaes[newidx]->AccessMode() ==
                                  SET_AUDIT_SUCCESS) ||
                                 (_pcaaaes[newidx]->AccessMode() ==
                                  SE_AUDIT_BOTH) )
                            {
                                *successmask |=_pcaaaes[newidx]->AccessMask();
                            }

                            if ( (_pcaaaes[newidx]->AccessMode() ==
                                  SET_AUDIT_FAILURE) ||
                                 (_pcaaaes[newidx]->AccessMode() ==
                                  SE_AUDIT_BOTH) )
                            {
                                *failuremask |=_pcaaaes[newidx]->AccessMask();
                            }
                        }
                     }
                     else
                     {
                         break;
                     }
                }
            }

            if (status == NO_ERROR)
            {
                //
                // loop thru the ACL AccountAccesses
                //
                for (ULONG oldidx = 0; oldidx < _pcaaaclindex ; oldidx++ )
                {
                    //
                    // no access convered by ace with inherit only flag on
                    //
                    if (0 == (_pcaaacl[oldidx]->AceFlags() & INHERIT_ONLY_ACE ) )
                    {
                        BOOL fresult;

                        //
                        // check if the trustee is a member of the account
                        //  access id
                        //
                        status = cmc.IsMemberOf( _pcaaacl[oldidx],
                                                 &fresult );
                        if (status == NO_ERROR)
                        {
                            if (fresult == TRUE)
                            {
                                //
                                // then decide which type to add it to
                                //
                                if ( (_pcaaacl[oldidx]->AccessMode() ==
                                                             SET_AUDIT_SUCCESS) ||
                                     (_pcaaacl[oldidx]->AccessMode() ==
                                                             SE_AUDIT_BOTH) )
                                {
                                    *successmask |=_pcaaacl[oldidx]->AccessMask();
                                }
                                if ( (_pcaaacl[oldidx]->AccessMode() ==
                                                             SET_AUDIT_FAILURE) ||
                                     (_pcaaacl[oldidx]->AccessMode() ==
                                                             SE_AUDIT_BOTH) )
                                {
                                    *failuremask |=_pcaaacl[oldidx]->AccessMask();
                                }
                            }
                         }
                         else
                         {
                             break;
                         }
                    }
                }
            }
        }
    }

    return(status);
}
#endif
//+---------------------------------------------------------------------------
//
//  Member:     _InitIterators, private
//
//  Synopsis:   resolves any conficts between the ACL and access entries,
//              and calculates the size required for an ACL or access entries
//              to return
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
DWORD CAcl::_InitIterators()
{
    DWORD status = NO_ERROR;
    //
    // new the iterators if required
    //
    if (_pcacli == NULL)
    {
        if (NULL == (_pcacli = new CAclIterator()))
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (status == NO_ERROR)
    {
        if (_pcaeli == NULL)
        {
            if (NULL == (_pcaeli = new CAesIterator()))
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _Pass1, private
//
//  Synopsis:   resolves any conficts between the ACL and access entries,
//              and calculates the size required for an ACL or access entries
//              to return
//
//  Arguments:  [OUT] cSize - the size required for an ACL or access entries
//              [OUT] cCount - the count of ACEs or access entries
//              [IN] fBuildAcl - if FALSE, calculate size for access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::_Pass1(PULONG cSize, PULONG cCount, BOOL fBuildAcl)
{

    DWORD status = NO_ERROR;
    BOOL useentry;

    //
    // initialize the size.
    //
    *cSize = fBuildAcl ? sizeof(ACL) : 0;
    *cCount = 0;

    //
    // assume that we are using all the (remaining) ACL entries
    // (ie. whats one more loop)
    //
    for (ULONG aclindex = 0; aclindex < _pcaaaclindex; aclindex++)
    {
        //
        // don't process any entries marked not used
        //
        if (_pcaaacl[aclindex]->AccessMode() != NOT_USED_ACCESS)
        {
            status = _UseEntry( _pcaaacl[aclindex],
                                cSize,
                                cCount,
                                fBuildAcl );
            if (status != NO_ERROR)
            {
                break;
            }
        }
    }
    //
    // if there are any access entries, resolve any conflicts
    //
    for (ULONG aeindex = 0; aeindex < _pcaaaesindex; aeindex++)
    {
        //
        // don't process any entries already marked not used.
        // (perhaps from a previous pass)
        //
        if (_pcaaaes[aeindex]->AccessMode() != NOT_USED_ACCESS)
        {
            //
            // first check for matching SIDs in the ACL
            //
            status = _CheckEntryList( _pcaaaes[aeindex],
                                      _pcaaacl,
                                      _pcaaaclindex,
                                      cSize,
                                      cCount,
                                      fBuildAcl );
            if (status != NO_ERROR)
            {
                break;
            }
            //
            // if the entry is still needed (access not already provided
            // by a previous entry), check the access entries list for matches
            //
            if (_pcaaaes[aeindex]->AccessMode() != NOT_USED_ACCESS)
            {
                //
                // then check for matching SIDS in any previous access entries
                //
                status = _CheckEntryList( _pcaaaes[aeindex],
                                          _pcaaaes,
                                          aeindex,
                                          cSize,
                                          cCount,
                                          fBuildAcl );
                if (status != NO_ERROR)
                {
                    break;
                }
                //
                // all done checking, if we still want the entry, use it
                //

                if ( (_pcaaaes[aeindex]->AccessMode() != NOT_USED_ACCESS) &&
                     (_pcaaaes[aeindex]->AccessMode() != REVOKE_ACCESS) )
                {
                    status = _UseEntry( _pcaaaes[aeindex],
                                        cSize,
                                        cCount,
                                        fBuildAcl );
                    if (status != NO_ERROR)
                    {
                        break;
                    }
                }
            }
        }
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _CheckEntryList, private
//
//  Synopsis:   resolves any conficts between the ACL and access entries,
//              and calculates the size required for an ACL or access entries
//              to return
//
//  Arguments:  [IN] pCAA - the Account Access class to check for matches against
//                          the list of account accessses
//              [IN] plistCAA - the list of account accesses to search thru
//              [IN] clistlength - the number of entries in the list
//              [IN/OUT] cSize - the size required for an ACL or access entries
//              [IN/OUT] cCount - the size required for an ACL or access entries
//              [IN] fBuildAcl - if FALSE, calculate size for access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::_CheckEntryList(CAccountAccess *pCAA,
                            CAccountAccess **plistCAA,
                            ULONG clistlength,
                            PULONG cSize,
                            PULONG cCount,
                            BOOL fBuildAcl)
{
    DWORD status = NO_ERROR;

    BOOL dontuseentry = FALSE;

    for (ULONG index = 0; index < clistlength; index++)
    {
        //
        // don't process any entries already marked not used.
        // (perhaps from a previous pass)
        //
        if (plistCAA[index]->AccessMode() != NOT_USED_ACCESS)
        {
            //
            // check for matching ids (and matching modes, see
            // accesscontrolcdd.doc for a full explaination of this)
            // this impersonate stuff is specifically for DS objects,
            // and the kind of ace management they do (specifically, see
            // notes on DS object specific permissions, and query access
            //
            if ( (RtlEqualSid( pCAA->Sid(), plistCAA[index]->Sid())) &&
                 ( ( (pCAA->AccessMode() == DENY_ACCESS) ||
                     (plistCAA[index]->AccessMode() == DENY_ACCESS) ) ||
                   ( (pCAA->MultipleTrusteeOperation() != TRUSTEE_IS_IMPERSONATE) &&
                     (plistCAA[index]->MultipleTrusteeOperation() != TRUSTEE_IS_IMPERSONATE) ||
                   ( (pCAA->MultipleTrusteeOperation() == TRUSTEE_IS_IMPERSONATE) &&
                     (plistCAA[index]->MultipleTrusteeOperation() == TRUSTEE_IS_IMPERSONATE) ))))
            {

                //
                // do things based on the type of the new entry
                //
                switch (pCAA->AccessMode())
                {
                case GRANT_ACCESS:
                case DENY_ACCESS:
                    //
                    // merge the entries
                    //
                    status = _MergeEntries(pCAA,
                                           plistCAA[index],
                                           cSize,
                                           cCount,
                                           fBuildAcl);
                    break;
                case SET_ACCESS:
                case REVOKE_ACCESS:
                case SET_AUDIT_SUCCESS:
                case SET_AUDIT_FAILURE:
                    //
                    // don't use the old entry (since the new one takes
                    // precedence)
                    //

                    status = _RemoveEntry(plistCAA[index],
                                          cSize,
                                          cCount,
                                          fBuildAcl);
                    break;
                default:
                    ASSERT( (pCAA->AccessMode() != GRANT_ACCESS  ) ||
                            (pCAA->AccessMode() != DENY_ACCESS   ) ||
                            (pCAA->AccessMode() != SET_ACCESS    ) ||
                            (pCAA->AccessMode() != REVOKE_ACCESS ) ||
                            (pCAA->AccessMode() != SET_AUDIT_SUCCESS ) ||
                            (pCAA->AccessMode() != SET_AUDIT_FAILURE ) );
                    break;
                }
            }
        }
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _UseEntry, private
//
//  Synopsis:   uses the entry for the ACL or access entries being built
//
//  Arguments:  [IN] pCAA - the Account Access class to use
//              [IN/OUT] cSize - the size required for an ACL or access entries
//              [IN/OUT] cCount - the size required for an ACL or access entries
//              [IN] fBuildAcl - if FALSE, calculate size for access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::_UseEntry(CAccountAccess *pCAA,
                        PULONG cSize,
                        PULONG cCount,
                        BOOL fBuildAcl)
{
    DWORD status = NO_ERROR;

    if (fBuildAcl)
    {
        //
        // increment the count (of aces in this case)
        // and grow the size
        //
        (*cSize) += _GetAceSize(pCAA);

    } else
    {
        //
        // get the size of the access entry
        //
        ULONG centrysize;

        status = _GetAccessEntrySize( pCAA,
                                      &centrysize);
        if (status == NO_ERROR)
        {
            (*cSize) += centrysize;
            if (pCAA->AccessMode() == SE_AUDIT_BOTH)
            {
                //
                // if it is an audit both (success and failure) ACE,
                // add two access entries
                //
                (*cSize) += centrysize;
                (*cCount)++;
            }
        }
    }
    //
    // increment the count (of access entries)
    //
    (*cCount)++;
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _RemoveEntry, private
//
//  Synopsis:   removes the entry from those to be used for the ACL or access
//              entries being built
//
//  Arguments:  [IN] pCAA - the Account Access class to not use
//              [IN/OUT] cSize - the size required for an ACL or access entries
//              [IN/OUT] cCount - the size required for an ACL or access entries
//              [IN] fBuildAcl - if FALSE, calculate size for access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::_RemoveEntry(CAccountAccess *pCAA,
                           PULONG cSize,
                           PULONG cCount,
                           BOOL fBuildAcl)
{
    DWORD status = NO_ERROR;

    ASSERT(pCAA->AccessMode() != NOT_USED_ACCESS);

    if (fBuildAcl)
    {
        //
        // increment the count (of aces in this case)
        // and grow the size
        //
        (*cSize) -= _GetAceSize(pCAA);
    } else
    {
        //
        // get the size of the access entry
        //
        ULONG centrysize;

        status = _GetAccessEntrySize( pCAA,
                                      &centrysize );
        if (status == NO_ERROR)
        {
            (*cSize) -= centrysize;
        }
    }
    //
    // increment the count (of access entries)
    //
    (*cCount)--;
    pCAA->SetAccessMode(NOT_USED_ACCESS);
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _MergeEntries, private
//
//  Synopsis:   this merge function checks two access entries with matching
//              SIDs for inheritance and mask intersections.  It is assumed that
//              the new access entry is either DENY_ACCESS or GRANT_ACCESS,
//              and the old entry is either DENY_ACCESS, GRANT_ACCESS, or SET_ACCESS
//
//  Arguments:  [IN] pnewCAA - the new Account Access class to merge with the
//                             old one
//              [IN] poldCAA - the old Account Access class
//              [IN/OUT] cSize - the size required for an ACL or access entries
//              [IN/OUT] cCount - the size required for an ACL or access entries
//              [IN] fBuildAcl - if FALSE, calculate size for access entries
//
//----------------------------------------------------------------------------
DWORD CAcl::_MergeEntries(CAccountAccess *pnewCAA,
                            CAccountAccess *poldCAA,
                            PULONG cSize,
                            PULONG cCount,
                            BOOL fBuildAcl)
{

    DWORD status = NO_ERROR;
    BOOL leave_old_ace = FALSE;

    //
    // bogus while loop for fake gotos
    //
    while(1)
    {
        //
        // can't set inheritance on objects
        //
        if ( ( (_fdir == ACCESS_TO_UNKNOWN ) ||
               (_fdir == ACCESS_TO_OBJECT ) ) &&
             (0 != pnewCAA->AceFlags()) )
        {
            status = ERROR_INVALID_PARAMETER;
            break;
        } else if (_fdir == ACCESS_TO_CONTAINER )
        {
            //
            // check for inheritance intersections
            //
            if (0 == (pnewCAA->AceFlags() & poldCAA->AceFlags()))
            {
                //
                // if disjoint inheritance, the entries really don't match
                //
                break;

            } else if (pnewCAA->AceFlags() != poldCAA->AceFlags())
            {
                //
                // if the entries inheritance intersects in some way, return an
                // error (can only set or revoke access in this case)
                //
                status = ERROR_INVALID_PARAMETER;
                break;
            }
        }
        //
        // now to merge the masks, switch on mask intersection type, and
        // then on entry types,
        // NOTE that SYNCHRONIZE and READ_CONTROL are always added on the
        // mask compares, however
        // it is only actually applied on the SET_ACCESS ACEs, so that, for
        // example, READ can be allowed, and WRITE can be denied (as opposed to
        // not granted).
        //
        if (0 == ((pnewCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL) &
                  (poldCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL)))
        {
            //
            // disjoint
            //
            if ( (pnewCAA->AccessMode() == poldCAA->AccessMode()) ||
                 ( (pnewCAA->AccessMode() != DENY_ACCESS) &&
                   (poldCAA->AccessMode() != DENY_ACCESS) ) )
            {
                //
                // equivalent modes
                //
                pnewCAA->SetAccessMask(pnewCAA->AccessMask() |
                                       poldCAA->AccessMask());
                status = _RemoveEntry(poldCAA,
                                      cSize,
                                      cCount,
                                      fBuildAcl);
            }
        } else if ((pnewCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL) ==
                   (poldCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL) )
        {
            //
            // equal
            //
            status = _RemoveEntry(poldCAA,
                                  cSize,
                                  cCount,
                                  fBuildAcl);

        } else if ( (poldCAA->AccessMask() | pnewCAA->AccessMask() |
                     SYNCHRONIZE | READ_CONTROL) ==
                    (poldCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL))
        {
            //
            // new is subset of old
            //
            if ( (pnewCAA->AccessMode() == poldCAA->AccessMode()) ||
                 ( (pnewCAA->AccessMode() != DENY_ACCESS) &&
                   (poldCAA->AccessMode() != DENY_ACCESS) ) )
            {
                //
                // equivalent modes
                //
                pnewCAA->SetAccessMode(NOT_USED_ACCESS);
            } else
            {
                //
                // one is deny, one is allow
                //
                poldCAA->SetAccessMask(poldCAA->AccessMask() &
                                       ~(pnewCAA->AccessMask()));
            }
        } else if ( (poldCAA->AccessMask() | pnewCAA->AccessMask() |
                     SYNCHRONIZE | READ_CONTROL) ==
                    (pnewCAA->AccessMask() | SYNCHRONIZE | READ_CONTROL))
        {
            //
            // old is subset of new
            //
            status = _RemoveEntry(poldCAA,
                                  cSize,
                                  cCount,
                                  fBuildAcl);
        } else
        {
            //
            // overlapping
            //
            if ( ( (pnewCAA->AccessMode() | SYNCHRONIZE | READ_CONTROL) ==
                   (poldCAA->AccessMode() | SYNCHRONIZE | READ_CONTROL) ) ||
                 ( (pnewCAA->AccessMode() != DENY_ACCESS) &&
                   (poldCAA->AccessMode() != DENY_ACCESS) ) )
            {
                //
                // equivalent modes
                //
                pnewCAA->SetAccessMask(pnewCAA->AccessMask() |
                                       poldCAA->AccessMask());
                status = _RemoveEntry(poldCAA,
                                      cSize,
                                      cCount,
                                      fBuildAcl);
            } else
            {
                //
                // one is deny, one is allow
                //
                poldCAA->SetAccessMask(poldCAA->AccessMask() &
                                       ~(pnewCAA->AccessMask()));
            }
        }
        break;
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _BuildAccessEntry, private
//
//  Synopsis:   converts an AccountAccess into an access entry
//
//  Arguments:  [IN] pCAA - the AccountAccess being converted to an access entry
//              [IN] nameptr - where to put the trustee name
//              [OUT] pAccessEntry - access entry to be stuffed
//              [IN] fAbsolute - if TRUE, trustee names are pointers
//
//+---------------------------------------------------------------------------
void CAcl::_BuildAccessEntry(CAccountAccess *pCAA,
                             LPWSTR *nameptr,
                             PACCESS_ENTRY pAccessEntry,
                             BOOL fAbsolute)
{

    pAccessEntry->AccessMode = pCAA->AccessMode();
    pAccessEntry->InheritType = (pCAA->AceFlags() & ACLBUILD_VALID_ACE_FLAGS);
    pAccessEntry->AccessMask = pCAA->AccessMask();

    //
    // now to make the trustee, first the single one
    //
    if (NULL != pCAA->Name())
    {
        wcscpy(*nameptr, pCAA->Name());
    } else
    {
        wcscpy(*nameptr, NAME_NOT_FOUND);
    }
    BuildTrusteeWithName(&(pAccessEntry->Trustee), *nameptr);
    //
    // return the real (simplified) trustee type
    //
    switch (pCAA->SidType())
    {
    case SidTypeUser:
        pAccessEntry->Trustee.TrusteeType = TRUSTEE_IS_USER;
        break;
    case SidTypeGroup:
    case SidTypeDomain:
    case SidTypeAlias:
    case SidTypeWellKnownGroup:
        pAccessEntry->Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        break;
    case SidTypeDeletedAccount:
    case SidTypeInvalid:
    case SidTypeUnknown:
    default:
        pAccessEntry->Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
        break;
    }
    //
    // increment to the next trustee
    //
    *nameptr = (LPWSTR)((PBYTE)(*nameptr) + (wcslen(*nameptr) + 1) * sizeof(WCHAR));

    //
    // now if there is a multiple trustee
    //
    if (pCAA->MultipleTrusteeOperation() == TRUSTEE_IS_IMPERSONATE)
    {
        //
        // make space for the impersonate trustee
        //
        PTRUSTEE pImpTrustee = (PTRUSTEE)*nameptr;
        (*nameptr) = (LPWSTR)((PBYTE)*nameptr  + sizeof(TRUSTEE));
        //
        // figure out the sid size
        // why not make the server a name based trustee??
        // answer: because it is not easier
        //
        PSID psid = pCAA->ImpersonateSid();
        ULONG sidsize = RtlLengthSid(psid);
        //
        // copy the sid, and increment the buffer pointer
        //
        RtlCopySid(sidsize, *nameptr,psid);
        //
        // connect the trustee together with the sid
        //
        BuildTrusteeWithSid(pImpTrustee, *nameptr);
        //
        // move the buffer pointer past the sid
        //
        (*nameptr) = (LPWSTR)((PBYTE)*nameptr + sidsize);
        //
        // finally turn the original trustee into an impersonate trustee
        // with the other one
        //
        BuildImpersonateTrustee(&(pAccessEntry->Trustee), pImpTrustee);
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     _BuildDualAuditEntries, private
//
//  Synopsis:   converts an ACEs AccountAccess for auditing both success
//              and failed opens into two access entries
//
//  Arguments:  [IN] pCAA - the AccountAccess being converted to an access entry
//              [IN] nameptr - where to put the trustee name
//              [IN/OUT] pae - list of access entries to be stuffed
//              [IN/OUT] ccount - index into access entry list to start stuffing
//              [IN] fAbsolute - if TRUE, trustee names are pointers
//
//+---------------------------------------------------------------------------
void CAcl::_BuildDualAuditEntries(CAccountAccess *pCAA,
                             LPWSTR *nameptr,
                             PACCESS_ENTRY pae,
                             DWORD *ccount,
                             BOOL fAbsolute)
{
    //
    // first add an access entry for the successful open
    _BuildAccessEntry(pCAA,
                      nameptr,
                      &(pae[*ccount]),
                      fAbsolute);
    pae[(*ccount)++].AccessMode = SET_AUDIT_SUCCESS;

    //
    // then add an entry for the failed open
    //
    _BuildAccessEntry(pCAA,
                      nameptr,
                      &(pae[*ccount]),
                      fAbsolute);
    pae[(*ccount)++].AccessMode = SET_AUDIT_FAILURE;
}
#if 0
//+---------------------------------------------------------------------------
//
//  Member:     _ComputeEffective, private
//
//  Synopsis:   computes effective rights from an AccountAccess, including
//              doing a check for group membership
//
//  Arguments:  [IN] pCAA - the AccountAccess to test against
//              [IN] cMC - the member check class
//              [IN OUT] AllowedMask - the mask to add allowed accesses to
//              [IN OUT] DeniedMask - the mask to add denied accesses to
//
//+---------------------------------------------------------------------------
DWORD CAcl::_ComputeEffective(CAccountAccess *pCAA,
                        CMemberCheck *cMC,
                        PACCESS_MASK AllowMask,
                        PACCESS_MASK DenyMask)
{
    DWORD status = NO_ERROR;
    //
    // no access convered by ace with inherit only flag on
    //
    if (0 == (pCAA->AceFlags() & INHERIT_ONLY_ACE ) )
    {
        BOOL fresult;

        //
        // check of the trustee is a member of the account access id
        //
        status = cMC->IsMemberOf( pCAA,
                                  &fresult );
        if (status == NO_ERROR)
        {
            if (fresult == TRUE)
            {
                //
                // if a denied, then add to the deny mask
                //
                if (pCAA->AccessMode() == DENY_ACCESS)
                {
                    *DenyMask |= pCAA->AccessMask();
                //
                // if a set, then add to the allowed mask
                //
                } else if ( (pCAA->AccessMode() ==  SET_ACCESS) ||
                            (pCAA->AccessMode() ==  GRANT_ACCESS) )
                {
                    *AllowMask |= pCAA->AccessMask();
                }
            }
        }
    }
    return(status);
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     _SetAceFlags, private
//
//  Synopsis:   sets the ACE (inheritance) flag on an ACE in an ACL being
//              constructed1
//
//  Arguments:  IN - [AceIndex]  - the index of the ace
//              IN/OUT - [pacl] - the acl
//              IN - [pcaa] - the account access for the ace index
//
//----------------------------------------------------------------------------
DWORD CAcl::_SetAceFlags(ULONG AceIndex, PACL pacl, CAccountAccess *pcaa)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    if (0 != pcaa->AceFlags())
    {
        //
        // get the ACE and set the ace flags
        //
        PACE_HEADER pah;
        if (NT_SUCCESS(ntstatus = RtlGetAce(pacl,
                                            AceIndex,
                                            (void **)&pah)))
        {
            pah->AceFlags |= (BYTE)(pcaa->AceFlags() & VALID_INHERIT_FLAGS);
        } else
        {
            return(RtlNtStatusToDosError(ntstatus));
        }
    }
    return(ERROR_SUCCESS);
}
//+---------------------------------------------------------------------------
//
//  Member:     _GetAceSize, private
//
//  Synopsis:   gets the size required for an ACE
//
//  Arguments:  IN - [pcaa]  - returns the size required for the ACE
//
//----------------------------------------------------------------------------
ULONG CAcl::_GetAceSize(CAccountAccess *pcaa)
{
    if (pcaa->AccessMode() == REVOKE_ACCESS)
    {
        return(0);
    } else if (pcaa->MultipleTrusteeOperation() == TRUSTEE_IS_IMPERSONATE)
    {
        return(RtlLengthSid(pcaa->Sid()) +
                sizeof(ACE_HEADER) +
                sizeof(ACCESS_MASK) +
                sizeof(ULONG) + // sizeof compound ace type & reserved short
                RtlLengthSid(pcaa->ImpersonateSid()) );
    } else
    {
        return(RtlLengthSid(pcaa->Sid()) +
               sizeof(ACE_HEADER) +
               sizeof(ACCESS_MASK));
    }
}
//+---------------------------------------------------------------------------
//
//  Member:     _GetAccessEntrySize, private
//
//  Synopsis:   gets the size required for an access entry
//
//  Arguments:  IN - [pcaa]  - the size required for an access entry
//
//----------------------------------------------------------------------------
DWORD CAcl::_GetAccessEntrySize(CAccountAccess *pcaa, PULONG cAccessEntrySize)
{
    DWORD status;
    LPWSTR name;

    status = pcaa->LookupName(&name);
    if (status == NO_ERROR)
    {
        *cAccessEntrySize = (name == NULL ?
                           (wcslen(NAME_NOT_FOUND) + 1) * sizeof(WCHAR) +
                           sizeof(ACCESS_ENTRY) :
                           (wcslen(name) + 1) * sizeof(WCHAR) +
                           sizeof(ACCESS_ENTRY));

        if (pcaa->MultipleTrusteeOperation() == TRUSTEE_IS_IMPERSONATE)
        {
            (*cAccessEntrySize) += (sizeof(TRUSTEE) +
                                    RtlLengthSid(pcaa->ImpersonateSid()));
        }
    }
    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _AddEntry , private
//
//  Synopsis:   adds an entry (either an ACE or an access entry) to the CACL
//              objects list of AccountAccess objects
//
//  Arguments:  IN - [ci]  - the iterator class
//              OUT - [pcaa] - the account access class for the entry
//              OUT - [pcaaindex] the index of the entry
//
//----------------------------------------------------------------------------
DWORD CAcl::_AddEntry(CIterator *ci,
                        CAccountAccess **pcaa,
                        PULONG pcaaindex)
{

    DWORD status;


    //
    // allocate space for the account access class
    //
    if (NULL != (*pcaa = new CAccountAccess()))
    {
        //
        // initialize the account access
        //
        status = ci->InitAccountAccess( *pcaa,
                                        _system,
                                        _fdir,
                                        _fsave_names_and_sids );
        if (status == NO_ERROR)
        {
            (*pcaaindex)++;

        }
        else
        {
            delete *pcaa;
        }
    }
    else
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Map ERROR_BAD_INHERITANCE_ACL to NO_ERROR. That error is returned
    // when an ACE is inherit-only, so we don't want it in the ACL entry.
    // We do, however, want to skip the ACE so it is good that hte
    // index is not incremented.
    //
    //
    // JINHUANG: InitAccountAccess is changed so that INHERIT_ONLY ace
    // is also added to the list. So this error should never be returned
    //

    if (status == ERROR_BAD_INHERITANCE_ACL)
    {
        status = NO_ERROR;
    }

    return(status);
}
//+---------------------------------------------------------------------------
//
//  Member:     _CheckForDuplicateEntries, private
//
//  Synopsis:   checks for duplicate AccountAccess objects in the CACLs list of
//              AccountAccess objects.
//
//  Arguments:  IN - [pcaa]  - the list of account access objects
//              IN - [curindex] - the account access just added (at the end)
//              IN - [countold] - the number of account accesses in the list
//
//----------------------------------------------------------------------------
DWORD CAcl::_CheckForDuplicateEntries(CAccountAccess **pcaa,
                                        ULONG curindex,
                                        ULONG countold)
{

    DWORD status = NO_ERROR;


    //
    // loop thru the existing AccountAccesses to see if the latest matches
    //
    for (ULONG idx = 0; idx < countold; idx++)
    {
        if (RtlEqualSid(pcaa[idx]->Sid(), pcaa[curindex]->Sid()))
        {
            pcaa[idx]->SetAccessMode(NOT_USED_ACCESS);
        }
    }
    //
    // loop thru the new AccountAccesses to see if the latest matches
    // (they start at countold, which is where idx is left at after
    // the last loop)
    //
    for (; idx < curindex; idx++)
    {
        if (RtlEqualSid(pcaa[idx]->Sid(), pcaa[curindex]->Sid()))
        {
            status =ERROR_INVALID_PARAMETER;
            break;
        }
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\winsafer\safewild.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    SafeWild.c        (WinSAFER Wildcard SID handling)

Abstract:

    This module implements various "Wildcard SID" operations that
    are used internally by the WinSAFER APIs to compute SID list
    intersections and inversions.

Author:

    Jeffrey Lawson (JLawson) - Apr 2000

Environment:

    User mode only.

Exported Functions:

    CodeAuthzpConvertWildcardStringSidToSidW        (private)
    CodeAuthzpCompareWildcardSidWithSid             (private)
    CodeAuthzpSidInWildcardList                     (private)
    CodeAuthzpInvertAndAddSids                      (private)
    CodeAuthzpExpandWildcardList                    (private)

Revision History:

    Created - Apr 2000

--*/

#include "pch.h"
#pragma hdrstop
#include <sddl.h>           // ConvertStringSidToSidW
#include "safewild.h"
#include <winsafer.h>
#include "saferp.h"        // CodeAuthzpGetTokenInformation





NTSTATUS NTAPI
CodeAuthzpConvertWildcardStringSidToSidW(
    IN LPCWSTR                  szStringSid,
    OUT PAUTHZ_WILDCARDSID      pWildcardSid
    )
/*++

Routine Description:

    Converts a textual SID into the machine-understanable binary format.
    For normal string SIDs, this is just a call to ConvertStringSidToSidW
    with the exception that this takes a AUTHZ_WILDCARDSID parameter.

    However, this function also allows a single SubAuthority to be
    optionally specified as a wildcard ('*'), which will match zero or
    more SubAuthority.  Note that only one wildcard can be present within
    any SID and must represent whole SubAuthority values.
    (ie: "S-1-5-4-*-7" or "S-1-5-4-*" is okay; but "S-1-5-4*-7" and
    "S-1-5-*-4-*-7" are both not acceptable).

Arguments:

    szStringSid - textual string SID possibly containing a wildcard.

    pWildcardSID - pointer to a AUTHZ_WILDCARDSID structure that will be
            filled with information about the boolean sid.

Return Value:

    Returns STATUS_SUCCESS on success, or another error code.

--*/
{
    DWORD dwLength;
    LPWSTR pBuffer;
    LPCWSTR pStar = NULL;
    LPCWSTR p;

    //
    // Do a quick analysis pass on the String SID and verify that
    // there is at most one '*' in it.  And if there is a '*',
    // it must represent a whole subauthority (possibly the last
    // subauthority).
    //
    ASSERT( ARGUMENT_PRESENT(szStringSid) && ARGUMENT_PRESENT(pWildcardSid) );
    for (p = szStringSid; *p; p++)
    {
        if (*p == L'-' &&
            *(p + 1) == L'*' &&
            (*(p + 2) == UNICODE_NULL || *(p + 2) == L'-') )
        {
            if (pStar != NULL) return STATUS_INVALID_SID;
            pStar = p + 1;
            p++;
        }
        else if (*p == L'*') return STATUS_INVALID_SID;
    }


    //
    // If this String SID does not contain a wildcard, then just
    // process it normally and quickly return.
    //
    if (pStar == NULL)
    {
        pWildcardSid->WildcardPos = (DWORD) -1;
        if (ConvertStringSidToSidW(szStringSid, &pWildcardSid->Sid))
            return STATUS_SUCCESS;
        else
            return STATUS_UNSUCCESSFUL;
    }


    //
    // Otherwise this was a String SID that contained a wildcard.
    //
    dwLength = wcslen(szStringSid);
    pBuffer = (LPWSTR) RtlAllocateHeap(RtlProcessHeap(), 0,
                                       sizeof(WCHAR) * (dwLength + 1));
    if (pBuffer != NULL)
    {
        PISID sid1, sid2;
        DWORD dwIndex;
        LPWSTR pNewStar;

        //
        // Copy the String SID and update our 'pStar' pointer to
        // point to the '*' within our newly copied buffer.
        //
        RtlCopyMemory(pBuffer, szStringSid,
                      sizeof(WCHAR) * (dwLength + 1));
        pNewStar = pBuffer + (pStar - szStringSid);


        //
        // Change the '*' to a '0' and convert the SID once.
        //
        *pNewStar = L'0';
        if (ConvertStringSidToSidW(pBuffer, (PSID*) &sid1))
        {
            //
            // Change the '*' to a '1' and convert the SID again.
            //
            *pNewStar = L'1';
            if (ConvertStringSidToSidW(pBuffer, (PSID*) &sid2))
            {
                //
                // Compare the resulting SIDs and find the subauthority that
                // differs only by the '0' or '1' component.  Since we expect
                // the converted SIDs to always be the same except for the
                // one SubAuthority that we changed, we use a lot of asserts.
                //
                ASSERT(sid1->Revision == sid2->Revision);
                ASSERT( RtlEqualMemory(&sid1->IdentifierAuthority.Value[0],
                    &sid2->IdentifierAuthority.Value[0],
                        6 * sizeof(sid1->IdentifierAuthority.Value[0]) ) );
                ASSERT(sid1->SubAuthorityCount == sid2->SubAuthorityCount);
                for (dwIndex = 0; dwIndex < sid1->SubAuthorityCount; dwIndex++)
                {
                    if (sid1->SubAuthority[dwIndex] != sid2->SubAuthority[dwIndex])
                    {
                        ASSERT(sid1->SubAuthority[dwIndex] == 0 &&
                            sid2->SubAuthority[dwIndex] == 1);
                        ASSERT( RtlEqualMemory(&sid1->SubAuthority[dwIndex + 1],
                                    &sid2->SubAuthority[dwIndex + 1],
                                    sizeof(sid1->SubAuthority[0]) *
                                        (sid1->SubAuthorityCount - dwIndex - 1)) );

                        //
                        // The position of the wildcard '*' has been found so
                        // squeeze it out and move the postfix SubAuthorities.
                        //
                        RtlMoveMemory(&sid1->SubAuthority[dwIndex],
                                &sid1->SubAuthority[dwIndex + 1],
                                sizeof(sid1->SubAuthority[0]) *
                                    (sid1->SubAuthorityCount - dwIndex - 1) );
                        sid1->SubAuthorityCount--;


                        //
                        // Fill in the SID_AND_ATTRIBUTES structure that
                        // we'll return to the caller.
                        // In debug builds, we place a marker in the
                        // upper-bits of the member 'Attributes' so that
                        // we can easily assert wildcard SIDs.
                        //
                        pWildcardSid->Sid = (PSID) sid1;
                        pWildcardSid->WildcardPos = dwIndex;


                        //
                        // Free any remaining resources and return success.
                        //
                        LocalFree( (HLOCAL) sid2 );
                        RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
                        return STATUS_SUCCESS;
                    }
                }

                //
                // We should never get here since we expect to find
                // at least the 1 difference that we introduced.
                //
                ASSERT(0);
                LocalFree( (HLOCAL) sid2 );
            }
            LocalFree( (HLOCAL) sid1 );
        }
        RtlFreeHeap(RtlProcessHeap(), 0, pBuffer);
        return STATUS_UNSUCCESSFUL;
    }
    return STATUS_NO_MEMORY;
}


NTSTATUS NTAPI
CodeAuthzpConvertWildcardSidToStringSidW(
    IN PAUTHZ_WILDCARDSID   pWildcardSid,
    OUT PUNICODE_STRING     pUnicodeOutput)
/*++

Routine Description:

    Converts a machine-understandable Wildcard SID into a textual string
    representation of the SID.

Arguments:

    pWildcardSID - pointer to a AUTHZ_WILDCARDSID structure that will be
            filled with information about the boolean sid.

    pUnicodeOutput - output buffer that will be allocated.

Return Value:

    Returns STATUS_SUCCESS on success, or another error code.

--*/
{
    NTSTATUS Status;
    WCHAR UniBuffer[ 256 ];
    UNICODE_STRING LocalString ;

    UCHAR   i;
    ULONG   Tmp;
    LARGE_INTEGER Auth ;

    PISID   iSid = (PISID) pWildcardSid->Sid;  // pointer to opaque structure


    if (!ARGUMENT_PRESENT(pUnicodeOutput)) {
        return STATUS_INVALID_PARAMETER;
    }

    if (RtlValidSid( iSid ) != TRUE) {
        return STATUS_INVALID_SID;
    }

    if ( iSid->Revision != SID_REVISION ) {
        return STATUS_INVALID_SID;
    }

    if (pWildcardSid->WildcardPos != -1 &&
        pWildcardSid->WildcardPos > iSid->SubAuthorityCount) {
        return STATUS_INVALID_SID;
    }

    LocalString.Buffer = UniBuffer;
    LocalString.Length = 0;
    LocalString.MaximumLength = 256 * sizeof(WCHAR);
    RtlAppendUnicodeToString(&LocalString, L"S-1-");

    // adjust the buffer so that the start of it is where the end was.
    // (note that we don't set Length, since RtlIntXXXToUnicodeString
    // directly overwrite from at the start of the buffer)
    LocalString.MaximumLength -= LocalString.Length;
    LocalString.Buffer += LocalString.Length / sizeof(WCHAR);

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){

        //
        // Ugly hex dump.
        //

        Auth.HighPart = (LONG) (iSid->IdentifierAuthority.Value[ 0 ] << 8) +
                        (LONG) iSid->IdentifierAuthority.Value[ 1 ] ;

        Auth.LowPart = (ULONG)iSid->IdentifierAuthority.Value[5]          +
                       (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
                       (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
                       (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);

        Status = RtlInt64ToUnicodeString(Auth.QuadPart, 16, &LocalString);

    } else {

        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);

        Status = RtlIntegerToUnicodeString(
                        Tmp,
                        10,
                        &LocalString);
    }

    if ( !NT_SUCCESS( Status ) )
    {
        return Status;
    }


    if (pWildcardSid->WildcardPos != -1)
    {
        //
        // Stringify the leading sub-authorities within the SID.
        //
        for (i = 0; i < pWildcardSid->WildcardPos; i++ ) {

            // Tack on a hyphen.
            Status = RtlAppendUnicodeToString(&LocalString, L"-");
            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }

            // adjust the buffer so that the start of it is where the end was.
            // (note that we don't set Length, since RtlIntXXXToUnicodeString
            // directly overwrite from at the start of the buffer)
            LocalString.MaximumLength -= LocalString.Length;
            LocalString.Buffer += LocalString.Length / sizeof(WCHAR);

            // Tack on the next subauthority.
            ASSERT( i < iSid->SubAuthorityCount );
            Status = RtlIntegerToUnicodeString(
                            iSid->SubAuthority[ i ],
                            10,
                            &LocalString );

            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }
        }


        //
        // Place the wildcard asterick within the buffer.
        //
        Status = RtlAppendUnicodeToString(&LocalString, L"-*");
        if (!NT_SUCCESS(Status)) {
            return Status;
        }


        //
        // Stringify all remaining sub-authorities within the SID.
        //
        for (; i < iSid->SubAuthorityCount; i++ ) {

            // tack on a hyphen.
            Status = RtlAppendUnicodeToString(&LocalString, L"-");
            if ( !NT_SUCCESS(Status) ) {
                return Status;
            }

            // adjust the buffer so that the start of it is where the end was.
            // (note that we don't set Length, since RtlIntXXXToUnicodeString
            // directly overwrite from at the start of the buffer)
            LocalString.MaximumLength -= LocalString.Length;
            LocalString.Buffer += LocalString.Length / sizeof(WCHAR);

            // tack on the next subauthority.
            Status = RtlIntegerToUnicodeString(
                            iSid->SubAuthority[ i ],
                            10,
                            &LocalString);

            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }
        }
    }
    else
    {
        for (i=0;i<iSid->SubAuthorityCount ;i++ ) {

            // tack on a hyphen.
            Status = RtlAppendUnicodeToString(&LocalString, L"-");
            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }

            // adjust the buffer so that the start of it is where the end was.
            // (note that we don't set Length, since RtlIntXXXToUnicodeString
            // directly overwrite from at the start of the buffer)
            LocalString.MaximumLength -= LocalString.Length;
            LocalString.Buffer += LocalString.Length / sizeof(WCHAR);

            // tack on the next subauthority.
            Status = RtlIntegerToUnicodeString(
                            iSid->SubAuthority[ i ],
                            10,
                            &LocalString );

            if ( !NT_SUCCESS( Status ) ) {
                return Status;
            }
        }
    }

    Status = RtlDuplicateUnicodeString(
            RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE,
            &LocalString, pUnicodeOutput);

    return Status;
}



BOOLEAN NTAPI
CodeAuthzpCompareWildcardSidWithSid(
    IN PAUTHZ_WILDCARDSID pWildcardSid,
    IN PSID pMatchSid
    )
/*++

Routine Description:

    Determines if a given SID matches when compared against a
    wildcard SID pattern.

Arguments:

    pWildcardSid - the wildcard SID pattern to evaluate.

    pMatchSid - the single SID to test.

Return Value:

    Returns TRUE if the specified wildcard SID matches against the
    specified single SID.  Otherwise returns FALSE.

--*/
{
    DWORD wildcardpos;
    ASSERT( ARGUMENT_PRESENT(pWildcardSid) && ARGUMENT_PRESENT(pMatchSid) );
    ASSERT( RtlValidSid(pWildcardSid->Sid) );

    wildcardpos = pWildcardSid->WildcardPos;
    if (wildcardpos != -1)
    {
        // This is a wildcard SID and needs to be handled specially.
        PISID wildsid = (PISID) pWildcardSid->Sid;
        PISID matchsid = (PISID) pMatchSid;

        ASSERT( wildcardpos <= wildsid->SubAuthorityCount );

        if (wildsid->Revision == matchsid->Revision )
        {
            if ( (wildsid->IdentifierAuthority.Value[0] ==
                  matchsid->IdentifierAuthority.Value[0])  &&
                 (wildsid->IdentifierAuthority.Value[1]==
                  matchsid->IdentifierAuthority.Value[1])  &&
                 (wildsid->IdentifierAuthority.Value[2] ==
                  matchsid->IdentifierAuthority.Value[2])  &&
                 (wildsid->IdentifierAuthority.Value[3] ==
                  matchsid->IdentifierAuthority.Value[3])  &&
                 (wildsid->IdentifierAuthority.Value[4] ==
                  matchsid->IdentifierAuthority.Value[4])  &&
                 (wildsid->IdentifierAuthority.Value[5] ==
                  matchsid->IdentifierAuthority.Value[5])
                )
            {
                if (matchsid->SubAuthorityCount >= wildsid->SubAuthorityCount)
                {
                    DWORD Index, IndexDiff;

                    //
                    // Ensure the prefix part of the wildcard matches.
                    //
                    ASSERT(wildcardpos <= matchsid->SubAuthorityCount );
                    for (Index = 0; Index < wildcardpos; Index++) {
                        if (wildsid->SubAuthority[Index] !=
                                matchsid->SubAuthority[Index])
                            return FALSE;
                    }

                    //
                    // Ensure the postfix part of the wildcard matches.
                    //
                    IndexDiff = (matchsid->SubAuthorityCount - wildsid->SubAuthorityCount);
                    for (Index = wildcardpos; Index < wildsid->SubAuthorityCount; Index++) {
                        if (wildsid->SubAuthority[Index] !=
                                matchsid->SubAuthority[Index + IndexDiff])
                            return FALSE;
                    }

                    return TRUE;        // matches okay!
                }
            }
        }
        return FALSE;
    }
    else
    {
        // This is a normal SID so we can compare directly.
        return RtlEqualSid(pWildcardSid->Sid, pMatchSid);
    }
}



BOOLEAN NTAPI
CodeAuthzpSidInWildcardList (
    IN PAUTHZ_WILDCARDSID   WildcardList    OPTIONAL,
    IN ULONG                WildcardCount,
    IN PSID                 SePrincipalSelfSid   OPTIONAL,
    IN PSID                 PrincipalSelfSid   OPTIONAL,
    IN PSID                 Sid
    )
/*++

Routine Description:

    Checks to see if a given SID is in the given list of Wildcards.

    N.B. The code to compute the length of a SID and test for equality
         is duplicated from the security runtime since this is such a
         frequently used routine.

    This function is mostly copied from the SepSidInSidAndAttributes
    found in ntos\se\tokendup.c, except it handles PrincipalSelfSid
    within the list as well as the passed in Sid.  SePrincipalSelfSid
    is also a parameter here, instead of an ntoskrnl global.  also the
    HonorEnabledAttribute argument was added.

Arguments:

    WildcardList - Pointer to the wildcard sid list to be examined

    WildcardCount - Number of entries in the WildcardList array.

    SePrincipalSelfSid - This parameter should optionally be the SID that
        will be replaced with the PrincipalSelfSid if this SID is encountered
        in any ACE.  This SID should be generated from SECURITY_PRINCIPAL_SELF_RID

        The parameter should be NULL if the object does not represent a principal.


    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        SECURITY_PRINCIPAL_SELF_RID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.


    Sid - Pointer to the SID of interest


Return Value:

    A value of TRUE indicates that the SID is in the token, FALSE
    otherwise.

--*/
{
    ULONG i;

    ASSERT( ARGUMENT_PRESENT(Sid) );

    if ( !ARGUMENT_PRESENT(WildcardList) || !WildcardCount ) {
        return FALSE;
    }

    //
    // If Sid is the constant PrincipalSelfSid,
    //  replace it with the passed in PrincipalSelfSid.
    //

    if ( ARGUMENT_PRESENT(PrincipalSelfSid) &&
         ARGUMENT_PRESENT(SePrincipalSelfSid) &&
         RtlEqualSid( SePrincipalSelfSid, Sid ) )
    {
        ASSERT( !RtlEqualSid(SePrincipalSelfSid, PrincipalSelfSid) );
        Sid = PrincipalSelfSid;
    }

    //
    // Scan through the user/groups and attempt to find a match with the
    // specified SID.
    //

    for (i = 0 ; i < WildcardCount ; i++, WildcardList++)
    {
        //
        // If the SID is the principal self SID, then compare it.
        //

        if ( ARGUMENT_PRESENT(SePrincipalSelfSid) &&
             ARGUMENT_PRESENT(PrincipalSelfSid) &&
             WildcardList->WildcardPos == -1 &&
             RtlEqualSid(SePrincipalSelfSid, WildcardList->Sid))
        {
            if (RtlEqualSid( PrincipalSelfSid, Sid ))
                return TRUE;
        }

        //
        // If the Wildcard SID matches the individual SID, then great.
        //

        else if ( CodeAuthzpCompareWildcardSidWithSid(WildcardList, Sid ) )
        {
            return TRUE;
        }
    }

    return FALSE;
}



BOOLEAN NTAPI
CodeAuthzpInvertAndAddSids(
    IN HANDLE                   InAccessToken,
    IN PSID                     InTokenOwner    OPTIONAL,
    IN DWORD                    InvertSidCount,
    IN PAUTHZ_WILDCARDSID       SidsToInvert,
    IN DWORD                    SidsAddedCount  OPTIONAL,
    IN PSID_AND_ATTRIBUTES      SidsToAdd       OPTIONAL,
    OUT DWORD                  *NewDisabledSidCount,
    OUT PSID_AND_ATTRIBUTES    *NewSidsToDisable
    )
/*++

Routine Description:

    Takes an input token and extracts its membership groups.
    A "left outer" set combination (non-intersection) of the
    membership groups with the SidsToInvert parameter.
    Additionally, the SidsToAdd list specifies a list of SIDs
    that will be optionally added to the resulting set.
    The final result is returned within a specified pointer.

Arguments:

    InAccessToken - Input token from which the membership group SIDs
        will be taken from.

    InTokenOwner - Optionally specifies the TokenUser of the specifies
        InAccessToken.  This SID is used to replace any instances of
        SECURITY_PRINCIPAL_SELF_RID  that are encountered in either
        the SidsToInvert or SidsToAdd arrays.  If this value is not
        specified, then no replacements will be made.


    InvertSidCount - Number of SIDs in the SidsToInvert array.

    SidsToInvert - Array of the allowable SIDs that should be kept.
        All of the token's group SIDs that are not one of these
        will be removed from the resulting set.


    SidsAddedCount - Optional number of SIDs in the SidsToAdd array.

    SidsToAdd - Optionally specifies the SIDs that should be
        explicitly added into the resultant set after the


    NewDisabledSidCount - Receives the number of SIDs within the
        final group array.

    NewSidsToDisable - Receives a pointer to the final group array.
        This memory pointer must be freed by the caller with RtlFreeHeap().
        All SID pointers within this resultant array are pointers within
        the contiguous piece of memory that make up the list itself.


Return Value:

    A value of TRUE indicates that the operation was successful,
    FALSE otherwise.

--*/
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    DWORD Index;
    DWORD NewSidTotalSize;
    DWORD NewSidListCount;
    LPBYTE nextFreeByte;
    PSID_AND_ATTRIBUTES NewSidList = NULL;
    PTOKEN_GROUPS tokenGroupsPtr = NULL;
    PSID SePrincipalSelfSid = NULL;


    //
    // Generate the principal self sid value so we know what to replace.
    //
    if (ARGUMENT_PRESENT(InTokenOwner))
    {
        if (!NT_SUCCESS(RtlAllocateAndInitializeSid(&SIDAuth, 1,
            SECURITY_PRINCIPAL_SELF_RID, 0, 0, 0, 0, 0, 0, 0,
            &SePrincipalSelfSid))) goto ExitHandler;
    }


    //
    // Obtain the current SID membership list from the token.
    //
    ASSERT( ARGUMENT_PRESENT(InAccessToken) );
    tokenGroupsPtr = (PTOKEN_GROUPS) CodeAuthzpGetTokenInformation(InAccessToken, TokenGroups);
    if (!tokenGroupsPtr) goto ExitHandler;


    //
    // Edit (in place) the tokenGroups and keep only SIDs that
    // are not also present in SidsToInvert list.
    //
    NewSidTotalSize = 0;
    ASSERT( ARGUMENT_PRESENT(SidsToInvert) );
    for (Index = 0; Index < tokenGroupsPtr->GroupCount; Index++)
    {
        if ( CodeAuthzpSidInWildcardList(
            SidsToInvert,           // the wildcard list
            InvertSidCount,         // number of wildcards
            SePrincipalSelfSid,     // principal self sid to search for
            InTokenOwner,           // principal self sid to replace with
            tokenGroupsPtr->Groups[Index].Sid
            ))
        {
            // SID was found, so we need to remove its
            // SID_AND_ATTRIBUTES entry from the list.
            RtlMoveMemory(&tokenGroupsPtr->Groups[Index],
                    &tokenGroupsPtr->Groups[Index+1],
                    sizeof(SID_AND_ATTRIBUTES) *
                        (tokenGroupsPtr->GroupCount - Index - 1));
            tokenGroupsPtr->GroupCount--;
            Index--;
        } else {
            // This SID should be kept, so remember how big it was.
            NewSidTotalSize += sizeof(SID_AND_ATTRIBUTES) +
                RtlLengthSid(tokenGroupsPtr->Groups[Index].Sid);
        }
    }


    //
    // Determine the space usage for any additional SIDs we need to add.
    //
    if (ARGUMENT_PRESENT(SidsToAdd))
    {
        for (Index = 0; Index < SidsAddedCount; Index++) {
            NewSidTotalSize += sizeof(SID_AND_ATTRIBUTES) +
                RtlLengthSid(SidsToAdd[Index].Sid);
        }
    } else {
        SidsAddedCount = 0;
    }


    //
    // Allocate a fresh SID_AND_ATTRIBUTES array that also includes
    // space for any extra SIDs we need to add.
    //
    ASSERT(NewSidTotalSize > 0);
    NewSidList = (PSID_AND_ATTRIBUTES) RtlAllocateHeap(RtlProcessHeap(),
            0, NewSidTotalSize);
    if (NewSidList == NULL)
        goto ExitHandler;


    //
    // Populate the new SID_AND_ATTRIBUTES array.
    //
    nextFreeByte = ((LPBYTE)NewSidList) + sizeof(SID_AND_ATTRIBUTES) *
            (tokenGroupsPtr->GroupCount + SidsAddedCount);
    NewSidListCount = tokenGroupsPtr->GroupCount;
    for (Index = 0; Index < NewSidListCount; Index++)
    {
        DWORD dwSidLength = RtlLengthSid(tokenGroupsPtr->Groups[Index].Sid);
        ASSERT(nextFreeByte + dwSidLength <= ((LPBYTE)NewSidList) + NewSidTotalSize);

        NewSidList[Index].Sid = (PSID) nextFreeByte;
        NewSidList[Index].Attributes = 0;           // must be zero.
        RtlCopyMemory(nextFreeByte, tokenGroupsPtr->Groups[Index].Sid, dwSidLength);

        nextFreeByte += dwSidLength;
    }
    for (Index = 0; Index < SidsAddedCount; Index++)
    {
        DWORD dwSidLength = RtlLengthSid(SidsToAdd[Index].Sid);
        ASSERT(nextFreeByte + dwSidLength <= ((LPBYTE) NewSidList) + NewSidTotalSize);

        NewSidList[NewSidListCount].Sid = (PSID) nextFreeByte;
        NewSidList[NewSidListCount].Attributes = 0;         // must be zero.
        RtlCopyMemory(nextFreeByte, SidsToAdd[Index].Sid, dwSidLength);

        NewSidListCount++;
        nextFreeByte += dwSidLength;
    }
    ASSERT(nextFreeByte <= ((LPBYTE)NewSidList) + NewSidTotalSize);


    //
    // Release allocated memory, but not the resultant array that we'll return.
    //
    RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) tokenGroupsPtr);

    if (SePrincipalSelfSid != NULL)
        RtlFreeSid(SePrincipalSelfSid);


    //
    // Success, return the result.
    //
    *NewSidsToDisable = NewSidList;
    *NewDisabledSidCount = NewSidListCount;
    return TRUE;


    //
    // Release allocated memory.
    //
ExitHandler:
    if (tokenGroupsPtr != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) tokenGroupsPtr);
    if (NewSidList != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) NewSidList);
    if (SePrincipalSelfSid != NULL)
        RtlFreeSid(SePrincipalSelfSid);

    return FALSE;
}


BOOLEAN NTAPI
CodeAuthzpExpandWildcardList(
    IN HANDLE                   InAccessToken,
    IN PSID                     InTokenOwner   OPTIONAL,
    IN DWORD                    WildcardCount,
    IN PAUTHZ_WILDCARDSID       WildcardList,
    OUT DWORD                  *OutSidCount,
    OUT PSID_AND_ATTRIBUTES    *OutSidList
    )
/*++

Routine Description:

    Takes an input token and extracts its membership groups.
    The specified list of Wildcard SIDs are used to identify
    all matching membership groups and an allocated list of all
    such SIDs are returned.

Arguments:

    InAccessToken - Input token from which the membership group SIDs
        will be taken from.

    InTokenOwner - Optionally specifies the TokenUser of the specifies
        InAccessToken.  This SID is used to replace any instances of
        SECURITY_PRINCIPAL_SELF_RID  that are encountered in either
        the SidsToInvert or SidsToAdd arrays.  If this value is not
        specified, then no replacements will be made.


    WildcardCount - Number of SIDs in the WildcardList array.

    WildcardList - Array of the allowable SIDs that should be kept.
        All of the token's group SIDs that are not one of these
        will be removed from the resulting set.


    OutSidCount - Receives the number of SIDs within the
        final group array.

    OutSidList - Receives a pointer to the final group array.
        This memory pointer must be freed by the caller with RtlFreeHeap().
        All SID pointers within this resultant array are pointers within
        the contiguous piece of memory that make up the list itself.


Return Value:

    A value of TRUE indicates that the operation was successful,
    FALSE otherwise.

--*/
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    DWORD Index;
    DWORD NewSidTotalSize;
    DWORD NewSidListCount;
    LPBYTE nextFreeByte;
    PSID_AND_ATTRIBUTES NewSidList = NULL;
    PTOKEN_GROUPS tokenGroupsPtr = NULL;
    PSID SePrincipalSelfSid = NULL;


    //
    // Generate the principal self sid value so we know what to replace.
    //
    if (ARGUMENT_PRESENT(InTokenOwner))
    {
        if (!NT_SUCCESS(RtlAllocateAndInitializeSid(&SIDAuth, 1,
            SECURITY_PRINCIPAL_SELF_RID, 0, 0, 0, 0, 0, 0, 0,
            &SePrincipalSelfSid))) goto ExitHandler;
    }


    //
    // Obtain the current SID membership list from the token.
    //
    ASSERT( ARGUMENT_PRESENT(InAccessToken) );
    tokenGroupsPtr = (PTOKEN_GROUPS) CodeAuthzpGetTokenInformation(InAccessToken, TokenGroups);
    if (!tokenGroupsPtr) goto ExitHandler;


    //
    // Edit (in place) the tokenGroups and keep only SIDs that
    // are not also present in SidsToInvert list.
    //
    NewSidTotalSize = 0;
    ASSERT( ARGUMENT_PRESENT(WildcardList) );
    for (Index = 0; Index < tokenGroupsPtr->GroupCount; Index++)
    {
        if ( CodeAuthzpSidInWildcardList(
            WildcardList,           // the wildcard list
            WildcardCount,         // number of wildcards
            SePrincipalSelfSid,     // principal self sid to search for
            InTokenOwner,           // principal self sid to replace with
            tokenGroupsPtr->Groups[Index].Sid
            ))
        {
            // This SID should be kept, so remember how big it was.
            NewSidTotalSize += sizeof(SID_AND_ATTRIBUTES) +
                RtlLengthSid(tokenGroupsPtr->Groups[Index].Sid);
        } else {
            // SID was not found, so we need to remove its
            // SID_AND_ATTRIBUTES entry from the list.
            RtlMoveMemory(&tokenGroupsPtr->Groups[Index],
                    &tokenGroupsPtr->Groups[Index+1],
                    sizeof(SID_AND_ATTRIBUTES) *
                        (tokenGroupsPtr->GroupCount - Index - 1));
            tokenGroupsPtr->GroupCount--;
            Index--;
        }
    }


    //
    // Allocate a fresh SID_AND_ATTRIBUTES array that also includes
    // space for any extra SIDs we need to add.
    //
    NewSidList = (PSID_AND_ATTRIBUTES) RtlAllocateHeap(RtlProcessHeap(),
            0, NewSidTotalSize);
    if (NewSidList == NULL)
        goto ExitHandler;


    //
    // Populate the new SID_AND_ATTRIBUTES array.
    //
    nextFreeByte = ((LPBYTE)NewSidList) + sizeof(SID_AND_ATTRIBUTES) *
            tokenGroupsPtr->GroupCount;
    NewSidListCount = tokenGroupsPtr->GroupCount;
    for (Index = 0; Index < NewSidListCount; Index++)
    {
        DWORD dwSidLength = RtlLengthSid(tokenGroupsPtr->Groups[Index].Sid);
        ASSERT(nextFreeByte + dwSidLength <= ((LPBYTE)NewSidList) + NewSidTotalSize);

        NewSidList[Index].Sid = (PSID) nextFreeByte;
        NewSidList[Index].Attributes = 0;           // must be zero.
        RtlCopyMemory(nextFreeByte, tokenGroupsPtr->Groups[Index].Sid, dwSidLength);

        nextFreeByte += dwSidLength;
    }
    ASSERT(nextFreeByte <= ((LPBYTE)NewSidList) + NewSidTotalSize);


    //
    // Release allocated memory, but not the resultant array that we'll return.
    //
    RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) tokenGroupsPtr);

    if (SePrincipalSelfSid != NULL)
        RtlFreeSid(SePrincipalSelfSid);


    //
    // Success, return the result.
    //
    *OutSidList = NewSidList;
    *OutSidCount = NewSidListCount;
    return TRUE;


    //
    // Release allocated memory.
    //
ExitHandler:
    if (tokenGroupsPtr != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) tokenGroupsPtr);
    if (NewSidList != NULL)
        RtlFreeHeap(RtlProcessHeap(), 0, (LPVOID) NewSidList);
    if (SePrincipalSelfSid != NULL)
        RtlFreeSid(SePrincipalSelfSid);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\accctrl2\src\trustee.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       TRUSTEE.CXX
//
//  Contents:   Implements the trustee support functions
//
//  History:    04-Sep-96       MacM        Created
//
//  Notes:      Trustee functions taken from DaveMont code:
//                      \windows\base\accctrl\src\helper.cxx
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

MARTA_NTMARTA_INFO   gNtMartaInfo;
CRITICAL_SECTION     NtMartaLoadCritical;

//+---------------------------------------------------------------------------
//
//  Function:   MartaInitialize
//
//  Synopsis:   Initializes MARTA.
//
//  Arguments:  None
//
//  Returns:    TRUE                --  Success
//              FALSE               --  Failure
//
//----------------------------------------------------------------------------
BOOL
MartaInitialize()
{
    NTSTATUS Status ;

    gAccProviders.fOptions = 0;
    gAccProviders.cProviders = 0;
    gNtMartaInfo.hDll = 0;

    Status = RtlInitializeCriticalSection( &gAccProviders.ProviderLoadLock );

    if  ( !NT_SUCCESS( Status ) ) {
        return FALSE ;
    }

    Status = RtlInitializeCriticalSection( &NtMartaLoadCritical );

    if  ( !NT_SUCCESS( Status ) ) {
        return FALSE ;
    }

    return(TRUE);
}




//+---------------------------------------------------------------------------
//
//  Function:   MartaDllInitialize
//
//  Synopsis:   Initializes MARTA.  This will happen during host DLL load time.
//
//  Arguments:  None
//
//  Returns:    TRUE                --  Success
//              FALSE               --  Failure
//
//----------------------------------------------------------------------------
BOOL
MartaDllInitialize(IN   HINSTANCE   hMod,
                   IN   DWORD       dwReason,
                   IN   PVOID       pvReserved)
{
    if(dwReason == DLL_PROCESS_ATTACH)
    {
        return(MartaInitialize());
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        AccProvUnload();
        DeleteCriticalSection( &gAccProviders.ProviderLoadLock );

        DeleteCriticalSection( &NtMartaLoadCritical );
    }

    return(TRUE);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpLoadMartaFunctions
//
//  Synopsis:   Loads the function pointer table for the NTMARTA functions.
//
//  Arguments:  None
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
AccProvpLoadMartaFunctions()
{
    DWORD   dwErr = ERROR_SUCCESS;
    HMODULE hDll;

    //
    // Do this here so we can get out fast in the normal
    // case.
    //

    if(gNtMartaInfo.hDll != NULL)
    {
        return(ERROR_SUCCESS);
    }

    //
    // We have to load the library _before_ entering the critsec to prevent 
    // a deadlock in case ntmarta functions are called from dllmain.
    //
    // Thread 1: Calls ntmarta function from dllmain of another dll and is 
    //           holding the loader lock. This thread now waits on the critsec.
    // Thread 2: Calls ntmarta function and grabs the critsec before thread 1
    //           can get there. This thread will hang since it can not get the
    //           loader lock.
    //

    hDll = LoadLibrary(L"NTMARTA.DLL");

    if(hDll == NULL)
    {
        dwErr = GetLastError();
        return(dwErr);
    }

    //
    // Try to load the entrypoints
    //

    LOAD_ENTRYPT(gNtMartaInfo.pfrFreeIndexArray,
                 pfNTMartaFreeIndexArray,
                 hDll,
                 "AccFreeIndexArray");

    LOAD_ENTRYPT(gNtMartaInfo.pfrTreeResetNamedSecurityInfo,
                 pfNTMartaTreeResetNamedSecurityInfo,
                 hDll,
                 "AccTreeResetNamedSecurityInfo");

    LOAD_ENTRYPT(gNtMartaInfo.pfrGetInheritanceSource,
                 pfNTMartaGetInheritanceSource,
                 hDll,
                 "AccGetInheritanceSource");

    LOAD_ENTRYPT(gNtMartaInfo.pfTrustee,
                 pfNTMartaLookupTrustee,
                 hDll,
                 "AccLookupAccountTrustee");

    LOAD_ENTRYPT(gNtMartaInfo.pfrGetNamedRights,
                 pfNTMartaGetNamedRights,
                 hDll,
                 "AccRewriteGetNamedRights");

    LOAD_ENTRYPT(gNtMartaInfo.pfrSetNamedRights,
                 pfNTMartaSetNamedRights,
                 hDll,
                 "AccRewriteSetNamedRights");

    LOAD_ENTRYPT(gNtMartaInfo.pfrGetHandleRights,
                 pfNTMartaGetHandleRights,
                 hDll,
                 "AccRewriteGetHandleRights");

    LOAD_ENTRYPT(gNtMartaInfo.pfrSetHandleRights,
                 pfNTMartaSetHandleRights,
                 hDll,
                 "AccRewriteSetHandleRights");

    LOAD_ENTRYPT(gNtMartaInfo.pfrSetEntriesInAcl,
                 pfNTMartaSetEntriesInAcl,
                 hDll,
                 "AccRewriteSetEntriesInAcl");

    LOAD_ENTRYPT(gNtMartaInfo.pfrGetExplicitEntriesFromAcl,
                 pfNTMartaGetExplicitEntriesFromAcl,
                 hDll,
                 "AccRewriteGetExplicitEntriesFromAcl");

    LOAD_ENTRYPT(gNtMartaInfo.pfName,
                 pfNTMartaLookupName,
                 hDll,
                 "AccLookupAccountName");

    LOAD_ENTRYPT(gNtMartaInfo.pfSid,
                 pfNTMartaLookupSid,
                 hDll,
                 "AccLookupAccountSid");

    LOAD_ENTRYPT(gNtMartaInfo.pfSetAList,
                 pfNTMartaSetAList,
                 hDll,
                 "AccSetEntriesInAList");

    LOAD_ENTRYPT(gNtMartaInfo.pfAToSD,
                 pfNTMartaAToSD,
                 hDll,
                 "AccConvertAccessToSecurityDescriptor");

    LOAD_ENTRYPT(gNtMartaInfo.pfSDToA,
                 pfNTMartaSDToA,
                 hDll,
                 "AccConvertSDToAccess");

    LOAD_ENTRYPT(gNtMartaInfo.pfGetAccess,
                 pfNTMartaGetAccess,
                 hDll,
                 "AccGetAccessForTrustee");

    LOAD_ENTRYPT(gNtMartaInfo.pfAclToA,
                 pfNTMartaAclToA,
                 hDll,
                 "AccConvertAclToAccess");

    LOAD_ENTRYPT(gNtMartaInfo.pfGetExplicit,
                 pfNTMartaGetExplicit,
                 hDll,
                 "AccGetExplicitEntries");

    EnterCriticalSection( &NtMartaLoadCritical );

    //
    // If the global is non-null, another thread succeeded in loading ntmarta 
    // before us. Return after decrementing the refcount on the library.
    //

    if(gNtMartaInfo.hDll != NULL)
    {
        LeaveCriticalSection( &NtMartaLoadCritical );
        FreeLibrary(hDll);
        return(ERROR_SUCCESS);
    }

    gNtMartaInfo.hDll = hDll;

    LeaveCriticalSection( &NtMartaLoadCritical );

    SetLastError(ERROR_SUCCESS);

Error:

    dwErr = GetLastError();

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvUnload
//
//  Synopsis:   Unlaods the various loaded dlls
//
//  Arguments:  None
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
AccProvUnload()
{
    for(ULONG iIndex = 0; iIndex < gAccProviders.cProviders; iIndex++)
    {
        if(gAccProviders.pProvList[iIndex].hDll != NULL)
        {
            FreeLibrary(gAccProviders.pProvList[iIndex].hDll);
        }
    }

    if(gNtMartaInfo.hDll != NULL)
    {
        FreeLibrary(gNtMartaInfo.hDll);
    }

    //
    // Finally, deallocate any memory
    //
    AccProvpFreeProviderList(&gAccProviders);
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithNameW
//
//  Synopsis:   Builds a TRUSTEE from a name
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pName]         --  Name to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildTrusteeWithNameW( IN OUT PTRUSTEE_W  pTrustee,
                       IN     LPWSTR      pName)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_NAME;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = pName;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithNameA
//
//  Synopsis:   Builds a TRUSTEE from a name
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pName]         --  Name to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildTrusteeWithNameA( IN OUT PTRUSTEE_A  pTrustee,
                       IN     LPSTR       pName)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_NAME;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = pName;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildImpersonateTrusteeWithNameW
//
//  Synopsis:   Builds an impersonation TRUSTEE from existing trustees
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pImpersonateTurstee]   The impersonation trustee
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildImpersonateTrusteeW( IN OUT PTRUSTEE_W  pTrustee,
                          IN     PTRUSTEE_W  pImpersonateTrustee)
{
    pTrustee->pMultipleTrustee = pImpersonateTrustee;
    pTrustee->MultipleTrusteeOperation = TRUSTEE_IS_IMPERSONATE;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildImpersonateTrusteeWithNameA
//
//  Synopsis:   Builds an impersonation TRUSTEE from existing trustees
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pImpersonateTurstee]   The impersonation trustee
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildImpersonateTrusteeA( IN OUT PTRUSTEE_A  pTrustee,
                          IN     PTRUSTEE_A  pImpersonateTrustee)
{
    pTrustee->pMultipleTrustee = pImpersonateTrustee;
    pTrustee->MultipleTrusteeOperation = TRUSTEE_IS_IMPERSONATE;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithSidW
//
//  Synopsis:   Builds a TRUSTEE from a sid
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pSid]          --  Sid to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildTrusteeWithSidW( IN OUT PTRUSTEE_W  pTrustee,
                      IN     PSID        pSid)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_SID;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPWSTR)pSid;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithSidA
//
//  Synopsis:   Builds a TRUSTEE from a sid
//
//  Arguments:  [OUT pTrustee]      --  Trustee to initialize
//              [IN  pSid]          --  Sid to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
WINAPI
BuildTrusteeWithSidA( IN OUT PTRUSTEE_A  pTrustee,
                      IN     PSID        pSid)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_SID;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPSTR)pSid;
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithObjectsAndSidA
//
//  Synopsis:   Builds a TRUSTEE from a name
//
//  Arguments:  [OUT pTrustee]             -- Trustee to initialize
//              [IN  pObjSid]              -- ObjSid struct for initialization
//              [IN  pObjectGuid]          -- Guid pointer for initialization
//              [IN  pInheritedObjectGuid] -- Guid pointer for initialization
//              [IN  pSid]                 --  Sid to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------

VOID
WINAPI
BuildTrusteeWithObjectsAndSidA(IN OUT PTRUSTEE_A         pTrustee,
                               IN     POBJECTS_AND_SID   pObjSid,
                               IN     GUID             * pObjectGuid,
                               IN     GUID             * pInheritedObjectGuid,
                               IN     PSID               pSid)
{
    GUID ZeroGuid = {0, 0, 0, 0};

    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_OBJECTS_AND_SID;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPSTR)pObjSid;

    pObjSid->ObjectsPresent = 0;
    pObjSid->ObjectTypeGuid = ZeroGuid;
    pObjSid->InheritedObjectTypeGuid = ZeroGuid;

    if (NULL != pObjectGuid)
    {
        pObjSid->ObjectsPresent |= ACE_OBJECT_TYPE_PRESENT;
        pObjSid->ObjectTypeGuid = *pObjectGuid;
    }

    if (NULL != pInheritedObjectGuid)
    {
        pObjSid->ObjectsPresent |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
        pObjSid->InheritedObjectTypeGuid = *pInheritedObjectGuid;
    }

    pObjSid->pSid = (SID *) pSid;
}


//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithObjectsAndSidW
//
//  Synopsis:   Builds a TRUSTEE from a name
//
//  Arguments:  [OUT pTrustee]             -- Trustee to initialize
//              [IN  pObjSid]              -- ObjSid struct for initialization
//              [IN  pObjectGuid]          -- Guid pointer for initialization
//              [IN  pInheritedObjectGuid] -- Guid pointer for initialization
//              [IN  pSid]                 --  Sid to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------

VOID
WINAPI
BuildTrusteeWithObjectsAndSidW(IN OUT PTRUSTEE_W         pTrustee,
                               IN     POBJECTS_AND_SID   pObjSid,
                               IN     GUID             * pObjectGuid,
                               IN     GUID             * pInheritedObjectGuid,
                               IN     PSID               pSid)
{
    GUID ZeroGuid = {0, 0, 0, 0};

    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_OBJECTS_AND_SID;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPWSTR)pObjSid;

    pObjSid->ObjectsPresent = 0;
    pObjSid->ObjectTypeGuid = ZeroGuid;
    pObjSid->InheritedObjectTypeGuid = ZeroGuid;

    if (NULL != pObjectGuid)
    {
        pObjSid->ObjectsPresent |= ACE_OBJECT_TYPE_PRESENT;
        pObjSid->ObjectTypeGuid = *pObjectGuid;
    }

    if (NULL != pInheritedObjectGuid)
    {
        pObjSid->ObjectsPresent |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
        pObjSid->InheritedObjectTypeGuid = *pInheritedObjectGuid;
    }

    pObjSid->pSid = (SID *) pSid;
}

//+---------------------------------------------------------------------------
//
//  Function:   BuildTrusteeWithObjectsAndSidW
//
//  Synopsis:   Builds a TRUSTEE from a name
//
//  Arguments:[OUT pTrustee]                 -- Trustee to initialize
//            [IN  pObjName]                 -- ObjName struct for initialization
//            [IN  pObjectType]              -- Object type for initialization
//            [IN  pObjectTypeName]          -- Guid name for initialization
//            [IN  pInheritedObjectTypeName] -- Guid name for initialization
//            [IN  Name]                     --  Name to use for initialization
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------

VOID
WINAPI
BuildTrusteeWithObjectsAndNameA(IN OUT PTRUSTEE_A          pTrustee,
                                IN     POBJECTS_AND_NAME_A pObjName,
                                IN     SE_OBJECT_TYPE      ObjectType,
                                IN     LPSTR               ObjectTypeName,
                                IN     LPSTR               InheritedObjectTypeName,
                                IN     LPSTR               Name)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_OBJECTS_AND_NAME;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPSTR)pObjName;

    pObjName->ObjectsPresent = 0;
    pObjName->ObjectType = ObjectType;
    pObjName->ObjectTypeName = ObjectTypeName;
    pObjName->InheritedObjectTypeName = InheritedObjectTypeName;

    if (NULL != ObjectTypeName)
    {
        pObjName->ObjectsPresent |= ACE_OBJECT_TYPE_PRESENT;
    }

    if (NULL != InheritedObjectTypeName)
    {
        pObjName->ObjectsPresent |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
    }

    pObjName->ptstrName = Name;
}

VOID
WINAPI
BuildTrusteeWithObjectsAndNameW(IN OUT PTRUSTEE_W          pTrustee,
                                IN     POBJECTS_AND_NAME_W pObjName,
                                IN     SE_OBJECT_TYPE      ObjectType,
                                IN     LPWSTR              ObjectTypeName,
                                IN     LPWSTR              InheritedObjectTypeName,
                                IN     LPWSTR              Name)
{
    pTrustee->pMultipleTrustee = NULL;
    pTrustee->MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    pTrustee->TrusteeForm = TRUSTEE_IS_OBJECTS_AND_NAME;
    pTrustee->TrusteeType = TRUSTEE_IS_UNKNOWN;
    pTrustee->ptstrName = (LPWSTR)pObjName;

    pObjName->ObjectsPresent = 0;
    pObjName->ObjectType = ObjectType;
    pObjName->ObjectTypeName = ObjectTypeName;
    pObjName->InheritedObjectTypeName = InheritedObjectTypeName;

    if (NULL != ObjectTypeName)
    {
        pObjName->ObjectsPresent |= ACE_OBJECT_TYPE_PRESENT;
    }

    if (NULL != InheritedObjectTypeName)
    {
        pObjName->ObjectsPresent |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
    }

    pObjName->ptstrName = Name;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeNameW
//
//  Synopsis:   Gets the trustee name from the trustee
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    Ptr to the trustee's name
//
//----------------------------------------------------------------------------
LPWSTR
WINAPI
GetTrusteeNameW( IN PTRUSTEE_W  pTrustee)
{
    if(pTrustee->ptstrName != NULL)
    {
        return(pTrustee->ptstrName);
    }
    else
    {
        return(NULL);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeNameA
//
//  Synopsis:   Gets the trustee name from the trustee
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    Ptr to the trustee's name
//
//----------------------------------------------------------------------------
LPSTR
WINAPI
GetTrusteeNameA( IN PTRUSTEE_A  pTrustee)
{
    if(pTrustee->ptstrName != NULL)
    {
        return(pTrustee->ptstrName);
    }
    else
    {
        return(NULL);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeTypeW
//
//  Synopsis:   Gets the type of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    TrusteeType
//
//----------------------------------------------------------------------------
TRUSTEE_TYPE
WINAPI
GetTrusteeTypeW( IN PTRUSTEE_W  pTrustee)
{
    if(pTrustee  != NULL)
    {
        return(pTrustee->TrusteeType);
    }

    return(TRUSTEE_IS_UNKNOWN);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeTypeA
//
//  Synopsis:   Gets the type of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    TrusteeType
//
//----------------------------------------------------------------------------
TRUSTEE_TYPE
WINAPI
GetTrusteeTypeA( IN PTRUSTEE_A  pTrustee)
{
    if(pTrustee  != NULL)
    {
        return(pTrustee->TrusteeType);
    }

    return(TRUSTEE_IS_UNKNOWN);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeFormW
//
//  Synopsis:   Gets the form of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    TrusteeForm
//
//----------------------------------------------------------------------------
TRUSTEE_FORM
WINAPI
GetTrusteeFormW( IN PTRUSTEE_W  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->TrusteeForm);
    }

    return(TRUSTEE_BAD_FORM);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeFormA
//
//  Synopsis:   Gets the form of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    TrusteeForm
//
//----------------------------------------------------------------------------
TRUSTEE_FORM
WINAPI
GetTrusteeFormA( IN PTRUSTEE_A  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->TrusteeForm);
    }

    return(TRUSTEE_BAD_FORM);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetMultipleTrusteeOperationW
//
//  Synopsis:   Gets the multiple trustee operation of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    mutliple trustee operation
//
//----------------------------------------------------------------------------
MULTIPLE_TRUSTEE_OPERATION
WINAPI
GetMultipleTrusteeOperationW( IN PTRUSTEE_W  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->MultipleTrusteeOperation);
    }
    return(NO_MULTIPLE_TRUSTEE);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetMultipleTrusteeOperationA
//
//  Synopsis:   Gets the multiple trustee operation of the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    mutliple trustee operation
//
//----------------------------------------------------------------------------
MULTIPLE_TRUSTEE_OPERATION
WINAPI
GetMultipleTrusteeOperationA( IN PTRUSTEE_A  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->MultipleTrusteeOperation);
    }
    return(NO_MULTIPLE_TRUSTEE);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetMultipleTrusteeW
//
//  Synopsis:   Gets the impersonate trustee from the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    Impersonate trustee
//
//----------------------------------------------------------------------------
PTRUSTEE_W
WINAPI
GetMultipleTrusteeW( IN PTRUSTEE_W  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->pMultipleTrustee);
    }

    return(NULL);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetMultipleTrusteeA
//
//  Synopsis:   Gets the impersonate trustee from the trustee structure
//
//  Arguments:  [IN  pTrustee]      --  Trustee to process
//
//  Returns:    Impersonate trustee
//
//----------------------------------------------------------------------------
PTRUSTEE_A
WINAPI
GetMultipleTrusteeA( IN PTRUSTEE_A  pTrustee)
{
    if(pTrustee != NULL)
    {
        return(pTrustee->pMultipleTrustee);
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\accctrl2\src\convert.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       CONVERT.CXX
//
//  Contents:   Conversion routines for converting back and forth between
//              ANSI and UNICODE and NT4 and NT5 style structures
//
//  History:    14-Sep-96       MacM        Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   ConvertStringWToStringA
//
//  Synopsis:   Allocates a buffer and coverts the UNICODE string ANSI
//
//  Arguments:  [IN  pwszString]    --  String to be converted
//              [OUT ppszString]    --  Where to return the converted string
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_PARAMETER A NULL destination string was given
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertStringWToStringA(IN  PWSTR           pwszString,
                        OUT PSTR           *ppszString)
{
    if(ppszString == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Simply size the string, do the allocation, and use the c runtimes
    // to do the conversion
    //
    if(pwszString == NULL)
    {
        *ppszString = NULL;
    }
    else
    {
        ULONG cLen = wcslen(pwszString);
        *ppszString = (PSTR)LocalAlloc(LMEM_FIXED,sizeof(CHAR) *
                                  (wcstombs(NULL, pwszString, cLen + 1) + 1));
        if(*ppszString  != NULL)
        {
             wcstombs(*ppszString,
                      pwszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}





//+---------------------------------------------------------------------------
//
//  Function:   ConvertStringAToStringW
//
//  Synopsis:   Allocates a buffer and coverts the ANSI string to UNICODE
//
//  Arguments:  [IN  pszString]     --  String to be converted
//              [OUT ppwszString]   --  Where to return the converted string
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_PARAMETER A NULL destination string was given
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertStringAToStringW(IN  PSTR            pszString,
                        OUT PWSTR          *ppwszString)
{
    if(ppwszString == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    if(pszString == NULL)
    {
        *ppwszString = NULL;
    }
    else
    {
        ULONG cLen = strlen(pszString);
        *ppwszString = (PWSTR)LocalAlloc(LMEM_FIXED,sizeof(WCHAR) *
                                  (mbstowcs(NULL, pszString, cLen + 1) + 1));
        if(*ppwszString  != NULL)
        {
             mbstowcs(*ppwszString,
                      pszString,
                      cLen + 1);
        }
        else
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(ERROR_SUCCESS);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetTrusteeWForSid
//
//  Synopsis:   Initializes the WIDE version of the trustee structure
//              with the NAME represented by the SID
//
//  Arguments:  [IN  pSid]          --  Trustee to be converted
//              [OUT pTrusteeW]     --  Trustee to be initialized
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
GetTrusteeWForSid(PSID       pSid,
                  PTRUSTEEW  pTrusteeW)
{
    DWORD   dwErr = ERROR_SUCCESS;
    SID_NAME_USE    SNE;
    PWSTR           pwszDomain;
    PWSTR           pwszName;

    //
    // First, lookup the name
    //
    dwErr = (*gNtMartaInfo.pfName)(NULL,
                                   (PSID)pSid,
                                   &pwszName,
                                   &pwszDomain,
                                   &SNE);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Then, initialize the rest of the strucutre
        LocalFree(pwszDomain);
        pTrusteeW->ptstrName = pwszName;
        pTrusteeW->TrusteeForm = TRUSTEE_IS_NAME;

        if(SNE == SidTypeUnknown)
        {
            pTrusteeW->TrusteeType = TRUSTEE_IS_UNKNOWN;
        }
        else
        {
            pTrusteeW->TrusteeType = (TRUSTEE_TYPE)(SNE);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertTrusteeAToTrusteeW
//
//  Synopsis:   Converts an ANSI trustee to a UNICODE trustee, and optionally
//              updates the UNICODE trustee to be name based
//
//  Arguments:  [IN  pTrusteeA]     --  Trustee to convert
//              [OUT pTrusteeW]     --  Where to store the results
//              [IN  fSidToName]    --  If TRUE, convert the trustee sid to
//                                      a name
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A NULL destination string was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ConvertTrusteeAToTrusteeW(IN  PTRUSTEE_A    pTrusteeA,
                          OUT PTRUSTEE_W    pTrusteeW,
                          IN  BOOL          fSidToName)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pTrusteeA == NULL || pTrusteeW == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    memcpy(pTrusteeW,
           pTrusteeA,
           sizeof(TRUSTEE));

    if(pTrusteeA->TrusteeForm == TRUSTEE_IS_NAME)
    {
        //
        // First, copy off the old string
        //
        PWSTR   pwszNewName = NULL;

        dwErr = ConvertStringAToStringW(pTrusteeA->ptstrName,
                                        &pwszNewName);
        if(dwErr == ERROR_SUCCESS)
        {
            pTrusteeW->ptstrName = pwszNewName;
        }
    }
    else
    {
        //
        // See if we need to lookup the account name
        //
        if(fSidToName == TRUE)
        {
            dwErr = GetTrusteeWForSid((PSID)pTrusteeA->ptstrName,
                                      pTrusteeW);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertTrusteeWToTrusteeA
//
//  Synopsis:   Inverse of the last function
//
//  Arguments:  [IN  pTrusteeW]     --  Trustee to convert
//              [OUT pTrusteeA]     --  Where to store the results
//              [IN  fSidToName]    --  If TRUE, convert the trustee sid to
//                                      a name
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_INVALID_PARAMETER A NULL destination string was given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ConvertTrusteeWToTrusteeA(IN  PTRUSTEE_W    pTrusteeW,
                          OUT PTRUSTEE_A    pTrusteeA,
                          IN  BOOL          fSidToName)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pTrusteeA == NULL || pTrusteeW == NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    memcpy(pTrusteeA,
           pTrusteeW,
           sizeof(TRUSTEE));

    PTRUSTEE_W  pActiveTrusteeW = pTrusteeW;
    TRUSTEE_W   TrusteeW;

    //
    // See if we need to convert to a name from a sid
    //
    if(pTrusteeW->TrusteeForm == TRUSTEE_IS_SID && fSidToName == TRUE)
    {
        pActiveTrusteeW = &TrusteeW;
        pActiveTrusteeW->ptstrName = NULL;
        dwErr = GetTrusteeWForSid((PSID)pTrusteeW->ptstrName,
                                  pActiveTrusteeW);
    }

    if(pActiveTrusteeW->TrusteeForm == TRUSTEE_IS_NAME)
    {
        //
        // First, copy off the old string
        //
        PSTR   pszNewName = NULL;

        dwErr = ConvertStringWToStringA(pActiveTrusteeW->ptstrName,
                                        &pszNewName);
        if(dwErr == ERROR_SUCCESS)
        {
            pTrusteeA->ptstrName = pszNewName;
        }
    }

    if(pActiveTrusteeW != pTrusteeW)
    {
        LocalFree(pActiveTrusteeW->ptstrName);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CompStringNode
//
//  Synopsis:   Compares a StringNode to a string pointer to see if they are
//              equal.  Used by the CList class for the ConvertAList*
//              rountines.
//
//  Arguments:  [IN pvValue]    --      String to look for
//              [IN pvNode]     --      List node to compare against
//
//  Returns:    TRUE            --      Nodes equal
//              FALSE           --      Nodes not equal
//
//----------------------------------------------------------------------------
BOOL  CompStringNode(IN  PVOID     pvValue,
                     IN  PVOID     pvNode)
{
    return(pvNode == pvValue);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAListWToAlistAInplace
//
//  Synopsis:   Converts an ACTRL_ACCESSW structure to a ACTRL_ACCESSA
//              structure inplace.  It simply changes all of the UNICODE
//              strings to ANSI strings.
//
//  Arguments:  [IN  pAListW]       --  Structure to convert
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ConvertAListWToAlistAInplace(IN OUT  PACTRL_ACCESSW     pAListW)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CSList  StringList(NULL);

    //
    // Ok, we'll start processing each particular entry.. When we find a
    // string, will try to insert it into our temporary list, if it doesn't
    // already exist..
    //
    for(ULONG iProps = 0;
        iProps < pAListW->cEntries && dwErr == ERROR_SUCCESS &&
        pAListW->pPropertyAccessList != NULL;
        iProps++)
    {
        //
        // First, the property name...
        //
        dwErr = StringList.InsertIfUnique((PWSTR)
                            pAListW->pPropertyAccessList[iProps].lpProperty,
                            CompStringNode);
        if(dwErr == ERROR_SUCCESS)
        {
            PACTRL_ACCESS_ENTRY_LIST  pAEL =
                        pAListW->pPropertyAccessList[iProps].pAccessEntryList;

            //
            // Then the access entry strings
            //
            for(ULONG iEntry = 0;
                pAEL && iEntry < pAEL->cEntries && dwErr == ERROR_SUCCESS &&
                pAEL->pAccessList != NULL;
                iEntry++)
            {
                dwErr = StringList.InsertIfUnique((PWSTR)
                                pAEL->pAccessList[iEntry].Trustee.ptstrName,
                                CompStringNode);
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = StringList.InsertIfUnique((PWSTR)
                                pAEL->pAccessList[iEntry].lpInheritProperty,
                                CompStringNode);
                }
            }
        }
    }

    //
    // Now, if all that worked, we'll go through and do the conversion
    //
    if(dwErr == ERROR_SUCCESS)
    {
        StringList.Reset();

        for(ULONG i = 0; i < StringList.QueryCount(); i++)
        {
            PWSTR   pwszCurrent = (PWSTR)StringList.NextData();
            if(pwszCurrent == NULL)
            {
                continue;
            }

            PSTR    pszCurrent = (PSTR)pwszCurrent;

#ifndef NO_DLL
            wcstombs(pszCurrent, pwszCurrent, wcslen(pwszCurrent) + 1);
#else
            while(*pwszCurrent != NULL)
            {
                wctomb(pszCurrent, *pwszCurrent);
                pszCurrent++;
                pwszCurrent++;
            }

            *pszCurrent = '\0';
#endif
        }
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   CleanupConvertNode
//
//  Synopsis:   Deletes a node from the list.  It restores the original
//              string and does a LocalFree on the new string
//
//  Arguments:  [IN pvNode]     --      Node to be removed
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
CleanupConvertNode(PVOID    pvNode)
{
    PCONVERT_ALIST_NODE pCAN = (PCONVERT_ALIST_NODE)pvNode;

    if(pCAN->ppwszInfoAddress != NULL)
    {
        LocalFree(*(pCAN->ppwszInfoAddress));
        *pCAN->ppwszInfoAddress = pCAN->pwszOldValue;
    }

    if(pCAN->pulVal1Address != NULL)
    {
        *pCAN->pulVal1Address = pCAN->ulOldVal1;
    }

    if(pCAN->pulVal2Address != NULL)
    {
        *pCAN->pulVal2Address = pCAN->ulOldVal2;
    }

    LocalFree(pCAN);
}



//+---------------------------------------------------------------------------
//
//  Function:   AllocAndInsertCNode
//
//  Synopsis:   Allocates a new coversion node and inserts into the linked
//              list.  This involves saving the old string pointer, and
//              replacing it's value with the specified new value.  Upon
//              deletion, this process is reversed.
//
//  Arguments:  [IN  SaveList]      --  List to insert into
//              [IN  ppwszAddress]  --  Address of the string to be changed
//              [IN  pwszOldValue]  --  Old value of the string
//              [IN  pwszNewValue]  --  New value of the string to be set
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
AllocAndInsertCNode(CSList      &SaveList,
                    PWSTR      *ppwszAddress,
                    PWSTR       pwszOldValue,
                    PWSTR       pwszNewValue,
                    PULONG      pulVal1Address,
                    ULONG       ulOldVal1,
                    ULONG       ulNewVal1,
                    PULONG      pulVal2Address,
                    ULONG       ulOldVal2,
                    ULONG       ulNewVal2)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PCONVERT_ALIST_NODE pCAN = (PCONVERT_ALIST_NODE)
                                       LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                                  sizeof(CONVERT_ALIST_NODE));
    if(pCAN == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pCAN->ppwszInfoAddress = ppwszAddress;
        pCAN->pwszOldValue     = pwszOldValue;

        *ppwszAddress = pwszNewValue;

        if(pulVal1Address != NULL)
        {
            pCAN->pulVal1Address = pulVal1Address;
            pCAN->ulOldVal1 = ulOldVal1;
            *pulVal1Address = ulNewVal1;
        }
        else
        {
            pCAN->pulVal1Address = NULL;
        }

        if(pulVal2Address != NULL)
        {
            pCAN->pulVal2Address = pulVal2Address;
            pCAN->ulOldVal2 = ulOldVal2;
            *pulVal2Address = ulNewVal2;
        }
        else
        {
            pCAN->pulVal2Address = NULL;
        }

        dwErr = SaveList.Insert((PVOID)pCAN);

        if(dwErr != ERROR_SUCCESS)
        {
            LocalFree(pCAN);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAListToNamedBasedW
//
//  Synopsis:   Goes through the give access list and converts all of the
//              TRUSTEES to named base, if they are not already
//
//  Arguments:  [IN  pAListW]       --  List to be changed
//              [IN  ChangedList]   --  Linked list class to save all of the
//                                      changes
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertAListToNamedBasedW(IN  PACTRL_ACCESSW pAListW,
                          IN  CSList&        ChangedList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pAListW == NULL)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Ok, here, since our provider doesn't understand SIDs, we'll have to
    // go through and change any SIDs that we find to account names.  This
    // will happen by simply doing a lookup.
    //
    for(ULONG iIndex = 0;
        iIndex < pAListW->cEntries && dwErr == ERROR_SUCCESS &&
        pAListW->pPropertyAccessList != NULL;
        iIndex++)
    {
        for(ULONG iAE = 0;
            iAE < pAListW->pPropertyAccessList[iIndex].pAccessEntryList->
                                                                   cEntries &&
            pAListW->pPropertyAccessList[iIndex].pAccessEntryList->
                                                          pAccessList != NULL;
            iAE++)
        {
            //
            // If it's SID based, we'll have to lookup the name...
            //
            if(pAListW->pPropertyAccessList[iIndex].pAccessEntryList->
                       pAccessList[iAE].Trustee.TrusteeForm == TRUSTEE_IS_SID)
            {
                PACTRL_ACCESS_ENTRY pAE = (PACTRL_ACCESS_ENTRY)&(
                                        pAListW->pPropertyAccessList[iIndex].
                                        pAccessEntryList->pAccessList[iAE]);
                PSID   pOldSid = (PSID)pAE->Trustee.ptstrName;
                TRUSTEE_TYPE    OldType = pAE->Trustee.TrusteeType;

                dwErr = GetTrusteeWForSid((PSID)pAE->Trustee.ptstrName,
                                          &(pAE->Trustee));
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AllocAndInsertCNode(ChangedList,
                                            &(pAE->Trustee.ptstrName),
                                            (PWSTR)pOldSid,
                                            pAE->Trustee.ptstrName,
                                            (PULONG)&(pAE->Trustee.TrusteeType),
                                            (ULONG)OldType,
                                            (ULONG)pAE->Trustee.TrusteeType,
                                            (PULONG)&(pAE->Trustee.TrusteeForm),
                                            (ULONG)TRUSTEE_IS_SID,
                                            (ULONG)TRUSTEE_IS_NAME);
                    if(dwErr != ERROR_SUCCESS)
                    {
                        LocalFree(pAE->Trustee.ptstrName);
                        pAE->Trustee.ptstrName = (PWSTR)pOldSid;
                    }
                }

            }

            if(dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }

    }

    return(dwErr);
}






//+---------------------------------------------------------------------------
//
//  Function:   ConvertAListAToNamedBasedW
//
//  Synopsis:   Same as above, but updates an ANSI list, and returns
//              a ptr to a WIDE list.  In addition, it will also convert
//              property and inheritproperty strings to UNICODE
//
//  Arguments:  [IN  pAListA]       --  List to be changed
//              [IN  ChangedList]   --  Linked list class to save all of the
//                                      changes
//              [IN  fSidToName]    --  If TRUE, the Sid-to-Name translation
//                                      is done
//              [OUT ppAListW]      --  Where the widw ptr to the list is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_PARAMETER A bad parameter was given
//
//  Notes:      The returned WIDE pointer is NOT allocated, but rather
//              the pAListA structure is "converted" in place.  It gets
//              restored when the saved list is destructed
//
//----------------------------------------------------------------------------
DWORD
ConvertAListAToNamedBasedW(IN  PACTRL_ACCESSA   pAListA,
                           IN  CSList&          ChangedList,
                           IN  BOOL             fSidToName,
                           OUT PACTRL_ACCESSW  *ppAListW)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PWSTR   pwszNew;

    if(pAListA == NULL)
    {
        *ppAListW = (PACTRL_ACCESSW)pAListA;
        return(ERROR_SUCCESS);
    }

    //
    // A little parameter checking first...
    //
    if(pAListA->cEntries != 0 && pAListA->pPropertyAccessList == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    //
    // This works the same as above, with the exception that we also need
    // to convert any other strings we find...
    //
    for(ULONG iIndex = 0;
        iIndex < pAListA->cEntries && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        //
        // First, the property names
        //
        if(pAListA->pPropertyAccessList[iIndex].lpProperty != NULL)
        {
            dwErr  = ConvertStringAToStringW((PSTR)
                            pAListA->pPropertyAccessList[iIndex].lpProperty,
                            &pwszNew);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AllocAndInsertCNode(ChangedList,
                  (PWSTR *)&(pAListA->pPropertyAccessList[iIndex].lpProperty),
                  (PWSTR)pAListA->pPropertyAccessList[iIndex].lpProperty,
                  pwszNew);
                if(dwErr != ERROR_SUCCESS)
                {
                    LocalFree(pwszNew);
                }
            }
        }

        //
        // Now, process all of the entries
        //
        ULONG iUpper = 0;
        if(pAListA->pPropertyAccessList[iIndex].pAccessEntryList != NULL)
        {
            iUpper = pAListA->pPropertyAccessList[iIndex].pAccessEntryList->
                                                                     cEntries;
        }

        if(iUpper != 0 && pAListA->pPropertyAccessList[iIndex].
                                        pAccessEntryList->pAccessList == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        for(ULONG iAE = 0; iAE < iUpper && dwErr == ERROR_SUCCESS; iAE++)
        {

            PACTRL_ACCESS_ENTRYA pAE = (PACTRL_ACCESS_ENTRYA)&(
                                        pAListA->pPropertyAccessList[iIndex].
                                        pAccessEntryList->pAccessList[iAE]);
            if(pAE->Trustee.TrusteeForm == TRUSTEE_IS_SID)
            {
                if(fSidToName == TRUE)
                {
                    TRUSTEE_W   TrusteeW;
                    dwErr = GetTrusteeWForSid((PSID)pAE->Trustee.ptstrName,
                                              &TrusteeW);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        pAE->Trustee.TrusteeForm = TRUSTEE_IS_NAME;

                        dwErr = AllocAndInsertCNode(
                                           ChangedList,
                                           (PWSTR *)&(pAE->Trustee.ptstrName),
                                           (PWSTR)pAE->Trustee.ptstrName,
                                           TrusteeW.ptstrName,
                                           (PULONG)&(pAE->Trustee.TrusteeType),
                                           (ULONG)pAE->Trustee.TrusteeType,
                                           (ULONG)TrusteeW.TrusteeType,
                                           (PULONG)&(pAE->Trustee.TrusteeForm),
                                           (ULONG)TRUSTEE_IS_SID,
                                           (ULONG)TRUSTEE_IS_NAME);
                        pAE->Trustee.TrusteeType = TrusteeW.TrusteeType;
                        if(dwErr != ERROR_SUCCESS)
                        {
                            LocalFree(TrusteeW.ptstrName);
                        }
                    }
                }
            }
            else
            {
                //
                // We'll have to copy the name
                //

                dwErr  = ConvertStringAToStringW(pAE->Trustee.ptstrName,
                                                 &pwszNew);
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AllocAndInsertCNode(ChangedList,
                                            (PWSTR *)&(pAE->Trustee.ptstrName),
                                            (PWSTR)pAE->Trustee.ptstrName,
                                            pwszNew);
                    if(dwErr != ERROR_SUCCESS)
                    {
                        LocalFree(pwszNew);
                    }
                }
            }

            //
            // Finally, see if we have to do an inherit property
            //
            if(dwErr == ERROR_SUCCESS && pAE->lpInheritProperty != NULL)
            {
                dwErr  = ConvertStringAToStringW((PSTR)pAE->lpInheritProperty,
                                                 &pwszNew);
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AllocAndInsertCNode(ChangedList,
                                           (PWSTR *)&(pAE->lpInheritProperty),
                                           (PWSTR)pAE->lpInheritProperty,
                                           pwszNew);
                    if(dwErr != ERROR_SUCCESS)
                    {
                        LocalFree(pwszNew);
                    }
                }
            }

            if(dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }
    }

    //
    // If it all worked, return the item as a wide version
    //
    if(dwErr == ERROR_SUCCESS)
    {
        *ppAListW = (PACTRL_ACCESSW)pAListA;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertExplicitAccessAToAccessW
//
//  Synopsis:   Same as above, but converts from ANSI to WIDE as well
//
//  Arguments:  [IN  cEntries]      --  Number of explicit entries
//              [IN  pExplicit]     --  Explicit entries list to change
//              [IN  ChangedList]   --  Linked list of changed entries
//              [OUT ppAccessList]  --  Where the converted list is returned
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertExplicitAccessAToW(IN   ULONG                  cEntries,
                          IN   PEXPLICIT_ACCESS_A     pExplicit,
                          IN   CSList&                ChangedList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    for(ULONG iIndex = 0;
        iIndex < cEntries && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        //
        // The only thing that has to happen is the Trustee name has to be
        // converted
        //
        if(pExplicit[iIndex].Trustee.TrusteeForm == TRUSTEE_IS_NAME)
        {
            PWSTR   pwszTrustee;
            dwErr = ConvertStringAToStringW(
                                    (PSTR)pExplicit[iIndex].Trustee.ptstrName,
                                    &pwszTrustee);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AllocAndInsertCNode(ChangedList,
                                        (PWSTR *)&(pExplicit[iIndex].Trustee.ptstrName),
                                        (PWSTR)pExplicit[iIndex].Trustee.ptstrName,
                                        pwszTrustee);
                if(dwErr != ERROR_SUCCESS)
                {
                    LocalFree(pwszTrustee);
                }
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAEToExplicit
//
//  Synopsis:   Converts a single AccessEntry to an Explicit entry
//
//  Arguments:  [IN  pAE]           --  AccessEntry to convert
//              [IN  pEx]           --  Explicit entrie to fill in
//
//  Returns:    VOID
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
ConvertAEToExplicit(IN  PACTRL_ACCESS_ENTRYW    pAE,
                    IN  PEXPLICIT_ACCESS        pEx)
{
    memcpy(&(pEx->Trustee),
           &(pAE->Trustee),
           sizeof(TRUSTEE));
    pEx->grfInheritance = pAE->Inheritance;
    ConvertAccessRightToAccessMask(pAE->Access,
                                   &(pEx->grfAccessPermissions));
    if(FLAG_ON(pAE->fAccessFlags,ACTRL_ACCESS_ALLOWED))
    {
        pEx->grfAccessMode = SET_ACCESS;
    }
    else if (FLAG_ON(pAE->fAccessFlags,ACTRL_ACCESS_DENIED))
    {
        pEx->grfAccessMode = DENY_ACCESS;
    }
    else if (FLAG_ON(pAE->fAccessFlags,ACTRL_AUDIT_SUCCESS))
    {
        pEx->grfAccessMode = SET_AUDIT_SUCCESS;
    }
    else if (FLAG_ON(pAE->fAccessFlags,ACTRL_AUDIT_FAILURE))
    {
        pEx->grfAccessMode = SET_AUDIT_FAILURE;
    }
}


BOOL
__stdcall
CDeclWcsicmp(PVOID  pv1, PVOID pv2)
{
    return(_wcsicmp((PWSTR)pv1, (PWSTR)pv2) == 0 ? TRUE : FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessWToExplicitW
//
//  Synopsis:   Converts an ACTRL_ACCESS list to an EXPLICIT_ACCESS list
//
//  Arguments:  [IN  pAccess]       --  Access list to convert
//              [OUT pcEntries]     --  Where to return the count of items
//              [OUT ppExplicit]    --  Explicit entries list
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertAccessWToExplicitW(IN  PACTRL_ACCESSW    pAccess,
                          OUT PULONG            pcEntries,
                          OUT PEXPLICIT_ACCESS *ppExplicit)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CSList  TrusteeList(NULL);

    ULONG               cEntries = 0;
    PEXPLICIT_ACCESS    pExplicit = NULL;

    //
    // First, count the entries and save the trustees
    //
    for(ULONG iProp = 0;
        iProp < pAccess->cEntries && dwErr == ERROR_SUCCESS &&
                                        pAccess->pPropertyAccessList != NULL;
        iProp++)
    {
        if(pAccess->pPropertyAccessList[iProp].pAccessEntryList != NULL)
        {
            PACTRL_ACCESS_ENTRY_LIST pAEL =
                        pAccess->pPropertyAccessList[iProp].pAccessEntryList;
            for(ULONG iEntry = 0;
                iEntry < pAEL->cEntries && dwErr == ERROR_SUCCESS &&
                                                    pAEL->pAccessList != NULL;
                iEntry++)
            {
                dwErr = TrusteeList.InsertIfUnique((PVOID)
                                 pAEL->pAccessList[iEntry].Trustee.ptstrName,
//                                 (CompFunc)_wcsicmp);
                                 CDeclWcsicmp);
                cEntries++;
            }
        }
    }

    //
    // Ok, now that we have a list of trustees, go ahead and size the strings
    //
    ULONG cSize = 0;

    if(dwErr == ERROR_SUCCESS)
    {
        TrusteeList.Reset();
        PWSTR pwszNext = (PWSTR)TrusteeList.NextData();
        while(pwszNext != NULL)
        {
            cSize += (ULONG)(SIZE_PWSTR(pwszNext));
            pwszNext = (PWSTR)TrusteeList.NextData();
        }
    }

    //
    // Ok, now for the allocation
    //
    if(dwErr == ERROR_SUCCESS)
    {
        pExplicit = (PEXPLICIT_ACCESS)AccAlloc(cSize +
                                        (cEntries * sizeof(EXPLICIT_ACCESS)));
        if(pExplicit == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Now, we'll go through and convert all of ACCESS_ENTRYs to
            // EXPLICIT_ACCESSes.
            //
            ULONG iIndex = 0;
            for(iProp = 0;
                iProp < pAccess->cEntries && dwErr == ERROR_SUCCESS &&
                                         pAccess->pPropertyAccessList != NULL;
                iProp++)
            {
                if(pAccess->pPropertyAccessList[iProp].pAccessEntryList !=
                                                                        NULL)
                {
                    PACTRL_ACCESS_ENTRY_LIST pAEL =
                         pAccess->pPropertyAccessList[iProp].pAccessEntryList;
                    for(ULONG iEntry = 0;
                        iEntry < pAEL->cEntries && pAEL->pAccessList != NULL;
                        iEntry++)
                    {
                        ConvertAEToExplicit(&(pAEL->pAccessList[iEntry]),
                                            &(pExplicit[iIndex]));
                        iIndex++;
                    }
                }
            }

            //
            // Now, we'll have to go through and reset all of our trustees
            //
            PWSTR   pwszTrustee = (PWSTR)((PBYTE)pExplicit +
                                        (cEntries * sizeof(EXPLICIT_ACCESS)));
            TrusteeList.Reset();
            PWSTR pwszNext = (PWSTR)TrusteeList.NextData();
            while(pwszNext != NULL)
            {
                wcscpy(pwszTrustee,
                       pwszNext);

                //
                // Now, go through the explicit list, and find all instances
                // of this trustee, and change it...
                //
                for(ULONG iSrch = 0; iSrch < cEntries; iSrch++)
                {
                    if(_wcsicmp(pExplicit[iSrch].Trustee.ptstrName,
                                pwszTrustee) == 0)
                    {
                        pExplicit[iSrch].Trustee.ptstrName = pwszTrustee;
                    }
                }

                pwszTrustee = (PWSTR)((PBYTE)pwszTrustee +
                                                    SIZE_PWSTR(pwszTrustee));

                pwszNext = (PWSTR)TrusteeList.NextData();
            }
        }
    }

    //
    // If it all worked, return it.. Otherwise, delete it
    //
    if(dwErr == ERROR_SUCCESS)
    {
        *ppExplicit = pExplicit;
        *pcEntries  = cEntries;
    }
    else
    {
        LocalFree(pExplicit);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessWToExplicitA
//
//  Synopsis:   Converts an ACTRL_ACCESS list to an ANSI EXPLICIT_ACCESS list
//
//  Arguments:  [IN  pAccess]       --  Access list to convert
//              [OUT pcEntries]     --  Where to return the count of items
//              [OUT ppExplicit]    --  Explicit entries list
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//----------------------------------------------------------------------------
DWORD
ConvertAccessWToExplicitA(IN  PACTRL_ACCESSW     pAccess,
                          OUT PULONG             pcEntries,
                          OUT PEXPLICIT_ACCESSA *ppExplicit)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CSList  TrusteeList(NULL);

    ULONG               cEntries = 0;
    PEXPLICIT_ACCESSA   pExplicit = NULL;

    //
    // First, count the entries and save the trustees
    //
    for(ULONG iProp = 0;
        iProp < pAccess->cEntries && dwErr == ERROR_SUCCESS &&
                                         pAccess->pPropertyAccessList != NULL;
        iProp++)
    {
        if(pAccess->pPropertyAccessList[iProp].pAccessEntryList != NULL)
        {
            PACTRL_ACCESS_ENTRY_LIST pAEL =
                        pAccess->pPropertyAccessList[iProp].pAccessEntryList;
            for(ULONG iEntry = 0;
                iEntry < pAEL->cEntries && dwErr == ERROR_SUCCESS &&
                                                    pAEL->pAccessList != NULL;
                iEntry++)
            {
                dwErr = TrusteeList.InsertIfUnique((PVOID)
                                 pAEL->pAccessList[iEntry].Trustee.ptstrName,
//                                 (CompFunc)_wcsicmp);
                                 CDeclWcsicmp);
                cEntries++;
            }
        }
    }

    //
    // Ok, now that we have a list of trustees, go ahead and size the strings
    //
    ULONG cSize = 0;

    if(dwErr == ERROR_SUCCESS)
    {
        TrusteeList.Reset();
        PWSTR pwszNext = (PWSTR)TrusteeList.NextData();
        while(pwszNext != NULL)
        {
            cSize += wcstombs(NULL,pwszNext, wcslen(pwszNext) + 1) + 1;
            pwszNext = (PWSTR)TrusteeList.NextData();
        }
    }

    //
    // Ok, now for the allocation
    //
    if(dwErr == ERROR_SUCCESS)
    {
        pExplicit = (PEXPLICIT_ACCESSA)AccAlloc(cSize +
                                        (cEntries * sizeof(EXPLICIT_ACCESS)));
        if(pExplicit == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Now, we'll go through and convert all of ACCESS_ENTRYs to
            // EXPLICIT_ACCESSes.
            //
            ULONG iIndex = 0;
            for(iProp = 0;
                iProp < pAccess->cEntries && dwErr == ERROR_SUCCESS &&
                                         pAccess->pPropertyAccessList != NULL;
                iProp++)
            {
                if(pAccess->pPropertyAccessList[iProp].pAccessEntryList !=
                                                                        NULL)
                {
                    PACTRL_ACCESS_ENTRY_LIST pAEL =
                         pAccess->pPropertyAccessList[iProp].pAccessEntryList;
                    for(ULONG iEntry = 0;
                        iEntry < pAEL->cEntries && pAEL->pAccessList != NULL;
                        iEntry++)
                    {
                        ConvertAEToExplicit(&(pAEL->pAccessList[iEntry]),
                                     (PEXPLICIT_ACCESSW)&(pExplicit[iIndex]));
                        iIndex++;
                    }
                }
            }

            //
            // Now, we'll have to go through and reset all of our trustees
            //
            PSTR   pszTrustee = (PSTR)((PBYTE)pExplicit +
                                        (cEntries * sizeof(EXPLICIT_ACCESS)));
            TrusteeList.Reset();
            PWSTR pwszNext = (PWSTR)TrusteeList.NextData();
            while(pwszNext != NULL)
            {
                wcstombs(pszTrustee, pwszNext, wcslen(pwszNext) + 1);

                //
                // Now, go through the explicit list, and find all instances
                // of this trustee, and change it...
                //
                for(ULONG iSrch = 0; iSrch < cEntries; iSrch++)
                {
                    if((PWSTR)pExplicit[iSrch].Trustee.ptstrName == pwszNext)
                    {
                        pExplicit[iSrch].Trustee.ptstrName = pszTrustee;
                    }
                }

                pszTrustee = (PSTR)((PBYTE)pszTrustee +
                           wcstombs(NULL,pwszNext, wcslen(pwszNext)) + 1);

                pwszNext = (PWSTR)TrusteeList.NextData();
            }
        }
    }

    //
    // If it all worked, return it.. Otherwise, delete it
    //
    if(dwErr == ERROR_SUCCESS)
    {
        *ppExplicit = pExplicit;
        *pcEntries  = cEntries;
    }
    else
    {
        LocalFree(pExplicit);
    }


    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   TrusteeAllocationSizeAToW
//
//  Synopsis:   Determines the size in UNICODE of an ANSI trustee
//
//  Arguments:  [IN  pTrustee]      --  Trustee to size
//
//  Returns:    size of the trustee on success
//              0 on failure
//
//
//
//----------------------------------------------------------------------------
ULONG TrusteeAllocationSizeAToW(IN PTRUSTEE_A pTrustee)
{
    ULONG cSize = 0;

    //
    // If impersonate, add size required for multiple trustees
    //
    if(pTrustee->MultipleTrusteeOperation == TRUSTEE_IS_IMPERSONATE)
    {
        //
        // Add the size of any linked trustees, note the recursion
        //
        cSize += sizeof(TRUSTEE_W) +
                      TrusteeAllocationSizeAToW(pTrustee->pMultipleTrustee);
    }

    //
    // Switch on the form, note that an invalid form just means no
    // size is added
    //
    switch(pTrustee->TrusteeForm)
    {
    case TRUSTEE_IS_NAME:
        cSize += (strlen(pTrustee->ptstrName) + 1) * sizeof(WCHAR);
        break;

    case TRUSTEE_IS_SID:
        cSize += RtlLengthSid((PSID)pTrustee->ptstrName) + sizeof(WCHAR);
        break;

    default:
        cSize = 0;
        break;
    }

    return(cSize);
}





//+---------------------------------------------------------------------------
//
//  Function:   TrusteeAllocationSizeWToW
//
//  Synopsis:   Determines the size in UNICODE of an UNICODE trustee
//
//  Arguments:  [IN  pTrustee]      --  Trustee to size
//
//  Returns:    size of the trustee on success
//              0 on failure
//
//
//
//----------------------------------------------------------------------------
ULONG TrusteeAllocationSizeWToW(IN PTRUSTEE_W pTrustee)
{
    ULONG cSize = 0;

    //
    // If impersonate, add size required for multiple trustees
    //
    if(pTrustee->MultipleTrusteeOperation == TRUSTEE_IS_IMPERSONATE)
    {
        //
        // Add the size of any linked trustees, note the recursion
        //
        cSize += sizeof(TRUSTEE_W) +
                      TrusteeAllocationSizeWToW(pTrustee->pMultipleTrustee);
    }

    //
    // Switch on the form, note that an invalid form just means no
    // size is added
    //
    switch(pTrustee->TrusteeForm)
    {
    case TRUSTEE_IS_NAME:
        cSize += (wcslen(pTrustee->ptstrName) + 1) * sizeof(WCHAR);
        break;

    case TRUSTEE_IS_SID:
        cSize += RtlLengthSid((PSID)pTrustee->ptstrName) + sizeof(WCHAR);
        break;

    default:
        cSize = 0;
        break;
    }

    return(cSize);
}





//+---------------------------------------------------------------------------
//
//  Function:   ConvertExplicitAccessAToExplicitAccessW
//
//  Synopsis:   Converts an ExplicitAccessList from ANSI to UNICODE
//
//  Arguments:  [IN  cAccess]       --  Number of items
//              [IN  pAccessA]      --  ANSI list
//              [OUT ppAccessW]     --  Where to return the WIDE list
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//
//----------------------------------------------------------------------------
DWORD
ConvertExplicitAccessAToExplicitAccessW(IN  ULONG               cAccesses,
                                        IN  PEXPLICIT_ACCESS_A  pAccessA,
                                        OUT PEXPLICIT_ACCESS_W *ppAccessW)
{
    ULONG               cbBytes, i;
    PEXPLICIT_ACCESS_W  pAccess;
    PBYTE               pbStuffPtr;
    DWORD               dwErr = ERROR_SUCCESS;

    cbBytes = cAccesses * sizeof(EXPLICIT_ACCESS_W);

    for (i = 0; i < cAccesses; i++ )
    {
        cbBytes += TrusteeAllocationSizeAToW(&(pAccessA[i].Trustee));
    }

    pAccess = (PEXPLICIT_ACCESS_W)AccAlloc(cbBytes);
    if(pAccess == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    pbStuffPtr = (PBYTE)pAccess + cAccesses * sizeof(EXPLICIT_ACCESS_W);

    for(i = 0; i < cAccesses; i++)
    {
        dwErr =  ConvertTrusteeAToTrusteeW(&(pAccessA[i].Trustee),
                                           &(pAccess[i].Trustee),
                                           FALSE);

        pAccess[i].grfAccessPermissions = pAccessA[i].grfAccessPermissions;
        pAccess[i].grfAccessMode        = pAccessA[i].grfAccessMode;
        pAccess[i].grfInheritance       = pAccessA[i].grfInheritance;
    }

    *ppAccessW = pAccess;

    return (dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessRightToAccessMask
//
//  Synopsis:   Converts from ACCESS_RIGHTS to an AccessMask
//
//  Arguments:  [IN  AccessRight]   --  Access mask to convert
//              [OUT pAccessMask]   --  Where to return the access mask
//
//  Returns:    VOID
//
//  Notes:
//
//
//----------------------------------------------------------------------------
VOID
ConvertAccessRightToAccessMask(IN  ACCESS_RIGHTS    AccessRight,
                               OUT PACCESS_MASK     pAccessMask)
{
    //
    // Look for the known entries first
    //
    *pAccessMask = 0;

    if((AccessRight & (ACTRL_STD_RIGHTS_ALL | ACTRL_SYSTEM_ACCESS)) != 0)
    {

        *pAccessMask = (AccessRight & ACTRL_STD_RIGHTS_ALL) >> 11;

    }

    //
    // Add in the remaining rights
    //
    *pAccessMask |= (AccessRight & ~(ACTRL_STD_RIGHTS_ALL | ACTRL_SYSTEM_ACCESS));
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertAccessMaskToAccessRight
//
//  Synopsis:   Converts from an AccessMask to ACCESS_RIGHTS
//
//  Arguments:  [IN  AccessMask]    --  Access mask to convert
//              [OUT pAccessRight]  --  Where to return the access rights
//
//  Returns:    VOID
//
//  Notes:
//
//
//----------------------------------------------------------------------------
VOID
ConvertAccessMaskToAccessRight(IN  ACCESS_MASK      AccessMask,
                               OUT PACCESS_RIGHTS   pAccessRight)
{
    //
    // Look for the known entries first
    //
    *pAccessRight = 0;
    GENERIC_MAPPING GenMapping = {STANDARD_RIGHTS_READ     | 0x1,
                                  STANDARD_RIGHTS_WRITE    | 0x2,
                                  STANDARD_RIGHTS_EXECUTE  | 0x4,
                                  STANDARD_RIGHTS_REQUIRED | 0x7};
    MapGenericMask(&AccessMask,
                   &GenMapping);

    if((AccessMask & STANDARD_RIGHTS_ALL) != 0)
    {
        *pAccessRight = (AccessMask & STANDARD_RIGHTS_ALL) << 11;
    }

    //
    // Add in the remaining rights
    //
    *(pAccessRight) |= (AccessMask & ~STANDARD_RIGHTS_ALL);
}





//+---------------------------------------------------------------------------
//
//  Function:   ConvertTrusteeWToTrusteeA
//
//  Synopsis:   Converts a WIDE trustee to an ANSI one.  Allocates the new
//              destination trustee
//
//  Arguments:  [IN  pTrusteeW]     --  Trustee to convert
//              [IN  ppTrusteeA]    --  Where to return the ANSI version of
//                                      the trustee
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Returned memory must be freed via LocalFree
//
//
//----------------------------------------------------------------------------
DWORD
ConvertTrusteeWToTrusteeA(IN  PTRUSTEE_W        pTrusteeW,
                          OUT PTRUSTEE_A       *ppTrusteeA)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pTrusteeW == NULL)
    {
        *ppTrusteeA = NULL;
    }
    else
    {
        //
        // First, if necessary, convert our wide name to an ascii name
        //
        ULONG   cNameSize = 0;
        if(pTrusteeW->TrusteeForm == TRUSTEE_IS_NAME)
        {
            cNameSize = wcstombs(NULL,
                                 pTrusteeW->ptstrName,
                                 wcslen(pTrusteeW->ptstrName) + 1) + 1;
        }
        else if(pTrusteeW->TrusteeForm == TRUSTEE_IS_SID)
        {
            if(RtlValidSid((PSID)pTrusteeW->ptstrName) == FALSE)
            {
                dwErr = ERROR_INVALID_SID;
            }
            else
            {
                cNameSize = RtlLengthSid((PSID)pTrusteeW->ptstrName);
            }
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Allocate it
            //
            *ppTrusteeA = (PTRUSTEE_A)AccAlloc(sizeof(TRUSTEE_A) + cNameSize);
            if(*ppTrusteeA == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                //
                // And copy it...
                //
                memcpy(*ppTrusteeA,
                       pTrusteeW,
                       sizeof(TRUSTEE_W));
                (*ppTrusteeA)->ptstrName = (PSTR)((PBYTE)*ppTrusteeA +
                                                           sizeof(TRUSTEE_A));

                if(pTrusteeW->TrusteeForm == TRUSTEE_IS_NAME)
                {
                    wcstombs((*ppTrusteeA)->ptstrName,
                             pTrusteeW->ptstrName,
                             wcslen(pTrusteeW->ptstrName) + 1);
                }
                else
                {
                    RtlCopySid(cNameSize,
                               (PSID)((*ppTrusteeA)->ptstrName),
                               (PSID)(pTrusteeW->ptstrName));
                }
            }
        }
    }

    return(dwErr);
}


//+---------------------------------------------------------------------------
//
// Stolen from old win32 access control API code
//+---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function : SpecialCopyTrustee
//
//  Synopsis : copies the from trustee into the to trustee, and any data
//             (such as the name, sid or linked multiple trustees) to the
//             stuff pointer, and moves the stuff pointer.
//
//  Arguments: IN OUT [pStuffPtr] - place to stuff data pointed to by the
//                                  from trustee
//             IN OUT [pToTrustee] - the trustee to copy to
//             IN OUT [pFromTrustee] - the trustee to copy from
//
//----------------------------------------------------------------------------
VOID
SpecialCopyTrustee(VOID **pStuffPtr, PTRUSTEE pToTrustee, PTRUSTEE pFromTrustee)
{


    //
    // first copy the current trustee
    // switch on the form, note that an invalid form just means no
    // data is copied
    //
    pToTrustee->MultipleTrusteeOperation = pFromTrustee->MultipleTrusteeOperation;
    pToTrustee->TrusteeForm = pFromTrustee->TrusteeForm;
    pToTrustee->TrusteeType = pFromTrustee->TrusteeType;
    pToTrustee->ptstrName = (LPWSTR)*pStuffPtr;
    //
    // copy the pointed to data
    //
    switch (pToTrustee->TrusteeForm)
    {
    case TRUSTEE_IS_NAME:
        wcscpy(pToTrustee->ptstrName, pFromTrustee->ptstrName);
        *pStuffPtr = ((PBYTE)*pStuffPtr +
                        (wcslen(pFromTrustee->ptstrName) + 1) * sizeof(WCHAR));
        break;
    case TRUSTEE_IS_SID:
    {
        ULONG csidsize = RtlLengthSid((PSID)pFromTrustee->ptstrName);

        //
        // Note: rtlcopysid can not fail unless there is a bug in
        // RtlLengthSid.
        //

        RtlCopySid(csidsize, (PSID)*pStuffPtr, (PSID)pFromTrustee->ptstrName);
        *pStuffPtr = ((PBYTE)*pStuffPtr +
                              csidsize + sizeof(WCHAR));
        break;
    }
    }
    //
    // if impersonate, copy multiple trustees, note the recursion
    //
    if (pFromTrustee->MultipleTrusteeOperation != NO_MULTIPLE_TRUSTEE)
    {
        //
        // move the stuff pointer, saving room for the new trustee structure
        //
        pToTrustee->pMultipleTrustee = (PTRUSTEE)*pStuffPtr;
        *pStuffPtr = (VOID *)((PBYTE)*pStuffPtr + sizeof(TRUSTEE));
        SpecialCopyTrustee(pStuffPtr,
                           (PTRUSTEE) ((ULONG_PTR)*pStuffPtr - sizeof(TRUSTEE)),
                           pFromTrustee->pMultipleTrustee);
    } else
    {
        pToTrustee->pMultipleTrustee = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  Function :  Win32AccessRequestToExplicitEntry
//
//  Synopsis : converts access requests to  explicit accesses
//
//  Arguments: IN [cCountOfExplicitAccesses] - number of input explicit accesses
//             IN [pExplicitAccessList]   - list of explicit accesses
//             OUT [pAccessEntryList]   - output access entries, caller must
//                                        free with AccFree
//
//----------------------------------------------------------------------------
DWORD
Win32ExplicitAccessToAccessEntry(IN ULONG cCountOfExplicitAccesses,
                                 IN PEXPLICIT_ACCESS pExplicitAccessList,
                                 OUT PACCESS_ENTRY *pAccessEntryList)

{
    DWORD status = NO_ERROR;
    //
    // allocate room for the access entrys
    //
    if (NULL != (*pAccessEntryList = (PACCESS_ENTRY)AccAlloc(
                              cCountOfExplicitAccesses * sizeof(ACCESS_ENTRY))))
    {
        //
        // copy them, note the the trustee is not copied
        //
        for (ULONG idx = 0; idx < cCountOfExplicitAccesses; idx++)
        {
           (*pAccessEntryList)[idx].AccessMode = (ACCESS_MODE)
                                          pExplicitAccessList[idx].grfAccessMode;
           (*pAccessEntryList)[idx].InheritType =
                                         pExplicitAccessList[idx].grfInheritance;
           (*pAccessEntryList)[idx].AccessMask =
                                  pExplicitAccessList[idx].grfAccessPermissions;
           (*pAccessEntryList)[idx].Trustee = pExplicitAccessList[idx].Trustee;
        }
    } else
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
    }
    return(status);
}

//+---------------------------------------------------------------------------
//
//  Function :  AccessEntryToWin32ExplicitAccess
//
//  Synopsis : gets trustee names and access rights from access entries
//
//  Arguments: IN [cCountOfAccessEntries]   - the count of acccess entries
//             IN [pListOfAccessEntries]   - the list of acccess entries
//             OUT [pListOfExplicitAccesses]  - the returned list of trustee
//
//----------------------------------------------------------------------------
DWORD
AccessEntryToWin32ExplicitAccess(IN ULONG cCountOfAccessEntries,
                                 IN PACCESS_ENTRY pListOfAccessEntries,
                                 OUT PEXPLICIT_ACCESS *pListOfExplicitAccesses)
{
    DWORD status = NO_ERROR;
    LPWSTR trustee;

    if (cCountOfAccessEntries > 0)
    {
        DWORD csize = cCountOfAccessEntries * sizeof(EXPLICIT_ACCESS);
        //
        // figure out how big the returned list is
        //
        for (ULONG idx = 0; idx < cCountOfAccessEntries; idx++)
        {
            csize += TrusteeAllocationSizeWToW(&
                                        (pListOfAccessEntries[idx].Trustee));
        }
        //
        // allocate space for the returned list
        //
        if (NULL !=(*pListOfExplicitAccesses =  (PEXPLICIT_ACCESS)
                                                AccAlloc(csize)))
        {
            //
            // loop thru the access entries, stuffing them as we go
            //
            PTRUSTEE stuffptr = (PTRUSTEE)((PBYTE)*pListOfExplicitAccesses +
                            cCountOfAccessEntries * sizeof(EXPLICIT_ACCESS));

            for (idx = 0; idx < cCountOfAccessEntries; idx++)
            {
                //
                // copy the trustee and move the stuff pointer
                //
                SpecialCopyTrustee((void **)&stuffptr,
                                   &((*pListOfExplicitAccesses)[idx].Trustee),
                                   &(pListOfAccessEntries[idx].Trustee));
                //
                // copy the rest of the data
                //
                (*pListOfExplicitAccesses)[idx].grfInheritance =
                                      pListOfAccessEntries[idx].InheritType;
                (*pListOfExplicitAccesses)[idx].grfAccessPermissions =
                                      pListOfAccessEntries[idx].AccessMask;
                (*pListOfExplicitAccesses)[idx].grfAccessMode =
                                      pListOfAccessEntries[idx].AccessMode;
            }
        } else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else
    {
        (*pListOfExplicitAccesses) = NULL;
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\advapi\feclient\feclient.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    feclient.cpp

Abstract:

    This module implements stubs to call EFS Api

Author:

    Robert Reichel (RobertRe)
    Robert Gu (RobertG)

Revision History:

--*/

//
// Turn off lean and mean so we get wincrypt.h and winefs.h included
//

#undef WIN32_LEAN_AND_MEAN

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <feclient.h>
#include <efsstruc.h>
#include <userenv.h>

#include <overflow.h>

//
// Constants used in export\import file
//

#define INISECTIONNAME   L"Encryption"
#define INIKEYNAME       L"Disable"
#define INIFILENAME      L"\\Desktop.ini"
#define TRUSTEDPEOPLE L"TrustedPeople"

#define BASIC_KEY_INFO  1
#define UPDATE_KEY_USED 0x100

#if DBG

ULONG DebugLevel = 0;

#endif


LPSTR   EfsOidlpstr  = szOID_KP_EFS;

//
// External prototypes
//
extern "C" {
DWORD
EfsReadFileRawRPCClient(
    IN      PFE_EXPORT_FUNC ExportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    );

DWORD
EfsWriteFileRawRPCClient(
    IN      PFE_IMPORT_FUNC ImportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    );

DWORD
EfsAddUsersRPCClient(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    );


DWORD
EfsRemoveUsersRPCClient(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    );

DWORD
EfsQueryRecoveryAgentsRPCClient(
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    );


DWORD
EfsQueryUsersRPCClient(
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    );

DWORD
EfsSetEncryptionKeyRPCClient(
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    );

DWORD
EfsDuplicateEncryptionInfoRPCClient(
    IN LPCWSTR lpSrcFileName,
    IN LPCWSTR lpDestFileName,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN PEFS_RPC_BLOB pRelativeSD,
    IN BOOL bInheritHandle
    );

DWORD
EfsFileKeyInfoRPCClient(
    IN      LPCWSTR        lpFileName,
    IN      DWORD          InfoClass,
    OUT     PEFS_RPC_BLOB  *KeyInfo
    );


}

//
// Exported function prototypes
//

DWORD
EfsClientEncryptFile(
    IN LPCWSTR      FileName
    );

DWORD
EfsClientDecryptFile(
    IN LPCWSTR      FileName,
    IN DWORD        Recovery
    );

BOOL
EfsClientFileEncryptionStatus(
    IN LPCWSTR      FileName,
    OUT LPDWORD     lpStatus
    );

DWORD
EfsClientOpenFileRaw(
    IN      LPCWSTR         lpFileName,
    IN      ULONG           Flags,
    OUT     PVOID *         Context
    );

DWORD
EfsClientReadFileRaw(
    IN      PFE_EXPORT_FUNC    ExportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    );

DWORD
EfsClientWriteFileRaw(
    IN      PFE_IMPORT_FUNC    ImportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    );

VOID
EfsClientCloseFileRaw(
    IN      PVOID           Context
    );

DWORD
EfsClientAddUsers(
    IN LPCTSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    );

DWORD
EfsClientRemoveUsers(
    IN LPCTSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    );

DWORD
EfsClientQueryRecoveryAgents(
    IN      LPCTSTR                             lpFileName,
    OUT     PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    );

DWORD
EfsClientQueryUsers(
    IN      LPCTSTR                             lpFileName,
    OUT     PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    );

DWORD
EfsClientSetEncryptionKey(
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    );

VOID
EfsClientFreeHashList(
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashList
    );

DWORD
EfsClientDuplicateEncryptionInfo(
    IN LPCWSTR lpSrcFile,
    IN LPCWSTR lpDestFile,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL
EfsClientEncryptionDisable(
    IN LPCWSTR DirPath,
    IN BOOL Disable
	);

DWORD
EfsClientFileKeyInfo(
    IN      LPCWSTR        lpFileName,
    IN      DWORD          InfoClass,
    OUT     PEFS_RPC_BLOB  *KeyInfo
    );

VOID
EfsClientFreeKeyInfo(
    IN PEFS_RPC_BLOB  pKeyInfo
    );

FE_CLIENT_DISPATCH_TABLE DispatchTable = {  EfsClientEncryptFile,
                                            EfsClientDecryptFile,
                                            EfsClientFileEncryptionStatus,
                                            EfsClientOpenFileRaw,
                                            EfsClientReadFileRaw,
                                            EfsClientWriteFileRaw,
                                            EfsClientCloseFileRaw,
                                            EfsClientAddUsers,
                                            EfsClientRemoveUsers,
                                            EfsClientQueryRecoveryAgents,
                                            EfsClientQueryUsers,
                                            EfsClientSetEncryptionKey,
                                            EfsClientFreeHashList,
                                            EfsClientDuplicateEncryptionInfo,
                                            EfsClientEncryptionDisable,
                                            EfsClientFileKeyInfo,
                                            EfsClientFreeKeyInfo
                                            };


FE_CLIENT_INFO ClientInfo = {
                            FE_REVISION_1_0,
                            &DispatchTable
                            };

//
// Internal function prototypes
//


BOOL
TranslateFileName(
    IN LPCWSTR FileName,
    OUT PUNICODE_STRING FullFileNameU
    );

BOOL
RemoteFile(
    IN LPCWSTR FileName
    );

extern "C"
BOOL
EfsClientInit(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context
    )
{
    return( TRUE );
}

extern "C"
BOOL
FeClientInitialize(
    IN     DWORD           dwFeRevision,
    OUT    LPFE_CLIENT_INFO       *lpFeInfo
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    dwFeRevision - Is the revision of the current FEAPI interface.

    lpFeInfo - On successful return, must contain a pointer to a structure
         describing the FE Client Interface.  Once returned, the FE Client
         must assume that the caller will continue to reference this table until
         an unload call has been made.  Any changes to this information, or
         deallocation of the memory containing the information may result in
         system corruptions.


Return Value:

    TRUE - Indicates the Client DLL successfully initialized.

    FALSE - Indicates the client DLL has not loaded.  More information may be
         obtained by calling GetLastError().

--*/

{

    *lpFeInfo = &ClientInfo;

    return( TRUE );
}

BOOL
TranslateFileName(
    IN LPCWSTR FileName,
    OUT PUNICODE_STRING FullFileNameU
    )

/*++

Routine Description:

    This routine takes the filename passed by the user and converts
    it to a fully qualified pathname in the passed Unicode string.

Arguments:

    FileName - Supplies the user-supplied file name.

    FullFileNameU - Returns the fully qualified pathname of the passed file.
        The buffer in this string is allocated out of heap memory and
        must be freed by the caller.

Return Value:

    TRUE on success, FALSE otherwise.

--*/


//
// Note: need to free the buffer of the returned string
//
{

    UNICODE_STRING FileNameU;
    LPWSTR SrcFileName = (LPWSTR)FileName;

    if (0 == FileName[0]) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }
    FullFileNameU->Buffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(), 0, MAX_PATH * sizeof( WCHAR ));
    if (!FullFileNameU->Buffer) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    FullFileNameU->MaximumLength = MAX_PATH * sizeof( WCHAR );

    FullFileNameU->Length = (USHORT)RtlGetFullPathName_U(
                                         SrcFileName,
                                         FullFileNameU->MaximumLength,
                                         FullFileNameU->Buffer,
                                         NULL
                                         );

    //
    // The return value is supposed to be the length of the filename, without counting
    // the trailing NULL character.  MAX_PATH is supposed be long enough to contain
    // the length of the file name and the trailing NULL, so what we get back had
    // better be less than MAX_PATH wchars.
    //

    if ( FullFileNameU->Length >= FullFileNameU->MaximumLength ){

        RtlFreeHeap( RtlProcessHeap(), 0, FullFileNameU->Buffer );
        FullFileNameU->Buffer = (PWSTR)RtlAllocateHeap( RtlProcessHeap(), 0, FullFileNameU->Length + sizeof(WCHAR));

        if (FullFileNameU->Buffer == NULL) {
            return( FALSE );
        }
        FullFileNameU->MaximumLength = FullFileNameU->Length + sizeof(WCHAR);

        FullFileNameU->Length = (USHORT)RtlGetFullPathName_U(
                                            SrcFileName,
                                            FullFileNameU->MaximumLength,
                                            FullFileNameU->Buffer,
                                            NULL
                                            );
    }


    if (FullFileNameU->Length == 0) {
        //
        // We failed for some reason
        //
    
        RtlFreeHeap( RtlProcessHeap(), 0, FullFileNameU->Buffer );
        return( FALSE );
    }
    
    return( TRUE );

}

BOOL
WriteEfsIni(
    IN LPCWSTR SectionName,
	IN LPCWSTR KeyName,
	IN LPCWSTR WriteValue,
	IN LPCWSTR IniFileName
	)
/*++

Routine Description:

    This routine writes to the ini file. A wrap of WritePrivateProfileString
    
Arguments:

    SectionName - Section name (Encryption).

    KeyName - Key name (Disable).
    
    WriteValue - The value to be write (1).
    
    IniFileName - The path for ini file (dir\desktop.ini).

Return Value:

    TRUE on success

--*/
{
    BOOL bRet;

	bRet = WritePrivateProfileString(
                SectionName,
                KeyName,
                WriteValue,
                IniFileName
                );

    //
    // If SetFileAttributes fails, life should go on.
    //

    SetFileAttributes(IniFileName, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN );

    return bRet;
}


BOOL
EfsClientEncryptionDisable(
    IN LPCWSTR DirPath,
    IN BOOL Disable
	)
/*++

Routine Description:

    This routine disable and enable EFS in the directory DirPath.
        
Arguments:

    DirPath - Directory path.

    Disable - TRUE to disable
    

Return Value:

    TRUE for SUCCESS

--*/
{
    LPWSTR IniFilePath;
    WCHAR  WriteValue[2];
    BOOL   bRet = FALSE;

    if (DirPath) {

        IniFilePath = (LPWSTR)RtlAllocateHeap( 
                                RtlProcessHeap(), 
                                0,
                                (wcslen(DirPath)+1+wcslen(INIFILENAME))*sizeof(WCHAR) 
                                );
        if (IniFilePath) {
            if (Disable) {
                wcscpy(WriteValue, L"1");
            } else {
                wcscpy(WriteValue, L"0");
            }
    
            wcscpy(IniFilePath, DirPath);
            wcscat(IniFilePath, INIFILENAME);
            bRet = WriteEfsIni(INISECTIONNAME, INIKEYNAME, WriteValue, IniFilePath);
            RtlFreeHeap( RtlProcessHeap(), 0, IniFilePath );
    
        }

    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return bRet;
}

BOOL
EfsDisabled(
    IN LPCWSTR SectionName,
	IN LPCWSTR KeyName,
	IN LPCWSTR IniFileName
	)
/*++

Routine Description:

    This routine checks if the encryption has been turned off for the ini file.
        
Arguments:

    SectionName - Section name (Encryption).

    KeyName - Key name (Disable).
    
    IniFileName - The path for ini file (dir\desktop.ini).

Return Value:

    TRUE for disabled

--*/
{
    DWORD ValueLength;
    WCHAR ResultString[4];

    memset( ResultString, 0, sizeof(ResultString) );

    ValueLength = GetPrivateProfileString(
                      SectionName,
                      KeyName,
                      L"0",
                      ResultString,
                      sizeof(ResultString)/sizeof(WCHAR),
                      IniFileName
                      );

    //
    // If GetPrivateProfileString failed, EFS will be enabled
    //

    return (!wcscmp(L"1", ResultString));
}

BOOL
DirEfsDisabled(
    IN LPCWSTR  DirName
    )
/*++

Routine Description:

    This routine checks if the encryption has been turned off for the dir.
        
Arguments:

    SectionName - Section name (Encryption).

    KeyName - Key name (Disable).
    
    IniFileName - The path for ini file (dir\desktop.ini).

Return Value:

    TRUE for disabled

--*/
{
    LPWSTR FileName;
    DWORD  FileLength = (wcslen(INIFILENAME)+wcslen(DirName)+1)*sizeof (WCHAR);
    BOOL   bRet = FALSE;

    FileName = (PWSTR)RtlAllocateHeap( RtlProcessHeap(), 0, FileLength );
    if (FileName) {
        wcscpy( FileName, DirName );
        wcscat( FileName, INIFILENAME );
        bRet = EfsDisabled( INISECTIONNAME, INIKEYNAME, FileName );
        RtlFreeHeap( RtlProcessHeap(), 0, FileName );
    }

    return bRet;
}

BOOL
RemoteFile(
    IN LPCWSTR FileName
    )
/*++

Routine Description:

    This routine checks if the file is a local file.
    If a UNC name is passed in, it assumes a remote file. A loopback operation will occur.

Arguments:

    FileName - Supplies the user-supplied file name.

Return Value:

    TRUE for remote file.

--*/

{

    if ( FileName[1] == L':' ){

        WCHAR DriveLetter[3];
        DWORD BufferLength = 3;
        DWORD RetCode = ERROR_SUCCESS;

        DriveLetter[0] = FileName[0];
        DriveLetter[1] = FileName[1];
        DriveLetter[2] = 0;

        RetCode = WNetGetConnectionW(
                                DriveLetter,
                                DriveLetter,
                                &BufferLength
                                );

        if (RetCode == ERROR_NOT_CONNECTED) {
            return FALSE;
        } else {
            return TRUE;
        }

    } else {
        return TRUE;
    }

}

DWORD
EfsClientEncryptFile(
    IN LPCWSTR      FileName
    )
{
    DWORD           rc;
    BOOL            Result;


    UNICODE_STRING FullFileNameU;

    if (NULL == FileName) {
       return ERROR_INVALID_PARAMETER;
    }
    Result = TranslateFileName( FileName, &FullFileNameU );

    if (Result) {

        //
        // Call the server
        //

        rc = EfsEncryptFileRPCClient( &FullFileNameU );
        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {
        rc = GetLastError();
    }

    return( rc );
}

DWORD
EfsClientDecryptFile(
    IN LPCWSTR      FileName,
    IN DWORD        dwRecovery
    )
{
    DWORD           rc;
    BOOL            Result;

    UNICODE_STRING FullFileNameU;

    if (NULL == FileName) {
       return ERROR_INVALID_PARAMETER;
    }
    Result = TranslateFileName( FileName, &FullFileNameU );

    if (Result) {

        //
        // Call the server
        //

        rc = EfsDecryptFileRPCClient( &FullFileNameU, dwRecovery );
        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {
        rc = GetLastError();
    }


    return( rc );
}

BOOL
EfsClientFileEncryptionStatus(
    IN LPCWSTR      FileName,
    OUT LPDWORD      lpStatus
    )
/*++

Routine Description:

    This routine checks if a file is encryptable or not.

    We do not test the NTFS Volume 5 for the reason of performance.
    This means we might return a file encryptable (on FAT at etc.), but
    actually it could not be encrypted. This should be OK. This is a best effort
    API. We have the same problem with network file. Any way, a file could fail
    to be encrypted for many reasons, delegation, disk space and etc.
    We disable the encryption from %windir% down.
    We might change these features later.

Arguments:

    FileName - The file to be checked.

    lpStatus - The encryption status of the file. Error code if the return value is
                    FALSE.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            Result;
    DWORD        FileAttributes;

    UNICODE_STRING FullFileNameU;

    if ((NULL == FileName) || ( NULL == lpStatus)) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return FALSE;
    }

    //
    // GetFileAttributes should use the name before TanslateFileName
    // in case the passed in name is longer than MAX_PATH and using the
    // format \\?\
    //

    FileAttributes = GetFileAttributes( FileName );

    if (FileAttributes == -1){
        *lpStatus = GetLastError();
        return FALSE;
    }

    Result = TranslateFileName( FileName, &FullFileNameU );

    //
    // FullFileNameU.Length does not include the ending 0. The data returned from TranslateFileName does have the ending 0.
    //

    ASSERT(FullFileNameU.Buffer[FullFileNameU.Length / 2] == 0);

    if (Result) {

        if ( (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ||
             (FileAttributes & FILE_ATTRIBUTE_SYSTEM) ) {

            //
            // File not encryptable. Either it is encypted or a system file.
            //

            if ( FileAttributes & FILE_ATTRIBUTE_ENCRYPTED ){

                *lpStatus = FILE_IS_ENCRYPTED;

            } else {

                *lpStatus = FILE_SYSTEM_ATTR ;

            }

        } else {

            LPWSTR  TmpBuffer;
            LPWSTR  FullPathName;
            UINT    TmpBuffLen;
            UINT    FullPathLen;
            UINT    PathLength;
            BOOL    GotRoot;
            BOOL    EfsDisabled = FALSE;

            //
            // Check if it is the root.
            //

            if ( FullFileNameU.Length >= MAX_PATH * sizeof(WCHAR)){

                //
                // We need to put back the \\?\ or \\?\UNC\ to use the
                // Win 32 API. The extra max bytes needed is 7. ( \\?\UNC + NULL - \) 
                //

                FullPathLen = FullFileNameU.Length + 7 * sizeof(WCHAR);
                TmpBuffLen = FullPathLen;
                FullPathName = (LPWSTR)RtlAllocateHeap(
                                            RtlProcessHeap(),
                                            0,
                                            FullPathLen
                                            );
                TmpBuffer = (LPWSTR)RtlAllocateHeap(
                                            RtlProcessHeap(),
                                            0,
                                            TmpBuffLen
                                            );

                if ((FullPathName == NULL) || (TmpBuffer == NULL)){
                    RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);
                    if (FullPathName){
                        RtlFreeHeap(RtlProcessHeap(), 0, FullPathName);
                    }
                    if (TmpBuffer){
                        RtlFreeHeap(RtlProcessHeap(), 0, TmpBuffer);
                    }
                    *lpStatus = ERROR_OUTOFMEMORY;
                    return FALSE;
                }

                if ( FullFileNameU.Buffer[0] == L'\\' ){

                    //
                    // Put back the \\?\UNC\
                    //

                    wcscpy(FullPathName, L"\\\\?\\UNC");
                    wcscat(FullPathName, &(FullFileNameU.Buffer[1]));
                    FullPathLen = FullFileNameU.Length + 6 * sizeof(WCHAR);

                } else {

                    //
                    // Put back the \\?\
                    //

                    wcscpy(FullPathName, L"\\\\?\\");
                    wcscat(FullPathName, FullFileNameU.Buffer);
                    FullPathLen = FullFileNameU.Length + 4 * sizeof(WCHAR);
                }

            } else {
                TmpBuffLen = MAX_PATH * sizeof(WCHAR);
                TmpBuffer = (LPWSTR)RtlAllocateHeap(
                                            RtlProcessHeap(),
                                            0,
                                            TmpBuffLen
                                            );
                if (TmpBuffer == NULL){
                    RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);
                    *lpStatus = ERROR_OUTOFMEMORY;
                    return FALSE;
                }

                FullPathName = FullFileNameU.Buffer;
                FullPathLen = FullFileNameU.Length;
            }

            //
            // Check desktop.ini here
            //


            wcscpy(TmpBuffer, FullFileNameU.Buffer); 
            if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

                //
                // This is a file. Get the DIR path
                //

                int ii;

                ii = wcslen(TmpBuffer) - 1;
                while ((ii >= 0) && (TmpBuffer[ii] != L'\\')) {
                    ii--;
                }
                if (ii>=0) {
                    TmpBuffer[ii] = 0;
                }

            }

            EfsDisabled = DirEfsDisabled( TmpBuffer );

            if (EfsDisabled) {
               *lpStatus = FILE_DIR_DISALLOWED;
            } else if (!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (FileAttributes & FILE_ATTRIBUTE_READONLY)){

                //
                // Read only file
                //

                *lpStatus = FILE_READ_ONLY;
            } else {
                GotRoot = GetVolumePathName(
                                    FullPathName,
                                    TmpBuffer,
                                    TmpBuffLen
                                    );
    
                if ( GotRoot ){
    
                    DWORD RootLength = wcslen(TmpBuffer) - 1;
                    TmpBuffer[RootLength] = NULL;
                    if ( (FullPathLen == RootLength * sizeof (WCHAR))
                           && !wcscmp(TmpBuffer, FullPathName)){
    
                        //
                        // It is the root
                        //
    
                        *lpStatus = FILE_ROOT_DIR;
    
                    } else {
    
                        //
                        // Check if it is the Windows\system32 directories
                        //
    
                        PathLength = GetSystemWindowsDirectory( TmpBuffer, TmpBuffLen );                    
                        //PathLength = GetWindowsDirectory( TmpBuffer, TmpBuffLen );
                        //PathLength = GetSystemDirectory( TmpBuffer, TmpBuffLen );
    
                        ASSERT(PathLength <= TmpBuffLen);
    
                        if ( PathLength > TmpBuffLen ) {
    
                            //
                            // This is unlikely. Not sure who will ever have the length
                            // of %windir%\system32 longer than MAXPATH in the real world. 
                            // Even this happen, user could still encrypt the file. FILE_UNKNOWN
                            // does not mean file could\or couldn't be encrypted.
                            //
    
                            *lpStatus = FILE_UNKNOWN ;
    
                        } else {
    
                            if ( ( FullFileNameU.Length < PathLength * sizeof (WCHAR) ) ||
                                  ( ( FullFileNameU.Buffer[PathLength] ) &&
                                    ( FullFileNameU.Buffer[PathLength] != L'\\') )){
    
                                //
                                // Check if a remote file
                                //
    
                                if ( RemoteFile( FullFileNameU.Buffer ) ){
    
                                    *lpStatus = FILE_UNKNOWN;
    
                                } else {
    
                                    *lpStatus = FILE_ENCRYPTABLE;
    
                                }
    
                            } else {
    
                                if ( _wcsnicmp(TmpBuffer, FullFileNameU.Buffer, PathLength)){
    
                                    //
                                    // Not under %SystemRoot%
                                    //
    
                                    if ( RemoteFile( FullFileNameU.Buffer ) ){
    
                                        *lpStatus = FILE_UNKNOWN;
    
                                    } else {
    
                                        *lpStatus = FILE_ENCRYPTABLE;
    
                                    }
                                } else {
    
                                    //
                                    // In windows root directory. WINNT
                                    //
    
                                    BOOL bRet;
                                    DWORD allowPathLen;
    
                                    //
                                    // Check for allow lists
                                    //
    
                                    allowPathLen = (DWORD) TmpBuffLen;
                                    bRet = GetProfilesDirectory(TmpBuffer, &allowPathLen);
                                    if (!bRet){
                                        RtlFreeHeap(RtlProcessHeap(), 0, TmpBuffer);
                                        TmpBuffer = (LPWSTR)RtlAllocateHeap(
                                                                RtlProcessHeap(),
                                                                0,
                                                                allowPathLen
                                                                );
                                        if (TmpBuffer){
                                            bRet = GetProfilesDirectory(TmpBuffer, &allowPathLen);
                                        } else {
                                            *lpStatus = ERROR_OUTOFMEMORY;
                                            Result = FALSE;
                                        }
                                    }
                                    if (bRet){
    
                                        //
                                        // Check for Profiles directory. allowPathLen including NULL.
                                        //
    
                                        if ((FullFileNameU.Length >= ((allowPathLen-1) * sizeof (WCHAR)) ) && 
                                             !_wcsnicmp(TmpBuffer, FullFileNameU.Buffer, allowPathLen - 1)){
                                            *lpStatus = FILE_ENCRYPTABLE;
                                        } else {
    
                                            //
                                            // Under %windir% but not profiles
                                            //
    
                                            *lpStatus = FILE_SYSTEM_DIR;
                                        }
                                    } else {
    
                                        if ( *lpStatus != ERROR_OUTOFMEMORY){
    
                                            //
                                            // This should not happen, unless a bug in GetProfilesDirectoryEx()
                                            //
                                            ASSERT(FALSE);
    
                                            *lpStatus = FILE_UNKNOWN;
                                        }
    
                                    }
                                }
                            }
                        }
                    }
                } else {
    
                    //
                    // Cannot get the root. The reason might very well be out of memory.
                    // Return FILE_UNKNOWN and let other codes dealing with the memory
                    // problem.
                    //
    
                    *lpStatus = FILE_UNKNOWN ;
    
                }
            }

            if ((FullPathName != FullFileNameU.Buffer) && FullPathName){
                RtlFreeHeap(RtlProcessHeap(), 0, FullPathName);
            }

            if (TmpBuffer){
                RtlFreeHeap(RtlProcessHeap(), 0, TmpBuffer);
            }

        }

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {
        *lpStatus = GetLastError();
    }

    return  Result;
}

DWORD
EfsClientOpenFileRaw(
    IN      LPCWSTR         FileName,
    IN      ULONG           Flags,
    OUT     PVOID *         Context
    )

/*++

Routine Description:

    This routine is used to open an encrypted file. It opens the file and
    prepares the necessary context to be used in ReadRaw data and WriteRaw
    data.


Arguments:

    FileName  --  File name of the file to be exported

    Flags -- Indicating if open for export or import; for directory or file.

    Context - Export context to be used by READ operation later. Caller should
              pass this back in ReadRaw().


Return Value:

    Result of the operation.

--*/

{
    DWORD        rc;
    BOOL            Result;
    UNICODE_STRING FullFileNameU;

    if ((NULL == FileName) || ( NULL == Context)) {
       return ERROR_INVALID_PARAMETER;
    }

    Result = TranslateFileName( FileName, &FullFileNameU );

    if (Result) {

        rc =  (EfsOpenFileRawRPCClient(
                        FullFileNameU.Buffer,
                        Flags,
                        Context
                        )
                    );

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {
        rc = GetLastError();
    }

    return rc;

}

DWORD
EfsClientReadFileRaw(
    IN      PFE_EXPORT_FUNC ExportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine is used to read encrypted file's raw data. It uses
    NTFS FSCTL to get the data.

Arguments:

    ExportCallback --  Caller supplied callback function to process the
                       raw data.

    CallbackContext -- Caller's context passed back in ExportCallback.

    Context - Export context created in the CreateRaw.

Return Value:

    Result of the operation.

--*/

{
    return ( EfsReadFileRawRPCClient(
                    ExportCallback,
                    CallbackContext,
                    Context
                    ));
}

DWORD
EfsClientWriteFileRaw(
    IN      PFE_IMPORT_FUNC ImportCallback,
    IN      PVOID           CallbackContext,
    IN      PVOID           Context
    )

/*++

Routine Description:

    This routine is used to write encrypted file's raw data. It uses
    NTFS FSCTL to write the data.

Arguments:

    ImportCallback --  Caller supplied callback function to provide the
                       raw data.

    CallbackContext -- Caller's context passed back in ImportCallback.

    Context - Import context created in the CreateRaw.

Return Value:

    Result of the operation.

--*/

{

    return ( EfsWriteFileRawRPCClient(
                    ImportCallback,
                    CallbackContext,
                    Context
                    ));
}

VOID
EfsClientCloseFileRaw(
    IN      PVOID           Context
    )
/*++

Routine Description:

    This routine frees the resources allocated by the CreateRaw

Arguments:

    Context - Created by the CreateRaw.

Return Value:

    NO.

--*/
{
    if ( !Context ){
        return;
    }

    EfsCloseFileRawRPCClient( Context );
}


//
// Beta 2 API
//

DWORD
EfsClientAddUsers(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    )
/*++

Routine Description:

    Calls client stub for AddUsersToFile EFS API.

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    nUsers - Supplies the number of entries in teh pEncryptionCertificates array

    pEncryptionCertificates - Supplies an array of pointers to PENCRYPTION_CERTIFICATE
        structures.  Length of array is given in nUsers parameter.

Return Value:

--*/
{
    DWORD        rc = ERROR_SUCCESS;
    UNICODE_STRING FullFileNameU;
    DWORD        ii = 0;
    CERT_CHAIN_PARA CertChainPara;


    if ((NULL == lpFileName) || (NULL == pEncryptionCertificates)) {
       return ERROR_INVALID_PARAMETER;
    }

    //
    // Let's check to see if the certs are good or not.
    //

    CertChainPara.cbSize = sizeof(CERT_CHAIN_PARA);
    CertChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    CertChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
    CertChainPara.RequestedUsage.Usage.rgpszUsageIdentifier=&EfsOidlpstr;

    while ((ERROR_SUCCESS == rc) && (ii < pEncryptionCertificates->nUsers)) {

        PCCERT_CONTEXT pCertContext = CertCreateCertificateContext(
                                          X509_ASN_ENCODING,
                                          pEncryptionCertificates->pUsers[ii]->pCertBlob->pbData,
                                          pEncryptionCertificates->pUsers[ii]->pCertBlob->cbData
                                          );
        if (pCertContext != NULL) {

            PCCERT_CHAIN_CONTEXT pChainContext;

            //
            // Do the chain validation
            //
            
            if (CertGetCertificateChain (
                                        HCCE_CURRENT_USER,
                                        pCertContext,
                                        NULL,
                                        NULL,
                                        &CertChainPara,
                                        0,
                                        NULL,
                                        &pChainContext
                                        )) {
                //
                // Let's check the chain
                //

                PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[ 0 ];
                PCERT_CHAIN_ELEMENT pElement = pChain->rgpElement[ 0 ];
                BOOL bSelfSigned = pElement->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED;
                DWORD dwErrorStatus = pChainContext->TrustStatus.dwErrorStatus;

                if (dwErrorStatus) {
                    if ((dwErrorStatus == CERT_TRUST_IS_UNTRUSTED_ROOT) && bSelfSigned ){

                        //
                        // Self signed. Check if it is in the my trusted store
                        //
                        HCERTSTORE trustedStore;
                        PCCERT_CONTEXT pCert=NULL;

                        trustedStore = CertOpenStore(
                                                CERT_STORE_PROV_SYSTEM_W,
                                                0,       // dwEncodingType
                                                0,       // hCryptProv,
                                                CERT_SYSTEM_STORE_CURRENT_USER,
                                                TRUSTEDPEOPLE
                                                );

                        if (trustedStore) {

                            pCert = CertFindCertificateInStore(
                                        trustedStore,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        0,
                                        CERT_FIND_EXISTING,
                                        pCertContext,
                                        pCert
                                        );
                            if (pCert) {
                    
                                //
                                // We found it.
                                //
                                CertFreeCertificateContext(pCert);

                            } else {

                                //
                                // Not trusted self-signed cert
                                //

                                rc = CERT_E_UNTRUSTEDROOT;

                            }

                            CertCloseStore( trustedStore, 0 );

                        } else {
                            rc = GetLastError();
                        }

                    } else {

                        //
                        // Other chain build error
                        //  Let's get the error code of the chain building.
                        //

                        CERT_CHAIN_POLICY_PARA PolicyPara;
                        CERT_CHAIN_POLICY_STATUS PolicyStatus;

                        RtlZeroMemory(&PolicyPara, sizeof(CERT_CHAIN_POLICY_PARA));
                        RtlZeroMemory(&PolicyStatus, sizeof(CERT_CHAIN_POLICY_STATUS));

                        PolicyPara.cbSize = sizeof(CERT_CHAIN_POLICY_PARA);
                        PolicyStatus.cbSize = sizeof(CERT_CHAIN_POLICY_STATUS);

                        if (!CertVerifyCertificateChainPolicy(
                                CERT_CHAIN_POLICY_BASE,
                                pChainContext,
                                &PolicyPara,
                                &PolicyStatus
                                )) {

                            rc = PolicyStatus.dwError;
                        }

                    }
                }

                CertFreeCertificateChain( pChainContext );

            } else {

                rc = GetLastError();

            }

            CertFreeCertificateContext(pCertContext);

        } else {

            rc = GetLastError();

        }

        ii++;
    }

    if (ERROR_SUCCESS == rc) {

        if (TranslateFileName( lpFileName, &FullFileNameU )) {
    
            rc = EfsAddUsersRPCClient( FullFileNameU.Buffer, pEncryptionCertificates );
    
            RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);
    
        } else {
    
            rc = GetLastError();
        }

    }

    return rc;
}

DWORD
EfsClientRemoveUsers(
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashes
    )
/*++

Routine Description:

    Calls client stub for RemoveUsersFromFile EFS API

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    pHashes - Supplies a structure containing a list of PENCRYPTION_CERTIFICATE_HASH
        structures, each of which represents a user to remove from the specified file.

Return Value:

--*/
{
    DWORD        rc;
    UNICODE_STRING FullFileNameU;


    if ((NULL == lpFileName) || (NULL == pHashes) || (pHashes->pUsers == NULL)) {
       return ERROR_INVALID_PARAMETER;
    }
    if (TranslateFileName( lpFileName, &FullFileNameU )) {

        rc =  EfsRemoveUsersRPCClient( FullFileNameU.Buffer, pHashes );

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {

        rc = GetLastError();
    }

    return rc;
}

DWORD
EfsClientQueryRecoveryAgents(
    IN      LPCWSTR                             lpFileName,
    OUT     PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    )
/*++

Routine Description:

    Calls client stub for QueryRecoveryAgents EFS API

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    pRecoveryAgents - Returns a pointer to a structure containing a list
        of PENCRYPTION_CERTIFICATE_HASH structures, each of which represents
        a recovery agent on the file.

Return Value:

--*/
{
    DWORD        rc;
    UNICODE_STRING FullFileNameU;


    if ((NULL == lpFileName) || (NULL == pRecoveryAgents)) {
       return ERROR_INVALID_PARAMETER;
    }
    if (TranslateFileName( lpFileName, &FullFileNameU )) {

        rc =  EfsQueryRecoveryAgentsRPCClient( FullFileNameU.Buffer, pRecoveryAgents );

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {

        rc = GetLastError();
    }

    return rc;
}

DWORD
EfsClientQueryUsers(
    IN      LPCWSTR                             lpFileName,
    OUT     PENCRYPTION_CERTIFICATE_HASH_LIST * pUsers
    )
/*++

Routine Description:

    Calls client stub for QueryUsersOnFile EFS API

Arguments:

    lpFileName - Supplies the name of the file to be modified.

    pUsers - Returns a pointer to a structure containing a list
        of PENCRYPTION_CERTIFICATE_HASH structures, each of which represents
        a user of this file (that is, someone who can decrypt the file).

Return Value:

--*/
{
    DWORD        rc;
    UNICODE_STRING FullFileNameU;

    if ((NULL == lpFileName) || (NULL == pUsers)) {
       return ERROR_INVALID_PARAMETER;
    }
    if (TranslateFileName( lpFileName, &FullFileNameU )) {

        rc =  EfsQueryUsersRPCClient( FullFileNameU.Buffer, pUsers );

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {

        rc = GetLastError();
    }

    return rc;
}


DWORD
EfsClientSetEncryptionKey(
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
/*++

Routine Description:

    Calls client stub for SetFileEncryptionKey EFS API

Arguments:

    pEncryptionCertificate - Supplies a pointer to an EFS certificate
        representing the public key to use for future encryption operations.

Return Value:

--*/
{
    /*
    if ((NULL == pEncryptionCertificate) || ( NULL == pEncryptionCertificate->pCertBlob)) {
       return ERROR_INVALID_PARAMETER;
    }
    */

    if ( pEncryptionCertificate && ( NULL == pEncryptionCertificate->pCertBlob)) {
       return ERROR_INVALID_PARAMETER;
    }

    DWORD rc =  EfsSetEncryptionKeyRPCClient( pEncryptionCertificate );

    return( rc );
}

VOID
EfsClientFreeHashList(
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pHashList
    )
/*++

Routine Description:

    This routine frees the memory allocated by a call to
    QueryUsersOnEncryptedFile and QueryRecoveryAgentsOnEncryptedFile

Arguments:

    pHashList - Supplies the hash list to be freed.

Return Value:

    None.  Faults in user's context if passed bogus data.

--*/

{
    if (NULL == pHashList) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return;
    }

    for (DWORD i=0; i<pHashList->nCert_Hash ; i++) {

         PENCRYPTION_CERTIFICATE_HASH pHash = pHashList->pUsers[i];

         if (pHash->lpDisplayInformation) {
             MIDL_user_free( pHash->lpDisplayInformation );
         }

         if (pHash->pUserSid) {
             MIDL_user_free( pHash->pUserSid );
         }

         MIDL_user_free( pHash->pHash->pbData );
         MIDL_user_free( pHash->pHash );
         MIDL_user_free( pHash );
    }

    MIDL_user_free( pHashList->pUsers );
    MIDL_user_free( pHashList );

    return;
}

DWORD
EfsGetMySDRpcBlob(
    IN PSECURITY_DESCRIPTOR pInSD,
    OUT PEFS_RPC_BLOB *pOutSDRpcBlob
    )
{
    DWORD rc = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pRelativeSD;
    ULONG SDLength = 0;

    if ( (pInSD == NULL) || !RtlValidSecurityDescriptor(pInSD) ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( ((PISECURITY_DESCRIPTOR)pInSD)->Control & SE_SELF_RELATIVE) {

        //
        // The input SD is already RELATIVE
        // Just fill EFS_RPC_BLOB
        //


        *pOutSDRpcBlob = (PEFS_RPC_BLOB) RtlAllocateHeap(
                                             RtlProcessHeap(),
                                             0,
                                             sizeof(EFS_RPC_BLOB) 
                                             );
        if (*pOutSDRpcBlob) {

            (*pOutSDRpcBlob)->cbData = RtlLengthSecurityDescriptor (
                                            pInSD
                                            );
            (*pOutSDRpcBlob)->pbData = (PBYTE) pInSD;

        } else {

            return(ERROR_NOT_ENOUGH_MEMORY);

        }


    } else {

        //
        // get the length
        //
        RtlMakeSelfRelativeSD( pInSD,
                               NULL,
                               &SDLength
                             );
    
        if ( SDLength > 0 ) {
    
            *pOutSDRpcBlob = (PEFS_RPC_BLOB) RtlAllocateHeap(
                                                 RtlProcessHeap(),
                                                 0,
                                                 SDLength + sizeof(EFS_RPC_BLOB) 
                                                 );

    
            if ( !(*pOutSDRpcBlob) ) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            pRelativeSD = (PSECURITY_DESCRIPTOR)(*pOutSDRpcBlob + 1);
            (*pOutSDRpcBlob)->cbData = SDLength;
            (*pOutSDRpcBlob)->pbData = (PBYTE) pRelativeSD;

    
            rc = RtlNtStatusToDosError(
                     RtlMakeSelfRelativeSD( pInSD,
                                            pRelativeSD,
                                            &SDLength
                                          ));
            if ( rc != ERROR_SUCCESS ) {
    
                RtlFreeHeap(RtlProcessHeap(), 0, *pOutSDRpcBlob);
                *pOutSDRpcBlob = NULL;
                return(rc);

            }
    
        } else {
    
            //
            // something is wrong with the SD
            //
            return(ERROR_INVALID_PARAMETER);
        }
    }

    return(rc);

}

DWORD
EfsClientDuplicateEncryptionInfo(
    IN LPCWSTR lpSrcFile,
    IN LPCWSTR lpDestFile,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    DWORD rc = ERROR_SUCCESS;

    UNICODE_STRING SrcFullFileNameU;
    UNICODE_STRING DestFullFileNameU;

    if (TranslateFileName( lpSrcFile, &SrcFullFileNameU )) {

        if (TranslateFileName( lpDestFile, &DestFullFileNameU )) {

            PEFS_RPC_BLOB pRpcBlob = NULL;
            BOOL bInheritHandle = FALSE;

            if (lpSecurityAttributes) {
                rc = EfsGetMySDRpcBlob(lpSecurityAttributes->lpSecurityDescriptor, &pRpcBlob);
                bInheritHandle = lpSecurityAttributes->bInheritHandle;
            }
            
            if (ERROR_SUCCESS == rc) {

                rc = EfsDuplicateEncryptionInfoRPCClient(
                        SrcFullFileNameU.Buffer,
                        DestFullFileNameU.Buffer,
                        dwCreationDistribution,
                        dwAttributes,
                        pRpcBlob,
                        bInheritHandle
                        );

                if (pRpcBlob) {

                    RtlFreeHeap(RtlProcessHeap(), 0, pRpcBlob);

                }
    
            }

            RtlFreeHeap(RtlProcessHeap(), 0, DestFullFileNameU.Buffer);

        } else {

            rc = GetLastError();
        }

        RtlFreeHeap(RtlProcessHeap(), 0, SrcFullFileNameU.Buffer);

    } else {

        rc = GetLastError();
    }

    return( rc );

}


DWORD
EfsClientFileKeyInfo(
    IN      LPCWSTR        lpFileName,
    IN      DWORD          InfoClass,
    OUT     PEFS_RPC_BLOB  *KeyInfo
    )
/*++

Routine Description:

    Calls client stub for EncryptedFileKeyInfo EFS API

Arguments:

    lpFileName - Supplies the name of the file.

    KeyInfo - Returns a pointer to a structure containing key info.
    
Return Value:

--*/
{
    DWORD        rc;
    UNICODE_STRING FullFileNameU;
    DWORD          FileAttributes;

    if ((NULL == lpFileName) || (NULL == KeyInfo)) {
       return ERROR_INVALID_PARAMETER;
    }

    if ((InfoClass != BASIC_KEY_INFO) && (InfoClass != UPDATE_KEY_USED)) {
        return ERROR_INVALID_PARAMETER;
    }
    
    if ( InfoClass == UPDATE_KEY_USED) {

        FileAttributes = GetFileAttributes( lpFileName );
        if ( (FileAttributes == -1) || !(FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            return ERROR_INVALID_PARAMETER;

        }
    }

    if (TranslateFileName( lpFileName, &FullFileNameU )) {

        rc =  EfsFileKeyInfoRPCClient( FullFileNameU.Buffer, InfoClass, KeyInfo );

        RtlFreeHeap(RtlProcessHeap(), 0, FullFileNameU.Buffer);

    } else {

        rc = GetLastError();
    }

    return rc;
}


VOID
EfsClientFreeKeyInfo(
    IN PEFS_RPC_BLOB  pKeyInfo
    )
/*++

Routine Description:

    This routine frees the memory allocated by a call to
    EfsClientFileKeyInfo

Arguments:

    pKeyInfo - Supplies the memory pointer to be freed.

Return Value:

    None.  Faults in user's context if passed bogus data.

--*/

{
    if (NULL == pKeyInfo) {
       SetLastError(ERROR_INVALID_PARAMETER);
       return;
    }

    if (pKeyInfo->pbData) {
        MIDL_user_free( pKeyInfo->pbData );
    }
    
    MIDL_user_free( pKeyInfo );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\accctrl2\src\iterator.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) 1993, Microsoft Corporation.
//
// File:        iterator.cxx
//
// Classes:     CIterator
//
// History:     Nov-93      DaveMont         Created.
//
//-------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

ULONG
CIterator::NumberEntries()
{
    return (0);
}

DWORD
CIterator::InitAccountAccess( CAccountAccess * caa,
                              LPWSTR           system,
                              IS_CONTAINER     fdir,
                              BOOL             fSaveNamesAndSids)
{
    return (0);
}

//+---------------------------------------------------------------------------
//
//  Member:    ctor, public
//
//  Synopsis:   initializes member variables
//
//  Arguments:  none
//
//----------------------------------------------------------------------------
CAclIterator::CAclIterator()
    : _pacl(NULL),
      _pcurrentace(NULL),
      _acecount(0)
{
}
//+---------------------------------------------------------------------------
//
//  Member:    new, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void * CAclIterator::operator new(size_t size)
{
    return(RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (ULONG)size));
}
//+---------------------------------------------------------------------------
//
//  Member:    delete, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void CAclIterator::operator delete(void *p, size_t size)
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}
//+---------------------------------------------------------------------------
//
//  Member:    Init, public
//
//  Synopsis:   initializes acl variables
//
//  Arguments:  IN - [pacl]  - the acl to iterate thru
//
//----------------------------------------------------------------------------
void CAclIterator::Init(PACL pacl)
{
    _acecount = 0;
    _pacl = pacl;
}

//+---------------------------------------------------------------------------
//
//  Member:     InitAccountAccess, public
//
//  Synopsis:   initializes the AccountAccess object for the current ACL iteration
//
//  Arguments:  IN - [caa]  - class encapsulating accounts and access rights
//              IN - [system]  - the machine to use for name/id lookups
//              IN - [fdir] - object/container status
//
//----------------------------------------------------------------------------
DWORD CAclIterator::InitAccountAccess(CAccountAccess *caa,
                                      LPWSTR system,
                                      IS_CONTAINER fdir,
                                      BOOL fSaveNamesAndSids)
{
    ACCESS_MODE accessmode;
    BOOL fimpersonate = FALSE;
    DWORD status;


    //
    // set the access mode based on the ace type
    //
    if (_pcurrentace->AceType == ACCESS_ALLOWED_ACE_TYPE)
    {
        accessmode = SET_ACCESS;
    } else if (_pcurrentace->AceType == ACCESS_DENIED_ACE_TYPE)
    {
        accessmode = DENY_ACCESS;
    } else if (_pcurrentace->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE)
    {
        fimpersonate = TRUE;
        accessmode = SET_ACCESS;
    } else if (_pcurrentace->AceType == SYSTEM_AUDIT_ACE_TYPE)
    {
        if (_pcurrentace->AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG)
        {
            if (_pcurrentace->AceFlags & FAILED_ACCESS_ACE_FLAG)
            {
                accessmode = (ACCESS_MODE) SE_AUDIT_BOTH;
            } else
            {
                accessmode = SET_AUDIT_SUCCESS;
            }
        } else if (_pcurrentace->AceFlags & FAILED_ACCESS_ACE_FLAG)
        {
            accessmode = SET_AUDIT_FAILURE;
        } else
        {
            return(ERROR_INVALID_ACL);
        }
    } else
    {
        return(ERROR_INVALID_ACL);
    }

    //
    // initialize the accountaccess class
    //
    if (!fimpersonate)
    {
         status = caa->Init((PSID) (&((PACCESS_ALLOWED_ACE)_pcurrentace)->SidStart),
                          system,
                       accessmode,
                       ((PACCESS_ALLOWED_ACE)_pcurrentace)->Mask,
                       _pcurrentace->AceFlags & VALID_INHERIT_FLAGS,
                       fSaveNamesAndSids);
    } else
    {
        PSID psid = (PSID)((PBYTE)(&((PCOMPOUND_ACCESS_ALLOWED_ACE)_pcurrentace)->SidStart) +
        RtlLengthSid(&((PCOMPOUND_ACCESS_ALLOWED_ACE)_pcurrentace)->SidStart));
        if (NO_ERROR == (status = caa->Init(psid,
                          system,
                       accessmode,
                       ((PCOMPOUND_ACCESS_ALLOWED_ACE)_pcurrentace)->Mask,
                       _pcurrentace->AceFlags & VALID_INHERIT_FLAGS,
                       fSaveNamesAndSids)))
        {
            status = caa->SetImpersonateSid((PSID) (&((PCOMPOUND_ACCESS_ALLOWED_ACE)_pcurrentace)->SidStart));
        }
    }

    return(status);
}

//+---------------------------------------------------------------------------
//
//  Member:     ctor, public
//
//  Synopsis:   initialized member variables
//
//  Arguments:  IN - [pae]  - access entries
//              IN - [count] - number of access entries
//
//----------------------------------------------------------------------------
CAesIterator::CAesIterator()
   :_pae(NULL),
    _pcurrententry(NULL),
    _curcount(0),
    _totalcount(0)
{
}
//+---------------------------------------------------------------------------
//
//  Member:    new, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void * CAesIterator::operator new(size_t size)
{
    return(RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (ULONG)size));
}
//+---------------------------------------------------------------------------
//
//  Member:    delete, public
//
//  Synopsis:
//
//----------------------------------------------------------------------------
void CAesIterator::operator delete(void *p, size_t size)
{
    RtlFreeHeap(RtlProcessHeap(), 0, p);
}
//+---------------------------------------------------------------------------
//
//  Member:     Init, public
//
//  Synopsis:   initialized member variables
//
//  Arguments:  IN - [pae]  - access entries
//              IN - [count] - number of access entries
//
//----------------------------------------------------------------------------
void CAesIterator::Init(ULONG ccount, PACCESS_ENTRY pae)
{
    _pae = pae;
    _pcurrententry = NULL;
    _curcount = 0;
    _totalcount = ccount;
}
//+---------------------------------------------------------------------------
//
//  Member:     InitAccountAccess, public
//
//  Synopsis:   initializes the AccountAccess object for the current ACL iteration
//
//  Arguments:  IN - [caa]  - class encapsulating accounts and access rights
//              IN - [system]  - the machine to use for name/id lookups
//              IN - [fdir] - object/container status
//
//----------------------------------------------------------------------------
DWORD CAesIterator::InitAccountAccess(CAccountAccess *caa,
                                      LPWSTR system,
                                      IS_CONTAINER fdir,
                                      BOOL fSaveNamesAndSids)
{
    DWORD status;


    //
    // initialize the accountaccess class depending on type of trustee
    //
    if (_pcurrententry->Trustee.TrusteeForm == TRUSTEE_IS_SID)
    {
        status = caa->Init( (PSID)GetTrusteeName(&(_pcurrententry->Trustee)),
                            system,
                            _pcurrententry->AccessMode,
                            _pcurrententry->AccessMask,
                            _pcurrententry->InheritType,
                            fSaveNamesAndSids );
    }
    else if (_pcurrententry->Trustee.TrusteeForm == TRUSTEE_IS_NAME)
    {
        status = caa->Init( GetTrusteeName(&(_pcurrententry->Trustee)),
                            system,
                            _pcurrententry->AccessMode,
                            _pcurrententry->AccessMask,
                            _pcurrententry->InheritType,
                            fSaveNamesAndSids );
    }
    else
    {
        status = ERROR_NOT_SUPPORTED;
    }

    if ( status == NO_ERROR &&
         GetMultipleTrusteeOperation(&_pcurrententry->Trustee) ==
             TRUSTEE_IS_IMPERSONATE )
    {
        switch (GetTrusteeForm(GetMultipleTrustee(&_pcurrententry->Trustee)))
        {
        case TRUSTEE_IS_SID:
            status = caa->SetImpersonateSid(
                              (PSID)GetTrusteeName(
                                  GetMultipleTrustee(&_pcurrententry->Trustee)));
            break;
        case TRUSTEE_IS_NAME:
            status = caa->SetImpersonateName(
                              (LPWSTR)GetTrusteeName(
                                  GetMultipleTrustee(&_pcurrententry->Trustee)));
            break;
        default:
            //
            // in this case, need to lookup the name from the current sec token on
            // the thread or process
            //
            status = ERROR_NOT_SUPPORTED;
            break;
        }
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\controls.hpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// controls.hpp
//
// User interface control classes.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#ifndef __CONTROLS_HPP__
#define __CONTROLS_HPP__

//-----------------------------------------------------------------------------

#include <objidl.h>
#include <scuisupp.h>

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

extern CLSID CreduiStringArrayClassId;

#define CREDUI_STRING_ARRAY_CLASS_STRING\
            L"{82BD0E67-9FEA-4748-8672-D5EFE5B779B0}"

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

struct CREDUI_BALLOON_TIP_INFO
{
    WCHAR *Title;
    WCHAR *Text;
    INT Icon;
    INT XPercent;
    INT YPercent;
};

//-----------------------------------------------------------------------------
// CreduiBalloonTip Class
//-----------------------------------------------------------------------------

class CreduiBalloonTip
{
public:

    CreduiBalloonTip();
    ~CreduiBalloonTip();

    BOOL Init(HINSTANCE instance, HWND parentWindow);

    BOOL SetInfo(HWND controlWindow, CONST CREDUI_BALLOON_TIP_INFO *tipInfo);
    CREDUI_BALLOON_TIP_INFO *GetInfo() { return TipInfo; }

    BOOL Show();
    BOOL Hide();
    BOOL IsVisible() { return Visible; }

private:

    HWND Window;
    HWND ParentWindow;
    HWND ControlWindow;

    CREDUI_BALLOON_TIP_INFO *TipInfo;

    BOOL Visible;
};

//-----------------------------------------------------------------------------
// CreduiPasswordBox Class
//-----------------------------------------------------------------------------

class CreduiPasswordBox
{
public:

    CreduiPasswordBox();
    ~CreduiPasswordBox();

    BOOL Init(
        HWND window,
        CreduiBalloonTip *ballonTip,
        CONST CREDUI_BALLOON_TIP_INFO *capsLockTipInfo,
        HFONT passwordFont = NULL,
        WCHAR passwordChar = L'');

private:

    WNDPROC OriginalMessageHandler;

    LRESULT
    MessageHandler(
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );

    static LRESULT CALLBACK MessageHandlerCallback(
        HWND passwordWindow,
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );

    HWND Window;
    HFONT PasswordFont;
    CreduiBalloonTip *BalloonTip;
    CONST CREDUI_BALLOON_TIP_INFO *CapsLockTipInfo;
};

//-----------------------------------------------------------------------------
// CreduiStringArrayFactory Class
//-----------------------------------------------------------------------------

class CreduiStringArrayFactory : public IClassFactory
{
public:

    CreduiStringArrayFactory();

    // IUnknown

    HRESULT STDMETHODCALLTYPE QueryInterface(
        CONST IID &interfaceId,
        VOID **outInterface
        );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IClassFactory

    HRESULT STDMETHODCALLTYPE CreateInstance(
        IUnknown *unknownOuter,
        CONST IID &interfaceId,
        VOID **outInterface
        );
    HRESULT STDMETHODCALLTYPE LockServer(BOOL lock);

private:

    ~CreduiStringArrayFactory(); // must use IUnknown::Release()

    ULONG ReferenceCount;
};

//-----------------------------------------------------------------------------
// CreduiStringArray Class
//-----------------------------------------------------------------------------

class CreduiStringArray : public IEnumString
{
public:

    CreduiStringArray();

    BOOL Init(UINT count);
    BOOL Find(CONST WCHAR *string);
    INT Add(CONST WCHAR *string);

    UINT GetCount() CONST { return Count; }

    // IUnknown

    HRESULT STDMETHODCALLTYPE QueryInterface(
        CONST IID &interfaceId,
        VOID **outInterface
        );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumString

    HRESULT STDMETHODCALLTYPE Next(
        ULONG count,
        WCHAR **array,
        ULONG *countFetched
        );
    HRESULT STDMETHODCALLTYPE Skip(ULONG count);
    HRESULT STDMETHODCALLTYPE Reset();
    HRESULT STDMETHODCALLTYPE Clone(IEnumString **enumInterface);

private:

    ~CreduiStringArray(); // must use IUnknown::Release()

    ULONG ReferenceCount;
    UINT Index;
    UINT Count;
    UINT MaxCount;
    WCHAR **Array;
};

//-----------------------------------------------------------------------------
// CreduiAutoCompleteComboBox Class
//-----------------------------------------------------------------------------

class CreduiAutoCompleteComboBox
{
public:

    CreduiAutoCompleteComboBox();
    ~CreduiAutoCompleteComboBox();

    BOOL Init(
        HMODULE instance,
        HWND comboBoxwindow,
        UINT stringCount,
        INT imageListResourceId = 0,
        INT initialImage = -1
        );
    INT Add(
        WCHAR *string,
        INT image = -1,
        BOOL autoComplete = TRUE,
        BOOL addUnique = TRUE,
        INT indexBefore = -1,
        INT indent = 0
        );
    BOOL Update(
        INT index,
        WCHAR *string,
        INT image = -1
        );
    BOOL Enable();

private:

    HWND Window;
    HIMAGELIST ImageList;
    CreduiStringArray *StringArray;
};

//-----------------------------------------------------------------------------
// CreduiIconParentWindow Class
//-----------------------------------------------------------------------------

class CreduiIconParentWindow
{
public:

    CreduiIconParentWindow();
    ~CreduiIconParentWindow();

    BOOL Init(HINSTANCE instance, UINT iconResourceId);
    HWND GetWindow() { return Window; }

    static BOOL Register(HINSTANCE instance);
    static BOOL Unregister();

private:

    HWND Window;

    static CONST WCHAR *ClassName;
    static HINSTANCE Instance;
    static LONG Registered;
};




//-----------------------------------------------------------------------------
// CreduiCredentialControl Class
//-----------------------------------------------------------------------------

class CreduiCredentialControl
{
public:

    CreduiCredentialControl();
    ~CreduiCredentialControl();

    static BOOL Register(HINSTANCE instance);
    static BOOL Unregister();

    virtual BOOL
    OnHelpInfo(
        LPARAM lp
        );


    virtual UINT
    MapID(UINT uid);


private:

    static CONST WCHAR *ClassName;
    static HINSTANCE Instance;
    static LONG Registered;

    BOOL IsInitialized;

    // User interface control state flags:

    enum
    {
        DISABLED_CONTROL            = 0x0001,
        DISABLED_CONTROL_PASSWORD   = 0x0002,
        DISABLED_CONTROL_USERNAME   = 0x0010,
        DISABLED_CONTROL_VIEW       = 0x0004,
        DISABLED_CONTROL_SAVE       = 0x0008,
    };

    BOOL DisabledControlMask;

    // User type image indices:

    enum
    {
        IMAGE_USERNAME              = 0,
        IMAGE_CERT                  = 1,
        IMAGE_CERT_EXPIRED          = 2,
        IMAGE_SMART_CARD            = 3,
        IMAGE_SMART_CARD_MISSING    = 4,
        IMAGE_SMART_CARD_EXPIRED    = 5
    };

    HWND Window;
    LONG Style;

    HWND UserNameStaticWindow;
    HWND UserNameControlWindow;
    HWND ViewCertControlWindow;
    HWND PasswordStaticWindow;
    HWND PasswordControlWindow;
    HWND SaveControlWindow;

    BOOL FirstPaint;
    BOOL ShowBalloonTip;
    CreduiBalloonTip BalloonTip;

    BOOL IsAutoComplete;
    BOOL NoEditUserName;
    BOOL KeepUserName;

    BOOL IsPassport;

    CreduiPasswordBox PasswordBox;

    UCHAR (*CertHashes)[CERT_HASH_LENGTH];
    ULONG CertCount;
    INT   CertBaseInComboBox;
    UCHAR (*UserNameCertHash)[CERT_HASH_LENGTH];
    INT   SmartCardBaseInComboBox;
    UINT SmartCardReadCount;
    UINT IsChangingUserName;
    UINT IsChangingPassword;

    CreduiAutoCompleteComboBox UserNameComboBox;

    LONG UserNameSelection;

    HSCARDUI ScardUiHandle;

    // Functions:

    BOOL InitWindow();
    BOOL CreateControls();
    BOOL InitComboBoxUserNames();
    BOOL AddCertificates();

    BOOL ViewCertificate(INT index);

    BOOL HandleSmartCardMessages(UINT message, CERT_ENUM *certEnum);

    INT FindSmartCardInComboBox(CERT_ENUM *certEnum);
    VOID RemoveSmartCardFromComboBox(CERT_ENUM *certEnum, BOOL removeParent);

    VOID Enable(BOOL enable = TRUE);

    VOID OnUserNameSelectionChange();

    BOOL OnSetUserNameA(CHAR *userNameA);
    BOOL OnSetUserName(WCHAR *userName);

    BOOL OnGetUserNameA(CHAR *userNameA, ULONG maxChars);
    BOOL OnGetUserName(WCHAR *userName, ULONG maxChars);

    BOOL OnSetPasswordA(CHAR *passwordA);
    BOOL OnSetPassword(WCHAR *password);

    BOOL OnGetPasswordA(CHAR *passwordA, ULONG maxChars);
    BOOL OnGetPassword(WCHAR *password, ULONG maxChars);

    LONG OnGetUserNameLength();

    BOOL OnShowBalloonA(CREDUI_BALLOONA *balloonA);
    BOOL OnShowBalloon(CREDUI_BALLOON *balloon);

    static LRESULT CALLBACK MessageHandlerCallback(
        HWND window,
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );
    LRESULT
    MessageHandler(
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );

    //
    // Command line specific data
    //

    BOOL DoingCommandLine;
    INT  Heartbeats;
#define CREDUI_HEARTBEAT_TIMER           1
#define CREDUI_HEARTBEAT_TIMER_VALUE    2000
#define CREDUI_MAX_HEARTBEATS           15
#define CREDUI_TIMEOUT_HEARTBEATS       5

    LPWSTR TargetName;
    LPWSTR InitialUserName;

    void CmdlineSmartCardPrompt();
    void CmdlineSavePrompt();

    BOOL GetSmartCardInfo(
        IN DWORD SmartCardIndex,
        IN DWORD BufferLength,
        OUT LPWSTR Buffer,
        OUT BOOL *IsACard,
        OUT BOOL *IsValid,
        OUT CERT_ENUM **CertEnum OPTIONAL
        );

    LPWSTR MatchSmartCard(
        IN DWORD SmartCardCount,
        IN LPWSTR UserName,
        OUT LPDWORD RetCertIndex,
        OUT CERT_ENUM **RetCertEnum
        );

};



//-----------------------------------------------------------------------------

#endif // __CONTROLS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\accctrl2\src\marta.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       MARTA.CXX
//
//  Contents:   Multi-provider support functions
//
//  History:    14-Sep-96       MacM        Created
//
//----------------------------------------------------------------------------
#define _ADVAPI32_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <accctrl.h>
#include <aclapi.h>
#include <marta.h>

//
// Global definitions
//
ACCPROV_PROVIDERS    gAccProviders;

//+---------------------------------------------------------------------------
//
//  Function:   AccProvpLoadDllEntryPoints
//
//  Synopsis:   This function will load all of the entry points for the
//              given provider dll.
//
//  Arguments:  [IN  pProvInfo]     --  Info on the provider
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
AccProvpLoadDllEntryPoints(PACCPROV_PROV_INFO   pProvInfo)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, GrantAccess
    //
    LOAD_ENTRYPT(pProvInfo->pfGrantAccess,
                 pfAccProvAddRights,
                 pProvInfo->hDll,
                 ACC_PROV_GRANT_ACCESS);

    //
    // Now, SetAccess
    //
    LOAD_ENTRYPT(pProvInfo->pfSetAccess,
                 pfAccProvSetRights,
                 pProvInfo->hDll,
                 ACC_PROV_SET_ACCESS);

    //
    // Then revoke
    //
    LOAD_ENTRYPT(pProvInfo->pfRevokeAccess,
                 pfAccProvRevoke,
                 pProvInfo->hDll,
                 ACC_PROV_REVOKE_ACCESS);

    LOAD_ENTRYPT(pProvInfo->pfRevokeAudit,
                 pfAccProvRevoke,
                 pProvInfo->hDll,
                 ACC_PROV_REVOKE_AUDIT);

    //
    // Next is GetRights
    //
    LOAD_ENTRYPT(pProvInfo->pfGetRights,
                 pfAccProvGetRights,
                 pProvInfo->hDll,
                 ACC_PROV_GET_ALL);

    //
    //  Is object accessible?
    //
    LOAD_ENTRYPT(pProvInfo->pfObjAccess,
                 pfAccProvObjAccess,
                 pProvInfo->hDll,
                 ACC_PROV_OBJ_ACCESS);

    LOAD_ENTRYPT(pProvInfo->pfhObjAccess,
                 pfAccProvHandleObjAccess,
                 pProvInfo->hDll,
                 ACC_PROV_HOBJ_ACCESS);

    //
    // Is access allowed?
    //
    LOAD_ENTRYPT(pProvInfo->pfTrusteeAccess,
                 pfAccProvTrusteeAccess,
                 pProvInfo->hDll,
                 ACC_PROV_ACCESS);

    //
    // Is access audited?
    //
    LOAD_ENTRYPT(pProvInfo->pfAudit,
                 pfAccProvAccessAudit,
                 pProvInfo->hDll,
                 ACC_PROV_AUDIT);

    //
    // Object Info
    //
    LOAD_ENTRYPT(pProvInfo->pfObjInfo,
                 pfAccProvGetObjTypeInfo,
                 pProvInfo->hDll,
                 ACC_PROV_OBJ_INFO);

    //
    // Cancel
    //
    LOAD_ENTRYPT(pProvInfo->pfCancel,
                 pfAccProvCancelOp,
                 pProvInfo->hDll,
                 ACC_PROV_CANCEL);
    //
    // Get the results
    //
    LOAD_ENTRYPT(pProvInfo->pfResults,
                 pfAccProvGetResults,
                 pProvInfo->hDll,
                 ACC_PROV_GET_RESULTS);

    //
    // Load the OPTIONAL handle functions, if they exist
    //
    if((pProvInfo->fProviderCaps & ACTRL_CAP_SUPPORTS_HANDLES) != 0)
    {
        LOAD_ENTRYPT(pProvInfo->pfhGrantAccess,
                     pfAccProvHandleAddRights,
                     pProvInfo->hDll,
                     ACC_PROV_HGRANT_ACCESS);

        LOAD_ENTRYPT(pProvInfo->pfhSetAccess,
                     pfAccProvHandleSetRights,
                     pProvInfo->hDll,
                     ACC_PROV_HSET_ACCESS);

        LOAD_ENTRYPT(pProvInfo->pfhRevokeAccess,
                     pfAccProvHandleRevoke,
                     pProvInfo->hDll,
                     ACC_PROV_HREVOKE_AUDIT);

        LOAD_ENTRYPT(pProvInfo->pfhRevokeAudit,
                     pfAccProvHandleRevoke,
                     pProvInfo->hDll,
                     ACC_PROV_HREVOKE_ACCESS);

        LOAD_ENTRYPT(pProvInfo->pfhGetRights,
                     pfAccProvHandleGetRights,
                     pProvInfo->hDll,
                     ACC_PROV_HGET_ALL);

        LOAD_ENTRYPT(pProvInfo->pfhTrusteeAccess,
                     pfAccProvHandleTrusteeAccess,
                     pProvInfo->hDll,
                     ACC_PROV_HACCESS);

        LOAD_ENTRYPT(pProvInfo->pfhAudit,
                     pfAccProvHandleAccessAudit,
                     pProvInfo->hDll,
                     ACC_PROV_HAUDIT);

        LOAD_ENTRYPT(pProvInfo->pfhObjInfo,
                     pfAccProvHandleGetObjTypeInfo,
                     pProvInfo->hDll,
                     ACC_PROV_HOBJ_INFO);
    }

    SetLastError(ERROR_SUCCESS);

Error:
    dwErr = GetLastError();

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpGetStringFromRegistry
//
//  Synopsis:   This function will read the indicated string from the
//              registry.  A buffer is allocated to hold the destination
//              string.  If the value being read is a REG_EXPAND_SZ type
//              string, it will be expanded before being returned.
//
//  Arguments:  [IN  hkReg]         --  Open registry handle
//              [IN  pwszRegKey]    --  Which key to read
//              [OUT ppwszValue]    --  Where the read string is to be
//                                      returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      Memory is allocated with AccAlloc and should be freed with
//              LocalFree.
//
//----------------------------------------------------------------------------
DWORD
AccProvpGetStringFromRegistry(HKEY      hkReg,
                              PWSTR     pwszRegKey,
                              PWSTR    *ppwszValue)
{
    DWORD   dwErr = ERROR_SUCCESS;

    DWORD   dwType, dwSize = 0;

    //
    // First, get the size of the string
    //
    dwErr = RegQueryValueEx(hkReg,
                            pwszRegKey,
                            NULL,
                            &dwType,
                            NULL,
                            &dwSize);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Allocate the string...
        //
        *ppwszValue = (PWSTR)LocalAlloc(LMEM_FIXED, dwSize);
        if(*ppwszValue == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Call it again and get the actual value...
            //
            dwErr = RegQueryValueEx(hkReg,
                                    pwszRegKey,
                                    NULL,
                                    &dwType,
                                    (PBYTE)*ppwszValue,
                                    &dwSize);

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // If it's a REG_EXPAND_SZ string, we'll want to go ahead
                // and do the expansion on it...
                //
                if(dwType == REG_EXPAND_SZ)
                {
                    DWORD   dwLength  = 0;

                    PWSTR   pwszDest = NULL;
                    dwLength = ExpandEnvironmentStrings(*ppwszValue,
                                                        pwszDest,
                                                        0);
                    if(dwLength == 0)
                    {
                        dwErr = GetLastError();
                    }
                    else
                    {
                        pwszDest = (PWSTR)LocalAlloc(LMEM_FIXED,
                                                    dwLength * sizeof(WCHAR));
                        if(pwszDest == NULL)
                        {
                            dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        else
                        {
                            dwLength = ExpandEnvironmentStrings(*ppwszValue,
                                                                pwszDest,
                                                                dwLength);
                            if(dwLength == 0)
                            {
                                dwErr = GetLastError();
                                LocalFree(pwszDest);
                            }
                            else
                            {
                                LocalFree(*ppwszValue);
                                *ppwszValue = pwszDest;
                            }
                        }
                    }
                }
            }
        }

        if(dwErr != ERROR_SUCCESS)
        {
            //
            // Something failed, so clean up...
            //
            LocalFree(*ppwszValue);
        }

    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   AccProvpAllocateProviderList
//
//  Synopsis:   This function will allocate and initialize the list of
//              provider info structs
//
//  Arguments:  [IN OUT  pProviders]    Provider info struct that has
//                                      provider list to be allocated
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
AccProvpAllocateProviderList(IN OUT  PACCPROV_PROVIDERS  pProviders)
{
    DWORD   dwErr = ERROR_SUCCESS;

    pProviders->pProvList = (PACCPROV_PROV_INFO)
                            LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(ACCPROV_PROV_INFO) *
                                                      pProviders->cProviders);
    if(pProviders->pProvList == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpFreeProvderList
//
//  Synopsis:   This function will cleanup and deallocate a list of providers
//
//  Arguments:  [IN  pProviders]    --  Information on the list of proivders
//
//  Returns:    VOID
//
//----------------------------------------------------------------------------
VOID
AccProvpFreeProviderList(IN  PACCPROV_PROVIDERS  pProviders)
{
    if(pProviders != NULL && pProviders->cProviders != 0 &&
                                               pProviders->pProvList != NULL)
    {
        ULONG iIndex;
        PACCPROV_PROV_INFO pCurrent = pProviders->pProvList;
        for(iIndex = 0; iIndex < pProviders->cProviders; iIndex++)
        {
            if(pCurrent->pwszProviderName != NULL)
            {
                LocalFree(pCurrent->pwszProviderName);
            }

            if(pCurrent->pwszProviderPath != NULL)
            {
                LocalFree(pCurrent->pwszProviderPath);
            }

            if(pCurrent->hDll != NULL)
            {
                FreeLibrary(pCurrent->hDll);
            }

            pCurrent++;
        }

        LocalFree(pProviders->pProvList);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpGetProviderCapabilities
//
//  Synopsis:   Gets the provider capabilities.  This is accomplished by
//              loading the specified DLL, and then calling the
//              appropriate entry point
//
//  Arguments:  IN  [pProvInfo]     --  Information about the provider DLL on
//                                      input.  This information is updated
//                                      during the course of this call
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_MOD_NOT_FOUND --  Something went wrong.  Either the
//                                      given module path was invalid or
//                                      we had no module path at all...
//
//----------------------------------------------------------------------------
DWORD
AccProvpGetProviderCapabilities(IN  PACCPROV_PROV_INFO  pProvInfo)
{
    DWORD   dwErr = ERROR_SUCCESS;


    //
    // We can tell if the capabilities have been read by examining
    // the the state of some of the provider info.  Namely, if the provider
    // path is not null and the module handle is, we know we haven't done
    // a load yet.  If the converse of that is true, than a load has already
    // ben done.  If they are both NULL, then we are in trouble, so we'll
    // simply fail it.
    //
    if(pProvInfo->hDll == NULL)
    {
        if(pProvInfo->pwszProviderPath == NULL)
        {
            dwErr = ERROR_MOD_NOT_FOUND;
        }
        else
        {
            //
            // Ok, we need to load the provider DLL and call the capabilities
            // functions
            //

            pProvInfo->hDll = LoadLibrary(pProvInfo->pwszProviderPath);
            if(pProvInfo->hDll == NULL)
            {
                dwErr = GetLastError();
            }
            else
            {
                pfAccProvGetCaps pfGetCaps;

                //
                // Now, that we have the provider loaded, we can delete the
                // provider path, since we won't need that again...
                //
                LocalFree(pProvInfo->pwszProviderPath);
                pProvInfo->pwszProviderPath = NULL;

                pfGetCaps =
                          (pfAccProvGetCaps)GetProcAddress(pProvInfo->hDll,
                                                           ACC_PROV_GET_CAPS);
                if(pfGetCaps == NULL)
                {
                    dwErr = GetLastError();
                }
                else
                {
                    //
                    // Now, it's a simple matter to get the capabilities
                    //
                    __try
                    {
                        (*pfGetCaps)(ACTRL_CLASS_GENERAL,
                                     &(pProvInfo->fProviderCaps));
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        dwErr = ERROR_BAD_PROVIDER;
                    }

                    //
                    // Don't need to keep the provider path anymore
                    //
                    LocalFree(pProvInfo->pwszProviderPath);
                    pProvInfo->pwszProviderPath = NULL;
                }
            }
        }
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpInitProviders
//
//  Synopsis:   Initializes all of the information regarding the providers.
//              This happens via reading the registry and creating the
//              necessary structures.
//
//  Arguments:  [IN OUT pProviders] --  Structure to fill in with all of the
//                                      provider information.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
AccProvpInitProviders(IN OUT PACCPROV_PROVIDERS  pProviders)
{
    DWORD   dwErr = ERROR_SUCCESS;
    HKEY    hkReg = NULL;

    EnterCriticalSection( &gAccProviders.ProviderLoadLock );

    //
    // If they've already been loaded, just return
    //
    if((pProviders->fOptions & ACC_PROV_PROVIDERS_LOADED) != 0)
    {
        LeaveCriticalSection( &gAccProviders.ProviderLoadLock );
        return(ERROR_SUCCESS);
    }

    //
    // Get the list of supported providers.  We'll do this by reading the
    // provider order
    //
    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE,
                       ACC_PROV_REG_ROOT,
                       &hkReg);
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszOrder = NULL;

        dwErr = AccProvpGetStringFromRegistry(hkReg,
                                              ACC_PROV_REG_ORDER,
                                              &pwszOrder);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Go through and count the number of entries...
            //
            PWSTR   pwszNextProv = pwszOrder;
            ULONG   cItems = 0;

            //
            // Protect against an empty list
            //
            if(wcslen(pwszNextProv) > 0)
            {
                while(pwszNextProv != NULL)
                {
                    cItems++;
                    pwszNextProv = wcschr(pwszNextProv, ',');
                    if(pwszNextProv != NULL)
                    {
                        pwszNextProv++;
                    }
                }
            }

            if(cItems == 0)
            {
                dwErr = ERROR_INVALID_DATA;
            }
            else
            {
                pProviders->cProviders = cItems;

                //
                // Go ahead and do the init and load the providers
                //
                dwErr = AccProvpAllocateProviderList(pProviders);

                if(dwErr == ERROR_SUCCESS)
                {
                    ULONG iIndex = 0;

                    //
                    // Now, start loading each of the providers
                    //
                    pwszNextProv =  pwszOrder;

                    while(pwszNextProv != NULL)
                    {
                        PWSTR pwszSep = wcschr(pwszNextProv, L',');

                        if(pwszSep != NULL)
                        {
                            *pwszSep = L'\0';
                        }

                        dwErr = AccProvpLoadProviderDef(hkReg,
                                                        pwszNextProv,
                                            &(pProviders->pProvList[iIndex]));

                        if(pwszSep != NULL)
                        {
                            *pwszSep = L',';
                            pwszSep++;
                        }

                        //
                        // Move on to the next value
                        //
                        pwszNextProv = pwszSep;
                        if(dwErr == ERROR_SUCCESS)
                        {
                            iIndex++;
                        }
                        else
                        {
                            dwErr = ERROR_SUCCESS;
                        }
                    }

                    //
                    // if we didn't load any providers, it's an error!
                    //
                    if(iIndex == 0)
                    {
                        dwErr = ERROR_BAD_PROVIDER;
                    }

                    //
                    // Finally, if all of that worked, pick up our flags
                    //
                    if(dwErr == ERROR_SUCCESS)
                    {
                        DWORD dwType;
                        DWORD dwUnique;
                        DWORD dwSize = sizeof(ULONG);

                        dwErr = RegQueryValueEx(hkReg,
                                                ACC_PROV_REG_UNIQUE,
                                                NULL,
                                                &dwType,
                                                (PBYTE)&dwUnique,
                                                &dwSize);

                        if(dwErr == ERROR_SUCCESS)
                        {
                            //
                            // Set our capabilities
                            //
                            if(dwUnique == 1)
                            {
                                pProviders->fOptions |= ACC_PROV_REQ_UNIQUE;
                            }
                        }
                        else
                        {
                            //
                            // If it wasn't found, then it's not an error.
                            // We just assume it be false
                            //
                            if(dwErr == ERROR_FILE_NOT_FOUND)
                            {
                                dwErr = ERROR_SUCCESS;
                            }
                        }
                    }
                }

            }
        }
    }

    if(hkReg != NULL)
    {
        RegCloseKey(hkReg);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Load the NT marta functions
        //
        dwErr = AccProvpLoadMartaFunctions();
        if(dwErr == ERROR_SUCCESS)
        {
            pProviders->fOptions |= ACC_PROV_PROVIDERS_LOADED;
        }
    }

    LeaveCriticalSection( &gAccProviders.ProviderLoadLock );

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpLoadProviderDef
//
//  Synopsis:   Loads a provider definition from the registry
//
//  Arguments:  [IN  hkReg]         --  Registry key to the open parent
//              [IN  pwszProvider]  --  Name of the provider to load
//              [OUT pProvInfo]     --  Provider info struct to fill
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed.
//
//----------------------------------------------------------------------------
DWORD
AccProvpLoadProviderDef(IN  HKEY                hkReg,
                        IN  PWSTR               pwszProvider,
                        OUT PACCPROV_PROV_INFO  pProvInfo)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, open the proper key...
    //
    HKEY    hkProv = NULL;
    dwErr = RegOpenKey(hkReg,
                       pwszProvider,
                       &hkProv);

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Ok, we've already got the provider name.  Now just save it off
        //
        pProvInfo->pwszProviderName = (PWSTR)LocalAlloc(LMEM_FIXED,
                                                sizeof(WCHAR) *
                                                  (wcslen(pwszProvider) + 1));
        if(pProvInfo->pwszProviderName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            wcscpy(pProvInfo->pwszProviderName,
                   pwszProvider);
        }

        if(dwErr == ERROR_SUCCESS)
        {

            dwErr = AccProvpGetStringFromRegistry(hkProv,
                                            ACC_PROV_REG_PATH,
                                            &(pProvInfo->pwszProviderPath));

            if(dwErr == ERROR_SUCCESS)
            {
                pProvInfo->fProviderState |=  ACC_PROV_PROV_OK;
            }
            else
            {
                //
                // No need to take up extra memory..
                //
                LocalFree(pProvInfo->pwszProviderName);
                pProvInfo->pwszProviderName = NULL;
                pProvInfo->fProviderState =  ACC_PROV_PROV_FAILED;
            }
        }


        RegCloseKey(hkProv);
    }

    //
    // If that worked, load it's capabilities
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpGetProviderCapabilities(pProvInfo);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpProbeProviderForObject
//
//  Synopsis:   Locates which provider supports an object.  The index of
//              this provider in the global list is returned.  In the
//              case where unique accessiblity is required, all the providers
//              will be tried.
//
//  Arguments:  [IN  pwszObject]    --  Object to look for
//              [IN  hObject]       --  Handle to object.  Either this or
//                                      pwszObject must be valid (but only
//                                      one);
//              [IN  ObjectType]    --  Type of object specified by pwszObject
//              [IN  pProviders]    --  List of providers to search
//              [OUT ppProvider]    --  Where the pointer to the active
//                                      provider is to be returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_AMBIGUOUS_PATH--  The RequireUniqueAccessibilty flag
//                                      was set and the path was reachable
//                                      by more than one provider.
//              ERROR_BAD_PROVIDER  --  No providers installed.
//
//----------------------------------------------------------------------------
DWORD
AccProvpProbeProviderForObject(IN   PWSTR               pwszObject,
                               IN   HANDLE              hObject,
                               IN   SE_OBJECT_TYPE      ObjectType,
                               IN   PACCPROV_PROVIDERS  pProviders,
                               OUT  PACCPROV_PROV_INFO *ppProvider)
{
    DWORD   dwErr = ERROR_BAD_PROVIDER;

    //
    // Walk through the entire list..
    //
    ULONG iIndex;
    ULONG iActive = 0xFFFFFFFF;
    PACCPROV_PROV_INFO  pCurrent = pProviders->pProvList;
    for(iIndex = 0; iIndex < pProviders->cProviders; iIndex++)
    {
        if(pCurrent->pfObjAccess == NULL || pCurrent->pfhObjAccess == NULL)
        {
            dwErr = AccProvpLoadDllEntryPoints(pCurrent);
            if(dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }

        //
        // Now, go ahead and do the call
        //
        __try
        {
            if(pwszObject != NULL)
            {
                dwErr = (*(pCurrent->pfObjAccess))(pwszObject,
                                                   ObjectType);
            }
            else
            {
                dwErr = (*(pCurrent->pfhObjAccess))(hObject,
                                                    ObjectType);
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            dwErr = GetExceptionCode();
        }


        if(dwErr == ERROR_SUCCESS)
        {
            //
            // See what's going on... If we don't require unique access,
            // simply accept this current one.  If we do require unique access
            // and this is the first provider, save it.  Otherwise, this is
            // not the provider, so return an error...
            //
            if((pProviders->fOptions & ACC_PROV_REQ_UNIQUE) != 0)
            {
                //
                // Ok, requiring unique...
                //
                if(iActive == 0xFFFFFFFF)
                {
                    iActive = iIndex;
                }
                else
                {
                    //
                    // Got a conflict
                    //

                    dwErr = ERROR_PATH_NOT_FOUND;
                    break;
                }
            }
            else
            {
                iActive = iIndex;
                break;
            }
        }
        else if (dwErr ==  ERROR_PATH_NOT_FOUND)
        {
            dwErr = ERROR_SUCCESS;
        }

        pCurrent++;
    }

    //
    // If we got a match, return it...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        if(iActive != 0xFFFFFFFF)
        {
            *ppProvider = &(pProviders->pProvList[iActive]);
        }
        else
        {
            //
            // Nobody recognized the object path...
            //
            dwErr = ERROR_PATH_NOT_FOUND;
        }
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpGetProviderForPath
//
//  Synopsis:   Gets the current provider for the path.  If a provider name
//              is passed it, it is compared against the loaded list.
//              Otherwise, and attempt is made to locate it.  Once located,
//              the function table is loaded, if not already done..
//
//  Arguments:  [IN  pwszObject]    --  Object to look for
//              [IN  ObjectType]    --  Type of object specified by pwszObject
//              [IN  pwszProvider]  --  If known, the provider to handle the
//                                      request.
//              [IN  pProviders]    --  List of providers to search
//              [OUT ppProvider]    --  Where the pointer to the active
//                                      provider is to be returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_AMBIGUOUS_PATH--  The RequireUniqueAccessibilty flag
//                                      was set and the path was reachable
//                                      by more than one provider.
//
//----------------------------------------------------------------------------
DWORD
AccProvpGetProviderForPath(IN  PCWSTR              pcwszObject,
                           IN  SE_OBJECT_TYPE      ObjectType,
                           IN  PCWSTR              pcwszProvider,
                           IN  PACCPROV_PROVIDERS  pProviders,
                           OUT PACCPROV_PROV_INFO *ppProvider)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first see if we have a provider given or if we need to locate it..
    //
    if(pcwszProvider == NULL)
    {
        //
        // No provider... Go find one
        //
        dwErr = AccProvpProbeProviderForObject((PWSTR)pcwszObject,
                                               NULL,
                                               ObjectType,
                                               pProviders,
                                               ppProvider);
    }
    else
    {
        ULONG iIndex;

        //
        // See if we can find it...
        //
        dwErr = ERROR_BAD_PROVIDER;
        for(iIndex = 0; iIndex < pProviders->cProviders; iIndex++)
        {
            if(_wcsicmp((PWSTR)pcwszProvider,
                        pProviders->pProvList[iIndex].pwszProviderName) == 0)
            {
                //
                // Found a match
                //
                *ppProvider = &(pProviders->pProvList[iIndex]);
                dwErr = ERROR_SUCCESS;
                break;
            }
        }
    }

    //
    // Now, see if we need to load the appropriate function tables
    //
    if(dwErr == ERROR_SUCCESS && (*ppProvider)->pfGrantAccess == NULL)
    {
        dwErr = AccProvpLoadDllEntryPoints(*ppProvider);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpGetProviderForHandle
//
//  Synopsis:   Gets the current provider for the path.  If a provider name
//              is passed it, it is compared against the loaded list.
//              Otherwise, and attempt is made to locate it.  Once located,
//              the function table is loaded, if not already done..
//
//  Arguments:  [IN  hObject]       --  Object to look for
//              [IN  ObjectType]    --  Type of object specified by pwszObject
//              [IN  pwszProvider]  --  If known, the provider to handle the
//                                      request.
//              [IN  pProviders]    --  List of providers to search
//              [OUT ppProvider]    --  Where the pointer to the active
//                                      provider is to be returned.
//
//  Returns:    ERROR_SUCCESS       --  Success
//              ERROR_AMBIGUOUS_PATH--  The RequireUniqueAccessibilty flag
//                                      was set and the path was reachable
//                                      by more than one provider.
//
//----------------------------------------------------------------------------
DWORD
AccProvpGetProviderForHandle(IN  HANDLE              hObject,
                             IN  SE_OBJECT_TYPE      ObjectType,
                             IN  PCWSTR              pcwszProvider,
                             IN  PACCPROV_PROVIDERS  pProviders,
                             OUT PACCPROV_PROV_INFO *ppProvider)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first see if we have a provider given or if we need to locate it..
    //
    if(pcwszProvider == NULL)
    {
        //
        // No provider... Go find one
        //
        dwErr = AccProvpProbeProviderForObject(NULL,
                                               hObject,
                                               ObjectType,
                                               pProviders,
                                               ppProvider);
    }
    else
    {
        ULONG iIndex;

        //
        // See if we can find it...
        //
        dwErr = ERROR_BAD_PROVIDER;
        for(iIndex = 0; iIndex < pProviders->cProviders; iIndex++)
        {
            if(_wcsicmp((PWSTR)pcwszProvider,
                        pProviders->pProvList[iIndex].pwszProviderName) == 0)
            {
                //
                // Found a match
                //
                *ppProvider = &(pProviders->pProvList[iIndex]);
                break;
            }
        }
    }

    //
    // Make sure that we support the handle based APIs for this provider
    //
    if(dwErr == ERROR_SUCCESS &&
       ((*ppProvider)->fProviderCaps & ACTRL_CAP_SUPPORTS_HANDLES) == 0)
    {
        dwErr = ERROR_CALL_NOT_IMPLEMENTED;
    }


    //
    // Now, see if we need to load the appropriate function tables
    //
    if(dwErr == ERROR_SUCCESS && (*ppProvider)->pfGrantAccess == NULL)
    {
        dwErr = AccProvpLoadDllEntryPoints(*ppProvider);
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\controls.cpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// controls.cpp
//
// User interface control classes.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#include "precomp.hpp"
#include "controls.hpp"
#include "resource.h"
#include "utils.hpp"
#include <shlguid.h>
#include <htmlhelp.h>

//-----------------------------------------------------------------------------
// Values
//-----------------------------------------------------------------------------

// These are the positions of the children controls of the credential control,
// in DLUs:

// make more space to localize the edit control tags.
#define SIZEFIX 20

#define CREDUI_CONTROL_USERNAME_STATIC_X          0
#define CREDUI_CONTROL_USERNAME_STATIC_Y          2
#define CREDUI_CONTROL_USERNAME_STATIC_WIDTH      (48 + SIZEFIX)
#define CREDUI_CONTROL_USERNAME_STATIC_HEIGHT     8

#define CREDUI_CONTROL_USERNAME_X                (50 + SIZEFIX)
#define CREDUI_CONTROL_USERNAME_Y                 0
#define CREDUI_CONTROL_USERNAME_WIDTH           (121 - SIZEFIX)
#define CREDUI_CONTROL_USERNAME_HEIGHT           96

#define CREDUI_CONTROL_VIEW_X                   175
#define CREDUI_CONTROL_VIEW_Y                     0
#define CREDUI_CONTROL_VIEW_WIDTH                13
#define CREDUI_CONTROL_VIEW_HEIGHT               13

#define CREDUI_CONTROL_PASSWORD_STATIC_X          0
#define CREDUI_CONTROL_PASSWORD_STATIC_Y         19
#define CREDUI_CONTROL_PASSWORD_STATIC_WIDTH      (48 + SIZEFIX)
#define CREDUI_CONTROL_PASSWORD_STATIC_HEIGHT     8

#define CREDUI_CONTROL_PASSWORD_X                (50 + SIZEFIX)
#define CREDUI_CONTROL_PASSWORD_Y                17
#define CREDUI_CONTROL_PASSWORD_WIDTH           (121 - SIZEFIX)
#define CREDUI_CONTROL_PASSWORD_HEIGHT           12

#define CREDUI_CONTROL_SAVE_X                    (50 + SIZEFIX)
#define CREDUI_CONTROL_SAVE_Y                    36
#define CREDUI_CONTROL_SAVE_WIDTH               138
#define CREDUI_CONTROL_SAVE_HEIGHT               10

// Use a common maximum string length for certificate display names:

#define CREDUI_MAX_CERT_NAME_LENGTH 256
#define CREDUI_MAX_CMDLINE_MSG_LENGTH   256


//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

CLSID CreduiStringArrayClassId = // 82BD0E67-9FEA-4748-8672-D5EFE5B779B0
{
    0x82BD0E67,
    0x9FEA,
    0x4748,
    {0x86, 0x72, 0xD5, 0xEF, 0xE5, 0xB7, 0x79, 0xB0}
};

// Balloon tip infos for PasswordBox control:
CONST CREDUI_BALLOON_TIP_INFO CreduiCapsLockTipInfo =
{
    CreduiStrings.CapsLockTipTitle,
    CreduiStrings.CapsLockTipText,
    TTI_WARNING, 90, 76
};
// Balloon tip infos for Credential control:

CONST CREDUI_BALLOON_TIP_INFO CreduiBackwardsTipInfo =
{
    CreduiStrings.BackwardsTipTitle,
    CreduiStrings.BackwardsTipText,
    TTI_ERROR, 90, 76
};

WCHAR CreduiCustomTipTitle[CREDUI_MAX_BALLOON_TITLE_LENGTH + 1];
WCHAR CreduiCustomTipMessage[CREDUI_MAX_BALLOON_MESSAGE_LENGTH + 1];

CREDUI_BALLOON_TIP_INFO CreduiCustomTipInfo =
{
    CreduiCustomTipTitle,
    CreduiCustomTipMessage,
    TTI_INFO, 90, 76
};

//-----------------------------------------------------------------------------
// CreduiBalloonTip Class Implementation
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiBalloonTip::CreduiBalloonTip
//
// Created 02/24/2000 johnstep (John Stephens)
//=============================================================================

CreduiBalloonTip::CreduiBalloonTip()
{
    Window = NULL;

    ParentWindow = NULL;
    ControlWindow = NULL;

    TipInfo = NULL;

    Visible = FALSE;
}

//=============================================================================
// CreduiBalloonTip::~CreduiBalloonTip
//
// Created 02/24/2000 johnstep (John Stephens)
//=============================================================================

CreduiBalloonTip::~CreduiBalloonTip()
{
    if (Window != NULL)
    {
        DestroyWindow(Window);
        Window = NULL;
    }
}

//=============================================================================
// CreduiBalloonTip::Init
//
// Creates and initializes the balloon window.
//
// Arguments:
//   instance (in) - this module
//   parentWindow (in) - the parent of the tool tip window
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/24/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiBalloonTip::Init(
    HINSTANCE instance,
    HWND parentWindow
    )
{
    if (Window != NULL)
    {
        DestroyWindow(Window);

        Window = NULL;

        ParentWindow = NULL;
        ControlWindow = NULL;

        TipInfo = NULL;

        Visible = FALSE;
    }

    Window = CreateWindowEx(NULL, TOOLTIPS_CLASS, NULL,
                            WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
                            CW_USEDEFAULT, CW_USEDEFAULT,
                            CW_USEDEFAULT, CW_USEDEFAULT,
                            parentWindow, NULL, instance, NULL);

    // Only assign class member values once we have successfully created the
    // window:

    if (Window != NULL)
    {
        ParentWindow = parentWindow;
        TipInfo = NULL;
        return TRUE;
    }

    return FALSE;
}

//=============================================================================
// CreduiBalloonTip::SetInfo
//
// Sets the tool tip information and adds or updates the tool.
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 03/02/2000 johnstep (John Stephens)
//=============================================================================

BOOL CreduiBalloonTip::SetInfo(
    HWND controlWindow,
    CONST CREDUI_BALLOON_TIP_INFO *tipInfo
    )
{
    //if ((controlWindow != ControlWindow) || (tipInfo != TipInfo))
    {
        TOOLINFO info;

        ZeroMemory(&info, sizeof info);

        info.cbSize = sizeof info;
        info.hwnd = ParentWindow;
        info.uId = reinterpret_cast<WPARAM>(ParentWindow);

        // If the tool already exists, hide it, then update the information.
        // Otherwise, add the tool now:

        if (SendMessage(Window, TTM_GETTOOLINFO, 0,
                reinterpret_cast<LPARAM>(&info)))
        {
            if (Visible)
            {
                Hide();
            }

            ZeroMemory(&info, sizeof info);

            info.cbSize = sizeof info;
            info.hwnd = ParentWindow;
            info.uId = reinterpret_cast<WPARAM>(ParentWindow);

            info.uFlags = TTF_IDISHWND | TTF_TRACK;
            info.hinst = NULL;
            info.lpszText = const_cast<WCHAR *>(tipInfo->Text);
            info.lParam = 0;

            SendMessage(Window, TTM_SETTOOLINFO, 0,
                reinterpret_cast<LPARAM>(&info));
        }
        else
        {
            info.uFlags = TTF_IDISHWND | TTF_TRACK;
            info.hinst = NULL;
            info.lpszText = const_cast<WCHAR *>(tipInfo->Text);
            info.lParam = 0;

            if (!SendMessage(Window, TTM_ADDTOOL, 0,
                reinterpret_cast<LPARAM>(&info)))
            {
                return FALSE;
            }
        }

        SendMessage(Window, TTM_SETTITLE, tipInfo->Icon,
                    reinterpret_cast<LPARAM>(tipInfo->Title));

        TipInfo = const_cast<CREDUI_BALLOON_TIP_INFO *>(tipInfo);
        ControlWindow = controlWindow;
    }

    return TRUE;
}

//=============================================================================
// CreduiBalloonTip::Show
//
// Updates the position of the balloon window, and then displays it.
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/24/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiBalloonTip::Show()
{
    if (!Visible && IsWindowEnabled(ControlWindow))
    {
        SetFocus(ControlWindow);

        RECT rect;
        GetWindowRect(ControlWindow, &rect);

        SendMessage(Window,
                    TTM_TRACKPOSITION, 0,
                    MAKELONG(
                        rect.left + TipInfo->XPercent *
                            (rect.right - rect.left) / 100,
                        rect.top + TipInfo->YPercent *
                            (rect.bottom - rect.top) / 100));

        TOOLINFO info;

        ZeroMemory(&info, sizeof info);

        info.cbSize = sizeof info;
        info.hwnd = ParentWindow;
        info.uId = reinterpret_cast<WPARAM>(ParentWindow);

        SendMessage(Window, TTM_TRACKACTIVATE, TRUE,
            reinterpret_cast<LPARAM>(&info));

        Visible = TRUE;
    }

    return TRUE;
}

//=============================================================================
// CreduiBalloonTip::Hide
//
// Hides the balloon window.
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/24/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiBalloonTip::Hide()
{
    if (Visible)
    {
        SendMessage(Window, TTM_TRACKACTIVATE, (WPARAM) FALSE, 0);

        Visible = FALSE;

        if (ParentWindow)
        {
            HWND hD = GetParent(ParentWindow);
            if (hD) 
            {
                InvalidateRgn(hD,NULL,FALSE);
                UpdateWindow(hD);
            }
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
// CreduiPasswordBox Class Implementation
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiPasswordBox::CreduiPasswordBox
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

CreduiPasswordBox::CreduiPasswordBox()
{
    OriginalMessageHandler = NULL;

    Window = NULL;
    PasswordFont = NULL;
    BalloonTip = NULL;
    CapsLockTipInfo = NULL;
}

//=============================================================================
// CreduiPasswordBox::~CreduiPasswordBox
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

CreduiPasswordBox::~CreduiPasswordBox()
{
    if (PasswordFont != NULL)
    {
        DeleteObject(static_cast<HGDIOBJ>(PasswordFont));
        PasswordFont = NULL;
    }
}

//=============================================================================
// CreduiPasswordBox::Init
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiPasswordBox::Init(
    HWND window,
    CreduiBalloonTip *balloonTip,
    CONST CREDUI_BALLOON_TIP_INFO *capsLockTipInfo,
    HFONT passwordFont,
    WCHAR passwordChar)
{
    // If passwordFont was passed, use it here, but leave the class
    // PasswordFont NULL so it will not be cleaned up by the destructor. If
    // it was not passed, create a font here, which will be freed by the
    // destructor:

    if (passwordFont == NULL)
    {
        passwordFont = PasswordFont;
    }

    Window = window;

    // If we still failed to create the font, and are not planning to display
    // balloon tips, then there's nothing do to, just return.

    if ((passwordFont == NULL) && (balloonTip == NULL))
    {
        return FALSE;
    }

    if (balloonTip != NULL)
    {
        if (capsLockTipInfo == NULL)
        {
            return FALSE;
        }

        BalloonTip = balloonTip;
        CapsLockTipInfo = capsLockTipInfo;

        OriginalMessageHandler =
            reinterpret_cast<WNDPROC>(
                GetWindowLongPtr(Window, GWLP_WNDPROC));

        if (OriginalMessageHandler != NULL)
        {
            SetLastError(ERROR_SUCCESS);

            if ((SetWindowLongPtr(
                    Window,
                    GWLP_USERDATA,
                    reinterpret_cast<LONG_PTR>(this)) == 0) &&
                (GetLastError() != ERROR_SUCCESS))
            {
                return FALSE;
            }

            SetLastError(ERROR_SUCCESS);

            if (SetWindowLongPtr(
                    Window,
                    GWLP_WNDPROC,
                    reinterpret_cast<LONG_PTR>(MessageHandlerCallback)) &&
                (GetLastError() != ERROR_SUCCESS))
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }

    if (passwordFont != NULL)
    {
        SendMessage(Window,
                    WM_SETFONT,
                    reinterpret_cast<WPARAM>(passwordFont),
                    0);
        SendMessage(Window, EM_SETPASSWORDCHAR, passwordChar, 0);

    }


    return TRUE;
}


//=============================================================================
// CreduiPasswordBox::MessageHandler
//
// This callback function just calls through to the original, except in a
// special case where Caps Lock is pressed. We then check to see if the tip is
// currently being displayed, and if the new state of Caps Lock is off, hide
// the tip.
//
// Arguments:
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Returns the result of calling the original message handler in every case.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

LRESULT
CreduiPasswordBox::MessageHandler(
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message)
    {
    case WM_KEYDOWN:
        if (wParam == VK_CAPITAL)
        {
        }
        else
        {
            if (BalloonTip->IsVisible())
            {
                BalloonTip->Hide();
            }
        }

        break;

    case WM_SETFOCUS:
        // Make sure no one can steal the focus while a user is
        // entering their password:

        LockSetForegroundWindow(LSFW_LOCK);

        // If the Caps Lock key is down, notify the user, unless the
        // password tip is already visible:

        if (!BalloonTip->IsVisible() && CreduiIsCapsLockOn())
        {
//            BalloonTip->SetInfo(Window, CapsLockTipInfo);
//            BalloonTip->Show();
        }

        break;

    case WM_PASTE:
        if (BalloonTip->IsVisible())
        {
            BalloonTip->Hide();
        }
        break;

    case WM_KILLFOCUS:
        if (BalloonTip->IsVisible())
        {
            BalloonTip->Hide();
        }

        // Make sure other processes can set foreground window
        // once again:

        LockSetForegroundWindow(LSFW_UNLOCK);

        break;
    }

    return CallWindowProc(OriginalMessageHandler,
                          Window,
                          message,
                          wParam,
                          lParam);
}

//=============================================================================
// CreduiPasswordBox::MessageHandlerCallback
//
// This calls through to CreduiPasswordBox::MessageHandler, from the this
// pointer.
//
// Arguments:
//   passwordWindow (in)
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Returns the result of calling the original message handler in every case.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

LRESULT
CALLBACK
CreduiPasswordBox::MessageHandlerCallback(
    HWND passwordWindow,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CreduiPasswordBox *that =
        reinterpret_cast<CreduiPasswordBox *>(
            GetWindowLongPtr(passwordWindow, GWLP_USERDATA));

    ASSERT(that != NULL);
    ASSERT(that->BalloonTip != NULL);
    ASSERT(that->CapsLockTipInfo != NULL);

    ASSERT(that->Window == passwordWindow);

    return that->MessageHandler(message, wParam, lParam);
}

//-----------------------------------------------------------------------------
// CreduiStringArrayFactory Class Implementation
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiStringArrayFactory::CreduiStringArrayFactory
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

CreduiStringArrayFactory::CreduiStringArrayFactory()
{
    ReferenceCount = 1;
}

//=============================================================================
// CreduiStringArrayFactory::~CreduiStringArrayFactory
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

CreduiStringArrayFactory::~CreduiStringArrayFactory()
{
}

//=============================================================================
// CreduiStringArrayFactory::QueryInterface (IUnknown)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArrayFactory::QueryInterface(
    CONST IID &interfaceId,
    VOID **outInterface
    )
{
    if ((interfaceId == IID_IUnknown) || (interfaceId == IID_IClassFactory))
    {
        *outInterface = static_cast<void *>(static_cast<IClassFactory *>(this));
    }
    else
    {
        *outInterface = NULL;
        return E_NOINTERFACE;
    }

    static_cast<IUnknown *>(*outInterface)->AddRef();
    return S_OK;
}

//=============================================================================
// CreduiStringArrayFactory::Addref (IUnknown)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

ULONG
CreduiStringArrayFactory::AddRef()
{
    return InterlockedIncrement(reinterpret_cast<LONG *>(&ReferenceCount));
}

//=============================================================================
// CreduiStringArrayFactory::Release (IUnknown)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

ULONG
CreduiStringArrayFactory::Release()
{
    if (InterlockedDecrement(reinterpret_cast<LONG *>(&ReferenceCount)) > 0)
    {
        return ReferenceCount;
    }

    delete this;

    return 0;
}

//=============================================================================
// CreduiClassFactory::CreateInstance (IClassFactory)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArrayFactory::CreateInstance(
    IUnknown *unknownOuter,
    CONST IID &interfaceId,
    VOID **outInterface
    )
{
    if (unknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    CreduiStringArray *stringArray = new CreduiStringArray;

    if (stringArray == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT result = stringArray->QueryInterface(interfaceId, outInterface);

    // Release the string array object in any case, because of the
    // QueryInterface succeeded, it already took another reference count on
    // the object:

    stringArray->Release();

    return result;
}

//=============================================================================
// CreduiClassFactory::LockServer (IClassFactory)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArrayFactory::LockServer(
    BOOL lock
    )
{
    if (lock)
    {
        InterlockedIncrement(reinterpret_cast<LONG *>(
            &CreduiComReferenceCount));
    }
    else
    {
        InterlockedDecrement(reinterpret_cast<LONG *>(
            &CreduiComReferenceCount));
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// CreduiStringArray Class Implementation
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiStringArray::CreduiStringArray
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiStringArray::CreduiStringArray()
{
    ReferenceCount = 1;
    Index = 0;
    Count = 0;
    MaxCount = 0;
    Array = NULL;

    InterlockedIncrement(reinterpret_cast<LONG *>(&CreduiComReferenceCount));
}

//=============================================================================
// CreduiStringArray::~CreduiStringArray
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiStringArray::~CreduiStringArray()
{
    if (Array != NULL)
    {
        while (Count > 0)
        {
            delete [] Array[--Count];
        }

        delete [] Array;
        MaxCount = 0;
        Count = 0;
    }

    InterlockedDecrement(reinterpret_cast<LONG *>(&CreduiComReferenceCount));
}

//=============================================================================
// CreduiStringArray::Init
//
// Initializes the string array.
//
// Arguments:
//   count (in) - number of strings in the array
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiStringArray::Init(
    UINT count
    )
{
    Count = 0;
    MaxCount = count;

    Array = new WCHAR *[count];

    if (Array != NULL)
    {
        return TRUE;
    }

    // Clean up:

    MaxCount = 0;

    return FALSE;
}

//=============================================================================
// CreduiStringArray::Find
//
// Searches for a string in the array.
//
// Arguments:
//   string (in) - string to search for
//
// Returns TRUE if the string was found or FALSE otherwise.
//
// Created 02/27/2000 johnstep (John Stephens)
//=============================================================================

BOOL CreduiStringArray::Find(
    CONST WCHAR *string
    )
{
    // Search for the string:

    for (UINT i = 0; i < Count; ++i)
    {
        ASSERT(Array[i] != NULL);

        if (_wcsicmp(Array[i], string) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//=============================================================================
// CreduiStringArray::Add
//
// Adds a string to the array.
//
// Arguments:
//   string (in) - string to add
//
// Returns TRUE if the string was added or FALSE otherwise.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiStringArray::Add(
    CONST WCHAR *string
    )
{
    // The array does not grow, so once we reach the limit, no more:
    // Count is a object state variable pointing to the next free slot.
    if (Count < MaxCount)
    {
        int bufferLength = wcslen(string) + 1;
        Array[Count] = new WCHAR[bufferLength];

        if (Array[Count] != NULL)
        {
            StringCchCopyW(Array[Count++], bufferLength, string);
            return TRUE;
        }
    }

    return FALSE;
}

//=============================================================================
// CreduiStringArray::QueryInterface (IUnknown)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArray::QueryInterface(
    CONST IID &interfaceId,
    VOID **outInterface
    )
{
    if ((interfaceId == IID_IUnknown) || (interfaceId == IID_IEnumString))
    {
        *outInterface = static_cast<void *>(static_cast<IEnumString *>(this));
    }
    else
    {
        *outInterface = NULL;
        return E_NOINTERFACE;
    }

    static_cast<IUnknown *>(*outInterface)->AddRef();
    return S_OK;
}

//=============================================================================
// CreduiStringArray::Addref (IUnknown)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

ULONG
CreduiStringArray::AddRef()
{
    return InterlockedIncrement(reinterpret_cast<LONG *>(&ReferenceCount));
}

//=============================================================================
// CreduiStringArray::Release (IUnknown)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

ULONG
CreduiStringArray::Release()
{
    if (InterlockedDecrement(reinterpret_cast<LONG *>(&ReferenceCount)) > 0)
    {
        return ReferenceCount;
    }

    delete this;

    return 0;
}

//=============================================================================
// CreduiStringArray::Next (IEnumString)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArray::Next(
    ULONG count,
    LPOLESTR *array,
    ULONG *countFetched
    )
{
    if ((count > 1) && (countFetched == NULL))
    {
        return E_INVALIDARG;
    }

    count = min(count, Count - Index);

    for (UINT i = 0; i < count; ++i)
    {
        int bufferLength = wcslen(Array[Index]) + 1;
        array[i] = static_cast<WCHAR *>(CoTaskMemAlloc(
            (sizeof (WCHAR)) * bufferLength));

        if (array[i] != NULL)
        {
            StringCchCopyW(array[i], bufferLength, Array[Index]);
        }
        else
        {
            while (i > 0)
            {
                CoTaskMemFree(array[--i]);
                array[i] = NULL;
            }

            if (countFetched != NULL)
            {
                *countFetched = 0;
            }

            return E_OUTOFMEMORY;
        }

        Index++;
    }

    if (countFetched != NULL)
    {
        *countFetched = count;
    }

    return (count > 0) ? S_OK : S_FALSE;
}

//=============================================================================
// CreduiStringArray::Skip (IEnumString)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArray::Skip(
    ULONG
    )
{
    return E_NOTIMPL;
}

//=============================================================================
// CreduiStringArray::Reset (IEnumString)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArray::Reset()
{
    Index = 0;

    return S_OK;
}

//=============================================================================
// CreduiStringArray::Clone (IEnumString)
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

HRESULT
CreduiStringArray::Clone(
    IEnumString **
    )
{
    return E_NOTIMPL;
}

//-----------------------------------------------------------------------------
// CreduiAutoCompleteComboBox Class Implementation
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiAutoCompleteComboBox::CreduiAutoCompleteComboBox
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiAutoCompleteComboBox::CreduiAutoCompleteComboBox()
{
    Window = NULL;
    ImageList = NULL;
    StringArray = NULL;
}

//=============================================================================
// CreduiAutoCompleteComboBox::~CreduiAutoCompleteComboBox
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiAutoCompleteComboBox::~CreduiAutoCompleteComboBox()
{
    if (StringArray != NULL)
    {
        StringArray->Release();
        StringArray = NULL;
    }

    if (ImageList != NULL)
    {
        ImageList_Destroy(ImageList);
        ImageList = NULL;
    }
}

//=============================================================================
// CreduiAutoCompleteComboBox::Init
//
// Initializes the shell auto complete list control for the given combo box,
// and sets the auto complete string list.
//
// Arguments:
//   instance (in)
//   comboBoxWindow (in)
//   stringCount (in)
//   imageListResourceId (in) - optional image list for the combo box
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiAutoCompleteComboBox::Init(
    HMODULE instance,
    HWND comboBoxWindow,
    UINT stringCount,
    INT imageListResourceId,
    INT initialImage
    )
{
    Window = comboBoxWindow;

    if (imageListResourceId != 0)
    {
        ImageList = ImageList_LoadImage(
            instance,
            MAKEINTRESOURCE(imageListResourceId),
            0, 16, RGB(0, 128, 128), IMAGE_BITMAP,
            LR_DEFAULTSIZE | LR_SHARED);

        if (ImageList != NULL)
        {
            SendMessage(Window,
                        CBEM_SETIMAGELIST,
                        0, reinterpret_cast<LPARAM>(ImageList));
        }
        else
        {
            return FALSE;
        }
    }

    BOOL success = FALSE;

    if (stringCount > 0)
    {
        HRESULT result =
            CoCreateInstance(CreduiStringArrayClassId,
                             NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IEnumString,
                             reinterpret_cast<VOID **>(&StringArray));

        if (SUCCEEDED(result))
        {
            if (StringArray->Init(stringCount))
            {
                success = TRUE;
            }
            else
            {
                StringArray->Release();
                StringArray = NULL;
            }
        }
    }
    else
    {
        success = TRUE;
    }

    if (success == TRUE)
    {
        COMBOBOXEXITEMW item;

        item.mask = CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
        item.iItem = -1;
        item.iImage = initialImage;
        item.iSelectedImage = initialImage;

        SendMessage(Window, CBEM_SETITEM, 0,
                    reinterpret_cast<LPARAM>(&item));

        return TRUE;
    }

    if (ImageList != NULL)
    {
        ImageList_Destroy(ImageList);
        ImageList = NULL;
    }

    return FALSE;
}

//=============================================================================
// CreduiAutoCompleteComboBox::Add
//
// Returns the index of the new item or -1 on failure.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

INT
CreduiAutoCompleteComboBox::Add(
    WCHAR *string,
    INT image,
    BOOL autoComplete,
    BOOL addUnique,
    INT indexBefore,
    INT indent
    )
{
    INT index = -1;

    if (addUnique)
    {
        index = (INT) SendMessage(Window, CB_FINDSTRINGEXACT, 0,
                                  reinterpret_cast<LPARAM>(string));
    }

    if (index == -1)
    {
        if (!autoComplete || StringArray->Add(string))
        {
            COMBOBOXEXITEMW item;

            item.mask = CBEIF_TEXT | CBEIF_INDENT;
            item.iItem = indexBefore;
            item.pszText = string;
            item.iIndent = indent;

            if (ImageList != NULL)
            {
                item.mask |= CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
                item.iImage = image;
                item.iSelectedImage = image;
            }

            index = (INT) SendMessage(Window, CBEM_INSERTITEM, 0,
                                      reinterpret_cast<LPARAM>(&item));
        }
    }

    return index;
}

//=============================================================================
// CreduiAutoCompleteComboBox::Update
//
// Updates an existing item. This does not update the associated string for
// auto complete items.
//
// Created 04/15/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiAutoCompleteComboBox::Update(
    INT index,
    WCHAR *string,
    INT image
    )
{
    COMBOBOXEXITEMW item;

    item.iItem = index;

    // Use CBEM_SETITEM in these cases:
    //
    // 1. We're updating the default (-1) item.
    // 2. The dropdown is closed.
    //
    // For other cases, we delete and recreate the item for the desired
    // result.

    BOOL isDropped = (BOOL) SendMessage(Window, CB_GETDROPPEDSTATE, 0, 0);

    if ((index == -1) || !isDropped)
    {
        item.mask = CBEIF_TEXT;
        item.pszText = string;

        if (ImageList != NULL)
        {
            item.mask |= CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
            item.iImage = image;
            item.iSelectedImage = image;
        }

        if (SendMessage(Window, CBEM_SETITEM, 0,
                        reinterpret_cast<LPARAM>(&item)) != 0)
        {
            RECT rect;

            GetClientRect(Window, &rect);
            InvalidateRect(Window, &rect, FALSE);

            return TRUE;
        }
    }
    else
    {
        item.mask = CBEIF_IMAGE | CBEIF_INDENT | CBEIF_SELECTEDIMAGE;

        if (SendMessage(Window, CBEM_GETITEM,
                        0, reinterpret_cast<LPARAM>(&item)))
        {
            item.mask |= CBEIF_TEXT;
            item.pszText = string;

            LPARAM data = SendMessage(Window, CB_GETITEMDATA, index, 0);

            if (ImageList != NULL)
            {
                item.mask |= CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
                item.iImage = image;
                item.iSelectedImage = image;
            }

            SendMessage(Window, CBEM_DELETEITEM, index, 0);

            index = (INT) SendMessage(Window, CBEM_INSERTITEM, 0,
                                      reinterpret_cast<LPARAM>(&item));

            if (index != -1)
            {
                SendMessage(Window, CB_SETITEMDATA, index, data);

                INT current = (INT) SendMessage(Window, CB_GETCURSEL, 0, 0);

                if (current == index)
                {
                    SendMessage(Window, CB_SETCURSEL, current, 0);
                }

                return TRUE;
            }
        }
    }

    return FALSE;
}

//=============================================================================
// CreduiAutoCompleteComboBox::Enable
//
// Created 02/27/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiAutoCompleteComboBox::Enable()
{
    BOOL success = TRUE;

    if (StringArray != NULL)
    {
        success = FALSE;

        IAutoComplete2 *autoCompleteInterface;

        HRESULT result =
            CoCreateInstance(
                CLSID_AutoComplete,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IAutoComplete2,
                reinterpret_cast<void **>(&autoCompleteInterface));

        if (SUCCEEDED(result))
        {
            result = autoCompleteInterface->Init((HWND)
                SendMessage(Window, CBEM_GETEDITCONTROL, 0, 0),
                    StringArray, NULL, NULL);

            if (SUCCEEDED(result))
            {
                result = autoCompleteInterface->SetOptions(ACO_AUTOSUGGEST);

                if (SUCCEEDED(result))
                {
                    success = TRUE;
                }
                else
                {
                    CreduiDebugLog("CreduiAutoCompleteComboBox::Enable: "
                                   "SetOptions failed: 0x%08X\n", result);
                }
            }

            autoCompleteInterface->Release();
            autoCompleteInterface = NULL;
        }
        else
        {
            CreduiDebugLog(
                "CreduiAutoCompleteComboBox::Enable: "
                "CoCreateInstance CLSID_AutoComplete failed: 0x%08X\n",
                result);
        }

        StringArray->Release();
        StringArray = NULL;
    }

    return success;
}

//-----------------------------------------------------------------------------
// CreduiIconParentWindow Class Implementation
//-----------------------------------------------------------------------------

CONST WCHAR *CreduiIconParentWindow::ClassName = L"CreduiIconParentWindow";
HINSTANCE CreduiIconParentWindow::Instance = NULL;
LONG CreduiIconParentWindow::Registered = FALSE;

//=============================================================================
// CreduiIconParentWindow::CreduiIconParentWindow
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

CreduiIconParentWindow::CreduiIconParentWindow()
{
    Window = NULL;
}

//=============================================================================
// CreduiIconParentWindow::~CreduiIconParentWindow
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

CreduiIconParentWindow::~CreduiIconParentWindow()
{
    if (Window != NULL)
    {
        DestroyWindow(Window);
        Window = NULL;
    }
}

//=============================================================================
// CreduiIconParentWindow::Register
//
// Set the instance to allow registration, which will be deferred until a
// window needs to be created.
//
// Arguments:
//   instance (in)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 04/16/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIconParentWindow::Register(
    HINSTANCE instance
    )
{
    Instance = instance;

    return TRUE;
}

//=============================================================================
// CreduiIconParentWindow::Unegister
//
// Unregisters the window class, if registered.
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 04/16/2000 johnstep (John Stephens)
//=============================================================================

BOOL CreduiIconParentWindow::Unregister()
{
    if (InterlockedCompareExchange(&Registered, FALSE, TRUE))
    {
        return UnregisterClass(ClassName, Instance);
    }

    return TRUE;
}

//=============================================================================
// CreduiIconParentWindow::Init
//
// Registers the window class, if not already registered, and creates the
// window.
//
// Arguments:
//   instance (in) - module to load the icon from
//   iconResourceId (in)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIconParentWindow::Init(
    HINSTANCE instance,
    UINT iconResourceId
    )
{
    WNDCLASS windowClass;

    ZeroMemory(&windowClass, sizeof windowClass);

    if (!InterlockedCompareExchange(&Registered, TRUE, FALSE))
    {
        windowClass.lpfnWndProc = DefWindowProc;
        windowClass.hInstance = Instance;
        windowClass.hIcon =
            LoadIcon(instance, MAKEINTRESOURCE(iconResourceId));
        windowClass.hCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
        windowClass.lpszClassName = ClassName;

        InterlockedExchange(&Registered, RegisterClass(&windowClass) != 0);

        if (!InterlockedCompareExchange(&Registered, FALSE, FALSE))
        {
            return FALSE;
        }
    }

    Window = CreateWindow(
        L"CreduiIconParentWindow",
        NULL,
        WS_CAPTION | WS_SYSMENU,
        0, 0, 0, 0,
        NULL, NULL, instance, NULL);

    return (Window != NULL);
}

//-----------------------------------------------------------------------------
// CreduiCredentialControl Class Implementation
//-----------------------------------------------------------------------------

CONST WCHAR *CreduiCredentialControl::ClassName = WC_CREDENTIAL;
HINSTANCE CreduiCredentialControl::Instance = NULL;
LONG CreduiCredentialControl::Registered = FALSE;

//=============================================================================
// CreduiCredentialControl::CreduiCredentialControl
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

CreduiCredentialControl::CreduiCredentialControl()
{
    IsInitialized = FALSE;

    DisabledControlMask = 0;

    Window = NULL;
    Style = 0;

    UserNameStaticWindow = NULL;
    UserNameControlWindow = NULL;
    ViewCertControlWindow = NULL;
    PasswordStaticWindow = NULL;
    PasswordControlWindow = NULL;

    FirstPaint = FALSE;
    ShowBalloonTip = FALSE;

    IsAutoComplete = FALSE;
    NoEditUserName = FALSE;
    KeepUserName = FALSE;

    IsPassport = FALSE;

    CertHashes = NULL;
    CertCount = 0;
    CertBaseInComboBox = 0;
    UserNameCertHash = NULL;
    SmartCardBaseInComboBox = 0;
    SmartCardReadCount = 0;
    IsChangingUserName = FALSE;
    IsChangingPassword = FALSE;

    UserNameSelection = 0;
    ScardUiHandle = NULL;

    DoingCommandLine = FALSE;
    TargetName = NULL;
    InitialUserName = NULL;
}

//=============================================================================
// CreduiCredentialControl::~CreduiCredentialControl
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

CreduiCredentialControl::~CreduiCredentialControl()
{
}

//=============================================================================
// CreduiCredentialControl::Register
//
// Arguments:
//   instance (in)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::Register(
    HINSTANCE instance
    )
{
    Instance = instance;

    WNDCLASS windowClass;

    ZeroMemory(&windowClass, sizeof windowClass);

    if (!InterlockedCompareExchange(&Registered, TRUE, FALSE))
    {
        windowClass.style = CS_GLOBALCLASS;
        windowClass.lpfnWndProc = MessageHandlerCallback;
        windowClass.cbWndExtra = sizeof (CreduiCredentialControl *);
        windowClass.hInstance = Instance;
        windowClass.hIcon = NULL;
        windowClass.hCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
        windowClass.lpszClassName = ClassName;

        InterlockedExchange(&Registered, RegisterClass(&windowClass) != 0);

        if (!InterlockedCompareExchange(&Registered, FALSE, FALSE))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//=============================================================================
// CreduiCredentialControl::Unegister
//
// Unregisters the window class, if registered.
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

BOOL CreduiCredentialControl::Unregister()
{
    if (InterlockedCompareExchange(&Registered, FALSE, TRUE))
    {
        return UnregisterClass(ClassName, Instance);
    }

    return TRUE;
}

//=============================================================================
// CreduiCredentialControl::ViewCertificate
//
// Views the certificate at index in our combo box.
//
// Arguments:
//   index (in) - index in the user name combo box
//
// Returns TRUE if the certificate was viewed, otherwise FALSE.
//
// Created 03/27/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::ViewCertificate(
    INT index
    )
{
    BOOL success = FALSE;

    if (index < CertBaseInComboBox)
    {
        return FALSE;
    }

    CONST CERT_CONTEXT *certContext = NULL;
    HCERTSTORE certStore = NULL;

    // If this is not a smart card, open the MY store and find the certificate
    // from the hash. Otherwise, just grab the certificate context from the
    // CERT_ENUM structure:

    if ((SmartCardBaseInComboBox > 0) &&
        (index >= SmartCardBaseInComboBox))
    {
        CERT_ENUM *certEnum =
            reinterpret_cast<CERT_ENUM *>(
                SendMessage(UserNameControlWindow,
                            CB_GETITEMDATA, index, 0));

        if (certEnum != NULL)
        {
            certContext = certEnum->pCertContext;
        }
    }
    else
    {
        certStore = CertOpenSystemStore(NULL, L"MY");

        if (certStore != NULL)
        {
            CRYPT_HASH_BLOB hashBlob;

            hashBlob.cbData = CERT_HASH_LENGTH;
            hashBlob.pbData = reinterpret_cast<BYTE *>(
                CertHashes[index - CertBaseInComboBox]);

            certContext = CertFindCertificateInStore(
                              certStore,
                              X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                              0,
                              CERT_FIND_SHA1_HASH,
                              &hashBlob,
                              NULL);
        }
    }

    // If we found a certificate context, view the certificate:

    if (certContext != NULL)
    {
        // Now, show the certificate with the common UI:

        CRYPTUI_VIEWCERTIFICATE_STRUCT certViewInfo;

        ZeroMemory(&certViewInfo, sizeof certViewInfo);
        certViewInfo.dwSize = sizeof certViewInfo;
        certViewInfo.hwndParent = Window;
        certViewInfo.pCertContext = certContext;

        BOOL changed;
        changed = FALSE;
        CryptUIDlgViewCertificate(&certViewInfo, &changed);

        // Get the name again, in case it changed. However, skip this if this
        // is a card reader, and is now invalid:

        COMBOBOXEXITEMW item;
        BOOL updateName = TRUE;

        if (index >= SmartCardBaseInComboBox)
        {
            item.mask = CBEIF_IMAGE;
            item.iItem = index;

            if (!SendMessage(UserNameControlWindow,
                             CBEM_GETITEM,
                             0,
                             reinterpret_cast<LPARAM>(&item)) ||
                (item.iImage == IMAGE_SMART_CARD_MISSING))
            {
                updateName = FALSE;
            }
        }

        if (updateName)
        {
            WCHAR displayName[CREDUI_MAX_CERT_NAME_LENGTH];

            CreduiGetCertificateDisplayName(
                certContext,
                displayName,
                RTL_NUMBER_OF(displayName),
                CreduiStrings.Certificate,
                CERT_NAME_FRIENDLY_DISPLAY_TYPE);

            item.mask = CBEIF_TEXT;
            item.iItem = index;
            item.pszText = displayName;

            SendMessage(UserNameControlWindow,
                        CBEM_SETITEM,
                        0,
                        reinterpret_cast<LPARAM>(&item));
        }

        success = TRUE;
    }

    // If we opened a store, free the certificate and close the store:

    if (certStore != NULL)
    {
        if (certContext != NULL)
        {
            CertFreeCertificateContext(certContext);
        }

        if (!CertCloseStore(certStore, 0))
        {
            CreduiDebugLog("CreduiCredentialControl::ViewCertificate: "
                           "CertCloseStore failed: %u\n", GetLastError());
        }
    }

    return success;
}

//=============================================================================
// CreduiCredentialControl::AddCertificates
//
// Adds interesting certificates to the combo box, and allocates an array of
// hashes to match. The hash is all we need to store the credential, and can
// be used to get a CERT_CONTEXT later to view the certificate.
//
// Assume CertCount is 0 upon entry.
//
// Stack space is used for temporary storage of hashes, since each hash is
// only 160 bits. We use a linked list structure, so including the next
// pointer and worst case alignment (8-byte) on 64-bit, the maximum structure
// size is 32 bytes. We don't want to consume too much stack space, so limit
// the number of entries to 256, which will consume up to 8 KB of stack space.
//
// Returns TRUE if at least one interesting certificate exists, and all were
// added to the combo box without error. Otherwise, returns FALSE.
//
// Created 03/25/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::AddCertificates()
{
    BOOL success = FALSE;

    ASSERT(CertCount == 0);

    HCERTSTORE certStore = CertOpenSystemStore(NULL, L"MY");

    if (certStore != NULL)
    {
        struct HASH_ENTRY
        {
            UCHAR Hash[CERT_HASH_LENGTH];
            HASH_ENTRY *Next;
        };

        HASH_ENTRY *hashList = NULL;
        HASH_ENTRY *current = NULL;
        HASH_ENTRY *next = NULL;

        CONST CERT_CONTEXT *certContext = NULL;

        // NOTE: Currently, add all client authentication certificates. This
        //       should be revisited.

        CHAR *ekUsageIdentifiers[] = {
            szOID_PKIX_KP_CLIENT_AUTH,
            szOID_KP_SMARTCARD_LOGON
        };

        CERT_ENHKEY_USAGE ekUsage = { 2, ekUsageIdentifiers };

        // We allow a maximum of 256 certificates to be added. This is a
        // reasonable limit, given the current user interface. If this is an
        // unreasonable limit for the personal certificate store, then this
        // can always be changed.

        while (CertCount < 256)
        {
            certContext =
                CertFindCertificateInStore(
                    certStore,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                    CERT_FIND_ENHKEY_USAGE,
                    static_cast<VOID *>(&ekUsage),
                    certContext);

            if (certContext != NULL)
            {
                DWORD length = CERT_HASH_LENGTH;

                // Only allocate a new entry if necessary. Something may have
                // failed from the previous loop iteration, so we can just
                // reuse the entry allocated then:

                if (next == NULL)
                {
                    // Wrap the alloca in an exception handler because it will
                    // throw a stack overflow exception on failure. Of course,
                    // of we're out of stack space, we may not even be able to
                    // clean up properly without throwing an exception.

                    __try
                    {
                        // known use of alloca() in a loop - small struct, 24 bytes on i386
                        //  normally small number, constrained number (limit 256)
                        //  protected by try/except
                        next = static_cast<HASH_ENTRY *>(
                                   alloca(sizeof HASH_ENTRY));
                    }
                    __except(
                        (GetExceptionCode() == EXCEPTION_STACK_OVERFLOW) ?
                            EXCEPTION_EXECUTE_HANDLER :
                            EXCEPTION_CONTINUE_SEARCH)
                    {
                        _resetstkoflw();
                        next = NULL;
                    }

                    // If this fails, for whatever reason, break out of the
                    // loop:

                    if (next == NULL)
                    {
                        CertFreeCertificateContext(certContext);
                        break;
                    }

                    next->Next = NULL;
                }

                if (!CertGetCertificateContextProperty(
                        certContext,
                        CERT_SHA1_HASH_PROP_ID,
                        static_cast<VOID *>(&next->Hash),
                        &length))
                {
                    // If we failed to get the hash for this certificate, just
                    // ignore it and continue with the next. The memory we
                    // allocation for this entry will be used on the next
                    // iteration if we do not set it to NULL.

                    continue;
                }

                if (CreduiIsRemovableCertificate(certContext))
                {
                    // If this certificate requires a removable component,
                    // such as a smart card, then skip it. We will enumerate
                    // these later.

                    continue;
                }

                WCHAR displayName[CREDUI_MAX_CERT_NAME_LENGTH];

                CreduiGetCertificateDisplayName(
                    certContext,
                    displayName,
                    RTL_NUMBER_OF(displayName),
                    CreduiStrings.Certificate,
                    CERT_NAME_FRIENDLY_DISPLAY_TYPE);

                // Add the certificate to the combo box. Certificate names may
                // not be unique, so allow duplicates:

                if (UserNameComboBox.Add(
                        displayName,
                        CreduiIsExpiredCertificate(certContext) ?
                            IMAGE_CERT_EXPIRED :
                            IMAGE_CERT,
                        FALSE,
                        FALSE) == -1)
                {
                    CertFreeCertificateContext(certContext);
                    break;
                }

                // Everything succeeded, so add the certificate to our list:

                if (current == NULL)
                {
                    current = next;
                    hashList = current;
                }
                else
                {
                    ASSERT(current->Next == NULL);

                    current->Next = next;
                    current = current->Next;
                }

                if (current == NULL)
                {
                    CertFreeCertificateContext(certContext);
                    break;
                }

                // Set next to NULL so we will allocate new memory on the
                // next iteration:

                next = NULL;

                CertCount++;
            }
            else
            {
                break;
            }
        }

        if (CertCount > 0)
        {
            current = hashList;

            // Now, allocate the final array of certificates. We allocate
            // this in a single block to help avoid thrashing the heap:

            CertHashes = new UCHAR [CertCount][CERT_HASH_LENGTH];

            if (CertHashes != NULL)
            {
                for (UINT i = 0; i < CertCount; ++i)
                {
                    CopyMemory(CertHashes[i],
                               current->Hash,
                               CERT_HASH_LENGTH);

                    current = current->Next;
                }

                success = TRUE;
            }
        }

        CertCloseStore(certStore, 0);
    }

    return success;
}

//=============================================================================
// CreduiCredentialControl::FindSmartCardInComboBox
//
// Finds a smart card entry in the user name combo box based on a CERT_ENUM.
//
// Arguments:
//   certEnum (in)
//
// Returns the index of the smart card or -1 if not found.
//
// Created 04/15/2000 johnstep (John Stephens)
//=============================================================================

INT
CreduiCredentialControl::FindSmartCardInComboBox(
    CERT_ENUM *certEnum
    )
{
    UINT count = (UINT) SendMessage(UserNameControlWindow, CB_GETCOUNT, 0, 0);

    if (count == CB_ERR)
    {
        return -1;
    }

    CERT_ENUM *findCertEnum;

    for (UINT i = SmartCardBaseInComboBox; i < count; ++i)
    {
        findCertEnum =
            reinterpret_cast<CERT_ENUM *>(
                SendMessage(UserNameControlWindow, CB_GETITEMDATA, i, 0));

        ASSERT(findCertEnum != NULL);

        if (_wcsicmp(findCertEnum->pszReaderName,
                     certEnum->pszReaderName) == 0)
        {
            return i;
        }
    }

    return -1;
}

//=============================================================================
// CreduiCredentialControl::RemoveSmartCardFromComboBox
//
// Removes all entries for this smart card from the user name combo box.
//
// Arguments:
//   certEnum (in)
//   removeParent (in)
//
// Created 07/12/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiCredentialControl::RemoveSmartCardFromComboBox(
    CERT_ENUM *certEnum,
    BOOL removeParent
    )
{
    INT count = (INT) SendMessage(UserNameControlWindow, CB_GETCOUNT, 0, 0);
    INT current = (INT) SendMessage(UserNameControlWindow,
                                    CB_GETCURSEL, 0, 0);

    if (count != CB_ERR)
    {
        CERT_ENUM *findCertEnum;
        BOOL parentEntry = TRUE;
        BOOL currentRemoved = FALSE;

        for (INT i = SmartCardBaseInComboBox; i < count; ++i)
        {
            findCertEnum =
                reinterpret_cast<CERT_ENUM *>(
                    SendMessage(UserNameControlWindow, CB_GETITEMDATA, i, 0));

            ASSERT(findCertEnum != NULL);

            if (_wcsicmp(findCertEnum->pszReaderName,
                         certEnum->pszReaderName) == 0)
            {
                if (parentEntry)
                {
                    parentEntry = FALSE;

                    if (!removeParent)
                    {
                        continue;
                    }
                }

                if (current == i)
                {
                    currentRemoved = TRUE;
                }

                SendMessage(
                    UserNameControlWindow,
                    CBEM_DELETEITEM,
                    i,
                    0);

                i--, count--;
            }
            else if (!parentEntry)
            {
                break;
            }
        }

        if (currentRemoved)
        {
            if (removeParent)
            {
                IsChangingUserName = TRUE;
                SendMessage(UserNameControlWindow, CB_SETCURSEL, -1, 0);
                UserNameComboBox.Update(-1, L"", IMAGE_USERNAME);
                IsChangingUserName = FALSE;

                IsChangingPassword = TRUE;
                SetWindowText(PasswordControlWindow, NULL);
                IsChangingPassword = FALSE;

                OnUserNameSelectionChange();
            }
            else
            {
                IsChangingUserName = TRUE;
                SendMessage(UserNameControlWindow, CB_SETCURSEL, --i, 0);
                IsChangingUserName = FALSE;
            }

            OnUserNameSelectionChange();
        }
    }
}

//=============================================================================
// CreduiCredentialControl::HandleSmartCardMessages
//
// Handle smart card messages.
//
// Arguments:
//   message (in)
//   certEnum (in)
//
// Returns TRUE if the message was handled or FALSE otherwise.
//
// Created 04/14/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::HandleSmartCardMessages(
    UINT message,
    CERT_ENUM *certEnum
    )
{
    ASSERT(ScardUiHandle != NULL);

    // This is sort of ugly since we cannot use a switch. First check for any
    // possible smart card message because we must do some things in common
    // for any of the messages:

    if ((message == CreduiScarduiWmReaderArrival) ||
        (message == CreduiScarduiWmReaderRemoval) ||
        (message == CreduiScarduiWmCardInsertion) ||
        (message == CreduiScarduiWmCardRemoval) ||
        (message == CreduiScarduiWmCardCertAvail) ||
        (message == CreduiScarduiWmCardStatus))
    {
        if (certEnum == NULL)
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "NULL was passed for the CERT_ENUM!");

            // We handled the message, even though it was invalid:

            return TRUE;
        }

        ASSERT(certEnum->pszReaderName != NULL);
    }
    else
    {
        return FALSE;
    }

    WCHAR *displayString;
    WCHAR string[256]; // Must be >= CREDUI_MAX_CERT_NAME_LENGTH

    ASSERT((sizeof string / (sizeof string[0])) >=
           CREDUI_MAX_CERT_NAME_LENGTH);

    INT index = FindSmartCardInComboBox(certEnum);

    if (message == CreduiScarduiWmReaderArrival)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: Reader arrival event for %0x\n",this->Window);
#endif
        // Add the reader, if it is not already there; it should not be:

        if (index == -1)
        {

            //
            // Reset command line Hearbeat timer.
            //

            Heartbeats = 0;

            index =
                UserNameComboBox.Add(
                    DoingCommandLine ?
                    CreduiStrings.NoCard :
                    CreduiStrings.EmptyReader,
                    IMAGE_SMART_CARD_MISSING,
                    FALSE,
                    FALSE);

            if (index != -1)
            {
                SendMessage(UserNameControlWindow,
                            CB_SETITEMDATA,
                            index,
                            reinterpret_cast<LPARAM>(certEnum));

                if (UserNameCertHash != NULL)
                {
                    // disable the view cert button - will enable on cert found msg
                    EnableWindow(ViewCertControlWindow, FALSE);
                    DisabledControlMask |= DISABLED_CONTROL_VIEW;

                    // change password prompt to PIN:
                    SetWindowText(
                        PasswordStaticWindow,
                        CreduiStrings.PinStatic);

                    // Clean password control
                    IsChangingPassword = TRUE;
                    SetWindowText(PasswordControlWindow, NULL);
                    IsChangingPassword = FALSE;

                    // enable the password control
                    EnableWindow(PasswordControlWindow, TRUE);
                    EnableWindow(PasswordStaticWindow, TRUE);
                    DisabledControlMask &= ~DISABLED_CONTROL_PASSWORD;

                    // Change Username prompt to Smartcard:
                    SetWindowText(
                        UserNameStaticWindow,
                        CreduiStrings.SmartCardStatic);
#if 0
                    // disable save if present.
                    if (SaveControlWindow != NULL)
                    {
                        EnableWindow(SaveControlWindow, FALSE);
                        DisabledControlMask |= DISABLED_CONTROL_SAVE;
                    }
#endif
                    IsChangingUserName = TRUE;
                    UserNameComboBox.Update(
                        -1,
                        DoingCommandLine ?
                        CreduiStrings.NoCard :
                        CreduiStrings.EmptyReader,
                        IMAGE_SMART_CARD_MISSING);
                    IsChangingUserName = FALSE;
                }
            }
            else
            {
                CreduiDebugLog(
                    "CreduiCredentialControl::HandleSmartCardMessages: "
                    "Failed to add smart card\n");
            }
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Reader arrived more than once");
        }

    }
    else if (message == CreduiScarduiWmReaderRemoval)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: Reader removal event for %0x\n",this->Window);
#endif
        if (index != -1)
        {
            RemoveSmartCardFromComboBox(certEnum, TRUE);
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Reader removed more than once");
        }
    }
    else if (message == CreduiScarduiWmCardInsertion)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card insertion event for %0x\n",this->Window);
#endif
        if (index != -1)
        {
            //
            // Reset command line Hearbeat timer.
            //

            Heartbeats = 0;

            SmartCardReadCount++;

            if (UserNameCertHash != NULL)
            {
                IsChangingUserName = TRUE;
                UserNameComboBox.Update(
                    -1,
                    CreduiStrings.ReadingCard,
                    IMAGE_SMART_CARD_MISSING);
                IsChangingUserName = FALSE;
            }

            IsChangingUserName = TRUE;
            UserNameComboBox.Update(index,
                                    CreduiStrings.ReadingCard,
                                    IMAGE_SMART_CARD_MISSING);
            IsChangingUserName = FALSE;
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Card insertion to absent reader\n");
        }
    }
    else if (message == CreduiScarduiWmCardRemoval)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card removal event for %0x\n",this->Window);
#endif
        if (index != -1)
        {
            if (BalloonTip.GetInfo() == &CreduiBackwardsTipInfo)
            {
                BalloonTip.Hide();
            }

            IsChangingUserName = TRUE;
            UserNameComboBox.Update(index,
                                    DoingCommandLine ?
                                    CreduiStrings.NoCard :
                                    CreduiStrings.EmptyReader,
                                    IMAGE_SMART_CARD_MISSING);
            IsChangingUserName = FALSE;

            // Clean password control
            IsChangingPassword = TRUE;
            SetWindowText(PasswordControlWindow, NULL);
            IsChangingPassword = FALSE;

            RemoveSmartCardFromComboBox(certEnum, FALSE);
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Card removal from absent reader\n");
        }
    }
    else if (message == CreduiScarduiWmCardCertAvail)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: cert available event for %0x\n",this->Window);
#endif
        // scard system still producing activity.  Extend timeout.
        Heartbeats = 0;
        if (index != -1)
        {
            // Filter certificates which are not for client authentication:

            if (!CreduiIsClientAuthCertificate(certEnum->pCertContext))
            {
                return TRUE;
            }

            UINT image = IMAGE_SMART_CARD_MISSING;
            COMBOBOXEXITEM item;

            item.mask = CBEIF_IMAGE;
            item.iItem = index;

            SendMessage(UserNameControlWindow, CBEM_GETITEM,
                        0, reinterpret_cast<LPARAM>(&item));

            //
            // For command line,
            //  get the UPN display name since the user is expected to type it.
            // For GUI,
            //  get the friendly display name since it is "friendly".
            //

            CreduiGetCertificateDisplayName(
               certEnum->pCertContext,
               string,
               CREDUI_MAX_CERT_NAME_LENGTH,
               CreduiStrings.Certificate,
               DoingCommandLine ?
                    CERT_NAME_UPN_TYPE :
                    CERT_NAME_FRIENDLY_DISPLAY_TYPE);

            displayString = string;

            //
            // Trim trailing spaces and -'s so it doesn't look cheesy
            //

            if ( DoingCommandLine ) {
                DWORD StringLength = wcslen(string);

                while ( StringLength > 0 ) {
                    if ( string[StringLength-1] == ' ' || string[StringLength-1] == '-' ) {
                        string[StringLength-1] = '\0';
                        StringLength--;
                    } else {
                        break;
                    }
                }

            }
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: cert name '%ws' %0x\n", string, this->Window);
#endif

            if (SendMessage(UserNameControlWindow,
                            CB_GETCURSEL,
                            0,
                            0) == index)
            {
                // Enable the view cert button, previously disabled on reader arrival
                EnableWindow(ViewCertControlWindow, TRUE);
                DisabledControlMask &= ~DISABLED_CONTROL_VIEW;
            }

            image =
                CreduiIsExpiredCertificate(certEnum->pCertContext) ?
                    IMAGE_SMART_CARD_EXPIRED :
                    IMAGE_SMART_CARD;

            INT newIndex = index;

            if (item.iImage != IMAGE_SMART_CARD_MISSING)
            {
                newIndex = UserNameComboBox.Add(displayString,
                                                image,
                                                FALSE,
                                                FALSE,
                                                index + 1,
                                                1);

                if (newIndex != -1)
                {
                    SendMessage(UserNameControlWindow,
                                CB_SETITEMDATA,
                                newIndex,
                                reinterpret_cast<LPARAM>(certEnum));
                }
                else
                {
                    newIndex = index;
                }
            }

            if (newIndex == index)
            {
                IsChangingUserName = TRUE;
                UserNameComboBox.Update(index, displayString, image);
                IsChangingUserName = FALSE;
            }

            if (UserNameCertHash != NULL)
            {
                UCHAR hash[CERT_HASH_LENGTH];
                DWORD length = CERT_HASH_LENGTH;

                if (CertGetCertificateContextProperty(
                        certEnum->pCertContext,
                        CERT_SHA1_HASH_PROP_ID,
                        static_cast<VOID *>(hash),
                        &length))
                {
                    // if the hash of an inserted card matches the one we're looking
                    //  for, release the match pattern from memory, and force 
                    //  select the inserted card.
                    //
                    // UserNameCertHash was set by unmarshalling the marshalled username
                    //  contained in a credential on the user keyring, and then searching
                    //  the cert store for a matching certificate.
                    if (RtlCompareMemory(UserNameCertHash,
                                         hash,
                                         CERT_HASH_LENGTH) ==
                                         CERT_HASH_LENGTH)
                    {
                        delete [] UserNameCertHash;
                        UserNameCertHash = NULL;

                        IsChangingUserName = TRUE;
                        SendMessage(UserNameControlWindow,
                                    CB_SETCURSEL, newIndex, 0);
                        IsChangingUserName = FALSE;

                        OnUserNameSelectionChange();
                    }
                }
            }
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Card certificate to absent reader\n");
        }
    }
    else if (message == CreduiScarduiWmCardStatus)
    {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status event for %0x\n",this->Window);
#endif
        if (index != -1)
        {
            if (--SmartCardReadCount == 0)
            {
                if (UserNameCertHash != NULL)
                {
                    IsChangingUserName = TRUE;
                    SetWindowText(UserNameControlWindow,
                                    DoingCommandLine ?
                                    CreduiStrings.NoCard :
                                    CreduiStrings.EmptyReader);
                    IsChangingUserName = FALSE;
                }
            }
            else 
            {
                // if still other readers to service, extend the timeout
                Heartbeats = 0;
            }

            UINT image = IMAGE_SMART_CARD_MISSING;
            BOOL showBalloon = FALSE;

            switch (certEnum->dwStatus)
            {
            case SCARD_S_SUCCESS:

                COMBOBOXEXITEM item;

#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status SUCCESS: %ws\n",  certEnum->pszCardName );
#endif
                item.mask = CBEIF_IMAGE;
                item.iItem = index;

                if (SendMessage(UserNameControlWindow, CBEM_GETITEM,
                                0, reinterpret_cast<LPARAM>(&item)) &&
                    (item.iImage != IMAGE_SMART_CARD_MISSING))
                {
                    return TRUE;
                }

                displayString = CreduiStrings.EmptyCard;
                break;

            case SCARD_E_UNKNOWN_CARD:
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status UNKNOWN CARD\n");
#endif
                displayString = CreduiStrings.UnknownCard;
                break;

            case SCARD_W_UNRESPONSIVE_CARD:
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status UNRESPONSIVE CARD\n");
#endif
                displayString = CreduiStrings.BackwardsCard;
                if (!DoingCommandLine) showBalloon = TRUE;
                break;

            case NTE_KEYSET_NOT_DEF:
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status NTE_KEYSET_NOT_DEF\n");
#endif
                // TODO: This case should be removed eventually.

                displayString = CreduiStrings.EmptyCard;
                break;

            case SCARD_W_REMOVED_CARD:
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status REMOVED CARD\n");
#endif
                displayString = DoingCommandLine ?
                                    CreduiStrings.NoCard :
                                    CreduiStrings.EmptyReader;
CreduiStrings.EmptyReader;
                break;

            default:
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: card status ERROR\n");
#endif
                displayString = CreduiStrings.CardError;
                break;
            }

            IsChangingUserName = TRUE;
            UserNameComboBox.Update(index, displayString, image);
            IsChangingUserName = FALSE;

            if (showBalloon && !BalloonTip.IsVisible())
            {
                BalloonTip.SetInfo(UserNameControlWindow,
                                   &CreduiBackwardsTipInfo);

                BalloonTip.Show();
            }
        }
        else
        {
            CreduiDebugLog(
                "CreduiCredentialControl::HandleSmartCardMessages: "
                "Card status to absent reader\n");
        }
    }

    // We handled the message:

    return TRUE;
}

//=============================================================================
// CreduiCredentialControl::CreateControls
//
// Created 06/23/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::CreateControls()
{
    // First we need the parent window:

    HWND dialogWindow = GetParent(Window);

    if (dialogWindow == NULL)
    {
        return FALSE;
    }

    // Create the various windows:

    RECT clientRect;
    RECT rect;
    UINT add;
    BOOL noViewCert = FALSE;

    if ( Style & CRS_KEEPUSERNAME )
    {
        KeepUserName = TRUE;
    }

    if (!(Style & CRS_USERNAMES) )
    {
        NoEditUserName = TRUE;
    }
    else if ((Style & (CRS_CERTIFICATES | CRS_SMARTCARDS)) == 0)
    {
        noViewCert = TRUE;
    }

    if ( Style & CRS_SINGLESIGNON )
        IsPassport = TRUE;
    else
        IsPassport = FALSE;

    // Determine how much wider the control is than the minimum to resize and
    // reposition controls as necessary:

    GetClientRect(Window, &clientRect);

    rect.left = 0;
    rect.top = 0;
    rect.right = CREDUI_CONTROL_MIN_WIDTH;
    rect.bottom = CREDUI_CONTROL_MIN_HEIGHT;

    if ( !DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
    {
        goto ErrorExit;
    }

    if ((clientRect.right - clientRect.left) >
        (rect.right - rect.left))
    {
        add = (clientRect.right - clientRect.left) -
              (rect.right - rect.left);
    }
    else
    {
        add = 0;
    }

    // Create user name static text control:

    rect.left = CREDUI_CONTROL_USERNAME_STATIC_X;
    rect.top = CREDUI_CONTROL_USERNAME_STATIC_Y;
    rect.right = rect.left + CREDUI_CONTROL_USERNAME_STATIC_WIDTH;
    rect.bottom = rect.top + CREDUI_CONTROL_USERNAME_STATIC_HEIGHT;

    if ( !DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
    {
        goto ErrorExit;
    }

    WCHAR* pUserNameLabel;
    if ( IsPassport )
        pUserNameLabel = CreduiStrings.EmailName;
    else
        pUserNameLabel = CreduiStrings.UserNameStatic;


    UserNameStaticWindow =
        CreateWindowEx(
            WS_EX_NOPARENTNOTIFY,
            L"STATIC",
            pUserNameLabel,
            WS_VISIBLE | WS_CHILD | WS_GROUP,
            rect.left,
            rect.top,
            rect.right - rect.left,
            rect.bottom - rect.top,
            Window,
            reinterpret_cast<HMENU>(IDC_USERNAME_STATIC),
            CreduiCredentialControl::Instance,
            NULL);

    if (UserNameStaticWindow == NULL)
    {
        goto ErrorExit;
    }

    // Create user name combo box:

    rect.left = CREDUI_CONTROL_USERNAME_X;
    rect.top = CREDUI_CONTROL_USERNAME_Y;

    if (!noViewCert)
    {
        rect.right = rect.left + CREDUI_CONTROL_USERNAME_WIDTH;
    }
    else
    {
        rect.right = CREDUI_CONTROL_VIEW_X + CREDUI_CONTROL_VIEW_WIDTH;
    }

    if ( KeepUserName )
    {
        rect.top += 2;      // fudge it to make them line up better
        rect.bottom = rect.top + CREDUI_CONTROL_PASSWORD_STATIC_HEIGHT;  // make it the same height as the password edit
    }
    else
    {
        rect.bottom = rect.top + CREDUI_CONTROL_USERNAME_HEIGHT;  // set the height
    }


    if ( !DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
    {
        goto ErrorExit;
    }

    // This block of statements and the usage of lExStyles : see bug 439840
    LONG_PTR lExStyles = GetWindowLongPtr(Window,GWL_EXSTYLE);
    SetWindowLongPtr(Window,GWL_EXSTYLE,(lExStyles | WS_EX_NOINHERITLAYOUT));

    if ( KeepUserName )
    {

        // create an edit box instead of a combo box

        UserNameControlWindow =
            CreateWindowEx(
                WS_EX_NOPARENTNOTIFY,
                L"Edit",
                L"",
                WS_VISIBLE | WS_CHILD | WS_TABSTOP | ES_READONLY,
                rect.left,
                rect.top,
                rect.right - rect.left + add,
                rect.bottom - rect.top,
                Window,
                reinterpret_cast<HMENU>(IDC_USERNAME),
                CreduiCredentialControl::Instance,
                NULL);
  
    }
    else
    {

        UserNameControlWindow =
            CreateWindowEx(
                WS_EX_NOPARENTNOTIFY,
                L"ComboBoxEx32",
                L"",
                WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_VSCROLL |
                    (NoEditUserName ? CBS_DROPDOWNLIST : CBS_DROPDOWN) |
                    CBS_AUTOHSCROLL,
                rect.left,
                rect.top,
                rect.right - rect.left + add,
                rect.bottom - rect.top,
                Window,
                reinterpret_cast<HMENU>(IDC_USERNAME),
                CreduiCredentialControl::Instance,
                NULL);
    }

    SetWindowLongPtr(Window,GWL_EXSTYLE,lExStyles);

    if (UserNameControlWindow == NULL)
    {
        goto ErrorExit;
    }

    // Create view button:

    if (!noViewCert)
    {
        rect.left = CREDUI_CONTROL_VIEW_X;
        rect.top = CREDUI_CONTROL_VIEW_Y;
        rect.right = rect.left + CREDUI_CONTROL_VIEW_WIDTH;
        rect.bottom = rect.top + CREDUI_CONTROL_VIEW_HEIGHT;

        if ( !DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
        {
            goto ErrorExit;
        }

        ViewCertControlWindow =
            CreateWindowEx(
                WS_EX_NOPARENTNOTIFY,
                L"BUTTON",
                L"&...",
                WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_GROUP |
                    BS_PUSHBUTTON | BS_CENTER,
                rect.left + add,
                rect.top,
                rect.right - rect.left,
                rect.bottom - rect.top,
                Window,
                reinterpret_cast<HMENU>(IDC_VIEW_CERT),
                CreduiCredentialControl::Instance,
                NULL);

        if (ViewCertControlWindow == NULL)
        {
            goto ErrorExit;
        }

        EnableWindow(ViewCertControlWindow, FALSE);
        DisabledControlMask |= DISABLED_CONTROL_VIEW;
    }

    // Create password static text control:

    rect.left = CREDUI_CONTROL_PASSWORD_STATIC_X;
    rect.top = CREDUI_CONTROL_PASSWORD_STATIC_Y;
    rect.right = rect.left + CREDUI_CONTROL_PASSWORD_STATIC_WIDTH;
    rect.bottom = rect.top + CREDUI_CONTROL_PASSWORD_STATIC_HEIGHT;

    if ( !DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
    {
        goto ErrorExit;
    }

    PasswordStaticWindow =
        CreateWindowEx(
            WS_EX_NOPARENTNOTIFY,
            L"STATIC",
            CreduiStrings.PasswordStatic,
            WS_VISIBLE | WS_CHILD | WS_GROUP,
            rect.left,
            rect.top,
            rect.right - rect.left,
            rect.bottom - rect.top,
            Window,
            reinterpret_cast<HMENU>(IDC_PASSWORD_STATIC),
            CreduiCredentialControl::Instance,
            NULL);

    if (PasswordStaticWindow == NULL)
    {
        goto ErrorExit;
    }

    // Create password edit control:

    rect.left = CREDUI_CONTROL_PASSWORD_X;
    rect.top = CREDUI_CONTROL_PASSWORD_Y;
    if (!noViewCert)
    {
        rect.right = rect.left + CREDUI_CONTROL_PASSWORD_WIDTH;
    }
    else
    {
        rect.right = CREDUI_CONTROL_VIEW_X + CREDUI_CONTROL_VIEW_WIDTH;
    }
    rect.bottom = rect.top + CREDUI_CONTROL_PASSWORD_HEIGHT;

    if (!DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
    {
        goto ErrorExit;
    }
    
    // This block of statements and the usage of lExStyles : see bug 439840
    lExStyles = GetWindowLongPtr(Window,GWL_EXSTYLE);
    SetWindowLongPtr(Window,GWL_EXSTYLE,(lExStyles | WS_EX_NOINHERITLAYOUT));

    PasswordControlWindow =
        CreateWindowEx(
            WS_EX_NOPARENTNOTIFY | WS_EX_CLIENTEDGE,
            L"EDIT",
            L"",
            WS_VISIBLE | WS_CHILD | WS_TABSTOP | ES_PASSWORD | ES_AUTOHSCROLL,
            rect.left,
            rect.top,
            rect.right - rect.left + add,
            rect.bottom - rect.top + 1, // NOTE: Add 1 for now, investigate
            Window,
            reinterpret_cast<HMENU>(IDC_PASSWORD),
            CreduiCredentialControl::Instance,
            NULL);
    
    SetWindowLongPtr(Window,GWL_EXSTYLE,lExStyles);

    if (PasswordControlWindow == NULL)
    {
        goto ErrorExit;
    }

    // Create save check box:

    if (Style & CRS_SAVECHECK )
    {
        rect.left = CREDUI_CONTROL_SAVE_X;
        rect.top = CREDUI_CONTROL_SAVE_Y;
        rect.right = rect.left + CREDUI_CONTROL_SAVE_WIDTH;
        rect.bottom = rect.top + CREDUI_CONTROL_SAVE_HEIGHT;

        if (!DoingCommandLine && !MapDialogRect(dialogWindow, &rect))
        {
            goto ErrorExit;
        }

        WCHAR* pSavePromptString;

        if ( IsPassport )
            pSavePromptString = CreduiStrings.PassportSave;
        else
            pSavePromptString = CreduiStrings.Save;

        SaveControlWindow =
            CreateWindowEx(
                WS_EX_NOPARENTNOTIFY,
                L"BUTTON",
                pSavePromptString,
                WS_VISIBLE | WS_CHILD | WS_TABSTOP | WS_GROUP |
                    BS_AUTOCHECKBOX,
                rect.left,
                rect.top,
                rect.right - rect.left + add,
                rect.bottom - rect.top,
                Window,
                reinterpret_cast<HMENU>(IDC_SAVE),
                CreduiCredentialControl::Instance,
                NULL);

        if (SaveControlWindow == NULL)
        {
            goto ErrorExit;
        }

        SendMessage(SaveControlWindow, BM_SETCHECK, BST_UNCHECKED, 0);
    }

    SendMessage(
        Window,
        WM_SETFONT,
        SendMessage(dialogWindow, WM_GETFONT, 0, 0),
        FALSE);

    return TRUE;

ErrorExit:

    if (SaveControlWindow != NULL)
    {
        DestroyWindow(SaveControlWindow);
        SaveControlWindow = NULL;
    }

    if (PasswordControlWindow != NULL)
    {
        DestroyWindow(PasswordControlWindow);
        PasswordControlWindow = NULL;
    }

    if (PasswordStaticWindow != NULL)
    {
        DestroyWindow(PasswordStaticWindow);
        PasswordStaticWindow = NULL;
    }

    if (ViewCertControlWindow != NULL)
    {
        DestroyWindow(ViewCertControlWindow);
        ViewCertControlWindow = NULL;
    }

    if (UserNameControlWindow != NULL)
    {
        DestroyWindow(UserNameControlWindow);
        UserNameControlWindow = NULL;
    }

    if (UserNameStaticWindow != NULL)
    {
        DestroyWindow(UserNameStaticWindow);
        UserNameStaticWindow = NULL;
    }

    return FALSE;
}

LPWSTR
TrimUsername(
    IN LPWSTR AccountDomainName OPTIONAL,
    IN LPWSTR UserName
    )
/*++

Routine Description:

    Returns a pointer to the substring of UserName past any AccountDomainName prefix.

Arguments:

    AccountDomainName - The DomainName to check to see if it prefixes the UserName.

    UserName - The UserName to check

Return Values:

    Return a pointer to the non-prefixed username

--*/
{
    DWORD AccountDomainNameLength;
    DWORD UserNameLength;
    WCHAR Temp[CNLEN+1];

    //
    // If we couldn't determine the AccountDomainName,
    //  return the complete user name.
    //

    if ( AccountDomainName == NULL ) {
        return UserName;
    }

    //
    // If the user name isn't prefixed by the account domain name,
    //  return the complete user name.
    //

    AccountDomainNameLength = wcslen( AccountDomainName );
    UserNameLength = wcslen( UserName );

    if ( AccountDomainNameLength > CNLEN || AccountDomainNameLength < 1 ) {
        return UserName;
    }

    if ( AccountDomainNameLength+2 > UserNameLength ) {
        return UserName;
    }

    if ( UserName[AccountDomainNameLength] != '\\' ) {
        return UserName;
    }

    RtlCopyMemory( Temp, UserName, AccountDomainNameLength*sizeof(WCHAR) );
    Temp[AccountDomainNameLength] = '\0';

    if ( _wcsicmp( Temp, AccountDomainName ) != 0 ) {
        return UserName;
    }

    return &UserName[AccountDomainNameLength+1];
}

//=============================================================================
// CreduiCredentialControl::InitComboBoxUserNames
//
// Created 06/23/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::InitComboBoxUserNames()
{
    CREDENTIAL **credentialSet = NULL;
    LOCALGROUP_MEMBERS_INFO_2 *groupInfo = NULL;
    DWORD nameCount = 0;
    LPWSTR AccountDomainName = NULL;

    if (Style & CRS_ADMINISTRATORS)
    {
        //
        // Enumerate the members of LocalAdministrators
        //

        if ( !CreduiGetAdministratorsGroupInfo(&groupInfo, &nameCount)) {
            return FALSE;
        }
    }
    else
    {
        if (!LocalCredEnumerateW(NULL, 0, &nameCount, &credentialSet))
        {
            return FALSE;
        }
    }

    // Initialize COM for STA, unless there are zero names:

    if ((Style & CRS_AUTOCOMPLETE) && nameCount > 0)
    {
        HRESULT comResult = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

        if (SUCCEEDED(comResult))
        {
            IsAutoComplete = TRUE;
        }
        else
        {
            // The auto complete object and our string object require a STA.
            // Our object could easily support a MTA, but we do not support
            // marshaling between apartments.

            if (comResult == RPC_E_CHANGED_MODE)
            {
                CreduiDebugLog("CreduiCredentialControl: "
                               "Auto complete disabled for MTA\n");
            }

            IsAutoComplete = FALSE;
        }
    }
    else
    {
        IsAutoComplete = FALSE;
    }

    // Initialize the auto complete combo box:

    if (!UserNameComboBox.Init(CreduiInstance,
                               UserNameControlWindow,
                               IsAutoComplete ? nameCount : 0,
                               IDB_TYPES,
                               IMAGE_USERNAME))
    {
        // If initialization failed, and we had attempted for auto complete
        // support, try again without auto complete:

        if (IsAutoComplete)
        {
            IsAutoComplete = FALSE;

            CoUninitialize();

            if (!UserNameComboBox.Init(CreduiInstance,
                                       UserNameControlWindow,
                                       0,
                                       IDB_TYPES,
                                       IMAGE_USERNAME))
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }

    //
    // If we'll complete the user name,
    //  truncate any username displayed here.
    //  (We'll complete it later.)
    //

    if ( Style & CRS_COMPLETEUSERNAME ) {
        AccountDomainName = GetAccountDomainName();
    }

    // Add user names from credentials, if not requesting an
    // Administrator:

   if (!(Style & CRS_KEEPUSERNAME))
   {
        // only add usernames if we're not keeping the one set

        UINT i = 0;

        if (!(Style & CRS_ADMINISTRATORS))
        {
            for (i = 0; i < nameCount; ++i)
            {
                // Skip domain certificates:

                if (credentialSet[i]->Type == CRED_TYPE_DOMAIN_CERTIFICATE)
                {
                    continue;
                }

                // If this is a generic credential, look for a marshaled
                // credential, and skip, if found:

                if ((credentialSet[i]->Type == CRED_TYPE_GENERIC) &&
                    LocalCredIsMarshaledCredentialW(credentialSet[i]->UserName))
                {
                    continue;
                }

                // Skip this credential if the name is empty:

                if (credentialSet[i]->UserName == NULL)
                {
                    continue;
                }

                // Add the user name to the combo box with auto complete. If
                // this fails, do not continue:

                if (UserNameComboBox.Add(
                       TrimUsername( AccountDomainName, credentialSet[i]->UserName),
                       0, IsAutoComplete, TRUE) == -1)
                {
                    break;
                }
            }

            LocalCredFree(static_cast<VOID *>(credentialSet));
        }
        else if (groupInfo != NULL)
        {
            PSID adminSid = NULL;

            if ( !CreduiLookupLocalSidFromRid(DOMAIN_USER_RID_ADMIN, &adminSid)) {
                adminSid = NULL;
            }

            // Add local administrators to the combo box:

            for (i = 0; i < nameCount; ++i)
            {
                if ( groupInfo[i].lgrmi2_sidusage == SidTypeUser )
                {
                    DWORD ComboBoxIndex;
                    BOOLEAN IsAdminAccount;
                    BOOLEAN RememberComboBoxIndex;


                    //
                    // If this is Personal and not safe mode,
                    //  Ignore the well-known Administrator account.
                    //

                    IsAdminAccount = (adminSid != NULL) &&
                                     EqualSid(adminSid, groupInfo[i].lgrmi2_sid);

                    if ( CreduiIsPersonal &&
                                !CreduiIsSafeMode &&
                                IsAdminAccount ) {

                            continue;
                    }

                    //
                    // If the caller wants to prepopulate the edit box,
                    //  flag that we need to remember this account
                    //
                    // Detect the well known admin account
                    //

                    RememberComboBoxIndex = FALSE;

                    if ( (Style & CRS_PREFILLADMIN) != 0 &&
                         IsAdminAccount ) {

                        RememberComboBoxIndex = TRUE;

                    }

                    //
                    // Add the name to the combo box
                    //

                    ComboBoxIndex =  UserNameComboBox.Add(
                            TrimUsername( AccountDomainName, groupInfo[i].lgrmi2_domainandname),
                            0,
                            IsAutoComplete,
                            TRUE);

                    if ( ComboBoxIndex == -1 ) {
                        break;
                    }

                    //
                    // If we're to remember the index,
                    //  do so.
                    //

                    if ( RememberComboBoxIndex ) {

                        UserNameSelection = ComboBoxIndex;

                        IsChangingUserName = TRUE;
                        SendMessage(UserNameControlWindow,
                                    CB_SETCURSEL,
                                    ComboBoxIndex,
                                    0);
                        IsChangingUserName = FALSE;
                    }
                }

            }

            delete [] adminSid;
            NetApiBufferFree(groupInfo);
        }
    }

    if ( AccountDomainName != NULL ) {
        NetApiBufferFree( AccountDomainName );
    }

    return TRUE;
}

//=============================================================================
// CreduiCredentialControl::InitWindow
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::InitWindow()
{
    // Set that we're intialized here, even though the controls have not yet
    // been created, etc.:

    IsInitialized = TRUE;

    // Make sure WS_EX_CONTROLPARENT is set:

    SetWindowLong(Window,
                  GWL_EXSTYLE,
                  GetWindowLong(Window, GWL_EXSTYLE) |
                      WS_EX_CONTROLPARENT);

    // Initialize the balloon tip for this window:

    if (!CreateControls() ||
        !BalloonTip.Init(CreduiInstance, Window))
    {
        return FALSE;
    }

    // Limit the number of characters entered into the user name and password
    // edit controls:

    SendMessage(UserNameControlWindow,
                CB_LIMITTEXT,
                CREDUI_MAX_USERNAME_LENGTH,
                0);

    SendMessage(PasswordControlWindow,
                EM_LIMITTEXT,
                CREDUI_MAX_PASSWORD_LENGTH,
                0);

    // Set the password character to something cooler:

    PasswordBox.Init(PasswordControlWindow,
                     &BalloonTip,
                     &CreduiCapsLockTipInfo);

    // Initialize the user name auto complete combo box:

    if ( !KeepUserName )
    {
        if (((Style & CRS_USERNAMES) && InitComboBoxUserNames()) ||
            UserNameComboBox.Init(CreduiInstance,
                                  UserNameControlWindow,
                                  0,
                                  IDB_TYPES,
                                  IMAGE_USERNAME))
        {
            // Since we're finished adding auto complete names, enable it now.
            // On failure, the UI can still be presented:

            UserNameComboBox.Enable();

            BOOL haveCertificates = FALSE;

            CertBaseInComboBox = (ULONG)
                SendMessage(UserNameControlWindow,
                            CB_GETCOUNT, 0, 0);

            if (Style & CRS_CERTIFICATES)
            {
                haveCertificates = AddCertificates();
            }

            SmartCardBaseInComboBox = CertBaseInComboBox + CertCount;

            if ((Style & CRS_SMARTCARDS) && CreduiHasSmartCardSupport)
            {
    #ifdef SCARDREPORTS
                CreduiDebugLog("CREDUI: Call to SCardUIInit for %0x\n",Window);
    #endif
                ScardUiHandle = SCardUIInit(Window);

                if (ScardUiHandle == NULL)
                {
    #ifdef SCARDREPORTS
                    CreduiDebugLog("CREDUI: Call to SCardUIInit failed\n");
    #endif
                    CreduiDebugLog("CreduiCredentialControl::InitWindow: "
                                   "SCardUIInit failed\n");
                }
            }

            // If NoEditUserName is allowed, make sure we eithet have at least one certificate
            // or a prefilled username for the control, otherwise fail

            if (NoEditUserName )
            {
                if (!haveCertificates &&
                    (ScardUiHandle == NULL))
                {
                    return FALSE;
                }

                IsChangingUserName = TRUE;
                SendMessage(UserNameControlWindow,
                            CB_SETCURSEL,
                            0,
                            0);
                IsChangingUserName = FALSE;

                // If we have at least one certificate, enable the view control
                // now. If a smart card, it will be enabled later:

                if (CertCount > 0)
                {
                    EnableWindow(ViewCertControlWindow, TRUE);
                    DisabledControlMask &= ~DISABLED_CONTROL_VIEW;
                }
            }

            // Wait until everything has been initialized before
            // we have the update.  This will now properly determine if the default
            // user name is a smart card or not.
            OnUserNameSelectionChange();
        }
        else
        {
            return FALSE;
        }
    }

    if ( !DoingCommandLine ) {
        SetFocus(UserNameControlWindow);
    }

    return TRUE;
}

//=============================================================================
// CredioCredentialControl::Enable
//
// Enables or disables all the user controls in the control.
//
// Arguments:
//   enable (in) - TRUE to enable the controls, FALSE to disable.
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiCredentialControl::Enable(
    BOOL enable
    )
{
    if (enable && (DisabledControlMask & DISABLED_CONTROL))
    {
        DisabledControlMask &= ~DISABLED_CONTROL;

        //EnableWindow(UserNameStaticWindow, TRUE);
        //EnableWindow(UserNameControlWindow, TRUE);

        if (!(DisabledControlMask & DISABLED_CONTROL_USERNAME))
        {
            EnableWindow(UserNameControlWindow, TRUE);
            EnableWindow(UserNameStaticWindow, TRUE);
        }
        
        if (!(DisabledControlMask & DISABLED_CONTROL_PASSWORD))
        {
            EnableWindow(PasswordControlWindow, TRUE);
            EnableWindow(PasswordStaticWindow, TRUE);
        }
        if (!(DisabledControlMask & DISABLED_CONTROL_VIEW))
        {
            EnableWindow(ViewCertControlWindow, TRUE);
        }
        if (SaveControlWindow != NULL)
        {
            if (!(DisabledControlMask & DISABLED_CONTROL_SAVE))
            {
                EnableWindow(SaveControlWindow, TRUE);
            }
        }

        IsChangingUserName = TRUE;
        SendMessage(UserNameControlWindow,
                    CB_SETCURSEL,
                    UserNameSelection,
                    0);
        IsChangingUserName = FALSE;

        OnUserNameSelectionChange();
    }
    else if (!(DisabledControlMask & DISABLED_CONTROL))
    {
        // Hide the balloon tip before disabling the window:

        if (BalloonTip.IsVisible())
        {
            BalloonTip.Hide();
        }

        DisabledControlMask |= DISABLED_CONTROL;

        UserNameSelection = (LONG) SendMessage(UserNameControlWindow,
                                               CB_GETCURSEL, 0, 0);

        EnableWindow(UserNameStaticWindow, FALSE);
        EnableWindow(UserNameControlWindow, FALSE);
        EnableWindow(ViewCertControlWindow, FALSE);

        EnableWindow(PasswordControlWindow, FALSE);
        SetFocus(UserNameControlWindow);
        EnableWindow(PasswordStaticWindow, FALSE);

        if (SaveControlWindow != NULL)
        {
            EnableWindow(SaveControlWindow, FALSE);
        }
    }
}

//=============================================================================
// CreduiCredentialControl::MessageHandlerCallback
//
// This is the actual callback function for the control window.
//
// Arguments:
//   window (in)
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

LRESULT
CALLBACK
CreduiCredentialControl::MessageHandlerCallback(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // CreduiDebugLog( "Control Callback: %8.8lx %8.8lx %8.8lx\n", message, wParam, lParam );
    CreduiCredentialControl *that =
        reinterpret_cast<CreduiCredentialControl *>(
            GetWindowLongPtr(window, 0));

    if (that != NULL)
    {
        LRESULT result2;
        ASSERT(window == that->Window);
        // CreduiDebugLog( "Certhashes: %8.8lx %8.8lx\n", that, that->CertHashes );

        result2 = that->MessageHandler(message, wParam, lParam);

        // CreduiDebugLog( "Certhashes2: %8.8lx %8.8lx\n", that, that->CertHashes );
        return result2;
    }

    if (message == WM_CREATE)
    {
        CreduiCredentialControl *control = new CreduiCredentialControl;

        if (control != NULL)
        {
            // Initialize some state:

            control->FirstPaint = TRUE;
            control->ShowBalloonTip = FALSE;

            control->Window = window;
            control->Style = GetWindowLong(window, GWL_STYLE);

            // Store this object's pointer in the user data window long:

            SetLastError(0);
            LONG_PTR retPtr = SetWindowLongPtr(window,
                                            0,
                                            reinterpret_cast<LONG_PTR>(control));

            if ( retPtr != 0  || GetLastError() == 0 )
            {
                // we sucessfully set the window pointer

                // If any of the required styles are set, initialize the window
                // now. Otherwise, defer until CRM_INITSTYLE:

                if (control->Style & (CRS_USERNAMES |
                                      CRS_CERTIFICATES |
                                      CRS_SMARTCARDS))
                {
                    if (control->InitWindow())
                    {
                        return TRUE;
                    }
                }
                else
                {
                    return TRUE;
                }
            }

            SetWindowLongPtr(window, 0, 0);

            delete control;
            control = NULL;
        }

        DestroyWindow(window);
        return 0;
    }

    return DefWindowProc(window, message, wParam, lParam);
}

//=============================================================================
// CreduiCredentialControl::OnSetUserNameA
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnSetUserNameA(
    CHAR *userNameA
    )
{
    BOOL success = FALSE;

    if (userNameA != NULL)
    {
        INT bufferSize =
            MultiByteToWideChar(CP_ACP, 0, userNameA, -1, NULL, 0);

        if (bufferSize != 0)
        {
            WCHAR *userName = new WCHAR[bufferSize];

            if (userName != NULL)
            {
                if (MultiByteToWideChar(CP_ACP,
                                        0,
                                        userNameA,
                                        -1,
                                        userName,
                                        bufferSize) > 0)
                {
                    success = OnSetUserName(userName);
                }

                delete [] userName;
            }
        }
    }
    else
    {
        success = OnSetUserName(NULL);
    }

    return success;
};

//=============================================================================
// CreduiCredentialControl::OnSetUserName
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnSetUserName(
    WCHAR *userName
    )
{
    if ((userName == NULL) ||
        (!LocalCredIsMarshaledCredentialW(userName)))
    {

        if ( DoingCommandLine ) 
        {
            // Save the initial user name for command line
            
            if (userName == NULL)
            {
                InitialUserName = NULL;
            }
            else
            {
                int bufferLength = wcslen(userName) + 1;
                InitialUserName = new WCHAR[bufferLength];

                if ( InitialUserName == NULL ) 
                {
                    // error return on failure to allocate
                    return FALSE;
                }
                StringCchCopyW(InitialUserName, bufferLength, userName);
            }
        }
        
        return SetWindowText(UserNameControlWindow, userName);
    }
    else
    {
        CRED_MARSHAL_TYPE credMarshalType;
        CERT_CREDENTIAL_INFO *certCredInfo = NULL;
        BOOL foundCert = FALSE;

        if (LocalCredUnmarshalCredentialW(
                userName,
                &credMarshalType,
                reinterpret_cast<VOID **>(&certCredInfo)))
        {
            // Search for the certificate. What can we do if it is a
            // smart card? Well, at least we can still search for it,
            // but it is a bit more work because we must retrieve the
            // hash from the context.

            if (credMarshalType == CertCredential)
            {
                for (UINT i = 0; i < CertCount; ++i)
                {
                    if (RtlCompareMemory(CertHashes[i],
                                         certCredInfo->rgbHashOfCert,
                                         CERT_HASH_LENGTH) ==
                                         CERT_HASH_LENGTH)
                    {
                        IsChangingUserName = TRUE;
                        SendMessage(UserNameControlWindow,
                                    CB_SETCURSEL,
                                    CertBaseInComboBox + i,
                                    0);
                        IsChangingUserName = FALSE;

                        OnUserNameSelectionChange();

                        EnableWindow(ViewCertControlWindow, TRUE);
                        DisabledControlMask &= ~DISABLED_CONTROL_VIEW;

                        foundCert = TRUE;
                        break;
                    }
                }

                // If we couldn't find the certificate in our list, determine
                // if this is a smart card certificate, based on its entry in
                // the MY certificate store. If it is, store the hash and
                // check for it on certificate arrival messages:

                if (!foundCert)
                {
                    CONST CERT_CONTEXT *certContext = NULL;
                    HCERTSTORE certStore = NULL;

                    certStore = CertOpenSystemStore(NULL, L"MY");

                    if (certStore != NULL)
                    {
                        CRYPT_HASH_BLOB hashBlob;

                        hashBlob.cbData = CERT_HASH_LENGTH;
                        hashBlob.pbData = reinterpret_cast<BYTE *>(
                            certCredInfo->rgbHashOfCert);

                        certContext = CertFindCertificateInStore(
                                          certStore,
                                          X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                          0,
                                          CERT_FIND_SHA1_HASH,
                                          &hashBlob,
                                          NULL);
                    }

                    // If we found a certificate context, check to see if it
                    // is from a smart card:

                    if ((certContext != NULL) &&
                        CreduiIsRemovableCertificate(certContext))
                    {
                        UserNameCertHash = new UCHAR [1][CERT_HASH_LENGTH];

                        if (UserNameCertHash != NULL)
                        {
                            CopyMemory(UserNameCertHash,
                                       certCredInfo->rgbHashOfCert,
                                       CERT_HASH_LENGTH);

                            foundCert = TRUE;
                        }
                    }

                    // If we opened a store, free the certificate and close
                    // the store:

                    if (certStore != NULL)
                    {
                        if (certContext != NULL)
                        {
                            CertFreeCertificateContext(certContext);
                        }

                        if (!CertCloseStore(certStore, 0))
                        {
                            CreduiDebugLog(
                                "CreduiCredentialControl::OnSetUserName: "
                                "CertCloseStore failed: %u\n",
                                GetLastError());
                        }
                    }
                }
            }

            LocalCredFree(static_cast<VOID *>(certCredInfo));
        }
        else
        {
            // Could not unmarshal, so just forget it:

            CreduiDebugLog(
                "CreduiCredentialControl::OnSetUserName: "
                "CredUnmarshalCredential failed: %u\n",
                GetLastError());
        }

        return foundCert;
    }
};

//=============================================================================
// CreduiCredentialControl::OnGetUserNameA
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnGetUserNameA(
    CHAR *userNameA,
    ULONG maxChars
    )
{
    BOOL success = FALSE;

    if ((userNameA != NULL) && (maxChars != 0))
    {
        WCHAR *userName = new WCHAR[maxChars + 1];

        if (userName != NULL)
        {
            if (OnGetUserName(userName, maxChars) &&
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    userName,
                    -1,
                    userNameA,
                    maxChars + 1, NULL, NULL))
            {
                success = TRUE;
            }

            delete [] userName;
        }
    }

    return success;
};

//=============================================================================
// CreduiCredentialControl::OnGetUserName
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnGetUserName(
    WCHAR *userName,
    ULONG maxChars
    )
{
    if (  KeepUserName )
    {
        SetLastError(0);

        return (GetWindowText(UserNameControlWindow,
                              userName,
                              maxChars + 1) > 0) ||
               (GetLastError() == ERROR_SUCCESS);
    }
    else
    {
        COMBOBOXEXITEM item;

        item.iItem = SendMessage(UserNameControlWindow, CB_GETCURSEL, 0, 0);

        // If we are trying to match a smart card certificate, fail this:

        if (UserNameCertHash != NULL)
        {
            return FALSE;
        }

        // If this is not a certificate, it's easy:

        if ((item.iItem == CB_ERR) || (item.iItem < CertBaseInComboBox))
        {
            BOOL RetVal;
            SetLastError(0);

            RetVal = GetWindowText(UserNameControlWindow,
                                   userName,
                                   maxChars + 1) > 0;

            if ( !RetVal ) {
                return ( GetLastError() == ERROR_SUCCESS );
            }

            //
            // Complete the typed in username

            if ( Style & CRS_COMPLETEUSERNAME) {

                RetVal = CompleteUserName(
                                     userName,
                                     maxChars,
                                     NULL,      // No target info
                                     NULL,
                                     0);        // No target name

            } else {

                RetVal = TRUE;
            }

            return RetVal;
        }

        // This is a certificate, maybe from a smart card:

        item.mask = CBEIF_IMAGE | CBEIF_TEXT;
        item.pszText = userName;
        item.cchTextMax = maxChars + 1;

        if (!SendMessage(UserNameControlWindow,
                         CBEM_GETITEM,
                         0,
                         reinterpret_cast<LPARAM>(&item)))
        {
            return FALSE;
        }

        CERT_CREDENTIAL_INFO certCredInfo;

        certCredInfo.cbSize = sizeof certCredInfo;

        if (item.iItem >= SmartCardBaseInComboBox)
        {
            if (item.iImage == IMAGE_SMART_CARD_MISSING)
            {
                return FALSE;
            }

            CERT_ENUM *certEnum =
                reinterpret_cast<CERT_ENUM *>(
                    SendMessage(UserNameControlWindow,
                                CB_GETITEMDATA, item.iItem, 0));

            // NOTE: Consider more complete error handling here.

            if (certEnum != NULL)
            {
                DWORD length = CERT_HASH_LENGTH;

                if (!CertGetCertificateContextProperty(
                        certEnum->pCertContext,
                        CERT_SHA1_HASH_PROP_ID,
                        static_cast<VOID *>(
                            certCredInfo.rgbHashOfCert),
                        &length))
                {
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            CopyMemory(certCredInfo.rgbHashOfCert,
                       &CertHashes[item.iItem - CertBaseInComboBox],
                       CERT_HASH_LENGTH);
        }

        WCHAR *marshaledCred;

        if (LocalCredMarshalCredentialW(
                CertCredential,
                &certCredInfo,
                &marshaledCred))
        {
            StringCchCopyW(userName, maxChars + 1, marshaledCred);

            LocalCredFree(static_cast<VOID *>(marshaledCred));

            return TRUE;
        }
        else
        {
            CreduiDebugLog("CreduiCredentialControl::OnGetUserName: "
                           "CredMarshalCredential failed: %u\n",
                           GetLastError());

            return FALSE;
        }
    }
}

//=============================================================================
// CreduiCredentialControl::OnSetPasswordA
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnSetPasswordA(
    CHAR *passwordA
    )
{
    return SetWindowTextA(PasswordControlWindow, passwordA);
};

//=============================================================================
// CreduiCredentialControl::OnSetPassword
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnSetPassword(
    WCHAR *password
    )
{
    return SetWindowText(PasswordControlWindow, password);
};

//=============================================================================
// CreduiCredentialControl::OnGetPasswordA
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnGetPasswordA(
    CHAR *passwordA,
    ULONG maxChars
    )
{
    if (DisabledControlMask & DISABLED_CONTROL_PASSWORD)
    {
        return FALSE;
    }

    SetLastError(0);

    return (GetWindowTextA(PasswordControlWindow,
                           passwordA,
                           maxChars + 1) > 0) ||
           (GetLastError() == ERROR_SUCCESS);
};

//=============================================================================
// CreduiCredentialControl::OnGetPassword
//
// Created 06/22/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnGetPassword(
    WCHAR *password,
    ULONG maxChars
    )
{
    if (DisabledControlMask & DISABLED_CONTROL_PASSWORD)
    {
        return FALSE;
    }

    SetLastError(0);

    return ((GetWindowText(PasswordControlWindow,
                  password,
                  maxChars + 1) > 0) ||
                 (GetLastError() == ERROR_SUCCESS)
               );
};

//=============================================================================
// CreduiCredentialControl::OnGetUserNameLength
//
// Created 07/19/2000 johnstep (John Stephens)
//=============================================================================

LONG
CreduiCredentialControl::OnGetUserNameLength()
{
    COMBOBOXEXITEM item;

    if (UserNameCertHash != NULL)
    {
        return -1;
    }

    item.iItem = SendMessage(UserNameControlWindow, CB_GETCURSEL, 0, 0);

    // If this is not a certificate, it's easy:

    if ((item.iItem == CB_ERR) || (item.iItem < CertBaseInComboBox))
    {
        return GetWindowTextLength(UserNameControlWindow);
    }
    else
    {
        WCHAR userName[CREDUI_MAX_USERNAME_LENGTH + 1];

        if (OnGetUserName(userName, CREDUI_MAX_USERNAME_LENGTH))
        {
            return wcslen(userName);
        }
        else
        {
            return -1;
        }
    }
}

//=============================================================================
// CreduiCredentialControl::OnShowBalloonA
//
// Created 06/23/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnShowBalloonA(
    CREDUI_BALLOONA *balloonA
    )
{
    // If NULL was passed, this means to hide the balloon:

    if (balloonA == NULL)
    {
        if (BalloonTip.IsVisible())
        {
            BalloonTip.Hide();
        }
        return TRUE;
    }

    // Argument validation, should match OnShowBalloon:

    if ((balloonA->dwVersion != 1) ||
        (balloonA->pszTitleText == NULL) ||
        (balloonA->pszMessageText == NULL))
    {
        return FALSE;
    }

    if ((balloonA->pszTitleText[0] == '\0') ||
        (balloonA->pszMessageText[0] == '\0'))
    {
        return FALSE;
    }

    BOOL success = FALSE;

    CREDUI_BALLOON balloon;

    balloon.dwVersion = balloonA->dwVersion;
    balloon.iControl = balloonA->iControl;
    balloon.iIcon = balloonA->iIcon;

    INT titleTextSize =
        MultiByteToWideChar(CP_ACP,
                            0,
                            balloonA->pszTitleText,
                            -1,
                            NULL,
                            0);

    INT messageTextSize =
        MultiByteToWideChar(CP_ACP,
                            0,
                            balloonA->pszMessageText,
                            -1,
                            NULL,
                            0);

    if ((titleTextSize != 0) && (messageTextSize != 0))
    {
        balloon.pszTitleText = new WCHAR[titleTextSize];

        if (balloon.pszTitleText != NULL)
        {
            if (MultiByteToWideChar(CP_ACP,
                                    0,
                                    balloonA->pszTitleText,
                                    -1,
                                    balloon.pszTitleText,
                                    titleTextSize) > 0)
            {
                balloon.pszMessageText = new WCHAR[messageTextSize];

                if (balloon.pszMessageText != NULL)
                {
                    if (MultiByteToWideChar(CP_ACP,
                                            0,
                                            balloonA->pszMessageText,
                                            -1,
                                            balloon.pszMessageText,
                                            messageTextSize) > 0)
                    {
                        success = OnShowBalloon(&balloon);
                    }

                    delete [] balloon.pszMessageText;
                }
            }

            delete [] balloon.pszTitleText;
        }
    }

    return success;
};

//=============================================================================
// CreduiCredentialControl::OnShowBalloon
//
// Created 06/23/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiCredentialControl::OnShowBalloon(
    CREDUI_BALLOON *balloon
    )
{
    // If NULL was passed, this means to hide the balloon:

    if (balloon == NULL)
    {
        if (BalloonTip.IsVisible())
        {
            BalloonTip.Hide();
        }
        return TRUE;
    }

    // Argument validation:

    if ((balloon->dwVersion != 1) ||
        (balloon->pszTitleText == NULL) ||
        (balloon->pszMessageText == NULL))
    {
        return FALSE;
    }

    if ((balloon->pszTitleText[0] == L'\0') ||
        (balloon->pszMessageText[0] == L'\0'))
    {
        return FALSE;
    }

    StringCchCopyW(
        CreduiCustomTipInfo.Title,
        RTL_NUMBER_OF(CreduiCustomTipTitle),
        balloon->pszTitleText);

    StringCchCopyW(
        CreduiCustomTipInfo.Text,
        RTL_NUMBER_OF(CreduiCustomTipMessage),
        balloon->pszMessageText);

    CreduiCustomTipInfo.Icon = balloon->iIcon;

    BalloonTip.SetInfo(
        (balloon->iControl == CREDUI_CONTROL_PASSWORD) ?
            PasswordControlWindow : UserNameControlWindow,
        &CreduiCustomTipInfo);

    BalloonTip.Show();

    return TRUE;
};

//=============================================================================
// CreduiCredentialControl::OnUserNameSelectionChange
//
// Created 06/21/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiCredentialControl::OnUserNameSelectionChange()
{
    COMBOBOXEXITEM item;
    LRESULT current;

    // Delete the user name certificate hash if the user has changed the
    // selection:

    delete [] UserNameCertHash;
    UserNameCertHash = NULL;

    current = SendMessage(UserNameControlWindow,
                          CB_GETCURSEL, 0, 0);

    item.mask = CBEIF_IMAGE;
    item.iItem = current;

    SendMessage(UserNameControlWindow, CBEM_GETITEM,
                0, reinterpret_cast<LPARAM>(&item));

    if (current < CertBaseInComboBox)
    {
        EnableWindow(ViewCertControlWindow, FALSE);
        DisabledControlMask |= DISABLED_CONTROL_VIEW;

        SetWindowText(
            PasswordStaticWindow,
            CreduiStrings.PasswordStatic);

        EnableWindow(PasswordControlWindow, TRUE);
        EnableWindow(PasswordStaticWindow, TRUE);
        DisabledControlMask &= ~DISABLED_CONTROL_PASSWORD;

        WCHAR* pUserNameLabel;
        if ( IsPassport )
            pUserNameLabel = CreduiStrings.EmailName;
        else
            pUserNameLabel = CreduiStrings.UserNameStatic;

        SetWindowText(
            UserNameStaticWindow,
            pUserNameLabel);

        if (SaveControlWindow != NULL)
        {
            EnableWindow(SaveControlWindow, TRUE);
            DisabledControlMask &= ~DISABLED_CONTROL_SAVE;
        }
    }
    else
    {
        SetWindowText(
            PasswordStaticWindow,
            CreduiStrings.PinStatic);

        if (item.iImage != IMAGE_SMART_CARD_MISSING)
        {
            EnableWindow(ViewCertControlWindow, TRUE);
            DisabledControlMask &= ~DISABLED_CONTROL_VIEW;
        }
        else
        {
            EnableWindow(ViewCertControlWindow, FALSE);
            DisabledControlMask |= DISABLED_CONTROL_VIEW;
        }
#if 0
        // set password control empty on cert name change now only occurs
        // if user selects different dropdown item (or types new)
        IsChangingPassword = TRUE;
        SetWindowText(PasswordControlWindow, NULL);
        IsChangingPassword = FALSE;
#endif
        if (current >= SmartCardBaseInComboBox)
        {
            EnableWindow(PasswordControlWindow, TRUE);
            EnableWindow(PasswordStaticWindow, TRUE);
            DisabledControlMask &= ~DISABLED_CONTROL_PASSWORD;
        }
        else
        {
            EnableWindow(PasswordControlWindow, FALSE);
            EnableWindow(PasswordStaticWindow, FALSE);
            DisabledControlMask |= DISABLED_CONTROL_PASSWORD;
        }

        SetWindowText(
            UserNameStaticWindow,
            item.iImage >= IMAGE_SMART_CARD ?
                CreduiStrings.SmartCardStatic :
                CreduiStrings.CertificateStatic);
#if 0
        if (SaveControlWindow != NULL)
        {
            EnableWindow(SaveControlWindow, FALSE);
            DisabledControlMask |= DISABLED_CONTROL_SAVE;
        }
#endif
    }
}

//=============================================================================
// CreduiCredentialControl::MessageHandler
//
// Called from the control window callback to handle the window messages.
//
// Arguments:
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Created 06/20/2000 johnstep (John Stephens)
//=============================================================================

LRESULT
CreduiCredentialControl::MessageHandler(
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // Handle WM_NCDESTROY whether initialized or not:

    if (message == WM_NCDESTROY)
    {
        delete this;
        return 0;
    }

    // If not initialized, only handle CRM_INITSTYLE:

    if (!IsInitialized)
    {
        if (message == CRM_INITSTYLE)
        {
            wParam &= CRS_USERNAMES |
                      CRS_CERTIFICATES |
                      CRS_SMARTCARDS |
                      CRS_ADMINISTRATORS |
                      CRS_PREFILLADMIN |
                      CRS_COMPLETEUSERNAME |
                      CRS_SAVECHECK |
                      CRS_KEEPUSERNAME;

            if (wParam != 0)
            {
                Style |= wParam;

                SetWindowLong(Window,
                              GWL_STYLE,
                              GetWindowLong(Window, GWL_STYLE) | Style);

                DoingCommandLine = (BOOL) lParam;

                return InitWindow();
            }

            return FALSE;
        }
        else
        {
            return DefWindowProc(Window, message, wParam, lParam);
        }
    }
    else if (message == WM_ENABLE)
    {
        Enable((BOOL) wParam);
    }

    // Always handle smart card messages, if support is available:

    if (ScardUiHandle != NULL)
    {
        // This function call will return TRUE if the message was handled:

        if (HandleSmartCardMessages(
                message,
                reinterpret_cast<CERT_ENUM *>(wParam)))
        {
            return 0;
        }
    }

    switch (message)
    {
    case CRM_SETUSERNAMEMAX:
        SendMessage(UserNameControlWindow, CB_LIMITTEXT, wParam, 0);
        return TRUE;

    case CRM_SETPASSWORDMAX:
        SendMessage(PasswordControlWindow, EM_LIMITTEXT, wParam, 0);
        return TRUE;
        
    case CRM_DISABLEUSERNAME:
        {
            DisabledControlMask |= DISABLED_CONTROL_USERNAME;
            EnableWindow(UserNameControlWindow,FALSE);
            EnableWindow(UserNameStaticWindow,FALSE);
            return TRUE;
        }
    case CRM_ENABLEUSERNAME:
        {
            DisabledControlMask &= ~DISABLED_CONTROL_USERNAME;
            EnableWindow(UserNameControlWindow,TRUE);
            EnableWindow(UserNameStaticWindow,TRUE);
            return TRUE;
        }
    
    case CRM_GETUSERNAMEMAX:
        return
            SendMessage(
                reinterpret_cast<HWND>(
                    SendMessage(Window, CBEM_GETEDITCONTROL, 0, 0)),
                 EM_GETLIMITTEXT,
                 0,
                 0);

    case CRM_GETPASSWORDMAX:
        return SendMessage(UserNameControlWindow, EM_GETLIMITTEXT, 0, 0);

    case CRM_SETUSERNAMEA:
        return OnSetUserNameA(reinterpret_cast<CHAR *>(lParam));
    case CRM_SETUSERNAMEW:
        return OnSetUserName(reinterpret_cast<WCHAR *>(lParam));

    case CRM_GETUSERNAMEA:
        return OnGetUserNameA(reinterpret_cast<CHAR *>(lParam), (ULONG) wParam);
    case CRM_GETUSERNAMEW:
        return OnGetUserName(reinterpret_cast<WCHAR *>(lParam), (ULONG) wParam);

    case CRM_SETPASSWORDA:
        return OnSetPasswordA(reinterpret_cast<CHAR *>(lParam));
    case CRM_SETPASSWORDW:
        return OnSetPassword(reinterpret_cast<WCHAR *>(lParam));

    case CRM_GETPASSWORDA:
        return OnGetPasswordA(reinterpret_cast<CHAR *>(lParam), (ULONG) wParam);
    case CRM_GETPASSWORDW:
        return OnGetPassword(reinterpret_cast<WCHAR *>(lParam), (ULONG) wParam);

    case CRM_GETUSERNAMELENGTH:
        return OnGetUserNameLength();

    case CRM_GETPASSWORDLENGTH:
        if (IsWindowEnabled(PasswordControlWindow))
        {
            return GetWindowTextLength(PasswordControlWindow);
        }
        return -1;

    case CRM_SETFOCUS:
        if ( DoingCommandLine ) {
            return 0;
        }
        switch (wParam)
        {
        case CREDUI_CONTROL_USERNAME:
            SetFocus(UserNameControlWindow);
            return TRUE;

        case CREDUI_CONTROL_PASSWORD:
            if (IsWindowEnabled(PasswordControlWindow))
            {
                SetFocus(PasswordControlWindow);

                // NOTE: Is it OK to always select the entire password text
                //       on this explicit set focus message?

                SendMessage(PasswordControlWindow, EM_SETSEL, 0, -1);
                return TRUE;
            }
            break;
        }
        return 0;

    case CRM_SHOWBALLOONA:
        return OnShowBalloonA(reinterpret_cast<CREDUI_BALLOONA *>(lParam));
    case CRM_SHOWBALLOONW:
        return OnShowBalloon(reinterpret_cast<CREDUI_BALLOON *>(lParam));

    case CRM_GETMINSIZE:
        SIZE *minSize;

        minSize = reinterpret_cast<SIZE *>(lParam);

        if (minSize != NULL)
        {
            minSize->cx = CREDUI_CONTROL_MIN_WIDTH;
            minSize->cy = CREDUI_CONTROL_MIN_HEIGHT;

            if (Style & CRS_SAVECHECK )
            {
                minSize->cy += CREDUI_CONTROL_ADD_SAVE;
            }

            return TRUE;
        }

        return FALSE;

    case CRM_SETCHECK:
        switch (wParam)
        {
        case CREDUI_CONTROL_SAVE:
            if ((Style & CRS_SAVECHECK ) &&
                IsWindowEnabled(SaveControlWindow))
            {
                CheckDlgButton(Window, IDC_SAVE,
                               lParam ? BST_CHECKED : BST_UNCHECKED);

                return TRUE;
            }
            break;
        }
        return FALSE;

    case CRM_GETCHECK:
        switch (wParam)
        {
        case CREDUI_CONTROL_SAVE:
            return
                (Style & CRS_SAVECHECK ) &&
                IsWindowEnabled(SaveControlWindow) &&
                IsDlgButtonChecked(Window, IDC_SAVE);

        default:
            return FALSE;
        }

    case CRM_DOCMDLINE:
        ASSERT( DoingCommandLine );

        //
        // For smartcards,
        //  just start the timer and we'll prompt when the timer has gone off.
        //

        TargetName = (LPWSTR)lParam;
        if ( Style & CRS_SMARTCARDS) {
            DWORD WinStatus;

            Heartbeats = 0;
            {
                WCHAR szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];
                szMsg[0] = 0;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            CreduiInstance,
                            IDS_READING_SMARTCARDS,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            NULL);
                CredPutStdout(szMsg);
            }

            if ( SetTimer ( Window, CREDUI_HEARTBEAT_TIMER, CREDUI_HEARTBEAT_TIMER_VALUE, NULL ) == 0 ) {
                // bail out of our wait loop if we couldn't set a timer
                return GetLastError();
            }

        //
        // For passwords,
        //  just do the prompt to save.
        //

        } else {

            CmdlineSavePrompt();
            PostQuitMessage( NO_ERROR );
        }

        return NO_ERROR;

    case WM_HELP:
        return OnHelpInfo(lParam);

    case WM_SETFONT:
        // Forward font setting from dialog to each control, except the
        // password control since we use a special font there:

        if (UserNameStaticWindow != NULL)
        {
            SendMessage(UserNameStaticWindow, message, wParam, lParam);
        }

        if (UserNameControlWindow != NULL)
        {
            SendMessage(UserNameControlWindow, message, wParam, lParam);
        }

        if (ViewCertControlWindow != NULL)
        {
            SendMessage(ViewCertControlWindow, message, wParam, lParam);
        }

        if (PasswordStaticWindow != NULL)
        {
            SendMessage(PasswordStaticWindow, message, wParam, lParam);
        }

        if (PasswordControlWindow != NULL)
        {
            SendMessage(PasswordControlWindow, message, wParam, lParam);
        }

        if (SaveControlWindow != NULL)
        {
            SendMessage(SaveControlWindow, message, wParam, lParam);
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_VIEW_CERT:
            ViewCertificate((INT)
                SendMessage(UserNameControlWindow,
                            CB_GETCURSEL, 0, 0));
            return 0;

        case IDC_PASSWORD:
            if (HIWORD(wParam) == EN_CHANGE)
            {
                // Always send the change message?

                SendMessage(
                    GetParent(Window),
                    WM_COMMAND,
                    MAKELONG(GetWindowLongPtr(Window, GWLP_ID),
                             CRN_PASSWORDCHANGE),
                    reinterpret_cast<LPARAM>(Window));
            }
            return 0;

        case IDC_USERNAME:
            switch (HIWORD(wParam))
            {
            case CBN_EDITCHANGE:
            case CBN_DROPDOWN:
            case CBN_KILLFOCUS:
                if ((HIWORD(wParam) != CBN_EDITCHANGE) || !IsChangingUserName)
                {
                    if (BalloonTip.IsVisible())
                    {
                        BalloonTip.Hide();
                    }
                }

                if (HIWORD(wParam) == CBN_EDITCHANGE)
                {
                    // Always send the change message?

                    SendMessage(
                        GetParent(Window),
                        WM_COMMAND,
                        MAKELONG(GetWindowLongPtr(Window, GWLP_ID),
                                 CRN_USERNAMECHANGE),
                        reinterpret_cast<LPARAM>(Window));

                    // If the name has changed as a result of user editing,
                    // reset to user name settings:

                    BOOL isDropped = (BOOL)
                        SendMessage(UserNameControlWindow,
                                    CB_GETDROPPEDSTATE, 0, 0);

                    if (isDropped)
                    {
                        OnUserNameSelectionChange();

                        RECT rect;

                        GetClientRect(UserNameControlWindow, &rect);
                        InvalidateRect(UserNameControlWindow, &rect, FALSE);

                        
                        SendMessage(Window,
                                    CB_SETCURSEL,
                                    SendMessage(Window, CB_GETCURSEL, 0, 0),
                                    0);

                        return 0;
                    }

                    if (IsChangingUserName)
                    {
                        return 0;
                    }

                    // we are seeking a cert or have selected a reader, and the droplist is 
                    //  not dropped.
                    if (((UserNameCertHash != NULL) ||
                         (SendMessage(UserNameControlWindow,
                             CB_GETCURSEL, 0, 0) >= CertBaseInComboBox)) &&
                        !isDropped)
                    {
                        delete [] UserNameCertHash;
                        UserNameCertHash = NULL;

                        if (!SendMessage(UserNameControlWindow,
                                         CB_GETDROPPEDSTATE, 0, 0))
                        {
                            SetFocus(UserNameControlWindow);

                            if (SendMessage(UserNameControlWindow,
                                            CB_GETCURSEL, 0, 0) == CB_ERR)
                            {
                                // user is typing a new user name - clear the password
                                IsChangingUserName = TRUE;
                                UserNameComboBox.Update(
                                    -1,
                                    L"",
                                    IMAGE_USERNAME);
                                IsChangingUserName = FALSE;

                                IsChangingPassword = TRUE;
                                SetWindowText(PasswordControlWindow, NULL);
                                IsChangingPassword = FALSE;

                                OnUserNameSelectionChange();
                            }
                        }
                    }
                }

                if (HIWORD(wParam) == CBN_DROPDOWN)
                {
                    if (UserNameCertHash != NULL)
                    {
                        delete [] UserNameCertHash;
                        UserNameCertHash = NULL;

                        IsChangingUserName = TRUE;
                        UserNameComboBox.Update(
                            -1,
                            L"",
                            IMAGE_USERNAME);
                        IsChangingUserName = FALSE;

                        IsChangingPassword = TRUE;
                        SetWindowText(PasswordControlWindow, NULL);
                        IsChangingPassword = FALSE;

                        OnUserNameSelectionChange();
                    }
                }

                return 0;

            case CBN_SELCHANGE:

                // force password clear on any select of an item from the dropdown. 
                IsChangingPassword = TRUE;
                SetWindowText(PasswordControlWindow, NULL);
                IsChangingPassword = FALSE;
                
                OnUserNameSelectionChange();
                return 0;
                
            }
            break;

        case IDC_SAVE:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                return TRUE;
            }
            break;

        }
        break;

    case WM_PAINT:
        if (FirstPaint && GetUpdateRect(Window, NULL, FALSE))
        {
            FirstPaint = FALSE;

            if (ShowBalloonTip)
            {
                ShowBalloonTip = FALSE;
                BalloonTip.Show();
            }
        }
        break;

    case WM_TIMER:
        if ( wParam == CREDUI_HEARTBEAT_TIMER )
        {
            Heartbeats++;
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: thump thump\n",this->Window);
#endif

            //
            // If we've waited long enough,
            //  or all cards have been read,
            //  process the cards.
            //

            if ( Heartbeats > CREDUI_MAX_HEARTBEATS ||
                  ( Heartbeats > CREDUI_TIMEOUT_HEARTBEATS && SmartCardReadCount == 0 )) {
#ifdef SCARDREPORTS
        CreduiDebugLog("CREDUI: Heartbeat timeout\n",this->Window);
#endif

                fputs( "\n", stdout );
                KillTimer ( Window, CREDUI_HEARTBEAT_TIMER );
                CmdlineSmartCardPrompt();

            //
            // If we're going to wait longer,
            //  let the user know we're making progress.
            //
            } else {
                fputs( ".", stdout );
            }
        }

        break;

    case WM_DESTROY:
        if (PasswordControlWindow != NULL)
        {
            SetWindowText(PasswordControlWindow, NULL);
            DestroyWindow(PasswordControlWindow);
            PasswordControlWindow = NULL;
        }

        if (PasswordStaticWindow != NULL)
        {
            DestroyWindow(PasswordStaticWindow);
            PasswordStaticWindow = NULL;
        }

        if (ViewCertControlWindow != NULL)
        {
            DestroyWindow(ViewCertControlWindow);
            ViewCertControlWindow = NULL;
        }

        if (UserNameControlWindow != NULL)
        {
            DestroyWindow(UserNameControlWindow);
            UserNameControlWindow = NULL;
        }

        if (UserNameStaticWindow != NULL)
        {
            DestroyWindow(UserNameStaticWindow);
            UserNameStaticWindow = NULL;
        }

        if (ScardUiHandle != NULL)
        {
#ifdef SCARDREPORTS
            CreduiDebugLog("CREDUI: Call to SCardUIExit\n");
#endif
            SCardUIExit(ScardUiHandle);
            ScardUiHandle = NULL;
        }

        if (UserNameCertHash != NULL)
        {
            delete [] UserNameCertHash;
            UserNameCertHash = NULL;
        }

        if (CertCount > 0)
        {
            ASSERT(CertHashes != NULL);

            delete [] CertHashes;
            CertHashes = NULL;
            CertCount = 0;
        }

        delete InitialUserName;
        InitialUserName = NULL;

        // Only call CoUninitialize if we successfully initialized for STA:

        if (IsAutoComplete)
        {
            CoUninitialize();
        }

        return 0;
    }

    return DefWindowProc(Window, message, wParam, lParam);
}

BOOL CreduiCredentialControl::GetSmartCardInfo(
    IN DWORD SmartCardIndex,
    IN DWORD BufferLength,
    OUT LPWSTR Buffer,
    OUT BOOL *IsACard,
    OUT BOOL *IsValid,
    OUT CERT_ENUM **CertEnum OPTIONAL
    )
/*++

Routine Description:

    Routine to get the smart card info for a smart card in the combo box

Arguments:

    SmartCardIndex - Index of the smart card relative to SmartCardBaseInComboBox

    BufferLength - Specifies the length of Buffer (in characters)

    Buffer - Specifies the buffer to return the text for the smart card

    IsValid - Return TRUE if the smartcard is valid
        Returns FALSE otherwise

    CertEnum - If specified, returns the description of the cert on the smartcard
        This field is should be ignore if IsValid is returns false

Return Values:

    Returns TRUE if Buffer and IsValid are filled in.

--*/
{
    COMBOBOXEXITEM item;

    //
    // Get the item from the control
    //

    item.iItem = SmartCardBaseInComboBox + SmartCardIndex;
    item.mask = CBEIF_IMAGE | CBEIF_TEXT;
    item.pszText = Buffer;
    item.cchTextMax = BufferLength;

    if (!SendMessage(UserNameControlWindow,
                     CBEM_GETITEM,
                     0,
                     reinterpret_cast<LPARAM>(&item)))
    {
        return FALSE;
    }

    *IsValid = (item.iImage == IMAGE_SMART_CARD);
    *IsACard = (*IsValid || (item.iImage == IMAGE_SMART_CARD_EXPIRED));

    if ( CertEnum != NULL) {
        if ( *IsValid ) {

            *CertEnum = (CERT_ENUM *) SendMessage( UserNameControlWindow,
                                                   CB_GETITEMDATA, item.iItem, 0);

            // NOTE: Consider more complete error handling here.

            if ( *CertEnum == NULL) {
                return FALSE;
            }
        }
    }
    return TRUE;
}

LPWSTR CreduiCredentialControl::MatchSmartCard(
    IN DWORD SmartCardCount,
    IN LPWSTR UserName,
    OUT LPDWORD RetCertIndex,
    OUT CERT_ENUM **RetCertEnum
    )
/*++

Routine Description:

    Returns the smart card that matches UserName.

Arguments:

    SmartCardCount  - specifies the number of smart cards to search

    UserName - specifies the user name to match

    RetCertIndex - returns an index to the found smart card.

    RetCertEnum - returns the description of the cert on the smartcard

Return Values:

    Returns NULL if UserName matches one of the smart cards

    On failure, returns a printf-style format string describing the error

--*/
{
    WCHAR SmartCardText[CREDUI_MAX_USERNAME_LENGTH + 1];
    DWORD i;
    BOOL SmartCardValid;
    BOOL IsACard;
    CERT_ENUM *CertEnum;
    CERT_ENUM *SavedCertEnum = NULL;
    DWORD SavedCertIndex = 0;

    //
    // Loop through the list of smart cards seeing if we see a match
    //

    for ( i=0; i<SmartCardCount; i++ ) {

        if ( !GetSmartCardInfo( i, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &IsACard, &SmartCardValid, &CertEnum ) ) {
            //return CreduiStrings.NoUsernameMatch;
            return (LPWSTR) IDS_NO_USERNAME_MATCH;
        }

        if ( !SmartCardValid ) {
            continue;
        }

        //
        // If the username is marshaled,
        //  compare the marshaled strings.
        //

        if ( LocalCredIsMarshaledCredentialW( UserName ) ) {
            WCHAR szTestmarshall[CREDUI_MAX_USERNAME_LENGTH+1];
            // see if this is the marshalled cred
             if ( CredUIMarshallNode ( CertEnum, szTestmarshall ) )
             {
                 if ( wcscmp ( szTestmarshall, UserName) == 0 ) {
                     *RetCertEnum = CertEnum;
                     *RetCertIndex = i;
                     return NULL;
                 }
             }

        //
        // If the username is not marshalled,
        //  just match a substring of the name
        //

        }  else if ( LookForUserNameMatch ( UserName, SmartCardText ) ) {

            //
            // If we already found a match,
            //  complain about the ambiguity.
            //

            if ( SavedCertEnum != NULL ) {
                //return CreduiStrings.ManyUsernameMatch;
                return (LPWSTR) IDS_MANY_USERNAME_MATCH;
            }

            SavedCertEnum = CertEnum;
            SavedCertIndex = i;
        }

    }

    //
    // If we didn't find a match,
    //  fail
    //

    if ( SavedCertEnum == NULL) {
        //return CreduiStrings.NoUsernameMatch;
        return (LPWSTR) IDS_NO_USERNAME_MATCH;
    }

    *RetCertEnum = SavedCertEnum;
    *RetCertIndex = SavedCertIndex;
    return NULL;
}

void CreduiCredentialControl::CmdlineSmartCardPrompt()
/*++

Routine Description:

    Command line code to select a smartcard from the list of ones available.

    Post a WM_QUIT message to terminate message processing.  The status of the operation
    is returned in wParam.
    UserName and Password strings set in their respective controls.

Arguments:

    None

Return Values:

    None

--*/
{
    DWORD WinStatus;

    LONG ComboBoxItemCount;
    DWORD SmartCardCount;
    DWORD ValidSmartCardCount = 0;
    DWORD InvalidSmartCardCount = 0;
    DWORD KnownGoodCard = 0;

    DWORD i;
    DWORD_PTR rgarg[2];          // at most 2 substitution arguments

    WCHAR szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];
    WCHAR UserName[CREDUI_MAX_USERNAME_LENGTH + 1];
    WCHAR Password[CREDUI_MAX_PASSWORD_LENGTH + 1];

    WCHAR SmartCardText[CREDUI_MAX_USERNAME_LENGTH + 1];
    BOOL SmartCardValid;
    BOOL IsACard;

    CERT_ENUM *SavedCertEnum = NULL;
    DWORD SavedCertIndex = 0;
    LPWSTR ErrorString = NULL;

    //
    // Compute the number of smart card entries
    //

    ComboBoxItemCount = (LONG) SendMessage(UserNameControlWindow, CB_GETCOUNT, 0, 0);

    if ( ComboBoxItemCount == CB_ERR ||
         ComboBoxItemCount <= SmartCardBaseInComboBox ) {

        // Didn't find any smart card readers
        szMsg[0] = 0;
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    CreduiInstance,
                    IDS_NO_READERS_FOUND,
                    0,
                    szMsg,
                    CREDUI_MAX_CMDLINE_MSG_LENGTH,
                    NULL);
        CredPutStdout(szMsg);
        WinStatus = ERROR_CANCELLED;
        goto Cleanup;
    }

    SmartCardCount = ComboBoxItemCount - SmartCardBaseInComboBox;

    //
    // Get a count of the number of valid and invalid smartcards
    //

    for ( i=0; i<SmartCardCount; i++ ) {

        if ( !GetSmartCardInfo( i, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &IsACard, &SmartCardValid, NULL ) ) {
            WinStatus = ERROR_INTERNAL_ERROR;
            goto Cleanup;
        }

        if ( SmartCardValid ) {
            ValidSmartCardCount ++;
            KnownGoodCard = i;
        } else {
            InvalidSmartCardCount ++;
        }

    }

    //
    // Get the username passed into the API
    //
    // Can't do a GetWindowText( UserNameControlWindow ) since the cert control has
    //  a non-editable window so we can't set the window text
    //

    if ( InitialUserName != NULL) {
        StringCchCopyW(UserName, RTL_NUMBER_OF(UserName), InitialUserName);
    } else {
        UserName[0] = '\0';
    }

    //
    // If the caller passed a name into the API,
    //  check to see if the name matches one of the smart cards.
    //

    if ( UserName[0] != '\0' ) {

        //
        // Find the smartcard that matches the username
        //

        ErrorString = MatchSmartCard(
                          SmartCardCount,
                          UserName,
                          &SavedCertIndex,
                          &SavedCertEnum );

        if ( ErrorString == NULL ) {
            WinStatus = NO_ERROR;
            goto Cleanup;
        }
    }

    //
    // Report any errors to the user
    //

    if ( InvalidSmartCardCount ) {

        szMsg[0] = 0;
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    CreduiInstance,
                    IDS_CMDLINE_ERRORS,
                    0,
                    szMsg,
                    CREDUI_MAX_CMDLINE_MSG_LENGTH,
                    NULL);
        CredPutStdout(szMsg);

        for ( i=0; i<SmartCardCount; i++ ) {

            if ( !GetSmartCardInfo( i, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &IsACard, &SmartCardValid, NULL ) ) {
                WinStatus = ERROR_INTERNAL_ERROR;
                goto Cleanup;
            }

            if ( !SmartCardValid ) 
        	{
                // GetSmartCardInfo() fills SmartCardText, which may include user's name
				if (IsACard)
				{
					szMsg[0] = 0;
			        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
			                    CreduiInstance,
			                    IDS_INVALIDCERT,
			                    0,
			                    szMsg,
			                    CREDUI_MAX_CMDLINE_MSG_LENGTH,
			                    NULL);
			        CredPutStdout(szMsg);
				}
				else
				{
	                CredPutStdout( SmartCardText );
				}
                //swprintf(szMsg,CreduiStrings.CmdLineError,i+1);
                szMsg[0] = 0;
                INT j = i+1;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            CreduiInstance,
                            IDS_CMDLINE_ERROR,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            (va_list *) &j);
		        CredPutStdout(szMsg);
		        CredPutStdout( L"\n" );
            } // end if invalid
        } // end for each reader
    } // end if any bad ones

    //
    // If the caller passed a name into the API,
    //  simply report that we couldn't find the cert and return
    //

    if ( UserName[0] != '\0' ) {

        // ErrorString is expected to be NoMatch or ManyMatch
        //_snwprintf(szMsg,
        //      CREDUI_MAX_CMDLINE_MSG_LENGTH,
        //      ErrorString,
        //      UserName);
        //      szMsg[0] = 0;
        //szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH] = L'\0';
        szMsg[0] = 0;
        rgarg[0] = (DWORD_PTR) UserName;
        // Note that ErrorString returned from MatchSmartCard has type LPWSTR, but it is actually
        //  a message ID.  We take the low word of the pointer as the ID.
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    CreduiInstance,
                    LOWORD(ErrorString),
                    0,
                    szMsg,
                    CREDUI_MAX_CMDLINE_MSG_LENGTH,
                    (va_list *) rgarg);

        CredPutStdout( szMsg );
        WinStatus = ERROR_CANCELLED;
        goto Cleanup;
    }

    //
    // If there was only one smartcard and it was valid,
    //  use it
    //

    // if ( ValidSmartCardCount == 1 && InvalidSmartCardCount == 0 ) {
    // gm: If list can only contain one item, use it.
    if ( ValidSmartCardCount == 1 ) {

        if ( !GetSmartCardInfo( KnownGoodCard, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &IsACard, &SmartCardValid, &SavedCertEnum ) ) {
            WinStatus = ERROR_INTERNAL_ERROR;
            goto Cleanup;
        }

        SavedCertIndex = KnownGoodCard;
        WinStatus = NO_ERROR;
        goto Cleanup;

    //
    // If there were valid smartcard,
    //  List the valid smartcards for the user
    //

    } else if ( ValidSmartCardCount ) {

        //
        // Tell user about all certs
        //

        szMsg[0] = 0;
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    CreduiInstance,
                    IDS_CHOOSE_A_CERT,
                    0,
                    szMsg,
                    CREDUI_MAX_CMDLINE_MSG_LENGTH,
                    NULL);
        CredPutStdout(szMsg);

        for ( i=0; i<SmartCardCount; i++ ) {

            if ( !GetSmartCardInfo( i, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &IsACard, &SmartCardValid, NULL ) ) {
                WinStatus = ERROR_INTERNAL_ERROR;
                goto Cleanup;
            }

            if ( SmartCardValid ) {
                //swprintf(szMsg,CreduiStrings.CmdLinePreamble,i+1,SmartCardText);
                szMsg[0] = 0;
                rgarg[0] = i+1;
                rgarg[1] = (DWORD_PTR) SmartCardText;
                
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            Instance,
                            IDS_CMDLINE_PREAMBLE,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            (va_list *) rgarg);
                CredPutStdout( szMsg );
            }
        }
        CredPutStdout( L"\n" );

        //
        // Ask user to enter the reader number of one of the smartcards
        //

        //_snwprintf(szMsg,
        //     CREDUI_MAX_CMDLINE_MSG_LENGTH,
        //      CreduiStrings.SCardPrompt,
        //      TargetName);
        //szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH] = L'\0';
        szMsg[0] = 0;
        rgarg[0] = (DWORD_PTR)TargetName;
        rgarg[1] = 0;
        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                    Instance,
                    IDS_SCARD_PROMPT,
                    0,
                    szMsg,
                    CREDUI_MAX_CMDLINE_MSG_LENGTH,
                    (va_list *) rgarg);
        CredPutStdout( szMsg );

        CredGetStdin( UserName, CREDUI_MAX_USERNAME_LENGTH, TRUE );

        if ( wcslen (UserName ) == 0 ) {
            szMsg[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_NO_SCARD_ENTERED ,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        NULL);
            CredPutStdout(szMsg);
            WinStatus = ERROR_CANCELLED;
            goto Cleanup;
        }

        //
        // Find the smartcard that matches the username
        //
        INT iWhich = 0;
        WCHAR *pc = NULL;
        
        iWhich = wcstol(UserName,&pc,10);
        if (pc == UserName) {
            // Invalid if at least one char was not numeric
            szMsg[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_READERINVALID,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        NULL);
            CredPutStdout(szMsg);
            WinStatus = ERROR_CANCELLED;
            goto Cleanup;
        }
        // convert 1 based UI number to 0 based internal index
        if (iWhich > 0) iWhich -= 1;
        if ( !GetSmartCardInfo( iWhich, CREDUI_MAX_USERNAME_LENGTH, SmartCardText, &IsACard, &SmartCardValid, &SavedCertEnum ) ) {
            // Invalid if that indexed card did not read correctly
                szMsg[0] = 0;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            CreduiInstance,
                            IDS_READERINVALID,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            NULL);
                CredPutStdout(szMsg);
            WinStatus = ERROR_CANCELLED;
            goto Cleanup;
        }

        // At this point, a valid number was entered, and an attempt to read the card made
        // GetSmartCardInfo() returned OK, but SmartCardValid may still be false
        if (!SmartCardValid)
        {
                szMsg[0] = 0;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            CreduiInstance,
                            IDS_READERINVALID,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            NULL);
                CredPutStdout(szMsg);
            WinStatus = ERROR_CANCELLED;
            goto Cleanup;
        }
        else
        {
            SavedCertIndex = iWhich;
            WinStatus = NO_ERROR;
            goto Cleanup;
        }
    }

    WinStatus = ERROR_CANCELLED;

    //
    // Complete the operation.
    //
    //  WinStatus is the status of the operation so far
    //  if NO_ERROR, SavedCertEnum is the description of the cert to use, and
    //               SavedCertIndex is the index to the selected cert.
    //
Cleanup:

    if ( WinStatus == NO_ERROR) {

        if ( CredUIMarshallNode ( SavedCertEnum, UserName ) ) {

            //
            // Save the username
            //

            UserNameSelection = SmartCardBaseInComboBox + SavedCertIndex;
            IsChangingUserName = TRUE;
            SendMessage(UserNameControlWindow,
                        CB_SETCURSEL,
                        UserNameSelection,
                        0);
            IsChangingUserName = FALSE;

            //
            // Prompt for the pin
            //

            //CredPutStdout( CreduiStrings.PinPrompt );
            //swprintf(szMsg,CreduiStrings.CmdLineThisCard,SavedCertIndex + 1);
            szMsg[0] = 0;
            i = SavedCertIndex + 1;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        Instance,
                        IDS_CMDLINE_THISCARD,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        (va_list *) &i);
            CredPutStdout(szMsg);

            CredGetStdin( Password, CREDUI_MAX_PASSWORD_LENGTH, FALSE );

            //
            // Save the pin
            //

            if  (!OnSetPassword( Password ) ) {
                WinStatus = GetLastError();

                CreduiDebugLog("CreduiCredentialControl::CmdlineSmartCardPrompt: "
                               "OnSetPassword failed: %u\n",
                               WinStatus );
            }

            //
            // Prompt whether the save the cred or not
            //

            CmdlineSavePrompt();

        } else {
            WinStatus = GetLastError();

            CreduiDebugLog("CreduiCredentialControl::CmdlineSmartCardPrompt: "
                           "CredMarshalCredential failed: %u\n",
                           WinStatus );
        }
    }

    //
    // Tell our parent window that we're done prompting
    //

    PostQuitMessage( WinStatus );

    return;
}

void CreduiCredentialControl::CmdlineSavePrompt()
/*++

Routine Description:

    Command line code to prompt for saving the credential

Arguments:

    None

Return Values:

    None

--*/
{
    WCHAR szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];
    WCHAR szY[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];
    WCHAR szN[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];

    //
    // Only prompt if we've been asked to display the checkbox
    //

    while ( Style & CRS_SAVECHECK ) {

            // Fetch the strings one by one from the messages, and cobble them together
            WCHAR *rgsz[2];
            szY[0] = 0;
            szN[0] = 0;
            rgsz[0] = szY;
            rgsz[1] = szN;
            szMsg[0] = 0;
            // Fetch yes and no strings
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_YES_TEXT,
                        0,
                        szY,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        NULL);
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_NO_TEXT,
                        0,
                        szN,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        NULL);
            // Arg substitute them into the prompt
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_SAVE_PROMPT,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        (va_list *) rgsz);

        szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH] = L'\0';
        CredPutStdout( szMsg );

        CredGetStdin( szMsg, CREDUI_MAX_CMDLINE_MSG_LENGTH, TRUE );

//        if ( toupper(szMsg[0]) == toupper(CreduiStrings.YesText[0]) ) {
        if ( toupper(szMsg[0]) == toupper(szY[0]) ) {
            Credential_CheckSave( Window, TRUE );
            break;
//        } else if ( toupper(szMsg[0]) == toupper(CreduiStrings.NoText[0]) ) {
        } else if ( toupper(szMsg[0]) == toupper(szN[0]) ) {
            Credential_CheckSave( Window, FALSE );
            break;
        }
    }
}

UINT CreduiCredentialControl::MapID(UINT uiID) {
   switch(uiID) {

   case IDC_USERNAME:
       return IDH_USERNAMEEDIT;
   case IDC_PASSWORD:
       return IDH_PASSWORDEDIT;
   case IDC_SAVE:
       return IDH_SAVECHECKBOX;
   default:
       return IDS_NOHELP;
   }
}

BOOL
CreduiCredentialControl::OnHelpInfo(LPARAM lp) {

    HELPINFO* pH;
    INT iMapped;
    pH = (HELPINFO *) lp;
    HH_POPUP stPopUp;
    RECT rcW;
    UINT gID;

    gID = pH->iCtrlId;
    iMapped = MapID(gID);
    
    if (iMapped == 0) return TRUE;
    
    if (IDS_NOHELP != iMapped) {

      memset(&stPopUp,0,sizeof(stPopUp));
      stPopUp.cbStruct = sizeof(HH_POPUP);
      stPopUp.hinst = Instance;
      stPopUp.idString = iMapped;
      stPopUp.pszText = NULL;
      stPopUp.clrForeground = -1;
      stPopUp.clrBackground = -1;
      stPopUp.rcMargins.top = -1;
      stPopUp.rcMargins.bottom = -1;
      stPopUp.rcMargins.left = -1;
      stPopUp.rcMargins.right = -1;
      stPopUp.pszFont = NULL;
      if (GetWindowRect((HWND)pH->hItemHandle,&rcW)) {
          stPopUp.pt.x = (rcW.left + rcW.right) / 2;
          stPopUp.pt.y = (rcW.top + rcW.bottom) / 2;
      }
      else stPopUp.pt = pH->MousePos;
      HtmlHelp((HWND) pH->hItemHandle,NULL,HH_DISPLAY_TEXT_POPUP,(DWORD_PTR) &stPopUp);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\api.cpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// api.cpp
//
// Win32 API function implementation and the DLL entry function.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#include "precomp.hpp"
#include "dialogs.hpp"
#include "resource.h"
//#include "utils.hpp"

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

HMODULE CreduiInstance = NULL;
ULONG CreduiComReferenceCount = 0;

BOOL CreduiIsPersonal = FALSE;
BOOL CreduiIsDomainController = FALSE;
BOOL CreduiIsSafeMode = FALSE;

CREDUI_STRINGS CreduiStrings;

UINT CreduiScarduiWmReaderArrival = 0;
UINT CreduiScarduiWmReaderRemoval = 0;
UINT CreduiScarduiWmCardInsertion = 0;
UINT CreduiScarduiWmCardRemoval = 0;
UINT CreduiScarduiWmCardCertAvail = 0;
UINT CreduiScarduiWmCardStatus = 0;

BOOL CreduiHasSmartCardSupport = FALSE;

static LONG CreduiFirstTime = TRUE;
static HANDLE CreduiInitEvent = NULL;

BOOL  gbWaitingForSSOCreds = FALSE;
WCHAR gszSSOUserName[CREDUI_MAX_USERNAME_LENGTH];
WCHAR gszSSOPassword[CREDUI_MAX_PASSWORD_LENGTH];
BOOL gbStoredSSOCreds = FALSE;

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiInitStringTable
//
// This function loads all the string resources into the global string table.
// It only needs to be called once per process.
//
// Return TRUE if the string table was successfully initialized or FALSE
// otherwise.
//
// Created 03/26/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiInitStringTable()
{
#define CREDUI_STRING(id, name) {\
    id, CreduiStrings.##name, (sizeof CreduiStrings.##name) / (sizeof WCHAR)\
}

    static struct
    {
        UINT Id;
        WCHAR *String;
        ULONG Length;
    } stringInfo[] = {
        // Static labels for controls
        CREDUI_STRING(IDS_USERNAME_STATIC, UserNameStatic),
        CREDUI_STRING(IDS_PASSWORD_STATIC, PasswordStatic),
        CREDUI_STRING(IDS_CERTIFICATE_STATIC, CertificateStatic),
        CREDUI_STRING(IDS_PIN_STATIC, PinStatic),
        CREDUI_STRING(IDS_CARD_STATIC, SmartCardStatic),
        // Caption strings
        CREDUI_STRING(IDS_DNS_CAPTION, DnsCaption),
        CREDUI_STRING(IDS_NETBIOS_CAPTION, NetbiosCaption),
        CREDUI_STRING(IDS_GENERIC_CAPTION, GenericCaption),
        CREDUI_STRING(IDS_WELCOME, Welcome),
        CREDUI_STRING(IDS_WELCOME_BACK, WelcomeBack),
        CREDUI_STRING(IDS_CONNECTING, Connecting),
        CREDUI_STRING(IDS_LOOKUP_NAME, LookupName),
        CREDUI_STRING(IDS_CARD_ERROR, CardError),
        CREDUI_STRING(IDS_SAVE, Save),
        CREDUI_STRING(IDS_PASSPORT_SAVE, PassportSave ),
        CREDUI_STRING(IDS_EMAIL_NAME, EmailName ),
        // Tooltip strings
        CREDUI_STRING(IDS_USERNAME_TIP_TITLE, UserNameTipTitle),
        CREDUI_STRING(IDS_USERNAME_TIP_TEXT, UserNameTipText),
        CREDUI_STRING(IDS_PASSWORD_TIP_TITLE, PasswordTipTitle),
        CREDUI_STRING(IDS_PASSWORD_TIP_TEXT, PasswordTipText),
        CREDUI_STRING(IDS_CAPSLOCK_TIP_TITLE, CapsLockTipTitle),
        CREDUI_STRING(IDS_CAPSLOCK_TIP_TEXT, CapsLockTipText),
        CREDUI_STRING(IDS_LOGON_TIP_TITLE, LogonTipTitle),
        CREDUI_STRING(IDS_LOGON_TIP_TEXT, LogonTipText),
        CREDUI_STRING(IDS_LOGON_TIP_CAPS, LogonTipCaps),
        CREDUI_STRING(IDS_BACKWARDS_TIP_TITLE, BackwardsTipTitle),
        CREDUI_STRING(IDS_BACKWARDS_TIP_TEXT, BackwardsTipText),
        CREDUI_STRING(IDS_WRONG_OLD_TIP_TITLE, WrongOldTipTitle),
        CREDUI_STRING(IDS_WRONG_OLD_TIP_TEXT, WrongOldTipText),
        CREDUI_STRING(IDS_NOT_SAME_TIP_TITLE, NotSameTipTitle),
        CREDUI_STRING(IDS_NOT_SAME_TIP_TEXT, NotSameTipText),
        CREDUI_STRING(IDS_TOO_SHORT_TIP_TITLE, TooShortTipTitle),
        CREDUI_STRING(IDS_TOO_SHORT_TIP_TEXT, TooShortTipText),
        CREDUI_STRING(IDS_DOWNGRADE_TIP_TEXT, DowngradeTipText),
        CREDUI_STRING(IDS_EMAILNAME_TIP_TITLE, EmailNameTipTitle),
        CREDUI_STRING(IDS_EMAILNAME_TIP_TEXT, EmailNameTipText),
        // strings that can appear in GUI or be copied from GUI and presented on cmdline
        CREDUI_STRING(IDS_CMDLINE_NOCARD,NoCard),               
        CREDUI_STRING(IDS_EMPTY_READER, EmptyReader),
        CREDUI_STRING(IDS_READING_CARD, ReadingCard),          
        CREDUI_STRING(IDS_CERTIFICATE, Certificate),
        CREDUI_STRING(IDS_EMPTY_CARD, EmptyCard),             
        CREDUI_STRING(IDS_UNKNOWN_CARD, UnknownCard),          
        CREDUI_STRING(IDS_BACKWARDS_CARD, BackwardsCard)
    };

#undef CREDUI_STRING

    for (UINT i = 0; i < (sizeof stringInfo) / (sizeof stringInfo[0]); ++i)
    {
        // Read all strings into string array from resources of application
        // Some strings which are GUI-only taken from resources
        // Strings that are may be output to cmdline are taken from MC file, which also
        //  permits more flexible argument substitution during localization
        if (stringInfo[i].Id >= 2500)
        {
            stringInfo[i].String[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        stringInfo[i].Id,
                        0,
                        stringInfo[i].String,
                        stringInfo[i].Length - 1,
                        NULL);
        }
        else if (!LoadString(CreduiInstance,
                        stringInfo[i].Id,
                        stringInfo[i].String,
                        stringInfo[i].Length))
        {
            CreduiDebugLog("CreduiInitStringTable: Load string %u failed\n",
                           stringInfo[i].Id);
            return FALSE;
        }
    }

    return TRUE;
}

//=============================================================================
// CreduiInitSmartCardWindowMessages
//
// Return TRUE on success or FALSE otherwise.
//
// Created 03/26/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiInitSmartCardWindowMessages()
{
    struct
    {
        UINT *message;
        CHAR *string;
    } messageInfo[] = {
        &CreduiScarduiWmReaderArrival, SCARDUI_READER_ARRIVAL,
        &CreduiScarduiWmReaderRemoval, SCARDUI_READER_REMOVAL,
        &CreduiScarduiWmCardInsertion, SCARDUI_SMART_CARD_INSERTION,
        &CreduiScarduiWmCardRemoval, SCARDUI_SMART_CARD_REMOVAL,
        &CreduiScarduiWmCardCertAvail, SCARDUI_SMART_CARD_CERT_AVAIL,
        &CreduiScarduiWmCardStatus, SCARDUI_SMART_CARD_STATUS
    };

    for (UINT i = 0; i < (sizeof messageInfo) / (sizeof messageInfo[0]); ++i)
    {
        *messageInfo[i].message =
            RegisterWindowMessageA(messageInfo[i].string);

        if (*messageInfo[i].message == 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}

//=============================================================================
// CreduiApiInit
//
// This function is called at API entry points to ensure the common controls
// we need are initialized. Currently, the only initialization done is only
// needed once per process, but this macro will handle per thread
// initialization in the future, if necessary:
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 03/10/2000 johnstep (John Stephens)
//=============================================================================

static
BOOL
CreduiApiInit()
{
    // First time initialization:

    ASSERT(CreduiInitEvent != NULL);

    if (InterlockedCompareExchange(&CreduiFirstTime, FALSE, TRUE))
    {
        INITCOMMONCONTROLSEX init;
        init.dwSize = sizeof init;
        init.dwICC = ICC_USEREX_CLASSES;

        if (!InitCommonControlsEx(&init))
        {
            return FALSE;
        }

        // Check for Personal SKU:

        OSVERSIONINFOEXW versionInfo;

        versionInfo.dwOSVersionInfoSize = sizeof OSVERSIONINFOEXW;

        if (GetVersionEx(reinterpret_cast<OSVERSIONINFOW *>(&versionInfo)))
        {
            CreduiIsPersonal =
                (versionInfo.wProductType == VER_NT_WORKSTATION) &&
                (versionInfo.wSuiteMask & VER_SUITE_PERSONAL);
            CreduiIsDomainController =
                (versionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER);
        }

        // Check for safe mode:

        HKEY key;

        if (RegOpenKeyEx(
               HKEY_LOCAL_MACHINE,
               L"SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option",
               0,
               KEY_READ,
               &key) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(
                    key,
                    L"OptionValue",
                    NULL,
                    NULL,
                    NULL,
                    NULL) == ERROR_SUCCESS)
            {
                CreduiIsSafeMode = TRUE;
            }

            RegCloseKey(key);
        }

        // Do other initialization:

        InitializeCredMgr();
        if (!CreduiInitStringTable())
        {
            return FALSE;
        }

        CreduiHasSmartCardSupport = CreduiInitSmartCardWindowMessages();

        CreduiIconParentWindow::Register(CreduiInstance);

        SetEvent(CreduiInitEvent);
    }
    else
    {
        WaitForSingleObject(CreduiInitEvent, INFINITE);
    }

    return TRUE;
}

//=============================================================================
// CreduiValidateUiInfo
//
// This function validates the CREDUI_INFO structure passed in. A NULL value
// is acceptable, and impies defaults.
//
// CredValidateUiInfoW for wide
// CredValidateUiInfoA for ANSI
//
// Arguments:
//   uiInfo (in) - structure to validate
//
// Returns TRUE if the structure is valid, or FALSE otherwise.
//
// Created 03/25/2000 johnstep (John Stephens)
//=============================================================================

static
BOOL
CreduiValidateUiInfoW(
    CREDUI_INFOW *uiInfo
    )
{
   
    if (uiInfo != NULL)
    {
    	if (uiInfo->cbSize != sizeof(*uiInfo) )  
        {
            return FALSE;
        }

        if ((uiInfo->hbmBanner != NULL) &&
            (GetObjectType(uiInfo->hbmBanner) != OBJ_BITMAP))
        {
            return FALSE;
        }

        if ((uiInfo->pszMessageText != NULL) &&
            (wcslen(uiInfo->pszMessageText) > CREDUI_MAX_MESSAGE_LENGTH))
        {
            return FALSE;
        }


        if ((uiInfo->pszCaptionText != NULL) &&
            (wcslen(uiInfo->pszCaptionText) > CREDUI_MAX_CAPTION_LENGTH))
        {
            return FALSE;
        }

    }

    return TRUE;
}

//=============================================================================
// CreduiConvertUiInfoToWide
//
// This function converts a CREDUI_INFOA structure to CREDUI_INFOW. On
// success,The caller is responsible for freeing pszMessageText and
// pszCaptionText via the delete [] operator.
//
// Arguments:
//   uiInfoA (in) - structure to convert
//   uiInfoW (out) - storage for converted structure. The pszMessageText and
//                   pszCaptionText will be set to NULL on failure or valid
//                   pointers (unless the in pointer is NULL) on success,
//                   allocated via the new [] operator.
//
// Returns TRUE if the structure is valid, or FALSE otherwise.
//
// Created 03/26/2000 johnstep (John Stephens)
//=============================================================================

static
BOOL
CreduiConvertUiInfoToWide(
    CREDUI_INFOA *uiInfoA,
    CREDUI_INFOW *uiInfoW
    )
{
    uiInfoW->cbSize = uiInfoA->cbSize;
    uiInfoW->hwndParent = uiInfoA->hwndParent;
    uiInfoW->pszMessageText = NULL;
    uiInfoW->pszCaptionText = NULL;
    uiInfoW->hbmBanner = uiInfoA->hbmBanner;

    INT bufferSize;

    if (uiInfoA->pszMessageText != NULL)
    {
        bufferSize =
            MultiByteToWideChar(
                CP_ACP, 0, uiInfoA->pszMessageText, -1, NULL, 0);

        if (bufferSize == 0)
        {
            goto ErrorExit;
        }

        uiInfoW->pszMessageText = new WCHAR[bufferSize];

        if (uiInfoW->pszMessageText == NULL)
        {
            goto ErrorExit;
        }

        if (MultiByteToWideChar(
                CP_ACP, 0, uiInfoA->pszMessageText, -1,
                const_cast<WCHAR *>(uiInfoW->pszMessageText),
                bufferSize) == 0)
        {
            goto ErrorExit;
        }
    }
    else
    {
        uiInfoW->pszMessageText = NULL;
    }

    if (uiInfoA->pszCaptionText != NULL)
    {
        bufferSize =
            MultiByteToWideChar(
                CP_ACP, 0, uiInfoA->pszCaptionText, -1, NULL, 0);

        if (bufferSize == 0)
        {
            goto ErrorExit;
        }

        uiInfoW->pszCaptionText = new WCHAR[bufferSize];

        if (uiInfoW->pszCaptionText == NULL)
        {
            goto ErrorExit;
        }

        if (MultiByteToWideChar(
                CP_ACP, 0, uiInfoA->pszCaptionText, -1,
                const_cast<WCHAR *>(uiInfoW->pszCaptionText),
                bufferSize) == 0)
        {
            goto ErrorExit;
        }
    }
    else
    {
        uiInfoW->pszCaptionText = NULL;
    }

    return TRUE;

ErrorExit:

    if (uiInfoW->pszCaptionText != NULL)
    {
        delete [] const_cast<WCHAR *>(uiInfoW->pszCaptionText);
        uiInfoW->pszCaptionText = NULL;
    }

    if (uiInfoW->pszMessageText != NULL)
    {
        delete [] const_cast<WCHAR *>(uiInfoW->pszMessageText);
        uiInfoW->pszMessageText = NULL;
    }

    return FALSE;
}



//=============================================================================
// CredUIPromptForCredentials
//
// Presents a user interface to get credentials from an application.
//
// CredUIPromptForCredentialsW for wide
// CredUIPromptForCredentialsA for ANSI
//
// Arguments:
//   uiInfo (in,optional)
//   targetName (in) - if specified, securityContext must be NULL
//   securityContext (in) - if specified, targetName must be NULL
//   error (in) - the authentication error
//   userName (in,out)
//   userNameBufferSize (in) - maximum length of userName
//   password (in,out)
//   passwordBufferSize (in) - maximum length of password
//   save (in/out) - TRUE if save check box was checked
//   flags (in)
//
// Returns:
//   ERROR_SUCCESS
//   ERROR_CANCELLED
//   ERROR_NO_SUCH_LOGON_SESSION - if credential manager cannot be used
//   ERROR_GEN_FAILURE
//   ERROR_INVALID_FLAGS
//   ERROR_INVALID_PARAMETER
//   ERROR_OUTOFMEMORY
//
// Created 10/17/2000 johnhaw

DWORD
CredUIPromptForCredentialsWorker(
    IN BOOL doingCommandLine,
    CREDUI_INFOW *uiInfo,
    CONST WCHAR *targetName,
    CtxtHandle *securityContext,
    DWORD authError,
    PWSTR pszUserName,
    ULONG ulUserNameBufferSize,
    PWSTR pszPassword,
    ULONG ulPasswordBufferSize,
    BOOL *save,
    DWORD flags
    )
/*++

Routine Description:

    This routine implements the GUI and command line prompt for credentials.

Arguments:

    DoingCommandLine - TRUE if prompting is to be done via the command line
        FALSE if prompting is to be done via GUI

    ... - Other parameters are the same a CredUIPromptForCredentials API

Return Values:

    Same as CredUIPromptForCredentials.

--*/
{
    ULONG CertFlags;
    ULONG CredCategory;
    ULONG PersistFlags;

    CreduiDebugLog("CUIPFCWorker: Flags: %x, Target: %S doingCommandLine: %i\n", flags, targetName, doingCommandLine);
    
    if ((NULL == pszUserName) || (NULL == pszPassword))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!CreduiApiInit())
    {
        return ERROR_GEN_FAILURE;
    }

    // Validate arguments:
    if ((flags & ~CREDUI_FLAGS_PROMPT_VALID) != 0)
    {
        CreduiDebugLog("CreduiPromptForCredentials: flags not valid %lx.\n", flags );
        return ERROR_INVALID_FLAGS;
    }

    //
    // Ensure there is is only one bit defining cert support
    //
    CertFlags = flags & (CREDUI_FLAGS_REQUIRE_SMARTCARD|CREDUI_FLAGS_REQUIRE_CERTIFICATE|CREDUI_FLAGS_EXCLUDE_CERTIFICATES);

    if ( CertFlags != 0 && !JUST_ONE_BIT(CertFlags) ) {
        CreduiDebugLog("CreduiPromptForCredentials: require smartcard, require certificate, and exclude certificates are mutually exclusive %lx.\n", flags );
        return ERROR_INVALID_FLAGS;
    }

    //
    // For the command line version,
    //  limit cert support further.
    //

    if ( doingCommandLine ) {
        if ( CertFlags == 0 ||
             (CertFlags & CREDUI_FLAGS_REQUIRE_CERTIFICATE) != 0 ) {
            CreduiDebugLog("CreduiPromptForCredentials: need either require smartcard or exclude certificates for command line %lx.\n", flags );
            return ERROR_INVALID_FLAGS;
        }
    }

    //
    // Ensure there is only one bit defining the credential category

    CredCategory = flags & (CREDUI_FLAGS_GENERIC_CREDENTIALS|CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS);

    if ( CredCategory != 0 && !JUST_ONE_BIT(CredCategory) ) {
        CreduiDebugLog("CreduiPromptForCredentials: generic creds and username target are mutually exclusive %lx.\n", flags );
        return ERROR_INVALID_FLAGS;
    }

    //
    // Ensure there is only one bit set saying whether the cred is to persist or not
    //

    PersistFlags = flags & (CREDUI_FLAGS_DO_NOT_PERSIST|CREDUI_FLAGS_PERSIST);

    if ( PersistFlags != 0 && !JUST_ONE_BIT(PersistFlags) ) {
        CreduiDebugLog("CreduiPromptForCredentials: DoNotPersist and Persist are mutually exclusive %lx.\n", flags );
        return ERROR_INVALID_FLAGS;
    }

    //
    // Ensure AlwaysShowUi is only specified for generic credentials
    //

    if ( flags & CREDUI_FLAGS_ALWAYS_SHOW_UI ) {
        if ( (flags & CREDUI_FLAGS_GENERIC_CREDENTIALS) == 0) {
            CreduiDebugLog("CreduiPromptForCredentials: AlwaysShowUi is only supported for generic credentials %lx.\n", flags );
            return ERROR_INVALID_FLAGS;
        }
    }

    //
    // Don't support a half-implemented feature
    //

    if ( securityContext != NULL ) {
        CreduiDebugLog("CreduiPromptForCredentials: securityContext must be null.\n" );
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Validate the passed in UI info
    //

    if (!CreduiValidateUiInfoW(uiInfo))
    {
        CreduiDebugLog("CreduiPromptForCredentials: UI info is invalid.\n" );
        return ERROR_INVALID_PARAMETER;
    }



    //
    // Ensure there are strings defined for the caption
    //

    if (flags & CREDUI_FLAGS_DO_NOT_PERSIST)
    {
        if ((targetName == NULL) &&
            ((uiInfo == NULL) ||
             (uiInfo->pszMessageText == NULL) ||
             (uiInfo->pszCaptionText == NULL)))
        {
            CreduiDebugLog("CreduiPromptForCredentials: DoNotPersist and target data empty.\n" );
            return ERROR_INVALID_PARAMETER;
        }

    }
    else if (targetName != NULL)
    {
        if ((securityContext != NULL) ||
            (targetName[0] == L'\0') ||
            (wcslen(targetName) > CREDUI_MAX_DOMAIN_TARGET_LENGTH))
        {
            CreduiDebugLog("CreduiPromptForCredentials: target name bad %ws.\n", targetName );
            return ERROR_INVALID_PARAMETER;
        }
    }
    else if (securityContext == NULL)
    {
        CreduiDebugLog("CreduiPromptForCredentials: no target data.\n" );
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Ensure the caller supplied the default value for the save check box
    //
    if (flags & CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX)
    {
        if (save == NULL)
        {
            CreduiDebugLog("CreduiPromptForCredentials: ShowSaveCheckbox and save is NULL.\n" );
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Ensure the user supplied a username if they set CREDUI_FLAGS_KEEP_USERNAME
    //
    if ( flags & CREDUI_FLAGS_KEEP_USERNAME )
    {
        if ( pszUserName == NULL )
        {
            CreduiDebugLog("CreduiPromptForCredentials: CREDUI_FLAGS_KEEP_USERNAME and pszUserName is NULL.\n" );
            return ERROR_INVALID_PARAMETER;
        }

    }

    // Use the stack for user name and password:

    WCHAR userName[CREDUI_MAX_USERNAME_LENGTH + 1];
    WCHAR password[CREDUI_MAX_PASSWORD_LENGTH + 1];

    ZeroMemory(userName, sizeof userName);
    ZeroMemory(password, sizeof password);

    DWORD result = ERROR_OUTOFMEMORY;

    if (FAILED(StringCchCopyW(userName, RTL_NUMBER_OF(userName), pszUserName)) ||
        FAILED(StringCchCopyW(password, RTL_NUMBER_OF(password), pszPassword)))
    {
        result = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Do the password dialog box:
    //
    //  Delay actually writing the credential to cred man if we're returning
    //  the credential to the caller.
    //  Otherwise, the CredWrite is just harvesting credentials for the next caller.
    //  So delay the CredWrite until this caller confirms the validity.
    //

    CreduiPasswordDialog* pDlg = new CreduiPasswordDialog(
        doingCommandLine,
        (pszUserName != NULL && pszPassword != NULL ),
        CredCategory,
        uiInfo,
        targetName,
        userName,
        sizeof(userName)/sizeof(WCHAR)-sizeof(WCHAR),   // Pass MaxChars instead of buffer size
        password,
        sizeof(password)/sizeof(WCHAR)-sizeof(WCHAR),   // Pass MaxChars instead of buffer size
        save,
        flags,
        (flags & CREDUI_FLAGS_GENERIC_CREDENTIALS) ? NULL : securityContext,
        authError,
        &result);

    if ( pDlg != NULL )
    {
        delete pDlg;
        pDlg = NULL;
    }
    else
    {
        // couldn't create dialog, return.
        result = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    // copy outbound username
    if ( pszUserName != NULL )
    {
        if (FAILED(StringCchCopyExW(
                pszUserName,
                ulUserNameBufferSize,
                userName,
                NULL,
                NULL,
                STRSAFE_FILL_ON_FAILURE)))
        {
            CreduiDebugLog("CreduiPromptForCredentials: type username is too long.\n" );
            result = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if ( pszPassword != NULL )
    {
        if (FAILED(StringCchCopyExW(
                pszPassword,
                ulPasswordBufferSize,
                password,
                NULL,
                NULL,
                STRSAFE_FILL_ON_FAILURE)))
        {
            CreduiDebugLog("CreduiPromptForCredentials: type password is too long.\n" );
            result = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

Cleanup:
    SecureZeroMemory(password, sizeof password);

    return result;
}

//=============================================================================

CREDUIAPI
DWORD
WINAPI
CredUIPromptForCredentialsW(
    CREDUI_INFOW *uiInfo,
    CONST WCHAR *targetName,
    CtxtHandle *securityContext,
    DWORD authError,
    PWSTR pszUserName,
    ULONG ulUserNameBufferSize,
    PWSTR pszPassword,
    ULONG ulPasswordBufferSize,
    BOOL *save,
    DWORD flags
    )
{
    //
    // Call the common code indicating this is the GUI interface
    //

    return CredUIPromptForCredentialsWorker(
                FALSE,      // GUI version
                uiInfo,
                targetName,
                securityContext,
                authError,
                pszUserName,
                ulUserNameBufferSize,
                pszPassword,
                ulPasswordBufferSize,
                save,
                flags );

}

CREDUIAPI
DWORD
WINAPI
CredUIPromptForCredentialsA(
    CREDUI_INFOA *uiInfo,
    CONST CHAR *targetName,
    CtxtHandle *securityContext,
    DWORD authError,
    PSTR  pszUserName,
    ULONG ulUserNameBufferSize,
    PSTR pszPassword,
    ULONG ulPasswordBufferSize,
    BOOL *save,
    DWORD flags
    )
{
    DWORD result;
    WCHAR targetNameW[CREDUI_MAX_DOMAIN_TARGET_LENGTH + 1];

    WCHAR userName[CREDUI_MAX_USERNAME_LENGTH + 1];
    WCHAR password[CREDUI_MAX_PASSWORD_LENGTH + 1];

    UINT  ConsoleCodePage = CP_ACP;
    CREDUI_INFOW uiInfoW = {0};

    if ((NULL == pszUserName) || (NULL == pszPassword))
    {
        result = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    // Convert in paramters to Unicode:
    // If a CREDUI_INFO structure was passed, convert it to wide now:

    if (uiInfo != NULL) {
        if (!CreduiConvertUiInfoToWide(uiInfo, &uiInfoW)) {
            result = ERROR_OUTOFMEMORY;
            goto Exit;
        }
    }

    // If a target name was passed, convert it to wide now:

    if (targetName != NULL)
    {
        if (!MultiByteToWideChar(ConsoleCodePage, 
                                 0, 
                                 targetName, 
                                 -1,
                                 targetNameW,
                                 CREDUI_MAX_DOMAIN_TARGET_LENGTH + 1) )
        {
            result = GetLastError();
            goto Exit;
        }
    }


    userName[0] ='\0';
    password[0] = '\0';

    if (strlen(pszUserName) > 0 )
    {
        if ( !MultiByteToWideChar( ConsoleCodePage, 
                                   0, 
                                   pszUserName, 
                                   -1,
                                   userName, 
                                   sizeof(userName)/sizeof(WCHAR) ) ) 
        {
            result = GetLastError();
            goto Exit;
        }
    }

    if (strlen(pszPassword) > 0)
    {
        if ( !MultiByteToWideChar( ConsoleCodePage,  
                                   0, 
                                   pszPassword, 
                                   -1,
                                   password, 
                                   sizeof(password)/sizeof(WCHAR) ) ) 
        {
            result = GetLastError();
            goto Exit;
        }
    }

    //
    // Call the common code indicating this is the GUI interface
    //
    result = CredUIPromptForCredentialsWorker(
                FALSE,      // GUI version
                (uiInfo != NULL) ? &uiInfoW : NULL,
                (targetName != NULL) ? targetNameW : NULL,
                securityContext,
                authError,
                userName,
                ulUserNameBufferSize,
                password,
                ulPasswordBufferSize,
                save,
                flags );


    if ( result == NO_ERROR && pszUserName != NULL )
    {
        if (!WideCharToMultiByte(ConsoleCodePage, 
                                 0, 
                                 userName, 
                                 -1, 
                                 pszUserName,
                                 ulUserNameBufferSize, 
                                 NULL, 
                                 NULL) ) 
        {
            CreduiDebugLog("CreduiPromptForCredentials: type username cannot be converted to ANSI.\n" );
            result = GetLastError();
        }
    }

    if ( result == NO_ERROR && pszPassword != NULL )
    {
        if (!WideCharToMultiByte(ConsoleCodePage, 
                                 0, 
                                 password, 
                                 -1, 
                                 pszPassword,
                                 ulPasswordBufferSize,
                                 NULL, 
                                 NULL) ) 
        {
            CreduiDebugLog("CreduiPromptForCredentials: type password cannot be converted to ANSI.\n" );
            result = GetLastError();
        }
    }

Exit:
    SecureZeroMemory(password, sizeof password);

    // Free the CREDUI_INFO allocations:

    if (uiInfo != NULL)
    {
        if (uiInfoW.pszMessageText != NULL)
        {
            delete [] const_cast<WCHAR *>(uiInfoW.pszMessageText);
        }

        if (uiInfoW.pszCaptionText != NULL)
        {
            delete [] const_cast<WCHAR *>(uiInfoW.pszCaptionText);
        }
    }

    return result;
}

DWORD
WINAPI
CredUIParseUserNameW(
    CONST WCHAR *UserName,
    WCHAR *user,
    ULONG userBufferSize,
    WCHAR *domain,
    ULONG domainBufferSize
    )
/*++

Routine Description:

    CredUIParseUserName is used to breakup a username returned by the cred management APIs
    into a username and domain part that can be used as input to other system APIs that
    require the full broken-up user credential.

    The following formats are supported:

        @@<MarshalledCredentialReference>: This is a marshaled credential reference as
        as defined by the CredIsMarshaledCredential API.  Such a credential is returned
        in the 'user' parameter.  The 'domain' parameter is set to an empty string.


        <DomainName>\<UserName>: The <UserName> is returned in the 'user' parameter and
        the <DomainName> is returned in the 'domain' parameter. The name is considered
        to have the this syntax if the 'UserName' string contains a \.

        <UserName>@<DnsDomainName>: The entire string is returned in the 'user' parameter.
        The 'domain' parameter is set to an empty string.
        For this syntax, the last @ in the string is used since <UserName> may
        contain an @ but <DnsDomainName> cannot.

        <UserName>: The <UserName> is returned in the 'user' parameter.
        The 'domain' parameter is set to an empty string.


Arguments:

    UserName - The user name to be parsed.

    user - Specifies a buffer to copy the user name portion of the parsed string to.

    userBufferSize - Specifies the size of the 'user' array in characters.
        The caller can ensure the passed in array is large enough by using an array
        that is CRED_MAX_USERNAME_LENGTH+1 characters long or by passing in an array that
        is wcslen(UserName)+1 characters long.

    domain - Specifies a buffer to copy the domain name portion of the parsed string to.

    domainBufferSize - Specifies the size of the 'domain' array in characters.
        The caller can ensure the passed in array is large enough by using an array
        that is CRED_MAX_USERNAME_LENGTH+1 characters long or by passing in an array that
        is wcslen(UserName)+1 characters long.

Return Values:

    The following status codes may be returned:

        ERROR_INVALID_ACCOUNT_NAME - The user name is not valid.

        ERROR_INVALID_PARAMETER - One of the parameters is invalid.

        ERROR_INSUFFICIENT_BUFFER - One of the buffers is too small.


--*/
{
    DWORD Status;
    CREDUI_USERNAME_TYPE UsernameType;


    //
    // Use the low level routine to do the work
    //

    Status = CredUIParseUserNameWithType(
                    UserName,
                    user,
                    userBufferSize,
                    domain,
                    domainBufferSize,
                    &UsernameType );

    if ( Status != NO_ERROR ) {
        return Status;
    }

    //
    // Avoid relative user names (for backward compatibility)
    //

    if ( UsernameType == CreduiRelativeUsername ) {
        user[0] = L'\0';
        domain[0] = L'\0';
        return ERROR_INVALID_ACCOUNT_NAME;
    }

    return NO_ERROR;

}

DWORD
WINAPI
CredUIParseUserNameA(
    CONST CHAR *userName,
    CHAR *user,
    ULONG userBufferSize,
    CHAR *domain,
    ULONG domainBufferSize
    )
/*++

Routine Description:

    Ansi version of CredUIParseUserName.

Arguments:

    Same as wide version except userBufferSize and domainBufferSize are in terms of bytes.

Return Values:

    Same as wide version.

--*/
{
    DWORD Status;

    WCHAR LocalUserName[CRED_MAX_USERNAME_LENGTH + 1];
    WCHAR RetUserName[CRED_MAX_USERNAME_LENGTH + 1];
    WCHAR RetDomainName[CRED_MAX_USERNAME_LENGTH + 1];


    //
    // Convert the passed in username to unicode
    //

    if ( MultiByteToWideChar( CP_ACP,
                              MB_ERR_INVALID_CHARS,
                              userName,
                              -1,
                              LocalUserName,
                              CRED_MAX_USERNAME_LENGTH + 1 ) == 0 ) {


        Status = GetLastError();
        goto Cleanup;
    }

    //
    // Call the unicode version of the API
    //

    Status = CredUIParseUserNameW(
                    LocalUserName,
                    RetUserName,
                    CRED_MAX_USERNAME_LENGTH + 1,
                    RetDomainName,
                    CRED_MAX_USERNAME_LENGTH + 1 );

    if ( Status != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Convert the answers back to ANSI
    //

    if ( WideCharToMultiByte( CP_ACP,
                              0,
                              RetUserName,
                              -1,
                              user,
                              userBufferSize,
                              NULL,
                              NULL ) == 0 ) {

        Status = GetLastError();
        goto Cleanup;
    }

    if ( WideCharToMultiByte( CP_ACP,
                              0,
                              RetDomainName,
                              -1,
                              domain,
                              domainBufferSize,
                              NULL,
                              NULL ) == 0 ) {

        Status = GetLastError();
        goto Cleanup;
    }



    Status = NO_ERROR;

Cleanup:
    if ( Status != NO_ERROR ) {
        user[0] = L'\0';
        domain[0] = L'\0';
    }
    return Status;
}

////////////////////////
// Command Line functions

//=============================================================================
// CredUIInitControls
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 06/21/2000 johnstep (John Stephens)
//=============================================================================

extern "C"
BOOL
WINAPI
CredUIInitControls()
{
    if (CreduiApiInit())
    {
        // Register the Credential controls:

        if (CreduiCredentialControl::Register(CreduiInstance))
        {
            return TRUE;
        }
    }

    return FALSE;
}

//=============================================================================
// DllMain
//
// The DLL entry function. Since we are linked to the CRT, we must define a
// function with this name, which will be called from _DllMainCRTStartup.
//
// Arguments:
//   instance (in)
//   reason (in)
//   (unused)
//
// Returns TRUE on success, or FALSE otherwise.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

extern "C"
BOOL
WINAPI
DllMain(
    HINSTANCE instance,
    DWORD reason,
    VOID *
    )
{
    BOOL success = TRUE;

    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(instance);
        CreduiInstance = instance;

        // Create a global event which will be set when first-time
        // initialization is completed by the first API call:

        CreduiInitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        if (CreduiInitEvent == NULL)
        {
            success = FALSE;
            goto failinit;
        }

        SHFusionInitialize(NULL);
        
        // Register the Credential controls:
        if (!CreduiCredentialControl::Register(instance))
        {
            CloseHandle(CreduiInitEvent);
            CreduiInitEvent = NULL;
            success = FALSE;
            goto failinit;
        }

        //
        // Initialize the confirmation list
        //

        if ( !InitConfirmationList() ) {

            CreduiCredentialControl::Unregister();
            CloseHandle(CreduiInitEvent);
            CreduiInitEvent = NULL;
            success = FALSE;
        }
failinit:
        break;

    case DLL_PROCESS_DETACH:

        CleanUpConfirmationList();

        if (CreduiFirstTime == FALSE)
        {
            CreduiIconParentWindow::Unregister();
        }

        // Unregister the Credential controls:

        CreduiCredentialControl::Unregister();

        SHFusionUninitialize();
        // Make sure to free the global initialization event:

        if (CreduiInitEvent != NULL)
        {
            CloseHandle(CreduiInitEvent);
        }

        UninitializeCredMgr();

        break;
    };

    return success;
}

//=============================================================================
// DllCanUnloadNow (COM)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

STDAPI
DllCanUnloadNow()
{
    return (CreduiComReferenceCount == 0) ? S_OK : S_FALSE;
}

//=============================================================================
// DllGetClassObject (COM)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

STDAPI
DllGetClassObject(
    CONST CLSID &classId,
    CONST IID &interfaceId,
    VOID **outInterface
    )
{
    if (classId != CreduiStringArrayClassId)
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    CreduiStringArrayFactory *factory = new CreduiStringArrayFactory;

    if (factory == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT result = factory->QueryInterface(interfaceId, outInterface);

    factory->Release();

    // Release the string array object in any case, because of the
    // QueryInterface succeeded, it already took another reference count on
    // the object:

    return result;
}

//=============================================================================
// DllRegisterServer (COM)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

STDAPI
DllRegisterServer()
{
    HRESULT result = E_FAIL;

    WCHAR fileName[MAX_PATH + 1];

    if (GetModuleFileName(CreduiInstance, fileName, MAX_PATH))
    {
        HKEY regKey;

        if (RegCreateKeyEx(
                HKEY_CLASSES_ROOT,
                L"CLSID\\" CREDUI_STRING_ARRAY_CLASS_STRING
                    L"\\InProcServer32",
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_SET_VALUE,
                NULL,
                &regKey,
                NULL) == ERROR_SUCCESS)
        {
            if (RegSetValueEx(
                    regKey,
                    NULL,
                    0,
                    REG_SZ,
                    reinterpret_cast<CONST BYTE *>(fileName),
                    (wcslen(fileName) + 1) * 2) == ERROR_SUCCESS)
            {
                if (RegSetValueEx(
                        regKey,
                        L"ThreadingModel",
                        0,
                        REG_SZ,
                        reinterpret_cast<CONST BYTE *>(L"Apartment"),
                        18) == ERROR_SUCCESS)
                {
                    result = S_OK;
                }
            }

            RegCloseKey(regKey);
        }
    }

    return result;
}

//=============================================================================
// DllUnregisterServer (COM)
//
// Created 04/03/2000 johnstep (John Stephens)
//=============================================================================

STDAPI
DllUnregisterServer()
{
    HRESULT result = S_OK;
    LONG error;

    // Delete our InProcServer32 key:

    error =
        RegDeleteKey(
            HKEY_CLASSES_ROOT,
            L"CLSID\\" CREDUI_STRING_ARRAY_CLASS_STRING L"\\InProcServer32");

    if ((error != ERROR_SUCCESS) &&
        (error != ERROR_FILE_NOT_FOUND))
    {
        result = E_FAIL;
    }

    // Delete our class ID key:

    error =
        RegDeleteKey(
            HKEY_CLASSES_ROOT,
            L"CLSID\\" CREDUI_STRING_ARRAY_CLASS_STRING);

    if ((error != ERROR_SUCCESS) &&
        (error != ERROR_FILE_NOT_FOUND))
    {
        result = E_FAIL;
    }

    return result;
}


CREDUIAPI
DWORD
WINAPI
CredUIConfirmCredentialsW(
    PCWSTR pszTargetName,
    BOOL  bConfirm
    )
{
    CreduiDebugLog("CredUIConfirmCredentialsW called for %S, confirm= %x\n",pszTargetName,bConfirm);
    if (NULL == pszTargetName) return ERROR_INVALID_PARAMETER;
    return ConfirmCred ( pszTargetName, bConfirm, TRUE );
}

CREDUIAPI
DWORD
WINAPI
CredUIConfirmCredentialsA(
    PCSTR pszTargetName,
    BOOL  bConfirm
    )
{
    WCHAR targetNameW[CRED_MAX_STRING_LENGTH+1+CRED_MAX_STRING_LENGTH];

    // If a target name was passed, convert it to wide now:

    if (pszTargetName != NULL)
    {
        if (MultiByteToWideChar(
                CP_ACP, 0, pszTargetName, -1,
                targetNameW,
                CRED_MAX_STRING_LENGTH+1+CRED_MAX_STRING_LENGTH) == 0)
        {
            return GetLastError();
        }
    }

    return CredUIConfirmCredentialsW ( targetNameW, bConfirm );
}

CREDUIAPI
DWORD
WINAPI
CredUICmdLinePromptForCredentialsW(
    PCWSTR targetName,
    PCtxtHandle securityContext,
    DWORD dwAuthError,
    PWSTR UserName,
    ULONG ulUserBufferSize,
    PWSTR pszPassword,
    ULONG ulPasswordBufferSize,
    PBOOL pfSave,
    DWORD flags
    )
{
    //
    // Call the common code indicating this is the command line interface
    //

    return CredUIPromptForCredentialsWorker(
                TRUE,       // Command line version
                NULL,       // Command line version has no uiInfo,
                targetName,
                securityContext,
                dwAuthError,
                UserName,
                ulUserBufferSize,
                pszPassword,
                ulPasswordBufferSize,
                pfSave,
                flags );
}

CREDUIAPI
DWORD
WINAPI
CredUICmdLinePromptForCredentialsA(
    PCSTR targetName,
    PCtxtHandle pContext,
    DWORD dwAuthError,
    PSTR UserName,
    ULONG ulUserBufferSize,
    PSTR pszPassword,
    ULONG ulPasswordBufferSize,
    PBOOL pfSave,
    DWORD flags
    )
{
    DWORD result = ERROR_GEN_FAILURE;
    WCHAR *targetNameW = NULL;

    if (!CreduiApiInit())
    {
        return ERROR_GEN_FAILURE;
    }

    // convert to unicode

    WCHAR userNameW[CREDUI_MAX_USERNAME_LENGTH + 1];
    WCHAR *pUserNameW;

    if ( UserName != NULL )
    {
        if (MultiByteToWideChar(CP_ACP, 0, UserName, -1,
                                userNameW, sizeof(userNameW)/sizeof(WCHAR)) == 0)
        {
            result = GetLastError();
            goto Exit;
        }
        pUserNameW = userNameW;
    }
    else
    {
        pUserNameW = NULL;
    }

    WCHAR passwordW[CREDUI_MAX_PASSWORD_LENGTH + 1];
    WCHAR *ppasswordW;

    if ( pszPassword != NULL )
    {
        if (MultiByteToWideChar(CP_ACP, 0, pszPassword, -1,
                                passwordW, sizeof(passwordW)/sizeof(WCHAR)) == 0)
        {
            result = GetLastError();
            goto Exit;
        }
        ppasswordW = passwordW;
    }
    else
    {
        ppasswordW = NULL;
    }

    // Allocate the target name memory because it can be up to 32 KB:

    if (targetName != NULL)
    {
        INT targetNameSize =
            MultiByteToWideChar(CP_ACP, 0, targetName, -1, NULL, 0);

        if (targetNameSize == 0)
        {
            result = GetLastError();
            goto Exit;
        }

        targetNameW = new WCHAR[targetNameSize];

        if (targetNameW != NULL)
        {
            if (MultiByteToWideChar(CP_ACP, 0, targetName, -1,
                                    targetNameW, targetNameSize) == 0)
            {
                result = GetLastError();
                goto Exit;
            }
        }
        else
        {
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto Exit;
        }
    }
    else
    {
        targetNameW = NULL;
    }

    result = CredUICmdLinePromptForCredentialsW ( targetNameW,
                                                  pContext,
                                                  dwAuthError,
                                                  userNameW,
                                                  ulUserBufferSize,
                                                  passwordW,
                                                  ulPasswordBufferSize,
                                                  pfSave,
                                                  flags );

    if ( UserName != NULL )
    {
        if (!WideCharToMultiByte(CP_ACP, 0, userNameW, -1, UserName,
                                 ulUserBufferSize, NULL, NULL) ) {
            result = GetLastError();
            goto Exit;
        }
    }

    if ( pszPassword != NULL )
    {
        if (!WideCharToMultiByte(CP_ACP, 0, passwordW, -1, pszPassword,
                                 ulPasswordBufferSize, NULL, NULL)) {
            result = GetLastError();
            goto Exit;
        }
    }

Exit:

    SecureZeroMemory(passwordW, sizeof passwordW);

    // Free the target name memory:
    delete [] targetNameW;

    return result;
}

// call this api to store a single-sign-on credential
// retruns ERROR_SUCCESS if success

CREDUIAPI
DWORD
WINAPI
CredUIStoreSSOCredW (
    PCWSTR pszRealm,
    PCWSTR pszUsername,
    PCWSTR pszPassword,
    BOOL   bPersist
    )
{
    CreduiDebugLog ( "CredUIStoreSSOCredW\n" );

    DWORD dwResult = ERROR_GEN_FAILURE;

    if ( pszUsername == NULL || pszPassword == NULL )
        return dwResult;

    // temporarily cache them locally
    if (FAILED(StringCchCopyW(
            gszSSOUserName,
            RTL_NUMBER_OF(gszSSOUserName),
            pszUsername)) ||
        FAILED(StringCchCopyW(
            gszSSOPassword,
            RTL_NUMBER_OF(gszSSOPassword),
            pszPassword)))
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    WCHAR szTargetName[CREDUI_MAX_DOMAIN_TARGET_LENGTH];

    gbStoredSSOCreds = TRUE;

    if ( gbWaitingForSSOCreds || !bPersist)
    {
        dwResult = ERROR_SUCCESS;
    }
    else
    {
        // otherwise store them in credmgr

        if ( pszRealm )
        {
            // validate it's not zero length
            if ((pszRealm[0] == L'\0') ||
                FAILED(StringCchCopyExW(
                    szTargetName,
                    RTL_NUMBER_OF(szTargetName) - 2,
                    pszRealm,
                    NULL,
                    NULL,
                    STRSAFE_NO_TRUNCATION)))
            {
                dwResult = ERROR_INVALID_PARAMETER;
                goto Exit;
            }
        }
        else
        {
            GetDeaultSSORealm(szTargetName, TRUE);
        }

        // finalize the target name
        // ensure that the tail will fit first
        if (FAILED(StringCchCatExW(
                szTargetName,
                RTL_NUMBER_OF(szTargetName),
                L"\\*",
                NULL,
                NULL,
                STRSAFE_NO_TRUNCATION)))
        {
            dwResult = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        // encrypt the password
        PVOID pEncryptedPassword;
        DWORD dwESize = wcslen(pszPassword)+1;
        if (EncryptPassword ( (PWSTR)pszPassword, &pEncryptedPassword, &dwESize ) == ERROR_SUCCESS)
        {
            // write it out

            CREDENTIALW NewCredential;

            memset ( (void*)&NewCredential, 0, sizeof(CREDENTIALW));

            DWORD dwFlags = 0;

            NewCredential.TargetName = szTargetName;
            NewCredential.Type = CRED_TYPE_DOMAIN_VISIBLE_PASSWORD;
            NewCredential.Persist = bPersist ? CRED_PERSIST_ENTERPRISE : CRED_PERSIST_SESSION;
            NewCredential.Flags =  0;
            NewCredential.CredentialBlobSize = dwESize;
            NewCredential.UserName = (LPWSTR)pszUsername;
            NewCredential.CredentialBlob = reinterpret_cast<BYTE *>(pEncryptedPassword);

            if ( CredWriteW(&NewCredential, dwFlags))
            {
                dwResult = ERROR_SUCCESS;
            }

            LocalFree (pEncryptedPassword);
        }
    }

Exit:

    SecureZeroMemory(gszSSOUserName, sizeof gszSSOUserName);
    SecureZeroMemory(gszSSOPassword, sizeof gszSSOPassword);

    return dwResult;
}

CREDUIAPI
DWORD
WINAPI
CredUIStoreSSOCredA (
    PCSTR pszRealm,
    PCSTR pszUsername,
    PCSTR pszPassword,
    BOOL  bPersist
    )
{
    DWORD dwResult = ERROR_GEN_FAILURE;

    // convert to unicode

    WCHAR realmW[CREDUI_MAX_DOMAIN_TARGET_LENGTH];
    WCHAR *prealmW;

    if ( pszRealm != NULL )
    {
        if (MultiByteToWideChar(CP_ACP, 0, pszRealm, -1,
                                realmW, RTL_NUMBER_OF(realmW)) == 0)
        {
            goto Exit;
        }
        prealmW = realmW;
    }
    else
    {
        prealmW = NULL;
    }

    WCHAR userNameW[CREDUI_MAX_USERNAME_LENGTH + 1];
    WCHAR *pUserNameW;

    if ( pszUsername != NULL )
    {
        if (MultiByteToWideChar(CP_ACP, 0, pszUsername, -1,
                                userNameW, RTL_NUMBER_OF(userNameW)) == 0)
        {
            goto Exit;
        }
        pUserNameW = userNameW;
    }
    else
    {
        pUserNameW = NULL;
    }

    WCHAR passwordW[CREDUI_MAX_PASSWORD_LENGTH + 1];
    WCHAR *ppasswordW;

    if ( pszPassword != NULL )
    {
        if (MultiByteToWideChar(CP_ACP, 0, pszPassword, -1,
                                passwordW, RTL_NUMBER_OF(passwordW)) == 0)
        {
            goto Exit;
        }
        ppasswordW = passwordW;
    }
    else
    {
        ppasswordW = NULL;
    }

    dwResult = CredUIStoreSSOCredW ( prealmW, pUserNameW, ppasswordW, bPersist );

Exit:
    // clean up passwords in memory
    SecureZeroMemory(passwordW, sizeof passwordW);

    return dwResult;
}

// call this api to retrieve the username for a single-sign-on credential
// retruns ERROR_SUCCESS if success, ERROR_NOT_FOUND if none was found

CREDUIAPI
DWORD
WINAPI
CredUIReadSSOCredW (
    PCWSTR pszRealm,
    PWSTR* ppszUsername
    )
{
    DWORD dwReturn = ERROR_NOT_FOUND;
    WCHAR szTargetName[CREDUI_MAX_DOMAIN_TARGET_LENGTH];

    if ( pszRealm )
    {
        // validate it's not zero length
        if ((pszRealm[0] == L'\0') ||
            FAILED(StringCchCopyExW(
                szTargetName,
                RTL_NUMBER_OF(szTargetName) - 2,
                pszRealm,
                NULL,
                NULL,
                STRSAFE_NO_TRUNCATION)))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        GetDeaultSSORealm(szTargetName, FALSE);
    }

    // validate it's not zero length
    if (szTargetName[0] != L'\0')
    {
        // finalize the target name
        // ensure that the tail will fit first
        if (FAILED(StringCchCatExW(
                szTargetName,
                RTL_NUMBER_OF(szTargetName),
                L"\\*",
                NULL,
                NULL,
                STRSAFE_NO_TRUNCATION)))
        {
            return ERROR_INVALID_PARAMETER;
        }

        PCREDENTIALW pCred;
        DWORD dwFlags = 0;

        if ( CredReadW ( szTargetName,
                    CRED_TYPE_DOMAIN_VISIBLE_PASSWORD,
                    dwFlags,
                    &pCred ) )
        {
            size_t len = wcslen(pCred->UserName);
            *ppszUsername = (PWSTR)LocalAlloc(LMEM_ZEROINIT, sizeof(WCHAR)*(len+1));
            if ( *ppszUsername )
            {
                dwReturn = ERROR_SUCCESS;
                StringCchCopyW(*ppszUsername, len + 1, pCred->UserName);
            }

            CredFree ( pCred );
        }
    }

    return dwReturn;
}

// call this api to retrieve the username for a single-sign-on credential
// retruns ERROR_SUCCESS if success, ERROR_NOT_FOUND if none was found

CREDUIAPI
DWORD
WINAPI
CredUIReadSSOCredA (
    PCSTR pszRealm,
    PSTR* ppszUsername
    )
{
    DWORD dwReturn = ERROR_NOT_FOUND;
    WCHAR szTargetName[CREDUI_MAX_DOMAIN_TARGET_LENGTH];

    PCREDENTIALW pCred;
    DWORD dwFlags = 0;
    UINT uiConsoleCodePage = CP_ACP;

    if ( pszRealm )
    {
        // validate it's not zero length
        int len = strlen(pszRealm);
        if ( len == 0 )
        {
            return ERROR_INVALID_PARAMETER;
        }

        if (MultiByteToWideChar(uiConsoleCodePage, 
                                0, 
                                pszRealm, 
                                len + 1,
                                szTargetName, 
                                RTL_NUMBER_OF(szTargetName) - 2)
            == 0)
        {
            dwReturn = GetLastError();
            goto Exit;
        }

    }
    else
    {
        GetDeaultSSORealm(szTargetName, FALSE);
    }

    if (szTargetName[0] != L'\0')
    {
        // finalize the target name
        // ensure that the tail will fit first
        if (FAILED(StringCchCatExW(
                szTargetName,
                RTL_NUMBER_OF(szTargetName),
                L"\\*",
                NULL,
                NULL,
                STRSAFE_NO_TRUNCATION)))
        {
            dwReturn = ERROR_INVALID_PARAMETER;
            goto Exit;
        }

        // first call credmgr to set the target info
        if ( CredReadW ( szTargetName,
                    CRED_TYPE_DOMAIN_VISIBLE_PASSWORD,
                    dwFlags,
                    &pCred ) )
        {
            DWORD dwConvertedLength = 0;
            
            dwConvertedLength = WideCharToMultiByte(uiConsoleCodePage, 
                                                    0, 
                                                    pCred->UserName, 
                                                    -1, 
                                                    *ppszUsername,
                                                    0, 
                                                    NULL, 
                                                    NULL);
                                
            if (dwConvertedLength == 0)
            {
                // string does not convert or other error - all map to this
                dwReturn = ERROR_INVALID_PARAMETER;
            }
            else
            {
                // have proper buffer size and string will convert without loss
                *ppszUsername = (PSTR)LocalAlloc(LMEM_ZEROINIT, dwConvertedLength);
                if (*ppszUsername)
                {
                    dwReturn = WideCharToMultiByte(uiConsoleCodePage, 
                                                   0, 
                                                   pCred->UserName, 
                                                   -1, 
                                                   *ppszUsername,
                                                   dwConvertedLength, 
                                                   NULL, 
                                                   NULL);

                    if (dwReturn)
                    {
                        // nonzero return is success
                        dwReturn = ERROR_SUCCESS;
                    }
                    else
                    {
                        dwReturn = GetLastError();
                    }
                }
            }
            CredFree ( pCred );
        } 
        // end cred read
    } 
    // end target name not empty

Exit:

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\precomp.hpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// precomp.hpp
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <malloc.h>
extern "C" {
#include <commctrl.h>
}
#define _CREDUI_
#include <wincrui.h>

#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif

#include <security.h>

#include <controls.hpp>
#include "utils.hpp"
#include <netlib.h>
#include <shfusion.h>
#include <strsafe.h>

#if defined(DBG)
#if defined(CREDUIPRINTF)
#define CreduiDebugLog printf
#else
#define CreduiDebugLog DbgPrint
#endif
#else
#define CreduiDebugLog
#endif

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

struct CREDUI_STRINGS
{
    WCHAR UserNameTipTitle[32];
    WCHAR UserNameTipText[256];
    WCHAR PasswordTipTitle[32];
    WCHAR PasswordTipText[256];
    WCHAR CapsLockTipTitle[32];
    WCHAR CapsLockTipText[256];
    WCHAR LogonTipTitle[32];
    WCHAR LogonTipText[256];
    WCHAR LogonTipCaps[256];
    WCHAR DnsCaption[64];
    WCHAR NetbiosCaption[64];
    WCHAR GenericCaption[64];
    WCHAR Welcome[64];
    WCHAR WelcomeBack[64];
    WCHAR Connecting[64];
    WCHAR PasswordStatic[32];
    WCHAR PinStatic[32];
    WCHAR UserNameStatic[32];
    WCHAR CertificateStatic[32];
    WCHAR Certificate[32];
    WCHAR LookupName[64];
    WCHAR EmptyReader[64];
    WCHAR NoCard[32];
    WCHAR UnknownCard[64];
    WCHAR BackwardsCard[64];
    WCHAR EmptyCard[64];
    WCHAR ReadingCard[64];
    WCHAR CardError[64];
    WCHAR BackwardsTipTitle[32];
    WCHAR BackwardsTipText[128];
    WCHAR SmartCardStatic[32];
    WCHAR WrongOldTipTitle[32];
    WCHAR WrongOldTipText[256];
    WCHAR NotSameTipTitle[32];
    WCHAR NotSameTipText[256];
    WCHAR TooShortTipTitle[32];
    WCHAR TooShortTipText[256];
    WCHAR Save[64];
    WCHAR PromptForUse[256];
    WCHAR NoUsernameEntered[256];
    WCHAR PassportSave[64];
    WCHAR EmailName[64];
    WCHAR DowngradeTipText[256];
    WCHAR EmailNameTipTitle[64];
    WCHAR EmailNameTipText[256];
};

// Private window message:

enum
{
    CREDUI_WM_APP_LOOKUP_COMPLETE   = WM_APP + 0,
    CREDUI_WM_APP_VIEW_COMPLETE     = WM_APP + 1
};

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

extern HMODULE CreduiInstance;
extern ULONG CreduiComReferenceCount;

extern BOOL CreduiIsPersonal;
extern BOOL CreduiIsDomainController;
extern BOOL CreduiIsSafeMode;

extern CREDUI_STRINGS CreduiStrings;

extern UINT CreduiScarduiWmReaderArrival;
extern UINT CreduiScarduiWmReaderRemoval;
extern UINT CreduiScarduiWmCardInsertion;
extern UINT CreduiScarduiWmCardRemoval;
extern UINT CreduiScarduiWmCardCertAvail;
extern UINT CreduiScarduiWmCardStatus;

extern BOOL CreduiHasSmartCardSupport;

extern CONST CREDUI_BALLOON_TIP_INFO CreduiCapsLockTipInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\dialogs.hpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// dialogs.hpp
//
// Credential manager user interface classes used to get credentials.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#ifndef __DIALOGS_HPP__
#define __DIALOGS_HPP__

//-----------------------------------------------------------------------------

#include "controls.hpp"

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

struct CREDUI_CHANGE_PASSWORD_INFO
{
    CONST WCHAR *UserName;
    WCHAR *Password;
    ULONG PasswordMaxChars;
    CreduiBalloonTip BalloonTip;
    CreduiPasswordBox OldPasswordBox;
    CreduiPasswordBox NewPasswordBox;
    CreduiPasswordBox ConfirmPasswordBox;
};

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

static
INT_PTR
CALLBACK
CreduiChangePasswordCallback(
    HWND changePasswordWindow,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

extern
BOOL
CreduiChangeDomainPassword(
    HWND parentWindow,
    CONST WCHAR *userName,
    WCHAR *password,
    ULONG passwordMaxChars
    );

//-----------------------------------------------------------------------------
// CreduiPasswordDialog Class
//-----------------------------------------------------------------------------

class CreduiPasswordDialog
{
public:

    CreduiPasswordDialog(
        IN BOOL DoingCommandLine,
        IN BOOL DelayCredentialWrite,
        IN DWORD credCategory,
        CREDUI_INFO *uiInfo,
        CONST WCHAR *targetName,
        WCHAR *userName,
        ULONG userNameMaxChars,
        WCHAR *password,
        ULONG passwordMaxChars,
        BOOL *save,
        DWORD flags,
        CtxtHandle *securityContext,
        DWORD authError,
        DWORD *result
        );
    ~CreduiPasswordDialog();

private:

    // Variables:

    DWORD Result;
    DWORD AuthError;

    HWND DialogWindow;

    HWND CredControlWindow;
    DWORD CredControlStyle;

    // User interface control state flags:

    enum
    {
        DISABLED_DIALOG             = 0x0001,
        DISABLED_CONTROL_CRED       = 0x0002,
        DISABLED_CONTROL_OK         = 0x0004,
    };

    BOOL DisabledControlMask;

    BOOL DelayCredentialWrite;
    BOOL EncryptedVisiblePassword;

    DWORD Flags;

    //
    // CredCategory defines the type of the credential
    //
    DWORD CredCategory;
#define DOMAIN_CATEGORY 0
#define USERNAME_TARGET_CATEGORY CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS
#define GENERIC_CATEGORY CREDUI_FLAGS_GENERIC_CREDENTIALS


    BOOL Save;
    WCHAR *TargetName;
    WCHAR *UserOrTargetName;
    CtxtHandle *SecurityContext;
    CREDUI_INFO UiInfo;
    WCHAR *UserName;
    ULONG UserNameMaxChars;
    WCHAR *Password;
    ULONG PasswordMaxChars;

    BOOL fInitialSaveState; // initial state of the Save checkbox
    BOOL fPassedUsername;
    BOOL fPasswordOnly;

    BOOL FirstPaint;
    CONST CREDUI_BALLOON *CredBalloon;

    enum
    {
        PASSWORD_UNINIT     = 0,
        PASSWORD_INIT       = 1,
        PASSWORD_CHANGED    = 2
    };

    DWORD PasswordState;

    LONG ResizeTop;
    LONG ResizeDelta;

    // Functions:

    BOOL InitWindow(HWND dialogWindow);
    VOID SelectAndSetWindowCaption();
    VOID SelectAndSetWindowMessage();

    VOID Enable(BOOL enable = TRUE);

    DWORD HandleOk();
    void    SetCredTargetFromInfo();
    DWORD UsernameHandleOk();
    DWORD FinishHandleOk();

    static LRESULT CALLBACK CmdLineMessageHandlerCallback(
        HWND window,
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );
    LRESULT
    CreduiPasswordDialog::CmdLineMessageHandler(
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );

    static INT_PTR CALLBACK DialogMessageHandlerCallback(
        HWND dialogWindow,
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );
    INT_PTR DialogMessageHandler(
        UINT message,
        WPARAM wParam,
        LPARAM lParam
        );

    static BOOL CALLBACK ResizeDialogCallback(
        HWND childWindow,
        LPARAM lParam);

    CREDENTIAL_TARGET_INFORMATION *TargetInfo;
    CREDENTIAL *PasswordCredential;
    CREDENTIAL *OldCredential;
    CREDENTIAL NewCredential;
    WCHAR OldUserName[CRED_MAX_USERNAME_LENGTH + 1];
    WCHAR NewTargetName[CRED_MAX_DOMAIN_TARGET_NAME_LENGTH + 1];
    WCHAR NewTargetAlias[CRED_MAX_STRING_LENGTH + 1];

    SSOPACKAGE SSOPackage;
    DWORD dwIDDResource;
    RECT rcBrand;
    HBITMAP hBrandBmp;

    DWORD MaximumPersist;
    DWORD MaximumPersistSso;

    //
    // Data specific to command line
    //

    DWORD
    CmdLineDialog(
        VOID
        );

    HWND CmdLineWindow;
    BOOL DoingCommandLine;
    static LONG Registered;

    DWORD
    CmdlinePasswordPrompt(
        VOID
        );



    // Functions:

    BOOL CompleteUserName();
    VOID SelectBestTargetName(BOOL serverOnly);
};

//-----------------------------------------------------------------------------

#endif // __DIALOGS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\resource.h ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// resource.h
//
// Resource identifiers for credential manager user interface resources.
//
// Created 02/18/2000 johnstep (John Stephens)
//=============================================================================

#ifndef __RESOURCE_H__
#define __RESOURCE_H__

//-----------------------------------------------------------------------------
#include "consmsg.h"

#define IDD_PASSWORD            101
#define IDD_CERTIFICATE         102
#define IDD_CHANGE_PASSWORD     103
#define IDD_BRANDEDPASSWORD     104

#define IDC_WELCOME_TEXT        1001
#define IDC_CRED                1002
#define IDC_USERNAME            1003
#define IDC_USERNAME_STATIC     1004
#define IDC_PASSWORD            1005
#define IDC_PASSWORD_STATIC     1006
#define IDC_SAVE                1007
#define IDC_BANNER              1009
#define IDC_VIEW_CERT           1010
#define IDC_NEW_PASSWORD        1011
#define IDC_CONFIRM_PASSWORD    1012
#define IDC_BRAND               1013
#define IDC_GETALINK            1014
#define IDC_HELPLINK            1015

#define IDC_BRANDRIGHT          1016
#define IDC_BRANDMID            1017
#define IDC_BRANDLEFT           1018

#define IDB_BANNER              1101
#define IDB_TYPES               1102
#define IDB_BRAND               1103

#define IDB_BRANDRIGHT          1104
#define IDB_BRANDMID            1105
#define IDB_BRANDLEFT           1106

#define IDI_DEFAULT             1201

#define IDS_USERNAME_TIP_TITLE  2001
#define IDS_USERNAME_TIP_TEXT   2002
#define IDS_CAPSLOCK_TIP_TITLE  2003
#define IDS_CAPSLOCK_TIP_TEXT   2004
#define IDS_LOGON_TIP_TITLE     2005
#define IDS_LOGON_TIP_TEXT      2006
#define IDS_LOGON_TIP_CAPS      2007
#define IDS_DNS_CAPTION         2008
#define IDS_NETBIOS_CAPTION     2009
#define IDS_GENERIC_CAPTION     2010
#define IDS_WELCOME             2011
#define IDS_WELCOME_BACK        2012
#define IDS_CONNECTING          2013
#define IDS_PASSWORD_STATIC     2014
#define IDS_PIN_STATIC          2015
#define IDS_USERNAME_STATIC     2016
#define IDS_CERTIFICATE_STATIC  2017
#define IDS_LOOKUP_NAME         2019
#define IDS_CARD_READY          2024
#define IDS_BACKWARDS_TIP_TITLE 2027
#define IDS_BACKWARDS_TIP_TEXT  2028
#define IDS_CARD_STATIC         2029
#define IDS_WRONG_OLD_TIP_TITLE 2030
#define IDS_WRONG_OLD_TIP_TEXT  2031
#define IDS_NOT_SAME_TIP_TITLE  2032
#define IDS_NOT_SAME_TIP_TEXT   2033
#define IDS_TOO_SHORT_TIP_TITLE 2034
#define IDS_TOO_SHORT_TIP_TEXT  2035
#define IDS_SAVE                2036
#define IDS_PASSPORT_SAVE       2051
#define IDS_EMAIL_NAME          2052
#define IDS_DOWNGRADE_TIP_TEXT  2056
#define IDS_EMAILNAME_TIP_TITLE 2058
#define IDS_EMAILNAME_TIP_TEXT  2059
#define IDS_PASSWORD_TIP_TITLE  2061
#define IDS_PASSWORD_TIP_TEXT   2062

// Help strings - context help for controls
#define IDS_NOHELP                          2100
#define IDH_USERNAMEEDIT                    2101
#define IDH_PASSWORDEDIT                    2102
#define IDH_SAVECHECKBOX                    2103


//-----------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\makefile.inc ===
#
# build a private credui.lib that contains undocumented and
# private functions
#

$(O)\creduip.def: credui.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) /DNOT_PUBLIC= $(C_PREPROCESSOR_FLAGS) $** > $@


$(O)\creduip.lib: $(O)\creduip.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\creduip.def
$(LIBRARY_OBJS)
<<NOKEEP


#
# Build public credui.lib
#

$(O)\credui.def: credui.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) /DNOT_PUBLIC=PRIVATE $(C_PREPROCESSOR_FLAGS) $** > $@


$(O)\credui.lib : $(O)\credui.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\credui.def
$(LIBRARY_OBJS)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\dialogs.cpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// dialogs.cpp
//
// Credential manager user interface classes used to get credentials.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#include "precomp.hpp"
#include "shellapi.h"
#include "dialogs.hpp"
#include "resource.h"
#include "utils.hpp"
#include "shpriv.h"
#include "shlobj.h"
#include "shlobjp.h"

// compile switch to allow credui to update wildcard creds
#define SETWILDCARD
NET_API_STATUS NetUserChangePasswordEy(LPCWSTR domainname, LPCWSTR username, LPCWSTR oldpassword, LPCWSTR newpassword);


// .NET logo sizes
#define BRANDLEFT_PIXEL_WIDTH       3
#define BRANDLEFT_PIXEL_HEIGHT      4
#define BRANDMID_PIXEL_HEIGHT       4
#define BRANDRIGHT_PIXEL_WIDTH    144
#define BRANDRIGHT_PIXEL_HEIGHT    37


//-----------------------------------------------------------------------------
// Values
//-----------------------------------------------------------------------------

#define CREDUI_MAX_WELCOME_TEXT_LINES 8

#define CREDUI_MAX_LOGO_HEIGHT        80

#define CREDUI_MAX_CMDLINE_MSG_LENGTH   256

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

// Balloon tip infos for change password dialog:

CONST CREDUI_BALLOON_TIP_INFO CreduiWrongOldTipInfo =
{
    CreduiStrings.WrongOldTipTitle,
    CreduiStrings.WrongOldTipText,
    TTI_ERROR, 96, 76
};

CONST CREDUI_BALLOON_TIP_INFO CreduiNotSameTipInfo =
{
    CreduiStrings.NotSameTipTitle,
    CreduiStrings.NotSameTipText,
    TTI_ERROR, 96, 76
};

CONST CREDUI_BALLOON_TIP_INFO CreduiTooShortTipInfo =
{
    CreduiStrings.TooShortTipTitle,
    CreduiStrings.TooShortTipText,
    TTI_ERROR, 96, 76
};

// Control balloons for password dialog:

CONST CREDUI_BALLOON CreduiUserNameBalloon =
{
    1, CREDUI_CONTROL_USERNAME, CREDUI_BALLOON_ICON_INFO,
    CreduiStrings.UserNameTipTitle,
    CreduiStrings.UserNameTipText
};

CONST CREDUI_BALLOON CreduiEmailNameBalloon =
{
    1, CREDUI_CONTROL_USERNAME, CREDUI_BALLOON_ICON_INFO,
    CreduiStrings.EmailNameTipTitle,
    CreduiStrings.EmailNameTipText
};

CONST CREDUI_BALLOON CreduiDowngradeBalloon =
{
    1, CREDUI_CONTROL_USERNAME, CREDUI_BALLOON_ICON_ERROR,
    CreduiStrings.LogonTipTitle,
    CreduiStrings.DowngradeTipText
};

CONST CREDUI_BALLOON CreduiLogonBalloon =
{
    1, CREDUI_CONTROL_PASSWORD, CREDUI_BALLOON_ICON_ERROR,
    CreduiStrings.LogonTipTitle,
    CreduiStrings.LogonTipText
};

CONST CREDUI_BALLOON CreduiLogonCapsBalloon =
{
    1, CREDUI_CONTROL_PASSWORD, CREDUI_BALLOON_ICON_ERROR,
    CreduiStrings.LogonTipTitle,
    CreduiStrings.LogonTipCaps
};

// Placehold for known password:

CONST WCHAR CreduiKnownPassword[] = L"********";

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

void DemoteOldDefaultSSOCred (
    PCREDENTIAL_TARGET_INFORMATION pTargetInfo,     // target info of new cred
    DWORD Flags
    );

//=============================================================================
// CreduiChangePasswordCallback
//
// This callback handles changing a domain password.
//
// Arguments:
//   changePasswordWindow (in)
//   message (in)
//   wParam (in)
//   lParam (in) - on WM_INITDIALOG, this is the info structure
//
// Returns TRUE if we handled the message, otherwise FALSE.
//
// Created 04/26/2000 johnstep (John Stephens)
//=============================================================================

INT_PTR
CALLBACK
CreduiChangePasswordCallback(
    HWND changePasswordWindow,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CREDUI_CHANGE_PASSWORD_INFO *info =
        reinterpret_cast<CREDUI_CHANGE_PASSWORD_INFO *>(
            GetWindowLongPtr(changePasswordWindow, GWLP_USERDATA));

    if (message == WM_INITDIALOG)
    {
        info = reinterpret_cast<CREDUI_CHANGE_PASSWORD_INFO *>(lParam);

        if (info != NULL)
        {
            // Store this object's pointer in the user data window long:

            SetWindowLongPtr(changePasswordWindow,
                             GWLP_USERDATA,
                             reinterpret_cast<LONG_PTR>(info));

            SetWindowText(
                GetDlgItem(changePasswordWindow, IDC_USERNAME),
                info->UserName);

            info->BalloonTip.Init(CreduiInstance, changePasswordWindow);

            info->OldPasswordBox.Init(
                GetDlgItem(changePasswordWindow, IDC_PASSWORD),
                &info->BalloonTip,
                &CreduiCapsLockTipInfo);

            info->NewPasswordBox.Init(
                GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                &info->BalloonTip,
                &CreduiCapsLockTipInfo);

            info->ConfirmPasswordBox.Init(
                GetDlgItem(changePasswordWindow, IDC_CONFIRM_PASSWORD),
                &info->BalloonTip,
                &CreduiCapsLockTipInfo);

            return TRUE;
        }
        else
        {
            EndDialog(changePasswordWindow, IDCANCEL);
        }
    }
    else switch (message)
    {
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_PASSWORD:
        case IDC_NEW_PASSWORD:
            if ((HIWORD(wParam) == EN_KILLFOCUS) ||
                (HIWORD(wParam) == EN_CHANGE))
            {
                if (info->BalloonTip.IsVisible())
                {
                    info->BalloonTip.Hide();
                }
            }
            break;

        case IDOK:
            WCHAR userDomain[CRED_MAX_USERNAME_LENGTH + 1];
            WCHAR userName[CRED_MAX_USERNAME_LENGTH + 1];
            WCHAR oldPassword[CRED_MAX_STRING_LENGTH + 1];
            WCHAR newPassword[CRED_MAX_STRING_LENGTH + 1];
            WCHAR confirmPassword[CRED_MAX_STRING_LENGTH + 1];

            oldPassword[0] = L'\0';
            newPassword[0] = L'\0';
            confirmPassword[0] = L'\0';

            GetWindowText(
                GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                newPassword,
                CRED_MAX_STRING_LENGTH);

            GetWindowText(
                GetDlgItem(changePasswordWindow, IDC_CONFIRM_PASSWORD),
                confirmPassword,
                CRED_MAX_STRING_LENGTH);

            if (wcscmp(newPassword, confirmPassword) != 0)
            {
                SetWindowText(
                    GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                    NULL);

                SetWindowText(
                    GetDlgItem(changePasswordWindow, IDC_CONFIRM_PASSWORD),
                    NULL);

                info->BalloonTip.SetInfo(
                    GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                    &CreduiNotSameTipInfo);

                info->BalloonTip.Show();
                SecureZeroMemory(newPassword, sizeof newPassword);
                SecureZeroMemory(confirmPassword, sizeof confirmPassword);
                break;
            }

            // Confirm password is no longer needed
            SecureZeroMemory(confirmPassword, sizeof confirmPassword);

            GetWindowText(
                GetDlgItem(changePasswordWindow, IDC_PASSWORD),
                oldPassword,
                CRED_MAX_STRING_LENGTH);

            if (CredUIParseUserName(
                    info->UserName,
                    userName,
                    sizeof(userName)/sizeof(WCHAR),
                    userDomain,
                    sizeof(userDomain)/sizeof(WCHAR)) == ERROR_SUCCESS)
            {
                NET_API_STATUS netStatus =
                    NetUserChangePasswordEy(userDomain,
                                          userName,
                                          oldPassword,
                                          newPassword);

                // Old password is no longer needed
                SecureZeroMemory(oldPassword, sizeof oldPassword);

                switch (netStatus)
                {
                case NERR_Success:
                    // Once we make it this far, the password has been
                    // changed. If the following call fails to update the
                    // credential, we really cannot do much about it except
                    // maybe notify the user.

                    StringCchCopyW(
                        info->Password,
                        info->PasswordMaxChars + 1,
                        newPassword);

                    // Scrub the passwords on the stack and clear the
                    // controls:

                    SecureZeroMemory(newPassword, sizeof newPassword);

                    // NOTE: We may want to first set the controls to some
                    //       pattern to fill the memory, then clear it.

                    SetWindowText(
                        GetDlgItem(changePasswordWindow, IDC_PASSWORD),
                        NULL);
                    SetWindowText(
                        GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                        NULL);
                    SetWindowText(
                        GetDlgItem(changePasswordWindow,
                                   IDC_CONFIRM_PASSWORD),
                        NULL);

                    // NOTE: We may want to notify the user that the password
                    //       has been successfully changed.

                    break;

                default:
                    // NOTE: If we got an unknown error, just handle it the
                    //       same way as an invalid password, for now:

                case ERROR_INVALID_PASSWORD:

                    // New password is no longer needed
                    SecureZeroMemory(newPassword, sizeof newPassword);

                    SetWindowText(
                        GetDlgItem(changePasswordWindow, IDC_PASSWORD),
                        NULL);

                    info->BalloonTip.SetInfo(
                        GetDlgItem(changePasswordWindow, IDC_PASSWORD),
                        &CreduiWrongOldTipInfo);

                    info->BalloonTip.Show();
                    return TRUE;

                case ERROR_ACCESS_DENIED:
                    // NOTE: One use of this return value is when the new
                    //       password and old are the same. Would any
                    //       configuration ever allow them to match? If not,
                    //       we could just compare before calling the API.

                case NERR_PasswordTooShort:

                    // New password is no longer needed
                    SecureZeroMemory(newPassword, sizeof newPassword);

                    SetWindowText(
                        GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                        NULL);
                    SetWindowText(
                        GetDlgItem(changePasswordWindow,
                                   IDC_CONFIRM_PASSWORD),
                        NULL);

                    info->BalloonTip.SetInfo(
                        GetDlgItem(changePasswordWindow, IDC_NEW_PASSWORD),
                        &CreduiTooShortTipInfo);

                    info->BalloonTip.Show();
                    return TRUE;
                }
            }
            else
            {
                SecureZeroMemory(newPassword, sizeof newPassword);
                SecureZeroMemory(oldPassword, sizeof oldPassword);
                break;
            }
            // Fall through...

        case IDCANCEL:
            EndDialog(changePasswordWindow, LOWORD(wParam));
            return TRUE;
        }
        break;
    }

    return FALSE;
}

//=============================================================================
// CreduiChangeDomainPassword
//
// Displays a dialog allowing the user to change the domain password.
//
// Arguments:
//   parentWindow (in)
//   userName (in)
//   password (out)
//   passwordMaxChars (in) - on WM_INITDIALOG, this is the info structure
//
// Returns TRUE if we handled the message, otherwise FALSE.
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiChangeDomainPassword(
    HWND parentWindow,
    CONST WCHAR *userName,
    WCHAR *password,
    ULONG passwordMaxChars
    )
{
    CREDUI_CHANGE_PASSWORD_INFO info;

    info.UserName = userName;
    info.Password = password;
    info.PasswordMaxChars = passwordMaxChars;

    return
        DialogBoxParam(
            CreduiInstance,
            MAKEINTRESOURCE(IDD_CHANGE_PASSWORD),
            parentWindow,
            CreduiChangePasswordCallback,
            reinterpret_cast<LPARAM>(&info)) == IDOK;
}

//-----------------------------------------------------------------------------
// CreduiPasswordDialog Class Implementation
//-----------------------------------------------------------------------------

LONG CreduiPasswordDialog::Registered = FALSE;

//=============================================================================
// CreduiPasswordDialog::SetCredTargetFromInfo()
//
// Created 04/03/2001 georgema
//=============================================================================
void CreduiPasswordDialog::SetCredTargetFromInfo()
{
    BOOL serverOnly = TRUE;

    NewCredential.Type = (CredCategory == GENERIC_CATEGORY) ?
                                CRED_TYPE_GENERIC :
                                CRED_TYPE_DOMAIN_PASSWORD;

    if ( TargetInfo != NULL )
    {
        if ( TargetInfo->CredTypeCount == 1 && *(TargetInfo->CredTypes) == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD ) {
            NewCredential.Type = CRED_TYPE_DOMAIN_VISIBLE_PASSWORD;
            MaximumPersist = MaximumPersistSso;
            serverOnly = (Flags & CREDUI_FLAGS_SERVER_CREDENTIAL);
        }

    }

    if ( CredCategory == DOMAIN_CATEGORY &&
        (TargetInfo != NULL))
    {
        SelectBestTargetName(serverOnly);

        NewCredential.TargetName = NewTargetName;
    }
    else
    {
        NewCredential.TargetName = const_cast<WCHAR *>(UserOrTargetName);
    }


}
//=============================================================================
// CreduiPasswordDialog::CreduiPasswordDialog
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiPasswordDialog::CreduiPasswordDialog(
    IN BOOL doingCommandLine,
    IN BOOL delayCredentialWrite,
    IN DWORD credCategory,
    CREDUI_INFO *uiInfo,
    CONST WCHAR *targetName,
    WCHAR *userName,
    ULONG userNameMaxChars,
    WCHAR *password,
    ULONG passwordMaxChars,
    BOOL *save,
    DWORD flags,
    CtxtHandle *securityContext,
    DWORD authError,
    DWORD *result
    )
/*++

Routine Description:

    This routine implements the GUI prompt for credentials

Arguments:

    DoingCommandLine - TRUE if prompting is to be done via the command line
        FALSE if prompting is to be done via GUI

    delayCredentialWrite - TRUE if the credential is to be written only upon confirmation.
        FALSE, if the credential is to be written now as a session credential then
            morphed to a more persistent credential upon confirmation.
        This field is ignored if Flags doesn't specify CREDUI_FLAGS_EXPECT_CONFIRMATION.

    credCategory - This is the subset of the "flags" parameter defining the category of
        the credential.


    ...

Return Values:

    None

--*/

{

    Result = ERROR_CANCELLED;

    hBrandBmp = NULL;

    // Initialize the result out argument for failure:
    if ( result != NULL )
        *result = Result;
// Turn on the following chatter always for debug builds
#if DBG
    // ensure that we don't miss uninitialized members in test...
    memset(this,0xcc,sizeof(CreduiPasswordDialog));
    CreduiDebugLog("CreduiPasswordDialog: Constructor. Incoming targetname = %S\n " ,targetName);
    CreduiDebugLog("Incoming username = %S\n",userName);
#endif
    CREDENTIAL **credentialSet = NULL;
    SecPkgContext_CredentialName credentialName = { 0, NULL };
    ZeroMemory(&NewCredential, sizeof NewCredential);
    fPassedUsername = FALSE;
    fPasswordOnly = FALSE;

    //FIX 399728
    if ((userName != NULL) &&
        (wcslen(userName) != 0)) fPassedUsername = TRUE;

    // Set most of the class members to valid initial values. The window
    // handles will be initialized later if everything succeeds:

    DoingCommandLine = doingCommandLine;
    DelayCredentialWrite = delayCredentialWrite;
    CredCategory = credCategory;
    UserName = userName;
    UserNameMaxChars = userNameMaxChars;
    Password = password;
    PasswordMaxChars = passwordMaxChars;
    Flags = flags;
    AuthError = authError;
    Save = (Flags & CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX) ? *save : FALSE;

    rcBrand.top = 0;
    rcBrand.left = 0;
    rcBrand.right = 0;
    rcBrand.bottom = 0;


    if (targetName != NULL)
    {
        TargetName = const_cast<WCHAR *>(targetName);
        SecurityContext = NULL;
    }
    else if ( CredCategory == DOMAIN_CATEGORY )
    {
        if( securityContext == NULL) {
            CreduiDebugLog("CreduiPasswordDialog: Need to pass target name for domain creds.\n" );
            if ( result != NULL )
                *result = ERROR_INVALID_PARAMETER;
            return;
        }

        SecurityContext = securityContext;

        // Get the credential name, which includes the type, from the
        // security context:

        if (QueryContextAttributes(
                SecurityContext,
                SECPKG_ATTR_CREDENTIAL_NAME,
                static_cast<VOID *>(&credentialName)) != SEC_E_OK)
        {
            // This is an invalid security context for this function:

            CreduiDebugLog("CreduiPasswordDialog: Cannot QueryContextAttributes.\n" );
            if ( result != NULL )
                *result = ERROR_INVALID_PARAMETER;
            return;
        }

        TargetName = credentialName.sCredentialName;
    }
    else TargetName = NULL;

    if (uiInfo != NULL)
    {
        UiInfo = *uiInfo;
    }
    else
    {
        UiInfo.cbSize = sizeof(UiInfo);
        UiInfo.hwndParent = NULL;
        UiInfo.pszMessageText = NULL;
        UiInfo.pszCaptionText = NULL;
        UiInfo.hbmBanner = NULL;
    }

    PasswordCredential = NULL;
    OldCredential = NULL;
    TargetInfo = NULL;

    EncryptedVisiblePassword = TRUE;

    FirstPaint = TRUE;
    CredBalloon = NULL;

    NewTargetName[0] = L'\0';
    NewTargetAlias[0] = L'\0';

    DisabledControlMask = 0;

    PasswordState = PASSWORD_UNINIT;

    ResizeTop = 0;
    ResizeDelta = 0;

    DWORD MaximumPersistArray[CRED_TYPE_MAXIMUM];

    if ( LocalCredGetSessionTypes( CRED_TYPE_MAXIMUM, MaximumPersistArray)) {

        //
        // Maintain "MaximumPersist" as the maximum persistence to use.
        //  We don't know yet whether this is an SSO cred, so keep it in a separate location
        //  until we know for sure.
        //
        // Be careful to not use MaximumPersist until we do know for sure
        //
        if ( CredCategory == DOMAIN_CATEGORY || CredCategory == USERNAME_TARGET_CATEGORY ) {
            MaximumPersist = MaximumPersistArray[CRED_TYPE_DOMAIN_PASSWORD];
        } else {
            MaximumPersist = MaximumPersistArray[CRED_TYPE_GENERIC];
        }

        MaximumPersistSso = MaximumPersistArray[CRED_TYPE_DOMAIN_VISIBLE_PASSWORD];

    } else {
        MaximumPersist = CRED_PERSIST_NONE;
        MaximumPersistSso = CRED_PERSIST_NONE;
    }


    fInitialSaveState = FALSE;      // ISSUE: this set at this point has no effect

    //
    // USERNAME_TARGET creds have two concepts of TargetName
    //  The target name on the peristed credential needs to be the UserName
    //  The target name everywhere else is the prompt text
    // UserOrTargetName is used in all the former cases.

    if ( CredCategory == USERNAME_TARGET_CATEGORY ) {
        UserOrTargetName = UserName;
    } else {
        UserOrTargetName = TargetName;
    }

    //
    // Get the target information for the target
    //
    // Only attempt to get target information if the target name is not a wildcard name.
    //
    // Do this regardless of whether the credential will be persisted.
    // Target info is used for completing the username.
    //

    if ( CredCategory == DOMAIN_CATEGORY &&
         SecurityContext == NULL &&
         !CreduiIsWildcardTargetName(TargetName) &&
         LocalCredGetTargetInfoW( TargetName,
                                  CRED_ALLOW_NAME_RESOLUTION,
                                  &TargetInfo) )
    {

        //
        // Check out the target info to ensure it matches the flag bits
        //  passed by the caller.
        //
        // If not, ignore the target info.
        //  We'll assume that the caller is using a different auth package than
        //  the one matching the cached info.
        //

        if ( TargetInfo->CredTypeCount != 0 ) {

            ULONG AuthPackageStyle;
            BOOL CertOk = FALSE;
            BOOL PasswordOk = FALSE;
            AuthPackageStyle = 0;

            //
            // Loop through the supported cred types seeing what style the auth package supports
            //

            for (UINT i = 0; i < TargetInfo->CredTypeCount; ++i)
            {
                switch ( TargetInfo->CredTypes[i] ) {
                case CRED_TYPE_DOMAIN_CERTIFICATE:
                    CertOk = TRUE;
                    break;
                case CRED_TYPE_DOMAIN_PASSWORD:
                case CRED_TYPE_DOMAIN_VISIBLE_PASSWORD:
                    PasswordOk = TRUE;
                    break;
                }

            }


            //
            // Adjust that for what the caller requires
            //
            if (Flags & (CREDUI_FLAGS_REQUIRE_SMARTCARD|CREDUI_FLAGS_REQUIRE_CERTIFICATE) ) {
                PasswordOk = FALSE;
            } else if (Flags & CREDUI_FLAGS_EXCLUDE_CERTIFICATES) {
                CertOk = FALSE;
            }

            //
            // If nothing to supported,
            //  ignore the target info
            //

            if ( !CertOk && !PasswordOk ) {
                LocalCredFree(static_cast<VOID *>(TargetInfo));
                TargetInfo = NULL;
            }
        }
    }


    //
    // If the credential might be peristed,
    //  determine the existing credential and
    //  build a template for the credential to be persisted.
    //

    if (!(Flags & CREDUI_FLAGS_DO_NOT_PERSIST))
    {
        // Read the existing credential for this target:

        CREDENTIAL *credential = NULL;

        Result = ERROR_SUCCESS;


        if ( CredCategory == GENERIC_CATEGORY )
        {
            if (LocalCredReadW(TargetName,
                         CRED_TYPE_GENERIC,
                         0,
                         &PasswordCredential))
            {
                OldCredential = PasswordCredential;
            }
            else
            {
                Result = GetLastError();
            }
        }
        else
        {
            DWORD count;

            //
            // If a TargetInfo was found,
            //  use it to read the matching credentials.
            //

            if ( TargetInfo != NULL ) {


                if (LocalCredReadDomainCredentialsW(TargetInfo, 0, &count,
                                              &credentialSet))
                {
                    for (DWORD i = 0; i < count; ++i)
                    {
#ifndef SETWILDCARD
                        //
                        // Ignore RAS and wildcard credentials,
                        //  we never want credUI to change such a credential.
                        //

                        if ( CreduiIsSpecialCredential(credentialSet[i]) ) {
                            continue;
                        }
#endif

                        //
                        // If the caller needs a server credential,
                        //  ignore wildcard credentials.
                        //

                        if ((Flags & CREDUI_FLAGS_SERVER_CREDENTIAL) &&
                             CreduiIsWildcardTargetName( credentialSet[i]->TargetName)) {

                            continue;
                        }

                        //
                        // If the caller wants a certificate,
                        //  ignore non certificates.
                        //

                        if ( Flags & (CREDUI_FLAGS_REQUIRE_CERTIFICATE|CREDUI_FLAGS_REQUIRE_SMARTCARD) ) {
                            if ( credentialSet[i]->Type != CRED_TYPE_DOMAIN_CERTIFICATE ) {
                                continue;
                            }
                        }

                        //
                        // If the caller wants to avoid certificates,
                        //  ignore certificates.
                        //

                        if ( Flags & CREDUI_FLAGS_EXCLUDE_CERTIFICATES ) {
                            if ( credentialSet[i]->Type == CRED_TYPE_DOMAIN_CERTIFICATE ) {
                                continue;
                            }
                        }

                        //
                        // CredReadDomain domain credentials returns creds in preference
                        //  order as specified by the TargetInfo.
                        //  So use the first valid one.
                        //
                        if ( OldCredential == NULL ) {
                            OldCredential = credentialSet[i];
                        }

                        //
                        // Remember the PasswordCredential in case we need to fall back to it
                        //
                        if ( credentialSet[i]->Type == CRED_TYPE_DOMAIN_PASSWORD ) {
                            PasswordCredential = credentialSet[i];
                        }
                    }

                    if (OldCredential == NULL)
                    {
                        Result = ERROR_NOT_FOUND;
                    }
                    else
                    {
                        Result = ERROR_SUCCESS;
                    }
                }
                else
                {
                    Result = GetLastError();
                }
            }

            //
            // We don't have a target info
            //  read each of the possible credential types
            //

            else
            {

                if (!(Flags & CREDUI_FLAGS_EXCLUDE_CERTIFICATES) &&
                    ((SecurityContext == NULL) ||
                        (credentialName.CredentialType ==
                            CRED_TYPE_DOMAIN_CERTIFICATE)) &&
                    *UserOrTargetName != '\0' &&
                    LocalCredReadW(UserOrTargetName,
                             CRED_TYPE_DOMAIN_CERTIFICATE,
                             0,
                             &credential))
                {
                    if (CreduiIsSpecialCredential(credential))
                    {
                        LocalCredFree(static_cast<VOID *>(credential));
                        credential = NULL;
                    }
                    else
                    {
                        OldCredential = credential;
                    }
                }

                if ( ( Flags & (CREDUI_FLAGS_REQUIRE_CERTIFICATE|CREDUI_FLAGS_REQUIRE_SMARTCARD)) == 0 ) {
                    if ( OldCredential == NULL &&
                         ((SecurityContext == NULL) ||
                            (credentialName.CredentialType ==
                                CRED_TYPE_DOMAIN_PASSWORD)) &&
                        *UserOrTargetName != '\0' &&
                        LocalCredReadW(UserOrTargetName,
                                 CRED_TYPE_DOMAIN_PASSWORD,
                                 0,
                                 &credential))
                    {
                        if (CreduiIsSpecialCredential(credential))
                        {
                            LocalCredFree(static_cast<VOID *>(credential));
                            credential = NULL;
                        }
                        else
                        {
                            PasswordCredential = credential;

                            OldCredential = credential;

                            Result = ERROR_SUCCESS;
                        }
                    }

                    if ( OldCredential == NULL &&
                         ((SecurityContext == NULL) ||
                            (credentialName.CredentialType ==
                                CRED_TYPE_DOMAIN_VISIBLE_PASSWORD)) &&
                        *UserOrTargetName != '\0' &&
                        LocalCredReadW(UserOrTargetName,
                                 CRED_TYPE_DOMAIN_VISIBLE_PASSWORD,
                                 0,
                                 &credential))
                    {
                        if (CreduiIsSpecialCredential(credential))
                        {
                            LocalCredFree(static_cast<VOID *>(credential));
                            credential = NULL;
                        }
                        else
                        {
                            OldCredential = credential;

                            Result = ERROR_SUCCESS;
                        }
                    }
                }

                if (OldCredential == NULL)
                {
                    Result = GetLastError();
                }
                else
                {
                    fInitialSaveState = TRUE;   // ISSUE: this set at this point has no effect
                    Result = ERROR_SUCCESS;
                }
            }
        }

        if (Result == ERROR_SUCCESS)
        {

            NewCredential = *OldCredential;

            // if we have an existing cred, set the save state
            if (OldCredential != NULL)
            {
                fInitialSaveState = TRUE;   // ISSUE: this set at this point has no effect
            }


            // If a user name was not passed, copy the user name and password
            // from the existing credential:

            if (UserName[0] == L'\0')
            {
                if (OldCredential->UserName != NULL)
                {
                    StringCchCopyW(
                        UserName,
                        UserNameMaxChars + 1,
                        OldCredential->UserName);
                }

                if (Password[0] == L'\0')
                {
                    if ((OldCredential->Type == CRED_TYPE_GENERIC) )
                    {
                        CopyMemory(
                            Password,
                            OldCredential->CredentialBlob,
                            OldCredential->CredentialBlobSize);

                        Password[OldCredential->
                            CredentialBlobSize >> 1] = L'\0';

                    }
                    else if (OldCredential->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD)
                    {
                        // check to see if the new one should be encrypted, but in any case, we can't prefill
                        // the password box
                        EncryptedVisiblePassword = IsPasswordEncrypted(OldCredential->CredentialBlob,
                                                                       OldCredential->CredentialBlobSize);
                        PasswordState = PASSWORD_CHANGED;
                    }
                    else
                    {
                        // If prompt is required now, or if we're rerturning the password, then we can't prefill the
                        // password box:
                        fInitialSaveState = TRUE;       // ISSUE: this set at this point has no effect

                        if (OldCredential->Flags & CRED_FLAGS_PROMPT_NOW || DelayCredentialWrite )
                        {
                            PasswordState = PASSWORD_CHANGED;
                        }
                        else
                        {
                            StringCchCopyW(
                                Password,
                                PasswordMaxChars + 1,
                                CreduiKnownPassword);
                        }
                    }

                }
            }
        }
        else
        {
            if (Result != ERROR_NO_SUCH_LOGON_SESSION)
            {
                Result = ERROR_SUCCESS;
            }

            OldCredential = NULL;

            SetCredTargetFromInfo();


            PasswordState = PASSWORD_CHANGED;
        }

        NewCredential.UserName = UserName;
        NewCredential.CredentialBlob = reinterpret_cast<BYTE *>(Password);

        //
        // Since the old cred is an SSO cred,
        //  use the SSO maximum persistence.
        //
        // Wait till now since NewCredential.Type is updated from either the old credential
        //  or from the target info above.
        //
        // BUGBUG: If there is no old credential or target info,
        //  we won't know this until later.
        //
        if ( NewCredential.Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD ) {
            MaximumPersist = MaximumPersistSso;
        }

        //
        // If the session type isn't supported on this machine,
        //  fail if the caller needs to save the credential.
        //

        if ( MaximumPersist == CRED_PERSIST_NONE ) {
            if ( DelayCredentialWrite )
            {
                // no credmgr available, and user asked to persist.  We can't persist, but we
                // can continue with UI and return values via the api - add CREDUI_FLAGS_DO_NOT_PERSIST
                Flags |= CREDUI_FLAGS_DO_NOT_PERSIST;

            }
            else
            {
                // we can't do anything without credmgr, return error
                if ( result != NULL )
                    *result = ERROR_NO_SUCH_LOGON_SESSION;
                return;
            }
        }
    }

    //
    // If the cred may not be persisted,
    //  clear the NewCredential.
    //

    if ( Flags & CREDUI_FLAGS_DO_NOT_PERSIST)
    {
        // NEED TO Initialize NewCred here
        ZeroMemory(&NewCredential, sizeof NewCredential);

        SetCredTargetFromInfo();
        PasswordState = PASSWORD_CHANGED;
        NewCredential.UserName = UserName;
        NewCredential.CredentialBlob = reinterpret_cast<BYTE *>(Password);

        Result = ERROR_SUCCESS;
    }

    if (Result == ERROR_SUCCESS)
    {
        HWND parentWindow = UiInfo.hwndParent;
        CreduiIconParentWindow iconWindow;

        if ((parentWindow == NULL) || !IsWindow(parentWindow))
        {
            if (iconWindow.Init(CreduiInstance, IDI_DEFAULT))
            {
                parentWindow = iconWindow.GetWindow();
            }
        }

        BOOL doPasswordDialog = TRUE;

        // Before doing the dialog, check for special errors:

        if ( CredCategory == DOMAIN_CATEGORY &&
             !DoingCommandLine &&
             CREDUIP_IS_EXPIRED_ERROR( authError ) &&
            (OldCredential != NULL))
        {
            if (CreduiChangeDomainPassword(
                    parentWindow,
                    UserName,
                    Password,
                    PasswordMaxChars))
            {
                doPasswordDialog = FALSE;

                // Attempt to write the new credential, first get the length.
                // The blob does not include the terminating NULL:

                NewCredential.CredentialBlobSize =
                    wcslen(Password) * sizeof (WCHAR);

                // If the password is empty, do not write a credential blob:

                if (NewCredential.CredentialBlobSize == 0)
                {
                    NewCredential.CredentialBlob = NULL;
                }
                else
                {
                    NewCredential.CredentialBlob =
                        reinterpret_cast<BYTE *>(Password);
                }

                Result = FinishHandleOk();
            }
        }

        // Check to see if we can skip the UI:

        if ( CredCategory == GENERIC_CATEGORY &&
            !(Flags & CREDUI_FLAGS_ALWAYS_SHOW_UI) &&
            (OldCredential != NULL) &&
            !(OldCredential->Flags & CRED_FLAGS_PROMPT_NOW))
        {
            doPasswordDialog = FALSE;

            if ((Flags & CREDUI_FLAGS_REQUIRE_CERTIFICATE) &&
                !LocalCredIsMarshaledCredentialW(OldCredential->UserName))
            {
                doPasswordDialog = TRUE;
            }

            if ((Flags & CREDUI_FLAGS_EXCLUDE_CERTIFICATES) &&
                LocalCredIsMarshaledCredentialW(OldCredential->UserName))
            {
                doPasswordDialog = TRUE;
            }
        }

        // Do the dialog box:

        // check to see if this is an SSO cred
        if ( GetSSOPackageInfo( TargetInfo, &SSOPackage ) )
        {
            // it's an sso cred
            dwIDDResource = IDD_BRANDEDPASSWORD;

            // we never set initial save state on these
            fInitialSaveState = FALSE;              // ISSUE: this set at this point has no effect

            // check to see if we already have a cred for this
            if (!CheckForSSOCred( NULL ))
            {


                // check to see if we should run the wizard
                if ( !(SSOPackage.dwRegistrationCompleted) && (SSOPackage.dwNumRegistrationRuns < 5) )
                {


                    doPasswordDialog = !TryLauchRegWizard ( &SSOPackage, UiInfo.hwndParent, (MaximumPersistSso > CRED_PERSIST_SESSION),
                                                           userName, userNameMaxChars,
                                                           password, passwordMaxChars,
                                                           &Result );

                }
            }
        }
        else
        {

            // it's not an sso cred
           dwIDDResource = IDD_PASSWORD;
        }


        // save a copy of the current working user name for later
        if (NewCredential.UserName != NULL)
        {
            StringCchCopyW(
                OldUserName,
                RTL_NUMBER_OF(OldUserName),
                NewCredential.UserName);
        }
        else
        {
            OldUserName[0] = 0;
        }

        if (doPasswordDialog)
        {
            if ( DoingCommandLine ) 
            {

                //
                // Do the command line version of a dialog box
                //

                Result = CmdLineDialog();

            } 
            else 
            {
       	        LinkWindow_RegisterClass();
                if (DialogBoxParam(
                        CreduiInstance,
                        MAKEINTRESOURCE(dwIDDResource),
                        parentWindow,
                        DialogMessageHandlerCallback,
                        reinterpret_cast<LPARAM>(this)) == IDOK)
                {
                    if ((Result != ERROR_SUCCESS) &&
                        (Result != ERROR_NO_SUCH_LOGON_SESSION))
                    {
                        Result = ERROR_CANCELLED;
                    }
                }
                else
                {
                    Result = ERROR_CANCELLED;
                }
            }
        }

    }
    else
    {
        Result = ERROR_NO_SUCH_LOGON_SESSION;
    }

    // kill outbound username if share-level access
    if (fPasswordOnly)
    {
        CreduiDebugLog("CUIPD: Share level credentials\n");
        userName[0] = 0;
    }

    // Make sure other processes can set foreground window once again:

    LockSetForegroundWindow(LSFW_UNLOCK);
    AllowSetForegroundWindow(ASFW_ANY);

    if (TargetInfo != NULL)
    {
        LocalCredFree(static_cast<VOID *>(TargetInfo));
    }

    // If we read a credential set, PasswordCredential
    // is a pointer into this set. Otherwise, they were
    // read separately:

    if (credentialSet != NULL)
    {
        LocalCredFree(static_cast<VOID *>(credentialSet));
    }
    else
    {
        if (PasswordCredential != NULL)
        {
            LocalCredFree(static_cast<VOID *>(PasswordCredential));
        }

    }

    if ( result != NULL )
        *result = Result;

    if ( save != NULL &&
        (Result == ERROR_SUCCESS))
    {
        *save = Save;
    }
}

//=============================================================================
// CreduiPasswordDialog::~CreduiPasswordDialog
//
// The constructor cleans up after itself, and since that is the only way to
// use this class, there's nothing to do in the destructor.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

CreduiPasswordDialog::~CreduiPasswordDialog()
{
    WCHAR ClassName[] = {L"CreduiCmdLineHelperWindow"};
    LONG lRet;
    
    if ( hBrandBmp != NULL )
        DeleteObject ( hBrandBmp );
    
    // If 'Registered' is nonzero, unregister the class
    if (InterlockedCompareExchange(&Registered, FALSE, TRUE))
    {
        lRet = UnregisterClass(ClassName, 0);
        // Put the class handle back if deregister failed
        if (0 == lRet) 
        {
            // If the unregister fails, allow other instances to retry the unregister
            CreduiDebugLog( "CreduiPasswordDialog::~CreduiPasswordDialog UnregisterClass failed.\n" );
            // put back the flag value that we had destroyed
            InterlockedExchange(&Registered,TRUE);
        }
    }
}


#define MAX_TEMP_TARGETNAME  64


DWORD
CreduiPasswordDialog::CmdLineDialog(
    VOID
)
/*++

Routine Description:

    This routine implements the command line prompt for credentials

Arguments:

    None
Return Values:

    Win 32 status of the operation

--*/
{
    DWORD WinStatus;
    HWND Window;
    MSG msg;


    //
    // Create the window class if it doesn't already exist
    //
    if (!InterlockedCompareExchange(&Registered, TRUE, FALSE))
    {
        WNDCLASS windowClass;

        ZeroMemory(&windowClass, sizeof windowClass);

        windowClass.style = CS_GLOBALCLASS;
        windowClass.cbWndExtra = 0;
        windowClass.lpfnWndProc = CmdLineMessageHandlerCallback;
        windowClass.hInstance = CreduiInstance;
        windowClass.hIcon = NULL;
        windowClass.hCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
        windowClass.lpszClassName = L"CreduiCmdLineHelperWindow";

        InterlockedExchange(&Registered, RegisterClass(&windowClass) != 0);

        if (!InterlockedCompareExchange(&Registered, FALSE, FALSE)) 
        {
            WinStatus = GetLastError();
            goto Cleanup;
        }
    }

    //
    // Create a window of that class
    //

    Window = CreateWindow(
        L"CreduiCmdLineHelperWindow",
        NULL,
        WS_POPUP,
        0, 0, 0, 0,
        NULL, NULL, CreduiInstance,(LPVOID) this);

    if ( Window == NULL ) 
    {
        WinStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Run the message loop
    //


    CreduiDebugLog( "Entering message loop\n" );
    for (;;) {
        BOOL GmStatus;

        GmStatus = GetMessage(&msg, NULL, 0, 0 );

        if ( GmStatus == -1 ) 
        {
            WinStatus = GetLastError();
            break;
        } 
        else if ( GmStatus == 0 ) 
        {
            WinStatus = Result;
            break;
        }

        DispatchMessage(&msg);
    }

    //
    // Get the status left from the message loop.

    WinStatus = (DWORD) msg.wParam;
    CreduiDebugLog( "Got Quit Message: %ld\n", WinStatus );

    //
    // Process the data as though the user hit OK to the GUI
    //

    if ( WinStatus == NO_ERROR ) {

        PasswordState = PASSWORD_CHANGED;

        WinStatus = HandleOk();

        if ( WinStatus == ERROR_NO_SUCH_LOGON_SESSION) 
        {
            WinStatus = ERROR_CANCELLED;
        }
    }

    CreduiDebugLog( "Calling destroy\n" );
    DestroyWindow( Window );

Cleanup:
    return WinStatus;
}

//=============================================================================
// CreduiPasswordDialog::FinishHandleOk
//
// This function writes the credential for domain credentials.
//
// Created 04/09/2000 johnstep (John Stephens)
//=============================================================================

DWORD
CreduiPasswordDialog::FinishHandleOk()
{

    DWORD error = ERROR_SUCCESS;
    PCREDENTIAL_TARGET_INFORMATION pTargetInfo = TargetInfo;

    if (Flags & CREDUI_FLAGS_KEEP_USERNAME )
        return error;

    DWORD dwCredWriteFlags = 0;
    BOOL bDoSave = TRUE;

    if (PasswordState == PASSWORD_INIT)
    {
        dwCredWriteFlags |= CRED_PRESERVE_CREDENTIAL_BLOB;
    }


    if ( dwIDDResource == IDD_BRANDEDPASSWORD )
    {
        // we need to reinterpret what Save means.  Save in this case means to save as the default
        // for the SSO realm, while !Save means rename the cred target as the username and
        // save without the password

        // never delay writing these creds
        DelayCredentialWrite = FALSE;

        if ( Save )
        {
            NewCredential.Persist = CRED_PERSIST_ENTERPRISE;
            if ( !(Flags & CREDUI_FLAGS_KEEP_USERNAME ))
                DemoteOldDefaultSSOCred ( TargetInfo, Flags );
        }
        else
        {
            // save this under the username if it doesn't already match NewCred's username

            if ( (OldCredential != NULL && OldCredential->UserName != NULL &&
                _wcsicmp ( OldCredential->UserName, UserName ) == 0 )||
                (Flags & CREDUI_FLAGS_KEEP_USERNAME ) )
            {
                // don't do this save if the username matches the currently saved cred - we don't want a duplicate
                bDoSave = FALSE;
            }

            // alter the TargetName
            TargetName = UserName;
            TargetInfo->TargetName = TargetName;

            // don't set a TargetInfo for this
            pTargetInfo = NULL;

            NewCredential.Persist = CRED_PERSIST_ENTERPRISE;
            NewCredential.CredentialBlob = NULL;
            NewCredential.CredentialBlobSize = 0;
            NewCredential.TargetName = TargetName;
            NewCredential.Flags = CRED_FLAGS_USERNAME_TARGET;

            DelayCredentialWrite = FALSE;
            EncryptedVisiblePassword = FALSE;
            dwCredWriteFlags = 0;

        }

    }


    //
    // Write the credential to credential manager
    //
    //  Don't delay actually writing the credential to cred man since we're not
    //  returning the credential to the caller.
    //

    if ( bDoSave )
    {
        error = WriteCred( TargetName,
                            Flags,
                            pTargetInfo,
                            &NewCredential,
                            dwCredWriteFlags,
                            DelayCredentialWrite,
                            EncryptedVisiblePassword);
    }
    else
    {
        error = ERROR_SUCCESS;
    }

    if ( error != NO_ERROR ) {
        CreduiDebugLog("CreduiPasswordDialog::HandleOk: "
                       "WriteCred failed: "
                       "%u\n", error);
    }

    if ((SecurityContext != NULL) && (error == ERROR_SUCCESS))
    {
        BOOL isValidated = TRUE;

        if (!SetContextAttributes(
                SecurityContext,
                SECPKG_ATTR_USE_VALIDATED,
                &isValidated,
                sizeof isValidated))
        {
            error = ERROR_GEN_FAILURE;
        }
    }

    // Clear any password from memory, and also make sure the credential blob
    // points to Password once again (in case it was set to NULL due to a zero
    // length blob):

    NewCredential.CredentialBlob = reinterpret_cast<BYTE *>(Password);
    NewCredential.CredentialBlobSize = 0;

    return error;
}

//=============================================================================
// CreduiPasswordDialog::Enable
//
// Enables or disables all the user controls in the dialog box. This allows us
// to maintain dialog responsiveness, while waiting for some potentially
// lengthy (network usually) operation to complete.
//
// Most controls are always enabled normally, but we need to track the state
// of IDC_CRED and IDOK. Do this with a simple DWORD bitmask.
//
// NOTE: Allow Cancel to remain enabled, and use it to abort the current
//       lookup? This means we have to somehow kill the thread, though, or
//       maybe just leave it, and close our handle to it?
//
// Arguments:
//   enable (in) - TRUE to enable the controls, FALSE to disable.
//
// Created 04/07/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiPasswordDialog::Enable(
    BOOL enable
    )
{
    if (enable && (DisabledControlMask & DISABLED_DIALOG))
    {
        DisabledControlMask &= ~DISABLED_DIALOG;

        EnableWindow(CredControlWindow, TRUE);
        if ( DialogWindow) {
            EnableWindow(GetDlgItem(DialogWindow, IDCANCEL), TRUE);

            if (!(DisabledControlMask & DISABLED_CONTROL_OK))
            {
                EnableWindow(GetDlgItem(DialogWindow, IDOK), TRUE);
            }
        }
    }
    else if (!(DisabledControlMask & DISABLED_DIALOG))
    {
        // Hide the balloon tip before disabling the window:

        DisabledControlMask |= DISABLED_DIALOG;

        EnableWindow(CredControlWindow, FALSE);
        if ( DialogWindow ) {

            EnableWindow(GetDlgItem(DialogWindow, IDCANCEL), FALSE);
            EnableWindow(GetDlgItem(DialogWindow, IDOK), FALSE);
        }
    }
}

//=============================================================================
// CreduiPasswordDialog::SelectAndSetWindowCaption
//
// Created 03/10/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiPasswordDialog::SelectAndSetWindowCaption()
{
    //
    // Command line doesn't have a caption
    //

    if ( !DialogWindow ) {
        return;
    }
    
    if (UiInfo.pszCaptionText != NULL)
    {
        SetWindowText(DialogWindow, UiInfo.pszCaptionText);
    }
    else
    {
        WCHAR captionText[256];

        if ( CredCategory == DOMAIN_CATEGORY )
        {
            if (TargetInfo != NULL)
            {
                if ((TargetInfo->DnsServerName != NULL) ||
                    (TargetInfo->NetbiosServerName == NULL))
                {
                    StringCchPrintfW(
                        captionText,
                        RTL_NUMBER_OF(captionText),
                        CreduiStrings.DnsCaption,
                        (TargetInfo->DnsServerName != NULL) ?
                            TargetInfo->DnsServerName :
                            TargetInfo->TargetName);
                }
                else if ((TargetInfo->NetbiosServerName != NULL) &&
                         (TargetInfo->NetbiosDomainName != NULL))
                {
                    StringCchPrintfW(
                        captionText,
                        RTL_NUMBER_OF(captionText),
                        CreduiStrings.NetbiosCaption,
                        TargetInfo->NetbiosServerName,
                        TargetInfo->NetbiosDomainName);
                }
                else
                {
                    StringCchPrintfW(
                        captionText,
                        RTL_NUMBER_OF(captionText),
                        CreduiStrings.DnsCaption,
                        TargetName);
                }
            }
            else
            {
                StringCchPrintfW(
                    captionText,
                    RTL_NUMBER_OF(captionText),
                    CreduiStrings.DnsCaption,
                    TargetName);
            }
        }
        else
        {
            StringCchPrintfW(
                captionText,
                RTL_NUMBER_OF(captionText),
                CreduiStrings.GenericCaption,
                TargetName);
        }

        SetWindowText(DialogWindow, captionText);
    }
}

//=============================================================================
// CreduiPasswordDialog::ResizeDialogCallback
//
// Created 04/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CALLBACK
CreduiPasswordDialog::ResizeDialogCallback(
    HWND childWindow,
    LPARAM lParam
    )
{
    CreduiPasswordDialog *that =
        reinterpret_cast<CreduiPasswordDialog *>(lParam);

    ASSERT(that != NULL);

    //
    // Command line doesn't care about window size
    //

    if ( that->DoingCommandLine ) {
        return TRUE;
    }


    HWND dialogWindow = GetParent(childWindow);

    if (dialogWindow == NULL)
    {
        // Stop enumeration because our window must have been destroyed or
        // something:

        return FALSE;
    }
    else if (dialogWindow == that->DialogWindow)
    {
        RECT childRect;

        GetWindowRect(childWindow, &childRect);

        // If this child window is below the message window, move it down:

        if (childRect.top >= that->ResizeTop)
        {
            MapWindowPoints ( NULL, dialogWindow,
                                reinterpret_cast<POINT *>(&childRect.left), 2 );

            SetWindowPos(childWindow,
                         NULL,
                         childRect.left,
                         childRect.top + that->ResizeDelta,
                         0,
                         0,
                         SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOOWNERZORDER |
                            SWP_NOZORDER);
        }
    }

    return TRUE;
}

//=============================================================================
// CreduiPasswordDialog::SelectAndSetWindowMessage
//
// This function will also resize the dialog to accomodate very long message
// text. The maximum number of lines allowed at once is
// CREDUI_MAX_WELCOME_TEXT_LINES, and, beyond that, a scrollbar is added.
//
// Created 03/10/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiPasswordDialog::SelectAndSetWindowMessage()
{
    HWND welcomeTextWindow = GetDlgItem(DialogWindow, IDC_WELCOME_TEXT);

    //
    // Command line doesn't have welcome text
    //

    if ( DoingCommandLine ) {
        return;
    }


    ASSERT(welcomeTextWindow != NULL);

    if (UiInfo.pszMessageText != NULL)
    {
        SetWindowText(welcomeTextWindow, UiInfo.pszMessageText);
    }
    else
    {
        WCHAR messageText[256];

        if ( CredCategory == GENERIC_CATEGORY )
        {
            if (UserName[0] == L'\0')
            {
                StringCchPrintfW(
                    messageText,
                    RTL_NUMBER_OF(messageText),
                    CreduiStrings.Welcome,
                    TargetName);
            }
            else
            {
                StringCchPrintfW(
                    messageText,
                    RTL_NUMBER_OF(messageText),
                    CreduiStrings.WelcomeBack,
                    TargetName);
            }
        }
        else
        {
            StringCchPrintfW(
                messageText,
                RTL_NUMBER_OF(messageText),
                CreduiStrings.Connecting,
                TargetName);
        }

        SetWindowText(welcomeTextWindow, messageText);
    }

    ULONG lineCount = (ULONG) SendMessage(welcomeTextWindow,
                                          EM_GETLINECOUNT,
                                          0,
                                          0);
    if (lineCount > 1)
    {
        if ( dwIDDResource == IDD_BRANDEDPASSWORD )
        {
            // Different layout (text to side of graphic)
            RECT messageRect;         // RECT for welcomeTextWindow
            ULONG lineHeight = 13;    // Height of line in welcomeTextWindow
            DWORD lineIndex = 0;      // Character index of first char in second line of welcomeTextWindow
            DWORD linePos = 0;        // Position of first char in second line of welcomeTextWindow

            GetWindowRect(welcomeTextWindow, &messageRect);

            // We don't want to resize anything for the branded password dialog
            ResizeDelta = 0;
            ResizeTop = messageRect.bottom;

            // Get the first character index of the second line
            lineIndex = (DWORD)SendMessage(welcomeTextWindow, EM_LINEINDEX, 1, 0);
            if (lineIndex > -1)
            {
                // Get the position of the first character of the second line
                linePos = (ULONG)SendMessage(welcomeTextWindow, EM_POSFROMCHAR, lineIndex, 0);

                if (linePos)
                {
                    // This is our line height
                    lineHeight = (ULONG)HIWORD(linePos);
                }
            }

            if ((lineCount * lineHeight) > CREDUI_MAX_LOGO_HEIGHT)
            {
                // Add the scrollbar. Consider adjusting the formatting rectangle
                // of the edit control because, by default, it is adjusted to
                // allow just exactly enough room for the scrollbar. This means
                // text could potentially "touch" the scrollbar, which would look
                // bad.

                LONG_PTR style = GetWindowLongPtr(welcomeTextWindow, GWL_STYLE);

                SetWindowLongPtr(welcomeTextWindow,
                                 GWL_STYLE,
                                 style |= WS_VSCROLL);
            }

            SetWindowPos(welcomeTextWindow,
                         NULL,
                         0,
                         0,
                         messageRect.right - messageRect.left,
                         messageRect.bottom - messageRect.top,
                         SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE |
                             SWP_NOOWNERZORDER | SWP_NOZORDER);


        }
        else
        {
            // normal layout (text below graphic)
            RECT messageRect;

            GetWindowRect(welcomeTextWindow, &messageRect);

            ULONG lineHeight = messageRect.bottom - messageRect.top;

            ResizeTop = messageRect.bottom;
            ResizeDelta = lineHeight *
                          (min(CREDUI_MAX_WELCOME_TEXT_LINES, lineCount) - 1);

            messageRect.bottom += ResizeDelta;

            if (lineCount > CREDUI_MAX_WELCOME_TEXT_LINES)
            {
                // Add the scrollbar. Consider adjusting the formatting rectangle
                // of the edit control because, by default, it is adjusted to
                // allow just exactly enough room for the scrollbar. This means
                // text could potentially "touch" the scrollbar, which would look
                // bad.

                LONG_PTR style = GetWindowLongPtr(welcomeTextWindow, GWL_STYLE);

                SetWindowLongPtr(welcomeTextWindow,
                                 GWL_STYLE,
                                 style |= WS_VSCROLL);
            }

            SetWindowPos(welcomeTextWindow,
                         NULL,
                         0,
                         0,
                         messageRect.right - messageRect.left,
                         messageRect.bottom - messageRect.top,
                         SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE |
                             SWP_NOOWNERZORDER | SWP_NOZORDER);

        }

        // Reposition all the other controls:

        EnumChildWindows(DialogWindow,
                         ResizeDialogCallback,
                         reinterpret_cast<LPARAM>(this));

        // Resize the dialog box now
        RECT dialogRect;

        GetWindowRect(DialogWindow, &dialogRect);

        SetWindowPos(DialogWindow,
                      NULL,
                      dialogRect.left,
                      dialogRect.top - (ResizeDelta / 2),
                      dialogRect.right - dialogRect.left,
                      (dialogRect.bottom - dialogRect.top) + ResizeDelta,
                      SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);

        ResizeTop = 0;
        ResizeDelta = 0;
    }
}

//=============================================================================
// CreduiPasswordDialog::InitWindow
//
// Created 02/25/2000 johnstep (John Stephens)
//
// Initialize the window
//
// dialogWindow - Window handle
//=============================================================================

BOOL
CreduiPasswordDialog::InitWindow(HWND dialogWindow)
{


    //
    // Store this object's pointer in the user data window long:
    //

    SetWindowLongPtr(dialogWindow,
                     GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(this));

    //
    // In the GUI case, remember the dialog box window
    //

    if ( !DoingCommandLine ) {
        DialogWindow = dialogWindow;

        // Get the window handles for the various controls:

        CredControlWindow = GetDlgItem(DialogWindow, IDC_CRED);

    //
    // In the command line case, remember the popup window
    //

    } else {
        CmdLineWindow = dialogWindow;

        //
        // Create a CredControlWindow
        //  It isn't visible, but the existence of the window allows the command line
        //  code to share logic with the GUI implementation
        //

        CredControlWindow =
            CreateWindowEx(
                WS_EX_NOPARENTNOTIFY,
                WC_CREDENTIAL,
                NULL,           // No window name
                WS_CHILD | WS_GROUP,
                0, 0, 0, 0,     // No coordinates on the screen
                CmdLineWindow,  // Parent window
                NULL,           // No menu window
                CreduiInstance,
                NULL);

        if ( CredControlWindow == NULL) {
            return FALSE;
        }
    }

    ASSERT(CredControlWindow != NULL);

    //
    // First, initialize the Credential control window:
    //
    // Set the default style
    //


    if (Flags & CREDUI_FLAGS_REQUIRE_SMARTCARD)
    {
        CredControlStyle = CRS_SMARTCARDS;
    }
    else if (Flags & CREDUI_FLAGS_REQUIRE_CERTIFICATE)
    {
        CredControlStyle = CRS_CERTIFICATES | CRS_SMARTCARDS;
    }
    else if (Flags & CREDUI_FLAGS_EXCLUDE_CERTIFICATES)
    {
        CredControlStyle = CRS_USERNAMES;
    }
    else
    {
        CredControlStyle = CRS_USERNAMES | CRS_CERTIFICATES | CRS_SMARTCARDS;
    }

    if (Flags & CREDUI_FLAGS_KEEP_USERNAME )
    {
        CredControlStyle |= CRS_KEEPUSERNAME;
    }


    //
    // If we have a target info,
    //  refine the style to match match what the auth package needs
    //
    // If the auth package has no opinion of its needs, allow everything.
    //
    if ( CredCategory == DOMAIN_CATEGORY &&
        TargetInfo != NULL &&
        TargetInfo->CredTypeCount != 0 )
    {
        ULONG AuthPackageStyle;
        AuthPackageStyle = 0;

        //
        // Loop through the supported cred types seeing what style the auth package supports
        //

        for (UINT i = 0; i < TargetInfo->CredTypeCount; ++i)
        {
            switch ( TargetInfo->CredTypes[i] ) {
            case CRED_TYPE_DOMAIN_CERTIFICATE:
                AuthPackageStyle |= CRS_CERTIFICATES | CRS_SMARTCARDS;
                break;
            case CRED_TYPE_DOMAIN_PASSWORD:
            case CRED_TYPE_DOMAIN_VISIBLE_PASSWORD:
                AuthPackageStyle |= CRS_USERNAMES;
                break;
            }

        }

        CredControlStyle &= (AuthPackageStyle | CRS_KEEPUSERNAME );
        ASSERT( CredControlStyle != 0);

    }

    //
    // If the caller wants only administrators,
    //  include that request in the style.
    //

    if (Flags & CREDUI_FLAGS_REQUEST_ADMINISTRATOR)
    {
        CredControlStyle |= CRS_ADMINISTRATORS;
    }


    //
    // If the caller asked to see the save checkbox,
    //  and we're running in a session that supports saving,
    //  include the save checkbox in the style
    //
    if ( (Flags & (CREDUI_FLAGS_DO_NOT_PERSIST|CREDUI_FLAGS_PERSIST)) == 0 &&
         !(Flags & CREDUI_FLAGS_KEEP_USERNAME ) &&
         MaximumPersist != CRED_PERSIST_NONE )
    {
        CredControlStyle |= CRS_SAVECHECK;

    }
    //
    // If the caller wants us to prompt for saving and return the result to him,
    //  include the save checkbox in the style
    //
    // This is for the occasion that an application uses credui to harvest credentials from the 
    //  user, and wants username, password, and save preference back.  Credui, however,
    //  is not to attempt to save the cred... that will be done by the application.
    //
    // TESTNOTE: Pass both flags, observe correct state returned by Save, but no call to
    //  credwrite from credui. (Credui does not itself attempt to save the cred)
    //
    else if ( (Flags & (CREDUI_FLAGS_DO_NOT_PERSIST|CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX)) ==
                       (CREDUI_FLAGS_DO_NOT_PERSIST|CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX) &&
                       !(Flags & CREDUI_FLAGS_KEEP_USERNAME ))
    {
        CredControlStyle |= CRS_SAVECHECK;
    }

    //
    // If we're not displaying the save checkbox,
    //  adust the size of the dialog box.
    //

    if ( (CredControlStyle & CRS_SAVECHECK) == 0 &&
         DialogWindow != NULL ) 
     {


        RECT rect;
        SetRect(&rect, 0, 0, 0, 0);

        rect.bottom = CREDUI_CONTROL_ADD_SAVE;

        MapDialogRect(DialogWindow, &rect);
        ResizeDelta = -rect.bottom;

        GetWindowRect(CredControlWindow, &rect);
        ResizeTop = rect.bottom;

        // Reposition all the other controls:

        EnumChildWindows(DialogWindow,
                         ResizeDialogCallback,
                         reinterpret_cast<LPARAM>(this));

        // Resize the dialog box now:

        GetWindowRect(DialogWindow, &rect);

        SetWindowPos(DialogWindow,
                     NULL,
                     rect.left,
                     rect.top - (ResizeDelta / 2),
                     rect.right - rect.left,
                     (rect.bottom - rect.top) + ResizeDelta,
                     SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);


        GetClientRect(CredControlWindow, &rect);

        SetWindowPos(CredControlWindow,
                     NULL,
                     0,
                     0,
                     rect.right - rect.left,
                     (rect.bottom - rect.top) + ResizeDelta,
                     SWP_NOMOVE | SWP_NOACTIVATE |
                     SWP_NOOWNERZORDER | SWP_NOZORDER);

        ResizeTop = 0;
        ResizeDelta = 0;

    }

if ( dwIDDResource == IDD_BRANDEDPASSWORD )
    {
        // size the parts of the brand
        RECT rect;
        RECT rectleft;
        RECT rectright;
        RECT rectmid;
        HWND hwndRight = GetDlgItem(DialogWindow, IDC_BRANDRIGHT);
        HWND hwndMid = GetDlgItem(DialogWindow, IDC_BRANDMID);
        HWND hwndLeft = GetDlgItem(DialogWindow, IDC_BRANDLEFT);
        HBITMAP hBmp;

        GetWindowRect(hwndRight, &rect);

        // Load the images from files
        // We can't load them in the .rc because then we lose transparency
        hBmp = (HBITMAP)LoadImage(CreduiInstance, MAKEINTRESOURCE(IDB_BRANDRIGHT), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION); 
        if (hBmp)
        {
            SendMessage(hwndRight, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBmp);
        }
        
        hBmp = (HBITMAP)LoadImage(CreduiInstance, MAKEINTRESOURCE(IDB_BRANDMID), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
        if (hBmp)
        {
            if (hwndMid)
            {
                SendMessage(hwndMid, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBmp);
            }
        }

        hBmp = (HBITMAP)LoadImage(CreduiInstance, MAKEINTRESOURCE(IDB_BRANDLEFT), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
        if (hBmp)
        {
            if (hwndLeft)
            {
                SendMessage(hwndLeft, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBmp);
            }
        }

        rectright.bottom = rect.bottom;
        rectright.top = rect.bottom - BRANDRIGHT_PIXEL_HEIGHT;
        rectright.right = rect.right;
        rectright.left = rect.right - BRANDRIGHT_PIXEL_WIDTH;

        rectleft.bottom = rect.bottom;
        rectleft.top = rect.bottom - BRANDLEFT_PIXEL_HEIGHT;
        rectleft.left = rect.left;
        rectleft.right = rect.left + BRANDLEFT_PIXEL_WIDTH;

        MapWindowPoints(NULL, DialogWindow, (LPPOINT)&rectleft, 2);
        MapWindowPoints(NULL, DialogWindow, (LPPOINT)&rectright, 2);

        if ( rectleft.right >= rectright.left )
        {
            // dialog is really narrow, just use rectright

            // hide the other two
            ShowWindow ( hwndMid, SW_HIDE );
            ShowWindow ( hwndLeft, SW_HIDE );

        }
        else
        {

            // calculate rectmid
            rectmid.bottom = rectleft.bottom;
            rectmid.top = rectleft.bottom - BRANDMID_PIXEL_HEIGHT;
            rectmid.left = rectleft.right;
            rectmid.right = rectright.left;

            // No need to MapWindowsPoints for rectmid, since it's base off of the already-mapped rects.
            SetWindowPos(hwndMid,
                         NULL,
                         rectmid.left,
                         rectmid.top,
                         rectmid.right - rectmid.left,
                         rectmid.bottom - rectmid.top,
                         SWP_NOACTIVATE | SWP_NOOWNERZORDER |
                            SWP_NOZORDER);

            SetWindowPos(hwndLeft,
                         NULL,
                         rectleft.left,
                         rectleft.top,
                         rectleft.right - rectleft.left,
                         rectleft.bottom - rectleft.top,
                         SWP_NOACTIVATE | SWP_NOOWNERZORDER |
                            SWP_NOZORDER);

        }


        SetWindowPos(hwndRight,
                     NULL,
                     rectright.left,
                     rectright.top,
                     rectright.right - rectright.left,
                     rectright.bottom - rectright.top,
                     SWP_NOACTIVATE | SWP_NOOWNERZORDER |
                        SWP_NOZORDER);



    }

    //
    // Tell the control window the style flags and whether we're doing command line
    //
    if (!SendMessage(CredControlWindow, CRM_INITSTYLE, (WPARAM)(CredControlStyle), DoingCommandLine ) )
    {
        return FALSE;
    }

    // If a custom banner bitmap was provided, set it now, and free the
    // default bitmap:

    if ( DialogWindow != NULL && UiInfo.hbmBanner != NULL)
    {
        HWND bannerControlWindow = GetDlgItem(DialogWindow, IDC_BANNER);

        ASSERT(bannerControlWindow != NULL);

        HBITMAP oldBitmap =
            reinterpret_cast<HBITMAP>(
                SendMessage(
                    bannerControlWindow,
                    STM_SETIMAGE,
                    IMAGE_BITMAP,
                    reinterpret_cast<LPARAM>(UiInfo.hbmBanner)));

        ASSERT(oldBitmap != NULL);

        DeleteObject(static_cast<HGDIOBJ>(oldBitmap));
    }
    else if ( DialogWindow != NULL && dwIDDResource == IDD_BRANDEDPASSWORD )
    {
        // if it's branded and there's no banner, hide the banner control
        HWND bannerControlWindow = GetDlgItem(DialogWindow, IDC_BANNER);

        if (bannerControlWindow != NULL)
        {
            ShowWindow ( bannerControlWindow, SW_HIDE );
        }

    }

    // Limit the number of characters entered into the user name and password
    // edit controls:
    Credential_SetUserNameMaxChars(CredControlWindow, UserNameMaxChars);
    Credential_SetPasswordMaxChars(CredControlWindow, PasswordMaxChars);

    SelectAndSetWindowCaption();
    SelectAndSetWindowMessage();

    //
    // Set the default check box states
    //  Default to don't save.  That ensures the user has to take an action to
    //  change global state.
    //
    //
    // If the caller is specifying the default value of the checkbox,
    //  grab that default
    //

    fInitialSaveState = FALSE;

    // Force initial save state to false if SSO
    if (Flags & CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX)
    {
        if (dwIDDResource != IDD_BRANDEDPASSWORD)
        {
            fInitialSaveState = Save;
        }
        else
        {
            fInitialSaveState = FALSE;
        }
    //
    // Only save if credman is available
    //
    } 
    else if ( MaximumPersist != CRED_PERSIST_NONE ) 
    {
        //
        // If the caller is forcing the save flag on,
        //  default the save flag to TRUE.
        //
        if ( Flags & CREDUI_FLAGS_PERSIST ) 
        {
            fInitialSaveState = TRUE;
        }
    }

    Credential_CheckSave(CredControlWindow, fInitialSaveState);

    // Make sure the new password window is the foreground window, if
    // possible:

    if ( DialogWindow != NULL ) {
        AllowSetForegroundWindow(GetCurrentProcessId());
        SetForegroundWindow(DialogWindow);
        AllowSetForegroundWindow(ASFW_ANY);
    }

    // NOTE: Do we really need the guest user name here?

    if ((TargetInfo != NULL) && (UserName[0] == L'\0'))
    {
        if (TargetInfo->Flags & CRED_TI_ONLY_PASSWORD_REQUIRED)
        {
            LPWSTR ServerName = NULL;

            if ( TargetInfo->NetbiosServerName != NULL ) {
                ServerName = TargetInfo->NetbiosServerName;

            } else if ( TargetInfo->DnsServerName != NULL &&
                (TargetInfo->Flags & CRED_TI_SERVER_FORMAT_UNKNOWN) != 0 ) {

                ServerName = TargetInfo->DnsServerName;
            }


            if ( ServerName != NULL )
            {
                LPWSTR GuestName;

                if ( !CreduiLookupLocalNameFromRid( DOMAIN_USER_RID_GUEST, &GuestName ) ) {
                    GuestName = NULL;
                }

                StringCchPrintfW(
                    UserName,
                    UserNameMaxChars + 1,
                    L"%s\\%s",
                    ServerName,
                    GuestName == NULL ? L"Guest" : GuestName);

                delete GuestName;

            }
        }
        else
        {
            if ( DialogWindow ) {
                EnableWindow(GetDlgItem(DialogWindow, IDOK), FALSE);
            }
            
            DisabledControlMask |= DISABLED_CONTROL_OK;
        }
    }

    if ((UserName[0] != L'\0') || (Password[0] != L'\0'))
    {
        // If this fails, it may be because the certificate was not found in
        // the store, so if this is a domain credential, use the password one,
        // if available:
        BOOL isMarshaled = LocalCredIsMarshaledCredentialW(UserName);

        if (Credential_SetUserName(CredControlWindow, UserName))
        {
            if (!isMarshaled)
            {
                Credential_SetPassword(CredControlWindow, Password);
            }
            if (TargetInfo)
            {
                if (TargetInfo->Flags & CRED_TI_ONLY_PASSWORD_REQUIRED)
                {
                    Credential_DisableUserName(CredControlWindow);
                    // when disabling the username field, prepare to return no username to the caller
                    if (Flags & CREDUI_FLAGS_PASSWORD_ONLY_OK)
                    {
                        fPasswordOnly = TRUE;
                        CreduiDebugLog("CreduiPasswordDialog::InitWindow - Password only share\n");
                    }
                }
            }
        }
        else
        {
            if ( CredCategory == DOMAIN_CATEGORY &&
                 isMarshaled &&
                 (PasswordCredential != NULL))
            {
                OldCredential = PasswordCredential;

                // Change as little as possible about the new credential
                // because we already selected the target name, etc.:

                if (OldCredential->UserName != NULL)
                {
                    StringCchCopyW(
                        UserName,
                        UserNameMaxChars + 1,
                        OldCredential->UserName);
                }
                else
                {
                    UserName[0] = L'\0';
                }

                Password[0] = L'\0';

                Credential_SetPassword(CredControlWindow, Password);
            }
            else
            {
                UserName[0] = L'\0';
                Password[0] = L'\0';
            }
        }

        if (PasswordState == PASSWORD_UNINIT)
        {
            PasswordState = PASSWORD_INIT;
        }

        if (UserName[0] != L'\0')
        {
            Credential_SetPasswordFocus(CredControlWindow);

            if (Flags & CREDUI_FLAGS_INCORRECT_PASSWORD)
            {
                if (CreduiIsCapsLockOn())
                {
                    CredBalloon = &CreduiLogonCapsBalloon;
                }
                else
                {
                    CredBalloon = &CreduiLogonBalloon;
                }
            }
        }
    }


    if (Flags & CREDUI_FLAGS_KEEP_USERNAME )
    {
        // okay button should always be enabled for this case
        EnableWindow(GetDlgItem(DialogWindow, IDOK), TRUE);
        DisabledControlMask &= ~DISABLED_CONTROL_OK;
    }

    return TRUE;
}

//=============================================================================
// CreduiPasswordDialog::CompleteUserName
//
// Searches the user name for a domain name, and determines whether this
// specifies the target server or a domain. If a domain is not present in the
// user name, add it if this is a workstation or no target information is
// available.
//
// Returns TRUE if a domain was already present in the user name, or if we
// added one. Otherwise, return FALSE.
//
// Created 03/10/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiPasswordDialog::CompleteUserName()
{

    return ::CompleteUserName(
                UserName,
                UserNameMaxChars,
                TargetInfo,
                TargetName,
                Flags);

}

//=============================================================================
// CreduiPasswordDialog::SelectBestTargetName
//
// Given TargetInfo, this function determines the most general target name
// possible, and stores the result in NewTargetName. If a target alias is
// available (NetBIOS name for a DNS name), this will be stored in
// NewTargetAlias. If the wildcard won't fit within the required string
// length, then it is not used.
//
// If serverOnly then, use the target information form of the target name,
// with the user-typed name as the alias. If unavailable, just use the user-
// typed form with a NULL alias.
//
// Created 03/10/2000 johnstep (John Stephens)
//=============================================================================

VOID
CreduiPasswordDialog::SelectBestTargetName(
    BOOL serverOnly
    )
{
    NET_API_STATUS NetStatus;

    BOOL usePrefixWildcard = TRUE;
    WCHAR *credName = NULL;
    LPWSTR DomainName = NULL;
    LPWSTR DnsDomainName = NULL;
    LPWSTR DnsForestName = NULL;
    LPWSTR ComputerName = NULL;
    BOOLEAN IsWorkgroupName;
    BOOLEAN AddWildcard = TRUE;

    // If serverOnly is passed, always use the new server-only behavior.
    
    if (serverOnly)
    {
        if (TargetInfo->TargetName != NULL)
        {
            credName = TargetInfo->TargetName;
            NewCredential.TargetAlias = TargetName;
        }
        else
        {
            credName = TargetName;
            NewCredential.TargetAlias = NULL;
        }

        ASSERT(credName != NULL);
        StringCchCopyW(
            NewTargetName,
            RTL_NUMBER_OF(NewTargetName),
            credName);

        return;
    }
    
    // Determine the maximum length name we can use for the wildcard case:

    const ULONG maxChars = ((sizeof NewTargetName) /
                            (sizeof NewTargetName[0])) - 3;

    if (TargetInfo->Flags & CRED_TI_ONLY_PASSWORD_REQUIRED )
    {
        serverOnly = TRUE;
    }

    //
    // If the auth package requires us to create a target info by an explicit name,
    //  only use that name.
    //

    if (    TargetInfo->Flags & CRED_TI_CREATE_EXPLICIT_CRED  )
    {
        credName = TargetInfo->TargetName;
        AddWildcard = FALSE;
    }


    //
    // If this machine is a member of a domain,
    //  and the target machine is a member of the same forest,
    //  and the user is logged onto an account in the forest,
    //  then this prompt must be because of an authorization issue.
    //
    // Avoid this check if a username was passed into the call
    //
    //  Special case this and create a server specific credential
    //
    if ( credName == NULL &&
         !serverOnly &&
         UserName[0] == '\0' ) {

        BOOL MachineInSameForest = FALSE;
        BOOL UserUsingDomainAccount = FALSE;

        //
        // First determine if this machine is in the same forest as the target machine
        //

        NetStatus = NetpGetDomainNameExExEx (
                        &DomainName,
                        &DnsDomainName,
                        &DnsForestName,
                        NULL,   // Don't need the GUID
                        &IsWorkgroupName );

        if ( NetStatus == NO_ERROR &&
             !IsWorkgroupName ) {

            //
            // check if the netbios domain names match
            //

            if ( TargetInfo->NetbiosDomainName != NULL &&
                 DomainName != NULL &&
                 _wcsicmp( TargetInfo->NetbiosDomainName, DomainName ) == 0 ) {

                MachineInSameForest = TRUE;

            //
            // check if the DNS domain names match
            //

            } else if ( TargetInfo->DnsDomainName != NULL &&
                        DnsDomainName != NULL &&
                        _wcsicmp( TargetInfo->DnsDomainName, DnsDomainName ) == 0 ) {

                MachineInSameForest = TRUE;

            //
            // handle the special domain format unknown case
            //

            } else if ( TargetInfo->DnsDomainName != NULL &&
                        DomainName != NULL &&
                        (TargetInfo->Flags & CRED_TI_DOMAIN_FORMAT_UNKNOWN) != 0 &&
                        _wcsicmp( TargetInfo->DnsDomainName, DomainName ) == 0 ) {

                MachineInSameForest = TRUE;

            //
            // handle the forest name
            //  (Too bad this doesn't work for the other trees in the forest.)
            //

            } else if ( TargetInfo->DnsTreeName != NULL &&
                        DnsForestName != NULL &&
                        _wcsicmp( TargetInfo->DnsTreeName, DnsForestName ) == 0 ) {

                MachineInSameForest = TRUE;

            }

        }

        //
        // If this machine and target machine are in the same forest,
        //  see if the user is logged onto an account that should have worked.
        //

        if ( MachineInSameForest ) {
            WCHAR UserNameBuffer[CRED_MAX_USERNAME_LENGTH+1];
            ULONG UserNameLength = CRED_MAX_USERNAME_LENGTH+1;

            if ( GetUserNameEx( NameSamCompatible,
                                UserNameBuffer,
                                &UserNameLength ) ) {

                //
                // Parse off the netbios account domain name
                //

                LPWSTR SlashPointer;

                SlashPointer = wcsrchr( UserNameBuffer, L'\\' );

                if ( SlashPointer != NULL ) {

                    *SlashPointer = '\0';

                    //
                    // Get the computer name of this machine
                    //

                    NetStatus = NetpGetComputerName( &ComputerName );


                    if ( NetStatus == NO_ERROR ) {

                        //
                        // If the netbios account domain doesn't match the local computer name,
                        //  then the user is logged onto an account in the forest.
                        //  Since trust within the forest is transitive,
                        //  these creds should have worked
                        //

                        if ( _wcsicmp( ComputerName, UserNameBuffer ) != 0 ) {
                            UserUsingDomainAccount = TRUE;
                        }
                    }
                }
            }

        }

        //
        // If both conditions are true,
        //  we should create a server only cred.
        //

        if ( MachineInSameForest && UserUsingDomainAccount ) {
            serverOnly = TRUE;
        }

    }


    //
    // Compute the most generic form of the target name
    //
    if ( credName == NULL && !serverOnly)
    {
        // Look for the most general name possible first, selecting DNS over
        // NetBIOS:

        if ((TargetInfo->DnsServerName != NULL) &&
            (TargetInfo->DnsTreeName != NULL) &&
            CreduiIsPostfixString(TargetInfo->DnsServerName,
                                  TargetInfo->DnsTreeName) &&
            (wcslen(TargetInfo->DnsTreeName) <= maxChars))
        {
            // Credential form: *.DnsTreeName

            credName = TargetInfo->DnsTreeName;
        }
        else if ((TargetInfo->DnsServerName != NULL) &&
                 (TargetInfo->DnsDomainName != NULL) &&
                 !(TargetInfo->Flags & CRED_TI_DOMAIN_FORMAT_UNKNOWN) &&
                 CreduiIsPostfixString(TargetInfo->DnsServerName,
                                       TargetInfo->DnsDomainName) &&
                 (wcslen(TargetInfo->DnsDomainName) <= maxChars))
        {
            // Credential form: *.DnsDomainName

            credName = TargetInfo->DnsDomainName;
        }
        else
        {
            usePrefixWildcard = FALSE;

            // If we have a DNS domain name, and it is different from the
            // target name and different from the NetBIOS server, if it
            // exists, then use it:

            if ((TargetInfo->DnsDomainName != NULL) &&
                (wcslen(TargetInfo->DnsDomainName) <= maxChars))
            {
                // Credential form: DnsDomainName\*

                credName = TargetInfo->DnsDomainName;

                // Set the target alias, if we have one. Don't change the
                // field otherwise, because it may already have been stored in
                // the old credential which was copied over:

                if (TargetInfo->NetbiosDomainName != NULL)
                {
                    ULONG append = wcslen(TargetInfo->NetbiosDomainName);

                    if (append <= maxChars)
                    {
                        StringCchCopyW(
                            NewTargetAlias,
                            RTL_NUMBER_OF(NewTargetAlias),
                            TargetInfo->NetbiosDomainName);

                        NewTargetAlias[append + 0] = L'\\';
                        NewTargetAlias[append + 1] = L'*';
                        NewTargetAlias[append + 2] = L'\0';

                        NewCredential.TargetAlias = NewTargetAlias;
                    }
                }
            }
            else if ((TargetInfo->NetbiosDomainName != NULL) &&
                     (wcslen(TargetInfo->NetbiosDomainName) <= maxChars))
            {
                // Credential form: NetbiosDomainName\*

                credName = TargetInfo->NetbiosDomainName;
            }
        }
    }

    //
    // If we still don't have a target name, select a server target name:
    //

    if (credName == NULL)
    {
        if (TargetInfo->DnsServerName != NULL)
        {
            // Credential form: DnsServerName

            credName = TargetInfo->DnsServerName;

            // Set the target alias, if we have one. Don't change the field
            // otherwise, because it may already have been stored in the old
            // credential which was copied over:

            if (TargetInfo->NetbiosServerName != NULL)
            {
                NewCredential.TargetAlias = TargetInfo->NetbiosServerName;
            }
        }
        else if (TargetInfo->NetbiosServerName != NULL)
        {
            // Credential form: NetbiosServerName

            credName = TargetInfo->NetbiosServerName;
        }
        else
        {
            // Credential form: TargetName

            credName = TargetName;
        }

        AddWildcard = FALSE;

    }
    ASSERT( credName != NULL );

    //
    // If the target name should be wildcarded,
    //  add the wildcard
    //

    if ( AddWildcard )
    {
        // Add the wildcard in the required format:

        if (usePrefixWildcard)
        {
            NewTargetName[0] = L'*';
            NewTargetName[1] = L'.';

            StringCchCopyW(
                NewTargetName + 2,
                maxChars + 1,
                credName);
        }
        else
        {
            StringCchCopyW(
                NewTargetName,
                maxChars + 1,
                credName);

            ULONG append = wcslen(NewTargetName);

            ASSERT(append <= maxChars);

            NewTargetName[append + 0] = L'\\';
            NewTargetName[append + 1] = L'*';
            NewTargetName[append + 2] = L'\0';
        }
    } else {
        StringCchCopyW(
            NewTargetName,
            maxChars + 1,
            credName);
    }


    if ( DomainName != NULL ) {
        NetApiBufferFree( DomainName );
    }
    if ( DnsDomainName != NULL ) {
        NetApiBufferFree( DnsDomainName );
    }
    if ( DnsForestName != NULL ) {
        NetApiBufferFree( DnsForestName );
    }
    if ( ComputerName != NULL ) {
        NetApiBufferFree( ComputerName );
    }

}

//=============================================================================
// CreduiPasswordDialog::UsernameHandleOk
//
// Do the username part of "HandleOk".  The caller should already have filled in
//  UserName as typed by the user.  On succes, UserName may be modified to reflect
//  completion flags.
//
// This part of HandleOk is split out because command line is considered to have two
//  OKs.  The first is when the user hits 'enter' after typing the username.  So
//  username validation happens then by calling this routine.
//
// Returns:
//  NO_ERROR: if the user name is OK.
//  ERROR_BAD_USERNAME: if the username syntax is bad
//  ERROR_DOWNGRADE_DETECTED: if the username doesn't match downgrade requirements
//
//=============================================================================

DWORD
CreduiPasswordDialog::UsernameHandleOk()
{
    DWORD WinStatus;

    BOOL isMarshaled = LocalCredIsMarshaledCredentialW(UserName);

    CreduiDebugLog("UsernameHandleOK: Flags = %x\n",Flags);
    //
    // Compute the credential type based on the new username
    //

    if ( CredCategory != GENERIC_CATEGORY )
    {
        if (isMarshaled)
        {
            NewCredential.Type = CRED_TYPE_DOMAIN_CERTIFICATE;
        }
        else
        {
            // ISSUE: large stack allocation
            SSOPACKAGE SSOPackage;

            // look in registry
            if ( GetSSOPackageInfo( TargetInfo, &SSOPackage ) )
            {
                // it's an sso cred
                NewCredential.Type = CRED_TYPE_DOMAIN_VISIBLE_PASSWORD;
                MaximumPersist = MaximumPersistSso;
            }
            else
            {
                // just a regular domain cred
                NewCredential.Type = CRED_TYPE_DOMAIN_PASSWORD;
            }
        }

        // Set the flag for username target cred
        if ( CredCategory == USERNAME_TARGET_CATEGORY ) {
            NewCredential.Flags |= CRED_FLAGS_USERNAME_TARGET;
        }
    }
    else
    {
        NewCredential.Type = CRED_TYPE_GENERIC;
    }


    //
    // If the caller wanted the username validated,
    //  do so now.
    //

    WinStatus = NO_ERROR;
    if ( NewCredential.Type == CRED_TYPE_DOMAIN_PASSWORD ||
         (Flags & CREDUI_FLAGS_COMPLETE_USERNAME) != 0 ) {

        if ( !CompleteUserName() ) {
            WinStatus = ERROR_BAD_USERNAME;
        }

    } else if ( Flags & CREDUI_FLAGS_VALIDATE_USERNAME ) {

        WCHAR user[CREDUI_MAX_USERNAME_LENGTH+1];
        WCHAR domain[CREDUI_MAX_USERNAME_LENGTH+1];

        WinStatus = CredUIParseUserNameW( UserName,
                              user,
                              sizeof(user)/sizeof(WCHAR),
                              domain,
                              sizeof(domain)/sizeof(WCHAR) );

        if (WinStatus != NO_ERROR) {
            WinStatus = ERROR_BAD_USERNAME;
        }

    }

    //
    // If all is good so far,
    //  and we were originally called because of a downgrade detection,
    //  and the user typed his logon creds,
    //  fail so that the downgrade attacker doesn't "win".
    //

    if ( WinStatus == NO_ERROR &&
         CREDUIP_IS_DOWNGRADE_ERROR( AuthError ) ) {

        WCHAR UserNameBuffer[CRED_MAX_USERNAME_LENGTH+1];
        ULONG UserNameLength;

        //
        // If the typed name is the sam compatible name,
        //  fail.
        //

        UserNameLength = sizeof(UserNameBuffer)/sizeof(WCHAR);

        if ( GetUserNameEx( NameSamCompatible,
                            UserNameBuffer,
                            &UserNameLength ) ) {


            if ( _wcsicmp( UserNameBuffer, UserName ) == 0 ) {
                WinStatus = ERROR_DOWNGRADE_DETECTED;
            }

        }


        //
        // If the typed name is the UPN,
        //  fail.
        //

        UserNameLength = sizeof(UserNameBuffer)/sizeof(WCHAR);

        if ( WinStatus == NO_ERROR &&
            wcsrchr( UserName, L'@' ) != NULL &&
            GetUserNameEx( NameUserPrincipal,
                           UserNameBuffer,
                           &UserNameLength ) ) {

            if ( _wcsicmp( UserNameBuffer, UserName ) == 0 ) {
                WinStatus = ERROR_DOWNGRADE_DETECTED;
            }
        }

    }

//    if (NULL == UserName) CreduiDebugLog("Exit UsernameHandleOK: Username NULL, Flags = %x\n",Flags);
//    else CreduiDebugLog("Exit UsernameHandleOK: UserName = %S, Flags = %x\n", UserName, Flags);

    return WinStatus;
}

//=============================================================================
// CreduiPasswordDialog::HandleOk
//
// Returns ERROR_SUCCESS on success, ERROR_NO_SUCH_LOGON_SESSION if credential
// manager cannot be used to write the credential, or an error from CredWrite
// or FinishHandleOk.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

DWORD
CreduiPasswordDialog::HandleOk()
{
    // Get the user name, password, and other settings from the dialog:
    if (!Credential_GetUserName(CredControlWindow,
                                UserName,
                                UserNameMaxChars))
    {
        return ERROR_GEN_FAILURE;
    }

#ifdef SETWILDCARD
    // if is wildcard cred, see if username entered in control matches the
    //  cred username.  If not, override the old credential.
    // gm 112901: Create a server specific cred on any username change on a cred
    //  involving a wildcard
    //if ( CreduiIsSpecialCredential(&NewCredential) )
    if ((NewCredential.TargetName != NULL) && (wcschr(NewCredential.TargetName,L'*')))
    {
        if (0 != _wcsicmp(OldUserName,UserName) )
        {
            // Change the TargetName from special cred to explicit target passed by caller
            ZeroMemory(&NewCredential,sizeof NewCredential);
            SetCredTargetFromInfo();
            NewCredential.UserName = UserName;
        }
    }

#endif

    // If we cannot get the password, then this is probably a certificate
    // so just set a blank password, which will result in no credential
    // blob:

    BOOL gotPassword =
        Credential_GetPassword(CredControlWindow,
                               Password,
                               PasswordMaxChars);

    if (!gotPassword)
    {
        Password[0] = L'\0';
    }

    //
    // Get the state of the Save checkbox
    //
    if ( CredControlStyle & CRS_SAVECHECK ) 
    {
        Save = Credential_IsSaveChecked(CredControlWindow);
    } 
    else 
    {
        // fInitialSaveState was set in InitWindow(), taking into account passed flags
        //  and the state of the initial save variable.
        Save = fInitialSaveState;
    }

    DWORD error = ERROR_SUCCESS;

    if (!(Flags & CREDUI_FLAGS_DO_NOT_PERSIST))
    {
        //
        // Only save the credential if the user checked the 'save' checkbox
        //

        if ( Save ) {

            //
            // Keep any existing persistence or use the maximum persistance available.
            //

            if (OldCredential != NULL) {
                NewCredential.Persist = OldCredential->Persist;
            } else {
                NewCredential.Persist = MaximumPersist;
            }

        //
        // The credential might still be saved if the caller didn't asked for the creds
        //  to be returned.
        //
        // ISSUE-2000/12/04-CliffV: Such callers are buggy.  We should assign bugs and get them fixed.
        //

        } else {
            NewCredential.Persist = CRED_PERSIST_SESSION;
        }



        if ( CredCategory == GENERIC_CATEGORY || PasswordState == PASSWORD_CHANGED )
        {
            // Attempt to write the new credential, first get the length. The blob
            // does not include the terminating NULL:

            NewCredential.CredentialBlobSize = wcslen(Password) * sizeof (WCHAR);
        }
        else
        {
            NewCredential.CredentialBlobSize = 0;
        }

        // If the password is empty, there is nothing to write:

        if (NewCredential.CredentialBlobSize == 0)
        {
            NewCredential.CredentialBlob = NULL;
        }
        else
        {
            NewCredential.CredentialBlob = reinterpret_cast<BYTE *>(Password);
        }
    }

    //
    // Validate the username
    //

    error = UsernameHandleOk();

    //
    // Save the credentials as required
    //
    if (!(Flags & CREDUI_FLAGS_DO_NOT_PERSIST) &&
        error == ERROR_SUCCESS ) {


        //
        // Only save the credential if the user checked the 'save' checkbox
        //
        // Also store them for callers that didn't ask for creds to be returned
        //
        // Also store them for Branded credenials
        //

        if ( Save ||
             !DelayCredentialWrite ||
             dwIDDResource == IDD_BRANDEDPASSWORD ) {

            error = FinishHandleOk();
            // Bug 230648: CredWrite could come back with ERROR_INVALID_PASSWORD here

        }
        
        else if ( fInitialSaveState && !Save )
        {

            // user unchecked the save box, delete the cred
            LocalCredDeleteW ( NewCredential.TargetName,
                               NewCredential.Type,
                               0 );

        } else {
            error = ERROR_SUCCESS;
        }

        if (error == ERROR_SUCCESS)
        {
            if ( DialogWindow ) {
                EndDialog(DialogWindow, IDOK);
            }

            return error;
        }
        else if (error == ERROR_NO_SUCH_LOGON_SESSION)
        {
            if ( DialogWindow ) {
                EndDialog(DialogWindow, IDCANCEL);
            }

            return error;
        }

        // can still fall out of this block with ERROR_INVALID_PASSWORD
        Credential_SetUserName(CredControlWindow, UserName);

    }

    //
    // If the credential couldn't be written,
    //  let the user type a better one.
    //
    if ((error != ERROR_SUCCESS) &&
        (error != ERROR_NO_SUCH_LOGON_SESSION))
    {
        // For some reason we failed to write the credential:

        if ( error == ERROR_DOWNGRADE_DETECTED ) 
        {
            SendMessage(CredControlWindow,
                                CRM_SHOWBALLOON,
                                0,
                                reinterpret_cast<LPARAM>(&CreduiDowngradeBalloon));
        } 
        else if ( error == ERROR_INVALID_PASSWORD ) 
        {
            // for now, use preexisting credui mechanism, though that may go away in
            // lieu of shell's global implementation using EM_SHOWBALLOONTIP
            Credential_ShowPasswordBalloon(CredControlWindow,
                            TTI_INFO,
                            CreduiStrings.PasswordTipTitle,
                            CreduiStrings.PasswordTipText);
        } 
        else 
        {
            if ( dwIDDResource == IDD_BRANDEDPASSWORD )
            {
                SendMessage(CredControlWindow,
                            CRM_SHOWBALLOON,
                            0,
                            reinterpret_cast<LPARAM>(&CreduiEmailNameBalloon));

            }
            else
            {
                SendMessage(CredControlWindow,
                            CRM_SHOWBALLOON,
                            0,
                            reinterpret_cast<LPARAM>(&CreduiUserNameBalloon));
            }
        }
    }

    return error;
}

DWORD CreduiPasswordDialog::CmdlinePasswordPrompt()
/*++

Routine Description:

    Command line code get username and password as needed from the user.

    UserName and Password strings set in their respective controls.

Arguments:

    None

Return Values:

    Status of the operation.

--*/
{
    DWORD WinStatus;

    WCHAR szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH + 1];
    ULONG LocalUserNameLength = 0;
    WCHAR LocalPassword[CREDUI_MAX_PASSWORD_LENGTH + 1];
    WCHAR LocalUserName[CREDUI_MAX_USERNAME_LENGTH + 1] = {0};

    BOOL bNeedUserNamePrompt = FALSE;

    //
    // Get the username passed into the API
    //

    if (!Credential_GetUserName(CredControlWindow,
                                UserName,
                                UserNameMaxChars))
    {
        UserName[0] = '\0';
    }

    // FIX352582 - allow update of wildcard creds.  Matched wildcard cred presents
    //  username.  User should see it and be able to override it.
    //bNeedUserNamePrompt = (UserName[0] == '\0');
    // FIX 399728 - prevent username prompting if the name was passed explicitly

    if (fPassedUsername) bNeedUserNamePrompt = FALSE;
    else if (!(Flags & USERNAME_TARGET_CATEGORY)) bNeedUserNamePrompt = TRUE;

    //
    // Loop getting the username until the user types a valid one
    //

    while ( bNeedUserNamePrompt ) {

        //
        // Prompt for username
        //

        if (UserName[0] != 0)
        {
                WCHAR *rgsz[2];
                rgsz[0] = UserName;
                rgsz[1] = TargetName;
                szMsg[0] = 0;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            CreduiInstance,
                            IDS_PASSEDNAME_PROMPT,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            (va_list *) rgsz);
        }
        else
        {
                WCHAR *rgsz[2];
                rgsz[0] = TargetName;
                rgsz[1] = 0;
                szMsg[0] = 0;
                FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            CreduiInstance,
                            IDS_USERNAME_PROMPT,
                            0,
                            szMsg,
                            CREDUI_MAX_CMDLINE_MSG_LENGTH,
                            (va_list *) rgsz);
        }
        szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH] = L'\0';
        CredPutStdout( szMsg );

        CredGetStdin( LocalUserName, UserNameMaxChars, TRUE );

        LocalUserNameLength = wcslen( LocalUserName );

        // If nothing entered and nothing passed, bail.
        // If nothing entered and a previous value exists, use previous value unchanged
        // else use overwrite old value with new value
        if ( LocalUserNameLength == 0 ) {
            if (UserName[0] == '\0')
            {
                WinStatus = ERROR_CANCELLED;
                goto Cleanup;
            }
        }
        else
        {
            StringCchCopyW(
                UserName,
                UserNameMaxChars,
                LocalUserName);
        }

        CreduiDebugLog("CreduiCredentialControl::CmdlinePasswordPrompt: "
                       "Username : %S\n",
                       UserName );

        //
        // See if the username is valid (and optional complete the new name)
        //

        WinStatus = UsernameHandleOk();

        if ( WinStatus != NO_ERROR ) {
            // invalid username, put up message and try again
            if ( WinStatus == ERROR_DOWNGRADE_DETECTED ) {
                    szMsg[0] = 0;
                    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                CreduiInstance,
                                IDS_DOWNGRADE_CMD_TEXT,
                                0,
                                szMsg,
                                CREDUI_MAX_CMDLINE_MSG_LENGTH,
                                NULL);
                    CredPutStdout(szMsg);
                    UserName[0] = 0;
            } else {
                    szMsg[0] = 0;
                    FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                CreduiInstance,
                                IDS_INVALID_USERNAME,
                                0,
                                szMsg,
                                CREDUI_MAX_CMDLINE_MSG_LENGTH,
                                NULL);
                    CredPutStdout(szMsg);
                    UserName[0] = 0;
            }
            CredPutStdout( L"\n" );
            continue;
        }

        //
        // Save the username in the control as though the GUI prompted for it
        //
        if  ( !Credential_SetUserName( CredControlWindow, UserName ) ) {

            WinStatus = GetLastError();

            CreduiDebugLog("CreduiCredentialControl::CmdlinePasswordPrompt: "
                           "OnSetUserName failed: %u\n",
                           WinStatus );
            goto Cleanup;
        }

        break;

    }

    //
    // Prompt for a password
    //

    //FIX216477 detect marshalled name and change the prompt string
    // to a generic one for any certificate
    if (CredIsMarshaledCredentialW( UserName )) {
        {
            WCHAR *rgsz[2];
            rgsz[0] = TargetName;
            szMsg[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_CERTIFICATE_PROMPT,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        (va_list *) rgsz);
        }
    } 
    else if ((Flags & USERNAME_TARGET_CATEGORY) || (LocalUserNameLength != 0)) 
    {
            WCHAR *rgsz[2];
            rgsz[0] = TargetName;
            szMsg[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_SIMPLEPASSWORD_PROMPT,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        (va_list *) rgsz);
    } else {
            WCHAR *rgsz[2];
            rgsz[0] = UserName;
            rgsz[1] = TargetName;
            szMsg[0] = 0;
            FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        CreduiInstance,
                        IDS_PASSWORD_PROMPT,
                        0,
                        szMsg,
                        CREDUI_MAX_CMDLINE_MSG_LENGTH,
                        (va_list *) rgsz);
            szMsg[CREDUI_MAX_CMDLINE_MSG_LENGTH] = L'\0';
    }
    CredPutStdout( szMsg );

    CredGetStdin( LocalPassword, CREDUI_MAX_PASSWORD_LENGTH, FALSE );

    //
    // Save the password in the control as though the GUI prompted for it
    //

    if  ( !Credential_SetPassword( CredControlWindow, LocalPassword ) ) {
        WinStatus = GetLastError();

        CreduiDebugLog("CreduiCredentialControl::CmdlinePasswordPrompt: "
                       "OnSetPassword failed: %u\n",
                       WinStatus );
        goto Cleanup;
    }

    WinStatus = NO_ERROR;

    //
    // Tell our parent window that we're done prompting
    //
Cleanup:
    SecureZeroMemory(LocalPassword, sizeof LocalPassword);
    return WinStatus;
}



//=============================================================================
// CreduiPasswordDialog::CmdLineMessageHandlerCallback
//
//
// The command line message handler function
//
// Arguments:
//   Window (in)
//   message (in)
//   wParam (in)
//   lParam (in)
//
//=============================================================================

LRESULT
CALLBACK
CreduiPasswordDialog::CmdLineMessageHandlerCallback(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    // CreduiDebugLog( "CmdLine Callback: %8.8lx %8.8lx %8.8lx\n", message, wParam, lParam );

    // on window message, retrieve object ptr from window data ptr
    // call class object handler function.
    CreduiPasswordDialog *that =
        reinterpret_cast<CreduiPasswordDialog *>(
            GetWindowLongPtr(window, GWLP_USERDATA));

    if (that != NULL) {
        ASSERT(window == that->CmdLineWindow);
        return that->CmdLineMessageHandler(message, wParam, lParam);
    }

    if (message == WM_CREATE)
    {
        DWORD WinStatus;
        LPCREATESTRUCT lpCreateStruct = (LPCREATESTRUCT)lParam;
        that = (CreduiPasswordDialog *)lpCreateStruct->lpCreateParams;

        if (that != NULL) {

            //
            // Initialize the window
            //

            if (!that->InitWindow( window )) {
                PostQuitMessage( ERROR_CANCELLED );
                return 0;
            }

            SetWindowPos ( window, HWND_BOTTOM, 0,0,0,0,  SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED );


            //
            // For passwords,
            //  prompt here.
            //
            // It is better to prompt here than in the control window since
            //  command line has to do user name completion and that is done at this layer.
            //

            if ( (that->Flags & CREDUI_FLAGS_REQUIRE_SMARTCARD) == 0 ) {
                WinStatus = that->CmdlinePasswordPrompt();

                if ( WinStatus != NO_ERROR ) {
                    PostQuitMessage( WinStatus );
                    return 0;
                }
            }

            //
            // For smartcards,
            //  Prompt in the control window since it supports smart card enumeration
            // For password,
            //  prompt where to save the cred.
            //

            WinStatus = (DWORD) SendMessage(that->CredControlWindow, CRM_DOCMDLINE, 0, (LPARAM)that->TargetName );

            if ( WinStatus != NO_ERROR ) {
                PostQuitMessage( WinStatus );
                return 0;
            }


        }
        return 0;
    }

    return DefWindowProc(window, message, wParam, lParam);

}



//=============================================================================
// CreduiPasswordDialog::CmdLineMessageHandler
//
// Called from the control window callback to handle the window messages.
//
// Arguments:
//   message (in)
//   wParam (in)
//   lParam (in)
//
//=============================================================================

LRESULT
CreduiPasswordDialog::CmdLineMessageHandler(
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    return SendMessage( CredControlWindow, message, wParam, lParam );
}

//=============================================================================
// CreduiPasswordDialog::DialogMessageHandlerCallback
//
// This is the actual callback function for the dialog window. On the intial
// create, this handles WM_INITDIALOG. After that, it is only responsible for
// getting the this pointer and calling DialogMessageHandler.
//
// Arguments:
//   dialogWindow (in)
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Returns TRUE if the message was handled or FALSE otherwise. FALSE is also
// returned in special cases such as WM_INITDIALOG.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

INT_PTR
CALLBACK
CreduiPasswordDialog::DialogMessageHandlerCallback(
    HWND dialogWindow,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    //CreduiDebugLog( "Dialog Callback: %8.8lx %8.8lx %8.8lx\n", message, wParam, lParam );
    CreduiPasswordDialog *that =
        reinterpret_cast<CreduiPasswordDialog *>(
            GetWindowLongPtr(dialogWindow, GWLP_USERDATA));

    if (that != NULL)
    {
        ASSERT(dialogWindow == that->DialogWindow);

        return that->DialogMessageHandler(message, wParam, lParam);
    }

    if (message == WM_INITDIALOG)
    {
        that = reinterpret_cast<CreduiPasswordDialog *>(lParam);

        if (that != NULL)
        {
            if (!that->InitWindow(dialogWindow))
            {
                EndDialog(dialogWindow, IDCANCEL);
            }
        }
    }

    return FALSE;
}

//=============================================================================
// CreduiPasswordDialog::DialogMessageHandler
//
// Called from the dialog window callback to handle the window messages.
//
// Arguments:
//   message (in)
//   wParam (in)
//   lParam (in)
//
// Returns TRUE if the message was handled or FALSE otherwise.
//
// Created 02/25/2000 johnstep (John Stephens)
//=============================================================================

INT_PTR
CreduiPasswordDialog::DialogMessageHandler(
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (message)
    {

    case WM_NOTIFY:
        {
            int idCtrl = (int)wParam;
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {

            case NM_CLICK:
            case NM_RETURN:
                switch (idCtrl)
                {
                    case IDC_GETALINK:
                        {
                            DWORD dwResult;

                            if ( TryLauchRegWizard ( &SSOPackage, DialogWindow, TRUE /* HasLogonSession */,
                                                           UserName, UserNameMaxChars,
                                                           Password, PasswordMaxChars,
                                                           &dwResult ))
                            {
                                // end dialog, Result
                                if ( dwResult == ERROR_SUCCESS )
                                {
                                    EndDialog(DialogWindow, IDOK);
                                    return TRUE;
                                }
                            }
                            else
                            {
                                // if we couldn't launch the wizard, try the web page.
                                if ( wcslen(SSOPackage.szRegURL) > 0 )
                                {
                                    ShellExecute ( NULL,
                                               NULL,
                                               SSOPackage.szRegURL,
                                               NULL,
                                               NULL,
                                               SW_SHOWNORMAL );
                                }
                            }
                        }

                        break;
                    case IDC_HELPLINK:
                        if ( wcslen(SSOPackage.szHelpURL) > 0 )
                        {
                            ShellExecute ( NULL,
                                       NULL,
                                       SSOPackage.szHelpURL,
                                       NULL,
                                       NULL,
                                       SW_SHOWNORMAL );
                        }
                        break;

                }

            }
        }
        break;


    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            Result = HandleOk();

            if (Result != ERROR_SUCCESS)
            {
                if (Result == ERROR_NO_SUCH_LOGON_SESSION)
                {
                    wParam = IDCANCEL;
                }
                else
                {
                    return TRUE;
                }
            }
            // Fall through...

        case IDCANCEL:
            EndDialog(DialogWindow, LOWORD(wParam));
            return TRUE;

        case IDC_CRED:
            if (HIWORD(wParam) == CRN_USERNAMECHANGE)
            {
                BOOL enable = TRUE;
                LONG length = Credential_GetUserNameLength(CredControlWindow);

                // Validate the user name:

                if ( CredCategory == DOMAIN_CATEGORY &&
                    ((TargetInfo == NULL) ||
                     !(TargetInfo->Flags & CRED_TI_ONLY_PASSWORD_REQUIRED)))
                {
                    enable = length > 0;
                }
                else
                {
                    enable = length != -1;
                }

                if (enable)
                {
                    EnableWindow(GetDlgItem(DialogWindow, IDOK), TRUE);
                    DisabledControlMask &= ~DISABLED_CONTROL_OK;
                }
                else
                {
                    EnableWindow(GetDlgItem(DialogWindow, IDOK), FALSE);
                    DisabledControlMask |= DISABLED_CONTROL_OK;
                }
            }
            else if (HIWORD(wParam) == CRN_PASSWORDCHANGE)
            {
                if (PasswordState == PASSWORD_INIT)
                {
                    PasswordState = PASSWORD_CHANGED;
                }
            }
            return TRUE;


        }
        break;

    case WM_ENTERSIZEMOVE:
        Credential_HideBalloon(CredControlWindow);
        return TRUE;

    case WM_PAINT:
        if (FirstPaint && GetUpdateRect(DialogWindow, NULL, FALSE))
        {
            FirstPaint = FALSE;

            if (CredBalloon != NULL)
            {
                SendMessage(CredControlWindow,
                            CRM_SHOWBALLOON,
                            0,
                            reinterpret_cast<LPARAM>(CredBalloon));
            }

            CredBalloon = NULL;
        }
        break;
    }

    return FALSE;
}

// looks for an existing cred with the same name as that of pNewCredential and demotes it to
// username only
void DemoteOldDefaultSSOCred (
    PCREDENTIAL_TARGET_INFORMATION pTargetInfo,     // target info of new cred
    DWORD Flags
    )
{
    CREDENTIALW **credentialSet = NULL;
    DWORD count;


    if ( pTargetInfo == NULL  )
        return;

    if (LocalCredReadDomainCredentialsW( pTargetInfo, 0, &count,
                                              &credentialSet))
    {

        PCREDENTIAL pOldCredential = NULL;

        for ( DWORD i = 0; i < count; i++ )
        {

#ifndef SETWILDCARD
            //
            // Ignore RAS and wildcard credentials,
            //  we never want credUI to change such a credential.
            //
            if ( CreduiIsSpecialCredential(credentialSet[i]) )
            {
                continue;
            }
#endif

            //
            // CredReadDomain domain credentials returns creds in preference
            //  order as specified by the TargetInfo.
            //  So use the first valid one.
            //
            if ( credentialSet[i]->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD )
            {
                pOldCredential = credentialSet[i];
                break;
            }


        }


        if ( pOldCredential != NULL )
        {
            // save this under the username

            pOldCredential->Persist = CRED_PERSIST_ENTERPRISE;
            pOldCredential->CredentialBlob = NULL;
            pOldCredential->CredentialBlobSize = 0;
            pOldCredential->TargetName = pOldCredential->UserName;
            pOldCredential->Flags = CRED_FLAGS_USERNAME_TARGET;


            WriteCred(  pOldCredential->UserName,
                        Flags,
                        NULL,
                        pOldCredential,
                        0,
                        FALSE,
                        FALSE);

        }
    }

    if (credentialSet != NULL)
    {
        LocalCredFree(static_cast<VOID *>(credentialSet));
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\pswchg.cpp ===
#include "precomp.hpp"
//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <windows.h>
#include <wincred.h>
#include <align.h>
#include <lm.h>
#include <ntsecapi.h>
#include <dsgetdc.h>
#include <stdlib.h>
//#include <stdio.h>
#include <string.h>

// !!!!!
// this file is a duplicate of a nearly identical file in the keymgr project.  It should be removed when
// the implementation of NetUserChangePassword() is updated to handle unc names and MIT Kerberos
// realms properly.  For now, it wraps NetUserChangePassword() to handle the extra cases.

// Dependent libraries:
//  secur32.lib, netapi32.lib

// external fn:  NET_API_STATUS NetUserChangePasswordEy(LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR)

BOOL 
IsMITName (
    LPCWSTR UserName
)
{
    BOOL fReturn = FALSE;
    HKEY MitKey;
    DWORD Index;
    PWSTR Realms;
    DWORD RealmSize;
    int err;
    DWORD NumRealms;
    DWORD MaxRealmLength;
    FILETIME KeyTime;
    WCHAR *szUncTail;
    
    if (NULL == UserName) return FALSE;
    
    szUncTail = wcschr(UserName,'@');
    if (NULL == szUncTail) return FALSE;
    szUncTail++;                        // point to char following @

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Domains"),
                0,
                KEY_READ,
                &MitKey );

    if ( err == 0 )
    {
#ifdef LOUDLY
        CreduiDebugLog("Kerberos domains key opened\n");
#endif
        err = RegQueryInfoKey( MitKey,
                               NULL,
                               NULL,
                               NULL,
                               &NumRealms,
                               &MaxRealmLength,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

        MaxRealmLength++ ;

        MaxRealmLength *= sizeof( WCHAR );

        Realms = (PWSTR) malloc(MaxRealmLength );


        if ( Realms)
        {
#ifdef LOUDLY
        CreduiDebugLog("Kerberos realms found\n");
#endif

            for ( Index = 0 ; Index < NumRealms ; Index++ )
            {
                RealmSize = MaxRealmLength ;

                err = RegEnumKeyEx( MitKey,
                                  Index,
                                  Realms,
                                  &RealmSize,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &KeyTime );
                if (err == 0)
                {
#ifdef LOUDLY
                    CreduiDebugLog("Fetched realm: ");
                    CreduiDebugLog(Realms);
                    CreduiDebugLog("\n");
                    CreduiDebugLog("Username suffix: ");
                    CreduiDebugLog(szUncTail);
                    CreduiDebugLog("\n");
#endif
                    if (0 == _wcsicmp(szUncTail, Realms))
                    {
#ifdef LOUDLY
                        CreduiDebugLog("Username maps to an MIT realm\n");
#endif
                        fReturn = TRUE;
                        break;
                    }
                }
            }
        }
        free(Realms);
    }
    return fReturn;
}

NTSTATUS
MitChangePasswordEy(
    LPCWSTR       DomainName,
    LPCWSTR       UserName,
    LPCWSTR       OldPassword,
    LPCWSTR       NewPassword,
    NTSTATUS      *pSubStatus
    )
{
    HANDLE hLsa = NULL;
    NTSTATUS Status;
    NTSTATUS SubStatus;
    
    STRING Name;
    ULONG PackageId;
    
    PVOID Response = NULL ;
    ULONG ResponseSize;
    
    PKERB_CHANGEPASSWORD_REQUEST ChangeRequest = NULL;
    ULONG ChangeSize = 0;
    
    UNICODE_STRING User,Domain,OldPass,NewPass;

    Status = LsaConnectUntrusted(&hLsa);
    if (!SUCCEEDED(Status)) goto Cleanup;
#ifdef LOUDLY
    CreduiDebugLog("We have an LSA handle\n");
#endif

    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );

    Status = LsaLookupAuthenticationPackage(
                hLsa,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
#ifdef LOUDLY
    CreduiDebugLog("Authentication package found\n");
#endif

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &OldPass,
        OldPassword
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_CHANGEPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    OldPass.Length +
                                    NewPass.Length ;
    ChangeRequest = (PKERB_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );

    if ( ChangeRequest == NULL )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup ;
    }

    ChangeRequest->MessageType = KerbChangePasswordMessage;

    ChangeRequest->AccountName = User;
    ChangeRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_CHANGEPASSWORD_REQUEST) + (PBYTE) ChangeRequest,4);

    RtlCopyMemory(
        ChangeRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    ChangeRequest->DomainName = Domain;
    ChangeRequest->DomainName.Buffer = ChangeRequest->AccountName.Buffer + ChangeRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    ChangeRequest->OldPassword = OldPass;
    ChangeRequest->OldPassword.Buffer = ChangeRequest->DomainName.Buffer + ChangeRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->OldPassword.Buffer,
        OldPass.Buffer,
        OldPass.Length
        );

    ChangeRequest->NewPassword = NewPass;
    ChangeRequest->NewPassword.Buffer = ChangeRequest->OldPassword.Buffer + ChangeRequest->OldPassword.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->NewPassword.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );


    //
    // We are running as the caller, so state we are impersonating
    //

    //ChangeRequest->Impersonating = TRUE;
#ifdef LOUDLY
    CreduiDebugLog("Attempting to call the authentication package\n");
#endif
    Status = LsaCallAuthenticationPackage(
                hLsa,
                PackageId,
                ChangeRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
#ifdef LOUDLY
        WCHAR szsz[200];
        swprintf(szsz,L"Call failed. Status %x SubStatus %x\n",Status, SubStatus);
        CreduiDebugLog(szsz);
#endif
        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
            *pSubStatus = STATUS_UNSUCCESSFUL ;
        } 
        else 
        {
            *pSubStatus = SubStatus;
        }
    }

Cleanup:

    if (hLsa) LsaDeregisterLogonProcess(hLsa);

    if (Response != NULL) LsaFreeReturnBuffer(Response);

    if (ChangeRequest != NULL)
    {
        SecureZeroMemory(ChangeRequest, ChangeSize);
        ChangeSize = 0;
        LocalFree(ChangeRequest);
    }
    
    return(Status);
}

/*

NetUserChangePasswordEy()

A wrapper function to superset the functionality of NetUserChangePassword(), specifically
by adding support for changing the account password for an MIT Kerberos principal.

This routine accepts:

1.  uncracked username, with NULL domain
2.  cracked username, with domain portion routed to the domain argument

In case 1, it handles all cases, including MIT realm password changes
In case 2, it will not handle MIT realms.  

Case 2 is provided for backwards compatibility with NetUserChangePassword().  It is intended
that callers should pass the uncracked name, and remove the cracking code from the client.

*/
NET_API_STATUS
NetUserChangePasswordEy (
    LPCWSTR domainname,
    LPCWSTR username,
    LPCWSTR oldpassword,
    LPCWSTR newpassword
)
{
    NTSTATUS ns;    // status from call
    NET_API_STATUS nas;
    NTSTATUS ss;    // substatus
#ifdef LOUDLY
    CreduiDebugLog("NetUserChangePasswordEy called for ");
    CreduiDebugLog(username);
    CreduiDebugLog("\n");
#endif
    // domainname may be a kerberos realm
    // If not a UNC name, call through to NetUserChangePassword
    // else
    //  locate UNC suffix
    //  search all domains returned by DsEnumerateDomainTrusts() for a match
    //  On match, if is kerberos realm, call MitChangePasswordEy()
    //  else call NetUserChangePassword
    if ((domainname == NULL) && IsMITName(username))
    {
        ns = MitChangePasswordEy(domainname, username, oldpassword, newpassword, &ss);
        // remap certain errors returned by MitChangePasswordEy to coincide with those of NetUserChangePassword
        if (NT_SUCCESS(ns)) nas = NERR_Success;
        else
        {
            switch (ns)
            {
                case STATUS_CANT_ACCESS_DOMAIN_INFO:
                case STATUS_NO_SUCH_DOMAIN:
                {
                    nas = NERR_InvalidComputer;
                    break;
                }
                case STATUS_NO_SUCH_USER:
                case STATUS_WRONG_PASSWORD_CORE:
                case STATUS_WRONG_PASSWORD:
                {
                    nas = ERROR_INVALID_PASSWORD;
                    break;
                }
                case STATUS_ACCOUNT_RESTRICTION:
                case STATUS_ACCESS_DENIED:
                case STATUS_BACKUP_CONTROLLER:
                {
                    nas = ERROR_ACCESS_DENIED;
                    break;
                }
                case STATUS_PASSWORD_RESTRICTION:
                {
                    nas = NERR_PasswordTooShort;
                    break;
                }
                        
                default:
                    nas = -1;       // will produce omnibus error message when found (none of the above)
                    break;
            }
        }
    }
    else if (NULL == domainname)
    {
        WCHAR RetUserName[CRED_MAX_USERNAME_LENGTH + 1];
        WCHAR RetDomainName[CRED_MAX_USERNAME_LENGTH + 1];
        RetDomainName[0] = 0;
        DWORD Status = CredUIParseUserNameW(
                        username,
                        RetUserName,
                        CRED_MAX_USERNAME_LENGTH,
                        RetDomainName,
                        CRED_MAX_USERNAME_LENGTH);
        switch (Status)
        {
            case NO_ERROR:
            {
#ifdef LOUDLY
                CreduiDebugLog("Non-MIT password change for ");
                CreduiDebugLog(RetUserName);
                CreduiDebugLog(" of domain ");
                CreduiDebugLog(RetDomainName);
                CreduiDebugLog("\n");
#endif
                nas = NetUserChangePassword(RetDomainName,RetUserName,oldpassword,newpassword);
                break;
            }
            case ERROR_INSUFFICIENT_BUFFER:
                nas = ERROR_INVALID_PARAMETER;
                break;
            case ERROR_INVALID_ACCOUNT_NAME:
            default:
                nas = NERR_UserNotFound;
                break;
        }

    }
    else 
    {
        // both username and domainname passed.
        nas = NetUserChangePassword(domainname,username,oldpassword,newpassword);
    }
#ifdef LOUDLY
    WCHAR szsz[200];
    swprintf(szsz,L"NUCPEy returns %x\n",nas);
    CreduiDebugLog(szsz);
#endif
    return nas;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\utils.cpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// utils.cpp
//
// Credential manager user interface utility functions.
//
// Created 06/06/2000 johnstep (John Stephens)
//=============================================================================

#include "precomp.hpp"
#include <lm.h>
#include <credp.h>
#include "wininet.h"
#include <windns.h> // DnsValidateName_W
extern "C" 
{
#include <names.h> // NetpIsDomainNameValid
}

#include "shpriv.h"

extern BOOL  gbWaitingForSSOCreds;
extern WCHAR gszSSOUserName[CREDUI_MAX_USERNAME_LENGTH];
extern WCHAR gszSSOPassword[CREDUI_MAX_PASSWORD_LENGTH];
extern BOOL gbStoredSSOCreds;

#define SIZE_OF_SALT  37
#define SALT_SHIFT     2

WCHAR g_szSalt[] = L"82BD0E67-9FEA-4748-8672-D5EFE5B779B0";

HMODULE hAdvapi32 = NULL;

CRITICAL_SECTION CredConfirmationCritSect;
CRED_AWAITING_CONFIRMATION* pCredConfirmationListHead = NULL;

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

//=============================================================================
// CreduiIsPostfixString
//
// This function determines if the postfix string is in fact a postfix string
// of the source string. This is similar to a strstr type of function, except
// the substring (postfix) must be at the end of the source string.
//
// Arguments:
//   source (in) - The string to search
//   postfix (in) - The postfix string to search for
//
// Return TRUE if postfix is a postfix string of source or FALSE otherwise
//
// Created 03/09/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsPostfixString(
    WCHAR *source,
    WCHAR *postfix
    )
{
    ULONG sourceLength = wcslen(source);
    ULONG postfixLength = wcslen(postfix);

    if (sourceLength >= postfixLength)
    {
        return _wcsicmp(source + sourceLength - postfixLength, postfix) == 0;
    }

    return FALSE;
}

//=============================================================================
// CreduiIsSpecialCredential
//
// Returns TRUE if the credential is a special type which we should not
// update or FALSE otherwise.
//
// Created 05/25/2000 johnstep (John Stephens)
//
//=============================================================================

BOOL
CreduiIsSpecialCredential(
    CREDENTIAL *credential
    )
{
    ASSERT(credential != NULL);

    // If credential empty for some reason, don't attempt the test
    if (credential->TargetName == NULL) return FALSE;
    
    if ((credential->TargetName[0] == L'*') &&
        (credential->TargetName[1] == L'\0'))
    {
        // The magical global wildcard credential, which we never create nor
        // update. This is a special credential:

        return TRUE;
    }

    if (_wcsicmp(credential->TargetName, CRED_SESSION_WILDCARD_NAME) == 0)
    {
        // This is another special credential:

        return TRUE;
    }

    return FALSE;
}

//=============================================================================
// CreduiLookupLocalSidFromRid
//
// Looks up the SID from the RID, allocates storage for the SID, and returns a
// pointer to it. The caller is responsible for freeing the memory via the
// delete [] operator.
//
// Arguments:
//   rid (in)
//   sid (out)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 04/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiLookupLocalSidFromRid(
    DWORD rid,
    PSID *sid
    )
{
    BOOL success = FALSE;

    *sid = NULL;

    // Get the account domain SID on the target machine.
    //
    // Note: If you were looking up multiple SIDs based on the same account
    //       domain, you only need to call this once.

    USER_MODALS_INFO_2 *userInfo;

    if (NetUserModalsGet(
            NULL,
            2,
            reinterpret_cast<BYTE **>(&userInfo)) == NERR_Success)
    {
        UCHAR subAuthCount =
            *GetSidSubAuthorityCount(userInfo->usrmod2_domain_id);

        SID *newSid =
            reinterpret_cast<SID *>(
                new BYTE [GetSidLengthRequired(subAuthCount + 1)]);

        if (newSid != NULL)
        {
            InitializeSid(
                newSid,
                GetSidIdentifierAuthority(userInfo->usrmod2_domain_id),
                subAuthCount + 1);

            // Copy existing sub authorities from account SID into new SID:

            for (ULONG i = 0; i < subAuthCount; ++i)
            {
                *GetSidSubAuthority(newSid, i) =
                    *GetSidSubAuthority(userInfo->usrmod2_domain_id, i);
            }

            // Append RID to new SID:

            *GetSidSubAuthority(newSid, subAuthCount) = rid;
            *sid = newSid;

            success = TRUE;
        }

        // Finished with userInfo, so free it here:
        NetApiBufferFree(userInfo);
    }

    return success;
}

//=============================================================================
// CreduiLookupLocalNameFromRid
//
// Looks up the Name from the RID, allocates storage for the Name, and returns a
// pointer to it. The caller is responsible for freeing the memory via the
// delete [] operator.
//
// Arguments:
//   rid (in)
//   name (out)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 04/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiLookupLocalNameFromRid(
    DWORD rid,
    LPWSTR *name
    )
{
    BOOL RetVal = FALSE;
    PSID Sid;
    WCHAR NameBuffer[UNLEN+1];
    DWORD NameLen;
    WCHAR DomainBuffer[DNLEN+1];
    DWORD DomainLen;
    SID_NAME_USE NameUse;

    //
    // First translate the rid to a SID
    //

    if ( !CreduiLookupLocalSidFromRid( rid, &Sid )) {
        return FALSE;
    }

    //
    // Translate the SID to a name
    //

    NameLen = UNLEN+1;
    DomainLen = DNLEN+1;
    if ( LookupAccountSid( NULL,
                            Sid,
                            NameBuffer,
                            &NameLen,
                            DomainBuffer,
                            &DomainLen,
                            &NameUse ) ) {


        //
        //  Allocate a buffer for the name
        //

        *name = (LPWSTR)( new WCHAR[NameLen+1]);

        if ( *name != NULL ) {

            RtlCopyMemory( *name, NameBuffer, (NameLen+1)*sizeof(WCHAR) );
            RetVal = TRUE;

        }
    }

    delete Sid;
    return RetVal;
}

//=============================================================================
// CreduiGetAdministratorsGroupInfo
//
// Returns a structure containing members of the well-known local
// Administrators group. The caller is responsible for freeing the returned
// memory via NetApiBufferFree.
//
// Arguments:
//   groupInfo (out)
//   memberCount (out)
//
// Returns TRUE on success or FALSE otherwise.
//
// Created 04/13/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiGetAdministratorsGroupInfo(
    LOCALGROUP_MEMBERS_INFO_2 **groupInfo,
    DWORD *memberCount
    )
{
    BOOL success = FALSE;

    *groupInfo = NULL;
    *memberCount = 0;

    SID_IDENTIFIER_AUTHORITY ntAuth = SECURITY_NT_AUTHORITY;

    SID *adminsSid = NULL;

    if (AllocateAndInitializeSid(&ntAuth,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 reinterpret_cast<VOID **>(&adminsSid)))
    {
        WCHAR user[UNLEN + 1];
        WCHAR domain[UNLEN + 1];

        DWORD userLength = (sizeof user) / (sizeof (WCHAR));
        DWORD domainLength = (sizeof domain) / (sizeof (WCHAR));

        SID_NAME_USE nameUse;

        // Get the name of the well-known Administrators SID:

        if (LookupAccountSid(NULL,
                             adminsSid,
                             user,
                             &userLength,
                             domain,
                             &domainLength,
                             &nameUse))
        {
            LOCALGROUP_MEMBERS_INFO_2 *info;
            DWORD count;
            DWORD total;

            if (NetLocalGroupGetMembers(NULL,
                                        user,
                                        2,
                                        reinterpret_cast<BYTE **>(&info),
                                        MAX_PREFERRED_LENGTH,
                                        &count,
                                        &total,
                                        NULL) == NERR_Success)
            {
                *groupInfo = info;
                *memberCount = count;

                success = TRUE;
            }
        }

        FreeSid(adminsSid);
    }

    return success;
}

//=============================================================================
// CreduiIsRemovableCertificate
//
// Arguments:
//   certContext (in) - certificate context to query
//
// Returns TRUE if the certificate has a removable component (such as a smart
// card) or FALSE otherwise.
//
// Created 04/09/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsRemovableCertificate(
    CONST CERT_CONTEXT *certContext
    )
{
    ASSERT(certContext != NULL);

    BOOL isRemovable = FALSE;

    // First, determine the buffer size:

    DWORD bufferSize = 0;

    if (CertGetCertificateContextProperty(
            certContext,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &bufferSize))
    {
        // Allocate the buffer on the stack:

        CRYPT_KEY_PROV_INFO *provInfo;

        __try
        {
            provInfo = static_cast<CRYPT_KEY_PROV_INFO *>(alloca(bufferSize));
        }
        __except(
            (GetExceptionCode() == EXCEPTION_STACK_OVERFLOW) ?
                EXCEPTION_EXECUTE_HANDLER :
                EXCEPTION_CONTINUE_SEARCH)
        {
            _resetstkoflw();
            provInfo = NULL;
        }

        if (provInfo != NULL)
        {
            if (CertGetCertificateContextProperty(
                    certContext,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    provInfo,
                    &bufferSize))
            {
                HCRYPTPROV provContext;

                if (CryptAcquireContext(
                        &provContext,
                        NULL,
                        provInfo->pwszProvName,
                        provInfo->dwProvType,
                        CRYPT_VERIFYCONTEXT | CRYPT_SILENT))
                {
                    DWORD impType;
                    DWORD impTypeSize = sizeof impType;

                    if (CryptGetProvParam(
                            provContext,
                            PP_IMPTYPE,
                            reinterpret_cast<BYTE *>(&impType),
                            &impTypeSize,
                            0))
                    {
                        if (impType & CRYPT_IMPL_REMOVABLE)
                        {
                            isRemovable = TRUE;
                        }
                    }

                    if (!CryptReleaseContext(provContext, 0))
                    {
                        CreduiDebugLog(
                            "CreduiIsRemovableCertificate: "
                            "CryptReleaseContext failed: %u\n",
                            GetLastError());
                    }
                }
            }
        }
    }

    return isRemovable;
}

//=============================================================================
// CreduiIsExpiredCertificate
//
// Arguments:
//   certContext (in) - certificate context to query
//
// Returns TRUE if the certificate has expired or FALSE otherwise.
//
// Created 06/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsExpiredCertificate(
    CONST CERT_CONTEXT *certContext
    )
{
    ASSERT(certContext != NULL);

    DWORD flags = CERT_STORE_TIME_VALIDITY_FLAG;

    return CertVerifySubjectCertificateContext(certContext,
                                               NULL,
                                               &flags) &&
           (flags & CERT_STORE_TIME_VALIDITY_FLAG);
}

//=============================================================================
// CreduiIsClientAuthCertificate
//
// Arguments:
//   certContext (in) - certificate context to query
//
// Returns TRUE if the certificate has the client authentication enhanced key
// usage extension (not property) or FALSE otherwise.
//
// Created 07/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsClientAuthCertificate(
    CONST CERT_CONTEXT *certContext
    )
{
    ASSERT(certContext != NULL);

    BOOL isClientAuth = FALSE;

    // First, determine the buffer size:

    DWORD bufferSize = 0;

    if (CertGetEnhancedKeyUsage(
            certContext,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            NULL,
            &bufferSize))
    {
        // Allocate the buffer on the stack:

        CERT_ENHKEY_USAGE *usage;

        __try
        {
            usage = static_cast<CERT_ENHKEY_USAGE *>(alloca(bufferSize));
        }
        __except(
            (GetExceptionCode() == EXCEPTION_STACK_OVERFLOW) ?
                EXCEPTION_EXECUTE_HANDLER :
                EXCEPTION_CONTINUE_SEARCH)
        {
            _resetstkoflw();
            usage = NULL;
        }

        if (usage != NULL)
        {
            if (CertGetEnhancedKeyUsage(
                    certContext,
                    CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                    usage,
                    &bufferSize))
            {
                for (UINT i = 0; i < usage->cUsageIdentifier; ++i)
                {
                    if (strcmp(usage->rgpszUsageIdentifier[i],
                               szOID_PKIX_KP_CLIENT_AUTH) == 0)
                    {
                        isClientAuth = TRUE;
                        break;
                    }
                    if (strcmp(usage->rgpszUsageIdentifier[i],
                               szOID_KP_SMARTCARD_LOGON) == 0)
                    {
                        isClientAuth = TRUE;
                        break;
                    }
                }
            }
        }
    }

    return isClientAuth;
}

//=============================================================================
// CreduiGetCertificateDisplayName
//
// Arguments:
//   certContext (in)
//   displayName (out)
//   displayNameMaxChars (in)
//   certificateString (in)
//   dwDisplayType (in)
//
// Returns TRUE if a display name was stored or FALSE otherwise.
//
// Created 06/12/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiGetCertificateDisplayName(
    CONST CERT_CONTEXT *certContext,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    WCHAR *certificateString,
    DWORD dwDisplayType
    )
{
    BOOL success = FALSE;

    if (displayNameMaxChars < 16)
    {
        goto Exit;
    }

    WCHAR *tempName;
    ULONG tempNameMaxChars = displayNameMaxChars / 2 - 1;
    ULONG ulccDisplayRoom = displayNameMaxChars;

    __try
    {
        tempName =
            static_cast<WCHAR *>(
                alloca(tempNameMaxChars * sizeof (WCHAR)));
    }
    __except(
        (GetExceptionCode() == EXCEPTION_STACK_OVERFLOW) ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH)
    {
        _resetstkoflw();
        tempName = NULL;
    }

    if (tempName == NULL)
    {
        goto Exit;
    }

    displayName[0] = L'\0';
    tempName[0] = L'\0';

    if (CertGetNameString(
            certContext,
            dwDisplayType,
            0,
            NULL,
            tempName,
            tempNameMaxChars))
    {
        success = TRUE;
        StringCchCopyW(displayName, displayNameMaxChars, tempName);
        ulccDisplayRoom -= wcslen(displayName);
    }

    if (CertGetNameString(
            certContext,
            dwDisplayType,
            CERT_NAME_ISSUER_FLAG,
            NULL,
            tempName,
            tempNameMaxChars))
    {
        if (_wcsicmp(displayName, tempName) != 0)
        {
            success = TRUE;

            WCHAR *where = &displayName[wcslen(displayName)];

            if (ulccDisplayRoom > 3)
            {
                if (where > displayName)
                {
                    *where++ = L' ';
                    *where++ = L'-';
                    *where++ = L' ';
                    ulccDisplayRoom -= 3;
                }
                StringCchCopyW(where, ulccDisplayRoom, tempName);
            }
        }
    }

Exit:

    if (!success)
    {
        StringCchCopyW(
            displayName,
            displayNameMaxChars,
            certificateString);
    }

    return success;
}

//=============================================================================
// CreduiIsWildcardTargetName
//
// This function determines if the given target name is a wildcard name.
// Currently, that means it either starts with a '*' or ends with a '*'. I
// suppose, a more general solution is to simply search for a '*' anywhere in
// the name.
//
// Arguments:
//   targetName (in) - The string to search
//
// Return TRUE if the target name is a wildcard name or FALSE otherwise.
//
// Created 03/09/2000 johnstep (John Stephens)
//=============================================================================

BOOL
CreduiIsWildcardTargetName(
    WCHAR *targetName
    )
{
    if ((targetName != NULL) && (targetName[0] != L'\0'))
    {
        return (targetName[0] == L'*') ||
               (targetName[wcslen(targetName) - 1] == L'*');
    }
    else
    {
        return FALSE;
    }
}

//
// returns TRUE if pszUserName exists as a prefix of pszCredential
//
// The UserName can either be an exact match or must be a prefix of a significant component.
//  That is, the first unmatched character must be an @ or \ character

BOOL
LookForUserNameMatch (
    const WCHAR * pszUserName,
    const WCHAR * pszCredential
    )
{
    ULONG length;
    int cmp;

    if ( pszUserName == NULL || pszCredential == NULL )
        return FALSE;

    length = wcslen ( pszUserName );
    if ( length <= 0 )
        return FALSE;

    if ( _wcsicmp ( pszUserName, pszCredential ) == 0 )
        return TRUE;

    if ( _wcsnicmp ( pszUserName, pszCredential, length ) == 0 ) {
        if ( pszCredential[length] == '@' || pszCredential[length] == '\\' ) {
            return TRUE;
        }
    }

    // didn't find it
    return FALSE;
}

// copies the marshalled name of pCert into pszMarshalledName.
// pszMarshalledName must be at least CREDUI_MAX_USERNAME_LENGTH in length
//
// returns TRUE if successful, FALSE if not
BOOL
CredUIMarshallNode (
    CERT_ENUM * pCert,
    WCHAR* pszMarshalledName
    )
{
    BOOL bMarshalled = FALSE;

    // marshall username
    WCHAR *marshaledCred;
    CERT_CREDENTIAL_INFO certCredInfo;

    certCredInfo.cbSize = sizeof certCredInfo;

    if (pCert != NULL)
    {
        DWORD length = CERT_HASH_LENGTH;

        if (CertGetCertificateContextProperty(
                pCert->pCertContext,
                CERT_SHA1_HASH_PROP_ID,
                static_cast<VOID *>(
                    certCredInfo.rgbHashOfCert),
                &length))
        {
            if (LocalCredMarshalCredentialW(CertCredential,
                                      &certCredInfo,
                                      &marshaledCred))
            {
                if (SUCCEEDED(StringCchCopyW(
                        pszMarshalledName,
                        CREDUI_MAX_USERNAME_LENGTH,
                        marshaledCred)))
                {
                    bMarshalled = TRUE;
                }

                LocalCredFree(static_cast<VOID *>(marshaledCred));
            }
        }
    }

    return bMarshalled;
}

#define MAX_KEY_LENGTH   1024


// removes any leading *. from pszIn and copies the right hand portion to pszOut.
// Assumes pszOut is at least MAX_KEY_LENGTH in size
void
StripLeadingWildcard (
    WCHAR* pszIn,
    WCHAR* pszOut )
{
    WCHAR* pStartPtr = pszIn;

    if ( wcslen ( pszIn ) > 2 )
    {
        if ( pszIn[0] == L'*' && pszIn[1] == L'.' )
        {
            pStartPtr += 2;
        }
    }

    StringCchCopyW(pszOut, MAX_KEY_LENGTH, pStartPtr);
}


// copies pszIn to pszOut and trucates pszOut at the first '\'
// Assumes pszOut is at least MAX_KEY_LENGTH in size
void
StripTrailingWildcard (
    WCHAR* pszIn,
    WCHAR* pszOut )
{
    StringCchCopyW(pszOut, MAX_KEY_LENGTH, pszIn);

    wcstok ( pszOut, L"\\" );
}


// Looks in the registry for an SSO entry for the specified package.
// Fills in the SSOPackage struct and returns TRUE if found.  Returns
// FALSE if no registry entry found
BOOL
GetSSOPackageInfo (
    CREDENTIAL_TARGET_INFORMATION* pTargetInfo,
    SSOPACKAGE* pSSOStruct
    )
{
    BOOL bSSO = FALSE;
    WCHAR szKeyName[MAX_KEY_LENGTH];
    HKEY key;
    DWORD dwType;
    DWORD dwSize;

    WCHAR szSSOName[MAX_KEY_LENGTH];

    if ( pSSOStruct == NULL )
    {
        return FALSE;
    }

    pSSOStruct->szBrand[0] = '\0';
    pSSOStruct->szURL[0] = '\0';
    pSSOStruct->szAttrib[0] = '\0';
    pSSOStruct->dwRegistrationCompleted = 0;
    pSSOStruct->dwNumRegistrationRuns = 0;
    pSSOStruct->pRegistrationWizard = NULL;

    // figure out SSO Name from Target Info
    if ( pTargetInfo == NULL )
    {
        return FALSE;
    }

    if ((pTargetInfo->PackageName == NULL) ||
        FAILED(StringCchCopyW(
            szSSOName,
            RTL_NUMBER_OF(szSSOName),
            pTargetInfo->PackageName)))
    {
        return FALSE;
    }

    StringCchPrintfW(
        szKeyName,
        RTL_NUMBER_OF(szKeyName),
        L"SYSTEM\\CurrentControlSet\\Control\\Lsa\\SSO\\%s",
        szSSOName);

    if ( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            szKeyName,
            0,
            KEY_READ,
            &key) == ERROR_SUCCESS)
    {
        dwSize = MAX_SSO_URL_SIZE * sizeof(WCHAR);

        bSSO = TRUE;

        if ( RegQueryValueEx(
                key,
                L"SSOBrand",
                NULL,
                &dwType,
                (LPBYTE)(pSSOStruct->szBrand),
                &dwSize) == ERROR_SUCCESS )
        {
            bSSO = TRUE;
        }

        dwSize = MAX_SSO_URL_SIZE * sizeof(WCHAR);
        if ( RegQueryValueEx(
                key,
                L"SSOAttribute",
                NULL,
                &dwType,
                (LPBYTE)(pSSOStruct->szAttrib),
                &dwSize ) != ERROR_SUCCESS )
        {
            if ( wcsstr ( szSSOName, L"Passport" ) )
            {
                StringCchCopyW(
                    pSSOStruct->szAttrib,
                    RTL_NUMBER_OF(pSSOStruct->szAttrib),
                    L"Passport");
            }
        }

        RegCloseKey(key);
    }

    // Now get stuff under Internet Settings
    StringCchPrintfW(
        szKeyName,
        RTL_NUMBER_OF(szKeyName),
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\%s",
        pSSOStruct->szAttrib);

    if ( RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                szKeyName,
                0,
                KEY_READ,
                &key) == ERROR_SUCCESS)
    {
        dwSize = MAX_SSO_URL_SIZE * sizeof(WCHAR);
        if ( RegQueryValueEx(
                key,
                L"RegistrationUrl",
                NULL,
                &dwType,
                (LPBYTE)(pSSOStruct->szRegURL),
                &dwSize) == ERROR_SUCCESS )
        {
        }

        dwSize = MAX_SSO_URL_SIZE * sizeof(WCHAR);
        if ( RegQueryValueEx(
                key,
                L"Help",
                NULL,
                &dwType,
                (LPBYTE)(pSSOStruct->szHelpURL),
                &dwSize) == ERROR_SUCCESS )
        {
        }

        RegCloseKey(key);
    }

    if ( RegOpenKeyEx(
            HKEY_CURRENT_USER,
            szKeyName,
            0,
            KEY_READ,
            &key) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        if ( RegQueryValueEx(
                key,
                L"RegistrationCompleted",
                NULL,
                &dwType,
                (LPBYTE)&(pSSOStruct->dwRegistrationCompleted),
                &dwSize ) == ERROR_SUCCESS )
        {
        }

        dwSize = sizeof(DWORD);
        if ( RegQueryValueEx(
                key,
                L"NumRegistrationRuns",
                NULL,
                &dwType,
                (LPBYTE)&(pSSOStruct->dwNumRegistrationRuns),
                &dwSize ) == ERROR_SUCCESS )
        {
        }

        RegCloseKey(key);
    }

    // TBD - get regwizard CLSID
    if ( bSSO && IsDeaultSSORealm ( pTargetInfo->DnsDomainName ) )
    {
        pSSOStruct->pRegistrationWizard = &CLSID_PassportWizard;
    }

    return bSSO;
}

// returns TRUE if it was found, with the value copied to pszRealm.
// pszRealm is expected to be at least (DNS_MAX_NAME_LENGTH + 1) in length
// returns FALSE if not found
BOOL ReadPassportRealmFromRegistry (
    WCHAR* pszRealm
    )
{
    BOOL retval = FALSE;
    HKEY key;

    if ( pszRealm == NULL )
    {
        return FALSE;
    }

    if ( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
            0,
            KEY_READ,
            &key) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD dwSize;

        dwSize = (DNS_MAX_NAME_LENGTH + 1) * sizeof(WCHAR);

        if ( RegQueryValueEx(
                key,
                L"LoginServerRealm",
                NULL,
                &dwType,
                (LPBYTE)(pszRealm),
                &dwSize) == ERROR_SUCCESS )
        {
            if ( ( dwType == REG_SZ ) &&
                 ( dwSize >= 4 ) &&
                 ( pszRealm[(dwSize - 1) / sizeof(WCHAR)] == L'\0') )
            {
                retval = TRUE;
            }
            else
            {
                retval = FALSE;
            }
        }
        else
        {
            retval = FALSE;
            pszRealm[0] = L'\0';
        }

        RegCloseKey(key);
    }

    return retval;

}

BOOL CheckForSSOCred( WCHAR* pszTargetRealm )
{
    BOOL bIsItThere = FALSE;

    WCHAR szTargetName[CREDUI_MAX_DOMAIN_TARGET_LENGTH + 1];

    if ( pszTargetRealm != NULL )
    {
        StringCchCopyExW(
            szTargetName,
            RTL_NUMBER_OF(szTargetName) - 2,
            pszTargetRealm,
            NULL,
            NULL,
            STRSAFE_NULL_ON_FAILURE);
    }
    else
    {
        GetDeaultSSORealm ( szTargetName, FALSE );
    }

    if (szTargetName[0] != L'\0')
    {
        // finalize the target name, ensuring that the tail will fit.
        if (SUCCEEDED(StringCchCatW(
                szTargetName,
                RTL_NUMBER_OF(szTargetName),
                L"\\*")))
        {
            PCREDENTIALW pCred;
            DWORD dwFlags = 0;

            // first call credmgr to set the target info
            if ( CredReadW ( szTargetName,
                        CRED_TYPE_DOMAIN_VISIBLE_PASSWORD,
                        dwFlags,
                        &pCred ) )
            {
                bIsItThere = TRUE;

                CredFree ( pCred );
            }
        }
    }

    return bIsItThere;
}

EXTERN_C typedef BOOL (STDAPICALLTYPE *PFN_FORCENEXUSLOOKUP)();

void GetDeaultSSORealm ( WCHAR* pszTargetName, BOOL bForceLookup )
{
    if ( pszTargetName == NULL )
    {
        return;
    }

    pszTargetName[0] = L'\0';

    // check the registry to see if we've already written the passport
    if ( ! ReadPassportRealmFromRegistry ( pszTargetName ) && bForceLookup )
    {
        // if not, call winiet to do this and then re-read the registry

        HMODULE hWininet = LoadLibrary(L"wininet.dll");
        if ( hWininet )
        {

            PFN_FORCENEXUSLOOKUP pfnForceNexusLookup = (PFN_FORCENEXUSLOOKUP)GetProcAddress(hWininet, "ForceNexusLookup");
            if ( pfnForceNexusLookup )
            {
                pfnForceNexusLookup();
            }

            FreeLibrary ( hWininet );
        }

        // try again
        if ( ! ReadPassportRealmFromRegistry ( pszTargetName ) )
        {
            return;
        }
    }
}

// returns TRUE if the targetrealm equals the default
BOOL IsDeaultSSORealm ( WCHAR* pszTargetName )
{
    BOOL bRet = FALSE;

    if ( pszTargetName == NULL )
    {
        return FALSE;   // can't be the default if it doesn't exist
    }

    WCHAR szTarget[DNS_MAX_NAME_LENGTH + 1];

    GetDeaultSSORealm ( szTarget, TRUE );

    if ( wcslen ( szTarget ) > 0 )
    {
        if ( _wcsicmp ( szTarget, pszTargetName) == 0 )
        {
            bRet = TRUE;
        }
    }
    
    return bRet;
}

// encrypt cred

DWORD EncryptPassword ( PWSTR pszPassword, PVOID* ppszEncryptedPassword, DWORD* pSize )
{
    DWORD dwResult = ERROR_GEN_FAILURE;

    if ( pszPassword == NULL || ppszEncryptedPassword == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    DATA_BLOB InBlob;
    DATA_BLOB OutBlob;

    InBlob.pbData = (BYTE*)pszPassword;
    InBlob.cbData = sizeof(WCHAR)*(wcslen(pszPassword)+1);

    DATA_BLOB EntropyBlob;
    WCHAR szSalt[SIZE_OF_SALT];
    
    // g_szSalt is a constant, cc = SIZE_OF_SALT including the null.
    StringCchCopyW(szSalt, RTL_NUMBER_OF(szSalt), g_szSalt);
    
    for ( int i = 0; i < SIZE_OF_SALT; i++ )
    {
        szSalt[i] <<= SALT_SHIFT;
    }
    EntropyBlob.pbData = (BYTE*)szSalt;
    EntropyBlob.cbData = sizeof(WCHAR)*(wcslen(szSalt)+1);

    if ( CryptProtectData ( &InBlob,
                            L"SSOCred",
                            &EntropyBlob,           // optional entropy
//                            NULL,           // optional entropy
                            NULL,
                            NULL,
                            CRYPTPROTECT_UI_FORBIDDEN,
                            &OutBlob ) )
    {

        *ppszEncryptedPassword = (PWSTR)LocalAlloc(LMEM_ZEROINIT, OutBlob.cbData);
        if ( *ppszEncryptedPassword )
        {
            memcpy ( *ppszEncryptedPassword, OutBlob.pbData, OutBlob.cbData );
            *pSize = OutBlob.cbData;
            dwResult = ERROR_SUCCESS;
        }
        LocalFree ( OutBlob.pbData );
    }

    SecureZeroMemory(szSalt, sizeof szSalt);

    return dwResult;
}

BOOL IsPasswordEncrypted ( PVOID pPassword, DWORD cbSize )
{
    BOOL bRet = FALSE;

    DATA_BLOB InBlob;
    DATA_BLOB OutBlob;
    LPWSTR pszDesc;

    InBlob.pbData = (BYTE*)pPassword;
    InBlob.cbData = cbSize;

    DATA_BLOB EntropyBlob;
    WCHAR szSalt[SIZE_OF_SALT];

    // g_szSalt is a constant, cc = SIZE_OF_SALT including the null.
    StringCchCopyW(szSalt, RTL_NUMBER_OF(szSalt), g_szSalt);
    
    for ( int i = 0; i < SIZE_OF_SALT; i++ )
    {
        szSalt[i] <<= SALT_SHIFT;
    }
    EntropyBlob.pbData = (BYTE*)szSalt;
    EntropyBlob.cbData = sizeof(WCHAR)*(wcslen(szSalt)+1);
    
    if ( CryptUnprotectData ( &InBlob,
                            &pszDesc,
                            &EntropyBlob,
//                            NULL,
                            NULL,
                            NULL,
                            CRYPTPROTECT_UI_FORBIDDEN,
                            &OutBlob ) )
    {

        if ( wcscmp (L"SSOCred", pszDesc) == 0 )
        {
            bRet = TRUE;
        }
        LocalFree ( pszDesc );
        LocalFree ( OutBlob.pbData );
    }

    SecureZeroMemory(szSalt, sizeof szSalt);

    return bRet;
}

// cred confirmation routines

VOID
DeleteConfirmationListEntry (
    IN CRED_AWAITING_CONFIRMATION* pConf
    )
/*++

Routine Description:

    This routine deletes a single confirmation list entry.

Arguments:

    pConf - Confirmation list entry to delete

Return Values:

    None.

--*/
{
    //
    // Delete the target info
    //

    if ( pConf->TargetInfo != NULL ) {
        LocalCredFree( pConf->TargetInfo );
    }

    //
    // Delete the credential
    //

    if ( pConf->EncodedCredential != NULL ) {

        if ( pConf->EncodedCredential->CredentialBlobSize != 0 &&
             pConf->EncodedCredential->CredentialBlob != NULL ) {

            SecureZeroMemory( pConf->EncodedCredential->CredentialBlob,
                              pConf->EncodedCredential->CredentialBlobSize );

        }
        LocalCredFree( pConf->EncodedCredential );
    }

    //
    // Free the confirmation list entry itself
    //
    delete (pConf);
}

DWORD
WriteCred(
    IN PCWSTR pszTargetName,
    IN DWORD Flags,
    IN PCREDENTIAL_TARGET_INFORMATION TargetInfo OPTIONAL,
    IN PCREDENTIAL Credential,
    IN DWORD dwCredWriteFlags,
    IN BOOL DelayCredentialWrite,
    IN BOOL EncryptedVisiblePassword
    )

/*++

Routine Description:

    This routine writes a credential.

    If the credential needs confirmation, the credential will be added to the
    confirmation list.

Arguments:

    pszTargetName - The target name of the resource that caused the credential to be
        written.

    Flags - Flags passed by the original caller.
        CREDUI_FLAGS_EXPECT_CONFIRMATION - Specifies that the credential is to be written
            to the confirmation list instead of being written immediately.

    TargetInfo - The target information associated with the target name.
        If not specified, the target informatio isn't known.

    Credential - The credential that is to be written.

    dwCredWriteFlags - Flags to pass to CredWrite when writing the credential

    DelayCredentialWrite - TRUE if the credential is to be written only upon confirmation.
        FALSE, if the credential is to be written now as a session credential then
            morphed to a more persistent credential upon confirmation.
        This field is ignored if Flags doesn't specify CREDUI_FLAGS_EXPECT_CONFIRMATION.

Return Values:

    TRUE - The cred was sucessfully added to the confirmation list.

    FALSE - There isn't enough memory to add the cred to the confirmation list.

--*/
{
    DWORD Win32Status = NO_ERROR;
    BOOL WriteCredNow;
    PVOID pCredentialBlob = NULL;
    DWORD dwCredentialBlobSize = 0;
    CREDENTIAL TempCredential;

    CreduiDebugLog("WriteCred called for %S, with flags %x, delay %x\n",pszTargetName,Flags,DelayCredentialWrite);

    //
    // Check to see if we should wait for confirmation
    //
    // ISSUE-2000/12/14-CliffV - there's no reason to avoid adding 'visible' passwords to
    //  the confirmation list.
    //

    if ( (Flags & CREDUI_FLAGS_EXPECT_CONFIRMATION) != 0 &&
         Credential->Type != CRED_TYPE_DOMAIN_VISIBLE_PASSWORD ) {

        if ( AddCredToConfirmationList ( pszTargetName,
                                         TargetInfo,
                                         Credential,
                                         dwCredWriteFlags,
                                         DelayCredentialWrite ) ) {

            //
            // Alter cred persistence type
            //  Then, at least, the credential will disappear upon logoff
            //

            Credential->Persist = CRED_PERSIST_SESSION;
            WriteCredNow = !DelayCredentialWrite;

        } else {

            // If we couldn't queue the CredWrite, do it now.
            WriteCredNow = TRUE;
        }

    //
    // If the caller doesn't supply a confirmation,
    //  write the credential now.
    //
    } else {
        WriteCredNow = TRUE;
    }

    //
    // Determine if we should encrypt the visible password
    //
    if ( Credential->Type == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD && EncryptedVisiblePassword ) {

        // encrypt it

        Win32Status = EncryptPassword ( (WCHAR*)Credential->CredentialBlob,
                                        &pCredentialBlob,
                                        &dwCredentialBlobSize );
        if ( Win32Status == ERROR_SUCCESS )
        {

            // Make a copy of the credential so we don't modify the original

            TempCredential = *Credential;
            Credential = &TempCredential;

            Credential->CredentialBlob = (LPBYTE)pCredentialBlob;
            Credential->CredentialBlobSize = dwCredentialBlobSize;
        }
    }

    //
    // If the credential needs to be written now,
    //  do it
    //

    if ( WriteCredNow && Win32Status == NO_ERROR ) { // ERROR_SUCCESS == NO_ERROR == 0

        if ( TargetInfo != NULL ) {
            if ( !LocalCredWriteDomainCredentialsW ( TargetInfo, Credential, dwCredWriteFlags) ) {
                Win32Status = GetLastError();
            }
        } else {
            if (!LocalCredWriteW( Credential, dwCredWriteFlags)) {
                Win32Status = GetLastError();
            }

        }
    }

    //
    // Free any credential blob we allocated.
    if ( pCredentialBlob )
    {
        SecureZeroMemory ( pCredentialBlob, dwCredentialBlobSize );
        LocalFree ( pCredentialBlob );
    }

    return Win32Status;
}

BOOL
AddCredToConfirmationList (
    IN PCWSTR pszTargetName,
    IN PCREDENTIAL_TARGET_INFORMATION TargetInfo OPTIONAL,
    IN PCREDENTIAL Credential,
    IN DWORD dwCredWriteFlags,
    IN BOOL DelayCredentialWrite
    )

/*++

Routine Description:

    This routine adds a credential to the confirmation list.  Such a credential must
    be confirmed at a later point in time or it will be deleted.

Arguments:

    pszTargetName - The target name of the resource that caused the credential to be
        written.  This target name is the handle used to identify the confirmation list
        entry.

    TargetInfo - The target information associated with the target name.
        If not specified, the target informatio isn't known.

    Credential - The credential that is to be written.

    dwCredWriteFlags - Flags to pass to CredWrite when writing the credential

    DelayCredentialWrite - TRUE if the credential is to be written only upon confirmation.
        FALSE, if the credential is to be written now as a session credential then
            morphed to a more persistent credential upon confirmation.

Return Values:

    TRUE - The cred was sucessfully added to the confirmation list.

    FALSE - There isn't enough memory to add the cred to the confirmation list.

--*/
{
    DWORD Win32Status;

    BOOLEAN bRetVal;
    CRED_AWAITING_CONFIRMATION* pNewEntry = NULL;
    CRED_AWAITING_CONFIRMATION* pOldEntry;

    CreduiDebugLog(
        "AddCredToConfirmationList: "
        "Called for target %S with target info %x\n",
        pszTargetName,(void *)TargetInfo);

    //
    // Allocate the entry itself
    //
    pNewEntry = new CRED_AWAITING_CONFIRMATION;

    if ( pNewEntry == NULL ) {
        bRetVal = FALSE;
        goto Cleanup;
    }

    //
    // Fill in the
    StringCchCopyW(
        pNewEntry->szTargetName,
        RTL_NUMBER_OF(pNewEntry->szTargetName),
        pszTargetName);
    pNewEntry->EncodedCredential = NULL;
    pNewEntry->TargetInfo = NULL;
    pNewEntry->DelayCredentialWrite = DelayCredentialWrite;
    pNewEntry->dwCredWriteFlags =dwCredWriteFlags;

    //
    // Make a copy of the target info
    //

    if ( TargetInfo != NULL ) {
        Win32Status = CredpConvertTargetInfo (
                                DoWtoW,
                                TargetInfo,
                                &pNewEntry->TargetInfo,
                                NULL );

        if ( Win32Status != NO_ERROR ) {
            bRetVal = FALSE;
            goto Cleanup;
        }

    }

    //
    // Make a copy of the credential
    //

    Win32Status = CredpConvertCredential (
                            DoWtoW,
                            DoBlobEncode,      // Encode the copied credential
                            Credential,
                            &pNewEntry->EncodedCredential );

    if ( Win32Status != NO_ERROR ) {
        bRetVal = FALSE;
        goto Cleanup;
    }

    //
    // Delete any existing entry
    //  (Wait until the new entry is allocated to ensure we don't delete the old
    //  entry when failing to create the new one.)
    //

    ConfirmCred( pszTargetName, FALSE, FALSE );

    //
    // Link the new entry into the global list
    //

    EnterCriticalSection( &CredConfirmationCritSect );
    
    if ( pCredConfirmationListHead == NULL) {
        pNewEntry->pNext = NULL;
    } else {
        pNewEntry->pNext = (void*)pCredConfirmationListHead;
    }

    pCredConfirmationListHead = pNewEntry;
    LeaveCriticalSection( &CredConfirmationCritSect );

    pNewEntry = NULL;

    bRetVal = TRUE;

    //
    // Release any locally used resources
    //
Cleanup:
    //
    // Free any partially allocated entry
    //

    if ( pNewEntry != NULL) {
        DeleteConfirmationListEntry( pNewEntry );
    }

    // Trim the list to 5 entries total
    INT i=0;                    // count the entries
    if ((pOldEntry = pCredConfirmationListHead) != NULL)
    {
        EnterCriticalSection( &CredConfirmationCritSect );
        while((pNewEntry = (CRED_AWAITING_CONFIRMATION*)(pOldEntry->pNext)) != NULL)
        {
            if (++i > 4)
            {
                // leave old (5th) entry alone, and remove all following one at a time
                pOldEntry->pNext = pNewEntry->pNext;
                CreduiDebugLog(
                    "AddCredToConfirmationList: "
                    "Removing excess waiting credential #%d for %S\n",
                    i,pNewEntry->szTargetName);
                // discard this record and continue to end
                DeleteConfirmationListEntry(pNewEntry);
            }
            else 
            {
                pOldEntry = pNewEntry;
                CreduiDebugLog(
                    "AddCredToConfirmationList: "
                    "Walking the list #%d\n",
                    i);
            }
        }
        LeaveCriticalSection( &CredConfirmationCritSect );
    }

    return bRetVal;
}

DWORD
ConfirmCred (
    IN PCWSTR pszTargetName,
    IN BOOL bConfirm,
    IN BOOL bOkToDelete
    )

/*++

Routine Description:

    This routine either confirms (bConfirm = TRUE ) or cancels (bConfirm = FALSE) the credential

Arguments:

    pszTargetName - The target name of the resource that caused the credential to be
        written.  This target name is the handle used to identify the confirmation list
        entry.

        ISSUE-2000/11/29-CliffV: We shouldn't be using pszTargetName as the handle.  It isn't
        specific enough.  We should use something that maps to a particular credential with a
        particular type.

    bConfirm - If TRUE, commits the credential.
        If FALSE, Aborts the transaction.  Deletes the transaction history.

    bOkToDelete - If TRUE and bConfirm is FALSE, any session credential created at the
        beginning of the transaction is deleted.  If FALSE, any session credential created at
        the begining of the transaction remains.

Return Values:

    Status of the operation.

--*/
{
    DWORD Result = NO_ERROR;

    CRED_AWAITING_CONFIRMATION* pPrev = NULL;
    CRED_AWAITING_CONFIRMATION* pConf;

    //
    // Find the credential in the global list.
    //
    CreduiDebugLog("ConfirmCred: Cred %S confirm %x.\n",pszTargetName,bConfirm );

    EnterCriticalSection( &CredConfirmationCritSect );
    pConf = pCredConfirmationListHead;

    while ( pConf != NULL ) {

        if ( _wcsicmp ( pszTargetName, pConf->szTargetName ) == 0 ) {
            break;
        }

        pPrev = pConf;
        pConf = (CRED_AWAITING_CONFIRMATION*)pConf->pNext;
    }

    //
    // We found the cred indicated
    //
    if (pConf == NULL) {
        //return ERROR_NOT_FOUND;       cannot return here
        Result = ERROR_NOT_FOUND;
        goto Cleanup;
    } 
    else {

        //
        // If the caller wants to commit the change,
        //  do it by writing the cred to cred manager.
        //
        // This works even if DelayCredentialWrite is false.
        // In that case, a session persistent credential has already been written.
        // However, the cached credential is better than that credential in every respect.
        //

        if ( bConfirm ) {

            //
            // Decode the Credential before writing it
            //

            if (!CredpDecodeCredential( (PENCRYPTED_CREDENTIALW)pConf->EncodedCredential ) ) {

                Result = ERROR_INVALID_PARAMETER;

            //
            // Actually write the credential
            //

            } else if ( pConf->TargetInfo != NULL ) {

                if ( !LocalCredWriteDomainCredentialsW ( pConf->TargetInfo,
                                                         pConf->EncodedCredential,
                                                         pConf->dwCredWriteFlags) ) {

                    Result = GetLastError();
                }

            } else {

                if ( !LocalCredWriteW ( pConf->EncodedCredential,
                                        pConf->dwCredWriteFlags) ) {

                    Result = GetLastError();
                }
            }

        //
        // If the caller wants to abort the commit,
        //  delete any credential credui already created.
        //

        } else {

            //
            // Only do this if credui actually wrote the credential.
            //
            // Note there is a timing window where we might be deleting a credential
            //  other than the one credui just wrote.  However, we're weeding out
            //  the applications that don't use DelayCredentialWrite.  That's the
            //  real fix.  In the mean time, it is better to delete creds that that
            //  don't work.
            //

            if ( !pConf->DelayCredentialWrite && bOkToDelete ) {

                if ( !LocalCredDeleteW ( pConf->EncodedCredential->TargetName,
                                         pConf->EncodedCredential->Type,
                                         0 ) ) {

                    Result = GetLastError();
                }
            }
        }

        //
        // remove it from list
        //

        if ( pPrev ) {
            pPrev->pNext = pConf->pNext;
        } else {
            pCredConfirmationListHead = (CRED_AWAITING_CONFIRMATION*)(pConf->pNext);
        }

        DeleteConfirmationListEntry(pConf);
    }
Cleanup:
    LeaveCriticalSection( &CredConfirmationCritSect );
    return Result;
}

void
CleanUpConfirmationList ()
{
    CRED_AWAITING_CONFIRMATION* pNext;
    CRED_AWAITING_CONFIRMATION* pConf;

    EnterCriticalSection( &CredConfirmationCritSect );
    pConf = pCredConfirmationListHead;

    while ( pConf != NULL )
    {

        pNext = (CRED_AWAITING_CONFIRMATION*)pConf->pNext;
        DeleteConfirmationListEntry(pConf);
        pConf = pNext;

    }

    pCredConfirmationListHead = NULL;
    LeaveCriticalSection( &CredConfirmationCritSect );

    //
    // Delete the Critical Section used to serialize access to the global list
    //

    DeleteCriticalSection( &CredConfirmationCritSect );
}

BOOL
InitConfirmationList ()
{
    //
    // Initialize the Critical Section used to serialize access to the global list
    //
    pCredConfirmationListHead = NULL;
    return InitializeCriticalSectionAndSpinCount( &CredConfirmationCritSect, 0 );

}

/////////////////
// wincred.h dynamic stuff
//

BOOL bCredMgrAvailable = FALSE;
PFN_CREDWRITEW pfnCredWriteW = NULL;
PFN_CREDREADW pfnCredReadW = NULL;
PFN_CREDENUMERATEW pfnCredEnumerateW = NULL;
PFN_CREDWRITEDOMAINCREDENTIALSW pfnCredWriteDomainCredentialsW = NULL;
PFN_CREDREADDOMAINCREDENTIALSW pfnCredReadDomainCredentialsW = NULL;
PFN_CREDDELETEW pfnCredDeleteW = NULL;
PFN_CREDRENAMEW pfnCredRenameW = NULL;
PFN_CREDGETTARGETINFOW pfnCredGetTargetInfoW = NULL;
PFN_CREDMARSHALCREDENTIALW pfnCredMarshalCredentialW = NULL;
PFN_CREDUNMARSHALCREDENTIALW pfnCredUnMarshalCredentialW = NULL;
PFN_CREDISMARSHALEDCREDENTIALW pfnCredIsMarshaledCredentialW = NULL;
PFN_CREDISMARSHALEDCREDENTIALA pfnCredIsMarshaledCredentialA = NULL;
PFN_CREDGETSESSIONTYPES pfnCredGetSessionTypes = NULL;
PFN_CREDFREE pfnCredFree = NULL;

// attempts to load credmgr functions - returns TRUE if credmgr is avail, FALSE if not
BOOL
InitializeCredMgr ()
{
    bCredMgrAvailable = FALSE;

    if ( hAdvapi32 == NULL )
        hAdvapi32 = LoadLibrary(L"advapi32.dll");

    if ( hAdvapi32 != NULL )
    {
        pfnCredWriteW = (PFN_CREDWRITEW)
            GetProcAddress(hAdvapi32, "CredWriteW");
        if (*pfnCredWriteW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredReadW = (PFN_CREDREADW)
            GetProcAddress(hAdvapi32, "CredReadW");
        if (*pfnCredReadW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredEnumerateW = (PFN_CREDENUMERATEW)
            GetProcAddress(hAdvapi32, "CredEnumerateW");
        if (*pfnCredEnumerateW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredWriteDomainCredentialsW = (PFN_CREDWRITEDOMAINCREDENTIALSW)
            GetProcAddress(hAdvapi32, "CredWriteDomainCredentialsW");
        if (*pfnCredWriteDomainCredentialsW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredReadDomainCredentialsW = (PFN_CREDREADDOMAINCREDENTIALSW)
            GetProcAddress(hAdvapi32, "CredReadDomainCredentialsW");
        if (*pfnCredReadDomainCredentialsW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredDeleteW = (PFN_CREDDELETEW)
            GetProcAddress(hAdvapi32, "CredDeleteW");
        if (*pfnCredDeleteW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredRenameW = (PFN_CREDRENAMEW)
            GetProcAddress(hAdvapi32, "CredRenameW");
        if (*pfnCredRenameW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredGetTargetInfoW = (PFN_CREDGETTARGETINFOW)
            GetProcAddress(hAdvapi32, "CredGetTargetInfoW");
        if (*pfnCredGetTargetInfoW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredMarshalCredentialW = (PFN_CREDMARSHALCREDENTIALW)
            GetProcAddress(hAdvapi32, "CredMarshalCredentialW");
        if (*pfnCredMarshalCredentialW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredUnMarshalCredentialW = (PFN_CREDUNMARSHALCREDENTIALW)
            GetProcAddress(hAdvapi32, "CredUnmarshalCredentialW");
        if (*pfnCredUnMarshalCredentialW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredIsMarshaledCredentialW = (PFN_CREDISMARSHALEDCREDENTIALW)
            GetProcAddress(hAdvapi32, "CredIsMarshaledCredentialW");
        if (*pfnCredIsMarshaledCredentialW == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredIsMarshaledCredentialA = (PFN_CREDISMARSHALEDCREDENTIALA)
            GetProcAddress(hAdvapi32, "CredIsMarshaledCredentialA");
        if (*pfnCredIsMarshaledCredentialA == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredGetSessionTypes = (PFN_CREDGETSESSIONTYPES)
            GetProcAddress(hAdvapi32, "CredGetSessionTypes");
        if (*pfnCredGetSessionTypes == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        pfnCredFree = (PFN_CREDFREE)
            GetProcAddress(hAdvapi32, "CredFree");
        if (*pfnCredFree == NULL)
        {
            FreeLibrary(hAdvapi32);
            hAdvapi32 = NULL;
            goto Exit;
        }

        bCredMgrAvailable = TRUE;
    }

Exit:

    return bCredMgrAvailable;
}

void
UninitializeCredMgr ()
{
    if ( hAdvapi32 != NULL )
        FreeLibrary(hAdvapi32);

    bCredMgrAvailable = FALSE;
}

/////////////////////
// Local functions to indirect CredMgr funcs
//

BOOL
WINAPI
LocalCredWriteW (
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    )
{
    if ( bCredMgrAvailable && pfnCredWriteW != NULL )
    {
        if (pfnCredWriteW(Credential,Flags))
        {
            return TRUE;
        }
        else
        {
            if (ERROR_INVALID_PARAMETER == GetLastError())
            {
                // attempt to null the alias field of the cred and try again
                Credential->TargetAlias = NULL;
                return pfnCredWriteW(Credential,Flags);
            }
            else
            {
                // Something else was wrong
                return FALSE;
            }
        }
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredReadW (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags,
    OUT PCREDENTIALW *Credential
    )
{
    if ( bCredMgrAvailable && pfnCredReadW != NULL )
    {
        return pfnCredReadW ( TargetName, Type, Flags, Credential );
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredEnumerateW (
    IN LPCWSTR Filter,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    )
{
    if ( bCredMgrAvailable && pfnCredEnumerateW != NULL )
    {
        return pfnCredEnumerateW ( Filter, Flags, Count, Credential );
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredWriteDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    )
{
    if ( bCredMgrAvailable && pfnCredWriteDomainCredentialsW != NULL )
    {
        if (pfnCredWriteDomainCredentialsW ( TargetInfo, Credential, Flags ))
        {
            return TRUE;
        }
        else
        {
            if (ERROR_INVALID_PARAMETER == GetLastError())
            {
                // attempt to null the alias field of the cred and try again
                Credential->TargetAlias = NULL;
                return pfnCredWriteDomainCredentialsW ( TargetInfo, Credential, Flags );
            }
            else
            {
                return FALSE;
            }
        }
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredReadDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    )
{
    if ( bCredMgrAvailable && pfnCredReadDomainCredentialsW != NULL )
    {
        return pfnCredReadDomainCredentialsW ( TargetInfo, Flags, Count, Credential );
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredDeleteW (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags
    )
{
    if ( bCredMgrAvailable && pfnCredDeleteW != NULL )
    {
        return pfnCredDeleteW ( TargetName, Type, Flags );
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredRenameW (
    IN LPCWSTR OldTargetName,
    IN LPCWSTR NewTargetName,
    IN DWORD Type,
    IN DWORD Flags
    )
{
    if ( bCredMgrAvailable && pfnCredRenameW != NULL )
    {
        return pfnCredRenameW ( OldTargetName, NewTargetName, Type, Flags );
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredGetTargetInfoW (
    IN LPCWSTR TargetName,
    IN DWORD Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    )
{
    if ( bCredMgrAvailable && pfnCredGetTargetInfoW != NULL )
    {
        return pfnCredGetTargetInfoW ( TargetName, Flags, TargetInfo);
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredMarshalCredentialW(
    IN CRED_MARSHAL_TYPE CredType,
    IN PVOID Credential,
    OUT LPWSTR *MarshaledCredential
    )
{
    if ( bCredMgrAvailable && pfnCredMarshalCredentialW != NULL )
    {
        return pfnCredMarshalCredentialW ( CredType, Credential, MarshaledCredential );
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredUnmarshalCredentialW(
    IN LPCWSTR MarshaledCredential,
    OUT PCRED_MARSHAL_TYPE CredType,
    OUT PVOID *Credential
    )
{
    if ( bCredMgrAvailable && pfnCredUnMarshalCredentialW != NULL )
    {
        return pfnCredUnMarshalCredentialW ( MarshaledCredential, CredType, Credential );
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredIsMarshaledCredentialW(
    IN LPCWSTR MarshaledCredential
    )
{
    if ( bCredMgrAvailable && pfnCredIsMarshaledCredentialW != NULL )
    {
        return pfnCredIsMarshaledCredentialW ( MarshaledCredential );
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredIsMarshaledCredentialA(
    IN LPCSTR MarshaledCredential
    )
{
    if ( bCredMgrAvailable && pfnCredIsMarshaledCredentialA != NULL )
    {
        return pfnCredIsMarshaledCredentialA ( MarshaledCredential );
    }
    else
    {
        return FALSE;
    }
}

BOOL
WINAPI
LocalCredGetSessionTypes (
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    )
{
    if ( bCredMgrAvailable && pfnCredGetSessionTypes != NULL )
    {
        return pfnCredGetSessionTypes ( MaximumPersistCount, MaximumPersist );
    }
    else
    {
        return FALSE;
    }
}

VOID
WINAPI
LocalCredFree (
    IN PVOID Buffer
    )
{
    if ( bCredMgrAvailable && pfnCredFree != NULL )
    {
        pfnCredFree ( Buffer );
    }
    else
    {

    }
}

VOID
CredPutStdout(
    IN LPWSTR String
    )
/*++

Routine Description:

    Output a string to stdout in the Console code page

    We can't use fputws since it uses the wrong code page.

Arguments:

    String - String to output

Return Values:

    None.

--*/
{
    int size;
    LPSTR Buffer = NULL;
    DWORD dwcc = 0;                                                     // char count
    DWORD dwWritten = 0;                                            // chars actually sent
    BOOL fIsConsole = TRUE;                                         // default - tested and set
    
    HANDLE hC = GetStdHandle(STD_OUTPUT_HANDLE);    // std output device handle
    if (INVALID_HANDLE_VALUE == hC) return;

    if (String == NULL) return;                                       // done if no string
    
    DWORD ft = GetFileType(hC);
    ft &= ~FILE_TYPE_REMOTE;
    fIsConsole = (ft == FILE_TYPE_CHAR);

    dwcc = wcslen(String);
    
    if (fIsConsole) 
    {
        WriteConsole(hC,String,dwcc,&dwWritten,NULL);
        return;
    }

    // Handle non-console output routing
    //
    // Compute the size of the converted string
    //

    size = WideCharToMultiByte( GetConsoleOutputCP(),
                                0,
                                String,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL );

    if ( size == 0 ) {
        return;
    }

    //
    // Allocate a buffer for it
    //

    __try {
        Buffer = static_cast<LPSTR>( alloca(size) );
    }
    __except ( ( GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ) ?
                     EXCEPTION_EXECUTE_HANDLER :
                     EXCEPTION_CONTINUE_SEARCH )
    {
        _resetstkoflw();
        Buffer = NULL;
    }

    if ( Buffer == NULL) {
        return;
    }

    //
    // Convert the string to the console code page
    //

    size = WideCharToMultiByte( GetConsoleOutputCP(),
                                0,
                                String,
                                -1,
                                Buffer,
                                size,
                                NULL,
                                NULL );

    if ( size == 0 ) {
        return;
    }

    //
    // Write the string to stdout
    //

    //fputs( Buffer, stdout );
    WriteFile(hC,Buffer,size,&dwWritten,NULL);
}

/***    GetPasswdStr -- read in password string
 *
 *      DWORD GetPasswdStr(char far *, USHORT);
 *
 *      ENTRY:  buf             buffer to put string in
 *              buflen          size of buffer
 *              &len            address of USHORT to place length in
 *
 *      RETURNS:
 *              0 or NERR_BufTooSmall if user typed too much.  Buffer
 *              contents are only valid on 0 return.
 *
 *      History:
 *              who     when    what
 *              erichn  5/10/89 initial code
 *              dannygl 5/28/89 modified DBCS usage
 *              erichn  7/04/89 handles backspaces
 *              danhi   4/16/91 32 bit version for NT
 *              cliffv  3/12/01 Stolen from netcmd
 */
#define CR              0xD
#define BACKSPACE       0x8

DWORD
GetPasswdStr(
    LPWSTR  buf,
    DWORD   buflen,
    PDWORD  len
    )
{
    WCHAR   ch;
    WCHAR   *bufPtr = buf;
    DWORD   c;
    DWORD   err;
    DWORD   mode;

    buflen -= 1;    /* make space for null terminator */
    *len = 0;       /* GP fault probe (a la API's)    */

    //
    // Init mode in case GetConsoleMode() fails
    //

    mode = ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT |
               ENABLE_MOUSE_INPUT;

    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode);

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
        (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {

        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);

        if (!err || c != 1) {
            ch = 0xffff;
        }

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
        {
            break;
        }

        if (ch == BACKSPACE)    /* back up one or two */
        {
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != buf)
            {
                bufPtr--;
                (*len)--;
            }
        }
        else
        {
            *bufPtr = ch;

            if (*len < buflen)
                bufPtr++ ;                   /* don't overflow buf */
            (*len)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    *bufPtr = '\0';         /* null terminate the string */
    putchar( '\n' );

    return ((*len <= buflen) ? 0 : NERR_BufTooSmall);
}

/***    GetString -- read in string with echo
 *
 *      DWORD GetString(char far *, USHORT, USHORT far *, char far *);
 *
 *      ENTRY:  buf             buffer to put string in
 *              buflen          size of buffer
 *              &len            address of USHORT to place length in
 *
 *      RETURNS:
 *              0 or NERR_BufTooSmall if user typed too much.  Buffer
 *              contents are only valid on 0 return.  Len is ALWAYS valid.
 *
 *      OTHER EFFECTS:
 *              len is set to hold number of bytes typed, regardless of
 *              buffer length.
 *
 *      Read in a string a character at a time.  Is aware of DBCS.
 *
 *      History:
 *              who     when    what
 *              erichn  5/11/89 initial code
 *              dannygl 5/28/89 modified DBCS usage
 *              danhi   3/20/91 ported to 32 bits
 *              cliffv  3/12/01 Stolen from netcmd
 */

DWORD
GetString(
    LPWSTR  buf,
    DWORD   buflen,
    PDWORD  len
    )
{
    DWORD c;
    DWORD err;

    buflen -= 1;    /* make space for null terminator */
    *len = 0;       /* GP fault probe (a la API's) */

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), buf, 1, &c, 0);
        if (!err || c != 1) {
            *buf = 0xffff;
        }

        if (*buf == (WCHAR)EOF) {
            break;
        }

        if (*buf ==  '\r' || *buf == '\n' ) {
            INPUT_RECORD    ir;
            DWORD cr;

            if (PeekConsoleInput(GetStdHandle(STD_INPUT_HANDLE), &ir, 1, &cr)) {
                ReadConsole(GetStdHandle(STD_INPUT_HANDLE), buf, 1, &c, 0);
            }
            break;
        }

        buf += (*len < buflen) ? 1 : 0; /* don't overflow buf */
        (*len)++;                       /* always increment len */
    }

    *buf = '\0';            /* null terminate the string */

    return ((*len <= buflen) ? 0 : NERR_BufTooSmall);
}

VOID
CredGetStdin(
    OUT LPWSTR Buffer,
    IN DWORD BufferMaxChars,
    IN BOOLEAN EchoChars
    )
/*++

Routine Description:

    Input a string from stdin in the Console code page.

    We can't use fgetws since it uses the wrong code page.

Arguments:

    Buffer - Buffer to put the read string into.
        The Buffer will be zero terminated and will have any traing CR/LF removed

    BufferMaxChars - Maximum number of characters to return in the buffer not including
        the trailing NULL.

    EchoChars - TRUE if the typed characters are to be echoed.
        FALSE if not.

Return Values:

    None.

--*/
{
    DWORD NetStatus;
    DWORD Length;

    if ( EchoChars ) {
        NetStatus = GetString( Buffer,
                               BufferMaxChars+1,
                               &Length );
    } else {
        NetStatus = GetPasswdStr( Buffer,
                                  BufferMaxChars+1,
                                  &Length );
    }

    if ( NetStatus == NERR_BufTooSmall ) {
        Buffer[0] = '\0';
    }
}

BOOLEAN
CredpValidateDnsString(
    IN OUT LPWSTR String OPTIONAL,
    IN DNS_NAME_FORMAT DnsNameFormat,
    OUT PULONG StringSize
    )

/*++

Routine Description:

    This routine validates a passed in string.  The string must be a valid DNS name.
    Any trailing . is truncated.

Arguments:

    String - String to validate
        Any trailing . is truncated.
        This field is only modified if the routine returns TRUE.

    DnsNameFormat - Expected format of the name.

    StringSize - Returns the length of the string (in bytes) including the
        trailing zero character.
        This field is only updated if the routine returns TRUE.

Return Values:

    TRUE - String is valid.

    FALSE - String is not valid.

--*/

{
    ULONG TempStringLen;

    if ( String == NULL ) {
        return FALSE;
    }

    TempStringLen = wcslen( String );

    if ( TempStringLen == 0 ) {
        return FALSE;
    } else {
        //
        // Remove the trailing .
        //
        if ( String[TempStringLen-1] == L'.' ) {

            TempStringLen -= 1;

            //
            // Ensure the string isn't empty now.
            //

            if ( TempStringLen == 0 ) {
                return FALSE;

            //
            // Ensure there aren't multiple trailing .'s
            //
            } else {
                if ( String[TempStringLen-1] == L'.' ) {
                    return FALSE;
                }
            }
        }

        //
        // Have DNS finish the validation
        //

        if ( TempStringLen != 0 ) {
            DWORD WinStatus;

            WinStatus = DnsValidateName_W( String, DnsNameFormat );

            if ( WinStatus != NO_ERROR &&
                 WinStatus != DNS_ERROR_NON_RFC_NAME ) {

                //
                // The RFC says hostnames cannot have numeric leftmost labels.
                //  However, Win 2K servers have such hostnames.
                //  So, allow them here forever more.
                //

                if ( DnsNameFormat == DnsNameHostnameFull &&
                     WinStatus == DNS_ERROR_NUMERIC_NAME ) {

                    /* Drop through */

                } else {
                    return FALSE;
                }
            }
        }
    }

    if ( TempStringLen > DNS_MAX_NAME_LENGTH ) {
        return FALSE;
    }

    String[TempStringLen] = L'\0';
    *StringSize = (TempStringLen + 1) * sizeof(WCHAR);
    return TRUE;
}

DWORD
CredUIParseUserNameWithType(
    CONST WCHAR *UserName,
    WCHAR *user,
    ULONG userBufferSize,
    WCHAR *domain,
    ULONG domainBufferSize,
    PCREDUI_USERNAME_TYPE UsernameType
    )
/*++

Routine Description:

    Same as CredUIParseUserNameW except it returns an enum defining which username
    syntax was found.

Arguments:

    UserName - The user name to be parsed.

    user - Specifies a buffer to copy the user name portion of the parsed string to.

    userBufferSize - Specifies the size of the 'user' array in characters.
        The caller can ensure the passed in array is large enough by using an array
        that is CRED_MAX_USERNAME_LENGTH+1 characters long or by passing in an array that
        is wcslen(UserName)+1 characters long.

    domain - Specifies a buffer to copy the domain name portion of the parsed string to.

    domainBufferSize - Specifies the size of the 'domain' array in characters.
        The caller can ensure the passed in array is large enough by using an array
        that is CRED_MAX_USERNAME_LENGTH+1 characters long or by passing in an array that
        is wcslen(UserName)+1 characters long.

Return Values:

    The following status codes may be returned:

        ERROR_INVALID_ACCOUNT_NAME - The user name is not valid.

        ERROR_INVALID_PARAMETER - One of the parameters is invalid.

        ERROR_INSUFFICIENT_BUFFER - One of the buffers is too small.


--*/
{
    DWORD Status;
    ULONG UserNameLength;
    LPWSTR LocalUserName = NULL;
    LPWSTR SlashPointer;

    LPWSTR AtPointer;
    ULONG LocalStringSize;
    LPCWSTR UserNameToCopy = NULL;
    LPCWSTR DomainNameToCopy = NULL;

    //
    // Validate the input parameters
    //

    if ( UserName == NULL ||
         user == NULL ||
         domain == NULL ||
         userBufferSize == 0 ||
         domainBufferSize == 0 ) {

        return ERROR_INVALID_PARAMETER;
    }

    user[0] = L'\0';
    domain[0] = L'\0';

    //
    // Compute the length of the UserName
    //

    UserNameLength = wcslen ( UserName );

    if ( UserNameLength > CRED_MAX_USERNAME_LENGTH ) {
        return ERROR_INVALID_ACCOUNT_NAME;
    }

    //
    // If this is a marshalled credential reference,
    //  just copy the entire string as the username.
    //  Set the domain name to an empty string.
    //

    if (LocalCredIsMarshaledCredentialW( UserName)) {

        UserNameToCopy = UserName;
        *UsernameType = CreduiMarshalledUsername;
        Status = NO_ERROR;
        goto Cleanup;
    }

    //
    // Grab a local writable copy of the string.
    //

    LocalUserName = (LPWSTR) LocalAlloc( 0, (UserNameLength+1)*sizeof(WCHAR) );

    if ( LocalUserName == NULL ) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( LocalUserName, UserName, (UserNameLength+1)*sizeof(WCHAR) );

    //
    // Classify the input account name.
    //
    // The name is considered to be <DomainName>\<UserName> if the string
    // contains an \.
    //

    SlashPointer = wcsrchr( LocalUserName, L'\\' );

    if ( SlashPointer != NULL ) {
        LPWSTR LocalUserNameEnd;
        LPWSTR AfterSlashPointer;

        //
        // Skip the backslash
        //

        *SlashPointer = L'\0';
        AfterSlashPointer = SlashPointer + 1;

        //
        // Ensure the string to the left of the \ is a valid domain name
        //
        // (Do DNS name first to allow the name to be canonicalized.)

        if ( !CredpValidateDnsString( LocalUserName, DnsNameDomain, &LocalStringSize ) &&
             !NetpIsDomainNameValid( LocalUserName ) ) {
            Status = ERROR_INVALID_ACCOUNT_NAME;
            goto Cleanup;
        }

        //
        // Ensure the string to the right of the \ is a valid user name
        //

        if ( !NetpIsUserNameValid( AfterSlashPointer )) {
            Status = ERROR_INVALID_ACCOUNT_NAME;
            goto Cleanup;
        }

        //
        // Copy the user name and domain name back to the caller.
        //

        UserNameToCopy = AfterSlashPointer;
        DomainNameToCopy = LocalUserName;

        *UsernameType = CreduiAbsoluteUsername;
        Status = NO_ERROR;
        goto Cleanup;
    }

    //
    // A UPN has the syntax <AccountName>@<DnsDomainName>.
    // If there are multiple @ signs,
    //  use the last one since an AccountName can have an @ in it.
    //
    //

    AtPointer = wcsrchr( LocalUserName, L'@' );
    if ( AtPointer != NULL ) {

        //
        // The string to the left of the @ can really have any syntax.
        //  But must be non-null.
        //

        if ( AtPointer == LocalUserName ) {
            Status = ERROR_INVALID_ACCOUNT_NAME;
            goto Cleanup;
        }

        //
        // Ensure the string to the right of the @ is a DNS domain name
        //

        AtPointer ++;
        if ( !CredpValidateDnsString( AtPointer, DnsNameDomain, &LocalStringSize ) ) {
            Status = ERROR_INVALID_ACCOUNT_NAME;
            goto Cleanup;
        }

        //
        // Return the entire UPN in the username field
        //

        UserNameToCopy = UserName;
        *UsernameType = CreduiUpn;
        Status = NO_ERROR;
        goto Cleanup;
    }

    //
    // Finally, check to see it it is an unqualified user name
    //

    if ( NetpIsUserNameValid( LocalUserName )) {

        UserNameToCopy = UserName;
        *UsernameType = CreduiRelativeUsername;
        Status = NO_ERROR;
        goto Cleanup;
    }

    //
    // All other values are invalid
    //

    Status = ERROR_INVALID_ACCOUNT_NAME;

    //
    // Cleanup
    //
Cleanup:

    //
    // On Success,
    //  copy the names back to the caller.
    //

    if ( Status == NO_ERROR ) {
        ULONG Length;

        //
        // Copy the user name back to the caller.
        //

        if (FAILED(StringCchCopyExW(
                user,
                userBufferSize,
                UserNameToCopy,
                NULL,
                NULL,
                STRSAFE_NULL_ON_FAILURE)))
        {
            Status = ERROR_INSUFFICIENT_BUFFER;
        }

        //
        // Copy the domain name back to the caller
        //

        if ( Status == NO_ERROR && DomainNameToCopy != NULL ) {

            //
            // Copy the user name back to the caller.
            //

            if (FAILED(StringCchCopyExW(
                    domain,
                    domainBufferSize,
                    DomainNameToCopy,
                    NULL,
                    NULL,
                    STRSAFE_NULL_ON_FAILURE)))
            {
                Status = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    }

    LocalFree( LocalUserName );

    return Status;
}

LPWSTR
GetAccountDomainName(
    VOID
    )
/*++

Routine Description:

    Returns the name of the account domain for this machine.

    For workstatations, the account domain is the netbios computer name.
    For DCs, the account domain is the netbios domain name.

Arguments:

    None.

Return Values:

    Returns a pointer to the name.  The name should be free using NetApiBufferFree.

    NULL - on error.

--*/
{
    DWORD WinStatus;

    LPWSTR AllocatedName = NULL;

    //
    // If this machine is a domain controller,
    //  get the domain name.
    //

    if ( CreduiIsDomainController ) {

        WinStatus = NetpGetDomainName( &AllocatedName );

        if ( WinStatus != NO_ERROR ) {
            return NULL;
        }

    //
    // Otherwise, the 'account domain' is the computername
    //

    } else {

        WinStatus = NetpGetComputerName( &AllocatedName );

        if ( WinStatus != NO_ERROR ) {
            return NULL;
        }
    }

    return AllocatedName;
}

BOOL
CompleteUserName(
    IN OUT LPWSTR UserName,
    IN ULONG UserNameMaxChars,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo OPTIONAL,
    IN LPWSTR TargetName OPTIONAL,
    IN DWORD Flags
    )
/*++

Routine Description:

    Searches the user name for a domain name, and determines whether this
    specifies the target server or a domain. If a domain is not present in the
    user name, add it if this is a workstation or no target information is
    available.

Arguments:

    UserName - The username to modify.  The buffer is modified in place.

    UserNameMaxChars - Size (in chars) of the UserName buffer not including space for the
        trailing NULL.
        The input string may be shorter than this.

    TargetInfo - The TargetInfo describing the target these credentials are for.
        If not specified, the Target info will not be used to contruct the domain name.

    TargetName - The user supplied target name describing the target these credentials are for.

    Flags - As passed to CredUIPromptForCredentials()
    
Return Values:

    Returns TRUE if a domain was already present in the user name, or if we
    added one. Otherwise, return FALSE.

--*/
{
    BOOLEAN RetVal;

    DWORD WinStatus;
    WCHAR RetUserName[CRED_MAX_USERNAME_LENGTH + 1];
    WCHAR RetDomainName[CRED_MAX_USERNAME_LENGTH + 1];
    WCHAR LogonDomainName[CRED_MAX_USERNAME_LENGTH + 1];
    CREDUI_USERNAME_TYPE UsernameType;

    LPWSTR AllocatedName = NULL;

    WCHAR *serverName = NULL;

    if ((Flags & CREDUI_FLAGS_GENERIC_CREDENTIALS) &&
        !(Flags & CREDUI_FLAGS_COMPLETE_USERNAME)) return FALSE;
    
    //
    // Determine the type and validity of the user name
    //

    WinStatus = CredUIParseUserNameWithType(
                    UserName,
                    RetUserName,
                    CRED_MAX_USERNAME_LENGTH + 1,
                    RetDomainName,
                    CRED_MAX_USERNAME_LENGTH + 1,
                    &UsernameType );

    if ( WinStatus != NO_ERROR ) {
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Most Types don't need to be completed
    //

    if ( UsernameType != CreduiRelativeUsername ) {
        RetVal = TRUE;
        goto Cleanup;
    }

    //
    // If we have target info,
    //  Use the information from the TargetInfo to qualify the username.
    //

    if (TargetInfo != NULL) {

        //
        // See if the target system claims to be a standalone system.
        //  In which case we just fill in the server name for the domain since
        //  all accounts valid for the system

        if ( TargetInfo->DnsTreeName != NULL ||
             TargetInfo->DnsDomainName != NULL ||
             TargetInfo->NetbiosDomainName != NULL ||
             (TargetInfo->Flags & CRED_TI_SERVER_FORMAT_UNKNOWN) != 0
          ) {

            // The target info contains domain information, so this is probably
            // not a standalone server; the user should enter the domain name:
            // gm: But we will prepend the user's logon domain name...
            ULONG ulSize = CRED_MAX_USERNAME_LENGTH;
            if (GetUserNameEx(NameSamCompatible,LogonDomainName,&ulSize))
            {
                WCHAR *pwc=wcschr(LogonDomainName, L'\\');
                if (NULL != pwc) 
                {
                    *pwc = '\0';    // term username at logon domain name only
                    serverName = LogonDomainName;
                }
            } 
            else 
            {
                RetVal = FALSE;
                goto Cleanup;
            }
        }
        else
        {
            if (TargetInfo->NetbiosServerName) {
                serverName = TargetInfo->NetbiosServerName;
            } else {
                serverName = TargetName;
            }
        }
    } 
    else if ( (TargetName != NULL)                     &&
            !CreduiIsWildcardTargetName(TargetName)             &&
            !(Flags & CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS)   )
    {

        // No target information, but this is not a wildcard target name, so
        // use this as the domain for the user name:

        serverName = TargetName;

        //
        // There is no target.
        //  therefore, the target must be the local machine.
        //  Use the 'account domain' of the local machine.

    } else {

        AllocatedName = GetAccountDomainName();

        serverName = AllocatedName;
    }

    //
    // If no name was found,
    //  we're done.
    //

    if (serverName == NULL) {
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Append the found name
    //

    WCHAR *where;

    ULONG userNameLength = wcslen(UserName);
    ULONG serverLength = wcslen(serverName);

    if ((userNameLength == 0 ) ||
        (userNameLength + serverLength + 1) > UserNameMaxChars)
    {
        RetVal = FALSE;
        goto Cleanup;
    }

    WCHAR *source = UserName + userNameLength + 1;

    where = source + serverLength;

    while (source > UserName)
    {
        *where-- = *--source;
    }

    StringCchCopyW(UserName, UserNameMaxChars, serverName);
    *where = L'\\';

    RetVal = TRUE;

Cleanup:
    if ( AllocatedName != NULL ) {
        NetApiBufferFree ( AllocatedName );
    }

    return RetVal;
}

// returns TRUE if the wizard was sucessfull, FALSE if not and a dialog should be popped
BOOL TryLauchRegWizard ( 
    SSOPACKAGE* pSSOPackage,  
    HWND hwndParent,
    BOOL HasLogonSession,
    WCHAR *userName,
    ULONG userNameMaxChars,
    WCHAR *password,
    ULONG passwordMaxChars,
    DWORD* pResult
    )
{
    BOOL bDoPasswordDialog = TRUE;

    if ( pSSOPackage == NULL )
    {
        return TRUE;
    }

    if ( pResult == NULL )
    {
        return TRUE;
    }

    *pResult = ERROR_CANCELLED;

    IModalWindow* pPPWizModalWindow;

    // launch wizard, if one is registered
    if ( pSSOPackage->pRegistrationWizard != NULL )
    {
        gbStoredSSOCreds = FALSE;

        HRESULT hr = CoCreateInstance ( *(pSSOPackage->pRegistrationWizard), NULL, CLSCTX_INPROC_SERVER,
                                        IID_IModalWindow, (LPVOID*)&pPPWizModalWindow );

        if ( FAILED(hr) || pPPWizModalWindow == NULL )
        {
            bDoPasswordDialog = TRUE;
        }
        else
        {
            // check to see if we have a logon session to do passport creds
            if ( !HasLogonSession )
            {
                if ( gbWaitingForSSOCreds )
                {
                    // can't re-enter this section of code, just do the dialog
                    bDoPasswordDialog = TRUE;
                }
                else
                {
                    gbWaitingForSSOCreds = TRUE;
                    bDoPasswordDialog = FALSE;
                    SecureZeroMemory(gszSSOUserName, sizeof gszSSOUserName);
                    SecureZeroMemory(gszSSOPassword, sizeof gszSSOPassword);
                }
            }
            else
            {
                bDoPasswordDialog = FALSE;
            }

            if ( bDoPasswordDialog == FALSE )
            {
                // try the wizard

                pPPWizModalWindow->Show(hwndParent);

                // check to see if it's been set
                if ( HasLogonSession ) 
                {
                    // look in credmgr
                    if ( gbStoredSSOCreds  ) //CheckForSSOCred( NULL ) )
                    {
                        *pResult = ERROR_SUCCESS;
                    }
                    else
                    {
                        *pResult = ERROR_CANCELLED;
                    }

                    // copy them to user-supplied input
                    if ( userName != NULL && password != NULL )
                    {
                        StringCchCopyW(userName, userNameMaxChars, gszSSOUserName);
                        StringCchCopyW(password, passwordMaxChars, gszSSOPassword);
                    }
                }
                else
                {
                    // look to see if it was squirreled away
                    if ( wcslen (gszSSOUserName) > 0 ) 
                    {
                        *pResult = ERROR_SUCCESS;

                        // copy them to user-supplied input
                        if ( userName != NULL && password != NULL )
                        {
                            StringCchCopyW(userName, userNameMaxChars, gszSSOUserName);
                            StringCchCopyW(password, passwordMaxChars, gszSSOPassword);
                        }
                        else
                        {
                            // can't do anything, return appropriate error to indicate no credmgr
                            *pResult = ERROR_NO_SUCH_LOGON_SESSION;
                        }
                    }
                    else
                    {
                        *pResult = ERROR_CANCELLED;
                    }

                    gbWaitingForSSOCreds = FALSE;
    
                }

                // zero out global strings
                SecureZeroMemory(gszSSOUserName, sizeof gszSSOUserName);
                SecureZeroMemory(gszSSOPassword, sizeof gszSSOPassword);
            }
        }
    }

    return !bDoPasswordDialog;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\autoenrl\csenroll\convert.c ===
#include <windows.h>
#include <wincrypt.h>
#include <autoenr.h>
#include <cryptui.h>
#include <stdio.h>
#include <certca.h>
#include <stdlib.h>

#define wszInvalidFileAndKeyChars  L"<>\"/\\:|?*"
#define wszUnsafeURLChars          L"#\"&<>[]^`{}|"
#define wszUnsafeDSChars           L"()='\"`,;+"
#define  wszSANITIZEESCAPECHAR  L"!"
#define  wszURLESCAPECHAR       L"%"
#define  wcSANITIZEESCAPECHAR   L'!'

BOOL
myIsCharSanitized(
    IN WCHAR wc)
{
    BOOL fCharOk = TRUE;
    if (L' ' > wc ||
        L'~' < wc ||
        NULL != wcschr(
		    wszInvalidFileAndKeyChars
			wszUnsafeURLChars
			wszSANITIZEESCAPECHAR
			wszURLESCAPECHAR
			wszUnsafeDSChars,
		    wc))
    {
	fCharOk = FALSE;
    }
    return(fCharOk);
}

PWCHAR 
mySanitizeName(
    IN WCHAR const *pwszName
	)
{
    HRESULT hr = S_OK;
    WCHAR const *pwszPassedName;
    WCHAR *pwszDst;
    WCHAR *pwszOut = NULL;
    WCHAR wcChar;
    DWORD dwSize;

    pwszPassedName = pwszName;

    dwSize = 0;

    if (NULL == pwszName)
    {
	return NULL;
    }

    while (L'\0' != (wcChar = *pwszPassedName++))
    {
	if (myIsCharSanitized(wcChar))
	{
	    dwSize++;
	}
        else
        {
            dwSize += 5; // format !XXXX
        }
    }
    if (0 == dwSize)
    {
        return NULL;
    }

    pwszOut = (WCHAR *) LocalAlloc(LMEM_ZEROINIT, (dwSize + 1) * sizeof(WCHAR));
    if (NULL == pwszOut)
    {
		return NULL;
    }

    pwszDst = pwszOut;
    while (L'\0' != (wcChar = *pwszName++))
    {
	if (myIsCharSanitized(wcChar))
	{
            *pwszDst = wcChar;
	    pwszDst++;
	}
        else
        {
            wsprintf(pwszDst, L"%ws", wszSANITIZEESCAPECHAR);
            pwszDst++;
            wsprintf(pwszDst, L"%04x", wcChar);
	    pwszDst += 4;
        }
    }
    *pwszDst = wcChar; // L'\0' terminator

	return pwszOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\creduit\creduit.cxx ===
/*--

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    creduit.cxx

Abstract:

    Test program for the credential manager UI API.


Author:

    16-Jan-2001 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:


--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <wincred.h>
#include <credp.h>
#include <stdio.h>
#include <stdlib.h>
#include <lmerr.h>
#include <align.h>

#define _CREDUI_
#include <wincrui.h>

#include <lmcons.h>
extern "C" {
#include <names.h>
#include <rpcutil.h>
}
#include <winerror.dbg>

//
// Structure defining a array of parsed strings
//

typedef struct _STRING_ARRAY {
    BOOLEAN Specified;
    DWORD Count;
#define STRING_ARRAY_COUNT 100
    LPWSTR Strings[STRING_ARRAY_COUNT];
} STRING_ARRAY, *PSTRING_ARRAY;

//
// Parsed Parameters
//

LPWSTR CommandLine;
DWORD GlCommand = 0xFFFFFFFF;

BOOLEAN GlAnsi;
BOOLEAN GlDoGui;

LPWSTR GlUserName;
LPWSTR GlTargetName;
LPWSTR GlMessage;
LPWSTR GlTitle;
LPWSTR GlAuthError;
DWORD GlCreduiFlags;
BOOLEAN GlNoConfirm;
BOOL GlSave;

//
// Table of valid parameters to the command.
//

struct _PARAMAMTER_DEF {
    LPWSTR Name;   // Name of the parameter

    LPSTR ValueName; // Test describing parameter value

    DWORD Type;     // Parameter type
#define PARM_COMMAND        1 // Parameter defines a command
#define PARM_COMMAND_STR    2 // Parameter defines a command (and has text string)
#define PARM_COMMAND_OPTSTR 3 // Parameter defines a command (and optionaly has text string)
#define PARM_STRING         4 // Parameter defines a text string
#define PARM_STRING_ENUM    5 // Parameter is an enumeration of text strings
#define PARM_STRING_ARRAY   6 // Parameter is an array of text strings
#define PARM_BOOLEAN        7 // Parameter set a boolean
#define PARM_BIT            8 // Parameter sets a bit in a DWORD

    PVOID Global;   // Address of global to write

    LPWSTR *EnumStrings;

    //
    // Describe relationships to other parameters.
    //
    DWORD Relationships;
#define ALLOW_CRED 0x01 // If specified, this parameter allows other IS_CRED parameters
#define IS_CRED    0x02 // This parameter is only allow if an ALLOW_CRED parameter has been seen previously
#define ALLOW_TI   0x10 // If specified, this parameter allows other IS_TI or IS_TIX parameters
#define IS_TI      0x20 // This parameter is only allow if an ALLOW_TI parameter has been seen previously
#define IS_TIX     0x40 // This parameter is only allow if an ALLOW_TI parameter has been seen previously
    LPSTR Comment;
} ParameterDefinitions[] =
{
    {L"UserName",   "UserName",          PARM_STRING,       &GlUserName,        NULL,            0,         "User Name" },
    {L"TargetName", "TargetName",        PARM_STRING,       &GlTargetName,      NULL,            0,         "Target Name" },
    {L"Message",    "Message",           PARM_STRING,       &GlMessage,         NULL,            0,         "Message for dialog box" },
    {L"Title",      "Title",             PARM_STRING,       &GlTitle,           NULL,            0,         "Title for dialog box" },
    {L"Gui",        NULL,                PARM_BOOLEAN,      &GlDoGui,           NULL,            0,         "Call GUI version of API" },
    {L"Ansi",       NULL,                PARM_BOOLEAN,      &GlAnsi,            NULL,            0,         "Use ANSI version of APIs" },
    { NULL },
    {L"ReqSmartcard",   (LPSTR)ULongToPtr(CREDUI_FLAGS_REQUIRE_SMARTCARD),    PARM_BIT, &GlCreduiFlags, NULL,            0,         "Require smartcard" },
    {L"ReqCertificate", (LPSTR)ULongToPtr(CREDUI_FLAGS_REQUIRE_CERTIFICATE),  PARM_BIT, &GlCreduiFlags, NULL,            0,         "Require certificate" },
    {L"ExcCertificates",(LPSTR)ULongToPtr(CREDUI_FLAGS_EXCLUDE_CERTIFICATES), PARM_BIT, &GlCreduiFlags, NULL,            0,         "Exclude certificates" },
    { NULL },
    {L"GenericCreds",   (LPSTR)ULongToPtr(CREDUI_FLAGS_GENERIC_CREDENTIALS),  PARM_BIT, &GlCreduiFlags, NULL,            0,         "Generic Credentials" },
    {L"RunasCreds",     (LPSTR)ULongToPtr(CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS),PARM_BIT,&GlCreduiFlags, NULL,       0,         "Runas Credentials" },
    { NULL },
    {L"Persist",        (LPSTR)ULongToPtr(CREDUI_FLAGS_PERSIST),              PARM_BIT, &GlCreduiFlags, NULL,            0,         "Always save Credentials" },
    {L"NoPersist",      (LPSTR)ULongToPtr(CREDUI_FLAGS_DO_NOT_PERSIST),       PARM_BIT, &GlCreduiFlags, NULL,            0,         "Never save Credentials" },
    {L"ShowSaveCheckbox:(T/F)",(LPSTR)ULongToPtr(CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX), PARM_BIT, &GlCreduiFlags, ((LPWSTR *)&GlSave),   0,         "Show Save checkbox (initial value)" },
    { NULL },
    {L"ValidateUsername",(LPSTR)ULongToPtr(CREDUI_FLAGS_VALIDATE_USERNAME),   PARM_BIT, &GlCreduiFlags, NULL,            0,         "Validate Username" },
    {L"CompleteUsername",(LPSTR)ULongToPtr(CREDUI_FLAGS_COMPLETE_USERNAME),   PARM_BIT, &GlCreduiFlags, NULL,            0,         "Complete Username" },
    { NULL },
    {L"Confirm",         (LPSTR)ULongToPtr(CREDUI_FLAGS_EXPECT_CONFIRMATION), PARM_BIT, &GlCreduiFlags, NULL,            0,         "Confirm that the credential worked" },
    {L"NoConfirm",       NULL,                                                PARM_BOOLEAN,&GlNoConfirm,NULL,            0,         "Confirm that the credential failed" },
    { NULL },
    {L"AlwaysShowUi",(LPSTR)ULongToPtr(CREDUI_FLAGS_ALWAYS_SHOW_UI),          PARM_BIT, &GlCreduiFlags, NULL,            0,         "Always Show UI" },
    {L"IncorrectPassword",(LPSTR)ULongToPtr(CREDUI_FLAGS_INCORRECT_PASSWORD), PARM_BIT, &GlCreduiFlags, NULL,            0,         "Show 'incorrect password' tip" },
    {L"AuthError",       "ErrorNum",     PARM_STRING,       &GlAuthError,       NULL,            0,         "Previous auth error number" },


};
#define PARAMETER_COUNT (sizeof(ParameterDefinitions)/sizeof(ParameterDefinitions[0]))

VOID
PrintOneUsage(
    LPWSTR Argument OPTIONAL,
    ULONG ArgumentIndex
    )
/*++

Routine Description:

    Print the command line parameter usage for one parameter

Arguments:

    Argument - Argument as typed by caller
        NULL if printing complete list of arguments

    ArugmentIndex - Index of the parameter to print

Return Value:

    None

--*/
{
    ULONG j;

    if ( ParameterDefinitions[ArgumentIndex].Name == NULL ) {
        fprintf( stderr, "\n" );
        return;
    }

    if ( Argument != NULL ) {
        fprintf( stderr,  "\nSyntax of '%ls' parameter is:\n", Argument );
    }

    fprintf( stderr,  "    /%ls", ParameterDefinitions[ArgumentIndex].Name );

    switch ( ParameterDefinitions[ArgumentIndex].Type ) {
    case PARM_COMMAND:
    case PARM_BOOLEAN:
        break;
    case PARM_BIT:
        if ( ParameterDefinitions[ArgumentIndex].EnumStrings == NULL ) {
            break;
        } else {
            fprintf( stderr, ":{T/F}" );
            break;
        }
    case PARM_COMMAND_OPTSTR:
        fprintf( stderr, "[:<%s>]", ParameterDefinitions[ArgumentIndex].ValueName );
        break;
    case PARM_STRING:
    case PARM_COMMAND_STR:
        fprintf( stderr, ":<%s>", ParameterDefinitions[ArgumentIndex].ValueName );
        break;
    case PARM_STRING_ENUM:
        fprintf( stderr, ":<" );
        for ( j=0; ParameterDefinitions[ArgumentIndex].EnumStrings[j] != NULL; j++) {
            if ( j!= 0 ) {
                fprintf( stderr, "|");
            }
            fprintf( stderr, "%ls", ParameterDefinitions[ArgumentIndex].EnumStrings[j] );
        }
        fprintf( stderr, ">" );

        break;
    case PARM_STRING_ARRAY:
        fprintf( stderr, ":<%s>", ParameterDefinitions[ArgumentIndex].ValueName );
        break;
    }

    if ( Argument == NULL ) {
        fprintf( stderr, " - %s", ParameterDefinitions[ArgumentIndex].Comment );
    }

    fprintf( stderr, "\n" );

}

VOID
PrintUsage(
    )
/*++

Routine Description:

    Print the command line parameter usage.

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG i;

    fprintf( stderr, "\nUsage: creduit [Options]\n\nWhere options are:\n\n");

    for ( i=0; i<PARAMETER_COUNT; i++ ) {
        PrintOneUsage( NULL, i );
    }

}

LPSTR
FindSymbolicNameForStatus(
    DWORD Id
    )
{
    ULONG i;

    i = 0;
    if (Id == 0) {
        return "NO_ERROR";
    }

#ifdef notdef
    if (Id & 0xC0000000) {
        while (ntstatusSymbolicNames[ i ].SymbolicName) {
            if (ntstatusSymbolicNames[ i ].MessageId == (NTSTATUS)Id) {
                return ntstatusSymbolicNames[ i ].SymbolicName;
            } else {
                i += 1;
            }
        }
    }
#endif // notdef

    while (winerrorSymbolicNames[ i ].SymbolicName) {
        if (winerrorSymbolicNames[ i ].MessageId == Id) {
            return winerrorSymbolicNames[ i ].SymbolicName;
        } else {
            i += 1;
        }
    }

#ifdef notdef
    while (neteventSymbolicNames[ i ].SymbolicName) {
        if (neteventSymbolicNames[ i ].MessageId == Id) {
            return neteventSymbolicNames[ i ].SymbolicName
        } else {
            i += 1;
        }
    }
#endif // notdef

    return NULL;
}


VOID
PrintStatus(
    DWORD NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{
    printf( "Status = %lu 0x%lx", NetStatus, NetStatus );

    switch (NetStatus) {
    case NERR_Success:
        printf( " NERR_Success" );
        break;

    case NERR_DCNotFound:
        printf( " NERR_DCNotFound" );
        break;

    case NERR_UserNotFound:
        printf( " NERR_UserNotFound" );
        break;

    case NERR_NetNotStarted:
        printf( " NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( " NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( " NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( " NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( " NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( " NERR_BadTransactConfig" );
        break;

    default:
        printf( " %s", FindSymbolicNameForStatus( NetStatus ) );
        break;

    }

    printf( "\n" );
}

VOID
PrintBytes(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content as hex and characters.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = (LPBYTE)Buffer;
    BOOLEAN DumpDwords = FALSE;

    //
    // Preprocess
    //

    if ( BufferSize > NUM_CHARS ) {
        printf("\n");  // Ensure this starts on a new line
        printf("------------------------------------\n");
    } else {
        if ( BufferSize % sizeof(DWORD) == 0 ) {
            DumpDwords = TRUE;
        }
    }

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            if ( DumpDwords ) {
                if ( i % sizeof(DWORD) == 0 ) {
                    DWORD ADword;
                    RtlCopyMemory( &ADword, &BufferPtr[i], sizeof(DWORD) );
                    printf("%08x ", ADword);
                }
            } else {
                printf("%02x ", BufferPtr[i]);
            }

            if ( isprint(BufferPtr[i]) ) {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            } else {
                TextBuffer[i % NUM_CHARS] = '.';
            }

        } else {

            if ( DumpDwords ) {
                TextBuffer[i % NUM_CHARS] = '\0';
            } else {
                if ( BufferSize > NUM_CHARS ) {
                    printf("   ");
                    TextBuffer[i % NUM_CHARS] = ' ';
                } else {
                    TextBuffer[i % NUM_CHARS] = '\0';
                }
            }

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    if ( BufferSize > NUM_CHARS ) {
        printf("------------------------------------\n");
    } else if ( BufferSize < NUM_CHARS ) {
        printf("\n");
    }
}

VOID
PrintTime(
    LPSTR Comment,
    LPFILETIME ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - GMT time to print (Nothing is printed if this is zero)

Return Value:

    None

--*/
{
    //
    // If we've been asked to convert an NT GMT time to ascii,
    //  Do so
    //

    if ( ConvertTime->dwLowDateTime != 0 || ConvertTime->dwHighDateTime != 0 ) {
        SYSTEMTIME SystemTime;
        FILETIME LocalFileTime;

        printf( "%s", Comment );

        if ( !FileTimeToLocalFileTime( ConvertTime, &LocalFileTime ) ) {
            printf( "Can't convert time from GMT to Local time: " );
            PrintStatus( GetLastError() );
            return;
        }

        if ( !FileTimeToSystemTime( &LocalFileTime, &SystemTime ) ) {
            printf( "Can't convert time from file time to system time: " );
            PrintStatus( GetLastError() );
            return;
        }

        printf( "%ld/%ld/%ld %ld:%2.2ld:%2.2ld\n",
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wYear,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond );
    }
}


BOOLEAN
ParseParameters(
    VOID
    )
/*++

Routine Description:

    Parse the command line parameters

Arguments:

    None

Return Value:

    TRUE if parse was successful.

--*/
{
    LPWSTR *argvw;
    int argcw;
    int i;
    ULONG j;

    LPWSTR OrigArgument;
    LPWSTR Argument;


    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW( CommandLine, &argcw );

    if ( argvw == NULL ) {
        fprintf( stderr, "Can't convert command line to Unicode: %ld\n", GetLastError() );

        return FALSE;
    }

    //
    // Loop through the command line arguments
    //

    for ( i=1; i<argcw; i++ ) {

        OrigArgument = Argument = argvw[i];

        //
        // Check if the Argument is a switch
        //

        if ( Argument[0] == '-' || Argument[0] == '/' ) {
            DWORD ArgumentIndex;
            ULONG ArgumentLength;
            PWCHAR ColonPointer;
            Argument ++;

            //
            // Find the colon at the end of the argument
            //

            ColonPointer = wcschr( Argument, L':' );
            if ( ColonPointer != NULL ) {
                *ColonPointer = '\0';
            }
            ArgumentLength = wcslen(Argument);

            //
            // Loop through the list of valid arguments finding all that match
            //

            ArgumentIndex = 0xFFFFFFFF;
            for ( j=0; j<PARAMETER_COUNT; j++ ) {

                //
                // Ignore placeholders
                //

                if ( ParameterDefinitions[j].Name == NULL ) {
                    continue;
                }

                //
                // Compare the names
                //

                if ( _wcsnicmp( Argument, ParameterDefinitions[j].Name, ArgumentLength ) == 0 ) {
                    //
                    // If more than one matches,
                    //  it's an error
                    //

                    if ( ArgumentIndex != 0xFFFFFFFF ) {
                        fprintf( stderr,
                                 "\nArgument '%ls' is ambiguous: %ls or %ls.\n",
                                 OrigArgument,
                                 ParameterDefinitions[j].Name,
                                 ParameterDefinitions[ArgumentIndex].Name );

                        return FALSE;
                    }

                    ArgumentIndex = j;

                    //
                    // If this is an exact match,
                    //  we're done.
                    //

                    if ( ArgumentLength == wcslen(ParameterDefinitions[j].Name)) {
                        break;
                    }
                }
            }

            //
            // If there were not matches,
            //  complain.
            //

            if ( ArgumentIndex == 0xFFFFFFFF ) {
                fprintf( stderr,
                         "\nArgument '%ls' is invalid.\n",
                         OrigArgument );
                PrintUsage();
                return FALSE;
            }

            //
            // Ensure the : is present as required
            //


            //
            // Return TRUE if the specified argument should have a : character after the
            //  argument name.
            //

            if ( ParameterDefinitions[ArgumentIndex].Type == PARM_COMMAND ||
                 ParameterDefinitions[ArgumentIndex].Type == PARM_BOOLEAN ||
                 (ParameterDefinitions[ArgumentIndex].Type == PARM_BIT &&
                  ParameterDefinitions[ArgumentIndex].EnumStrings == NULL ) ) {

                if ( ColonPointer != NULL ) {
                    PrintOneUsage( OrigArgument, ArgumentIndex );
                    return FALSE;
                }

            } else {

                if ( ColonPointer == NULL ) {
                    if ( ParameterDefinitions[ArgumentIndex].Type != PARM_COMMAND_OPTSTR ) {
                        PrintOneUsage( OrigArgument, ArgumentIndex );
                        return FALSE;
                    }
                } else {
                    Argument = ColonPointer + 1;
                }

            }

            //
            // Parse the rest of the argument
            //
            // Handle commands
            //

            switch ( ParameterDefinitions[ArgumentIndex].Type ) {
            case PARM_COMMAND:
            case PARM_COMMAND_STR:
            case PARM_COMMAND_OPTSTR:
                if ( GlCommand != 0xFFFFFFFF ) {
                    fprintf( stderr,
                             "\nArgument '%ls' and '/%ls' are mutually exclusive.\n",
                             OrigArgument,
                             ParameterDefinitions[GlCommand].Name );

                    return FALSE;
                }
                GlCommand = ArgumentIndex;


                /* Drop through */

            //
            // Handle parameters of the form /xxx:string
            //

            case PARM_STRING: {
                LPWSTR *StringPointer;
                StringPointer = (LPWSTR *)(ParameterDefinitions[ArgumentIndex].Global);

                //
                // If a string is not present,
                //  we're done.
                //

                if ( ColonPointer == NULL ) {
                    break;
                }

                //
                // Ensure argument only specified once.
                //

                if ( *StringPointer != NULL ) {
                    fprintf( stderr,
                             "\nArgument '%ls' may only be specified once.\n",
                             OrigArgument );

                    return FALSE;

                }

                //
                // Ensure an actual string was specified.
                //

                if ( *Argument == '\0' ) {
                    fprintf( stderr,
                             "\nArgument '%ls' requires a value.\n",
                             OrigArgument );

                    return FALSE;
                }


                *StringPointer = Argument;
                break;
            }

            //
            // Handle parameters of the form /xxx:a|b|c
            //

            case PARM_STRING_ENUM: {
                ULONG EnumIndex;
                LPDWORD DwordPointer;
                LPWSTR *EnumStrings;

                //
                // Ensure argument only specified once.
                //

                DwordPointer = (LPDWORD)(ParameterDefinitions[ArgumentIndex].Global);

                if ( *DwordPointer != 0 ) {
                    fprintf( stderr,
                             "\nArgument '%ls' may only be specified once.\n",
                             OrigArgument );

                    return FALSE;

                }

                EnumStrings = ParameterDefinitions[ArgumentIndex].EnumStrings;
                ArgumentLength = wcslen(Argument);

                //
                // Loop through the list of valid values finding all that match
                //

                EnumIndex = 0xFFFFFFFF;
                for ( j=0; EnumStrings[j] != NULL; j++ ) {

                    //
                    // Compare the names
                    //

                    if ( _wcsnicmp( Argument, EnumStrings[j], ArgumentLength ) == 0 ) {

                        //
                        // If more than one matches,
                        //  it's an error
                        //

                        if ( EnumIndex != 0xFFFFFFFF ) {

                            PrintOneUsage( OrigArgument, ArgumentIndex );

                            fprintf( stderr,
                                     "\nValue '%ls' is ambiguous: %ls or %ls.\n",
                                     Argument,
                                     EnumStrings[j],
                                     EnumStrings[EnumIndex] );

                            return FALSE;
                        }

                        EnumIndex = j;

                        //
                        // If this is an exact match,
                        //  we're done.
                        //

                        if ( ArgumentLength == wcslen(EnumStrings[j]) ) {
                            break;
                        }
                    }
                }

                //
                // If there were not matches,
                //  complain.
                //

                if ( EnumIndex == 0xFFFFFFFF ) {

                    PrintOneUsage( OrigArgument, ArgumentIndex );

                    fprintf( stderr,
                             "\nValue '%ls' is invalid.\n",
                             Argument );

                    return FALSE;
                }
                *DwordPointer = EnumIndex + 1;
                break;
            }

            //
            // Handle parameters of the form /xxx:a,b,c
            //

            case PARM_STRING_ARRAY: {
                PWCHAR CommaPointer;
                PSTRING_ARRAY StringArray;

                StringArray = ((PSTRING_ARRAY)(ParameterDefinitions[ArgumentIndex].Global));

                //
                // Ensure argument only specified once.
                //

                if ( StringArray->Specified ) {
                    fprintf( stderr,
                             "\nArgument '%ls' may only be specified once.\n",
                             OrigArgument );

                    return FALSE;

                }
                StringArray->Specified = TRUE;

                //
                // Loop through the values specified by the user
                //

                for (;;) {

                    //
                    // Ensure an actual string was specified.
                    //

                    if ( *Argument == '\0' ) {
                        fprintf( stderr,
                                 "\nArgument '%ls' requires a value.\n",
                                 OrigArgument );

                        return FALSE;
                    }

                    //
                    // Save it
                    //

                    StringArray->Count ++;

                    if ( StringArray->Count >= STRING_ARRAY_COUNT ) {
                        fprintf( stderr,
                                 "\nArgument '%ls' has too many values.\n",
                                 OrigArgument );

                        return FALSE;
                    }

                    StringArray->Strings[StringArray->Count-1] = Argument;

                    //
                    // Determine if there is another value
                    //
                    CommaPointer = wcschr( Argument, L',' );
                    if ( CommaPointer == NULL ) {
                        break;
                    }

                    *CommaPointer = '\0';
                    Argument = CommaPointer + 1;

                };

                break;
            }

            //
            // Handle parameters of the form /xxx
            //

            case PARM_BOOLEAN: {
                BOOLEAN *BooleanPointer;
                BooleanPointer = (BOOLEAN *)(ParameterDefinitions[ArgumentIndex].Global);

                *BooleanPointer = TRUE;
                break;
            }

            //
            // Handle parameters of the form /xxx that imply setting a bit
            //

            case PARM_BIT: {
                DWORD *DwordPointer;
                DwordPointer = (DWORD *)(ParameterDefinitions[ArgumentIndex].Global);

                *DwordPointer |= PtrToUlong( ParameterDefinitions[ArgumentIndex].ValueName );

                //
                // Some of these have TRUE or FALSE as an optional argument
                //

                if ( ParameterDefinitions[ArgumentIndex].EnumStrings != NULL ) {
                    if ( toupper(*Argument) == 'T' ) {
                        *((BOOL *)(ParameterDefinitions[ArgumentIndex].EnumStrings)) = TRUE;
                    } else if ( toupper(*Argument) == 'F' ) {
                        *((BOOL *)(ParameterDefinitions[ArgumentIndex].EnumStrings)) = FALSE;
                    } else {
                        fprintf( stderr,
                                 "\nArgument '%ls' requires a T or F as value.\n",
                                 OrigArgument );

                        return FALSE;
                    }
                }
                break;
            }

            default:
                fprintf( stderr,
                         "\nArgument '%ls' had an internal error.\n",
                         OrigArgument );
                return FALSE;

            }


        //
        // Handle arguments that aren't switches.
        //
        } else {

            //
            // All current arguments are switches
            //

            PrintUsage();
            return FALSE;

        }

    }


    return TRUE;
}


//
// Include routines to support the /ANSI parameter
//

LPSTR
NetpAllocAStrFromWStr (
    IN LPCWSTR Unicode
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding ANSI
    string.

Arguments:

    Unicode - Specifies the UNICODE zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated ANSI string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToAnsiSize( &UnicodeString );

    AnsiString.Buffer = (PCHAR) LocalAlloc( 0, AnsiString.MaximumLength );

    if ( AnsiString.Buffer == NULL) {
        return (NULL);
    }

    if(!NT_SUCCESS( RtlUnicodeStringToAnsiString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        (void) LocalFree( AnsiString.Buffer );
        return NULL;
    }

    return AnsiString.Buffer;

} // NetpAllocStrFromWStr

extern "C"
BOOL
DllMain(
    HINSTANCE instance,
    DWORD reason,
    VOID *
    );

int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Drive the credential manager API.

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    DWORD WinStatus;
    WCHAR Password[CREDUI_MAX_PASSWORD_LENGTH + 1];
    WCHAR UserName[CREDUI_MAX_USERNAME_LENGTH + 1];
    DWORD AuthError = NO_ERROR;
    CREDUI_INFOW UiInfoW;
    PCREDUI_INFOW UiInfoWptr = NULL;

    //
    // Parse the command line parameters
    //

    UserName[0] = '\0';
    Password[0] = '\0';

    if ( !ParseParameters() ) {
        return 1;
    }

    //
    // Fill in the parameters
    //

    if ( GlUserName != NULL) {
        wcscpy( UserName, GlUserName );
    }

    //
    // Get the error number
    //

    if ( GlAuthError != NULL ) {
        LPWSTR End;

        AuthError = wcstoul( GlAuthError, &End, 10 );
    }

    //
    // Handle special parameters
    //

    if ( GlNoConfirm ) {
        GlCreduiFlags |= CREDUI_FLAGS_EXPECT_CONFIRMATION;
    }

    //
    // Build the UI info
    //

    if ( GlMessage || GlTitle ) {
        UiInfoWptr = &UiInfoW;

        ZeroMemory( &UiInfoW, sizeof(UiInfoW) );

        UiInfoW.cbSize = sizeof(UiInfoW);
        UiInfoW.pszMessageText = GlMessage;
        UiInfoW.pszCaptionText = GlTitle;
    }


    //
    // Execute the requested command
    //

    switch ( GlCommand ) {
    case 0xFFFFFFFF:
        if ( GlAnsi ) {
            printf( "We don't yet do ansi.\n");
        } else {

            if ( GlDoGui ) {
                WinStatus = CredUIPromptForCredentialsW(
                                UiInfoWptr,
                                GlTargetName,
                                NULL,   // No security context
                                AuthError,
                                UserName,
                                sizeof(UserName)/sizeof(WCHAR),
                                Password,
                                sizeof(Password)/sizeof(WCHAR),
                                &GlSave,
                                GlCreduiFlags );
            } else {
                WinStatus = CredUICmdLinePromptForCredentialsW(
                                GlTargetName,
                                NULL,   // No security context
                                AuthError,
                                UserName,
                                sizeof(UserName)/sizeof(WCHAR),
                                Password,
                                sizeof(Password)/sizeof(WCHAR),
                                &GlSave,
                                GlCreduiFlags );

            }

            if ( WinStatus != NO_ERROR ) {
                fprintf( stderr, "CredUIPromptForCredentialsW failed: \n" );
                PrintStatus( WinStatus );
                return 1;
            }

            printf( "UserName: '%ws'\n", UserName );
            printf( "Password: '%ws'\n", Password );
            printf( "Save: %ld\n", GlSave );

            //
            // Do confirmation
            //

            if ( GlCreduiFlags & CREDUI_FLAGS_EXPECT_CONFIRMATION ) {

                WinStatus = CredUIConfirmCredentialsW( GlTargetName, !GlNoConfirm );

                if ( WinStatus != NO_ERROR ) {
                    fprintf( stderr, "CredUIConfirmCredentialsW failed: \n" );
                    PrintStatus( WinStatus );
                }

            }
        }
        break;

    default:
        fprintf( stderr, "Internal error: %ld\n", GlCommand );
        return 1;
    }

    fprintf( stderr, "Command completed successfully.\n" );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\autoenrl\csenroll\enroll.c ===
#include <windows.h>
#include <wincrypt.h>
#include <autoenr.h>
#include <cryptui.h>
#include <stdio.h>
#include <certca.h>
#include <stdlib.h>

#define SHA1_HASH_LEN 20
#define MSG_ERROR_S 1
#define MSG_ERROR_C 2
#define MSG_WARNING_S 4
#define MSG_WARNING_C 8
#define MSG_INFO_S 16
#define MSG_INFO_C 32

#define szOID_WINDOWS_SYSTEM_COMPONENT_VERIFICATION "1.3.6.1.4.1.311.10.3.6"
#define wszCERTTYPE_WINDOWS_TEST_BUILD_SIGNING L"WindowsTestBuildSigning"

PWCHAR mySanitizeName(IN WCHAR const *pwszName);

DWORD dwMsgLevel = MSG_ERROR_S | MSG_ERROR_C | MSG_INFO_S | MSG_INFO_C;

#define PrintMessage(MsgType, Msg) \
	if (MsgType & dwMsgLevel & MSG_ERROR_S)        _PrintMessage(L"csenroll: error: "); \
	else if (MsgType & dwMsgLevel & MSG_ERROR_C)   _PrintMessage(L"                 "); \
	else if (MsgType & dwMsgLevel & MSG_WARNING_S) _PrintMessage(L"csenroll: warning: "); \
	else if (MsgType & dwMsgLevel & MSG_WARNING_C) _PrintMessage(L"                   "); \
	else if (MsgType & dwMsgLevel & MSG_INFO_S) _PrintMessage(L"csenroll: "); \
	else if (MsgType & dwMsgLevel & MSG_INFO_C) _PrintMessage(L"          "); \
	if (MsgType & dwMsgLevel) _PrintMessage Msg

void
_PrintMessage(
	LPWSTR pwszFormat,
	...
	)
{
	WCHAR rgwszBuffer[1024];

	va_list argList;

	va_start(argList, pwszFormat);
	vswprintf(rgwszBuffer, pwszFormat, argList);

	fwprintf(stderr, rgwszBuffer);
}

				
BOOL
EnrollForCodeSigningCertificate(
    IN LPWSTR pwszCAName,
    IN LPWSTR pwszDNSName,
	PCERT_CONTEXT pOldCert
    )
{
    CRYPTUI_WIZ_CERT_REQUEST_INFO       CertRequestInfo;
    CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW    NewKeyInfo;
    CRYPTUI_WIZ_CERT_TYPE               CertType;
    CRYPT_KEY_PROV_INFO                 ProviderInfo;
    PCCERT_CONTEXT                      pCertContext = NULL;
    PCCERT_CONTEXT                      pCert = NULL;
    DWORD                               dwCAStatus;
    DWORD                               dwAcquireFlags = 0;
    LPWSTR                              pwszProvName = NULL;
	WCHAR								rgwszMachineName[MAX_COMPUTERNAME_LENGTH + 1]; 
    DWORD                               cMachineName = MAX_COMPUTERNAME_LENGTH + 1;
    CRYPT_DATA_BLOB                     CryptData;
    DWORD                               dwErr = 0;
    BOOL                                fRet = FALSE;
	LPWSTR								rgwszCertType[2];

    memset(&CertRequestInfo, 0, sizeof(CertRequestInfo));
    memset(&NewKeyInfo, 0, sizeof(NewKeyInfo));
    memset(&ProviderInfo, 0, sizeof(ProviderInfo));
    memset(&rgwszMachineName, 0, sizeof(rgwszMachineName));
    memset(&CryptData, 0, sizeof(CryptData));
    memset(&CertType, 0, sizeof(CertType));

    // set up the provider info
    ProviderInfo.dwProvType = 0; // pInfo->dwProvType;
    ProviderInfo.pwszProvName = NULL;  // The wizard will choose one based
                                       // on the cert type

    // set the acquire context flags
    // UNDONE - need to add silent flag
    ProviderInfo.dwFlags = 0; // dwAcquireFlags;

    // set the key specification
    ProviderInfo.dwKeySpec = 0; // pInfo->dwKeySpec;

    // set up the new key info
    NewKeyInfo.dwSize = sizeof(NewKeyInfo);
    NewKeyInfo.pKeyProvInfo = &ProviderInfo;
    // set the flags to be passed when calling CryptGenKey
    NewKeyInfo.dwGenKeyFlags = 0; // pInfo->dwGenKeyFlags;

    // set the request info
    CertRequestInfo.dwSize = sizeof(CertRequestInfo);

    // cert exists then check if expired (if so do renewal)
    if (pOldCert)
    {
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_RENEW;
        CertRequestInfo.pRenewCertContext = pOldCert;
    }
    else
    {
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;
        CertRequestInfo.pRenewCertContext = NULL;
    }

    // UNDONE - for now always gen a new key, later may allow using existing key
    // for things like renewal
    CertRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
    CertRequestInfo.pPvkNew = &NewKeyInfo;

    // destination cert store is the MY store (!!!! hard coded !!!!)
    CertRequestInfo.pwszDesStore = L"MY";

    // set algorithm for hashing
    CertRequestInfo.pszHashAlg = NULL;

    // set the cert type
	rgwszCertType[0] = wszCERTTYPE_WINDOWS_TEST_BUILD_SIGNING;
	rgwszCertType[1] = NULL;

    CertRequestInfo.dwCertChoice = CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE;
    CertType.dwSize = sizeof(CertType);
    CertType.cCertType = 1;
    CertType.rgwszCertType = rgwszCertType;
    CertRequestInfo.pCertType = &CertType;

    // set the Cert Server machine and authority
    CertRequestInfo.pwszCALocation = pwszDNSName;
    CertRequestInfo.pwszCAName = mySanitizeName(pwszCAName);

    // certify and create a key at the same time
    if (!CryptUIWizCertRequest(
		CRYPTUI_WIZ_NO_UI, 
		0, 
		NULL,
        &CertRequestInfo, 
		&pCertContext,     
        &dwCAStatus))    
    {
        PrintMessage(MSG_ERROR_S, (L"CyptUIWizCertRequest failed with %lxh\n", GetLastError()));
        goto Ret;
    }

	if (dwCAStatus != CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED) {

        PrintMessage(MSG_ERROR_S, (L"CyptUIWizCertRequest failed to issue certificate\n"));
        goto Ret;
	}

    fRet = TRUE;
Ret:
	if (CertRequestInfo.pwszCAName)
		LocalFree((PVOID) CertRequestInfo.pwszCAName);

    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    if (pCert)
        CertFreeCertificateContext(pCert);

    if (pwszProvName)
        LocalFree(pwszProvName);

    return fRet;
}

BOOL
ExportCertificateHash(
	PCERT_CONTEXT pCertContext
	)
{
	BYTE bSHA1Hash[SHA1_HASH_LEN], bPrintHash[SHA1_HASH_LEN * 2 + 1];
	DWORD cbHashLen = sizeof(bSHA1Hash), i;

	if (CertGetCertificateContextProperty(
		pCertContext,
		CERT_SHA1_HASH_PROP_ID,
		bSHA1Hash,
		&cbHashLen
		) == FALSE) {

		return FALSE;
	}

	for (i = 0; i < SHA1_HASH_LEN; i++) {

		BYTE dwVal = bSHA1Hash[i];

		bPrintHash[i * 2] = ((dwVal >> 4) >= 10 ? (dwVal >> 4) + 'A' - 10 : (dwVal >> 4) + '0');
		bPrintHash[i * 2 + 1] = ((dwVal & 0xf) >= 10 ? (dwVal & 0xf) + 'A' - 10 : (dwVal & 0xf) + '0');
	}

	bPrintHash[SHA1_HASH_LEN * 2] = '\0';

	printf(bPrintHash);

	return TRUE;
}

PCERT_CONTEXT
FindCodeSigningCertificate(
	HCERTSTORE hCertStore,
	LPWSTR pwszCAName,
	BYTE *pbSHA1Hash
	)
{
	PCERT_CONTEXT pRootContext = NULL, pCertContext = NULL;
	PCERT_CONTEXT pPrevCertContext = NULL, pReturnCertContext = NULL;
	PCERT_CHAIN_CONTEXT pChainContext = NULL;
	CERT_CHAIN_PARA ChainPara;
	CERT_ENHKEY_USAGE EnhKeyUsage, *pEnhKeyUsage;
	LPSTR rgpszOids[2];
	DWORD cElement, cbHashLen, cbUsageLen, i;
	BOOL bFound = FALSE, bFoundCodeSigning, bFoundWindowsVerification;
	BYTE rgbHashBuffer[SHA1_HASH_LEN];
	BYTE rgbUsage[1024];
	ULARGE_INTEGER CertTime, PrevCertTime;

	PrevCertTime.QuadPart = 0;

	__try {

		for (pPrevCertContext = NULL; ;pPrevCertContext = pCertContext) { 

			pCertContext = (PCERT_CONTEXT) CertFindCertificateInStore(
				hCertStore,              
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				0,
				CERT_FIND_ISSUER_STR, 
				pwszCAName,
				pPrevCertContext
				);

			if (pCertContext == NULL) {

				__leave;
			}

			cbUsageLen = sizeof(rgbUsage);
							
			pEnhKeyUsage = (PCERT_ENHKEY_USAGE) rgbUsage;

			if (CertGetEnhancedKeyUsage(
				pCertContext,
				0,
				pEnhKeyUsage,
				&cbUsageLen
				) == FALSE) {

				PrintMessage(MSG_ERROR_S, (L"Can't get certificate usage\n"));
				__leave;
			}

			bFoundCodeSigning = FALSE;
			bFoundWindowsVerification = FALSE;

			for (i = 0; i < pEnhKeyUsage->cUsageIdentifier; i++) {

				if (strcmp(
					   pEnhKeyUsage->rgpszUsageIdentifier[i], 
					   szOID_PKIX_KP_CODE_SIGNING) == 0) {

					bFoundCodeSigning = TRUE;
				}

				if (strcmp(
					   pEnhKeyUsage->rgpszUsageIdentifier[i], 
					   szOID_WINDOWS_SYSTEM_COMPONENT_VERIFICATION) == 0) {

					bFoundWindowsVerification = TRUE;
				}

				if (bFoundCodeSigning && bFoundWindowsVerification) {

					break;
				}
			}

			if (bFoundCodeSigning == FALSE || bFoundWindowsVerification == FALSE) {

				PrintMessage(MSG_WARNING_S, (L"Certificate issued by CA %s in 'MY store' can't be used for Windows build signing\n", pwszCAName));
				continue;

			} 

			bFound = FALSE;

			memset(rgbHashBuffer, 0, sizeof(rgbHashBuffer));

			// the user specified a hash for the root cert
			// check if this cert chains up to this root.
			if (memcmp(pbSHA1Hash, rgbHashBuffer, sizeof(rgbHashBuffer)) != 0) {

				rgpszOids[0] = szOID_PKIX_KP_CODE_SIGNING;
				rgpszOids[1] = szOID_WINDOWS_SYSTEM_COMPONENT_VERIFICATION;

				ChainPara.cbSize = sizeof(ChainPara);
				ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
				ChainPara.RequestedUsage.Usage.cUsageIdentifier = 2;
				ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgpszOids;

				if (CertGetCertificateChain(
					NULL, 
					pCertContext, 
					NULL,
					NULL,
					&ChainPara,
					0, 
					NULL,
					(CERT_CHAIN_CONTEXT const **) &pChainContext
					) == FALSE) {

					__leave;
				}

				// get to the root cert of this chain
				cElement = pChainContext->rgpChain[0]->cElement;
				pRootContext = (PCERT_CONTEXT) 
					pChainContext->rgpChain[0]->rgpElement[cElement - 1]->pCertContext;

				cbHashLen = sizeof(rgbHashBuffer);

				if (CertGetCertificateContextProperty(
					pRootContext,
					CERT_SHA1_HASH_PROP_ID,
					rgbHashBuffer,
					&cbHashLen
					) == FALSE) {

					PrintMessage(MSG_ERROR_S, (L"Can't get SHA1 hash for Windows build signing certificate\n"));
					__leave;
				}

				// check if this is the root cert we want
				if (memcmp(rgbHashBuffer, pbSHA1Hash, cbHashLen) != 0) {

					PrintMessage(MSG_WARNING_S, (L"Found Windows build signing certificate does not chain up to"));
					PrintMessage(MSG_WARNING_C, (L"requested root cert (wrong hash provided with -roothash?)\n"));
					continue;
					__leave;
				}

				bFound = TRUE;
				break;
			}

			// check the cert time of this cert against the time of the prev. valid cert.
			memcpy(&CertTime, &pCertContext->pCertInfo->NotAfter, sizeof(CertTime));

			if (CertTime.QuadPart > PrevCertTime.QuadPart) {

				if (pReturnCertContext) {

					CertFreeCertificateContext(pReturnCertContext);
				}

				pReturnCertContext = (PCERT_CONTEXT) CertDuplicateCertificateContext(pCertContext);
				PrevCertTime.QuadPart = CertTime.QuadPart;
			}
		}
	}
	__finally {

		if (pChainContext) {

			CertFreeCertificateChain(pChainContext);
		}

		if (bFound == FALSE) {

			CertFreeCertificateContext(pCertContext);
			pCertContext = NULL;
		}
	}

	return pReturnCertContext;
}

HCAINFO
CheckCA(
	LPWSTR pwszCAName
	)
{
	LPWSTR *pwszCertTypes = NULL, pwszSanitizeName = NULL;
	HCAINFO hCAInfo = NULL;
	BOOL bFoundCodeSigningCA = FALSE;
	int i;

	__try {

		if ((pwszSanitizeName = mySanitizeName(pwszCAName)) == NULL) {

			__leave;
		}

		// scan through the list of CAs to find a valid CA name
		if (CAFindByName(
				pwszSanitizeName,
				NULL,
				0,
				&hCAInfo
				) != S_OK) {

			PrintMessage(MSG_WARNING_S, (L"Can't find CA %s\n", pwszCAName));
			__leave;
		}

		// get the list of certificate templates that this CA can issue
		if (CAGetCAProperty(
			hCAInfo,
			CA_PROP_CERT_TYPES,
			&pwszCertTypes
			) != S_OK) {

			PrintMessage(MSG_ERROR_S, (L"Unable to retrieve certificate template list from CA %s\n", pwszCAName));
			__leave;
		}

		for (i = 0; pwszCertTypes[i]; i++) {

			if (wcscmp (pwszCertTypes[i], wszCERTTYPE_CODE_SIGNING) == 0) {

				bFoundCodeSigningCA = TRUE;
				break;
			}
		}
	}
	__finally {

		if (pwszCertTypes) {

			CAFreeCAProperty(hCAInfo, pwszCertTypes);
		}

		if (bFoundCodeSigningCA == FALSE && hCAInfo) {

			CACloseCA(hCAInfo);
			hCAInfo = NULL;
		}

		if (pwszSanitizeName != NULL) {

			LocalFree(pwszSanitizeName);
		}
	}

	return hCAInfo;
}

void 
PrintHelp(
	void
	)
{
	printf("Usage: csenroll -ca CAName [-ca CAName] [-d Days] [-h] [-roothash Hash]\n");
	printf(" Enroll for a Windows build signing certificate\n");
	printf("\n");
	printf(" Options:\n");
	printf(" -ca <CAName>       Name of CA from where to get a certificate\n");
	printf("                    For backup purposes you can specify multiple names.\n");
	printf("\n");
	printf(" -d <days>          Number of days before expiration of current certificate\n");
	printf("                    when an attempt is made to renew current certificate.\n");
	printf("\n");
	printf(" -h                 Show this help.\n");
	printf("\n");
	printf(" -roothash <Hash>   Specifiy the hash of the root certificate that the current\n");
	printf("                    Windows build signing certficate has to chain up to.\n");
	printf("                    Use this option to ensure that your Windows build signing\n");
	printf("                    certificate chains up to the correct root certificate\n");
	printf("\n");
	printf("\n");
}

int 
__cdecl
main(int argc, char **argv)
{
	PCERT_CONTEXT pCertContext = NULL;
	HCAINFO hCAInfo = NULL;
	HCERTSTORE hCertStore = NULL;
	LPWSTR pwszCAName = NULL, *pwszCAList = NULL, *pwszDNSName = NULL;
	BYTE rgbRootHash[SHA1_HASH_LEN];
	BOOL bRootHash = FALSE, bRet = FALSE;
	int i, dwNumCA = 0, dwDaysValid = 0, dwDays = 10;

	memset(rgbRootHash, 0, sizeof(rgbRootHash));

	__try {

		while (--argc) {

			argv += 1;

			if (_stricmp(*argv, "-ca") == 0) {

				int dwLen;

				argc -= 1;
				argv += 1;

				dwLen = (strlen(*argv) + 1) * sizeof(WCHAR);			

				if (pwszCAList == NULL) {

					pwszCAList = (LPWSTR *) malloc(sizeof(LPWSTR) * (dwNumCA + 2));

				} else {

					pwszCAList = (LPWSTR *) realloc(pwszCAList, sizeof(LPWSTR) * (dwNumCA + 2));
				}

				if (pwszCAList == NULL) {

					PrintMessage(MSG_ERROR_S, (L"Failed to allocate memory\n"));
					__leave;
				}

				pwszCAList[dwNumCA + 1] = NULL;
				pwszCAList[dwNumCA] = (LPWSTR) malloc(dwLen);

				if (pwszCAList[dwNumCA] == NULL) {

					PrintMessage(MSG_ERROR_S, (L"Failed to allocate memory\n"));
					__leave;
				}

				MultiByteToWideChar(
					CP_UTF8,
					0,
					*argv,
					-1,
					pwszCAList[dwNumCA],
					dwLen
					);

				dwNumCA += 1;
			}

			if (_stricmp(*argv, "-roothash") == 0) {

				argv += 1;
				argc -= 1;

				if (strlen(*argv) != SHA1_HASH_LEN * 2) {

					PrintMessage(MSG_ERROR_S, (L"Hash must have a length of 40 bytes\n"));
					__leave;
				}

				_strupr(*argv);

				for (i = 0; i < SHA1_HASH_LEN * 2; i++) {

					BYTE bNum;

					if ((*argv)[i] >= '0' && (*argv)[i] <= '9') {

						bNum = (*argv)[i] - '0';

					} else if ((*argv)[i] >= 'A' && (*argv)[i] <= 'F') {

						bNum = (*argv)[i] - 'A' + 10;

					} else {

						PrintMessage(MSG_ERROR_S, (L"Illegal hexdecimal number in hash\n"));
						__leave;
					}

					rgbRootHash[i / 2] |= (i % 2 ? bNum : bNum << 4);
				}

				bRootHash = TRUE;
			}

			if (_stricmp(*argv, "-v") == 0) {

				dwMsgLevel |= MSG_WARNING_S | MSG_WARNING_C;
			}

			if (_stricmp(*argv, "-d") == 0) {

				argv += 1;
				argc -= 1;

				dwDays = atoi(*argv);
			}

			if (_stricmp(*argv, "-h") == 0) {

				PrintHelp();
				__leave;
			}
		}

		if (dwNumCA == 0) {

			PrintHelp();
			__leave;
		}

		hCertStore = CertOpenSystemStore(
			0,               
			L"MY"
			);

		if (hCertStore == NULL) {

			PrintMessage(MSG_ERROR_S, (L"Can't open 'MY store'\n"));
			__leave;
		}

		if (bRootHash == FALSE) {

			PrintMessage(MSG_WARNING_S, (L"Certificate chain can't be verified (no -roothash specified)\n"));
		}

		for (i = 0; i < dwNumCA; i++) {

			//
			// now try to find a Windows build signing cert that was issued 
			// from a known ca and that chains up to a known root
			//
			pCertContext = FindCodeSigningCertificate(
				hCertStore,
				pwszCAList[i],
				rgbRootHash
				);

			if (pCertContext) {

				pwszCAName = pwszCAList[i];
				break;
			}
		}

		if (pCertContext) {

			// check how long the current cert is valid
			ULARGE_INTEGER CertTime, CurrentTime, days;
			FILETIME SystemTime, LocalTime;	

			memcpy(&CertTime, &pCertContext->pCertInfo->NotAfter, sizeof(CertTime));

			GetSystemTimeAsFileTime(&SystemTime);
			memcpy(&CurrentTime, &SystemTime, sizeof(CurrentTime));

			if (CertTime.QuadPart > CurrentTime.QuadPart) {

				dwDaysValid = (DWORD) 
					((CertTime.QuadPart - CurrentTime.QuadPart) / 
					(10000000i64 * 24 * 60 * 60));
			}

			//
			// now check if the CA that originally issued 
			// the cert is still available
			//
			if ((hCAInfo = CheckCA(pwszCAName)) == NULL) {

				PrintMessage(MSG_WARNING_S, (L"Can't find CA %s to renew certificate\n", pwszCAName));

				if (dwDaysValid < (dwDays / 2)) {

					// since we won't be able to renew this cert, just get a new one.
					CertFreeCertificateContext(pCertContext);
					pCertContext = NULL;
				} 
			}
		} 
		
		if (pCertContext == NULL) {

			// find a CA that can issue a windows build signing cert
			for (i = 0; i < dwNumCA; i++) {

				if (hCAInfo = CheckCA(pwszCAList[i])) {

					pwszCAName = pwszCAList[i];
					break;
				}
			}
		}

		if (pCertContext == NULL && hCAInfo == NULL) {

			PrintMessage(MSG_ERROR_S, (L"Can't find Windows build signing CA\n"));
			__leave;
		}

		if (hCAInfo && (pCertContext == NULL ||	dwDaysValid < dwDays)) {

			PrintMessage(
				MSG_INFO_S, 
				(L"%s build signing certificate. Please wait...\n", pCertContext ? L"Renewing" : L"Enrolling for")
				);

			// get DNS name of CA
			if (CAGetCAProperty(
				hCAInfo,
				CA_PROP_DNSNAME,
				&pwszDNSName
				) != S_OK) {

				PrintMessage(MSG_ERROR_S, (L"Unable to retrieve DNS name for %s\n", pwszCAName));
				__leave;
			}

			if (EnrollForCodeSigningCertificate(
				pwszCAName,
				*pwszDNSName,
				pCertContext
				) == FALSE) {

				PrintMessage(MSG_ERROR_S, (L"Enrollment for Windows build signing certificate failed\n"));
				PrintMessage(MSG_ERROR_C, (L"Check access rights to CA %s and\n", pwszCAName));
				PrintMessage(MSG_ERROR_C, (L"Windows build signing certificate template\n"));
				__leave;
			}

			// now make sure that we really have a cert in the store
			if (pCertContext) {

				CertFreeCertificateContext(pCertContext);
				pCertContext = NULL;
			}

			if (CertControlStore(
				hCertStore,                 
				0,                         
				CERT_STORE_CTRL_RESYNC,                      
				NULL                 
				) == FALSE) {

				PrintMessage(MSG_ERROR_S, (L"Failed to resync the 'MY store'\n"));
				__leave;
			}

			pCertContext = FindCodeSigningCertificate(
				hCertStore,
				pwszCAName,
				rgbRootHash
				);

			if (pCertContext == NULL) {

				PrintMessage(MSG_ERROR_S, (L"Can't find valid Windows build signing certificate in 'MY store'\n"));
				__leave;
			}
		}

		if (ExportCertificateHash(pCertContext) == FALSE) {

			PrintMessage(MSG_ERROR_S, (L"Export of Windows build signing certificate has failed\n"));
			__leave;
		}

		bRet = TRUE;
	}
	__finally {

		if (pwszDNSName) {

			CAFreeCAProperty(hCAInfo, pwszDNSName);
		}

		if (hCAInfo) {

			CACloseCA(hCAInfo);
		}

		if (pCertContext) {

			CertFreeCertificateContext(pCertContext);
		}

		if (hCertStore) {

			CertCloseStore(hCertStore, 0);
		}

	}
	return (bRet ? 0 : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\credui\utils.hpp ===
//=============================================================================
// Copyright (c) 2000 Microsoft Corporation
//
// dialogs.hpp
//
// Credential manager user interface classes used to get credentials.
//
// Created 02/29/2000 johnstep (John Stephens)
//=============================================================================

#ifndef __UTILS_HPP__
#define __UTILS_HPP__

#include <wincrypt.h>
#include <cryptui.h>
#include <lm.h>

//
// Determine if the passed in DWORD has precisely one bit set.
//

#define JUST_ONE_BIT( _x ) (((_x) != 0 ) && ( ( (~(_x) + 1) & (_x) ) == (_x) ))

// Singly-linked list Structure for holding a cred awaiting confirmation
typedef struct _CRED_AWAITING_CONFIRMATION
{
    WCHAR szTargetName[CRED_MAX_STRING_LENGTH+1+CRED_MAX_STRING_LENGTH + 1];
    PCREDENTIAL_TARGET_INFORMATION TargetInfo;
    PCREDENTIAL EncodedCredential;
    DWORD dwCredWriteFlags;
    BOOL DelayCredentialWrite;
    void* pNext;        // pointer to next cred in list
} CRED_AWAITING_CONFIRMATION;

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

BOOL
CreduiIsSpecialCredential(
    CREDENTIAL *credential
    );

BOOL
CreduiLookupLocalSidFromRid(
    DWORD rid,
    PSID *sid
    );

BOOL
CreduiLookupLocalNameFromRid(
    DWORD rid,
    LPWSTR *name
    );

BOOL
CreduiGetAdministratorsGroupInfo(
    LOCALGROUP_MEMBERS_INFO_2 **groupInfo,
    DWORD *memberCount
    );

BOOL
CreduiIsRemovableCertificate(
    CONST CERT_CONTEXT *certContext
    );

BOOL
CreduiIsExpiredCertificate(
    CONST CERT_CONTEXT *certContext
    );

BOOL
CreduiIsClientAuthCertificate(
    CONST CERT_CONTEXT *certContext
    );

BOOL
CreduiGetCertificateDisplayName(
    CONST CERT_CONTEXT *certContext,
    WCHAR *displayName,
    ULONG displayNameMaxChars,
    WCHAR *certificateString,
    DWORD dwDisplayType
    );

BOOL
CreduiIsWildcardTargetName(
    WCHAR *targetName
    );

BOOL
CreduiIsPostfixString(
    WCHAR *source,
    WCHAR *postfix
    );

// returns TRUE if pszUserName exists as a substring in pszCredential, FALSE if not
BOOL
LookForUserNameMatch (
    const WCHAR * pszUserName,
    const WCHAR * pszCredential
    );


// copies the marshalled name of pCert into pszMarshalledName.
// pszMarshalledName must be at least CREDUI_MAX_USERNAME_LENGTH in length
//
// returns TRUE if successful, FALSE if not
BOOL
CredUIMarshallNode (
    CERT_ENUM * pCert,
    WCHAR* pszMarshalledName
    );

DWORD
WriteCred(
    IN PCWSTR pszTargetName,
    IN DWORD Flags,
    IN PCREDENTIAL_TARGET_INFORMATION TargetInfo OPTIONAL,
    IN PCREDENTIAL Credential,
    IN DWORD dwCredWriteFlags,
    IN BOOL DelayCredentialWrite,
    IN BOOL EncryptedVisiblePassword
    );


BOOL AddCredToConfirmationList (
    IN PCWSTR pszTargetName,
    IN PCREDENTIAL_TARGET_INFORMATION TargetInfo OPTIONAL,
    IN PCREDENTIAL Credential,
    IN DWORD dwCredWriteFlags,
    IN BOOL DelayCredentialWrite
    );

DWORD
ConfirmCred (
    IN PCWSTR pszTargetName,
    IN BOOL bConfirm,
    IN BOOL bOkToDelete
    );

void CleanUpConfirmationList();
BOOL InitConfirmationList();

BOOL IsDeaultSSORealm ( WCHAR* pszTargetName );


#define MAX_SSO_URL_SIZE    4096

#define SSOBRAND_X_SIZE     320
#define SSOBRAND_Y_SIZE      60

typedef struct _SSOPACKAGE {
    WCHAR szBrand[MAX_SSO_URL_SIZE];
    WCHAR szURL[MAX_SSO_URL_SIZE];
    WCHAR szAttrib[CRED_MAX_STRING_LENGTH];
    WCHAR szRegURL[MAX_SSO_URL_SIZE];
    WCHAR szHelpURL[MAX_SSO_URL_SIZE];
    DWORD dwRegistrationCompleted;              // 0 if not completed, 1 if completed
    DWORD dwNumRegistrationRuns;                // number of times we've prompted for registration
    CONST CLSID* pRegistrationWizard;                 // CLSID of any registration wizard   
} SSOPACKAGE;

// Looks in the registry for an SSO entry for the specified package.
// Fills in the SSOPackage struct and returns TRUE if found.  Returns
// FALSE if no registry entry found
BOOL
GetSSOPackageInfo (
    CREDENTIAL_TARGET_INFORMATION* TargetInfo,
    SSOPACKAGE* pSSOStruct
    );


// returns TRUE if it was found, with the value copied to pszRealm.
// pszRealm is expected to be at least CREDUI_MAX_DOMAIN_TARGET_LENGTH in length
// returns FALSE if not found
BOOL ReadPassportRealmFromRegistry (
    WCHAR* pszRealm );


void GetDeaultSSORealm ( WCHAR* pszTargetName, BOOL bForceLookup = TRUE );

// returns TRUE if a cred is saved for that realm
BOOL CheckForSSOCred( WCHAR* pszTargetRealm );

DWORD EncryptPassword ( PWSTR pszPassword, PVOID* ppszEncryptedPassword, DWORD* pSize );

BOOL IsPasswordEncrypted ( PVOID pPassword, DWORD cbSize );


// Uses GDI+ to load an image as an HBITMAP
HBITMAP LoadImageFromFileViaGdiPlus(
    PWSTR pszFileName,
    UINT *pcWidth,
    UINT *pcHeight);



///////////////////////////////////////////////////////////////////////////////////////////////
//
// Wincred.h functions
//
// these are local mirrors of the credmgr functions so we can handle downlevel cases properly
//
///////////////////////////////////////////////////////////////////////////////////////////////

// Prototypes for Whistler functions

typedef
BOOL
(WINAPI
*PFN_CREDWRITEW) (
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    );


typedef
BOOL
(WINAPI
*PFN_CREDREADW) (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags,
    OUT PCREDENTIALW *Credential
    );

typedef
BOOL
(WINAPI
*PFN_CREDENUMERATEW) (
    IN LPCWSTR Filter,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    );


typedef
BOOL
(WINAPI
*PFN_CREDWRITEDOMAINCREDENTIALSW) (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    );

typedef
BOOL
(WINAPI
*PFN_CREDREADDOMAINCREDENTIALSW) (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    );

typedef
BOOL
(WINAPI
*PFN_CREDDELETEW) (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags
    );

typedef
BOOL
(WINAPI
*PFN_CREDRENAMEW) (
    IN LPCWSTR OldTargetName,
    IN LPCWSTR NewTargetName,
    IN DWORD Type,
    IN DWORD Flags
    );


typedef
BOOL
(WINAPI
*PFN_CREDGETTARGETINFOW) (
    IN LPCWSTR TargetName,
    IN DWORD Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    );


typedef
BOOL
(WINAPI
*PFN_CREDMARSHALCREDENTIALW) (
    IN CRED_MARSHAL_TYPE CredType,
    IN PVOID Credential,
    OUT LPWSTR *MarshaledCredential
    );


typedef
BOOL
(WINAPI
*PFN_CREDUNMARSHALCREDENTIALW) (
    IN LPCWSTR MarshaledCredential,
    OUT PCRED_MARSHAL_TYPE CredType,
    OUT PVOID *Credential
    );


typedef
BOOL
(WINAPI
*PFN_CREDISMARSHALEDCREDENTIALW) (
    IN LPCWSTR MarshaledCredential
    );

typedef
BOOL
(WINAPI
*PFN_CREDISMARSHALEDCREDENTIALA) (
    IN LPCSTR MarshaledCredential
    );


typedef
BOOL
(WINAPI
*PFN_CREDGETSESSIONTYPES) (
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    );

typedef
VOID
(WINAPI
*PFN_CREDFREE) (
    IN PVOID Buffer
    );

// pointers to Whistler functions

extern BOOL bCredMgrAvailable;
extern PFN_CREDWRITEW pfnCredWriteW;
extern PFN_CREDREADW pfnCredReadW;
extern PFN_CREDENUMERATEW pfnCredEnumerateW;
extern PFN_CREDWRITEDOMAINCREDENTIALSW pfnCredWriteDomainCredentialsW;
extern PFN_CREDREADDOMAINCREDENTIALSW pfnCredReadDomainCredentialsW;
extern PFN_CREDDELETEW pfnCredDeleteW;
extern PFN_CREDRENAMEW pfnCredRenameW;
extern PFN_CREDGETTARGETINFOW pfnCredGetTargetInfoW;
extern PFN_CREDMARSHALCREDENTIALW pfnCredMarshalCredentialW;
extern PFN_CREDUNMARSHALCREDENTIALW pfnCredUnMarshalCredentialW;
extern PFN_CREDISMARSHALEDCREDENTIALW pfnCredIsMarshaledCredentialW;
extern PFN_CREDISMARSHALEDCREDENTIALA pfnCredIsMarshaledCredentialA;
extern PFN_CREDGETSESSIONTYPES pfnCredGetSessionType;
extern PFN_CREDFREE pfnCredFree;


//////
// local functions prototypes
//

BOOL
WINAPI
LocalCredWriteW (
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    );


BOOL
WINAPI
LocalCredReadW (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags,
    OUT PCREDENTIALW *Credential
    );

BOOL
WINAPI
LocalCredEnumerateW (
    IN LPCWSTR Filter,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    );


BOOL
WINAPI
LocalCredWriteDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PCREDENTIALW Credential,
    IN DWORD Flags
    );

BOOL
WINAPI
LocalCredReadDomainCredentialsW (
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN DWORD Flags,
    OUT DWORD *Count,
    OUT PCREDENTIALW **Credential
    );

BOOL
WINAPI
LocalCredDeleteW (
    IN LPCWSTR TargetName,
    IN DWORD Type,
    IN DWORD Flags
    );

BOOL
WINAPI
LocalCredRenameW (
    IN LPCWSTR OldTargetName,
    IN LPCWSTR NewTargetName,
    IN DWORD Type,
    IN DWORD Flags
    );


BOOL
WINAPI
LocalCredGetTargetInfoW (
    IN LPCWSTR TargetName,
    IN DWORD Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    );


BOOL
WINAPI
LocalCredMarshalCredentialW(
    IN CRED_MARSHAL_TYPE CredType,
    IN PVOID Credential,
    OUT LPWSTR *MarshaledCredential
    );


BOOL
WINAPI
LocalCredUnmarshalCredentialW(
    IN LPCWSTR MarshaledCredential,
    OUT PCRED_MARSHAL_TYPE CredType,
    OUT PVOID *Credential
    );


BOOL
WINAPI
LocalCredIsMarshaledCredentialW(
    IN LPCWSTR MarshaledCredential
    );

BOOL
WINAPI
LocalCredIsMarshaledCredentialA(
    IN LPCSTR MarshaledCredential
    );


BOOL
WINAPI
LocalCredGetSessionTypes (
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    );

VOID
WINAPI
LocalCredFree (
    IN PVOID Buffer
    );


// function to load pointers
BOOL
InitializeCredMgr ();

// function to unload lib
void
UninitializeCredMgr();

VOID
CredPutStdout(
    IN LPWSTR String
    );

VOID
CredGetStdin(
    OUT LPWSTR Buffer,
    IN DWORD BufferLength,
    IN BOOLEAN EchoChars
    );






//=============================================================================
// CreduiIsCapsLockOn
//
// Returns TRUE if the Caps Lock key was on at the time the most recent
// message was posted or FALSE otherwise.
//
// Created 02/27/2000 johnstep (John Stephens)
//=============================================================================

inline
BOOL
CreduiIsCapsLockOn()
{
    return (GetKeyState(VK_CAPITAL) & 1) == 1;
}



//
// Type of username
//

typedef enum _CREDUI_USERNAME_TYPE {
    CreduiMarshalledUsername, // @@...
    CreduiAbsoluteUsername,   // <DomainName>\<UserName>
    CreduiUpn,                // <UserName>@<DnsDomainName>
    CreduiRelativeUsername,   // <UserName>
} CREDUI_USERNAME_TYPE, *PCREDUI_USERNAME_TYPE;

DWORD
CredUIParseUserNameWithType(
    CONST WCHAR *UserName,
    WCHAR *user,
    ULONG userMaxChars,
    WCHAR *domain,
    ULONG domainMaxChars,
    PCREDUI_USERNAME_TYPE UsernameType
    );

LPWSTR
GetAccountDomainName(
    VOID
    );

BOOL
CompleteUserName(
    IN OUT LPWSTR UserName,
    IN ULONG UserNameMaxChars,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo OPTIONAL,
    IN LPWSTR TargetName OPTIONAL,
    IN DWORD Flags
    );


BOOL TryLauchRegWizard ( 
    SSOPACKAGE* pSSOPackage,                        
    HWND hwndParent,
    BOOL HasLogonSession,
    WCHAR *userName,
    ULONG userNameMaxChars,
    WCHAR *password,
    ULONG passwordMaxChars,
    DWORD* pResult
    );

//-----------------------------------------------------------------------------

#endif // __UTILS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\autoenrl\pautoenr\autoenro.h ===
//+--------------------------------------------------------------------------
//  FILE          : autoenro.h                                             
//  DESCRIPTION   : Private Auto Enrollment functions                      
//                                                             
//            
//  Copyright (C) 1993-2000 Microsoft Corporation   All Rights Reserved    
//+--------------------------------------------------------------------------

#ifndef __AUTOENRO_H__
#define __AUTOENRO_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//--------------------------------------------------------------------------
//  Globals
//--------------------------------------------------------------------------
extern HINSTANCE   g_hmodThisDll;


//--------------------------------------------------------------------------
//  contant defines
//--------------------------------------------------------------------------
#define AE_PENDING_REQUEST_ACTIVE_PERIOD        60      //60 days

#define	AE_RETRY_LIMIT							3		//retry 3 times for machine DNS error

#define SHA1_HASH_LENGTH    20

#define ENCODING_TYPE       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING

#define MY_STORE            L"MY"

#define REQUEST_STORE       L"REQUEST"

#define ACRS_STORE          L"ACRS"

//possible status for the request tree
#define CERT_REQUEST_STATUS_ACTIVE                      0x01

#define CERT_REQUEST_STATUS_OBTAINED                    0x02

#define CERT_REQUEST_STATUS_PENDING                     0x03  
                                                
#define CERT_REQUEST_STATUS_SUPERSEDE_ACTIVE            0x04  


// Time skew margin for fast CA's
#define FILETIME_TICKS_PER_SECOND           10000000

#define AE_DEFAULT_SKEW                     60*60*1  // 1 hour

#define MAX_DN_SIZE                         256

#define AE_SUMMARY_COLUMN_SIZE              100

#define PENDING_ALLOC_SIZE                  20   

#define USER_AUTOENROLL_DELAY_FOR_MACHINE   70       //70 seconds to wait


//defines for autoenrollment event log
#define EVENT_AUTO_NAME                     L"AutoEnrollment"
#define AUTO_ENROLLMENT_EVENT_LEVEL_KEY     TEXT("SOFTWARE\\Microsoft\\Cryptography\\AutoEnrollment")
#define AUTO_ENROLLMENT_EVENT_LEVEL         TEXT("AEEventLogLevel")

//defines for autoenrollment disable key
#define AUTO_ENROLLMENT_DISABLE_KEY         L"SOFTWARE\\Microsoft\\Cryptography\\AutoEnrollment\\AEDisable"

//defines for autoenrollment user no wait for 60 seconds key
#define AUTO_ENROLLMENT_EXPRESS_KEY         L"SOFTWARE\\Microsoft\\Cryptography\\AutoEnrollment\\AEExpress"

//defines for autoenrollment directory cache information
#define AUTO_ENROLLMENT_DS_KEY              L"SOFTWARE\\Microsoft\\Cryptography\\AutoEnrollment\\AEDirectoryCache"
#define AUTO_ENROLLMENT_DS_USN              L"AEMaxUSN"
#define AUTO_ENROLLMENT_DS_OBJECT           L"AEObjectCount"

#define AUTO_ENROLLMENT_TEMPLATE_KEY        L"SOFTWARE\\Microsoft\\Cryptography\\CertificateTemplateCache"

#define AUTO_ENROLLMENT_USN_ATTR            L"uSNChanged"

//defines for the UI component
#define AUTO_ENROLLMENT_SHOW_TIME           15                  //show the balloon for 15 seconds
#define AUTO_ENROLLMENT_INTERVAL            7 * 60 * 30         //show the icon for 7 hours 7* 3600
#define AUTO_ENROLLMENT_RETRIAL             2

#define AUTO_ENROLLMENT_QUERY_INTERVAL      30              //query continue every 30 seconds

#define AUTO_ENROLLMENT_BALLOON_LENGTH      7 * 60 * 60              	//keep the balloon for 7 hours

#define AE_DEFAULT_POSTPONE                 1                   //we relaunch autoenrollment for 1 hour

//define used for sorting of columns in the list view
#define AE_SUMMARY_COLUMN_TYPE              1
#define AE_SUMMARY_COLUMN_REASON            2
#define SORT_COLUMN_ASCEND                  0x00010000
#define SORT_COLUMN_DESCEND                 0x00020000


//--------------------------------------------------------------------------
//  struct defines
//--------------------------------------------------------------------------
//struct for retry property on the certificate due to DNS error
typedef struct _AE_RETRY_INFO_
{
    DWORD				cbSize;
	DWORD				dwRetry;
	ULARGE_INTEGER		dueTime;
} AE_RETRY_INFO;


//struct for autoenrollment main thread
typedef struct _AE_MAIN_THREAD_INFO_
{
    HWND     hwndParent;
    DWORD    dwStatus;
} AE_MAIN_THREAD_INFO;


//struct for updating certificate store from AD
typedef struct _AE_STORE_INFO_
{
    LPWSTR      pwszStoreName;
    LPWSTR      pwszLdapPath;
} AE_STORE_INFO;

//struct for the information we compute from DS
typedef struct _AE_DS_INFO_
{
    BOOL                fValidData;
    DWORD               dwObjects;
    ULARGE_INTEGER      maxUSN;
} AE_DS_INFO;

//struct for param of view RA certificate dialogue
typedef struct _AE_VIEW_RA_INFO_
{
    PCERT_CONTEXT       pRAContext;
    LPWSTR              pwszRATemplate;
} AE_VIEW_RA_INFO;


//struct for individual certifcate information
typedef struct _AE_CERT_INFO_
{
    BOOL    fValid;
    BOOL    fRenewal;
} AE_CERT_INFO;

//strcut for certificate's template information
typedef struct _AE_TEMPLATE_INFO_
{
    LPWSTR  pwszName;
    LPWSTR  pwszOid;
    DWORD   dwVersion;
} AE_TEMPLATE_INFO;

//struct for certificate authority information
typedef struct _AE_CA_INFO_
{
    HCAINFO         hCAInfo;
    LPWSTR          *awszCertificateTemplate;
    LPWSTR          *awszCAName;
    LPWSTR          *awszCADNS;
    LPWSTR          *awszCADisplay;
} AE_CA_INFO;


//struct for keeping the issued pending certificates
typedef struct _AE_PEND_INFO_
{
    CRYPT_DATA_BLOB blobPKCS7;          //the issued pending certificate for UI installation
    CRYPT_DATA_BLOB blobHash;           //the hash of the certificate request to be removed from the request store
}AE_PEND_INFO;

//struct for certificate template information
typedef struct _AE_CERTTYPE_INFO_
{
    HCERTTYPE       hCertType;
    DWORD           dwSchemaVersion;
    DWORD           dwVersion;
    LPWSTR          *awszName;
    LPWSTR          *awszDisplay;
    LPWSTR          *awszOID;  
    LPWSTR          *awszSupersede;
    DWORD           dwEnrollmentFlag;
    DWORD           dwPrivateKeyFlag;
    LARGE_INTEGER   ftExpirationOffset;
    DWORD           dwStatus;
    BOOL            fCheckMyStore;
    BOOL            fRenewal;
    BOOL            fNeedRA;            //the request needs to be signed by itself or another certificate
    BOOL            fCrossRA;           //the request is cross RAed.
    BOOL            fSupersedeVisited;  //the flag to prevent infinite loop in superseding relationship
    BOOL            fUIActive;
    DWORD           dwActive;
    DWORD           *prgActive;
    DWORD           dwRandomCAIndex;
    PCERT_CONTEXT   pOldCert;           //for renewal case managing MY store
    HCERTSTORE      hArchiveStore;      //contains the certificates to be archived
    HCERTSTORE      hObtainedStore;     //for supersede relation ships
    HCERTSTORE      hIssuedStore;       //keep issued certificates for re-publishing
    DWORD           dwPendCount;        //the count of pending issued certs
    AE_PEND_INFO    *rgPendInfo;        //the point to the struct array
    DWORD           idsSummary;         //the summary string ID
} AE_CERTTYPE_INFO;

//struct for the autoenrollment process
typedef struct _AE_GENERAL_INFO_
{
    HWND                hwndParent;
    LDAP *              pld;
    HANDLE              hToken;
    BOOL                fMachine;
    DWORD               dwPolicy;
    DWORD               dwLogLevel;
    WCHAR               wszMachineName[MAX_COMPUTERNAME_LENGTH + 2];
    HCERTSTORE          hMyStore;
    HCERTSTORE          hRequestStore;
    DWORD               dwCertType;
    AE_CERTTYPE_INFO    *rgCertTypeInfo;
    DWORD               dwCA;
    AE_CA_INFO          *rgCAInfo;
    HMODULE             hXenroll;
    BOOL                fUIProcess;                 //whether we are doing interactive enrollment
    HANDLE              hCancelEvent;
    HANDLE              hCompleteEvent;
    HANDLE              hThread;
    HWND                hwndDlg;                    //the dialogue window handle of the UI window
    DWORD               dwUIPendCount;              //the count of UI required pending requests
    DWORD               dwUIEnrollCount;            //the count of UI requires new requests
    DWORD               dwUIProgressCount;          //the count of active working items
    BOOL                fSmartcardSystem;           //whether a smart card reader is installed
	LPWSTR				pwszDns;					//the DNS name of the local computer
	LPWSTR				pwszNetBIOS;				//the NetBios name of the local computer
} AE_GENERAL_INFO;

//--------------------------------------------------------------------------
//  Class definition
//--------------------------------------------------------------------------
class CQueryContinue : IQueryContinue
{
public:
    CQueryContinue();
    ~CQueryContinue();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IQueryContinue
    STDMETHODIMP QueryContinue();    // S_OK -> Continue, other 

    // DoBalloon
    HRESULT DoBalloon();

private:
    LONG                    m_cRef;
    IUserNotification       *m_pIUserNotification;
    HANDLE                  m_hTimer;
};


//--------------------------------------------------------------------------
//  function prototype
//--------------------------------------------------------------------------
HRESULT 
AEGetConfigDN(
    IN  LDAP *pld,
    OUT LPWSTR *pwszConfigDn
    );

HRESULT
AERobustLdapBind(
    OUT LDAP ** ppldap);

BOOL    AERetrieveGeneralInfo(AE_GENERAL_INFO *pAE_General_Info);

BOOL    AEFreeGeneralInfo(AE_GENERAL_INFO *pAE_General_Info);

BOOL    AERetrieveCAInfo(LDAP *pld, BOOL fMachine, HANDLE hToken, DWORD *pdwCA, AE_CA_INFO **prgCAInfo);

BOOL    AEFreeCAInfo(DWORD dwCA, AE_CA_INFO *rgCAInfo);

BOOL    AEFreeCAStruct(AE_CA_INFO *pCAInfo);

BOOL    AERetrieveCertTypeInfo(LDAP *pld, BOOL fMachine, DWORD *pdwCertType, AE_CERTTYPE_INFO **prgCertType);

BOOL    AEFreeCertTypeInfo(DWORD dwCertType, AE_CERTTYPE_INFO *rgCertTypeInfo);

BOOL    AEFreeCertTypeStruct(AE_CERTTYPE_INFO *pCertTypeInfo);

BOOL    AEAllocAndCopy(LPWSTR    pwszSrc, LPWSTR    *ppwszDest);

BOOL    AEIfSupersede(LPWSTR  pwsz, LPWSTR *awsz, AE_GENERAL_INFO *pAE_General_Info);

BOOL    AEClearVistedFlag(AE_GENERAL_INFO *pAE_General_Info);

BOOL    AECopyCertStore(HCERTSTORE     hSrcStore,   HCERTSTORE     hDesStore);

BOOL    AEIsAnElement(LPWSTR   pwsz, LPWSTR *awsz);

BOOL    AECancelled(HANDLE hCancelEvent);

BOOL    AERetrieveTemplateInfo(PCCERT_CONTEXT           pCertCurrent, 
                                AE_TEMPLATE_INFO        *pTemplateInfo);

BOOL    AEFreeTemplateInfo(AE_TEMPLATE_INFO *pAETemplateInfo);

AE_CERTTYPE_INFO *AEFindTemplateInRequestTree(AE_TEMPLATE_INFO  *pTemplateInfo,
                                              AE_GENERAL_INFO   *pAE_General_Info);


BOOL    AEUIProgressAdvance(AE_GENERAL_INFO *pAE_General_Info);

BOOL    AEUIProgressReport(BOOL fPending, AE_CERTTYPE_INFO *pCertType, HWND hwndDlg, HANDLE hCancelEvent);

BOOL    FormatMessageUnicode(LPWSTR * ppwszFormat, UINT ids, ...);

void    AELogAutoEnrollmentEvent(IN DWORD    dwLogLevel,
                            IN BOOL     fError,
                            IN HRESULT  hr,
                            IN DWORD    dwEventId,
                            IN BOOL     fMachine,
                            IN HANDLE   hToken,
                            IN DWORD    dwParamCount,
                            ...
                            );

BOOL    AENetLogonUser(
                        LPTSTR UserName,
                        LPTSTR DomainName,
                        LPTSTR Password,
                        PHANDLE phToken
                        );

BOOL	AEIsEmptyStore(HCERTSTORE     hCertStore);

BOOL	AEIsSameDNS(PCCERT_CONTEXT	pFirstCert, PCCERT_CONTEXT pSecondCert);

BOOL	AEGetDNSNameFromCertificate(PCCERT_CONTEXT	pCertContext,
									LPWSTR			*ppwszDnsName);

BOOL	AEGetRetryProperty(PCCERT_CONTEXT	pCertContext,
						   AE_RETRY_INFO	**ppAE_Retry_Info);

BOOL	AEUpdateRetryProperty(AE_GENERAL_INFO	*pAE_General_Info, 
							  LPWSTR			pwszTemplateDisplay,
							  PCCERT_CONTEXT	pNewContext, 
							  PCCERT_CONTEXT	pOldContext);

BOOL	AEFasterRetrialSchedule(PCCERT_CONTEXT	pFirstContext, 
								PCCERT_CONTEXT	pSecondContext);

//--------------------------------------------------------------------------
//  Debug prints
//--------------------------------------------------------------------------
#if DBG
#define AE_ERROR                0x0001
#define AE_WARNING              0x0002
#define AE_INFO                 0x0004
#define AE_TRACE                0x0008
#define AE_ALLOC                0x0010
#define AE_RES                  0x0020

#define AE_DEBUG(x) AEDebugLog x
#define AE_BEGIN(x) AEDebugLog(AE_TRACE, L"BEGIN:" x L"\n");
#define AE_RETURN(x) { AEDebugLog(AE_TRACE, L"RETURN (%lx) Line %d\n",(x), __LINE__); return (x); }
#define AE_END()    { AEDebugLog(AE_TRACE, L"END:Line %d\n",  __LINE__); }
#define AE_BREAK()  { AEDebugLog(AE_TRACE, L"BREAK  Line %d\n",  __LINE__); }
void    AEDebugLog(long Mask,  LPCWSTR Format, ...);

#define MAX_DEBUG_BUFFER 256

#else
#define AE_DEBUG(x) 
#define AE_BEGIN(x) 
#define AE_RETURN(x) return (x)
#define AE_END() 
#define AE_BREAK() 

#endif

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __AUTOENRO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\autoenrl\pautoenr\pautoenr.c ===
#include <windows.h>
#include <wincrypt.h>
#include <autoenr.h>
#include <cryptui.h>

#define MY_TEST_REG_ENTRY   "Software\\Microsoft\\Cryptography\\AutoEnroll"
#define PST_EVENT_INIT "PS_SERVICE_STARTED"


/*BOOL SmallTest(DWORD dw)
{
    HKEY    hRegKey = 0;
    DWORD   dwDisposition;
    BOOL    fRet = FALSE;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER, MY_TEST_REG_ENTRY,
                                        0, NULL, REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS, NULL, &hRegKey,
                                        &dwDisposition))
        goto Ret;

    if (ERROR_SUCCESS != RegSetValueEx(hRegKey, "AutoEnrollTest", 0,
                                       REG_BINARY, (BYTE*)&dw, sizeof(dw)))
        goto Ret;

    fRet = TRUE;
Ret:
    if (hRegKey)
        RegCloseKey(hRegKey);
    SetLastError(dw);
    return fRet;
}*/

void AutoEnrollErrorLogging(DWORD dwErr)
{
    return;
    // UNDONE - log the error along with some useful message
    //SmallTest(dwErr);
}

#define FAST_BUFF_LEN   256



BOOL EnrollForACert(
                    IN BOOL fMachineEnrollment,
                    IN BOOL fRenewalRequired,
                    IN PAUTO_ENROLL_INFO pInfo
                    )
{
    CRYPTUI_WIZ_CERT_REQUEST_INFO       CertRequestInfo;
    CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW    NewKeyInfo;
    CRYPTUI_WIZ_CERT_TYPE               CertType;
    CRYPT_KEY_PROV_INFO                 ProviderInfo;
    PCCERT_CONTEXT                      pCertContext = NULL;
    PCCERT_CONTEXT                      pCert = NULL;
    DWORD                               dwCAStatus;
    DWORD                               dwAcquireFlags = 0;
    LPWSTR                              pwszProvName = NULL;
	WCHAR								rgwszMachineName[MAX_COMPUTERNAME_LENGTH + 1]; 
    DWORD                               cMachineName = MAX_COMPUTERNAME_LENGTH + 1;
    CRYPT_DATA_BLOB                     CryptData;
    DWORD                               dwErr = 0;
    BOOL                                fRet = FALSE;

    memset(&CertRequestInfo, 0, sizeof(CertRequestInfo));
    memset(&NewKeyInfo, 0, sizeof(NewKeyInfo));
    memset(&ProviderInfo, 0, sizeof(ProviderInfo));
    memset(rgwszMachineName, 0, sizeof(rgwszMachineName));
    memset(&CryptData, 0, sizeof(CryptData));
    memset(&CertType, 0, sizeof(CertType));

    if (fMachineEnrollment)
    {
        dwAcquireFlags = CRYPT_MACHINE_KEYSET;
	    if (0 == GetComputerNameW(rgwszMachineName,
                                  &cMachineName))
        {
            goto Ret;
        }
        CertRequestInfo.pwszMachineName = rgwszMachineName;
    }
    
    // set up the provider info
    ProviderInfo.dwProvType = pInfo->dwProvType;

    ProviderInfo.pwszProvName = NULL;  // The wizard will choose one based
                                       // on the cert type

    // set the acquire context flags
    // UNDONE - need to add silent flag
    ProviderInfo.dwFlags = dwAcquireFlags;

    // set the key specification
    ProviderInfo.dwKeySpec = pInfo->dwKeySpec;

    // set up the new key info
    NewKeyInfo.dwSize = sizeof(NewKeyInfo);
    NewKeyInfo.pKeyProvInfo = &ProviderInfo;
    // set the flags to be passed when calling CryptGenKey
    NewKeyInfo.dwGenKeyFlags = pInfo->dwGenKeyFlags;

    // set the request info
    CertRequestInfo.dwSize = sizeof(CertRequestInfo);

    // UNDONE - if cert exists then check if expired (if so do renewal)
    if (pInfo->fRenewal)
    {
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_RENEW;
        CertRequestInfo.pRenewCertContext = pInfo->pOldCert;
    }
    else
    {
        CertRequestInfo.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;
        CertRequestInfo.pRenewCertContext = NULL;
    }

    // UNDONE - for now always gen a new key, later may allow using existing key
    // for things like renewal
    CertRequestInfo.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
    CertRequestInfo.pPvkNew = &NewKeyInfo;

    // destination cert store is the MY store (!!!! hard coded !!!!)
    CertRequestInfo.pwszDesStore = L"MY";

    // set algorithm for hashing
    CertRequestInfo.pszHashAlg = NULL;

    // set the cert type
    CertRequestInfo.dwCertChoice = CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE;
    CertType.dwSize = sizeof(CertType);
    CertType.cCertType = 1;
    CertType.rgwszCertType = &pInfo->pwszCertType;
    CertRequestInfo.pCertType = &CertType;

    // set the requested cert extensions
    CertRequestInfo.pCertRequestExtensions = &pInfo->CertExtensions;

    // set post option  
    CertRequestInfo.dwPostOption = 0;

    // set the Cert Server machine and authority
    CertRequestInfo.pwszCALocation = pInfo->pwszCAMachine;
    CertRequestInfo.pwszCAName = pInfo->pwszCAAuthority;

    // certify and create a key at the same time
    if (!CryptUIWizCertRequest(CRYPTUI_WIZ_NO_UI, 0, NULL,
                               &CertRequestInfo, &pCertContext,     
                               &dwCAStatus))    
    {
        AutoEnrollErrorLogging(GetLastError());
        goto Ret;
    }

    if (CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED == dwCAStatus)
    {
        BYTE aHash[20];
        CRYPT_HASH_BLOB blobHash;

        blobHash.pbData = aHash;
        blobHash.cbData = sizeof(aHash);
        CryptData.cbData = (wcslen(pInfo->pwszAutoEnrollmentID) + 1) * sizeof(WCHAR);
        CryptData.pbData = (BYTE*)pInfo->pwszAutoEnrollmentID;
        
        // We need to get the real certificate of the store, as the one
        // passed back is self contained.
        if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_SHA1_HASH_PROP_ID,
                                          blobHash.pbData,
                                          &blobHash.cbData))
        {
            AutoEnrollErrorLogging(GetLastError());
            goto Ret;
        }

        pCert =  CertFindCertificateInStore(pInfo->hMYStore,
                                            pCertContext->dwCertEncodingType,
                                            0,
                                            CERT_FIND_SHA1_HASH,
                                            &blobHash,
                                            NULL);
        if(pCert == NULL)
        {
            AutoEnrollErrorLogging(GetLastError());
            goto Ret;
        }

        // place the auto enrollment property on the cert
        if (!CertSetCertificateContextProperty(pCert,
                        CERT_AUTO_ENROLL_PROP_ID, 0, &CryptData))
        {
            AutoEnrollErrorLogging(GetLastError());
            goto Ret;
        }
    }

    // UNDONE - request did not return cert so take appropriate action
//    else
//    {
//        goto Ret;
//    }

    fRet = TRUE;
Ret:
    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    if (pCert)
        CertFreeCertificateContext(pCert);

    if (pwszProvName)
        LocalFree(pwszProvName);

    return fRet;
}









//+---------------------------------------------------------------------------
//
//  Function:   ProvAutoEnrollment
//
//  Synopsis:   Entry point for the default MS auto enrollment client provider.
//
//  Arguments:  
//          fMachineEnrollment - TRUE if machine is enrolling, FALSE if user
//
//          pInfo - information needed to enroll (see AUTO_ENROLL_INFO struct
//                  in autoenrl.h)
//
//  History:    01-12-98   jeffspel   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL ProvAutoEnrollment(
                        IN BOOL fMachineEnrollment,
                        IN PAUTO_ENROLL_INFO pInfo
                        )
{
    BOOL                fRenewalRequired = FALSE;
    BOOL                fRet = FALSE;

 
        // enroll for a cert
        if (!EnrollForACert(fMachineEnrollment, fRenewalRequired, pInfo))
            goto Ret;

    fRet = TRUE;
Ret:
    return fRet;
}

BOOLEAN
DllInitialize(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context
    )
{

    return( TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\autoenrl\pautoenr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDD_USER_AUTOENROLL_GENERAL_DLG 184
#define IDD_USER_AUTOENROLL_INFO_DLG    185
#define IDD_VIEW_RA_CERTIFICATE_DLG     186
#define IDD_USER_SUMMARY_DLG            187
#define IDC_EDIT2                       200
#define IDC_EDIT1                       201
#define IDC_BUTTON1                     202
#define IDC_BUTTON2                     203
#define IDC_ENROLL_PROGRESS             204
#define IDC_EDIT3                       204
#define IDC_BUTTON3                     205
#define IDC_LIST1                       291
#define IDC_LIST2                       292
#define IDI_AUTOENROLL_ICON             1000
#define IDI_ENROLL_ICON                 1001
#define IDI_KEY_ICON                    1002
#define IDS_USER                        2000
#define IDS_MACHINE                     2001
#define IDS_BALLOON_TITLE               2002
#define IDS_BALLOON_TEXT                2003
#define IDS_ICON_TIP                    2004
#define IDS_REPORT_ENROLL               2005
#define IDS_REPORT_RENEW                2006
#define IDS_REPORT_ENROLL_RA            2007
#define IDS_REPORT_PENDING              2008
#define IDS_VIEW_RA_INFO                2011
#define IDS_VIEW_RA_INFO_GENERAL        2012
#define IDS_SUMMARY_REQUEST             2013
#define IDS_SUMMARY_CA                  2014
#define IDS_SUMMARY_INSTALL             2015
#define IDS_COLUMN_TYPE                 2016  
#define IDS_COLUMN_REASON               2017


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        242
#define _APS_NEXT_COMMAND_VALUE         32787
#define _APS_NEXT_CONTROL_VALUE         293
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\win32\ntcrypto\autoenrl\pautoenr\autoenro.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       autoenro.cpp
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <winuser.h>
#include <wincrypt.h>
#include <stdio.h>
#include <cryptui.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <oleauto.h>
#define SECURITY_WIN32
#include <rpc.h>
#include <security.h>
#include <winldap.h>
#include <dsrole.h>
#include <shobjidl.h>
#include <shellapi.h>
#include <commctrl.h>
#include <winscard.h>
#include <Rpcdce.h>

#include <certca.h>
#include <certsrv.h>
#include <autoenr.h>
#include <autoenro.h>
#include <autolog.h>
#include <resource.h>
#include <xenroll.h>

//*******************************************************************************
//
//
//     Global Defines and Data Structures
//
//
//*******************************************************************************


HINSTANCE   g_hmodThisDll = NULL;   // Handle to this DLL itself.

#if DBG
DWORD g_AutoenrollDebugLevel = AE_ERROR; //| AE_WARNING | AE_INFO | AE_TRACE;
#endif

//when we look at supersede relationship, we based on the following order
DWORD   g_rgdwSupersedeOrder[]={CERT_REQUEST_STATUS_OBTAINED,
                                CERT_REQUEST_STATUS_ACTIVE,
                                CERT_REQUEST_STATUS_PENDING,
                                CERT_REQUEST_STATUS_SUPERSEDE_ACTIVE};

DWORD   g_dwSupersedeOrder=sizeof(g_rgdwSupersedeOrder)/sizeof(g_rgdwSupersedeOrder[0]);


//the list of certificate store to update
AE_STORE_INFO   g_rgStoreInfo[]={
    L"ROOT",    L"ldap:///CN=Certification Authorities,CN=Public Key Services,CN=Services,%s?cACertificate?one?objectCategory=certificationAuthority",
    L"NTAuth",  L"ldap:///CN=Public Key Services,CN=Services,%s?cACertificate?one?cn=NTAuthCertificates",
    L"CA",      L"ldap:///CN=AIA,CN=Public Key Services,CN=Services,%s?crossCertificatePair,cACertificate?one?objectCategory=certificationAuthority"
};

DWORD   g_dwStoreInfo=sizeof(g_rgStoreInfo)/sizeof(g_rgStoreInfo[0]);

typedef   IEnroll4 * (WINAPI *PFNPIEnroll4GetNoCOM)();

static WCHAR * s_wszLocation = L"CN=Public Key Services,CN=Services,";



//*******************************************************************************
//
//
//     Implementation of IQueryContinue for use autoenrollment notification
//
//
//*******************************************************************************
//--------------------------------------------------------------------------
//  CQueryContinue 
//--------------------------------------------------------------------------
CQueryContinue::CQueryContinue()
{
    m_cRef=1;
    m_pIUserNotification=NULL;
    m_hTimer=NULL;
}

//--------------------------------------------------------------------------
//  ~CQueryContinue 
//--------------------------------------------------------------------------
CQueryContinue::~CQueryContinue()
{


}

//--------------------------------------------------------------------------
//  CQueryContinue 
//--------------------------------------------------------------------------
HRESULT CQueryContinue::QueryInterface(REFIID riid, void **ppv)
{
    if(IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IQueryContinue))
    {
        *ppv=(LPVOID)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//--------------------------------------------------------------------------
//  AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CQueryContinue::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
//  Release 
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CQueryContinue::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

//--------------------------------------------------------------------------
//  CQueryContinue 
//--------------------------------------------------------------------------
HRESULT CQueryContinue::QueryContinue()
{
    //disable the balloon
    if(m_pIUserNotification)
        m_pIUserNotification->SetBalloonInfo(NULL, NULL, NIIF_INFO);

    //wait for the timer to be activated
    if(m_hTimer)
    {
        if(WAIT_OBJECT_0 == WaitForSingleObject(m_hTimer, 0))
          return S_FALSE;
    }
  
    return S_OK;
}
   

//--------------------------------------------------------------------------
//  DoBalloon() 
//--------------------------------------------------------------------------
HRESULT CQueryContinue::DoBalloon()
{

    HRESULT             hr=E_FAIL;
    WCHAR               wszTitle[MAX_DN_SIZE];
    WCHAR               wszText[MAX_DN_SIZE];
    HICON               hIcon=NULL;
    LARGE_INTEGER       DueTime;

   if(S_OK != (hr=CoCreateInstance(CLSID_UserNotification,
                                   NULL,
				   CLSCTX_ALL,
				   IID_IUserNotification,
				   (void **)&m_pIUserNotification)))
		goto Ret;

    if(NULL==m_pIUserNotification)
    {
        hr=E_FAIL;
        goto Ret;
    }

    //create a waitable timer with default security setting
    m_hTimer=CreateWaitableTimer(NULL, TRUE, NULL);

    if(NULL==m_hTimer)
    {
        hr=E_FAIL;
        goto Ret;
    }

    //set the timer
    DueTime.QuadPart = Int32x32To64(-10000, AUTO_ENROLLMENT_BALLOON_LENGTH * 1000);

    if(!SetWaitableTimer(m_hTimer, &DueTime, 0, NULL, 0, FALSE))
    {
        hr=E_FAIL;
        goto Ret;
    }


    if(S_OK != (hr=m_pIUserNotification->SetBalloonRetry(AUTO_ENROLLMENT_SHOW_TIME * 1000,
                                        AUTO_ENROLLMENT_INTERVAL * 1000,
                                        AUTO_ENROLLMENT_RETRIAL)))
        goto Ret;

    if((!LoadStringW(g_hmodThisDll,IDS_ICON_TIP, wszText, MAX_DN_SIZE)) ||
       (NULL==(hIcon=LoadIcon(g_hmodThisDll, MAKEINTRESOURCE(IDI_AUTOENROLL_ICON)))))
    {
       hr=E_FAIL;
       goto Ret;
    }

    if(S_OK != (hr=m_pIUserNotification->SetIconInfo(hIcon, wszText)))
        goto Ret;


    if((!LoadStringW(g_hmodThisDll,IDS_BALLOON_TITLE, wszTitle, MAX_DN_SIZE)) ||
       (!LoadStringW(g_hmodThisDll,IDS_BALLOON_TEXT, wszText, MAX_DN_SIZE)))
    {
       hr=E_FAIL;
       goto Ret;
    }

    if(S_OK !=(hr=m_pIUserNotification->SetBalloonInfo(wszTitle, wszText, NIIF_INFO)))
        goto Ret;

    //user did not click on the icon or we time out
    hr= m_pIUserNotification->Show(this, AUTO_ENROLLMENT_QUERY_INTERVAL * 1000);

Ret:
    if(m_hTimer)
    {
        CloseHandle(m_hTimer);
        m_hTimer=NULL;
    }


    if(m_pIUserNotification)
    {
        m_pIUserNotification->Release();
        m_pIUserNotification=NULL;
    }

    return hr;
}

//*******************************************************************************
//
//
//     Functions for autoenrollment
//
//
//*******************************************************************************

//--------------------------------------------------------------------------
//
// Name:    FindCertificateInOtherStore
//
//--------------------------------------------------------------------------
PCCERT_CONTEXT FindCertificateInOtherStore(
    IN HCERTSTORE hOtherStore,
    IN PCCERT_CONTEXT pCert
    )
{
    BYTE rgbHash[SHA1_HASH_LENGTH];
    CRYPT_DATA_BLOB HashBlob;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = SHA1_HASH_LENGTH;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &HashBlob.cbData
            ) || SHA1_HASH_LENGTH != HashBlob.cbData)
        return NULL;

    return CertFindCertificateInStore(
            hOtherStore,
            ENCODING_TYPE,      // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &HashBlob,
            NULL                //pPrevCertContext
            );
}

//--------------------------------------------------------------------------
//
//  AEUpdateCertificateStore
//
// Description: This function enumerates all of the certificate in the DS based
// LdapPath, and moves them into the corresponding local machine store.
//
//--------------------------------------------------------------------------
HRESULT WINAPI  AEUpdateCertificateStore(LDAP   *pld,
                                        LPWSTR  pwszConfig,
                                        LPWSTR  pwszStoreName,
                                        LPWSTR  pwszLdapPath)
{
    HRESULT							hr = S_OK;
	CERT_LDAP_STORE_OPENED_PARA		CertOpenStoreParam;
    PCCERT_CONTEXT					pContext = NULL,
									pOtherCert = NULL;

    LPWSTR							pwszLdapStore = NULL;
    HCERTSTORE						hEnterpriseStore = NULL,
									hLocalStore = NULL;

    if((NULL==pld) || (NULL==pwszConfig) || (NULL==pwszStoreName) || (NULL==pwszLdapPath))
    {
        hr = E_INVALIDARG;
        goto error;
    }

    pwszLdapStore = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pwszConfig)+wcslen(pwszLdapPath)+1));
    if(pwszLdapStore == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    wsprintf(pwszLdapStore, 
             pwszLdapPath,
             pwszConfig);

    
    hLocalStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_REGISTRY_W, 
                                0, 
                                0, 
                                CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE, 
                                pwszStoreName);
    if(hLocalStore == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"Unable to open ROOT store (%lx)\n\r", hr));
        goto error;
    }

	memset(&CertOpenStoreParam, 0, sizeof(CertOpenStoreParam));
	CertOpenStoreParam.pvLdapSessionHandle=pld;
	CertOpenStoreParam.pwszLdapUrl=pwszLdapStore;

    hEnterpriseStore = CertOpenStore(CERT_STORE_PROV_LDAP, 
                  0,
                  0,
                  CERT_STORE_READONLY_FLAG | CERT_LDAP_STORE_SIGN_FLAG |
				  CERT_LDAP_STORE_OPENED_FLAG,
                  &CertOpenStoreParam);
    
    if(hEnterpriseStore == NULL)
    {
        DWORD err = GetLastError();

        if((err == ERROR_FILE_NOT_FOUND))
        {
            // There was no store, so there are no certs
            hr = S_OK;
            goto error;
        }


        hr = HRESULT_FROM_WIN32(err);

        AE_DEBUG((AE_ERROR, L"Unable to open ROOT store (%lx)\n\r", hr));
        goto error;
    }


    while(pContext = CertEnumCertificatesInStore(hEnterpriseStore, pContext))
    {
        if (pOtherCert = FindCertificateInOtherStore(hLocalStore, pContext)) {
            CertFreeCertificateContext(pOtherCert);
        } 
        else
        {
            CertAddCertificateContextToStore(hLocalStore,
                                         pContext,
                                         CERT_STORE_ADD_ALWAYS,
                                         NULL);
        }
    }

    while(pContext = CertEnumCertificatesInStore(hLocalStore, pContext))
    {
        if (pOtherCert = FindCertificateInOtherStore(hEnterpriseStore, pContext)) {
            CertFreeCertificateContext(pOtherCert);
        } 
        else
        {
            CertDeleteCertificateFromStore(CertDuplicateCertificateContext(pContext));
        }
    }


error:

    if(hr != S_OK)
    {
        AELogAutoEnrollmentEvent(
                            STATUS_SEVERITY_ERROR,  //this event will always be logged
                            TRUE,
                            hr,
                            EVENT_FAIL_DOWNLOAD_CERT,
                            TRUE,
                            NULL,
                            2,
                            pwszStoreName,
                            pwszLdapStore);

    }

    if(pwszLdapStore)
    {
        LocalFree(pwszLdapStore);
    }

    if(hEnterpriseStore)
    {
        CertCloseStore(hEnterpriseStore,0);
    }

    if(hLocalStore)
    {
        CertCloseStore(hLocalStore,0);
    }

    return hr;
}

//--------------------------------------------------------------------------
//
//  AENeedToUpdateDSCache
//
//--------------------------------------------------------------------------
BOOL AENeedToUpdateDSCache(LDAP *pld, LPWSTR pwszDCInvocationID, LPWSTR pwszConfig, AE_DS_INFO *pAEDSInfo)
{
    BOOL                fNeedToUpdate=TRUE;
    DWORD               dwRegObject=0;
    ULARGE_INTEGER      maxRegUSN;
    ULARGE_INTEGER      maxDsUSN;
    DWORD               dwType=0;
    DWORD               dwSize=0;
    DWORD               dwDisp=0;
    struct l_timeval    timeout;
    LPWSTR              rgwszAttrs[] = {AUTO_ENROLLMENT_USN_ATTR, NULL};
    LDAPMessage         *Entry=NULL;

    LPWSTR              *awszValue = NULL;
    HKEY                hDSKey=NULL;
    HKEY                hDCKey=NULL;
    LDAPMessage         *SearchResult = NULL;
    LPWSTR              pwszContainer=NULL;


    if((NULL==pld) || (NULL==pwszDCInvocationID) || (NULL==pwszConfig) || (NULL==pAEDSInfo))
        goto error;

    //init
    memset(pAEDSInfo, 0, sizeof(AE_DS_INFO));

    //compute the # of objects and maxUSN from the directory
    pwszContainer=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (1 + wcslen(pwszConfig) + wcslen(s_wszLocation)));
    if(NULL == pwszContainer)
        goto error;
        
    wcscpy(pwszContainer, s_wszLocation);
    wcscat(pwszContainer, pwszConfig);

    timeout.tv_sec = 300;
    timeout.tv_usec = 0;
    
	if(LDAP_SUCCESS != ldap_search_stW(
		      pld, 
		      pwszContainer,
		      LDAP_SCOPE_SUBTREE,
		      L"(objectCategory=certificationAuthority)",
		      rgwszAttrs,
		      0,
		      &timeout,
		      &SearchResult))
        goto error;

    //get the # of objects
    pAEDSInfo->dwObjects = ldap_count_entries(pld, SearchResult);

    for(Entry = ldap_first_entry(pld, SearchResult);  Entry != NULL; Entry = ldap_next_entry(pld, Entry))
    {

        awszValue = ldap_get_values(pld, Entry, AUTO_ENROLLMENT_USN_ATTR);

        if(NULL==awszValue)
            goto error;

        if(NULL==awszValue[0])
            goto error;

        maxDsUSN.QuadPart=0;

        maxDsUSN.QuadPart=_wtoi64(awszValue[0]);

        //if any error happens, maxDsUSN will be 0.
        if(0 == maxDsUSN.QuadPart)
            goto error;

        if((pAEDSInfo->maxUSN).QuadPart < maxDsUSN.QuadPart)
             (pAEDSInfo->maxUSN).QuadPart = maxDsUSN.QuadPart;

        ldap_value_free(awszValue);
        awszValue=NULL;
    }

    //signal that we have retrieved correct data from the directory
    pAEDSInfo->fValidData=TRUE;

   //find if we have cached any information about the DC of interest
    if(ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                         AUTO_ENROLLMENT_DS_KEY,
                         0,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hDSKey,
                         &dwDisp))        
        goto error;


    if(ERROR_SUCCESS != RegOpenKeyEx(
                        hDSKey,
                        pwszDCInvocationID,
                        0,
                        KEY_ALL_ACCESS,
                        &hDCKey))
        goto error;


    dwSize=sizeof(dwRegObject);

    if(ERROR_SUCCESS != RegQueryValueEx(
                        hDCKey,
                        AUTO_ENROLLMENT_DS_OBJECT,  
                        NULL,
                        &dwType,
                        (PBYTE)(&dwRegObject),    
                        &dwSize))
        goto error;

    if(REG_DWORD != dwType)
        goto error;


    dwSize=sizeof(maxRegUSN);

    if(ERROR_SUCCESS != RegQueryValueEx(
                        hDCKey,
                        AUTO_ENROLLMENT_DS_USN,  
                        NULL,
                        &dwType,
                        (PBYTE)(&(maxRegUSN)),    
                        &dwSize))
        goto error;

    if(REG_BINARY != dwType)
        goto error;


    //compare the registry data with the data from directory
    if(dwRegObject != (pAEDSInfo->dwObjects))
        goto error;

    if(maxRegUSN.QuadPart != ((pAEDSInfo->maxUSN).QuadPart))
        goto error;

    fNeedToUpdate=FALSE;

error:
    
    if(awszValue)
        ldap_value_free(awszValue);

    if(pwszContainer)
        LocalFree(pwszContainer);

    if(hDCKey)
        RegCloseKey(hDCKey);

    if(hDSKey)
        RegCloseKey(hDSKey);

    if(SearchResult)
        ldap_msgfree(SearchResult);

    //remove the temporary data
    if(pAEDSInfo)
    {
        if(FALSE == fNeedToUpdate)
            memset(pAEDSInfo, 0, sizeof(AE_DS_INFO));
    }


    return fNeedToUpdate;
}

//--------------------------------------------------------------------------
//
//  AEUpdateDSCache
//
//--------------------------------------------------------------------------
BOOL AEUpdateDSCache(LPWSTR pwszDCInvocationID, AE_DS_INFO *pAEDSInfo)
{

    BOOL    fResult=FALSE;
    DWORD   dwDisp=0;

    HKEY    hDSKey=NULL;
    HKEY    hDCKey=NULL;

    if((NULL==pwszDCInvocationID) || (NULL==pAEDSInfo))
        goto error;

    if(ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                         AUTO_ENROLLMENT_DS_KEY,
                         0,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hDSKey,
                         &dwDisp))
        goto error;


    //create the key named by the DC
    if(ERROR_SUCCESS != RegCreateKeyEx(hDSKey,
                         pwszDCInvocationID,
                         0,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hDCKey,
                         &dwDisp))
        goto error;

    //set the # of objects value
    if(ERROR_SUCCESS != RegSetValueEx(hDCKey,
                    AUTO_ENROLLMENT_DS_OBJECT,
                    NULL,
                    REG_DWORD,
                    (PBYTE)&(pAEDSInfo->dwObjects),
                    sizeof(pAEDSInfo->dwObjects)))
        goto error;

    //set the max uSN value
    if(ERROR_SUCCESS != RegSetValueEx(hDCKey,
                    AUTO_ENROLLMENT_DS_USN,
                    NULL,
                    REG_BINARY,
                    (PBYTE)&(pAEDSInfo->maxUSN),
                    sizeof(pAEDSInfo->maxUSN)))
        goto error;

    fResult=TRUE;

error:

    if(hDCKey)
        RegCloseKey(hDCKey);

    if(hDSKey)
        RegCloseKey(hDSKey);


    return fResult;
}


//--------------------------------------------------------------------------
//
//  AERetrieveInvocationID
//
//--------------------------------------------------------------------------
BOOL  AERetrieveInvocationID(LDAP *pld, LPWSTR *ppwszID)
{  
    BOOL                fResult=FALSE;
    struct l_timeval    timeout;
    LPWSTR              rgwszDSAttrs[] = {L"dsServiceName", NULL};
    LPWSTR              rgwszIDAttr[] = {L"invocationId", NULL};
    LDAPMessage         *Entry=NULL;

    LPWSTR              *awszValues = NULL;
    LDAPMessage         *SearchResults = NULL;
    struct berval       **apUUID = NULL;
    LDAPMessage         *SearchIDResult = NULL;
    BYTE                *pbUUID=NULL;



    if((NULL==pld) || (NULL==ppwszID))
        goto error;

    *ppwszID=NULL;

    //retrieve the dsSerivceName attribute
    timeout.tv_sec = 300;
    timeout.tv_usec = 0;

	if(LDAP_SUCCESS != ldap_search_stW(
		      pld, 
		      NULL,                     //NULL DN for dsServiceName
		      LDAP_SCOPE_BASE,
		      L"(objectCategory=*)",
		      rgwszDSAttrs,
		      0,
		      &timeout,
		      &SearchResults))
        goto error;


    Entry = ldap_first_entry(pld, SearchResults);

    if(NULL == Entry)
        goto error;

    awszValues = ldap_get_values(pld, Entry, rgwszDSAttrs[0]);

    if(NULL==awszValues)
        goto error;

    if(NULL==awszValues[0])
        goto error;

    //retrieve the invocationId attribute
    timeout.tv_sec = 300;
    timeout.tv_usec = 0;

	if(LDAP_SUCCESS != ldap_search_stW(
		      pld, 
		      awszValues[0],                     
		      LDAP_SCOPE_BASE,
		      L"(objectCategory=*)",
		      rgwszIDAttr,
		      0,
		      &timeout,
		      &SearchIDResult))
        goto error;


    Entry = ldap_first_entry(pld, SearchIDResult);

    if(NULL == Entry)
        goto error;

	apUUID = ldap_get_values_len(pld, Entry, rgwszIDAttr[0]);

    if(NULL == apUUID)
        goto error;

    if(NULL == (*apUUID))
        goto error;

    pbUUID = (BYTE *)LocalAlloc(LPTR, (*apUUID)->bv_len);

    if(NULL == (pbUUID))
        goto error;

	if(0 == ((*apUUID)->bv_len))
		goto error;

	if(NULL == ((*apUUID)->bv_val))
		goto error;

    memcpy(pbUUID, (*apUUID)->bv_val, (*apUUID)->bv_len);

    if(RPC_S_OK != UuidToStringW((UUID *)pbUUID, ppwszID))
        goto error;

    fResult=TRUE;

error:

    if(pbUUID)
        LocalFree(pbUUID);

    if(apUUID)
        ldap_value_free_len(apUUID);

    if(SearchIDResult)
        ldap_msgfree(SearchIDResult);

    if(awszValues)
        ldap_value_free(awszValues);

    if(SearchResults)
        ldap_msgfree(SearchResults);

    return fResult;
}

//--------------------------------------------------------------------------
//
//  AEDownloadStore
//
//--------------------------------------------------------------------------
BOOL WINAPI AEDownloadStore(LDAP *pld)
{
    BOOL        fResult = TRUE;
    DWORD       dwIndex = 0;
    AE_DS_INFO  AEDSInfo;

    LPWSTR      wszConfig = NULL;
    LPWSTR      pwszDCInvocationID = NULL;

    memset(&AEDSInfo, 0, sizeof(AEDSInfo));

    if(S_OK  != AEGetConfigDN(pld, &wszConfig))
    {
        fResult=FALSE;
        goto error;
    }

    //get the pwszDCInvocationID.  NULL means AENeedToUpdateDSCache will return TRUE
    AERetrieveInvocationID(pld, &pwszDCInvocationID);

    if(AENeedToUpdateDSCache(pld, pwszDCInvocationID, wszConfig, &AEDSInfo))
    {
        for(dwIndex =0; dwIndex < g_dwStoreInfo; dwIndex++)
        {
            fResult = fResult && (S_OK == AEUpdateCertificateStore(
                                            pld, 
                                            wszConfig,
                                            g_rgStoreInfo[dwIndex].pwszStoreName,
                                            g_rgStoreInfo[dwIndex].pwszLdapPath));
        }

        //only update the new DS cached information if we have a successful download
        if((fResult) && (TRUE == AEDSInfo.fValidData) && (pwszDCInvocationID))
            AEUpdateDSCache(pwszDCInvocationID, &AEDSInfo);
    }


error:

    if(pwszDCInvocationID)
        RpcStringFreeW(&pwszDCInvocationID);

    if(wszConfig)
    {
        LocalFree(wszConfig);
    }

    return fResult;
}


//--------------------------------------------------------------------------
//
//  AESetWakeUpFlag
//
//  We set the flag to tell winlogon if autoenrollment should be waken up
//  during each policy check
//
//--------------------------------------------------------------------------
BOOL WINAPI AESetWakeUpFlag(BOOL    fMachine,   BOOL fWakeUp)
{
    BOOL    fResult = FALSE;
    DWORD   dwDisp = 0;
    DWORD   dwFlags = 0;

    HKEY    hAEKey = NULL;
    
    if(ERROR_SUCCESS != RegCreateKeyEx(
                    fMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                    AUTO_ENROLLMENT_FLAG_KEY,
                    0,
                    L"",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hAEKey,
                    &dwDisp))
        goto Ret;

    if(fWakeUp)
        dwFlags = AUTO_ENROLLMENT_WAKE_UP_REQUIRED;

    if(ERROR_SUCCESS != RegSetValueEx(
                    hAEKey,
                    AUTO_ENROLLMENT_FLAG,
                    0,
                    REG_DWORD,
                    (PBYTE)&dwFlags,
                    sizeof(dwFlags)))
        goto Ret;


    fResult=TRUE;

Ret:
    if(hAEKey)
        RegCloseKey(hAEKey);

    return fResult;
}


//--------------------------------------------------------------------------
//
//  AESetWakeUpTimer
//
//  Set the timer to wake us up in 8 hrs
//
//--------------------------------------------------------------------------
BOOL WINAPI AESetWakeUpTimer(BOOL fMachine, LARGE_INTEGER *pPreTime, LARGE_INTEGER *pPostTime)
{
    HRESULT hr;
    HKEY hKey;
    HKEY hCurrent;
    DWORD dwType, dwSize, dwResult;
    LONG lTimeout;
    LARGE_INTEGER DueTime;
    WCHAR * wszTimerName;
    LARGE_INTEGER EnrollmentTime;

    // must be cleaned up
    HANDLE hTimer=NULL;

    // Build a timer event to ping us in about 8 hours if we don't get notified sooner.
    lTimeout=AE_DEFAULT_REFRESH_RATE;

    // Query for the refresh timer value
    if (ERROR_SUCCESS==RegOpenKeyEx((fMachine?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER), SYSTEM_POLICIES_KEY, 0, KEY_READ, &hKey)) {
        dwSize=sizeof(lTimeout);
        if(ERROR_SUCCESS != RegQueryValueEx(hKey, TEXT("AutoEnrollmentRefreshTime"), NULL, &dwType, (LPBYTE) &lTimeout, &dwSize))
		{
			lTimeout=AE_DEFAULT_REFRESH_RATE;
		}
		else
		{
			if(REG_DWORD != dwType)
				lTimeout=AE_DEFAULT_REFRESH_RATE;
		}
        RegCloseKey(hKey);
    }

    // Limit the timeout to once every 240 hours (10 days)
    if (lTimeout>=240) {
        lTimeout=240;
    } else if (lTimeout<0) {
        lTimeout=0;
    }

    // Convert hours to milliseconds
    lTimeout=lTimeout*60*60*1000;

    // Special case 0 milliseconds to be 7 seconds
    if (lTimeout==0) {
        lTimeout=7000;
    }

    // convert to 10^-7s. not yet negative values are relative
    DueTime.QuadPart=Int32x32To64(-10000, lTimeout);

    // if user has hold on the UI for too long and the cycle passed the 8 hours.
    // we set the time for 1 hour
    EnrollmentTime.QuadPart=pPostTime->QuadPart - pPreTime->QuadPart;

    if(EnrollmentTime.QuadPart > 0)
    {
        if((-(DueTime.QuadPart)) > EnrollmentTime.QuadPart)
        {
            DueTime.QuadPart = DueTime.QuadPart + EnrollmentTime.QuadPart;
        }
        else
        {
            // Convert hours to milliseconds
            lTimeout=AE_DEFAULT_POSTPONE*60*60*1000;
            DueTime.QuadPart = Int32x32To64(-10000, lTimeout);
        }
    }


    // find the timer
    if (fMachine) {
        wszTimerName=L"Global\\" MACHINE_AUTOENROLLMENT_TIMER_NAME;
    } else {
        wszTimerName=USER_AUTOENROLLMENT_TIMER_NAME;
    }
    hTimer=OpenWaitableTimer(TIMER_MODIFY_STATE, false, wszTimerName);
    if (NULL==hTimer) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"OpenWaitableTimer(%s) failed with 0x%08X.\n", wszTimerName, hr));
        goto error;
    }

    // set the timer
    if (!SetWaitableTimer (hTimer, &DueTime, 0, NULL, 0, FALSE)) {
        hr=HRESULT_FROM_WIN32(GetLastError());
        AE_DEBUG((AE_ERROR, L"SetWaitableTimer  failed with 0x%08X.\n", hr));
        goto error;
    }

    AE_DEBUG((AE_INFO, L"Set wakeup timer.\n"));

    hr=S_OK;
error:
    if (NULL!=hTimer) {
        CloseHandle(hTimer);
    }
    return (S_OK==hr);
}


//--------------------------------------------------------------------------
//
//  AEGetPendingRequestProperty
//
//--------------------------------------------------------------------------
BOOL    AEGetPendingRequestProperty(IEnroll4    *pIEnroll4, 
                                    DWORD       dwIndex, 
                                    DWORD       dwProp, 
                                    LPVOID      pProp)
{
    CRYPT_DATA_BLOB *pBlob=NULL;
    BOOL            fResult=FALSE;

    if((NULL==pIEnroll4) || (NULL==pProp))
        return FALSE;

    switch(dwProp)
    {
        case XEPR_REQUESTID:   
        case XEPR_DATE:           
        case XEPR_VERSION:
                fResult = (S_OK == pIEnroll4->enumPendingRequestWStr(dwIndex, dwProp, pProp));
            break;
            
            
        case XEPR_CANAME:                     
        case XEPR_CAFRIENDLYNAME: 
        case XEPR_CADNS:          
        case XEPR_V1TEMPLATENAME: 
        case XEPR_V2TEMPLATEOID:  
        case XEPR_HASH:
                
                pBlob=(CRYPT_DATA_BLOB *)pProp;

                pBlob->cbData=0;
                pBlob->pbData=NULL;

                if(S_OK != pIEnroll4->enumPendingRequestWStr(dwIndex, dwProp, pProp))
                    goto Ret;

                if(0 == pBlob->cbData)
                    goto Ret;

                pBlob->pbData=(BYTE *)LocalAlloc(LPTR, pBlob->cbData);
                if(NULL == pBlob->pbData)
                    goto Ret;

                fResult = (S_OK == pIEnroll4->enumPendingRequestWStr(dwIndex, dwProp, pProp));

            break;

        default:
            break;
    }

Ret:
    if(FALSE==fResult)
    {
        if(pBlob)
        {
            if(pBlob->pbData)
                LocalFree(pBlob->pbData);

            memset(pBlob, 0, sizeof(CRYPT_DATA_BLOB));
        }
    }

    return fResult;
}
//--------------------------------------------------------------------------
//
//  AERetrieveRequestProperty
//
//--------------------------------------------------------------------------
BOOL    AERetrieveRequestProperty(IEnroll4          *pIEnroll4, 
                                  DWORD             dwIndex, 
                                  DWORD             *pdwCount, 
                                  DWORD             *pdwMax, 
                                  CRYPT_DATA_BLOB   **prgblobHash)
{
    BOOL                fResult=FALSE;
    CRYPT_DATA_BLOB     *pblobHash=NULL;

    if((NULL==pIEnroll4) || (NULL==pdwCount) || (NULL==pdwMax) || (NULL==prgblobHash) ||
        (NULL==*prgblobHash))
        goto Ret;

    //need to alloc more memory
    if((*pdwCount) >= (*pdwMax))
    {
        pblobHash=*prgblobHash;

        *prgblobHash=(CRYPT_DATA_BLOB *)LocalAlloc(LPTR, 
                                    ((*pdwMax) + PENDING_ALLOC_SIZE) * sizeof(CRYPT_DATA_BLOB));
        if(NULL==(*prgblobHash))
        {
            *prgblobHash=pblobHash;
            pblobHash=NULL;
            goto Ret;
        }

        memset(*prgblobHash, 0, ((*pdwMax) + PENDING_ALLOC_SIZE) * sizeof(CRYPT_DATA_BLOB));

        //copy the old memmory
        memcpy(*prgblobHash, pblobHash, (*pdwMax) * sizeof(CRYPT_DATA_BLOB));

        *pdwMax=(*pdwMax) + PENDING_ALLOC_SIZE;
    }


    if(!AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_HASH, 
                                    &((*prgblobHash)[*pdwCount])))
        goto Ret;

    (*pdwCount)=(*pdwCount) + 1;

    fResult=TRUE;

Ret:

    if(pblobHash)
        LocalFree(pblobHash);

    return fResult;
}


//--------------------------------------------------------------------------
//
//  AERemovePendingRequest
//
//--------------------------------------------------------------------------
BOOL    AERemovePendingRequest(IEnroll4         *pIEnroll4, 
                               DWORD            dwCount, 
                               CRYPT_DATA_BLOB  *rgblobHash)
{
    DWORD   dwIndex=0;
    BOOL    fResult=TRUE;

    if((NULL==pIEnroll4) || (NULL==rgblobHash))
        return FALSE;

    for(dwIndex=0; dwIndex < dwCount; dwIndex++)
    {
        if(S_OK != (pIEnroll4->removePendingRequestWStr(rgblobHash[dwIndex])))
            fResult=FALSE;
    }

    return fResult;
}

//--------------------------------------------------------------------------
//
//  AEFreePendingRequests
//
//--------------------------------------------------------------------------
BOOL    AEFreePendingRequests(DWORD dwCount, CRYPT_DATA_BLOB    *rgblobHash)
{
    DWORD   dwIndex=0;

    if(rgblobHash)
    {
        for(dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            if(rgblobHash[dwIndex].pbData)
                LocalFree(rgblobHash[dwIndex].pbData);
        }

        LocalFree(rgblobHash);
    }

    return TRUE;
}


//--------------------------------------------------------------------------
//
//  AEValidVersionCert
//  
//      Verify the certificate returned from CA has the latest version info.
//  If so, copy the certificate to the hIssuedStore for potentical publishing
// 
//--------------------------------------------------------------------------
BOOL    AEValidVersionCert(AE_CERTTYPE_INFO *pCertType, IEnroll4  *pIEnroll4, CRYPT_DATA_BLOB  *pBlobPKCS7)
{
    BOOL                fValid=FALSE;   

    PCCERT_CONTEXT      pCertContext=NULL;
    AE_TEMPLATE_INFO    AETemplateInfo;

    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    if((NULL==pCertType) || (NULL==pIEnroll4) || (NULL==pBlobPKCS7))
        goto Ret;

    if(NULL==(pBlobPKCS7->pbData))
        goto Ret;

    if(S_OK != pIEnroll4->getCertContextFromResponseBlob(pBlobPKCS7, &pCertContext))
        goto Ret;

    if(!AERetrieveTemplateInfo(pCertContext, &AETemplateInfo))
        goto Ret;
                      

    if(AETemplateInfo.pwszOid)
    {
        if(AETemplateInfo.dwVersion >= (pCertType->dwVersion))
            fValid=TRUE;
    }
    else
    {
        //V1 template
        if(NULL == AETemplateInfo.pwszName)
            goto Ret;

        fValid=TRUE;
    }

    if(pCertContext && (TRUE == fValid))
    {
        CertAddCertificateContextToStore(pCertType->hIssuedStore, 
                                        pCertContext,
                                        CERT_STORE_ADD_USE_EXISTING,
                                        NULL);
    }

Ret:
    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    AEFreeTemplateInfo(&AETemplateInfo);

    return fValid;
}


//--------------------------------------------------------------------------
//
//  AECopyPendingBlob
//  
//      Copy the issued PKCS7 and request hash.
// 
//--------------------------------------------------------------------------
BOOL    AECopyPendingBlob(CRYPT_DATA_BLOB   *pBlobPKCS7,
                          IEnroll4          *pIEnroll4, 
                          DWORD             dwXenrollIndex, 
                          AE_CERTTYPE_INFO  *pCertType)
{
    BOOL            fResult=FALSE;
    DWORD           dwIndex=0;

    AE_PEND_INFO    *pPendInfo=NULL;

    if((NULL==pBlobPKCS7)||(NULL==pIEnroll4)||(NULL==pCertType))
        goto Ret;

    if(NULL==(pBlobPKCS7->pbData))
        goto Ret;

    dwIndex=pCertType->dwPendCount;

    //increase the memory array
    if(0 != dwIndex)
    {
        pPendInfo=pCertType->rgPendInfo;

        pCertType->rgPendInfo=(AE_PEND_INFO *)LocalAlloc(LPTR, 
                                    (dwIndex + 1) * sizeof(AE_PEND_INFO));

        if(NULL==(pCertType->rgPendInfo))
        {
            pCertType->rgPendInfo=pPendInfo;
            pPendInfo=NULL;
            goto Ret;
        }

        memset(pCertType->rgPendInfo, 0, (dwIndex + 1) * sizeof(AE_PEND_INFO));

        //copy the old memmory
        memcpy(pCertType->rgPendInfo, pPendInfo, (dwIndex) * sizeof(AE_PEND_INFO));
    }
    else
    {
        pCertType->rgPendInfo=(AE_PEND_INFO *)LocalAlloc(LPTR, sizeof(AE_PEND_INFO));

        if(NULL==(pCertType->rgPendInfo))
            goto Ret;

        memset(pCertType->rgPendInfo, 0, sizeof(AE_PEND_INFO));
    }

    
    //copy the issued PKCS7 blob
    (pCertType->rgPendInfo)[dwIndex].blobPKCS7.pbData=(BYTE *)LocalAlloc(
                                            LPTR,
                                            pBlobPKCS7->cbData);

    if(NULL == ((pCertType->rgPendInfo)[dwIndex].blobPKCS7.pbData))
        goto Ret;
                  
    memcpy((pCertType->rgPendInfo)[dwIndex].blobPKCS7.pbData,
            pBlobPKCS7->pbData,
            pBlobPKCS7->cbData);

    (pCertType->rgPendInfo)[dwIndex].blobPKCS7.cbData=pBlobPKCS7->cbData;

    //copy the hash of the request
    if(!AEGetPendingRequestProperty(pIEnroll4, dwXenrollIndex, XEPR_HASH, 
                                    &((pCertType->rgPendInfo)[dwIndex].blobHash)))
    {
        LocalFree((pCertType->rgPendInfo)[dwIndex].blobPKCS7.pbData);
        (pCertType->rgPendInfo)[dwIndex].blobPKCS7.pbData=NULL;
        (pCertType->rgPendInfo)[dwIndex].blobPKCS7.cbData=0;
        goto Ret;
    }

    (pCertType->dwPendCount)++;

    fResult=TRUE;

Ret:
    if(pPendInfo)
        LocalFree(pPendInfo);

    return fResult;
}
//--------------------------------------------------------------------------
//
//  AEProcessUIPendingRequest
//  
//      In this function, we install the issued pending certificate request
//  that will require UI.
// 
//--------------------------------------------------------------------------
BOOL WINAPI AEProcessUIPendingRequest(AE_GENERAL_INFO *pAE_General_Info)
{
    DWORD                   dwIndex=0;
    DWORD                   dwPendIndex=0;
    AE_CERTTYPE_INFO        *pCertTypeInfo=pAE_General_Info->rgCertTypeInfo;
    AE_CERTTYPE_INFO        *pCertType=NULL;
    BOOL                    fInit=FALSE;
    PFNPIEnroll4GetNoCOM    pfnPIEnroll4GetNoCOM=NULL;
    HMODULE                 hXenroll=NULL;
    HRESULT                 hr=E_FAIL;

    IEnroll4                *pIEnroll4=NULL;

    if(NULL==pAE_General_Info)
        goto Ret;

    //has to be in the UI mode
    if(FALSE == pAE_General_Info->fUIProcess)
        goto Ret;

    if(NULL==pCertTypeInfo)
        goto Ret;

    hXenroll=pAE_General_Info->hXenroll;

    if(NULL==hXenroll)
        goto Ret;

    if(NULL==(pfnPIEnroll4GetNoCOM=(PFNPIEnroll4GetNoCOM)GetProcAddress(
                        hXenroll,
                        "PIEnroll4GetNoCOM")))
        goto Ret;


    if(FAILED(CoInitialize(NULL)))
	    goto Ret;

    fInit=TRUE;

    if(NULL==(pIEnroll4=pfnPIEnroll4GetNoCOM()))
        goto Ret;

    //Set the request store flag based on fMachine
    if(pAE_General_Info->fMachine)
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE))
            goto Ret;
    }
    else
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_CURRENT_USER))
            goto Ret;
    }

    //initialize the enumerator
    if(S_OK != pIEnroll4->enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL))
        goto Ret;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        pCertType = &(pCertTypeInfo[dwIndex]);

        if(pCertType->dwPendCount)
        {
            for(dwPendIndex=0; dwPendIndex < pCertType->dwPendCount; dwPendIndex++)
            {
                //check if cancel button is clicked
                if(AECancelled(pAE_General_Info->hCancelEvent))
                    break;

                //report the current enrollment action
                AEUIProgressReport(TRUE, pCertType, pAE_General_Info->hwndDlg, pAE_General_Info->hCancelEvent);

   		        //install the certificate
                if(S_OK == (hr = pIEnroll4->acceptResponseBlob(
                    &((pCertType->rgPendInfo)[dwPendIndex].blobPKCS7))))
                {
                    //mark the status to obtained if required
                    //this is a valid certificate
                    if(AEValidVersionCert(pCertType, pIEnroll4, &((pCertType->rgPendInfo)[dwPendIndex].blobPKCS7)))
                        pCertType->dwStatus = CERT_REQUEST_STATUS_OBTAINED;

                    //the certificate is successfully issued and installed
                    //remove the request from the request store
                    pIEnroll4->removePendingRequestWStr((pCertType->rgPendInfo)[dwPendIndex].blobHash);

                    AELogAutoEnrollmentEvent(
                        pAE_General_Info->dwLogLevel,
                        FALSE, 
                        S_OK, 
                        EVENT_PENDING_INSTALLED, 
                        pAE_General_Info->fMachine, 
                        pAE_General_Info->hToken, 
                        1,
                        pCertType->awszDisplay[0]);

                }
                else
                {
                    //doing this for summary page
                    if((SCARD_E_CANCELLED != hr) && (SCARD_W_CANCELLED_BY_USER != hr))
                        pCertType->idsSummary=IDS_SUMMARY_INSTALL;

                    AELogAutoEnrollmentEvent(
                        pAE_General_Info->dwLogLevel,
                        TRUE, 
                        hr, 
                        EVENT_PENDING_FAILED, 
                        pAE_General_Info->fMachine, 
                        pAE_General_Info->hToken, 
                        1,
                        pCertType->awszDisplay[0]);
                }

                //advance progress
                AEUIProgressAdvance(pAE_General_Info);
            }
        }
    }

Ret:
    if(pIEnroll4)
        pIEnroll4->Release();

    if(fInit)
        CoUninitialize();
    
    return TRUE;
}   
   

//--------------------------------------------------------------------------
//
//  AEProcessPendingRequest -- UIless call.
//  
//      In this function, we check each pending requests in the request store.
//  We install the certificate is the request has been issued by the CA, and 
//  mark the certificate type status to obtained if the certificate is issued
//  and of correct version
//
//      We remove any requests that are stale based on the # of days defined
//  in the registry.  If no value is defined in the registry, use 
//  AE_PENDING_REQUEST_ACTIVE_PERIOD (60 days).
//
//      Also, if there is no more pending requests active in the request store,
//  we set the registry value to indicate that winlogon should not wake us up.
// 
//--------------------------------------------------------------------------
BOOL WINAPI AEProcessPendingRequest(AE_GENERAL_INFO *pAE_General_Info)
{
    DWORD                   dwRequestID=0;
    LONG                    dwDisposition=0;
    DWORD                   dwIndex=0;
    DWORD                   dwCount=0;
    DWORD                   dwMax=PENDING_ALLOC_SIZE;
    AE_CERTTYPE_INFO        *pCertType=NULL;
    PFNPIEnroll4GetNoCOM    pfnPIEnroll4GetNoCOM=NULL;
    BOOL                    fInit=FALSE;
    AE_TEMPLATE_INFO        AETemplateInfo;
    CRYPT_DATA_BLOB         blobPKCS7;
    HMODULE                 hXenroll=NULL;
    VARIANT                 varCMC; 
	HRESULT					hr=E_FAIL;
  

    IEnroll4                *pIEnroll4=NULL;
    ICertRequest2           *pICertRequest=NULL;
	BSTR	                bstrCert=NULL;
    LPWSTR                  pwszCAConfig=NULL;
    BSTR                    bstrConfig=NULL;
    CRYPT_DATA_BLOB         *rgblobHash=NULL;
    CRYPT_DATA_BLOB         blobCAName;
    CRYPT_DATA_BLOB         blobCALocation;
    CRYPT_DATA_BLOB         blobName;


    if(NULL==pAE_General_Info)
        goto Ret;

    //init the dwUIPendCount to 0
    pAE_General_Info->dwUIPendCount=0;

    //has to be in the UIless mode
    if(TRUE == pAE_General_Info->fUIProcess)
        goto Ret;

    hXenroll=pAE_General_Info->hXenroll;

    if(NULL==hXenroll)
        goto Ret;

    if(NULL==(pfnPIEnroll4GetNoCOM=(PFNPIEnroll4GetNoCOM)GetProcAddress(
                        hXenroll,
                        "PIEnroll4GetNoCOM")))
        goto Ret;


    if(FAILED(CoInitialize(NULL)))
	    goto Ret;

    fInit=TRUE;

    if(NULL==(pIEnroll4=pfnPIEnroll4GetNoCOM()))
        goto Ret;


	if(S_OK != CoCreateInstance(CLSID_CCertRequest,
									NULL,
									CLSCTX_INPROC_SERVER,
									IID_ICertRequest2,
									(void **)&pICertRequest))
		goto Ret;

    //Set the request store flag based on fMachine
    if(pAE_General_Info->fMachine)
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE))
            goto Ret;
    }
    else
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_CURRENT_USER))
            goto Ret;
    }

    memset(&blobCAName, 0, sizeof(blobCAName));
    memset(&blobCALocation, 0, sizeof(blobCALocation));
    memset(&blobName, 0, sizeof(blobName));
    memset(&AETemplateInfo, 0, sizeof(AETemplateInfo));

    rgblobHash=(CRYPT_DATA_BLOB *)LocalAlloc(LPTR, dwMax * sizeof(CRYPT_DATA_BLOB));
    if(NULL==rgblobHash)
        goto Ret;

    memset(rgblobHash, 0, dwMax * sizeof(CRYPT_DATA_BLOB));

    //initialize the enumerator
    if(S_OK != pIEnroll4->enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL))
        goto Ret;

    //initlialize the variant
    VariantInit(&varCMC); 

    while(AEGetPendingRequestProperty(
                    pIEnroll4,
                    dwIndex,
                    XEPR_REQUESTID,
                    &dwRequestID))
    {

        //query the status of the requests to the CA
        if(!AEGetPendingRequestProperty(
                    pIEnroll4,
                    dwIndex,
                    XEPR_CANAME,
                    &blobCAName))
            goto Next;

        if(!AEGetPendingRequestProperty(
                    pIEnroll4,
                    dwIndex,
                    XEPR_CADNS,
                    &blobCALocation))
            goto Next;

        //build the config string
        pwszCAConfig=(LPWSTR)LocalAlloc(LPTR, 
            sizeof(WCHAR) * (wcslen((LPWSTR)(blobCALocation.pbData)) + wcslen((LPWSTR)(blobCAName.pbData)) + wcslen(L"\\") + 1));

        if(NULL==pwszCAConfig)
            goto Next;

        wcscpy(pwszCAConfig, (LPWSTR)(blobCALocation.pbData));
        wcscat(pwszCAConfig, L"\\");
        wcscat(pwszCAConfig, (LPWSTR)(blobCAName.pbData));

        //conver to bstr
        bstrConfig=SysAllocString(pwszCAConfig);
        if(NULL==bstrConfig)
            goto Next;

        //find the template information
        //get the version and the template name of the request
        if(AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_V2TEMPLATEOID, &blobName))
        {
            AETemplateInfo.pwszOid=(LPWSTR)blobName.pbData;
        }
        else
        {
            if(!AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_V1TEMPLATENAME, &blobName))
                goto Next;

            AETemplateInfo.pwszName=(LPWSTR)blobName.pbData;
        }

        //find the template
        if(NULL==(pCertType=AEFindTemplateInRequestTree(
                        &AETemplateInfo, pAE_General_Info)))
            goto Next;


        if(S_OK != pICertRequest->RetrievePending(
                            dwRequestID,
							bstrConfig,
							&dwDisposition))
            goto Next;

 	    switch(dwDisposition)
	    {
		    case CR_DISP_ISSUED:
				    if(S_OK != pICertRequest->GetFullResponseProperty(
                                            FR_PROP_FULLRESPONSE, 0, PROPTYPE_BINARY, CR_OUT_BINARY,
										    &varCMC))
                    {
                        goto Next;
                    }

                    // Check to make sure we've gotten a BSTR back: 
                    if (VT_BSTR != varCMC.vt) 
                    {
	                    goto Next; 
                    }

                    bstrCert = varCMC.bstrVal; 

                    // Marshal the cert into a CRYPT_DATA_BLOB:
				    blobPKCS7.cbData = (DWORD)SysStringByteLen(bstrCert);
				    blobPKCS7.pbData = (BYTE *)bstrCert;

                    // we will keep the PKCS7 blob for installation
                    if(CT_FLAG_USER_INTERACTION_REQUIRED & (pCertType->dwEnrollmentFlag))
                    {
                        //signal that we should pop up the UI balloon
                        (pAE_General_Info->dwUIPendCount)++;

                        //copy the PKCS7 blob from the cert server
                        AECopyPendingBlob(&blobPKCS7,
                                            pIEnroll4, 
                                            dwIndex, 
                                            pCertType);
                    }
                    else
                    {
   				        //install the certificate
                        if(S_OK != (hr = pIEnroll4->acceptResponseBlob(&blobPKCS7)))
						{
							AELogAutoEnrollmentEvent(
								pAE_General_Info->dwLogLevel,
								TRUE, 
								hr, 
								EVENT_PENDING_FAILED, 
								pAE_General_Info->fMachine, 
								pAE_General_Info->hToken, 
								1,
								pCertType->awszDisplay[0]);

                            goto Next;
						}

                        //mark the status to obtained if required
                        //this is a valid certificate
                        if(AEValidVersionCert(pCertType, pIEnroll4, &blobPKCS7))
                            pCertType->dwStatus = CERT_REQUEST_STATUS_OBTAINED;

                        //the certificate is successfully issued and installed
                        //remove the request from the request store
                        AERetrieveRequestProperty(pIEnroll4, dwIndex, &dwCount, &dwMax, &rgblobHash);
                    }

                    AELogAutoEnrollmentEvent(
                        pAE_General_Info->dwLogLevel,
                        FALSE, 
                        S_OK, 
                        EVENT_PENDING_ISSUED, 
                        pAE_General_Info->fMachine, 
                        pAE_General_Info->hToken, 
                        2,
                        pCertType->awszDisplay[0],
                        pwszCAConfig);
			    break;

		    case CR_DISP_UNDER_SUBMISSION:

                    AELogAutoEnrollmentEvent(
                        pAE_General_Info->dwLogLevel,
                        FALSE, 
                        S_OK, 
                        EVENT_PENDING_PEND, 
                        pAE_General_Info->fMachine, 
                        pAE_General_Info->hToken, 
                        2,
                        pCertType->awszDisplay[0],
                        pwszCAConfig);


			    break;

		    case CR_DISP_INCOMPLETE:
		    case CR_DISP_ERROR:   
		    case CR_DISP_DENIED:   
		    case CR_DISP_ISSUED_OUT_OF_BAND:	  //we consider it a failure in this case
		    case CR_DISP_REVOKED:
		    default:
                    //requests failed.  remove the request from the request store
                    AERetrieveRequestProperty(pIEnroll4, dwIndex, &dwCount, &dwMax, &rgblobHash);

					if(S_OK == pICertRequest->GetLastStatus(&hr))
					{
						AELogAutoEnrollmentEvent(
							pAE_General_Info->dwLogLevel,
							TRUE, 
							hr, 
							EVENT_PENDING_DENIED, 
							pAE_General_Info->fMachine, 
							pAE_General_Info->hToken,
							2,
							pwszCAConfig,
							pCertType->awszDisplay[0]);
					}

			    break;
	    }
   
Next:
        if(pwszCAConfig)
            LocalFree(pwszCAConfig);
        pwszCAConfig=NULL;

        if(bstrConfig)
            SysFreeString(bstrConfig);
        bstrConfig=NULL;

	    if(bstrCert)
		    SysFreeString(bstrCert);
        bstrCert=NULL;

        if(blobCAName.pbData)
            LocalFree(blobCAName.pbData);
        memset(&blobCAName, 0, sizeof(blobCAName));

        if(blobCALocation.pbData)
            LocalFree(blobCALocation.pbData);
        memset(&blobCALocation, 0, sizeof(blobCALocation));

        if(blobName.pbData)
            LocalFree(blobName.pbData);
        memset(&blobName, 0, sizeof(blobName));

        memset(&AETemplateInfo, 0, sizeof(AETemplateInfo));

        VariantInit(&varCMC); 

        dwIndex++;
    }

    //remove the requests based the hash
    AERemovePendingRequest(pIEnroll4, dwCount, rgblobHash);

Ret:

    AEFreePendingRequests(dwCount, rgblobHash);

    if(pICertRequest)
        pICertRequest->Release();

    if(pIEnroll4)
        pIEnroll4->Release();

    if(fInit)
        CoUninitialize();
    
    return TRUE;
}
   
//--------------------------------------------------------------------------
//
//  AEIsLocalSystem
//
//--------------------------------------------------------------------------

BOOL
AEIsLocalSystem(BOOL *pfIsLocalSystem)
{
    HANDLE                      hToken = 0;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL                        fRet = FALSE;
    BOOL                        fRevertToSelf = FALSE;

    PSID                        psidLocalSystem = NULL;

    *pfIsLocalSystem = FALSE;

    if (!OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,
                 &hToken))
    {
        if (ERROR_NO_TOKEN != GetLastError())
            goto Ret;

        //we need to impersonateself and get the thread token again
        if(!ImpersonateSelf(SecurityImpersonation))
            goto Ret;

        fRevertToSelf = TRUE;

        if (!OpenThreadToken(
                     GetCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,
                     &hToken))
            goto Ret;
    }

    //build the well known local system SID (s-1-5-18)
    if (!AllocateAndInitializeSid(
                    &siaNtAuthority,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &psidLocalSystem
                    ))
        goto Ret;

    fRet = CheckTokenMembership(
                    hToken,
                    psidLocalSystem,
                    pfIsLocalSystem);

Ret:

    if(fRevertToSelf)
        RevertToSelf();

    if(psidLocalSystem)
        FreeSid(psidLocalSystem);

    if (hToken)
        CloseHandle(hToken);

    return fRet;
}


//--------------------------------------------------------------------------
//
//  AEInSafeBoot
//
//  copied from the service controller code
//--------------------------------------------------------------------------
BOOL WINAPI AEInSafeBoot()
{
    DWORD   dwSafeBoot = 0;
    DWORD   cbSafeBoot = sizeof(dwSafeBoot);
    DWORD   dwType = 0;

    HKEY    hKeySafeBoot = NULL;

    if(ERROR_SUCCESS == RegOpenKeyW(
                              HKEY_LOCAL_MACHINE,
                              L"system\\currentcontrolset\\control\\safeboot\\option",
                              &hKeySafeBoot))
    {
        // we did in fact boot under safeboot control
        if(ERROR_SUCCESS != RegQueryValueExW(
                                    hKeySafeBoot,
                                    L"OptionValue",
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwSafeBoot,
                                    &cbSafeBoot))
        {
            dwSafeBoot = 0;
        }

        if(hKeySafeBoot)
            RegCloseKey(hKeySafeBoot);
    }

    return (0 != dwSafeBoot);
}


//--------------------------------------------------------------------------
//
//  AEIsDomainMember
//
//--------------------------------------------------------------------------
BOOL WINAPI AEIsDomainMember()
{
    DWORD dwErr;
    BOOL bIsDomainMember=FALSE;

    // must be cleaned up
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC * pDomInfo=NULL;

    dwErr=DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (BYTE **)&pDomInfo);
    if (ERROR_SUCCESS==dwErr) 
	{
        if (DsRole_RoleStandaloneWorkstation!=pDomInfo->MachineRole 
            && DsRole_RoleStandaloneServer!=pDomInfo->MachineRole) 
		{
			//no autoenrollment on NT4
			if(NULL != (pDomInfo->DomainNameDns)) 
			{
				bIsDomainMember=TRUE;
			}
        }
    }

    if (NULL!=pDomInfo) 
	{
        DsRoleFreeMemory(pDomInfo);
    }

    return bIsDomainMember;
}


//-----------------------------------------------------------------------
//
//  AEGetPolicyFlag
//
//-----------------------------------------------------------------------
BOOL    AEGetPolicyFlag(BOOL   fMachine, DWORD  *pdwPolicy)
{
    DWORD   dwPolicy = 0;
    DWORD   cbPolicy = sizeof(dwPolicy);
    DWORD   dwType = 0;

    HKEY    hKey = NULL;

    if(ERROR_SUCCESS ==  RegOpenKeyW(
                                fMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                                AUTO_ENROLLMENT_KEY,
                                &hKey))
    {
        if(ERROR_SUCCESS != RegQueryValueExW(
                                    hKey,
                                    AUTO_ENROLLMENT_POLICY,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwPolicy,
                                    &cbPolicy))
	    {
            dwPolicy = 0;
        }
		else
		{
			if(REG_DWORD != dwType)
				dwPolicy=0;
		}

        if(hKey)
            RegCloseKey(hKey);

    }

    *pdwPolicy=dwPolicy;

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AERetrieveLogLevel
//
//-----------------------------------------------------------------------
BOOL AERetrieveLogLevel(BOOL    fMachine, DWORD *pdwLogLevel)
{
    DWORD   dwLogLevel = STATUS_SEVERITY_ERROR;   //we default to highest logging level
    DWORD   cbLogLevel = sizeof(dwLogLevel);
    DWORD   dwType = 0;

    HKEY    hKey = NULL;

    if(ERROR_SUCCESS ==  RegOpenKeyW(
                                fMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                                AUTO_ENROLLMENT_EVENT_LEVEL_KEY,
                                &hKey))
    {
        if(ERROR_SUCCESS != RegQueryValueExW(
                                    hKey,
                                    AUTO_ENROLLMENT_EVENT_LEVEL,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwLogLevel,
                                    &cbLogLevel))
	    {
            dwLogLevel = STATUS_SEVERITY_ERROR;
        }
		else
		{
			if(REG_DWORD != dwType)
				dwLogLevel = STATUS_SEVERITY_ERROR;
		}

        if(hKey)
            RegCloseKey(hKey);

    }

    *pdwLogLevel=dwLogLevel;

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AERetrieveTemplateInfo
//
//-----------------------------------------------------------------------
BOOL    AERetrieveTemplateInfo(PCCERT_CONTEXT           pCertCurrent, 
                                AE_TEMPLATE_INFO        *pTemplateInfo)
{
    BOOL                fResult = FALSE;
    PCERT_EXTENSION     pExt = NULL;
    DWORD               cbData=0;

    CERT_NAME_VALUE     *pbName = NULL;
    CERT_TEMPLATE_EXT   *pbTemplate = NULL;

    if((NULL==pCertCurrent) || (NULL==pTemplateInfo))
        goto Ret;

    memset(pTemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    //try to find V2 template extension first
    if(pExt = CertFindExtension(szOID_CERTIFICATE_TEMPLATE,
                                pCertCurrent->pCertInfo->cExtension,
                                pCertCurrent->pCertInfo->rgExtension))
    {
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_CERTIFICATE_TEMPLATE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              NULL,
                              &cbData))
            goto Ret;

        pbTemplate = (CERT_TEMPLATE_EXT *)LocalAlloc(LPTR, cbData);

        if(NULL==pbTemplate)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_CERTIFICATE_TEMPLATE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbTemplate,
                              &cbData))
            goto Ret;

        //copy the version
        pTemplateInfo->dwVersion=pbTemplate->dwMajorVersion;

        //copy the extension oid
        if(NULL==pbTemplate->pszObjId)
            goto Ret;

        if(0 == (cbData = MultiByteToWideChar(CP_ACP, 
                                  0,
                                  pbTemplate->pszObjId,
                                  -1,
                                  NULL,
                                  0)))
            goto Ret;

        if(NULL==(pTemplateInfo->pwszOid=(LPWSTR)LocalAlloc(LPTR, cbData * sizeof(WCHAR))))
            goto Ret;

        if(0 == MultiByteToWideChar(CP_ACP, 
                                  0,
                                  pbTemplate->pszObjId,
                                  -1,
                                  pTemplateInfo->pwszOid,
                                  cbData))
            goto Ret;

    }
    else
    {

        //try V1 template extension
        if(NULL == (pExt = CertFindExtension(
                                    szOID_ENROLL_CERTTYPE_EXTENSION,
                                    pCertCurrent->pCertInfo->cExtension,
                                    pCertCurrent->pCertInfo->rgExtension)))
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              X509_UNICODE_ANY_STRING,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              NULL,
                              &cbData))
            goto Ret;

        pbName = (CERT_NAME_VALUE *)LocalAlloc(LPTR, cbData);

        if(NULL==pbName)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              X509_UNICODE_ANY_STRING,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbName,
                              &cbData))
            goto Ret;

        if(!AEAllocAndCopy((LPWSTR)(pbName->Value.pbData),
                            &(pTemplateInfo->pwszName)))
            goto Ret;
    }


    fResult = TRUE;

Ret:

    if(pbTemplate)
        LocalFree(pbTemplate);

    if(pbName)
        LocalFree(pbName);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AEFreeTemplateInfo
//
//-----------------------------------------------------------------------
BOOL    AEFreeTemplateInfo(AE_TEMPLATE_INFO *pAETemplateInfo)
{
    if(pAETemplateInfo->pwszName)
        LocalFree(pAETemplateInfo->pwszName);

    if(pAETemplateInfo->pwszOid)
        LocalFree(pAETemplateInfo->pwszOid);

    memset(pAETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AEFindTemplateInRequestTree
//
//-----------------------------------------------------------------------
AE_CERTTYPE_INFO *AEFindTemplateInRequestTree(AE_TEMPLATE_INFO  *pTemplateInfo,
                                              AE_GENERAL_INFO   *pAE_General_Info)
{
    DWORD               dwIndex = 0;
    AE_CERTTYPE_INFO    *rgCertTypeInfo=NULL;
    AE_CERTTYPE_INFO    *pCertType=NULL;
    
    if(NULL == (rgCertTypeInfo=pAE_General_Info->rgCertTypeInfo))
        return NULL;

    if( (NULL == pTemplateInfo->pwszName) && (NULL == pTemplateInfo->pwszOid))
        return NULL;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if(pTemplateInfo->pwszOid)
        {
            //we are guaranteed to have an OID if the schema is greater than or equal to 2
            if(rgCertTypeInfo[dwIndex].dwSchemaVersion >= CERTTYPE_SCHEMA_VERSION_2)
            {
                if(0 == wcscmp(pTemplateInfo->pwszOid, (rgCertTypeInfo[dwIndex].awszOID)[0]))
                {
                    pCertType = &(rgCertTypeInfo[dwIndex]);
                    break;
                }
            }
        }
        else
        {
            //we are guaranteed to have a name
            if(0 == wcscmp(pTemplateInfo->pwszName, (rgCertTypeInfo[dwIndex].awszName)[0]))
            {
                pCertType = &(rgCertTypeInfo[dwIndex]);
                break;
            }
        }
    }

    return pCertType;
}

//-----------------------------------------------------------------------
//
//	AEGetDNSNameFromCertificate
//
//-----------------------------------------------------------------------
BOOL	AEGetDNSNameFromCertificate(PCCERT_CONTEXT	pCertContext,
									LPWSTR			*ppwszDnsName)
{
	BOOL					fResult=FALSE;
    PCERT_EXTENSION			pExt=NULL;
    DWORD					cbData=0;
    DWORD					iAltName=0;
	DWORD					dwSize=0;

    PCERT_ALT_NAME_INFO		pAltName=NULL;

	if((NULL==pCertContext) || (NULL==ppwszDnsName))
		goto Ret;

	*ppwszDnsName=NULL;

    if(NULL == (pExt = CertFindExtension(szOID_SUBJECT_ALT_NAME2,
                                pCertContext->pCertInfo->cExtension,
                                pCertContext->pCertInfo->rgExtension)))
		goto Ret;

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szOID_SUBJECT_ALT_NAME2,
                          pExt->Value.pbData,
                          pExt->Value.cbData,
                          0,
                          NULL,
                          &cbData))
		goto Ret;

	pAltName=(PCERT_ALT_NAME_INFO)LocalAlloc(LPTR, cbData);
	if(NULL == pAltName)
		goto Ret;

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szOID_SUBJECT_ALT_NAME2,
                          pExt->Value.pbData,
                          pExt->Value.cbData,
                          0,
                          pAltName,
                          &cbData))
		goto Ret;

	//compare the data in the certificate with what is returned from GetComputerNameEx
    for(iAltName=0; iAltName < pAltName->cAltEntry; iAltName++)
    {
        if(CERT_ALT_NAME_DNS_NAME == ((pAltName->rgAltEntry)[iAltName].dwAltNameChoice))
        {
			if(pAltName->rgAltEntry[iAltName].pwszDNSName)
			{
				dwSize=wcslen(pAltName->rgAltEntry[iAltName].pwszDNSName);

				if(0 == dwSize)
					goto Ret;
			
				*ppwszDnsName=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (dwSize + 1));
				if(NULL == (*ppwszDnsName))
					goto Ret;

				wcscpy(*ppwszDnsName, pAltName->rgAltEntry[iAltName].pwszDNSName);

				fResult=TRUE;

				break;
			}
		}
	}

Ret:

	if(pAltName)
		LocalFree(pAltName);

	return fResult;
}

//-----------------------------------------------------------------------
//
//	AEIsSameDNS
//
//-----------------------------------------------------------------------
BOOL	AEIsSameDNS(PCCERT_CONTEXT	pFirstCert, PCCERT_CONTEXT pSecondCert)
{
	BOOL		fSame=FALSE;

	LPWSTR		pwszFirst=NULL;
	LPWSTR		pwszSecond=NULL;

	AEGetDNSNameFromCertificate(pFirstCert, &pwszFirst);

	AEGetDNSNameFromCertificate(pSecondCert, &pwszSecond);

	if(NULL == pwszFirst)
	{
		if(NULL == pwszSecond)
		{
			fSame=TRUE;
		}
	}
	else
	{
		if(NULL != pwszSecond)
		{
			if(0 == _wcsicmp(pwszFirst, pwszSecond))
			{
				fSame=TRUE;
			}
		}
	}

	if(pwszFirst)
		LocalFree(pwszFirst);

	if(pwszSecond)
		LocalFree(pwszSecond);

	return fSame;
}


//-----------------------------------------------------------------------
//
//	AEGetRetryProperty
//
//-----------------------------------------------------------------------
BOOL	AEGetRetryProperty(PCCERT_CONTEXT	pCertContext,
						   AE_RETRY_INFO	**ppAE_Retry_Info)
{
	BOOL					fResult=FALSE;
    DWORD					cbData=0;

	AE_RETRY_INFO			*pRetry_Info=NULL;

	if((NULL==pCertContext) || (NULL==ppAE_Retry_Info))
		goto Ret;

	*ppAE_Retry_Info=NULL;

	if(!CertGetCertificateContextProperty(
			pCertContext, 
			CERT_AUTO_ENROLL_RETRY_PROP_ID,
			NULL,
			&cbData))
		goto Ret;

	pRetry_Info=(AE_RETRY_INFO *)LocalAlloc(LPTR, cbData);
	if(NULL == pRetry_Info)
		goto Ret;

	if(!CertGetCertificateContextProperty(
			pCertContext, 
			CERT_AUTO_ENROLL_RETRY_PROP_ID,
			pRetry_Info,
			&cbData))
		goto Ret;

	//verify the integrity of the property on the certificate
	if(cbData < sizeof(AE_RETRY_INFO))
		goto Ret;

	if((pRetry_Info->cbSize) < sizeof(AE_RETRY_INFO))
		goto Ret;

	*ppAE_Retry_Info=pRetry_Info;
	pRetry_Info=NULL;

	fResult=TRUE;

Ret:

	if(pRetry_Info)
		LocalFree(pRetry_Info);

	return fResult;
}

//-----------------------------------------------------------------------
//
//	AEFasterRetrialSchedule
//
//		Determine if the 1st certificate context has a faster retrial schedule
//	than the second certifcate based on the CERT_AUTO_ENROLL_RETRY_PROP_ID property
//
//-----------------------------------------------------------------------
BOOL	AEFasterRetrialSchedule(PCCERT_CONTEXT	pFirstContext, 
								PCCERT_CONTEXT	pSecondContext)
{
	BOOL				fFaster=FALSE;

	AE_RETRY_INFO		*pFirst_Retry=NULL;
	AE_RETRY_INFO		*pSecond_Retry=NULL;

	//if the property does not exist, it is always the immediate retrial
	if(!AEGetRetryProperty(pFirstContext, &pFirst_Retry))
	{
		fFaster=TRUE;
		goto Ret;
	}

	//if the property exists on the 1st certificate, but not on the
	//second certificate, the second is always faster
	if(!AEGetRetryProperty(pSecondContext, &pSecond_Retry))
	{
		fFaster=FALSE;
		goto Ret;
	}

	//now both has the property
	//if the second has exceeded the limit, the first is always faster
	if(AE_RETRY_LIMIT < pSecond_Retry->dwRetry)
	{
		fFaster=TRUE;
		goto Ret;
	}

	//the second has not exceeded the limit, while the first has exceeded the limit;
	//the second is faster
	if(AE_RETRY_LIMIT < pFirst_Retry->dwRetry)
	{
		fFaster=FALSE;
		goto Ret;
	}

	//neither has exceeded the limit
	if(pFirst_Retry->dwRetry <= pSecond_Retry->dwRetry)
	{
		fFaster=TRUE;
	}
	else
	{
		fFaster=FALSE;
	}

Ret:

	if(pFirst_Retry)
		LocalFree(pFirst_Retry);

	if(pSecond_Retry)
		LocalFree(pSecond_Retry);

	return fFaster;
}

//-----------------------------------------------------------------------
//
//	AEUpdateRetryProperty
//
//		The newly aquired certificate has the same DNS name of the old
//	certificate, and the DNS Name is not the same as the local machine.
//
//		Update the CERT_AUTO_ENROLL_RETRY_PROP_ID property
//
//-----------------------------------------------------------------------
BOOL	AEUpdateRetryProperty(AE_GENERAL_INFO	*pAE_General_Info, 
							  LPWSTR			pwszTemplateDisplay,
							  PCCERT_CONTEXT	pNewContext, 
							  PCCERT_CONTEXT	pOldContext)
{
	BOOL				fResult=FALSE;
    ULARGE_INTEGER		ftTime;
	ULONG				lSecond=0;
	CRYPT_DATA_BLOB		blobProp;
	WCHAR			wsz[SHA1_HASH_LENGTH];

	AE_RETRY_INFO		*pAE_Retry_Info=NULL;

	if((NULL == pAE_General_Info) || (NULL == pNewContext) || (NULL == pOldContext))
		goto Ret;

	if(!AEGetRetryProperty(pOldContext, &pAE_Retry_Info))
	{
		//make up a default one
		pAE_Retry_Info=(AE_RETRY_INFO *)LocalAlloc(LPTR, sizeof(AE_RETRY_INFO));
		if(NULL == pAE_Retry_Info)
			goto Ret;

		memset(pAE_Retry_Info, 0, sizeof(AE_RETRY_INFO));

		pAE_Retry_Info->cbSize=sizeof(AE_RETRY_INFO);
		pAE_Retry_Info->dwRetry=0;	//first attempt
	}


	//increment the count and set the next update date
	if(pAE_Retry_Info->dwRetry <= AE_RETRY_LIMIT)
	{
		(pAE_Retry_Info->dwRetry)++;

		//get the current time
		GetSystemTimeAsFileTime((LPFILETIME)&ftTime);

		// Convert 24 hours to seconds 
		lSecond=(pAE_Retry_Info->dwRetry)*24*60*60;

		//lSecond=(pAE_Retry_Info->dwRetry)*2*60;

    		ftTime.QuadPart += UInt32x32To64(FILETIME_TICKS_PER_SECOND, lSecond);
		(pAE_Retry_Info->dueTime).QuadPart = ftTime.QuadPart;
	}

	//copy the property on the certificate
	memset(&blobProp, 0, sizeof(CRYPT_DATA_BLOB));

	blobProp.cbData=sizeof(AE_RETRY_INFO);
	blobProp.pbData=(BYTE *)pAE_Retry_Info;

	if(!CertSetCertificateContextProperty(
		  pNewContext, 
		  CERT_AUTO_ENROLL_RETRY_PROP_ID, 
		  0, 
		  &blobProp))
	  goto Ret;

	//log the event
	if(pAE_Retry_Info->dwRetry <= AE_RETRY_LIMIT)
	{

            _itow(((pAE_Retry_Info->dwRetry) * 24), wsz, 10);
        AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_MISMATCH_DNS_RETRY,                              
                 pAE_General_Info->fMachine, pAE_General_Info->hToken, 2, pwszTemplateDisplay, wsz);
	}
	else
	{
            _itow(AE_RETRY_LIMIT, wsz, 10);
        AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_MISMATCH_DNS,                              
                 pAE_General_Info->fMachine, pAE_General_Info->hToken, 2, pwszTemplateDisplay, wsz);
	}

										 
	fResult=TRUE;

Ret:

	if(pAE_Retry_Info)
		LocalFree(pAE_Retry_Info);
		
	return fResult;
}


//-----------------------------------------------------------------------
//
//  AEVerifyDNSName
//
//		Verify the DNS name in the certificate match what is returned
//	from GetComputerNameEx, either ComputerNameDnsFullyQualified or
//	ComputerNameNetBIOS.  For V2 template, perform the verification
//	only when the template specify so.
//
//		By default, we assume the DNS will match.  The function will only
//	signal an error if it successfully obtained DNS name from GetComputerNameEx
//	and from the certificate and they do not match.  
//
//-----------------------------------------------------------------------
BOOL	AEVerifyDNSName(AE_GENERAL_INFO   *pAE_General_Info,
						PCCERT_CONTEXT    pCertCurrent)
{
	BOOL					fDNSMatch=TRUE;
    AE_CERTTYPE_INFO		*pCertType=NULL;
	DWORD					dwValue=0;
	BOOL					fDnsName=TRUE;
	BOOL					fNetBIOS=TRUE;

	LPWSTR					pwszDnsName=NULL;
    AE_TEMPLATE_INFO		AETemplateInfo;

    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

	//find the template that the certificate belongs to
	if(!AERetrieveTemplateInfo(pCertCurrent, &AETemplateInfo))
		goto Ret;

	pCertType=AEFindTemplateInRequestTree(&AETemplateInfo, pAE_General_Info);

	if(NULL==pCertType)
		goto Ret;

    if(S_OK != CAGetCertTypeFlagsEx(
                        pCertType->hCertType,
                        CERTTYPE_SUBJECT_NAME_FLAG,
                        &dwValue))
        goto Ret;

    if((CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT & dwValue) || 
       (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME & dwValue))
        goto Ret;

	//no need to verify non-template certificates or non-DNS specified template
	if(AETemplateInfo.pwszOid)
	{
		if( 0 == (CT_FLAG_SUBJECT_ALT_REQUIRE_DNS & dwValue))
			goto Ret;
	}

	//get the DNS entry from the certificate
	if(!AEGetDNSNameFromCertificate(pCertCurrent, &pwszDnsName))
	{
		fDNSMatch=FALSE;
		goto Ret;
	}

	//compare the data in the certificate with what is returned from GetComputerNameEx
	if(pAE_General_Info->pwszDns)
	{
		if(0 != _wcsicmp(pwszDnsName, pAE_General_Info->pwszDns))
		{
			fDnsName=FALSE;
		}
	}

	if(pAE_General_Info->pwszNetBIOS)
	{
		if(0 != _wcsicmp(pwszDnsName, pAE_General_Info->pwszNetBIOS))
		{
			fNetBIOS=FALSE;
		}
	}

	//either DNS or NetBIOS name should match
	if((FALSE == fDnsName) && (FALSE == fNetBIOS))
	{
		fDNSMatch=FALSE;
	}


Ret:
	if(pwszDnsName)
		LocalFree(pwszDnsName);

    AEFreeTemplateInfo(&AETemplateInfo);

	return fDNSMatch;
}

//-----------------------------------------------------------------------
//
//  AEVerifyDNSNameWithRetry
////
//-----------------------------------------------------------------------
BOOL	AEVerifyDNSNameWithRetry(AE_GENERAL_INFO   *pAE_General_Info,
								PCCERT_CONTEXT    pCertCurrent)
{
	BOOL				fResult=FALSE;
    ULARGE_INTEGER		ftTime;

	AE_RETRY_INFO		*pAE_Retry_Info=NULL;
	
	//detect if DNS name in the certificate matches the local machine
	//Success means no need to re-enroll
	if(TRUE == AEVerifyDNSName(pAE_General_Info, pCertCurrent))
	{
		fResult=TRUE;
		goto Ret;
	}

	//now that the DNS name does not match, check the CERT_AUTO_ENROLL_RETRY_PROP_ID
	//property on the pCertCurrent to determine the correct action

	//property does not exit.  Allow for re-enrollment by marking a failure
	if(!AEGetRetryProperty(pCertCurrent, &pAE_Retry_Info))
	{
		fResult=FALSE;
		goto Ret;
	}
				
	//property exit
	
	//the Maximum # of trial has reached.  Disallow for re-enrollment by returning a success
	if(AE_RETRY_LIMIT < pAE_Retry_Info->dwRetry)
	{
		fResult=TRUE;
		goto Ret;
	}

	//get the current time
    GetSystemTimeAsFileTime((LPFILETIME)&ftTime);
	
	//the time limit has not reached.  Disallow for re-enrollment by returning a success
	if(ftTime.QuadPart < (pAE_Retry_Info->dueTime).QuadPart)
	{
		fResult=TRUE;
		goto Ret;
	}

	//the rest should be re-enrolled by returning a failure
	fResult=FALSE;

Ret:

	if(pAE_Retry_Info)
		LocalFree(pAE_Retry_Info);

	return fResult;
}


//-----------------------------------------------------------------------
//
//  AEIsLogonDCCertificate
//
//
//-----------------------------------------------------------------------
BOOL AEIsLogonDCCertificate(PCCERT_CONTEXT pCertContext)
{
    BOOL                fDCCert=FALSE;
    PCERT_EXTENSION     pExt = NULL;
    DWORD               cbData = 0;
    DWORD               dwIndex = 0;
    BOOL                fFound = FALSE;

    CERT_ENHKEY_USAGE   *pbKeyUsage=NULL;
    AE_TEMPLATE_INFO    AETemplateInfo;

    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));


    if(NULL==pCertContext)
        return FALSE;


    if(!AERetrieveTemplateInfo(pCertContext, &AETemplateInfo))
        goto Ret;
                      

    if(AETemplateInfo.pwszName)
    {
        //this is a V1 template.  Search for the hard coded DC template name
        if(0 == _wcsicmp(wszCERTTYPE_DC, AETemplateInfo.pwszName))
            fDCCert=TRUE;
    }
    else
    {
        //this is a V2 template.  Search for the smart card logon OID
        if(NULL==(pExt=CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                    pCertContext->pCertInfo->cExtension,
                                    pCertContext->pCertInfo->rgExtension)))
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_ENHANCED_KEY_USAGE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              NULL,
                              &cbData))
            goto Ret;

        pbKeyUsage=(CERT_ENHKEY_USAGE *)LocalAlloc(LPTR, cbData);
        if(NULL==pbKeyUsage)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_ENHANCED_KEY_USAGE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbKeyUsage,
                              &cbData))
            goto Ret;

        for(dwIndex=0; dwIndex < pbKeyUsage->cUsageIdentifier; dwIndex++)
        {
            if(0==_stricmp(szOID_KP_SMARTCARD_LOGON,(pbKeyUsage->rgpszUsageIdentifier)[dwIndex]))
            {
                fDCCert=TRUE;
                break;
            }
        }
    }


Ret:

    if(pbKeyUsage)
        LocalFree(pbKeyUsage);

    AEFreeTemplateInfo(&AETemplateInfo);

    return fDCCert;

}
//-----------------------------------------------------------------------
//
//  AEValidateCertificateInfo
//
//      This function verifies if the certificate needs to be renewed or 
//  re-enrolled based on:
//  
//      1. Presence of the private key
//      2. Chaining of the certificate
//      3. If the certificate is close to expiration
//
//-----------------------------------------------------------------------
BOOL    AEValidateCertificateInfo(AE_GENERAL_INFO   *pAE_General_Info,
                                  AE_CERTTYPE_INFO  *pCertType,
                                  BOOL              fCheckForPrivateKey,
                                  PCCERT_CONTEXT    pCertCurrent, 
                                  AE_CERT_INFO      *pAECertInfo)
{
    BOOL                        fResult = TRUE;
    DWORD                       cbData = 0;
    CERT_CHAIN_PARA             ChainParams;
    CERT_CHAIN_POLICY_PARA      ChainPolicy;
    CERT_CHAIN_POLICY_STATUS    PolicyStatus;
    LARGE_INTEGER               ftTime;
    HRESULT                     hrChainStatus = S_OK;
    LARGE_INTEGER               ftHalfLife;
    BOOL                        fReset=FALSE;

    PCCERT_CHAIN_CONTEXT        pChainContext = NULL;

    if((NULL==pCertCurrent) || (NULL==pAECertInfo)  || (NULL==pAE_General_Info))
    {
        SetLastError(E_INVALIDARG);
        fResult = FALSE;
        goto Ret;
    }

    //assume the certificate is bad
    pAECertInfo->fValid = FALSE;
    pAECertInfo->fRenewal = FALSE;

    //////////////////////////////////////////////////
    //
    //check for the private key information
    //
    //////////////////////////////////////////////////
    if(fCheckForPrivateKey)
    {
        if(!CertGetCertificateContextProperty(
                pCertCurrent,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &cbData))
        {
            fReset=TRUE;
            goto Ret;
        }
    }

    /////////////////////////////////////////////////////////
    //
    //check for chaining, revoke status and expiration of the certificate
    //
    /////////////////////////////////////////////////////////

    memset(&ChainParams, 0, sizeof(ChainParams));
    ChainParams.cbSize = sizeof(ChainParams);
    ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

    ChainParams.RequestedUsage.Usage.cUsageIdentifier = 0;
    ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;

    // Build a small time skew into the chain building in order to deal
    // with servers that may skew slightly fast.
    GetSystemTimeAsFileTime((LPFILETIME)&ftTime);
    ftTime.QuadPart += Int32x32To64(FILETIME_TICKS_PER_SECOND, AE_DEFAULT_SKEW);

    // Build a cert chain for the current status of the cert..
    if(!CertGetCertificateChain(pAE_General_Info->fMachine?HCCE_LOCAL_MACHINE:HCCE_CURRENT_USER,
                                pCertCurrent,
                                (LPFILETIME)&ftTime,
                                NULL,
                                &ChainParams,
                                CERT_CHAIN_REVOCATION_CHECK_CHAIN,
                                NULL,
                                &pChainContext))
    {
        AE_DEBUG((AE_WARNING, L"Could not build certificate chain (%lx)\n\r", GetLastError()));
        goto Ret;
    }
    
    //validate the certificate chain

    //special case for domain controller certificate.
    //it should not have any revocation error, even for status unknown case

    //check against the base policy
    memset(&ChainPolicy, 0, sizeof(ChainPolicy));
    ChainPolicy.cbSize = sizeof(ChainPolicy);
    ChainPolicy.dwFlags = 0;  // ignore nothing
    ChainPolicy.pvExtraPolicyPara = NULL;

    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.dwError = 0;
    PolicyStatus.lChainIndex = -1;
    PolicyStatus.lElementIndex = -1;
    PolicyStatus.pvExtraPolicyStatus = NULL;

    if(!CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_BASE,
                                          pChainContext,
                                          &ChainPolicy,
                                          &PolicyStatus))
    {
        AE_DEBUG((AE_WARNING, L"Base Chain Policy failed (%lx) - must get new cert\n\r", GetLastError()));
        goto Ret;
    }

    hrChainStatus = PolicyStatus.dwError;

    if((S_OK ==  hrChainStatus) ||
       (CRYPT_E_NO_REVOCATION_CHECK ==  hrChainStatus) ||
       (CRYPT_E_REVOCATION_OFFLINE ==  hrChainStatus))
    {
        // The cert is still currently acceptable by trust standards, so we can renew it
        pAECertInfo->fRenewal = TRUE;
    }
    else
    {
        fReset=TRUE;
        goto Ret;
    }

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
        pChainContext = NULL;
    }

    /////////////////////////////////////////////////////////
    //
    //check the DNS name in the machine certificate.  It has
	//to match with the computer's DNS name
    //
    /////////////////////////////////////////////////////////
	if(pAE_General_Info->fMachine)
	{
		if(!AEVerifyDNSNameWithRetry(pAE_General_Info, pCertCurrent))
		{
			pAECertInfo->fRenewal = FALSE;
			goto Ret;
		}
	}

    /////////////////////////////////////////////////////////
    //
    // Check if the certificate is close to expire
    //
    ///////////////////////////////////////////////////////////////////////
    if(NULL==pCertType)
        goto Ret;

    // Nudge the evaluation of the cert chain by the expiration
    // offset so we know if is expired by that time in the future.
    GetSystemTimeAsFileTime((LPFILETIME)&ftTime);

    // Build the certificate chain for trust operations
    memset(&ChainParams, 0, sizeof(ChainParams));
    ChainParams.cbSize = sizeof(ChainParams);
    ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

    ChainParams.RequestedUsage.Usage.cUsageIdentifier = 0;
    ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;

    //get the 80% lifetime of the certificate
    ftHalfLife.QuadPart = ((((LARGE_INTEGER UNALIGNED *)&(pCertCurrent->pCertInfo->NotAfter))->QuadPart - 
                               ((LARGE_INTEGER UNALIGNED *)&(pCertCurrent->pCertInfo->NotBefore))->QuadPart)/10) * 8;

    //check if the old cert is time nesting invalid
    if(ftHalfLife.QuadPart < 0)
        goto Ret;

    //check if the offset was specified in a relative value
    if(pCertType->ftExpirationOffset.QuadPart < 0)
    {
        if(ftHalfLife.QuadPart > (- pCertType->ftExpirationOffset.QuadPart))
        {
            ftTime.QuadPart -= pCertType->ftExpirationOffset.QuadPart;
        }
        else
        {
            ftTime.QuadPart += ftHalfLife.QuadPart;
        }
    }
    else
    {
        //the offset was specified in an absolute value
        if(0 < pCertType->ftExpirationOffset.QuadPart) 
            ftTime = pCertType->ftExpirationOffset;
        else
            //use the half time mark if the offset is 0
            ftTime.QuadPart += ftHalfLife.QuadPart;
    }

    //check the certificate chain at a future time
    if(!CertGetCertificateChain(pAE_General_Info->fMachine?HCCE_LOCAL_MACHINE:HCCE_CURRENT_USER,
                                    pCertCurrent,
                                    (LPFILETIME)&ftTime,
                                    NULL,               //no additional store
                                    &ChainParams,
                                    0,                  //no revocation check
                                    NULL,               //Reserved
                                    &pChainContext))
    {
        AE_DEBUG((AE_WARNING, L"Could not build certificate chain (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    // Verify expiration of the certificate
    memset(&ChainPolicy, 0, sizeof(ChainPolicy));
    ChainPolicy.cbSize = sizeof(ChainPolicy);
    ChainPolicy.dwFlags = 0;  // ignore nothing
    ChainPolicy.pvExtraPolicyPara = NULL;

    memset(&PolicyStatus, 0, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    PolicyStatus.dwError = 0;
    PolicyStatus.lChainIndex = -1;
    PolicyStatus.lElementIndex = -1;
    PolicyStatus.pvExtraPolicyStatus = NULL;

    if(!CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_BASE,
                                          pChainContext,
                                          &ChainPolicy,
                                          &PolicyStatus))
    {
        AE_DEBUG((AE_WARNING, L"Base Chain Policy failed (%lx) - must get new cert\n\r", GetLastError()));
        goto Ret;
    }

    hrChainStatus = PolicyStatus.dwError;

    if((S_OK != hrChainStatus) &&
       (CRYPT_E_NO_REVOCATION_CHECK != hrChainStatus) &&
       (CRYPT_E_REVOCATION_OFFLINE != hrChainStatus))
    {
        // The cert is close to expire. we must re-renewal
        goto Ret;
    }

    //the certificate is good
    pAECertInfo->fValid = TRUE;

    fResult = TRUE;

Ret:

    if(pAE_General_Info->fMachine)
    {
        if(TRUE == fReset)
        {
            //clear out the retry logic
	    CertSetCertificateContextProperty(
		  pCertCurrent, 
		  CERT_AUTO_ENROLL_RETRY_PROP_ID, 
		  0, 
		  NULL);
        }

    }


    if(pChainContext)
        CertFreeCertificateChain(pChainContext);

    return fResult;
}

//-----------------------------------------------------------------------
//
//  AESameOID
//
//      Check if the two OIDs are the same
//-----------------------------------------------------------------------
BOOL AESameOID(LPWSTR pwszOID, LPSTR pszOID)
{
    DWORD   cbChar=0;
    BOOL    fSame=FALSE;

    LPSTR   pszNewOID=NULL;

    if((NULL==pwszOID) || (NULL==pszOID))
        return FALSE;

    cbChar= WideCharToMultiByte(
                CP_ACP,                // codepage
                0,                      // dwFlags
                pwszOID,
                -1,
                NULL,
                0,
                NULL,
                NULL);

    if(0 == cbChar)
        goto Ret;

    if(NULL==(pszNewOID=(LPSTR)LocalAlloc(LPTR, cbChar)))
        goto Ret;

    cbChar= WideCharToMultiByte(
                CP_ACP,                // codepage
                0,                      // dwFlags
                pwszOID,
                -1,
                pszNewOID,
                cbChar,
                NULL,
                NULL);

    if(0 == cbChar)
        goto Ret;


    if(0 == _stricmp(pszNewOID, pszOID))
        fSame=TRUE;

Ret:

    if(pszNewOID)
        LocalFree(pszNewOID);

    return fSame;
}


//-----------------------------------------------------------------------
//
//  AEValidRAPolicyWithProperty
//
//      Check if the certificate matches the RA signature requirement
//  of the certificate type
//-----------------------------------------------------------------------
BOOL    AEValidRAPolicyWithProperty(PCCERT_CONTEXT pCertContext, 
                                    LPWSTR          *rgwszPolicy,
                                    LPWSTR          *rgwszAppPolicy)
{
    PCERT_EXTENSION     pExt = NULL;
    DWORD               cbData = 0;
    DWORD               dwIndex = 0;
    DWORD               dwFindIndex=0;
    BOOL                fFound = FALSE;
    BOOL                fValid = FALSE;

    CERT_ENHKEY_USAGE   *pbKeyUsage=NULL;
    CERT_POLICIES_INFO  *pbAppPolicy=NULL;
    CERT_POLICIES_INFO  *pbPolicy=NULL;

    //find the EKUs
    if(pExt=CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                pCertContext->pCertInfo->cExtension,
                                pCertContext->pCertInfo->rgExtension))
    {
        cbData=0;
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szOID_ENHANCED_KEY_USAGE,
                          pExt->Value.pbData,
                          pExt->Value.cbData,
                          0,
                          NULL,
                          &cbData))
        goto Ret;

        pbKeyUsage=(CERT_ENHKEY_USAGE *)LocalAlloc(LPTR, cbData);
        if(NULL==pbKeyUsage)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_ENHANCED_KEY_USAGE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbKeyUsage,
                              &cbData))
            goto Ret;
    }

    //get the cert issurance policy
    if(pExt=CertFindExtension(szOID_CERT_POLICIES,
                                pCertContext->pCertInfo->cExtension,
                                pCertContext->pCertInfo->rgExtension))
    {
        cbData=0;
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szOID_CERT_POLICIES,
                          pExt->Value.pbData,
                          pExt->Value.cbData,
                          0,
                          NULL,
                          &cbData))
        goto Ret;

        pbPolicy=(CERT_POLICIES_INFO *)LocalAlloc(LPTR, cbData);
        if(NULL==pbPolicy)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_CERT_POLICIES,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbPolicy,
                              &cbData))
            goto Ret;
    }
   
    
    //get the cert application policy
    if(pExt=CertFindExtension(szOID_APPLICATION_CERT_POLICIES,
                                pCertContext->pCertInfo->cExtension,
                                pCertContext->pCertInfo->rgExtension))
    {
        cbData=0;
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szOID_CERT_POLICIES,
                          pExt->Value.pbData,
                          pExt->Value.cbData,
                          0,
                          NULL,
                          &cbData))
        goto Ret;

        pbAppPolicy=(CERT_POLICIES_INFO *)LocalAlloc(LPTR, cbData);
        if(NULL==pbAppPolicy)
            goto Ret;

        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              szOID_CERT_POLICIES,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,
                              pbAppPolicy,
                              &cbData))
            goto Ret;
    }
    

    if(rgwszPolicy)
    {
        if(rgwszPolicy[0])
        {
            if(NULL==pbPolicy)
                goto Ret;

            dwIndex=0;
            while(rgwszPolicy[dwIndex])
            {
                fFound=FALSE;

                for(dwFindIndex=0; dwFindIndex < pbPolicy->cPolicyInfo; dwFindIndex++)
                {
                    if(AESameOID(rgwszPolicy[dwIndex], (pbPolicy->rgPolicyInfo)[dwFindIndex].pszPolicyIdentifier))
                    {
                        fFound=TRUE;
                        break;
                    }
                }

                if(FALSE == fFound)
                    goto Ret;

                dwIndex++;
            }
        }
    }

    if(rgwszAppPolicy)
    {
        if(rgwszAppPolicy[0])
        {
            if((NULL==pbAppPolicy) && (NULL==pbKeyUsage))
                goto Ret;

            dwIndex=0;
            while(rgwszAppPolicy[dwIndex])
            {
                fFound=FALSE;

                if(pbAppPolicy)
                {
                    for(dwFindIndex=0; dwFindIndex < pbAppPolicy->cPolicyInfo; dwFindIndex++)
                    {
                        if(AESameOID(rgwszAppPolicy[dwIndex], (pbAppPolicy->rgPolicyInfo)[dwFindIndex].pszPolicyIdentifier))
                        {
                            fFound=TRUE;
                            break;
                        }
                    }
                }

                if((FALSE == fFound) && (pbKeyUsage))
                {
                    for(dwFindIndex=0; dwFindIndex < pbKeyUsage->cUsageIdentifier; dwFindIndex++)
                    {
                        if(AESameOID(rgwszAppPolicy[dwIndex],(pbKeyUsage->rgpszUsageIdentifier)[dwFindIndex]))
                        {
                            fFound=TRUE;
                            break;
                        }
                    }
                }

                if(FALSE == fFound)
                    goto Ret;

                dwIndex++;
            }
        }
    }

    fValid=TRUE;

Ret:
    if(pbKeyUsage)
        LocalFree(pbKeyUsage);

    if(pbPolicy)
        LocalFree(pbPolicy);

    if(pbAppPolicy)
        LocalFree(pbAppPolicy);

    return fValid;
}


//-----------------------------------------------------------------------
//
//  AEValidRAPolicy
//
//      Check if the certificate matches the RA signature requirement
//  of the certificate type
//-----------------------------------------------------------------------
BOOL    AEValidRAPolicy(PCCERT_CONTEXT pCertContext, AE_CERTTYPE_INFO *pCertType)
{
    BOOL                fValid=FALSE;

    LPWSTR              *rgwszPolicy=NULL;
    LPWSTR              *rgwszAppPolicy=NULL;

    if((NULL==pCertType) || (NULL==pCertContext))
        return FALSE;

    //get the certificate type properties
    CAGetCertTypePropertyEx(pCertType->hCertType,
                            CERTTYPE_PROP_RA_POLICY,
                            &rgwszPolicy);


    CAGetCertTypePropertyEx(pCertType->hCertType,
                            CERTTYPE_PROP_RA_APPLICATION_POLICY,
                            &rgwszAppPolicy);

    fValid = AEValidRAPolicyWithProperty(pCertContext, rgwszPolicy, rgwszAppPolicy);


    if(rgwszPolicy)
        CAFreeCertTypeProperty(pCertType->hCertType, rgwszPolicy);

    if(rgwszAppPolicy)
        CAFreeCertTypeProperty(pCertType->hCertType, rgwszAppPolicy);

    return fValid;

}

//-----------------------------------------------------------------------
//
//  AESomeCSPSupported
//
//-----------------------------------------------------------------------
BOOL    AESomeCSPSupported(HCERTTYPE     hCertType)
{
    BOOL            fResult=FALSE;
    DWORD           dwIndex=0;
    DWORD           dwCSPIndex=0;
    DWORD           dwProviderType=0;
    DWORD           cbSize=0;

    LPWSTR          *awszCSP=NULL;
    LPWSTR          pwszProviderName=NULL;
    HCRYPTPROV      hProv=NULL;


    if(NULL==hCertType)
        goto Ret;

    //no CSPs means all CSPs are fine
    if((S_OK != CAGetCertTypePropertyEx(
                    hCertType,
                    CERTTYPE_PROP_CSP_LIST,
                    &awszCSP)) || (NULL == awszCSP))
    {
        fResult=TRUE;
        goto Ret;
    }

    //no CSP means all CSPs are fine
    if(NULL == awszCSP[0])
    {
        fResult=TRUE;
        goto Ret;
    }

    for(dwIndex=0; NULL != awszCSP[dwIndex]; dwIndex++)
    {
        for (dwCSPIndex = 0; 
	        CryptEnumProvidersW(dwCSPIndex, 0, 0, &dwProviderType, NULL, &cbSize);
	        dwCSPIndex++)
        {	
	        pwszProviderName = (LPWSTR)LocalAlloc(LPTR, cbSize);

	        if(NULL == pwszProviderName)
	            goto Ret;
	    
	        //get the provider name and type
	        if(!CryptEnumProvidersW(dwCSPIndex,
	            0,
	            0,
	            &dwProviderType,
	            pwszProviderName,
	            &cbSize))
	            goto Ret; 

            if(0 == _wcsicmp(pwszProviderName, awszCSP[dwIndex]))
            {
                //find the CSP.  See if it is present in the box
                if(CryptAcquireContextW(
                            &hProv,
                            NULL,
                            awszCSP[dwIndex],
                            dwProviderType,
                            CRYPT_VERIFYCONTEXT | CRYPT_SILENT))
                {

                    CryptReleaseContext(hProv, 0);
                    hProv=NULL;

                    fResult=TRUE;
                    break;
                }
            }

            //keep the CSP enumeration
            if(pwszProviderName)
                LocalFree(pwszProviderName);

            pwszProviderName=NULL;
            cbSize=0;
            dwProviderType=0;
        }

        //detect if a valid CSP if found
        if(TRUE == fResult)
        {
            break;
        }

        cbSize=0;
        dwProviderType=0;
    }

Ret:
    if(pwszProviderName)
        LocalFree(pwszProviderName);

    if(hProv)
        CryptReleaseContext(hProv, 0);

    if(awszCSP)
        CAFreeCertTypeProperty(hCertType, awszCSP);

    return fResult;

}

//-----------------------------------------------------------------------
//
//  AEFindCSPType
//
//-----------------------------------------------------------------------
BOOL    AEFindCSPType(LPWSTR pwszCSP, DWORD *pdwType)
{
	BOOL	fResult=FALSE;
	DWORD	dwIndex=0;
	DWORD	dwProviderType=0;
	DWORD	cbSize=0;

	LPWSTR	pwszCSPName=NULL;

	if((NULL==pwszCSP) || (NULL==pdwType))
		goto Ret;

	*pdwType=0;

    //enum all the providers on the system
   while(CryptEnumProviders(
                            dwIndex,
                            0,
                            0,
                            &dwProviderType,
                            NULL,
                            &cbSize))
   {

		pwszCSPName=(LPWSTR)LocalAlloc(LPTR, cbSize);

		if(NULL==pwszCSPName)
			goto Ret;

        //get the CSP name and the type
        if(!CryptEnumProviders(
                            dwIndex,
                            0,
                            0,
                            &dwProviderType,
                            pwszCSPName,
                            &cbSize))
            goto Ret;

		if(0 == _wcsicmp(pwszCSPName, pwszCSP))
		{
			//find the CSP
			*pdwType=dwProviderType;
			fResult=TRUE;
			goto Ret;
		}

		dwIndex++;
		dwProviderType=0;
		cbSize=0;

		if(pwszCSPName)
		{
			LocalFree(pwszCSPName);
			pwszCSPName=NULL;
		}
   }

Ret:

	if(pwszCSPName)
		LocalFree(pwszCSPName);

	return fResult;

}

//-----------------------------------------------------------------------
//
//  AESmartcardOnlyTemplate
//
//-----------------------------------------------------------------------
BOOL    AESmartcardOnlyTemplate(HCERTTYPE   hCertType)
{
    BOOL            fResult=FALSE;
    DWORD           dwIndex=0;
    DWORD           dwImpType=0;
    DWORD           cbData=0;
    DWORD           dwSCCount=0;
	DWORD			dwCSPType=0;

    LPWSTR          *awszCSP=NULL;
    HCRYPTPROV      hProv = NULL;

    if(NULL==hCertType)
        goto Ret;

    if(S_OK != CAGetCertTypePropertyEx(
                    hCertType,
                    CERTTYPE_PROP_CSP_LIST,
                    &awszCSP))
        goto Ret;

    if(NULL==awszCSP)
        goto Ret;

    for(dwIndex=0; NULL != awszCSP[dwIndex]; dwIndex++)
    {
        dwImpType=0;
		dwCSPType=0;

        //find the CSP type based on the CSP name
		if(AEFindCSPType(awszCSP[dwIndex], &dwCSPType))
		{
			if(CryptAcquireContextW(
						&hProv,
						NULL,
						awszCSP[dwIndex],
						dwCSPType,
						CRYPT_VERIFYCONTEXT | CRYPT_SILENT))
			{

				cbData = sizeof(dwImpType);
         
				if(CryptGetProvParam(hProv,
						PP_IMPTYPE,
						(BYTE *)(&dwImpType),
						&cbData,
						0))
				{
					if((CRYPT_IMPL_REMOVABLE & dwImpType) && (CRYPT_IMPL_MIXED & dwImpType))
						dwSCCount++;
				}

				CryptReleaseContext(hProv, 0);
				hProv=NULL;
			}
			else
			{
				//not supported CSP.  Count it as part of the SmartCard CSP count since this
				//CSP will not work when the smart card subsystem is not present
				dwSCCount++;
			}
		}
		else
		{
			//not supported CSP.  Count it as part of the SmartCard CSP count since this
			//CSP will not work when the smart card subsystem is not present
			dwSCCount++;
		}
    }

    //smart card CSP only if all CSPs are for smart card only
    if((0 != dwIndex) && (dwIndex==dwSCCount))
        fResult=TRUE;

Ret:
    if(hProv)
        CryptReleaseContext(hProv, 0);

    if(awszCSP)
        CAFreeCertTypeProperty(hCertType, awszCSP);

    return fResult;
}


//-----------------------------------------------------------------------
//
//  AEUserProtectionForTemplate
//
//-----------------------------------------------------------------------
BOOL   AEUserProtectionForTemplate(AE_GENERAL_INFO *pAE_General_Info, PCERT_CONTEXT pCertContext)
{
    BOOL                fUserProtection=FALSE;
    AE_CERTTYPE_INFO    *pCertType=NULL;

    AE_TEMPLATE_INFO    AETemplateInfo;


    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    if((NULL == pAE_General_Info) || (NULL == pCertContext))
        goto Ret;

    //get the template information for the certificate
    if(!AERetrieveTemplateInfo(pCertContext, &AETemplateInfo))
        goto Ret;

    pCertType=AEFindTemplateInRequestTree(&AETemplateInfo, pAE_General_Info);

    if(NULL==pCertType)
        goto Ret;

    if(CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED & (pCertType->dwPrivateKeyFlag))
        fUserProtection=TRUE;

Ret:

    AEFreeTemplateInfo(&AETemplateInfo);

    return fUserProtection;
}

//-----------------------------------------------------------------------
//
//  AEUISetForTemplate
//
//-----------------------------------------------------------------------
BOOL    AEUISetForTemplate(AE_GENERAL_INFO *pAE_General_Info, PCERT_CONTEXT pCertContext)
{
    BOOL                fUI=FALSE;
    AE_CERTTYPE_INFO    *pCertType=NULL;

    AE_TEMPLATE_INFO    AETemplateInfo;


    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    if((NULL == pAE_General_Info) || (NULL == pCertContext))
        goto Ret;

    //get the template information for the certificate
    if(!AERetrieveTemplateInfo(pCertContext, &AETemplateInfo))
        goto Ret;

    pCertType=AEFindTemplateInRequestTree(&AETemplateInfo, pAE_General_Info);

    if(NULL==pCertType)
        goto Ret;

    if(CT_FLAG_USER_INTERACTION_REQUIRED & (pCertType->dwEnrollmentFlag))
        fUI=TRUE;

Ret:

    AEFreeTemplateInfo(&AETemplateInfo);

    return fUI;
}

//-----------------------------------------------------------------------
//
//  AECanEnrollCertType
//
//-----------------------------------------------------------------------
BOOL    AECanEnrollCertType(HANDLE  hToken, AE_CERTTYPE_INFO *pCertType, AE_GENERAL_INFO *pAE_General_Info, BOOL *pfUserProtection)
{
    DWORD               dwValue = 0;
    PCCERT_CONTEXT      pCertCurrent=NULL;
    AE_CERT_INFO        AECertInfo;

    memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));

	*pfUserProtection=FALSE;

    //check enrollment ACL
    if(S_OK != CACertTypeAccessCheckEx(
                        pCertType->hCertType,
                        hToken,
                        CERTTYPE_ACCESS_CHECK_ENROLL | CERTTYPE_ACCESS_CHECK_NO_MAPPING))
        return FALSE;


    //check the subject requirements
    if(S_OK != CAGetCertTypeFlagsEx(
                        pCertType->hCertType,
                        CERTTYPE_SUBJECT_NAME_FLAG,
                        &dwValue))
        return FALSE;

    if((CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT & dwValue) || 
       (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME & dwValue))
        return FALSE;

    //check if we are doing smart card CSPs and there is no reader installed
    if(FALSE == (pAE_General_Info->fSmartcardSystem))
    {
        if(AESmartcardOnlyTemplate(pCertType->hCertType))
            return FALSE;
    }

    //check if all CSPs on the template is not supported 
    {
        if(!AESomeCSPSupported(pCertType->hCertType))
            return FALSE;
    }


    //we might not get the RA property for V1 template
    dwValue = 0;

    //check the RA support
    if(S_OK != CAGetCertTypePropertyEx(
                pCertType->hCertType,
                CERTTYPE_PROP_RA_SIGNATURE,
                &dwValue))
        return TRUE;

    if(0==dwValue)
        return TRUE;

    //self-template RA
    if((CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT & (pCertType->dwEnrollmentFlag)) &&
        ((pCertType->fRenewal) && (pCertType->pOldCert))
       )
    {
        //the request has to be RAed
        pCertType->fNeedRA=TRUE;
        return TRUE;
    }

    //autoenrollment only deal with one RA signature.  
    //it is sufficient for autoenrollment RA scenarios
    if(1!=dwValue)
        return FALSE;

    //the certificate template requires one and only one RA signature

    //cross-template RA
    //enumerate all certificate in store
    while(pCertCurrent = CertEnumCertificatesInStore(pAE_General_Info->hMyStore, pCertCurrent))
    {
        //check if we need to enroll/renewal for the certificate
        AEValidateCertificateInfo(pAE_General_Info, 
                                NULL,
                                TRUE,               //valid private key
                                pCertCurrent, 
                                &AECertInfo);

        //the certificate is good enough for RA signature purpose
        if(AECertInfo.fRenewal)
        {
            if(AEValidRAPolicy(pCertCurrent, pCertType))
            {
				if(AEUserProtectionForTemplate(pAE_General_Info, (PCERT_CONTEXT)pCertCurrent))
				{
					if(pAE_General_Info->fMachine)
					{
						*pfUserProtection=TRUE;
						continue;
					}
					else
					{
						if(0==(CT_FLAG_USER_INTERACTION_REQUIRED & (pCertType->dwEnrollmentFlag)))
						{
							*pfUserProtection=TRUE;
							continue;
						}
					}
				}

                pCertType->fRenewal=TRUE;

                if(pCertType->pOldCert)
                {
                    CertFreeCertificateContext(pCertType->pOldCert);
                    pCertType->pOldCert=NULL;
                }

                //we will free the certificate context later
                pCertType->pOldCert=(PCERT_CONTEXT)pCertCurrent;

                //we mark UI required if the RAing certificate template requires UI
                if(AEUISetForTemplate(pAE_General_Info, pCertType->pOldCert))
                    pCertType->fUIActive=TRUE;

                //we mark the requests has to be RAed.
                pCertType->fNeedRA=TRUE;

                //we mark that we are doing cross RAing.
                pCertType->fCrossRA=TRUE;

				*pfUserProtection=FALSE;

                return TRUE;
            }
        }

        memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
    }


    return FALSE;
}

//-----------------------------------------------------------------------
//
//  AEMarkAutoenrollment
//
//-----------------------------------------------------------------------
BOOL    AEMarkAutoenrollment(AE_GENERAL_INFO *pAE_General_Info)
{
    DWORD   dwIndex = 0;

    for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
    {
        if(CT_FLAG_AUTO_ENROLLMENT & ((pAE_General_Info->rgCertTypeInfo)[dwIndex].dwEnrollmentFlag))
        {
            //check the autoenrollment ACL
            if(S_OK != CACertTypeAccessCheckEx(
                            (pAE_General_Info->rgCertTypeInfo)[dwIndex].hCertType,
                            pAE_General_Info->hToken,
                            CERTTYPE_ACCESS_CHECK_AUTO_ENROLL | CERTTYPE_ACCESS_CHECK_NO_MAPPING))
                continue;


            //mark the template nees to be auto-enrolled
            (pAE_General_Info->rgCertTypeInfo)[dwIndex].dwStatus=CERT_REQUEST_STATUS_ACTIVE;
            (pAE_General_Info->rgCertTypeInfo)[dwIndex].fCheckMyStore=TRUE;
        }
    }

    return TRUE;
}

//-----------------------------------------------------------------------
//
//    IsACRSStoreEmpty
//
//
//-----------------------------------------------------------------------
BOOL IsACRSStoreEmpty(BOOL fMachine)
{
    DWORD                       dwOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG;
    LPSTR                       pszCTLUsageOID = NULL;
    BOOL                        fEmpty = TRUE;
    CERT_PHYSICAL_STORE_INFO    PhysicalStoreInfo;
    CTL_FIND_USAGE_PARA         CTLFindUsage;

    PCCTL_CONTEXT               pCTLContext = NULL;
    HCERTSTORE                  hStoreACRS=NULL;

    memset(&PhysicalStoreInfo, 0, sizeof(PhysicalStoreInfo));
    memset(&CTLFindUsage, 0, sizeof(CTLFindUsage));


    // if the auto enrollment is for a user then we need to shut off inheritance
    // from the local machine store so that we don't try and enroll for certs
    // which are meant to be for the machine
    if (FALSE == fMachine)
    {
		dwOpenStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG;

        PhysicalStoreInfo.cbSize = sizeof(PhysicalStoreInfo);
        PhysicalStoreInfo.dwFlags = CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG;

        if (!CertRegisterPhysicalStore(ACRS_STORE, 
                                       CERT_SYSTEM_STORE_CURRENT_USER,
                                       CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME, 
                                       &PhysicalStoreInfo,
                                       NULL))
        {
            AE_DEBUG((AE_ERROR, L"Could not register ACRS store: (%lx)\n\r", GetLastError()));
            goto Ret;
        }
    }

    // open the ACRS store and fine the CTL based on the auto enrollment usage
    if (NULL == (hStoreACRS = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                          ENCODING_TYPE, 
                                          NULL, 
                                          dwOpenStoreFlags, 
                                          ACRS_STORE)))
    {
        AE_DEBUG((AE_ERROR, L"Could not open ACRS store: (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    //find the template name specified in the CTLContext
    CTLFindUsage.cbSize = sizeof(CTLFindUsage);
    CTLFindUsage.SubjectUsage.cUsageIdentifier = 1;
    pszCTLUsageOID = szOID_AUTO_ENROLL_CTL_USAGE;
    CTLFindUsage.SubjectUsage.rgpszUsageIdentifier = &pszCTLUsageOID;

    while(pCTLContext = CertFindCTLInStore(hStoreACRS,
                                           X509_ASN_ENCODING,
                                           CTL_FIND_SAME_USAGE_FLAG,
                                           CTL_FIND_USAGE,
                                           &CTLFindUsage,
                                           pCTLContext))
    {
        fEmpty=FALSE;
        break;
    }


Ret:

    if(pCTLContext)
        CertFreeCTLContext(pCTLContext);

    if(hStoreACRS)
        CertCloseStore(hStoreACRS, 0);

    return fEmpty;
}


//-----------------------------------------------------------------------
//
//  AEMarkAEObject
//
//      Mark the active status based on ACRS store
//
//      INFORMATION:
//      we do not honor the CA specified in the autoenrollment object anymore.  All CAs
//      in the enterprise should be treated equal; and once the CA is renewed, it certificate
//      will be changed anyway.
//-----------------------------------------------------------------------
BOOL    AEMarkAEObject(AE_GENERAL_INFO  *pAE_General_Info)
{
    DWORD                       dwOpenStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG;
    PCCTL_CONTEXT               pCTLContext = NULL;
    LPSTR                       pszCTLUsageOID = NULL;
    LPWSTR                      wszCertTypeName = NULL;
    AE_CERTTYPE_INFO            *pCertType=NULL;
    CERT_PHYSICAL_STORE_INFO    PhysicalStoreInfo;
    CTL_FIND_USAGE_PARA         CTLFindUsage;
    AE_TEMPLATE_INFO            AETemplateInfo;

    HCERTSTORE                  hStoreACRS=NULL;

    memset(&PhysicalStoreInfo, 0, sizeof(PhysicalStoreInfo));
    memset(&CTLFindUsage, 0, sizeof(CTLFindUsage));
    memset(&AETemplateInfo, 0, sizeof(AETemplateInfo));


    // if the auto enrollment is for a user then we need to shut off inheritance
    // from the local machine store so that we don't try and enroll for certs
    // which are meant to be for the machine
    if (FALSE == (pAE_General_Info->fMachine))
    {
		dwOpenStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG;

        PhysicalStoreInfo.cbSize = sizeof(PhysicalStoreInfo);
        PhysicalStoreInfo.dwFlags = CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG;

        if (!CertRegisterPhysicalStore(ACRS_STORE, 
                                       CERT_SYSTEM_STORE_CURRENT_USER,
                                       CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME, 
                                       &PhysicalStoreInfo,
                                       NULL))
        {
            AE_DEBUG((AE_ERROR, L"Could not register ACRS store: (%lx)\n\r", GetLastError()));
            goto Ret;
        }
    }

    // open the ACRS store and fine the CTL based on the auto enrollment usage
    if (NULL == (hStoreACRS = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                                          ENCODING_TYPE, 
                                          NULL, 
                                          dwOpenStoreFlags, 
                                          ACRS_STORE)))
    {
        AE_DEBUG((AE_ERROR, L"Could not open ACRS store: (%lx)\n\r", GetLastError()));
        goto Ret;
    }

    //find the template name specified in the CTLContext
    CTLFindUsage.cbSize = sizeof(CTLFindUsage);
    CTLFindUsage.SubjectUsage.cUsageIdentifier = 1;
    pszCTLUsageOID = szOID_AUTO_ENROLL_CTL_USAGE;
    CTLFindUsage.SubjectUsage.rgpszUsageIdentifier = &pszCTLUsageOID;

    while(pCTLContext = CertFindCTLInStore(hStoreACRS,
                                           X509_ASN_ENCODING,
                                           CTL_FIND_SAME_USAGE_FLAG,
                                           CTL_FIND_USAGE,
                                           &CTLFindUsage,
                                           pCTLContext))
    {
        if(NULL== (pCTLContext->pCtlInfo->ListIdentifier.pbData))
            continue;

        wszCertTypeName = wcschr((LPWSTR)pCTLContext->pCtlInfo->ListIdentifier.pbData, L'|');
        if(wszCertTypeName)
        {
            wszCertTypeName++;
        }
        else
        {
            wszCertTypeName = (LPWSTR)pCTLContext->pCtlInfo->ListIdentifier.pbData;
        }

        AETemplateInfo.pwszName = wszCertTypeName;

        if(pCertType=AEFindTemplateInRequestTree(&AETemplateInfo, pAE_General_Info))
        {
            if(0 == pCertType->dwStatus)
            {
                //mark the template needs to be auto-enrolled
                pCertType->dwStatus=CERT_REQUEST_STATUS_ACTIVE;
                pCertType->fCheckMyStore=TRUE;
            }
        }
        else
        {
            //log that the template is invalid
            AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_INVALID_ACRS_OBJECT,                              
                 pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, wszCertTypeName);
        }

    }


Ret:

    if(hStoreACRS)
        CertCloseStore(hStoreACRS, 0);

    return TRUE;
}


//-----------------------------------------------------------------------
//
//  AEManageAndMarkMyStore
//
//-----------------------------------------------------------------------
BOOL    AEManageAndMarkMyStore(AE_GENERAL_INFO *pAE_General_Info)
{
    AE_CERT_INFO        AECertInfo;
    AE_CERTTYPE_INFO    *pCertType=NULL;
    BOOL                fNeedToValidate=TRUE;
    PCCERT_CONTEXT      pCertCurrent = NULL;
    DWORD               cbData=0;

    AE_TEMPLATE_INFO    AETemplateInfo;


    memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));

    //enumerate all certificate in store
    while(pCertCurrent = CertEnumCertificatesInStore(pAE_General_Info->hMyStore, pCertCurrent))
    {
        //only interested in certificate with template information
        if(AERetrieveTemplateInfo(pCertCurrent, &AETemplateInfo))
        {
            if(pCertType=AEFindTemplateInRequestTree(
                            &AETemplateInfo, pAE_General_Info))
            {
                //if we are not supposed to check for my store, only search
                //for template with ACTIVE status
                if(0 == (AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT & (pAE_General_Info->dwPolicy)))
                {
                    if(!(pCertType->fCheckMyStore))
                        goto Next;
                }

                //make sure the version of the certificate template is up to date
                //we do not have version for V1 template
                if(AETemplateInfo.pwszOid)
                {
                    if(AETemplateInfo.dwVersion < pCertType->dwVersion)
                    {
                        AECertInfo.fValid=FALSE;
                        AECertInfo.fRenewal = FALSE;

                        //self-RA renewal
                        if(CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT & pCertType->dwEnrollmentFlag)
                        {
                            if(CertGetCertificateContextProperty(
                                pCertCurrent,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                NULL,
                                &cbData))
                                AECertInfo.fRenewal = TRUE;
                        }

                        fNeedToValidate=FALSE;
                    }
                }
                
                if(fNeedToValidate)
                {
                    //check if we need to enroll/renewal for the certificate
                    AEValidateCertificateInfo(pAE_General_Info, 
                                            pCertType,
                                            TRUE,               //valid private key
                                            pCertCurrent, 
                                            &AECertInfo);
                }

                if(AECertInfo.fValid)
                {
                    //if the certificate is valid, mark as obtained.  And copy the 
                    //certificate to the obtained store.  Keep the archive store.
                    pCertType->dwStatus = CERT_REQUEST_STATUS_OBTAINED;

                    CertAddCertificateContextToStore(
                            pCertType->hObtainedStore,
                            pCertCurrent,
                            CERT_STORE_ADD_ALWAYS,
                            NULL);

                }
                else
                {
                    //the certificate is not valid
                    //mark the status to active if it is not obtained
                    if(CERT_REQUEST_STATUS_OBTAINED != pCertType->dwStatus)
                    {
                        pCertType->dwStatus = CERT_REQUEST_STATUS_ACTIVE;

                        if(AECertInfo.fRenewal)
                        {
                            //we only need to copy renewal information once
                            if(!pCertType->fRenewal)
                            {
                                pCertType->fRenewal=TRUE;
                                pCertType->pOldCert=(PCERT_CONTEXT)CertDuplicateCertificateContext(pCertCurrent);
                            }
                        }
                    }

                    //copy the certificate to the Archive certificate store
                    CertAddCertificateContextToStore(
                            pCertType->hArchiveStore,
                            pCertCurrent,
                            CERT_STORE_ADD_ALWAYS,
                            NULL);
                }
            }
            else
            {
                 //log that the template is invalid
                 AELogAutoEnrollmentEvent(
                    pAE_General_Info->dwLogLevel, 
                    FALSE, 
                    S_OK, 
                    EVENT_INVALID_TEMPLATE_MY_STORE,                              
                    pAE_General_Info->fMachine, 
                    pAE_General_Info->hToken, 
                    1,
                    AETemplateInfo.pwszName ? AETemplateInfo.pwszName : AETemplateInfo.pwszOid);

            }
        }

Next:
        memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
        AEFreeTemplateInfo(&AETemplateInfo);
        fNeedToValidate=TRUE;
        cbData=0;
    }

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AEOpenUserDSStore
//
//      INFORMATION: We could just open the "UserDS" store as if it is "My"
//
//-----------------------------------------------------------------------
HCERTSTORE  AEOpenUserDSStore(AE_GENERAL_INFO *pAE_General_Info, DWORD dwOpenFlag)
{
    LPWSTR      pwszPath=L"ldap:///%s?userCertificate?base?objectCategory=user";
    DWORD       dwSize=0;
    WCHAR       wszDN[MAX_DN_SIZE];

    LPWSTR      pwszDN=NULL;
    LPWSTR      pwszStore=NULL;
    HCERTSTORE  hStore=NULL;

    dwSize=MAX_DN_SIZE;

    if(!GetUserNameExW(NameFullyQualifiedDN, wszDN, &dwSize))
    {
        if(dwSize > MAX_DN_SIZE)
        {
            pwszDN=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * dwSize);

            if(NULL==pwszDN)
                goto Ret;

            if(!GetUserNameExW(NameFullyQualifiedDN, pwszDN, &dwSize))
                goto Ret;
        }
        else
            goto Ret;
    }

    pwszStore = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*(wcslen(pwszDN ? pwszDN : wszDN)+wcslen(pwszPath)+1));
    if(pwszStore == NULL)
        goto Ret;

    wsprintf(pwszStore, 
             pwszPath,
             pwszDN ? pwszDN : wszDN);

    hStore = CertOpenStore(CERT_STORE_PROV_LDAP, 
                  ENCODING_TYPE,
                  NULL,
                  dwOpenFlag | CERT_LDAP_STORE_SIGN_FLAG, 
                  pwszStore);

Ret:

    if(pwszStore)
        LocalFree(pwszStore);

    if(pwszDN)
        LocalFree(pwszDN);

    return hStore;
}


//-----------------------------------------------------------------------
//
//  AECheckUserDSStore
//
//-----------------------------------------------------------------------
BOOL    AECheckUserDSStore(AE_GENERAL_INFO  *pAE_General_Info)
{
    PCCERT_CONTEXT      pCertCurrent = NULL;
    AE_CERTTYPE_INFO    *pCertType=NULL;
    BOOL                fNeedToValidate=TRUE;
    AE_CERT_INFO        AECertInfo;

    HCERTSTORE          hUserDS = NULL;
    AE_TEMPLATE_INFO    AETemplateInfo;
    
    memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
    memset(&AETemplateInfo, 0, sizeof(AE_TEMPLATE_INFO));
    
    pCertType=pAE_General_Info->rgCertTypeInfo;

    if(NULL==pCertType)
        goto Ret;

    if(NULL== (hUserDS = AEOpenUserDSStore(pAE_General_Info, CERT_STORE_READONLY_FLAG)))
        goto Ret;

    pCertType = NULL;
    while(pCertCurrent = CertEnumCertificatesInStore(hUserDS, pCertCurrent))
    {
        //only interested in certificate with template information
        if(AERetrieveTemplateInfo(pCertCurrent, &AETemplateInfo))
        {
            if(pCertType=AEFindTemplateInRequestTree(
                            &AETemplateInfo, pAE_General_Info))
            {
                //if we are not supposed to check for UserDS store, only search
                //for template with ACTIVE status
                if(0 == (AUTO_ENROLLMENT_ENABLE_MY_STORE_MANAGEMENT & (pAE_General_Info->dwPolicy)))
                {
                    if(!(pCertType->fCheckMyStore))
                        goto Next;
                }

                //make sure the version of the certificate template is up to date
                //we do not have version for V1 template
                if(AETemplateInfo.pwszOid)
                {
                    if(AETemplateInfo.dwVersion < pCertType->dwVersion)
                    {
                        AECertInfo.fValid=FALSE;
                        AECertInfo.fRenewal=FALSE;
                        fNeedToValidate=FALSE;
                    }
                }
                
                if(fNeedToValidate)
                {
                    //check if we need to enroll/renewal for the certificate
                    AEValidateCertificateInfo(pAE_General_Info, 
                                            pCertType,
                                            FALSE,               //does not valid private key
                                            pCertCurrent, 
                                            &AECertInfo);
                }

                //we only interested in any valid certificate
                if(AECertInfo.fValid)
                {
                    if((CT_FLAG_AUTO_ENROLLMENT_CHECK_USER_DS_CERTIFICATE & (pCertType->dwEnrollmentFlag)) &&
                        (CERT_REQUEST_STATUS_OBTAINED != pCertType->dwStatus))
                    {
                        //mark the status as obtained. 
                        pCertType->dwStatus = CERT_REQUEST_STATUS_OBTAINED;
                    }

                    CertAddCertificateContextToStore(
                            pCertType->hObtainedStore,
                            pCertCurrent,
                            CERT_STORE_ADD_USE_EXISTING,
                            NULL);

                }
                else
                {
                    //copy the certificate to the Archive certificate store
                    CertAddCertificateContextToStore(
                            pCertType->hArchiveStore,
                            pCertCurrent,
                            CERT_STORE_ADD_USE_EXISTING,
                            NULL);
                }
            }
        }

Next:
        memset(&AECertInfo, 0, sizeof(AE_CERT_INFO));
        AEFreeTemplateInfo(&AETemplateInfo);
        fNeedToValidate=TRUE;
    }
Ret:
    
    if(hUserDS)
        CertCloseStore(hUserDS, 0);

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AECheckPendingRequests
//
//      If we have pending update-to-date certificate requests, no need
//  to enroll/renew for duplicates.
//-----------------------------------------------------------------------
BOOL    AECheckPendingRequests(AE_GENERAL_INFO *pAE_General_Info)
{
    DWORD                   dwIndex=0;
    DWORD                   dwVersion=0;
    AE_CERTTYPE_INFO        *pCertType=NULL;
    BOOL                    fValid=FALSE;
    DWORD                   dwCount=0;
    DWORD                   dwMax=PENDING_ALLOC_SIZE;
    PFNPIEnroll4GetNoCOM    pfnPIEnroll4GetNoCOM=NULL;
    FILETIME                ftTime;
    LARGE_INTEGER           ftRequestTime;
    AE_TEMPLATE_INFO        AETemplateInfo;

    IEnroll4                *pIEnroll4=NULL;
    CRYPT_DATA_BLOB         *rgblobHash=NULL;
    CRYPT_DATA_BLOB         blobName;

    //init before any goto Ret
    memset(&blobName, 0, sizeof(blobName));
    memset(&AETemplateInfo, 0, sizeof(AETemplateInfo));

    if(NULL==pAE_General_Info->hXenroll)
        goto Ret;

    if(NULL==(pfnPIEnroll4GetNoCOM=(PFNPIEnroll4GetNoCOM)GetProcAddress(
                        pAE_General_Info->hXenroll,
                        "PIEnroll4GetNoCOM")))
        goto Ret;

    if(NULL==(pIEnroll4=pfnPIEnroll4GetNoCOM()))
        goto Ret;

    GetSystemTimeAsFileTime(&ftTime);

    if(pAE_General_Info->fMachine)
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_LOCAL_MACHINE))
            goto Ret;
    }
    else
    {
        if(S_OK != pIEnroll4->put_RequestStoreFlags(CERT_SYSTEM_STORE_CURRENT_USER))
            goto Ret;
    }

    //enumerate all the pending requests

    rgblobHash=(CRYPT_DATA_BLOB *)LocalAlloc(LPTR, dwMax * sizeof(CRYPT_DATA_BLOB));
    if(NULL==rgblobHash)
        goto Ret;

    memset(rgblobHash, 0, dwMax * sizeof(CRYPT_DATA_BLOB));

    //initialize the enumerator
    if(S_OK != pIEnroll4->enumPendingRequestWStr(XEPR_ENUM_FIRST, 0, NULL))
        goto Ret;

    while(AEGetPendingRequestProperty(
                    pIEnroll4,
                    dwIndex,
                    XEPR_DATE,
                    &ftRequestTime))
    {
        ftRequestTime.QuadPart += Int32x32To64(FILETIME_TICKS_PER_SECOND, 
                                    AE_PENDING_REQUEST_ACTIVE_PERIOD * 24 * 3600);

        //remove the request if out of date
        if(0 <= CompareFileTime(&ftTime, (LPFILETIME)&ftRequestTime))
        {
            AERetrieveRequestProperty(pIEnroll4, dwIndex, &dwCount, &dwMax, &rgblobHash);
        }
        else
        {
            //get the version and the template name of the request
            if(AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_V2TEMPLATEOID, &blobName))
            {
                //this is a V2 template
                if(!AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_VERSION, &dwVersion))
                    goto Next;

                AETemplateInfo.pwszOid=(LPWSTR)blobName.pbData;

            }
            else
            {
                if(!AEGetPendingRequestProperty(pIEnroll4, dwIndex, XEPR_V1TEMPLATENAME, &blobName))
                    goto Next;

                AETemplateInfo.pwszName=(LPWSTR)blobName.pbData;
            }

            //find the template
            if(NULL==(pCertType=AEFindTemplateInRequestTree(
                            &AETemplateInfo, pAE_General_Info)))
                goto Next;

            if(AETemplateInfo.pwszName)
                fValid=TRUE;
            else
            {
                if(dwVersion >= pCertType->dwVersion)
                    fValid=TRUE;
            }

            if(fValid)
            {
                //this is a valid pending request 
                if(CERT_REQUEST_STATUS_OBTAINED != pCertType->dwStatus)
                    pCertType->dwStatus=CERT_REQUEST_STATUS_PENDING;
            }
            else
            {
                if(CERT_REQUEST_STATUS_OBTAINED == pCertType->dwStatus)
                    AERetrieveRequestProperty(pIEnroll4, dwIndex, &dwCount, &dwMax, &rgblobHash);
            }
        }

Next:
        
        if(blobName.pbData)
            LocalFree(blobName.pbData);
        memset(&blobName, 0, sizeof(blobName));

        memset(&AETemplateInfo, 0, sizeof(AETemplateInfo));

        fValid=FALSE;
        dwVersion=0;

        dwIndex++;
    }

    //remove the requests based the hash
    if(dwCount)
    {
        AERemovePendingRequest(pIEnroll4, dwCount, rgblobHash);
        AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_PENDING_INVALID, pAE_General_Info->fMachine, pAE_General_Info->hToken, 0);
    }

Ret:

    AEFreePendingRequests(dwCount, rgblobHash);

    if(blobName.pbData)
        LocalFree(blobName.pbData);

    if(pIEnroll4)
        pIEnroll4->Release();

    return TRUE;
}

//-----------------------------------------------------------------------
//
//  AECheckSupersedeRequest
//
//-----------------------------------------------------------------------
BOOL AECheckSupersedeRequest(DWORD              dwCurIndex,
                             AE_CERTTYPE_INFO   *pCurCertType, 
                             AE_CERTTYPE_INFO   *pSupersedingCertType, 
                             AE_GENERAL_INFO    *pAE_General_Info)
{
    BOOL                fFound=FALSE;

    LPWSTR              *awszSuperseding=NULL; 

    if(S_OK == CAGetCertTypePropertyEx(
                 pSupersedingCertType->hCertType, 
                 CERTTYPE_PROP_SUPERSEDE,
                 &(awszSuperseding)))
    {
        if(awszSuperseding && awszSuperseding[0])
        {
            if(AEIfSupersede(pCurCertType->awszName[0], awszSuperseding, pAE_General_Info))
            {
                switch(pCurCertType->dwStatus)
                {
                    case CERT_REQUEST_STATUS_ACTIVE:
                    case CERT_REQUEST_STATUS_SUPERSEDE_ACTIVE:
                            //remove the active status if it is superseded by an obtained certificate
                            if(CERT_REQUEST_STATUS_OBTAINED != pSupersedingCertType->dwStatus) 
                            {
                                pCurCertType->dwStatus = CERT_REQUEST_STATUS_SUPERSEDE_ACTIVE;
                                pSupersedingCertType->prgActive[pSupersedingCertType->dwActive]=dwCurIndex;
                                (pSupersedingCertType->dwActive)++;

                            }
                            else
                            {
                                pCurCertType->dwStatus = 0;
                            }

                    case CERT_REQUEST_STATUS_PENDING:
                                AECopyCertStore(pCurCertType->hArchiveStore,
                                                pSupersedingCertType->hArchiveStore);

                        break;

                    case CERT_REQUEST_STATUS_OBTAINED:

                                AECopyCertStore(pCurCertType->hObtainedStore,
                                                pSupersedingCertType->hArchiveStore);

                        break;

                   default:
								AECopyCertStore(pCurCertType->hArchiveStore,
                                                pSupersedingCertType->hArchiveStore);

                        break;    
                }

                //we consider that we find a valid superseding template only if the status
                //is obtained.  If the status is anyting else, we need to keep searching since
                //enrollment/renewal requests might not be granted
                if(CERT_REQUEST_STATUS_OBTAINED == pSupersedingCertType->dwStatus)
                    fFound=TRUE;
            }

            //clear the visited flag in AE_General_Info
            AEClearVistedFlag(pAE_General_Info);
        }

        //free the property
        if(awszSuperseding)
            CAFreeCertTypeProperty(
                pSupersedingCertType->hCertType,
                awszSuperseding);

        awszSuperseding=NULL;
    }

    return fFound;
}

//-----------------------------------------------------------------------
//
//  AEIsCALonger
//
//      For renewal, the CA's certificate has to live longer than the 
//  renewing certificate    
//  
//-----------------------------------------------------------------------
BOOL    AEIsCALonger(HCAINFO    hCAInfo, PCERT_CONTEXT  pOldCert)
{
    BOOL            fCALonger=TRUE;

    PCCERT_CONTEXT  pCACert=NULL;

    //we assume the CA is good unless we found something wrong
    if((NULL == hCAInfo) || (NULL == pOldCert))
        goto Ret;

    if(S_OK != CAGetCACertificate(hCAInfo, &pCACert))
        goto Ret;

    if(NULL == pCACert)
        goto Ret;

    //CA cert's NotAfter should be longer than the issued certificate' NotAfger
    if(1 == CompareFileTime(&(pCACert->pCertInfo->NotAfter), &(pOldCert->pCertInfo->NotAfter)))
        goto Ret;

    fCALonger=FALSE;

Ret:

    if(pCACert)
        CertFreeCertificateContext(pCACert);

    return fCALonger;
}


//-----------------------------------------------------------------------
//
//  AECanFindCAForCertType
//
//      Check if there exists a CA that can issue the specified certificate 
//  template.    
//  
//-----------------------------------------------------------------------
BOOL    AECanFindCAForCertType(AE_GENERAL_INFO   *pAE_General_Info, AE_CERTTYPE_INFO *pCertType)
{
    DWORD           dwIndex=0;
    BOOL            fFound=FALSE;
    AE_CA_INFO      *prgCAInfo=pAE_General_Info->rgCAInfo;
    BOOL            fRenewal=FALSE;


    //detect if we are performing an enrollment or renewal
    if((pCertType->fRenewal) && (pCertType->pOldCert))
    {
        if((pCertType->fNeedRA) && (pCertType->fCrossRA))
            fRenewal=FALSE;
        else
            fRenewal=TRUE;
    }
    else
        fRenewal=FALSE;

    if(prgCAInfo)
    {
        for(dwIndex=0; dwIndex < pAE_General_Info->dwCA; dwIndex++)
        {
            //make sure the CA supports the specific template
            if(AEIsAnElement((pCertType->awszName)[0], 
                              (prgCAInfo[dwIndex]).awszCertificateTemplate))
            {
                if(FALSE == fRenewal)
                {
                    fFound=TRUE;
                    break;
                }
                else
                {
                    if(AEIsCALonger(prgCAInfo[dwIndex].hCAInfo, pCertType->pOldCert))
                    {
                        fFound=TRUE;
                        break;
                    }
                }
            }
        }
    }

    return fFound;
}

//-----------------------------------------------------------------------
//
//  AEManageActiveTemplates
//      
//      We make sure that for all active templates, we can in deed enroll
//  for it.
//
//-----------------------------------------------------------------------
BOOL    AEManageActiveTemplates(AE_GENERAL_INFO   *pAE_General_Info)
{
    DWORD               dwIndex=0;
    AE_CERTTYPE_INFO    *pCertTypeInfo=pAE_General_Info->rgCertTypeInfo;
    AE_CERTTYPE_INFO    *pCurCertType=NULL;
    BOOL                fCanEnrollCertType=FALSE;
	BOOL				fUserProtection=FALSE;
	DWORD				dwEventID=0;

    if(pCertTypeInfo)
    {
        for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
        {
            pCurCertType = &(pCertTypeInfo[dwIndex]);

            fCanEnrollCertType=FALSE;
			fUserProtection=FALSE;

            if(CERT_REQUEST_STATUS_PENDING == pCurCertType->dwStatus)
            {
                //check if UI is required
                if(CT_FLAG_USER_INTERACTION_REQUIRED & (pCurCertType->dwEnrollmentFlag))
                {
                    pCurCertType->fUIActive=TRUE;

                    if(pAE_General_Info->fMachine)
                    {
                        pCurCertType->dwStatus = 0;

                        //log that user does not have access right to the template
                        AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_NO_ACCESS_ACRS_OBJECT,                              
                            pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, (pCurCertType->awszDisplay)[0]);
                    }
                }

                continue;
            }


            if(CERT_REQUEST_STATUS_ACTIVE != pCurCertType->dwStatus)
                continue;

			//check for V1 smart card User or smart card logon certificate template
			if((0 == _wcsicmp(wszCERTTYPE_SMARTCARD_USER, (pCurCertType->awszName)[0])) || 
			   (0 == _wcsicmp(wszCERTTYPE_USER_SMARTCARD_LOGON,(pCurCertType->awszName)[0]))
			  )
			{
                pCurCertType->dwStatus = 0;

                //log that user does not have access right to the template
                AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_NO_V1_SCARD,                              
                    pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, (pCurCertType->awszDisplay)[0]);

				continue;
			}

			//check if CRYPT_USER_PROTECTED is used for machine certificate template
			if(CT_FLAG_STRONG_KEY_PROTECTION_REQUIRED & pCurCertType->dwPrivateKeyFlag)
			{
                if(pAE_General_Info->fMachine)
                {
                    pCurCertType->dwStatus = 0;

                    //log that machine template should not require user password
                    AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_NO_USER_PROTECTION_FOR_MACHINE,                              
                        pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, (pCurCertType->awszDisplay)[0]);

					continue;
                }
				else
				{
					if(0 == (CT_FLAG_USER_INTERACTION_REQUIRED & (pCurCertType->dwEnrollmentFlag)))
					{
						pCurCertType->dwStatus = 0;

						//log that user interaction is not set
						AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_NO_USER_INTERACTION,                              
							pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, (pCurCertType->awszDisplay)[0]);

						continue;
					}
				}
			}

            fCanEnrollCertType=AECanEnrollCertType(pAE_General_Info->hToken, pCurCertType, pAE_General_Info, &fUserProtection);

            if((!fCanEnrollCertType) ||
               (!AECanFindCAForCertType(pAE_General_Info, pCurCertType))
              )
            {
                pCurCertType->dwStatus = 0;

                //log that user does not have access right to the template
				if(FALSE == fUserProtection)
				{
					dwEventID=EVENT_NO_ACCESS_ACRS_OBJECT;
				}
				else
				{
					if(pAE_General_Info->fMachine)
						dwEventID=EVENT_NO_USER_PROTECTION_FOR_MACHINE_RA;
					else
						dwEventID=EVENT_NO_USER_INTERACTION_RA;
				}

				AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, dwEventID,                              
						pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, (pCurCertType->awszDisplay)[0]);
            }
            else
            {
                //check if UI is required
                if(CT_FLAG_USER_INTERACTION_REQUIRED & (pCurCertType->dwEnrollmentFlag))
                {
                    pCurCertType->fUIActive=TRUE;

                    if(pAE_General_Info->fMachine)
                    {
                        pCurCertType->dwStatus = 0;

                        //log that user does not have access right to the template
                        AELogAutoEnrollmentEvent(pAE_General_Info->dwLogLevel, FALSE, S_OK, EVENT_NO_ACCESS_ACRS_OBJECT,                              
                            pAE_General_Info->fMachine, pAE_General_Info->hToken, 1, (pCurCertType->awszDisplay)[0]);
                    }
                }

            }
        }

    }

    return TRUE;
}        
//-----------------------------------------------------------------------
//
//  AEManageSupersedeRequests
//      remove duplicated requests based on "Supersede" relationship
//
//
//-----------------------------------------------------------------------
BOOL    AEManageSupersedeRequests(AE_GENERAL_INFO   *pAE_General_Info)
{
    DWORD               dwIndex=0;
    DWORD               dwSuperseding=0;
    DWORD               dwOrder=0;
    AE_CERTTYPE_INFO    *pCertTypeInfo=pAE_General_Info->rgCertTypeInfo;
    AE_CERTTYPE_INFO    *pCurCertType=NULL;
    AE_CERTTYPE_INFO    *pSupersedingCertType=NULL;
    BOOL                fFound=FALSE;

    if(pCertTypeInfo)
    {
        for(dwIndex=0; dwIndex < pAE_General_Info->dwCertType; dwIndex++)
        {
            pCurCertType = &(pCertTypeInfo[dwIndex]);

            //we only consider templates with valid status
           if((0 == pCurCertType->dwStatus) && (TRUE == AEIsEmptyStore(pCurCertType->hArchiveStore)))
                continue;

            fFound=FALSE;

            for(dwOrder=0; dwOrder < g_dwSupersedeOrder; dwOrder++)
            {
                for(dwSuperseding=0; dwSuperseding < pAE_General_Info->dwCertType; dwSuperseding++)
                {
                    //one can not be superseded by itself
                    if(dwIndex == dwSuperseding)
                        continue;

                    pSupersedingCertType = &(pCertTypeInfo[dwSuperseding]);

                    //we consider templates with obtained status first
                    if(g_rgdwSupersedeOrder[dwOrder] != pSupersedingCertType->dwStatus)
                        continue;

                    fFound = AECheckSupersedeRequest(dwIndex, pCurCertType, pSupersedingCertType, pAE_